<?xml version="1.0"?>
<!DOCTYPE HTML PUBLIC "~//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta charset="UTF-8">

<!--
// help file for ESP and OpenCSM
// written by John Dannenhoffer
-->

<html>
  <head>
    <title>ESP User's Manual</title>

    <style type="text/css">
      body {font-size: 12pt;}
    </style>
  </head>

  <body>
    <p><h1 align=center>Engineering Sketch Pad (ESP) Version 1.21</h1>
    <p><h3>Authors: John F. Dannenhoffer, III (Syracuse University) and Bob Haimes (MIT)</h3>
    <p><h3>Date: July 2022.</h3>

    <p><h3 align=center><img src="esp_logo.png" width="400"/></h3>

    <p><h2 id="sec0">0.0 Table of Contents</h2>
    <p><a href="#sec1">1.0 Overview</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec1.1">1.1 Gallery of cases</a>
    <p><a href="#sec2">2.0 Tutorials</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.1">2.1 First tutorial: <code>ESP</code> user interface</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.2">2.2 Second tutorial: Base <code>ESP</code> model</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.3">2.3 Third tutorial: Using the sketcher and adding spokes</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.4">2.4 Fourth tutorial: RULEs, BLENDs, and error checking</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.5">2.5 Fifth tutorial: Multi-models </a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.6">2.6 Sixth tutorial: Integrated Design Environment </a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.7">2.7 First legacy tutorial: Basic usage</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.8">2.8 Second legacy tutorial: Sketcher</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.9">2.9 Third legacy tutorial: Aircraft example</a>
    <p><a href="#sec3">3.0 Command Line</a>
    <p><a href="#sec4">4.0 Interactive Options</a>
    <p><a href="#sec5">5.0 Format of the <code>.csm</code> and <code>.udc</code> Files</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.1">5.1 Format of the <code>.csm</code> file</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.2">5.2 Format of the <code>.udc</code> file</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.3">5.3 Special characters</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.4">5.4 Valid CSM statements</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.5">5.5 User-defined Primitives/Functions shipped with OpenCSM</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.6">5.6 User-defined Components shipped with OpenCSM</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.7">5.7 Number rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.8">5.8 String rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.9">5.9 Parameter rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.10">5.10 Expression rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.11">5.11 Attribute rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.12">5.12 Format of the plotfile</a>
    <p><a href="#sec6">6.0 Example <code>.csm</code> file</a>
    <p><a href="#sec7">7.0 Frequently Asked Questions</a>
    <p><a href="#sec8">8.0 Release notes</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.1">8.1 New/extended features in v1.21</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.2">8.2 Bug fixes since v1.20</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.3">8.3 New/extended features in v1.20</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.4">8.4 Bug fixes since v1.19</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.5">8.5 New/extended features in v1.19</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.6">8.6 Bug fixes since v1.18</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.7">8.7 New/extended features in v1.18</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.8">8.8 Bug fixes since v1.17</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.9">8.9 New/extended features in v1.17</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.10">8.10 Bug fixes since v1.16</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.11">8.11 New/extended features in v1.16</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.12">8.12 Bug fixes since v1.15</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.13">8.13 New/extended features in v1.15</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.14">8.14 Bug fixes since v1.14</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.15">8.15 New/extended features in v1.14</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.16">8.16 Bug fixes since v1.13</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.17">8.17 New/extended features in v1.13</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.18">8.18 Bug fixes since v1.12</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.19">8.19 New/extended features in v1.12</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.20">8.20 Bug fixes since v1.11</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.21">8.21 New/extended features in v1.11</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.22">8.22 Bug fixes since v1.10</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.23">8.23 New/extended features in v1.10</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.24">8.24 Bug fixes since v1.09</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.25">8.25 New/extended features in v1.09</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.26">8.26 Bug fixes since v1.08</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.27">8.27 New/extended features in v1.08</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.28">8.28 Bug fixes since v1.07</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.29">8.29 New/extended features in v1.07</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.30">8.30 Bug fixes since v1.06</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.31">8.31 New/extended features in v1.06</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.32">8.32 Bug fixes since v1.05</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.33">8.33 Known problems in v1.09</a>
    <p><a href="#sec9">9.0 Error Codes</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec9.1">9.1 OpenCSM error codes</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec9.2">9.2 EGADS error codes</a>
    <p><a href="#sec10">10.0 Bug Reports and Other Feedback</a>
    <p><a href="#sec11">11.0 Copyright</a>
    <p><a href="#sec12">12.0 Glossary</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec1">1.0: Overview</h2>

    <p>The Engineering Sketch Pad (<code>ESP</code>) is a
       browser-based program for creating, editing, and generating
       constructive solid models for use in the multi-disciplinary
       analysis and optimization of engineered systems.  It is built
       using a client-server architecture.

    <p>The server consists of a back-end program
       (<code>serveESP</code>) that performs the majority of the
       computational work; the server has been designed to work on a
       variety of compute platforms, including UNIX, LINUX, OSX, and
       Windows.  As will be described below, the user
       of <code>ESP</code> typically starts a session by starting the
       server.

    <p>The client, which is built within a web browser, provides the
       graphical user interface with which most users will provide
       inputs and receive outputs.  The supported browsers include
       recent versions of FireFox, Google Chrome, Safari, and Edge.
       (Internet Explorer is not supported because of a bug within the
       WebSockets layer provided by the browser).

    <p><code>ESP</code> is technically just the user-interface to a
      system of software packages, including:
      <ul>
        <li><code>WebViewer</code> is a package for generating complex
            three-dimensional representations of geometry within a web
            Browser.  It consists of software that is incorporated
            into the server as well as a series of JavaScript
            functions that operate in the web Browser via
            <code>WebGL</code>.</li>
        <li><code>OpenCSM</code> is a feature-based, associative,
            parametric solid modeler that supports manifold solids
            (the typical output) and non-manifold sheets and wires
            (such as may be needed for representing wake sheets and
            antennae).  The inputs to <code>OpenCSM</code> is an
            ASCII, human-readable <code>.csm</code> file, in which
            the model is described by a series of design Parameters
            and a Feature Tree (or build prescription).  The Feature
            Tree consists of a user-specified series of standard
            primitives, Boolean operators, and transformations.
            <code>OpenCSM</code> also includes the ability for users
            to define their own user-defined primitives (via compiled
            code) and user-defined components (via scripts).  The
            persistence of Attributes, even through regenerations,
            directly supports the use of <code>OpenCSM</code> within
            multi-fidelity and multi-disciplinary analysis and
            design. <code>OpenCSM</code> also provides the ability for
            a user to compute the geometric sensitivity of a
            configuration with respect to (any combination of) the
            design Parameters, often without regeneration; these
            sensitivities can then be used by a grid-generator so that
            the sensitivity of the grid with respect to the design
            Parameters can be computed.</li>
        <li><code>EGADS</code>, the Electronic Geometry Aircraft
            Design System, is an open-source geometry interface
            to <code>OpenCASCADE</code>, in which the functionality
            in <code>OpenCASCADE</code> that is needed for
            construction of typical applications is incorporated into
            about 70 C-functions.  These functions support a "bottom
            up" approach to configuration construction, in which the
            boundary representation (BRep) is built up from nodes, to
            curves, to edges, to loops, to surfaces, to faces, to
            shells, to bodies.  <code>EGADS</code> also supports a
            "top-down" approach, which directly maps
            to <code>OpenCSM</code>'s Feature
            Tree.  <code>EGADS</code> provides persistent user-defined
            Attributes on all topological entities.</li>
        <li><code>OpenCASCADE</code> is a large, openly-available
            geometry engine on which the rest of the system is
            built.  <code>OpenCASCADE</code> is the only part of
            the <code>ESP</code> system that needs to be acquired from
            an outside source.  See the <code>README.txt</code> file
            associated with the <code>ESP</code> distribution for
            details.</li>
      </ul>

    <p>All the parts of the <code>ESP</code> system are distributed as
       source code that is licensed via the LGPL 2.1 license.  See
       the <a href="#sec11">Copyright</a> section below for details.

    <p>In most cases, a user will start with a configuration that is
       described in a <code>.csm</code> file and then modify it and/or
       build it via <code>OpenCSM</code>'s various commands.

    <p>For a convenient Quick Reference,
       see <code>$ESP_ROOT/doc/ESP_QuickReference.pdf</code>, which is
       a two-page summary of the various <code>.csm</code> commands,
       built-in functions, dot-suffixes, and the <code>ESP</code>
       character set.

    <p><h3 id="sec1.1">1.1 Gallery of cases</h3>

    <p><code>ESP</code> ships with a assortment of
       <code>.csm</code> files, as shown below. Feel free to open them
       in your favorite text editor to see how they were constructed.

       <h4>CanardFighter.csm</h4>
       <img src="pictures/gallery/CanardFighter.png" width="100%"/>

       <h4>Cobra.csm</h4>
       <img src="pictures/gallery/Cobra.png" width="100%"/>

       <h4>Dragon.csm</h4>
       <img src="pictures/gallery/Dragon.png" width="100%"/>

       <h4>Hypersonic.csm</h4>
       <img src="pictures/gallery/Hypersonic.png" width="100%"/>

       <h4>JMR3.csm</h4>
       <img src="pictures/gallery/JMR3.png" width="100%"/>

       <h4>Lander.csm</h4>
       <img src="pictures/gallery/Lander.png" width="100%"/>

       <h4>OrionLEV.csm</h4>
       <img src="pictures/gallery/OrionLEV.png" width="100%"/>

       <h4>RM-10.csm</h4>
       <img src="pictures/gallery/RM-10.png" width="100%"/>

       <h4>Xwing.csm</h4>
       <img src="pictures/gallery/Xwing.png" width="100%"/>

    <p>In addition, several students have created models of a variety
       of configurations.  The <code>.csm</code> files for these cases
       are not included in the distribution since they have not been
       cleaned up; nevertheless, the models are very impressive.

      <h4>A12</h4>
      <img src="pictures/studentGallery/A12.png" width="100%"/>

      <h4>BulletTrain</h4>
      <img src="pictures/studentGallery/BulletTrain.png" width="100%"/>

      <h4>Cessna162</h4>
      <img src="pictures/studentGallery/Cessna162.png" width="100%"/>

      <h4>F104</h4>
      <img src="pictures/studentGallery/f104.png" width="100%"/>

      <h4>F117</h4>
      <img src="pictures/studentGallery/F117.png" width="100%"/>

      <h4>GenericFighter</h4>
      <img src="pictures/studentGallery/GenericFighter.png" width="100%"/>

      <h4>LunarLander_11</h4>
      <img src="pictures/studentGallery/LunarLander_11.png" width="100%"/>

      <h4>PittsSpecial</h4>
      <img src="pictures/studentGallery/PittsSpecial.png" width="100%"/>

      <h4>Sub03</h4>
      <img src="pictures/studentGallery/sub03.png" width="100%"/>

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec2">2.0: Tutorials</h2>

    <p>There are six (new) Tutorials that will help you get
       acquainted with the Engineering Sketch Pad (<code>ESP</code>).
       The first uses a fairly sophisticated multi-model to help you
       get familiar with the <code>ESP</code> browser-based graphical
       user interface (GUI).  Then in Tutorials 2 through 5, the
       configuration that was used in Tutorial 1 will be built up,
       step by step.

    <p>These Tutorials cover many of <code>ESP</code>'s features, but
       not all of them.  They follow current <code>ESP</code> best
       practices, in which a configuration is built by using a
       scripting language; most users find this mode of using
       <code>ESP</code> to be more flexible and faster than the
       GUI-based mode used by traditional CAD systems.  But, if you
       favor the traditional CAD system look-and-feel, check out the
       legacy Tutorials (starting with <a href="#sec2.7">First legacy
       tutorial: Basic usage</a>)

    <p>For a more extensive introduction to <code>ESP</code>, see
       the <code>ESP</code> training slides (which are available
       at <code>acdl.mit.edu/ESP/ESPtraining2021.tgz</code>).  In
       addition, detailed descriptions of all commands are included
       later in this help document <a href="#sec5.4">Valid CSM
       statements</a>.

    <p>Before we begin, a few notes:
      <ul>
        <li>words that are capitalized generally refer to a specific
            term within the <code>ESP</code> system; multi-word terms
            are often given in camel-case, such as MessageWindow;</li>
        <li>words in <b>boldface type</b> refer to button labels or
            links in the interface that you would press by clicking on
            it with the left mouse button;</li>
        <li>words in <i>italics type</i> are the definitions of terms,
            etc.;</li>
        <li>names of the various <code>ESP</code> Commands are
            shown <code>UPPERCASE</code>; and</li>
        <li>words that you type are typically given in a
            <code>typeface like this</code>.</li>
      </ul>

    <p><h3 id="sec2.1">2.1 First Tutorial: <code>ESP</code> user interface</h3>

    <p>This first Tutorial is designed to help you get familiar with
       the <code>ESP</code> browser-based user interface.

    <p><h4>Starting <code>ESP</code></h4>

    <p>There are two main ways of starting <code>ESP</code>.

    <p><i>Technique 1.</i> Click the <b>ESP121</b> icon on your
       desktop.  This will open up a terminal window in which all the
       environment variables needed to run <code>ESP</code> are
       defined.  After the window opens, you can issue a command such
       as:
       <pre>
         serveESP [options] [filename[.csm]]
       </pre>
       where <code>[options]</code> is a list of one or more
       command-line options, and <code>filename</code> (with or
       without the <code>.csm</code> extension) is the (optional)
       model file.  The <code>[options]</code> gives you ability to do
       things such as building the model in batch mode (i.e., no user
       interface) with the <code>-batch</code> option, or changing the
       port number used by the server with the <code>-port</code>
       option.  Try <code>-help</code> to get a full list of the
       available <code>[options]</code>.

    <p>To start the first Tutorial, simply enter:
      <pre>
        serveESP ../data/tutorial1    (on MAC or LINUX)
      </pre>
      or
      <pre>
        serveESP ..\data\tutorial1     (on Windows)
      </pre>

    <p>After serveESP builds the configuration, it will automatically
       open up a browser containing the <code>ESP</code> user
       interface.  When <code>ESP</code> starts, it may first ask you
       for the hostname and port associated with the server (which was
       started when you typed serveESP).

    <p><img src="pictures/tutorial1-01.png" width="100%"/>

    <p>Most often you will choose the default
       <code>Localhost:7681</code>.  Note that a new feature
       in <code>ESP121</code> allows more than one user to attach to the
       same session, allowing them to work collaboratively on the same
       model at the same time.  This new collaboration feature is not
       explicitly covered in these Tutorials.

    <p><i>Technique 2.</i> Click the <b>runESP121</b> icon on your
       desktop, which will open up (in the background) a terminal
       window and then a browser containing the <code>ESP</code> user
       interface.  The first thing it may ask you for is the hostname
       and port associated with the server (that is actually running
       in the terminal window), as shown above. Most often you will
       choose the default <code>Localhost:7681</code>.  Note that a
       new feature in <code>ESP</code> allows more than one user to
       attach to the same session, allowing them to work
       collaboratively on the same model at the same time.  This new
       collaboration feature is not explicitly covered in these
       Tutorials.

    <p>When <code>ESP</code> starts using technique 2, it will not
       contain a model. You will have to manually load the model by
       pressing the <b>File</b> button (near the top left) and then choosing
       <b>Open</b>.  You will be asked for the name of the file, at
       which time you should answer:
      <pre>
        ../data/tutorial1      (on MAC or Linux)
      </pre>
      or
      <pre>
        ..\data\tutorial1      (in Windows)
      </pre>

    <p><img src="pictures/tutorial1-02.png" width="100%"/>

    <p><h4>Organization of the browser window</h4>

    <p>After you have chosen either technique 1 or 2, it is time to
       explore the <code>ESP</code> user interface.  You will see that
       the window is broken into four frames:

    <p><img src="pictures/tutorial1-03.png" width="100%"/>

      <ul>
        <li>The <i>TreeWindow</i> is on the top left, and it contains
            most of the controls that you will be using
            in <code>ESP</code>.  It contains command buttons and a
            tree-like structure that allows you to add/edit/examine
            the DesignParameters, examine the LocalVariables,
            add/edit/examine/delete the Branches in the FeatureTree,
            and control the visibility of the Display.  A full
            description of the TreeWindow in contained below;</li>
        <li>The <i>GraphicsWindow</i> is on the top right, and it can
            display a variety of items.  This window is used mostly to
            display a 3D rendition of the current model.  When you are
            creating a sketch (described in Tutorial 3), the sketch
            will be displayed in the GraphicsWindow.  Also, the
            GraphicsWindow is used from time to time to post a form
            when you are adding/editing/examining a DesignParameter,
            LocalVariable, or Branch;</li>
        <li>The <i>KeyWindow</i> is on the bottom left, and it
            most-often contains the <code>ESP</code> logo.  Other uses
            for the KeyWindow is for textual status (such as when you
            are using the sketcher) or an annotated spectrum (when you
            are showing sensitivities); and</li>
        <li>The <i>MessageWindow</i> is on the bottom right and it
            contain status information and messages that can tell you
            what <code>ESP</code> is doing.  The background color of
            the MessageWindow can be:
          <ul>
            <li><i>off-white</i>, which is the normal backbround;</li>
            <li><i>yellow</i>, which means that an error has been
                encountered.  If you see this, double-clicking in the
                MessageWindow should open up a code editor (described
                below) and take you to the offending line; and</li>
            <li><i>pink</i>, which means that the server has crashed.
                If you see this, please report the error to
                the <code>ESP</code> authors so that the bug can be
                fixed.</li>
          </ul>
      </ul>

    <p><h4>Manipulating the 3D image in the GraphicsWindow</h4>

    <p>The first thing to do is to play with the image in the
       GraphicsWindow.  This is done with the mouse in the following
       ways:
      <ul>
        <li><i>Drag</i>: translate the graphical image;</li>
        <li><i>Shift-Drag</i>: moving mouse up while dragging zooms in
            while moving the mouse down while dragging zooms out.
            Note that the mouse wheel can also be used to zoom in and
            out;</li>
        <li><i>Ctrl-Drag</i>: rotate the object about its center (see
            below for more details); and</li>
        <li><i>Alt-Drag</i>: rotate the view about an axis that is
            perpendicular to the screen.  (Use <i>Option-Drag</i> on
            Mac OSX)</li>
      </ul>
      It is suggested that you use the left or middle mouse button for
      these operations, since many browsers steal right mouse actions
      and do something such as posting a popup menu.

    <p>When using the mouse, it is possible to
       enter <i>FlyingMode</i>, in which the view continually changes
       until the mouse button is released.  FlyingMode is particularly
       useful when one needs to translate a long distance.  Toggling
       FlyingMode is done by pressing the <b>!</b> key in the
       GraphicsWindow.

    <p>At any time, a user might want to save a view for later use in
       the browser session.  This is done by pressing the
       <b>&gt;</b> key in the GraphicsWindow; the
       saved view can be retrieved (multiple times) by pressing the
       <b>&lt;</b> key.

    <p>You can also save a view into a file (for use in a
       later <code>ESP</code> session) with the
       <b>&lt;Ctrl-&gt;&gt;</b> or <b>.</b> keys, which will prompt
       you for a filename.  You can read a view file with
       the <b>&lt;Ctrl-&lt;&gt;</b> or <b>,</b> keys, which will
       prompt you for the view filename.  If the file does not exist,
       nothing will happen.

    <p>The default (home) view can be obtained by pressing either
       the <b>&lt;Home&gt;</b> key or the <b>H</b> button near the top
       of the TreeWindow.  (The home view is one in which
       the <i>x</i>-coordinate increases from left to right and
       the <i>y</i>-coordinate increases from bottom to top.)  One can
       also get the top view by pressing the <b>T</b> button, the
       bottom view by pressing the <b>B</b> button, the left side view
       by pressing the <b>L</b> button, or the right side view by
       pressing the <b>R</b> button.

    <p>The function of the arrow keys on the keyboard depends on
       whether FlyingMode is active or not.  For example, if
       FlyingMode is not active (the default), pressing
       the <b>&lt;Left&gt;</b> key causes the object to rotate to the
       left by 30 degrees; if FlyingMode is active (because
       the <b>!</b> key was pressed), then pressing
       the <b>&lt;Left&gt;</b> key causes the object on the screen to
       translate to the left.  If the <b>Shift</b> is held while
       the <b>&lt;Left&gt;</b> key is pressed, the increments are 5
       degrees and the translations are also smaller.

    <p>The <b>&lt;PgUp&gt;</b> key or the <b>+</b> button can be used
       to zoom in and the <b>&lt;PgDn&gt;</b> key or the <b>-</b>
       button can be used to zoom out.  (Recall that the mouse wheel
       can also be used.)  The behavior of these keys/buttons does not
       depend on the current FlyingMode.

    <p>To re-center the image at a given point and simultaneously
       reset the point about which mouse rotations will occur, point
       to any object in the GraphicsWindow and press <b>*</b>
       or <b>8</b>; the image will be re-centered and a message will
       be posted in the MessageWindow.

    <p>To determine the identity of any object in the GraphicsWindow,
       simply put your cursor on the object and press <b>^</b>
       or <b>6</b>; a summary of the identified object is shown in the
       MessageWindow.  (Note that if the cursor is not exactly over
       any object, the message will only be posted once the mouse
       passes over a graphic object.)

    <p>To determine the approximate coordinates of any location in the
       GraphicsWindow, simply put your cursor on the location and
       press <b>@</b> or <b>2</b>; a little red square is placed at
       the location and the approximate coordinates of the location
       are shown in the MessageWindow.  Also posted is the distance
       from the previous query.  Note that the little red square is
       cleared if the distance from the previous query is zero (i.e.,
       the <b>@</b> or <b>2</b> option was selected twice at the same
       screen location).

    <p>To add an Attribute to any Face or Edge, simply put your cursor
       on the object in the GraphicsWindow and press <b>A</b> (upper
       case A). You will then be asked for the name of the new
       Attribute as well of its value, which can either be a string
       (if is starts with a $) or a semi-colon separated list of
       expressions.

    <p>Lastly, to get help on the commands that are available in the
       GraphicsWindow, press <b>?</b> and a short listing will be
       given in the MessageWindow.

    <p><h4>Changing how the model is displayed in the GraphicsWindow</h4>

    <p>Now let's look at the Display part of the TreeWindow.  By
       default, "Display" is expanded and you can see that you have
       Bodys named "SheetModel", "SolidModel", and "Spindle".  Expand
       the listing for "SolidModel" by pressing the <b>+</b> to the
       left of "SolidModel" and you will see entries for Faces, Edges,
       and Nodes.  To the right of "Faces" (below "SolidModel") you
       will see three items:
      <ul>
        <li><b>Viz</b>: toggles the visibility of all Faces associated
            with SolidModel;</li>
        <li><b>Grd</b>: toggles the internal tessellation grids
            associated with all the Faces in SolidModel; and</li>
        <li><b>Trn</b>: toggles the pseudo-transparency of all the
            Faces associated with SolidModel.</li>
      </ul>
      Try each of these and see what happens.

      In addition, you can also change the display characteristics
      with key-presses in the GraphicsWindow.  Hover over an entity
      and press:
      <ul>
        <li><b>v</b> to toggle the visibility (Note that if an entity
            is not visible, you will need to turn visibility on in the
            TreeWindow since there is nothing to point to when you
            want to turn it back on);</li>
        <li><b>g</b> to toggle the grid;</li>
        <li><b>t</b> to toggle the transparency; and</li>
        <li><b>o</b> to toggle the orientation (little arrows showing
            the directions of Edges).</li>
      </ul>

    <p>Notice also that there is a <b>+</b> to the left of "Faces",
       which indicates that you can interact with the object on a
       Face-by-Face basis.  The basic rules here are:
      <ul>
        <li>changes made to a specific entity (such as a Face or Edge)
            applies only to that entity;</li>
        <li>changes made to the heading (such as "Faces") applies to
            all Faces in the group; and</li>
        <li>changes made at the Body level applies to all Faces,
        Edges, and Nodes in the body.</li>
      </ul>

    <p>When you have a configuration with lots of Bodys, it is
       sometimes useful to alter the visibility of all Faces, Edges,
       or Nodes (in all Bodys).  This can be done by pressing on the
       word <b>Display</b> in the KeyWindow.

    <p>To see this working, press <b>Viz</b> to the right of
       "Display", which will turn everything off.  Pressing it again,
       will now turn everything on, including little black squares at
       every Node in all Bodys.  Sometimes this is useful, but other
       times it is annoying.  So pressing on <b>Display</b> will bring
       up a pop-up; if you now choose <code>-1</code> (hide all Nodes)
       and press <b>Enter</b>, the Nodes will be removed from the
       graphical image.

    <p><h4>The File menu (in the TreeWindow)</h4>

    <p>Now it is time to look at the buttons at the top of the
       TreeWindow.  The first one to look at is the <b>File</b>
       button, which posts a menu with the following options:
      <ul>
        <li><b>New</b> - this option removes the current model from
            memory (after asking if this is really what you want to
            do) and starts you off with an empty model;</li>
        <li><b>Open</b> - this option asks for the name of the model
            file to open; if you give it a name, it removes the
            current model from memory and loads the new model;</li>
        <li><b>Export Feature Tree</b> - this option creates a new
            model file by reading the current DesignParameters and the
            current FeatureTree (i.e., the Branches).  Note that this
            option does its best to format the resulting file
            appropriately, but it does not know about any formatting
            that you have done and does not know about any comments
            that you have written.  Therefore, the option should only
            be used if you have been editing the model file directly
            via the GUI;</li>
        <li><b>Edit: xxx</b> - this option allows you to edit (one of)
            the current model file(s). This is the option that you
            will be using extensively while you are developing your
            model in Tutorials 2 through 5; and</li>
        <li><b>Edit: &lt;new file&gt;</b> - this option allows you to
            edit a new model file.</li>
      </ul>

    <p><h4>The Tool menu (in the TreeWindow)</h4>

    <p>The second button on the top of the TreeWindow is
       the <b>Tool</b> button, which gives you access to the various
       tools within <code>ESP</code>.  In version 1.21, there are only
       five options here:
      <ul>
        <li><b>Sketch</b> - we will be using this in Tutorial 3;</li>
        <li><b>Caps</b> - this allows interactions
             with <code>CAPS</code>, which will be covered in Tutorial
             6; </li>
        <li><b>ErepEd</b> - this option allows you to define an
            effective topology, which is a way of collecting Faces
             into EFaces in order to facilitate mesh generation.  This
             will not be discussed further in these Tutorials.</li>
        <li><b>Plugs</b> - this option automatically updates a model's
             DesignParameters so as to least-square fit a cloud of
             points that are defined in a PlotFile.  This is not
             defined in further in this document; and</li>
        <li><b>Pyscript</b> - this option allows a user to run a
             Python script, which will be covered in Tutorial 6.
      </ul>
      It is anticipated that many more tools will be added to
      the <b>Tool</b> menu in future releases of <code>ESP</code>.

    <p><h4>Other buttons in the TreeWindow</h4>

      <p>The <b>StepThru</b> button allows you to view the steps used
         to build a model.  When you first press this button, the
         first Body created during the construction process is shown.
         The legend on the button changes to <b>NextStep</b>, which
         then gives you the option of seeing the next step in the
         build.  This button can be pressed repeatedly to see the
         whole build process. If you want to leave StepThru mode,
         simply press <b>CancelStepThru</b> at the bottom of the
         TreeWindow.  Also while in StepThru mode, you can use the
         following key-presses in the GraphicsWindow:
        <ul>
          <li><b>n</b> to go to the next step (which is the same as
              pressing the <b>NextStep</b> button);</li>
          <li><b>p</b> to go to the previous step;</li>
          <li><b>f</b> to go to the first step; and</li>
          <li><b>l</b> (lower case L) to go to the last step.</li>
        </ul>
        If you ask to go to the next step and you are currently at the
        last step, StepThru mode will be canceled (same as
        pressing <b>CancelStepThru</b>).  Similarly, if you are at the
        first step and ask to go to the previous step, StepThru mode
        will be canceled.

      <p>The <b>Help</b> button bring up the help document (which you
         are currently reading).

      <p>The second row of button contains two (or three) buttons.

      <p>The first button can have a variety of labels:
        <ul>
          <li><b>Up to date</b> (in white) tells you that the
              configuration that you are seeing in the GraphicsWindow
              is consistent with the current DesignParameters and
              Branches.  Pressing the button when the legend is <b>Up
              to date</b> will rebuild the entire configuration and
              reset the GUI.  Occasionally you might encounter a bug
              in the GUI where it says that a command is disabled, but
              you know it should not be.  In these cases, you can
              press the <b>Up to date</b> to reset the GUI;</li>
          <li><b>Press to Re-build</b> (in green) tells you that the
              configuration in the GraphicsWindow is inconsistent with
              either the DesignParameters or Branches.  Pressing this
              button will rebuild the configuration and update the
              GraphicsWindow;</li>
          <li><b>Rebuilding...</b> (in yellow) tells you that the
              configuration is in the process of being re-built;
              and</li>
          <li><b>Fix before re-build</b> (in red) tells you that an
              error was encountered (see the MessageWindow for more
              information) and that you need to fix the error before
              re-building (and updating the image in the
              GraphicsWindow).</li>
        </ul>

      <p>The second button in the second row, <b>Undo</b>, allows you
         to un-do the last change that you made using the GUI.  Note
         that not all actions can be un-done.

      <p>The third button in the second row may, or may not, be
         visible.  (In this Tutorial, it is not visible.)  It is used
         when there is more than one user connected to the same
         hostname and port at the same time.  In this case, the button
         will be visible with the legend <b>Collab</b>.  The color of
         the button give you information about your collaboration
         status:
        <ul>
          <li>green means that you have the "ball" and have total
              control;</li>
          <li>white means that you have control of your display but
              that you cannot change any DesignParameters or Branches
              (although you can examine them) and cannot ask that
              sensitivities be displayed; and</li>
          <li>yellow means the your display is synchronized with the
              display of the user with the "ball" and that you can
              examine DesignParameters or Branches, but nothing
              else.</li>
        </ul>
        These Tutorials will not further discuss this
        new <code>ESP</code> feature.

      <p>The third row of buttons allows you to set the home, left,
         right, bottom, or top view and allow you to zoom in and out.
         These were described above.

      <p>Now it is time to start looking at the tree itself.  At the
         top level of the tree are four groups:
        <ul>
          <li><b>Design Parameters</b> allows you to create, examine,
              edit, or delete a DesignParameter.  It is also used to
              display sensitivities (more on this later);</li>
          <li><b>Local Variables</b> allows you to examine a
              LocalVariable;</li>
          <li><b>Branches</b> allows you to create, examine, edit, or
              delete a Branch in the FeatureTree; and</li>
          <li><b>Display</b> allow you to manipulate the
              GraphicsWindow; most of this was described at length
              above, but the <b>DisplayType</b>
              and <b>DisplayFilter</b> will be described below.</li>
        </ul>

      <p><h4>DesignParameters</h4>

      <p>If you click the <b>+</b> to the left of "Design
         Parameters", a list of the current DesignParameters is
         shown as well as the name of all DesignParameter groups
         (described later).  The groups can have sub-groups, etc, so
         sometimes it is convenient to see everything at once.  This
         can be done by pressing <b>ExpandAll</b> to the right
         of "Design Parameters".  (When you have done this, the
         legend will change to <b>CollapseAll</b> which will have the
         opposite effect.

      <p>Now let us start looking at what happens when we change a
         DesignParameter.  We are going to start by
         pressing <b>makeSpindle</b> (which, as you will see in
         Tutorial 4 allows us to make the spindle in various ways.)
         When you have done this, the GraphicsWindow will change to a
         form that gives you all the information associated with this
         DesignParameter.

      <p><img src="pictures/tutorial1-04.png" width="100%"/>

      <p>Across the top of the form is a series of buttons:
        <ul>
          <li><b>Compute geom sens</b> allows you to compute the
              geometric sensitivity of the configuration (more on this
              later);</li>
          <li><b>Compute tess sens</b> allows you to compute the
              tessellation sensitivity of the configuration (more on
              this later too);</li>
          <li><b>Clear Design Velocities</b> which is also associated
              with sensitivities;</li>
          <li><b>Delete Parameter</b> allows you to delete the
              DesignParameter;</li>
          <li><b>Cancel</b> removes any changes that you may have made
              on this form and returns to the GraphicsWindow to show
              the 3D model; and</li>
          <li><b> OK</b> save the changes you have made on this form
              and returns the GraphicsWindow back to the 3D view.
              Note that the configuration will not automatically be
              rebuilt; you will have to press <b>Press to Re-build</b>
              to do that.</li>
        </ul>

      <p>Another thing you may notice is that the first column in the
         DesignParameter tree is changed to magenta for the
         DesignParameter that is being edited.  Also, for any Branch
         that uses the DesignParameter, the first column in the
         Branches tree has a yellow background.  You may have to
         press <b>ExpandAll</b> to the right of "Branches" to see the
         Branches ("Brch_000005" and "Brch_000039") that use
         "makeSpindle".

      <p>For now, change the value of <code>makeSpindle</code>
         from <code>1</code> to <code>-1</code>", press
         the <b>&lt;Enter&gt;</b> key or the <b>OK</b> button.  Now
         press <b>Press to Re-build</b> and you will see your new
         configuration (which will only consist of the spindle).

      <p><img src="pictures/tutorial1-05.png" width="100%"/>

      <p>Now press the <b>+</b> under "Design Parameters" and to the
         left of "spindle:" in the TreeWindow, and then
         press <b>yrad</b>; this will open up a form that allows you
         to edit the multi-valued DesignParameter.  As you will see
         later when we build the model, "yrad" has four values.  For
         now, change the value in "row 1" and "column 2"
         to <code>2</code>, hit <b>Enter</b> and <b>Press to
         Re-build</b>.  You should see that the configuration has now
         changed (to make the second radius much larger).

      <p><img src="pictures/tutorial1-06.png" width="100%"/>

      <p>Change the value back to <code>0.5</code> and re-build.

      <p>You can also press <b>Delete Parameter</b> to delete a
         DesignParameter from the model.  Be aware that doing will
         break the model build process if the model refers to it in
         any of its Branches.  So we will not delete any
         DesignParameters in this Tutorial.

      <p>If you want to add a new DesignParameter, simply click
         on <b>Design Parameters</b>.  You will be asked for the new
         parameter name (which must start with a letter, underscore,
         or colon, and be followed by up to 63 letters, digits,
         underscores, and colons).  You will then get a form that
         looks like the one we have been using, except for the fact
         that it will contain two buttons near the top (in addition to
         <b>OK</b> and <b>Cancel</b>):
        <ul>
          <li><b>Add row</b> adds a new row (making it a multi-valued
              DesignParameter); and</li>
          <li><b>Add column</b> adds a new column (making it a
              multi-valued DesignParameter).</li>
        </ul>
        Initially all the values are blank; you must add values for
        them. The initial values for the velocities are 0.

      <p><h4>Sensitivities</h4>

      <p>Now let us see how the sensitivities work.  If you once again
         edit the "spindle:yrad" DesignParameter, you will see that
         since "spindle:yrad" is a multi-valued DesignParameter you
         get a new row of entry boxes (near the bottom) in which to
         enter the design velocities.  So if you wanted to compute the
         sensitivity of the geometry with respect to (WRT) the second
         "spindle"yrad" value, enter a <code>1</code> in "row 1" and
         "column 2" in the velocities table and press <b>Compute geom
         sens</b>.  The GraphicsWindow will switch back to a view of
         the 3D configuration, which will be colored based upon the
         sensitivity value at each point.  You will also see that the
         KeyWindow changed to show you a spectrum associated with the
         colors in the GraphicsWindow.  (red indicates that the
         surface will move outward and blue indicates that the surface
         will move inward).  Since part of the configuration is red,
         you can see that the geometry will grow outward.  Note that
         the geometric sensitivity tells you how the local surface
         normal will change; this is generally computed exactly
         in <code>ESP</code> by actually differentiating the build
          process.

      <p><img src="pictures/tutorial1-07.png" width="100%"/>

      <p><code>ESP</code> has another sensitivity, namely the
         tessellation sensitivity.  This is an approximation of how
         points will move if the DesignParameters changes.  (It is only
         an approximation, since we do not know how your particular
         mesh generator will redistribute points on the surface when
         the surface shape changes.)  If you now re-edit "spindle:yrad"
         and press <b>Compute tess sens</b>, you will get the surfaces
         painted again and you will see little tufts showing the
         sensitivity.  If the tufts are too long, you could always
         change the design velocity to a smaller value (such as 0.1)
         and the spines will get shorter (which looks a lot better for
         this case).  By the way, blue spines are associated with
          Faces and red spines are associated with Edges.

      <p><img src="pictures/tutorial1-08.png" width="100%"/>

      <p>To return to a display without sensitivities, choose any
         DesignParameter, press <b>Clear Design Velocities</b>,
         then <b>OK</b>, and then <b>Press to Re-build</b>. Do this
         now.

      <p><h4>LocalVariables</h4>

      <p>A LocalVariable is a parameter that cannot be set before a
         model is built (unlike DesignParameters, which get their
         values before the model is built).  Instead, it is created
         and used during the build process.  To understand the
         difference, let us take an example. Suppose the you had a
         DesignParameter called "diameter", but the operation that
         creates a <code>SPHERE</code> takes the radius as one of its
         arguments.  There are a variety of ways of handling this
         situation, but an obvious one is to create a LocalVariable
         called "radius" and then using a <code>SET</code> statement
        <pre>
          SET   radius  diameter/2
        </pre>
         to set the radius to half the diameter.  Clearly the "radius"
         depends on the "diameter", so it cannot be directly set
         outside the build process.

      <p>There are two special kinds of LocalVariables:
        <ul>
          <li><i>OutputParameters</i> whose values are available
              outside <code>ESP</code> (for example,
              in <code>CAPS</code>).  You can see the current value
              (and velocity) of all OutputParameters by pressing the
              word <b>Local Variables</b> in the TreeWindow; and</li>
          <li><i>AtParameters</i> whose values are automatically set
              any time a Body is built.  For example, there is an
              AtParameter named <code>@volume</code>, which contains
              the volume of the Body just built.  To see all the
              AtParameters, press the <b>+</b> to the left of
              "@-parameters" for a full list; the meanings of these
              are described in the <a href="#sec5.9">Parameter
              rules</a> section in the latter
              part of the help file.</li>
        </ul>

      <p><b>ExpandAll</b> works exactly the same as it does for the
         DesignParameters.

      <p><h4>Branches</h4>

      <p>In <code>ESP</code>, a model is built by executing the
         Branches in the FeatureTree.  There are several kinds of
         Branches in <code>ESP</code>:
        <ul>
          <li>some Branches create a new Body (such
              as <code>BOX</code>, <code>CYLINDER</code>,
              <code>SPHERE</code>, <code>CONE</code>,
              and <code>TORUS</code>) based upon its arguments;</li>
          <li>some Branches combine previous Bodys into a new Body
              (such as the <code>UNION</code>, <code>INTERSECT</code>,
              and <code>SUBTRACT</code> Boolean operators);</li>
          <li>some Branches perform transformations on another Body
              (such as <code>TRANSLATE</code>, <code>SCALE</code>,
              <code>ROTATE</code>*, and <code>MIRROR</code>);</li>
          <li>others control the execution of the FeatureTree (such as
              <code>IFTHEN/ELSEIF/ELSE/ENDIF</code> logic blocks and
              loops with <code>PATBEG/PATEND</code>); and</li>
          <li>yet other Branches are used to <code>SET</code>
              LocalVariables, etc..</li>
        </ul>
        You will become familiar with may of the Branches in Tutorials
        2 through 5.

      <p>A new Branch can be created (at the end of the FeatureTree) by
         pressing the word <b>Branches</b> in the TreeWindow.

      <p><b>ExpandAll</b> works exactly the same as it does for the
         DesignParameters and LocalVariables.  Do that now.

      <p>One can inspect, edit, or delete a Branch by pressing on the
         name of the Branch, which typically has a name such as
         "Brch_xxxxxx".

      <p>Now click on <b>Brch_000114</b> and the Branch editor will
        appear.

      <p><img src="pictures/tutorial1-09.png" width="100%"/>

      <p>At the top of the Branch editor you will see a series of
         buttons:
        <ul>
          <li><b>Add new Branch after this Branch</b> can be pressed
              to create a new Branch after the current one in the
              FeatureTree;</li>
          <li><b>Delete this Branch</b> does exactly as the name
              implies;</li>
          <li><b>Show Attributes/Csystems</b> allows you to manipulate
              the Attributes and coordinate systems associated with a
              Branch (more on this in the next Tutorial); and</li>
          <li><b>Build to this Branch</b> allows you to re-execute the
              FeatureTree from the beginning up to this Branch.</li>
        </ul>

      <p>Below the button are the properties and arguments associated
         with the Branch.  If you edit these, remember to
         press <b>OK</b> and then <b>Press to Re-build</b> to see the
         effect of the edits.

      <p>If you choose "Brch_000114", you will see that the first
         column is colored magenta.  None of the other entries in the
        first column are colored, which either means that:
        <ul>
          <li>the statement does not use any entries from the Stack and the
              Body that is produced is left on the Stack at the end of
              the build (which is not the case here), or</li>
          <li>the statement was not executed during the last build
              (which is the case here).
          </ul>

      <p>To get around this, change the DesignParameter "makeSpindle"
         to <code>o</code> and <b>Press to Re-build</b>.  Once you've
         done this and re-edit "Brch_000114", the first column in the
         Branches tree in the TreeWindow is colored as follows:
        <ul>
          <li>magenta - the Branch being edited (in this case
              "Brch_000114");</li>
          <li>cyan - the two Branches whose Bodys are
              being <code>UNION</code>ed (in this case "Brch_000101"
              and "Brch_000113"); and</li>
          <li>yellow - the Branch that uses this Body (in this case,
              the <code>UNION</code> in "Brch_000117"),</li>
        </ul>

      <p>Current <code>ESP</code> best practice does not rely much on
         editing the Branches using these features; these features are
         typically used for "quick explorations" as you will see in
        the Tutorials that follow.

      <p>For now, <b>Cancel</b> out of the Branch editor.

      <p><h4>DisplayType and KeyWindow</h4>

      <p><code>ESP</code> can display the 3D configuration with
         various coloring schemes.  You can choose amongst them by
         clicking on <b>DisplayType</b>:
        <ul>
          <li><i>0 monochrome</i> is the default coloring scheme (that
              you've been seeing so far), except for the fact that some
              of the Faces have been explicitly colored, as described
              in some of the following Tutorials.  In monochrome
              mode:
            <ul>
              <li>Faces associated with SolidBodys are shown in light
                  yellow;</li>
              <li>Faces associated with SheetBodys are shown in light
                  red;</li>
              <li>Edges that were created as part of a primitive
                  operation are shown in green;</li>
              <li>Edges that were created by a Boolean or Applied
                  Branch (described below) are shown in blue;</li>
              <li>Edges that have only one associated Face are shown
                  in brown;</li>
              <li>Edges that have more than two associated Faces are
                  shown in orange; and</li>
              <li>Nodes are shown as small black squares.</li>
            </ul>
          <li><i>1 normalized U parameter</i> shows how the U
              parameter (on a Face) varies.  Since this is normalized,
              when using this mode it is probably best to choose the
              range <code>0</code> to <code>1</code>;</li>
          <li><i>2 normalized V parameter</i> shows how the V
              parameter (on a Face) varies.  Since this is normalized,
              when using this mode it is probably best to choose the
              range <code>0</code> to <code>1</code>;</li>
          <li><i>3 minimum curvature</i> shows the smaller of the two
              principal curvatures at each point on each Face;</li>
          <li><i>4 maximum curvature</i> shows the larger of the two
              principal curvatures at each point on each Face;</li>
          <li><i>5 Gaussian curvature</i> shows the Gaussian curvature
              (which is the product of the two principal curvatures,
              but scaled to highlight surface waviness) at each
              point on each Face;</li>
          <li><i>6 Normals</i> show the outward-pointing normals at each
              of the tessellation points.  The lengths of the little
              tufts can be adjusted by clicking in the KeyWindow and
              changing the LowerLimit to <code>0</code> and the
              UpperLimit to <code>1</code> (or somthing smaller if the
              tufts are too long); and</li>
          <li><i>10 Erep</i> shows the effective topology (which can be
              generated via <b>Tool->ErepEd</b>).</li></li>
        </ul>

      <p>When using any of the modes except monochrome or Erep, you
         will see that the KeyWindow shows you a title and a little
         spectrum to let you know what the various colors mean.  If
         you click in the KeyWindow (when a spectrum is showing), you
         can change the values associated with the lower limit (blue)
         and the upper limit (red).  When viewing normals, the lower
         KeyWindow limit will usually be zero and the upper limit can
         be used to adjust the lengths of the tufts.

        Trying these on the spindle gives you pictures like this.

      <p><img src="pictures/tutorial1-10.png" width="100%"/>

      <p><img src="pictures/tutorial1-11.png" width="100%"/>

      <p><img src="pictures/tutorial1-12.png" width="100%"/>

      <p><h4>DisplayFilter</h4>

      <p>For the next part of the Tutorial it is probably best to
        focus on the SolidBody.  So, do the following:
        <ul>
          <li>change DesignParameter "makeSpindle"
              to <code>1</code>;</li>
          <li><b>Press to Re-build</b> the configuration;</li>
          <li>turn the visibility of "SheetModel" off; and</li>
          <li>go back to monochrome mode in
              the <b>DisplayType</b></li>
        </ul>
        When you have done this, you should see the following.

      <p><img src="pictures/tutorial1-13.png" width="100%"/>

      <p>This model was constructed so that all of the Faces have an
         Attribute named "myPart" on it.  To see this for yourself,
         put your cursor on any Face and press the <b>^</b> key; a
         description of the Face and all of its Attributes are
         displayed in the MessageWindow, such as:

      <p><img src="pictures/tutorial1-14.png" width="100%"/>

      <p>Click on <b>DisplayFilter</b> and enter <code>myPart</code>
         in the popup window.  In order to see what the available
         values for the "myPart" Attribute are for this model,
         enter <code>?</code> in the new popup; in a
         popup, <code>ESP</code> tells you that the valid names are
         "tire", "disk", "spoke", "hole", and "spindle".
         Enter <code>spoke</code> and the Faces with that Attribute
         are shown as usual, while all other Faces are shown
         transparently, as in

      <p><img src="pictures/tutorial1-15.png" width="100%"/>

      <p>Try changing the DisplayFilter
         to <code>myPart</code>, <code>hole</code> to see the Faces
         associated with the holes.  You can turn the DisplayFilter
         off by simply pressing <b>Enter</b> in one of the popups.

      <p>Closing your browser will also terminate
         the <code>ESP</code> server.

      <p>Now that you have finished your tour of the <code>ESP</code>
         interface, proceed on to Tutorial 2 to start building up this
         configuration from scratch.

    <p><h3 id="sec2.2">2.2 Second Tutorial: Base <code>ESP</code> model</h3>

      <p>In the second tutorial, you will start building up a
         configuration, step by step.  It is assumed that you are
         already familiar with the <code>ESP</code> browser-based
         graphical user interface (GUI).  If you are not, please
         do <a href="#sec2.1">Tutorial 1</a> first.

      <p>Begin by starting <code>ESP</code> by either pressing
         the <b>runESP121</b> icon on you desktop, or by pressing
         the <b>ESP121</b> icon and then typing <code>serveESP</code>
         in the window that pops up.

      <p>In either case, if </code>ESP</code> asks for you hostname
         and port, enter (the default) <code>Localhost:7681</code>.
         This should bring up an empty <code>ESP</code> GUI.

      <p><h4>First (example) configuration</h4>

      <p>We are going to start a new configuration, using
         the <code>ESP</code> integrated code editor.  To do that,
         click on <b>File</b> and then choose <b>Edit: &lt;new
         file&gt;</b>.  The GraphicsWindow should now contain and
         empty file.

      <p>Start by typing the following into the code editor:
        <pre>
          # tutorial2
          # written by ...

          DESPMTR    length    4   # length of box
          DESPMTR    height    3   # height of box
          DESPMTR    depth     2   # depth  of box

          # create box centered at the origin
          BOX        -length/2  -height/2  -depth/2 \ comment
                      length     height     depth

          END
        </pre>

      <p>When you have done this, you should see:

      <p><img src="pictures/tutorial2-01.png" width="100%"/>

      <p>Before we go any further, some explanation about the code (or
        script) editor is in order.  The integrated editor has a row
        of buttons at the top:
        <ul>
          <li><b>Copy</b>: take highlighted text and puts a
              copy of it onto the clipboard;</li>
          <li><b>Cut</b>: remove highlighted text and puts it
              onto the clipboard;</li>
          <li><b>Paste</b>: put copy of the clipboard at the
              current cursor location;</li>
          <li><b>Insert</b>: insert the contents of another file at
              the current cursor location;
          <li><b>Search</b>: look for a string (see prompt
              near top of screen). The search is case sensitive;</li>
          <li><b>Prev</b>: look for previous occurrence of
              current search string;</li>
          <li><b>Next</b>: look for next occurrence of
              current search string;</li>
          <li><b>Replace</b>: replace current search string with the
              replacement text (see prompt near top of screen);</li>
          <li><b>Comment</b>: for the current highlighted text
            <ul>
              <li>if the first line is uncommented, comment all lines that
                  are highlighted</li>
              <li>if the first line is commented, uncomment all lines
                  that are highlighted (if possible)</li>
            </ul>
          <li><b>Indent</b>: use standard indentation for
              all highlight lines;</li>
          <li><b>Hint</b>: provide a hint of the arguments associated
              with the line at the current cursor (see top of screen
              for hint);</li>
          <li><b>Undo</b>: undo the last change;</li>
          <li><b>Cancel</b>: exit the editor and do not save
              changes; and</li>
          <li><b>Save</b>: save the changes and exit the editor
           <ul>
             <li>if editing the <code>.csm</code> file and there are
                 no current <code>.udc</code> files, then the
                 configuration is automatically rebuilt</li>
             <li>otherwise, you will need to press <b>Press to
                 Rebuild</b> to rebuild the configuration</li>
           </ul>
        </ul>

    <p>Note that the text in the file is colored:
      <ul>
        <li>comments are shown in grey;</li>
        <li>command names are shown in blue (this is an easy way to
            check that you have spelled the command name
            correctly);</li>
        <li>parameter names are shown in yellow;</li>
        <li>numbers are shown in green;</li>
        <li>strings are shown in magenta; and</li>
        <li>quotation marks (which show the extent of an argument) are
            shown in cyan.</li>
      </ul>

    <p>Now it is time to explain the script that you typed.

    <p>Lines 1 and 2:
      <pre>
        # tutorial2
        # written by ...
      </pre>
       are comments, designated by the comment symbol
       (#).  It is good practice to name and sign your scripts, since
       you may return to them in the future, and any information that
       you include will help you.

    <p>All <code>ESP</code> commands begin with a CommandName (which
       you expect to see in blue), followed by zero or more arguments.
       The CommandName can be either all UPPERCASE or lowercase, but
       not MixedCase.  The arguments are separated from the
       CommandName and from each other by spaces.  If you want to
       include a space within an argument (to increase readability),
       simply put quotation marks (" ") around the
       argument.  <code>ESP</code> ignores anything after it finds a
       comment "#" symbol.

    <p>Lines 4 through 6:
      <pre>
        DESPMTR    length    4   # length of box
        DESPMTR    height    3   # height of box
        DESPMTR    depth     2   # depth  of box
      </pre>
       define DesignParameters.  To get the most out
       of an <code>ESP</code> model, you should define the
       configuration in terms of DesignParameters so that you can:
      <ul>
        <li>create various (parametric) instances of the
            configuration; and</li>
        <li>find the (geometric or tessellation) sensitivity of the
            configuration with respect to the DesignParameter(s).</li>
      </ul>
       The format of the <code>DESPMTR</code> statement is:
      <ul>
        <li>the CommandName <code>DESPMTR</code>
            or <code>despmtr</code>;</li>
        <li>the name of the DesignParameter, which must start with a
            letter (a-z and A-Z), an underscore (_), or a colon (:),
            followed by zero to 63 letters (a-z and A-Z), digits
            (0-9), underscores (_), and colons (:).  Note that the
            colon means nothing special when building a configuration,
            but that it gives you a convenient way of grouping your
            DesignParameters in the GUI; and</li>
        <li>a value, which could be a number (such as 3.14159 or
            2.5e+3) or a simple expression (such as 1/2).</li>
      </ul>
      In lines 4 through 6, the # starts a comment.

    <p>Lines 9 and 10:
      <pre>
        BOX        -length/2  -height/2  -depth/2 \ comment
                    length     height     depth
      </pre>
       actually generate a <code>BOX</code>, which is specified by its
       beginning coordinates (xbase, ybase, zbase) and its size (dx,
       dy, dz).  If you put you cursor on line 9 and press
       the <b>Hint</b> button near the top of the editor, the editor
       will list (just below the buttons) the format of
       the <code>BOX</code> command.  Note that on line 9 there is a
       backslash (\); this is the line continuation character, which
       tells <code>ESP</code> to ignore the backslash and everything
       following it, and concatenate the following line.  So, lines 9
       and 10 are equivalent to:
      <pre>
        BOX  -length/2 -height/2 -depth/2 length height depth
      </pre>
       Note that the continuation character was used here to improve
       readability.

    <p>Since we wanted the <code>BOX</code> centered at the origin,
       and since the <code>BOX</code> command is defined in terms of a
       "base" point, we needed to specify that the "base" was half
       the length, height, and depth away from the origin.

    <p>In <code>ESP</code>, expressions follow the same syntax as most
       modern computer languages. See <a href="#sec5.10">Expression
       rules</a> for complete details.

    <p>Line 12:
      <pre>
        END
      </pre>
      identifies the <code>END</code> of the script.  This
       statement is technically not needed, but I always use
       it.  <code>ESP</code> does not read (or process) anything after
       the <code>END</code> statement, so it is a convenient way of
       testing an <code>ESP</code> script while you are writing and
       debugging it.

    <p>Now that the script is complete, it is time to run it.  To do
       this, press the <b>Save</b> button at the top of the editor.
       Since this is a new file, <code>ESP</code> will ask for the
       filename with which to save it.  For this tutorial,
       enter <code>tutorial2</code> (or <code>tutorial2.csm</code> at
       the prompt.  This will cause the file to be saved and the model
       to be automatically executed.  Your GraphicsWindow will then
       change to a 3D view of your configuration.

      <p><img src="pictures/tutorial2-02.png" width="100%"/>

    <p>To see the effect of the DesignParameters in your model,
       press <b>length</b> in the DesignParameters part of the
       TreeWindow and change the value to <code>1</code>,
       hit <b>OK</b> and <b>Press to Re-build</b>.  You should see a
       shortened version of your box.

      <p><img src="pictures/tutorial2-03.png" width="100%"/>

    <p>Now let us return to the code editor, by pressing <b>File</b>
       (at the top of the TreeWindow), and then <b>Edit:
       tutorial2.csm</b>.  You will get a popup that says "1 change(s)
       will be lost.  Continue?".  This is informing you that you
       changed something via the TreeWindow (in this case, the length
       of the <code>BOX</code>).  Since we only did this to verify that
       our DesignParameters were working okay, we can implicitly
       discard this change and return to the code editor by
       pressing <b>OK</b>.

    <p>Now we are going to add a cylinder that starts at the middle of
       the front Face and is vertical with a length of "height".  This
       can be done by modifying your script to:
      <pre>
        # tutorial2
        # written by ...

        DESPMTR    length    4   # length of box
        DESPMTR    height    3   # height of box
        DESPMTR    depth     2   # depth  of box
        DESPMTR    radius    1/2 # radius of cylinder

        # create box centered at the origin
        BOX        -length/2  -height/2  -depth/2 \ comment
                    length     height     depth

        # create the cylinder and move to correct location
        CYLINDER   0  0  0  0  height  0  radius
        TRANSLATE  0  0  depth/2

        END
      </pre>
      Your editor should look like this:

    <p><img src="pictures/tutorial2-04.png" width="100%"/>

    <p>Note that we added a new line 7:
      <pre>
        DESPMTR    radius    1/2 # radius of cylinder
      </pre>
       which is a new DesignParameter for the radius of
       the <code>CYLINDER</code>.

    <p>Then in line 14:
      <pre>
        CYLINDER   0  0  0  0  height  0  radius
      </pre>
        we actually generate the <code>CYLINDER</code>
       (see the <b>Hint</b> for help on the <code>CYLINDER</code>
       statement).  The <code>CYLINDER</code> is then
      <code>TRANSLATE</code>d to its correct position in line 15:
      <pre>
        TRANSLATE  0  0  depth/2
      </pre>
       If you actually had looked at the <b>Hint</b> for
       a <code>CYLINDER</code> you would have noticed that we could
       have done the statements in lines 14 and 15 in the single
       statement:
      <pre>
        CYLINDER   0  0  depth/2  0  height  depth/2  radius
      </pre>

    <p>The reason that this was done in two statements here was to
       explain the concept of the Stack, which is used in the
       construction process.  <code>ESP</code> maintains of
       last-in-first-out Stack of the Bodys that are created during
       the build process.  The Stack starts empty for every build.
       Then the <code>BOX</code> statement in line 10
       creates "Body 1", which is put onto the Stack.  So the Stack
      looks like:
      <pre>
        Body 1       (the box)
      </pre>

    <p>Then the <code>CYLINDER</code> is generated in line 14
      (creating "Body 2"), so the Stack looks like:
      <pre>
        Body 2       (the cylinder)
        Body 1       (the box)
      </pre>

    <p>Now the <code>TRANSLATE</code> statement in line 15 takes the
       Body on the top of the Stack ("Body 2")
       and <code>TRANSLATE</code>s it to its new location.  In essence,
       the Body on the top of the Stack has been replaced by the new
       Body.  So the Stack now looks like:
      <pre>
        Body 3       (the translated cylinder)
        Body 1       (the box)
      </pre>
       See that by using the Stack, there was no need to
       tell <code>ESP</code> which Body was to
       be <code>TRANLATE</code>d.

    <p>If we <b>Save</b> this modified script, we should get a
        configuration with two Bodys:

    <p><img src="pictures/tutorial2-05.png" width="100%"/>

    <p>Finally we want to combine the two Bodys on the top of the
       Stack (which currently only contains two Bodys) using a Boolean
       operation:
      <ul>
        <li><code>UNION</code> fuses the two Bodys together;</li>
        <li><code>SUBTRACT</code> removes from "Body 1" any part of
            "Body 3" that is within it; and</li>
        <li><code>INTERSECT</code> returns the common part of its two
            input Bodys.</li>
      </ul>
      Let us start off with the <code>UNION</code>, so add a new line
      to you script, to produce:
      <pre>
        # tutorial2
        # written by ...

        DESPMTR    length    4   # length of box
        DESPMTR    height    3   # height of box
        DESPMTR    depth     2   # depth  of box
        DESPMTR    radius    1/2 # radius of cylinder

        # create box centered at the origin
        BOX        -length/2  -height/2  -depth/2 \ comment
                    length     height     depth

        # create the cylinder and move to correct location
        CYLINDER   0  0  0  0  height  0  radius
        TRANSLATE  0  0  depth/2

        UNION
        END
      </pre>

    <p>If you <b>Save</b> your new script, you will see one Body
       ("Body 4").  Also, the Stack now just contains the result of
       the <code>UNION</code>
      <pre>
        Body 4        (the result of the union)
      </pre>

    <p>Imagine that you wanted to set up your script so the
       particular Boolean operation that was to be used could be
       selected during the build process.  This could be done by
       modifying your script to be:
      <pre>
        # tutorial2
        # written by ...

        DESPMTR    length    4   # length of box
        DESPMTR    height    3   # height of box
        DESPMTR    depth     2   # depth  of box
        DESPMTR    radius    1/2 # radius of cylinder
        CFGPMTR    oper      1   # =1 for UNION, =2 for SUBTRACT, otherwise INTERSECT

        # create box centered at the origin
        BOX        -length/2  -height/2  -depth/2 \ comment
                    length     height     depth

        # create the cylinder and move to correct location
        CYLINDER   0  0  0  0  height  0  radius
        TRANSLATE  0  0  depth/2

        # choose the appropriate Boolean
        IFTHEN    oper EQ 1
           UNION
        ELSEIF    oper EQ 2
           SUBTRACT
        ELSE
           INTERSECT
        ENDIF

        END
      </pre>
       which would look like this:

    <p><img src="pictures/tutorial2-06.png" width="100%"/>

    <p>The first this we should note is line 8:
      <pre>
        CFGPMTR    oper      1   # =1 for UNION, =2 for SUBTRACT, otherwise INTERSECT
      </pre>
       which contains a ConfigurationParameter. A
       ConfigurationParameter is like a DesignParameter in every
       respect, except that you cannot take the sensitivity with
       respect to it.  That makes it ideal for cases (such as this),
       where you want to be able to influence the build before it
       happens, but not in a way that could be differentiated.

    <p>Here we have introduced a new concept (line lines 19 through
      25):
      <pre>
        IFTHEN    oper EQ 1
           UNION
        ELSEIF    oper EQ 2
           SUBTRACT
        ELSE
           INTERSECT
        ENDIF
      </pre>
       that is fairly unique to <code>ESP</code>: the logic block.
       This is introduced by the <code>IFTHEN</code> statement,
       followed by zero or more statements, followed by zero or
       more <code>ELSEIF</code> statements (each of which can be
       followed by zero or more statements), followed by an
       optional <code>ELSE</code> statement (with its own included
       statements), followed by the <code>ENDIF</code> statement.
       This logic construct can be found in every computer language;
      oddly is seems to be lacking in most CAD system.

    <p>The relations operations allowed in the <code>IFTHEN</code>
      and <code>ELSEIF</code> statments are:
      <ul>
        <li><code>EQ</code> for is equal;</li>
        <li><code>NE</code> for is not equal;</li>
        <li><code>LT</code> for is less than;</li>
        <li><code>LE</code> for is less than or equal;</li>
        <li><code>GT</code> for is greater than; and</li>
        <li><code>GE</code> for is greater than or equal.</li>
      </ul>
      If you look at the <b>Hint</b> you will see that you can have
      two relational operations joined by either <code>AND</code>
      or </code>OR</code>.

    <p><b>Save</b> your modified script.  Try modifying "oper" in
       the <code>ESP</code> TreeWindow to get each of the following:

    <p><img src="pictures/tutorial2-07.png" width="100%"/>

    <p><img src="pictures/tutorial2-08.png" width="100%"/>

    <p><img src="pictures/tutorial2-09.png" width="100%"/>

    <p><h4>Second (real) configuration --- basic tire</h4>

    <p>Rather than typing a lot of code, we are going to use the
       Tutorial files in the <code>ESP</code> distribution.  To do
       that, press <b>File</b>, then <b>Open</b>, and then
       enter <code>../data/tutorial2</code> on MAC or LINUX or
       <code>..\data\tutorial2</code> on Windows.

    <p>If we open the script editor, we see <code>DESPMTR</code>
       statements such as those in lines 5 through 7:
      <pre>
        DESPMTR   tire:width         12.0      # width of tire
        DESPMTR   tire:diam_outer    30.0      # outer diam  of tire
        DESPMTR   tire:diam_inner    22.0      # inner diam  of tire
      </pre>
       before.  The only difference here is that the names contain a
       colon (:).  This is done because we expect the model to get
       fairly complicated and it would be good to group
       DesignParameters so that they are easier to find in
       the <code>ESP</code> GUI.

    <p>The strategy that we are going to use to build a tire-like
       object is to define a cross-section and then use it to make a
       body of revolution.  In Tutorial 3 we will use the sketcher to
       make a complex cross-section, but for this Tutorial we will
       just be using a rectangle.

    <p>We will start with a <code>BOX</code> command (in line 19), but
       this time we will make its "dz" zero, to create a SheetBody (a
       Body without volume) instead of the traditional SolidBody.
       Notice that the SheetBody is defined in the <i>xy</i>-plane
       (because <code>zbase</code> is <code>0</code>) and that is goes
       between <code>0</code> and <code>tire:width/2</code> in
       the <i>x</i> direction and <code>tire:diam_inner/2</code>
       and <code>tire:diam_outer/2</code> in the <i>y</i> direction.
       (By the way, after this statement there is only one Body on the
       Stack.)

    <p>We want to now <code>REVOLVE</code> this Body around
       the <i>x</i>-axis to make a ring.  In <code>ESP</code>, it is
       NOT the best practice to actually <code>REVOLVE</code>
       something 360 degrees since some of the (subsequent) geometric
       operations are not robust for this case.  Therefore the best
       practice is to <code>REVOLVE</code> it 180 degrees and
       then <code>MIRROR</code> it and <code>JOIN</code> the two
       halves together.

    <p>In line 22:
      <pre>
        REVOLVE   0   0   0   1   0   0   180
      </pre>
       you can see that we <code>REVOLVE</code> the Body
       on the Stack (that is, the Body that was created by
       the <code>BOX</code> command) around an axis that passes
       through (0,0,0), which is in the (1,0,0) (that is <i>x</i>) direction,
       and <code>REVOLVE</code> it 180 degrees.  (See the <b>Hint</b>
       on the <code>REVOLVE</code> command if you need it by putting
      the cursor on line 22 and pressing the <b>Hint</b> button.)

    <p>If we use <b>StepThru</b> mode, we can see the <b>REVOLVE</b>d Body.

    <p><img src="pictures/tutorial2-10.png" width="100%"/>

    <p>After doing this, the Stack will contain:
      <pre>
        Body 2      (the revolved Body)
      </pre>

    <p>Next we will be transforming this Body (that is, we will
       be <code>MIRROR</code>ing it).  The various transformations
       in <code>ESP</code> are:
      <ul>
        <li><code>TRANSLATE</code> to move a Body;</li>
        <li><code>SCALE</code> to make a Body bigger or smaller;</li>
        <li><code>ROTATEX</code> to rotate around an axis that is
            parallel to the x-axis;</li>
        <li><code>ROTATEY</code> to rotate around an axis that is
            parallel to the y-axis;</li>
        <li><code>ROTATEZ</code> to rotate around an axis that is
            parallel to the z-axis; and</li>
        <li><code>MIRROR</code> to make the mirror image of a
          Body.</li>
      </ul>

    <p>We now want to <code>MIRROR</code> across the <i>xy</i> plane
       (signified as the (0,0,1) plane). But, the <code>MIRROR</code>
       operates the same as all the other transformations; that is it
       takes the Body off the top of the Stack, performs the
       transformation, and then pushes the result back onto the Stack.
       Since we want to keep the original Body and then make a mirror
       image, we need do a little manipulation of the Stack.  This is
      done by line 30:
      <pre>
        RESTORE   .
      </pre>
       which tells <code>ESP</code> to make another copy of the Body
       on the top of the Stack.  After doing this, the Stack will
       contain:
      <pre>
        Body 3        (a copy of Body 2)
        Body 2        (the original revolved Body)
      </pre>

    <p>We can now <code>MIRROR</code> the Body on the top of the
      Stack (Body 3), producing:
      <pre>
        Body 4        (a mirrored version of Body 3)
        Body 2        (the original revolved Body)
      </pre>

    <p>Finally we can <code>JOIN</code> the two halves together.  The
       difference between <code>UNION</code> and <code>JOIN</code> is
       subtle, but important.  <code>JOIN</code> should be used when
       you expect to have Faces (or Edges) that are coincident in the
       input Bodys; <code>UNION</code> is more general, but has the
       possibility of creating lots of little sliver Faces if the
       Faces that are being combined are not exactly the same.  Best
       practices say to use <code>JOIN</code> whenever appropriate
      and <code>UNION</code> only when needed.

    <p>Again, if we use <b>StepThru</b> mode, we can see
       the <b>JOIN</b>ed original and <b>MIRROR</b>ed Bodys.

    <p><img src="pictures/tutorial2-11.png" width="100%"/>

    <p>Lines 34 through 36:
      <pre>
        RESTORE   .
        MIRROR    1   0   0
        JOIN
      </pre>
       do exactly the same as above, but makes and
       combines a mirror image about the <i>x</i> (1,0,0) plane.

    <p><h4>Adding in disk and attribution</h4>

    <p>The next thing that we will do is add in the disk and provide
       Attributes on the model.

    <p>We are going to go through the new statements a little at a
      time.

    <p>First look at lines 10 and 11:
      <pre>
        DESPMTR   disk:width          1.0      # width  of disk
        DESPMTR   disk:chamfer        0.5      # chamfer radius btwn disk and tire
      </pre>
       in which we define new DesignParameters for putting a disk
       inside the tire.  The disk itself is generated in line 46 (and
      continued in line 47):
      <pre>
        CYLINDER  -disk:width/2  0  0  \
                  +disk:width/2  0  0  (tire:diam_inner+tire:diam_outer)/4
      </pre>
      and then <code>UNION</code>ed with the tire in line 50:
      <pre>
        UNION
      </pre>

    <p><code>ESP</code> models get much of their value through the use
        of Attributes.  An Attribute is a name/value pair that can be
        attached to any Body, any Face, any Edge, or any Node.  The
        value can be:
      <ul>
        <li>a number;</li>
        <li>a group of numbers, which are separated from each other by
            semi-colons (;); or</li>
        <li>a character string, which is identified by a leading
            dollar sign ($).  See the section
            on <a href="#sec5.8">String rules</a> for details.</li>
      </ul>

    <p>See lines 48 and 49:
      <pre>
        ATTRIBUTE myPart $disk
        ATTRIBUTE _color  $red
      </pre>
       These <code>ATTRIBUTE</code> statements tell <code>ESP</code>
       to put the indicated Attribute on the <code>CYLINDER</code>
       Body (that was created by the immediately-preceding Branch) as
       well as any Faces created when the <code>CYLIDER</code> was
       being created.  Hence all the Faces will be marked as being
       part of the "disk" (via the "myPart" Attribute) and will be
       colored "red".  See the section on <a href="#sec5.11">Attribute
       rules</a> below for details about special Attributes, such as
       "_color".

    <p>Identifying the "tread" part of the configuration is a bit
       trickier. This is because the tread Faces were generated by
       the <code>REVOLVE</code> operation.  But we do not want all the
       Faces that were created to get the "tread" Attribute.  To get
       around this, we will use the <code>SELECT</code> statement.
       This statement has lots of options, and in fact is the longest
       entry in the sections that describes the various commands.

    <p>To figure out which Face we want to Attribute:
      <ul>
        <li>press <b>ExpandAll</b> to the right of "Branches" in the
            TreeWindow;</li>
        <li>press <b>Brch_000002</b> (which you can see is
            the <code>REVOLVE</code> Branch; and</li>
        <li>press <b>Build to this Branch</b>.</li>
      </ul>

    <p>Put your cursor over the magenta Face and press the <b>^</b>
       (or <b>6</b>) key in the GraphicsWindow, and you should see this:

    <p><img src="pictures/tutorial2-12.png" width="100%"/>

    <p>In the MessageWindow, you can see that the Face has many
       Attributes, but the one we are interested in is the one called
       "_faceID".  The "_faceID" is a unique triple of numbers that
      tell you:
      <ul>
        <li>the Body in which the Face first appeared, which in this
            case is Body 2 (the <code>REVOLVE</code>);</li>
        <li>the face-order associated with the Face, which is
            described more fully under the description of
            the <code>REVOLVE</code> command; and</li>
        <li>a sequence number, which is <code>1</code> unless the
            original Face was cut up as part of a prior
            operation.</li>
      </ul>

    <p>So we could use a statement such as:
      <pre>
        SELECT FACE 2 6 1
      </pre>
      to get this Face.  But, if we were to edit the script and add
      something else before the <code>REVOLVE</code>, then the first
      entry would change.  A safer way of doing this is to use the
      "last" Body; this can be done conveniently using
      the <code>@nbody</code> AtParameter.  Hence, we used the line:
      <pre>
        SELECT FACE @nbody 6
      </pre>
      where the trailing <code>1</code> is assumed.

    <p>We can <code>ATTRIBUTE</code> this <code>SELECT</code>
       statement (in lines 26 and 27):
      <pre>
        ATTRIBUTE myTag  $tread
        ATTRIBUTE _color $magenta
      </pre>
       to get the desired result.

    <p><h4>Drilling holes</h4>

    <p>The next thing is to add in a series (called a pattern) of
       holes, through the disk and around the <i>x</i>-axis.  To do
       this, we are going to have to start by defining the
       DesignParameters associated with the holes (in lines 14 through
       16):
      <pre>
        CFGPMTR   hole:num            5        # number of holes
        DESPMTR   hole:diam_circ      4.0      # diam of circle of holes
        DESPMTR   hole:rad            0.5      # radius of each hole
      </pre>
       Note that it does not make sense to compute the sensitivity
       with respect to the number of holes, so "hole:num" is actually
       a ConfigurationParameter.

    <p>The actual drilling of the holes is performed by the pattern in
       lines 59 through 75:  To start off, look at lines 59 and 75:
      <pre>
        PATBEG  ihole  hole:num

        PATEND
      </pre>
      These define a pattern (in C a "for" loop and in FORTRAN a "do"
      loop), where the LocalVariable <code>ihole</code> gets the value
      "1" the during first trip through the loop, the value "2" the second
      time, ... and the value <code>hole:num</code> the last time.
      Note that if <code>hole:num</code> is not greater than zero, the
      pattern will be skipped.

    <p>The actual drilling of the holes is done by
       the <code>SUBTRACT</code>ion of a <code>CYLINDER</code> from
      the disk; this is done in lines 71 through 74:
      <pre>
        CYLINDER -disk:width  y  z \
                 +disk:width  y  z  hole:rad
        ATTRIBUTE myPart $hole
        SUBTRACT
      </pre>
       Note a few things:
      <ul>
        <li>the <i>x</i>-extents of the <code>CYLINDER</code> are will beyond
            the thickness of the disk.  Making sure that you have a
            "clean Boolean" is a best practice; and</li>
        <li>the Faces associated with the hole are identified with the
            Attribute <code>myPart=$hole</code></li>
      </ul>

    <p>One other thing to note here is how the center of the hole (in
       <i>y</i> and <i>z</i>) is computed.  In cases where there is
       only one hole, it is placed on the <i>x</i>-axis with the lines:
      <pre>
        SET  y  0
        SET  z  0
      </pre>
       In cases with more than one hole, they are equally spaced
       around the x-axis by lines 66 through 68.  Note a few things in
       line 67:
      <pre>
        SET  y  "hole:diam_circ/2 * cosd(theta)"
      </pre>
      <ul>
        <li>quotation marks are put around the second argument to make
            it easier to read.  (Without the quotation marks, the
            second argument would just be <code>hole:diam_circ/2*cosd(theta)</code>);
            and</li>
        <li><code>ESP</code> has many built-in function (described in the
            <a href="#sec5.10">Expression rules</a> part of this
            document).  In particular, <code>cosd()</code> takes the
            cosine of its argument in degrees.</li>
      </ul>

    <p><h4>Adding a chamfer</h4>

    <p>The next step is to add a <code>CHAMFER</code> between the tire
       and the disk.  To see how to do this, see the help
       on </code>CHAMFER</code>:
    <pre>
       CHAMFER   radius edgeList=0
                 use:    apply a chamfer to a Body
                 pops:   Body
                 pushes: Body
                 notes:  Sketch may not be open
                         Solver may not be open
                         if listStyle==0
                            if previous operation is boolean, apply to all new Edges
                            edgeList=0 is the same as edgeList=[0;0]
                            edgeList is a multi-value Parameter or a semicolon-separated
                               list
                            pairs of edgeList entries are processed in order
                            pairs of edgeList entries are interpreted as follows:
                               col1  col2   meaning
                                =0    =0    add all Edges
                                >0    >0    add    Edges between iford=+icol1
                                                             and iford=+icol2
                                <0    <0    remove Edges between iford=-icol1
                                                             and iford=-icol2
                                >0    =0    add    Edges adjacent to iford=+icol1
                                <0    =0    remove Edges adjacent to iford=-icol1
                         else
                            edgeList contains Edge number(s)
                         sensitivity computed w.r.t. radius
                         sets up @-parameters
                         new Faces all receive the Branchs Attributes
                         face-order is based upon order that is returned from EGADS
                         signals that may be thrown/caught:
                            $illegal_argument
                            $illegal_value
                            $insufficient_bodys_on_stack
                            $wrong_types_on_stack
    </pre>
       Note a few things:
       <ul>
         <li>the command and its argument are specified on the first
             line.  The second argument, <code>edgeList=0</code> has a
             default value of <code>0</code>;</li>
         <li><i>use:</i> describes how it is used;</li>
         <li><i>pops:</i> says that it pops one Body off the
             Stack;</li>
         <li><i>pushes:</i> says that it pushes one Body onto the top
             of the Stack; and</li>
         <li><i>notes:</i> gives lots more description of what should
             happen.  In particular, the last part of
             the <i>notes:</i> tells you the type of errors you might
             expect so that you may "catch" them later (as described
           below).</li>
       </ul>

    <p>For our case, we simply want to put the <code>CHAMFER</code>
       between the tire and the disk, for which <code>edgeList</code>
       can be left blank if we place the <code>CHAMFER</code> command
       just after the <code>UNION</code> of the tire and the disk.
       This is done in lines 54 and 55:
      <pre>
        CHAMFER   disk:chamfer
        ATTRIBUTE _color $blue
      </pre>
       (Note that the Faces created by the <code>CHAMFER</code> are
       colored blue in line 55).

    <p>But what if the user does not want a <code>CHAMFER</code>?  We
       can add the statements in lines 53 and 56 to skip this if the
       use specifies a non-positive value
       for <code>disk:chamfer</code>.

    <p><h4>OutputParameters</h4>

    <p><code>ESP</code> has the ability to make some of its
       LocalVariables available outside <code>ESP</code> (such as
       in <code>CAPS</code>).  This is done with
      the <code>OUTPMTR</code> statements in lines 8 and 12:
      <pre>
        OUTPMTR   tire:volume                  # volume      of tire

        OUTPMTR   disk:volume                  # volume of disk
      </pre>

    <p>The first one is fairly easy to compute since there is an
       AtParameter that contains the volume of the last Body created
       (or <code>SELECT</code>ed).  Line 39:
      <pre>
        SET       tire:volume  @volume
      </pre>
       stores that value in the <code>OUTPMTR tire:volume</code>.

    <p>Getting the volume of the disk is a bit harder, since we must
       account for the holes and/or <code>CHAMFER</code>.  The easiest
       way of doing this is to make a <code>CYLINDER</code> that just
       fits within the tire, <code>INTERSECT</code>ing it with the
       current configuration, and then looking up
       its <code>@volume</code>.  But the problem with that is that we
       still want to keep the whole configuration (and
      the <code>INTERSECT</code> operation will consume it).

    <p>The answer to this is <code>STORE</code>
       and <code>RESTORE</code>.  Earlier, we saw a special version
       of <code>RESTORE</code> (that is, <code>RESTORE .</code>) to duplicate
       the Body on the top of the Stack.

    <p>The <code>STORE</code> command in line 78:
      <pre>
        STORE    SolidModel  0  1
      </pre>
       says to remember the Body on the top of the Stack
       as <code>SolidModel 0</code> (name and index) and furthermore
       to leave the copy of the Body on the stack (because the third
       argument <code>keep</code> had a non-zero value).  So after line
       78 the Stack is unchanged but the Body on the top of the Stack
       was <code>STORE</code>d away for future use.

    <p>Lines 82 through 86:
      <pre>
        SET      xmax     2*tire:width
        CYLINDER -xmax  0  0  +xmax  0  0  tire:diam_inner/2
        INTERSECT
        SET      disk:volume  @volume
        STORE    .          # pop Body off stack
      </pre>
       create the temporary <code>CYLINDER</code>,
       <code>INTERSECT</code> it with the configuration that had been
       on the top of the Stack, and then saves its volume
       in <code>disk:volume</code>. The last line, <code>STORE
       .</code> removes the Body that was left on the Stack after
       the <code>INTERSECT</code> operation from the Stack.

    <p>Finally, we want to display the final configurations, so
       we <code>RESTORE</code> it in line 89:
      <pre>
        RESTORE          SolidModel
      </pre>
       and then name it (in the <code>ESP</code> GUI) so that it is
       easier for the user.

    <p>One final note.  Although it might seem daunting to build a
       script like <code>tutorial2.csm</code>, if you build it up,
       step-by-step, it is not quite so difficult.

    <p><h3 id="sec2.3">2.3 Third Tutorial: Using the sketcher and adding spokes</h3>

    <p>As with the second Tutorial, this third Tutorial will start with
       the basics on a sample problem and then we will apply what we
      learned to the real Tutorial problem.

    <p><h4>First sketch - the shape</h4>

    <p>For the third tutorial, we will start without
       a <code>.csm</code> file.  This can either be done by starting
      over or by pressing <b>File</b> and then <b>New</b>.

    <p>We are going to start with an empty sketch.  To do this we will
       first add a <code>SKBEG</code> Branch by pressing
       <b>Branches</b>, selecting a <b>SKBEG</b>, and making
       the <code>x</code>, <code>y</code>, and <code>z</code> all
       zero.  The final argument, <code>relative</code>, is set
       to <code>1</code> to indicate that all coordinates in the
       sketch are relative to the coordinates that were contained in
       the <code>SKBEG</code> statement.

    <p>When a <code>SKBEG</code> Branch is added, <code>ESP</code> now
       automatically adds the matching <code>SKEND</code> Branch and
       automatically enters the Sketcher.

    <p>There are several changes between normal 3D mode and the
       Sketcher.  The first difference is the buttons on the top of
       the TreeWindow.  A second button has now appeared that is
       labeled <b>Sketch</b>, which will pop up a menu
       with the entries:
      <ul>
        <li><b>Save</b>: this will save the current Sketch and exit
            the Sketcher; and</li>
        <li><b>Quit</b>: this will exit the Sketcher (with all the
            work done in the Sketcher being lost)</li>
      </ul>

    <p>The legend on another button has now changed to
       <b>Drawing...</b>, which describes the status of
       the Sketcher.

    <p>Also, the KeyWindow now lists the status of the Sketcher
       status, in terms of the number of degrees of freedom
       (<code>ndof</code>) and the number of constraints
       (<code>ncon</code>).  This is followed by a listing of the
       available commands in the Sketcher.

    <p>Within the Sketcher (which is displayed in
       the GraphicsWindow), there is a point at the
       center that has the legend "XY" and a blue line between that
       point and the current cursor location.  As you move the cursor
       around in the Sketcher, you will notice that the blue line
       follows the cursor.  You will also notice that if the line is
       approximately horizontal or vertical, it will change from blue
       to orange; this is an indication that if the current cursor
       location is chosen (see below), an implicit "horizontal" or
       "vertical" constraint will be created.

    <p>As you can see in the KeyWindow, you have 6 choices:
      <ul>
        <li><b>l</b> (lower case "L") - create a line segment
            (<code>LINSEG</code>) in the sketch;</li>
        <li><b>c</b> - create a circular arc (<code>ARC</code>) in the
            sketch;</li>
        <li><b>s</b> - add a spline point (<code>SPLINE</code>) to the
            sketch;</li>
        <li><b>b</b> - add a Bezier control point
            (<code>BEZIER</code>) to the sketch;</li>
        <li><b>z</b> - add a zero-length segment; and</li>
        <li><b>o</b> - finish the sketch (that is, leave a
            sketch open)</li>
      </ul>

    <p>If you just press the mouse button, the <b>l</b> (lower case L)
       option will be chosen for you.  So now, draw the sketch shown
       in:

    <p><img src="pictures/tutorial3-01.png" width="100%"/>

    <p>in a counter-clockwise direction, starting at the point with
       the label "XY".  Make sure that when you have completed the
       closed sketch, the last point should be the same as the first
       point.  You can ensure this by noting that a circle is placed
       around the first point if the last point is "close enough".

    <p>Notice that several of the line segments have either the letter
       "H" or "V" associated with them.  These "horizontal" or
       "vertical" constraints were automatically added for you since
       you pressed <b>l</b> or the mouse button when the
       line was orange.  Also notice that since you "closed" the
       sketch, it got filled in with grey.  (If you had left it open
       by pressing the <b>o</b> key, there would be no filling.)

    <p>Your completed sketch should now have 16 degrees of freedom
       (since there are 8 points and no arcs) and 10 constraints.  To
       see what the meaning of the various constraint letters are,
       notice that the KeyWindow has now changed to explain the
       meaning of the constraints.  In summary, at the first point,
       both the "X" and "Y" coordinates are fixed.  The other
       constraints are that certain line segments are either
       constrained to be horizontal ("H") or vertical("V").

    <p>Since the number of constraints is fewer than the number of
       degrees of freedom, we will have to add more constraints.

    <p>If you do not know what constraint(s) to add, press the
       <b>Constraining...</b> button and several choices
       will be presented to you (in green), as in:

    <p><img src="pictures/tutorial3-02.png" width="100%"/>

    <p>We will choose the following:
      <ul>
        <li>put the cursor over the middle of the bottom segment and
            press <b>L</b> (which will set its length) and
            enter <code>4</code> in the pop-up;</li>
        <li>put the cursor over the left vertical line, press
            "<b>L</b>" and enter <code>3</code>;</li>
        <li>put the cursor over the right vertical line, press
            "<b>L</b>" and enter <code>3</code>;</li>
        <li>put the cursor over the horizontal segment at the
            top-left, press "<b>L</b>", and enter <code>1</code>;</li>
        <li>put the cursor over the horizontal segment at the
            top-right, press "<b>L</b>", and enter <code>1</code>;
            and</li>
        <li>put the cursor over the vertical segment on the left side
            of the slot, press "<b>L</b>", and
            enter <code>2</code></li>
      </ul>

    <p>Since the number of constraints now matches the number of degrees
       of freedom, the grey fill has changed to a light green fill and
       the first button has turned green with the legend
       <b>Press to Solve</b>.  Press that button and (hopefully) your
       sketch will solve.  (If it does not, you can always remove
       constraints by moving the cursor over the constraint and
       pressing <b>&lt;</b>, which deletes selected constraints at
       that point or on that segment.)  To center the image,
       press the <b>H</b> button.  You screen should
       look like:

    <p><img src="pictures/tutorial3-03.png" width="100%"/>

    <p>We are now finished with the Sketcher (for now), so press
       <b>Sketch</b> and then <b>Save</b> to return to the normal 3D
       view.  You can now press <b>Press to Re-build</b> to rebuild
       the 3D object, giving a screen that looks like:

    <p><img src="pictures/tutorial3-04.png" width="100%"/>

    <p>You will notice that we hard-coded dimensions into our sketch.
       To make the sketch more useful, it would be convenient to drive
       it with DesignParameters.  To do this, we first have to create
       them.  This is done in the code editor or by pressing
       <b>Design Parameters</b> in the TreeWindow,
       entering <code>length</code> as the Parameter name and setting
       its value to <code>4</code>.

    <p>In a similar way, create a <code>height</code> DesignParameter
       whose value is <code>3</code> and a <code>thick</code>
       DesignParameter whose value is <code>0.5</code>.

    <p>Now, let us use these DesignParameters in the sketch.  To do
       this, choose one of the statements between the <code>SKBEG</code> and
       <code>SKEND</code>.  I suggest choosing <b>Brch_000003</b>,
       which is the <code>SKVAR</code> statement (which shows the
       default locations of each of the sketch points).
       Select <b>Enter Sketcher</b>.

    <p>We are now going to change the various "L" constraints, by
       moving the mouse over the "L", pressing <b>L</b>
       and entering the new value.  Specifically, you should change
       the "L" constrains as follows:
      <ul>
        <li>bottom should have length set to <code>length</code>;</li>
        <li>left should have its length set to <code>height</code>;</li>
        <li>right should have its length set to <code>height</code>;</li>
        <li>top-left should have its length set  to <code>thick</code>;</li>
        <li>top-right should have its length set
            to <code>thick</code>; and</li>
        <li>left side of slot should have its length set to
            <code>height-thick</code></li>
      </ul>

    <p><b>Press to Solve</b>, giving:

    <p><img src="pictures/tutorial3-05.png" width="100%"/>

    <p>Press <b>Sketch</b> and <b>Save</b> (to exit the Sketcher)
      and <b>Press to Re-build</b> to use the latest changes.

    <p>Think about what we have done.  We have made a U-shaped channel
       whose overall length and height were given, and whose channel
       walls were all set to "thick".  Suppose instead that the
       "design intent" of the channel was to create a channel of a
       given slot width.  In this case, we would want to constrain the
       sketch differently.

    <p>Start by creating a DesignParameter named <code>slot</code>
       whose single value was <code>1</code>.  Now
       select <b>Brch_000002</b> and <b>Enter Sketcher</b>.  We are
       going to have to remove the "L" constraints from the top two
       horizontal segments, so go to each and press <b>&lt;</b>.
       Since there are two constraints here, you are asked which
       constraint to remove.  Simply enter <code>L</code> at the
       prompt and the length constraint will be removed but the
       horizontal constraint will remain.  If you want to remove all
       constraints, press <b>&lt;</b> multiple times.

    <p>Now move the mouse over the horizontal segment at the bottom of
       the slot and press <b>L</b> and set the length to
       <code>slot</code>.  You will notice that the sketch is
       under-constrained (is grey).  We need to add a constraint that
       the slot is centered.  To do this, we are going to make the
       lengths of the two small horizontal segments near the top on
       each side of the U equal to each other.  The first step here is
       to identify one of the segments.  This is done with
       the <b>?</b>  command.  So, move the cursor over the top-left
       horizontal segment and press <b>?</b>.  You will notice in the
       MessageWindow that this is segment 7.  Now move over the
       top-right horizontal segment and enter the length <code>::L[7]</code>,
       which tells it to use the same length as segment 7.  <b>Press
       to Solve</b> to give:

    <p><img src="pictures/tutorial3-06.png" width="100%"/>

    <p>Press <b>Sketch</b> and <b>Save</b> and
       <b>Press to Re-build</b>.

    <p>Now open the list of DesignParameters (using the "<b>+</b>" to
       the left of "Design Parameters") and change the value
       of <b>slot</b> to <code>2</code>.  <b>Press to Re-build</b> to
       see the effect of this change.

    <p>We will now experiment with some of the other constraints.
       Specifically we will be removing some of our "H" and "V"
       constraints and instead add constraints at some of the points.
       Re-enter the Sketcher and move the cursor over the right-hand
       segment, press <b>&lt;</b> to remove the vertical
       constraint.  Similarly remove the horizontal constraint from
       the top-right horizontal segment.

    <p>The sketch is under-constrained (is grey).  We are going to add
       a perpendicularity constraint at the point at the lower-right
       corner by moving the mouse over the point and pressing
       <b>P</b>.  Just to be different, at the top-right
       point we are going to add an "angle" constraint by pressing
       <b>A</b> and adding a value of <code>90</code>. Note that an
       angle less than 180 turns to the left whereas one greater than
       180 turns to the right.

    <p><b>Press to Solve</b> and <b>Sketch</b> and <b>Save</b>.

    <p>We are now going to extrude the sketch into a solid.  This is
       done by first creating a DesignParameter
       named <code>depth</code> and giving it a default value
       of <code>3</code>.  Then add an <code>EXTRUDE</code> Branch (by
       pressing <b>Branches</b> in the TreeWindow), whose arguments
       are <code>dx=0</code>, <code>dy=0</code>,
       and <code>dz=depth</code>.  This will extrude the sketch in the
       "z" direction (out of the screen).  <b>Press to Re-build</b>,
       yielding:

    <p><img src="pictures/tutorial3-07.png" width="100%"/>

    <p>As with most programs, it makes sense to periodically save your
       work, so press <b>File</b>, <b>Export FeatureTree</b>, and save
       the current model in a file named
       "<code>tutorial3</code>".  (Note that the
       "<code>.csm</code>" suffix will automatically be added for
       you.)

    <p>To see the <code>.csm</code> file associated with the current
       model, press the <b>File</b> and <b>Edit: tutorial3.csm</b> buttons.  For now
       you can ignore the warning.  At the top of the file, all the
       DesignParameters are defined (along with their current values).
       This is followed by the Branches in the Feature Tree.  Note the
       the sketch starts with a <code>SKBEG</code> statement.  This is
       followed by a <code>SKVAR</code> statement that specifies the
       initial locations of the various points in the sketch.  (These
       positions were automatically set up for you when you drew the
       sketch).  Following that, there is a series
       of <code>SKCON</code> statements that define the various
       constraints in the Sketcher.  The first argument of
       each <code>SKCON</code> statement is the constraint type (which
       corresponds with the letters in the Sketcher), followed by the
       point (or segment) number and the value; again these were
       automatically set up for you when you drew the sketch and
       constrained it.  This is then followed by a series
       of <code>LINSEG</code> Branches, which say that our current
       sketch is made up of a series of line segments.  Again the
       number of the points to use in the <code>LINSEG</code> Branches
       was set up automatically for you.

    <p>Press <b>Cancel</b> to exit the editor and return
       to the normal view.

    <p>We are now going to create another sketch, which will be used
       to cut a hole in the left upright of the bracket. This cut will
       be parameterized with a DesignParameter named <code>rad</code>
       whose value is <code>0.5</code>.  (You can create that now.)

    <p>Now we want to create a new sketch.  We do this by adding a
       <code>SKBEG</code> Branch (by pressing <b>Branches</b> in the
       TreeWindow); set all its arguments to <code>0</code>.

    <p>The sketch that we are going to create consists of a
       race-track-shape curve, as shown in:

    <p><img src="pictures/tutorial3-08.png" width="100%"/>

    <p>This is done with the following actions. Draw a horizontal
       segment off to the right (make sure the line from the last
       point is drawn in orange) and press <b>L</b> (or click the
       mouse) to create the first horizontal segment.  Then move the
       mouse up and press the <b>C</b> key to create a circular arc
       segment.  When you have done that, the segment that you just
       created turns red and follows the cursor; move the cursor and
       see how it changes.  Once it is located at approximately the
       correct location, press the mouse button.  Then sketch the
       horizontal line segment to the left, a circular arc on the left
       end, and finally a line segment back to the original point.

    <p>You might be wondering why the bottom of the racetrack was
       created with two <code>LINSEG</code>s.  The reason is that we
       are ultimately going to want to center the sketch on the
       left-leg of the bracket, so having a point at the "center" of
       the sketch will be convenient.

    <p>We are now going to constrain the sketch as follows:
      <ul>
        <li>"L" constraint on bottom-left horizontal segment set to
            <code>rad</code>;</li>
        <li>"L" constraint on bottom-right horizontal segment set to
            <code>rad</code>;</li>
        <li>"R" constraint on the right-hand circle set
            to <code>rad</code> (that is, you set the radius of the
            circular arc);</li>
        <li>"T" constraint (tangency) at the point at the bottom of
            the left-hand arc</li>
        <li>"T" constraint (tangency) at the point at the bottom of
            the right-hand arc</li>
        <li>"T" constraint (tangency) at the point at the top of the
            left-hand arc</li>
        <li>"T" constraint (tangency) at the point at the top of the
            right-hand arc</li>
      </ul>

    <p><b>Press to Solve</b>, zoom in (using the
       <b>+</b> button) and center the sketch in the
       window (using the <b>H</b>) button, yielding:

    <p><img src="pictures/tutorial3-09.png" width="100%"/>

    <p><b>Sketch</b> and <b>Save</b> and <b>Press to Re-build</b>. If
       you turn the configuration around, you will see the sketch at
       the back left bottom corner, as in:

    <p><img src="pictures/tutorial3-10.png" width="100%"/>

    <p>We want to rotate this to be parallel with the <em>y-z</em>
       plane by adding a <code>ROTATEY</code> Branch (with
       arguments <code>90</code>, <code>0</code>,
       <code>0</code>), move it to its proper location by adding
       a <code>TRANSLATE</code> Branch (with arguments
       <code>0</code>, <code>height-3*rad</code>,
       and <code>depth/2</code>).  If you <b>Press to Re-build</b> you
       will see that the sketch is now properly positioned.  We can
       then add an <code>EXTRUDE</code> Branch (with
       arguments <code>length/2</code>, <code>0</code>,
       and <code>0</code>) and finally subtract that new volume by
       adding a <code>SUBTRACT</code> Branch (with the default
       arguments).  If you <b>Press to Re-build</b>, you should get:

    <p><img src="pictures/tutorial3-11.png" width="100%"/>

    <p><h4>Adding a sketch to a model</h4>

    <p>One of the problems with using the interactive sketcher is that
       the only way of saving an interactively-drawn sketch is to use <b>Export
       FeatureTree</b>, but that option removes all your formatting
       and all the comments that you have already spent time to put in
       your model file.  (You could also create a constrained sketch
       using <code>SOLBEG/SOLEND</code> and then using statements such
       as <code>LINSEG</code> or <code>CIRARC</code> directly.  This
       technique is not covered in this tutorial.)

    <p>To demonstrate adding a sketch to a model, we are going to make
       a parameterized wedge.  Start with an empty <code>ESP</code> by
       pressing <b>File</b> and <b>New</b>.

    <p>To create a parameterized sketch of a triangle, do the
      following:
      <ul>
        <li>add a <code>SET</code> Branch (by pressing <b>Branches</b>
            and then selecting <code>SET</code>).
            The <code>$pmtrName</code> is <code>length</code> and
            the <code>exprs</code> is <code>4</code>;</li>
        <li>add another <code>SET</code> Branch so
            that <code>height</code> is <code>3</code>;</li>
        <li><b>Press to Re-build</b> to process these statements; and</li>
        <li>add a <code>SKBEG</code> Branch that starts
            at <code>0</code>, <code>0</code>, <code>0</code>, and
            draw the following:</li>
      </ul>

    <p><img src="pictures/tutorial3-12.png" width="100%"/>

    <p>The "length" of the horizontal segment is <code>length</code>
       and the "length" of the vertical segment
       is <code>height</code>. <b>Press to Solve</b>,
       then <b>Sketch</b>, then <b>Save</b>, then <b>Press to
        Re-build</b>.  You should now see the following:

    <p><img src="pictures/tutorial3-13.png" width="100%"/>

    <p>Notice that the Body is drawn in pink, meaning that it is a
       SheetBody (that is, a Body with Face(s) that does not enclose a
       volume).

    <p>Next we are going to save this as a user-defined component
      (UDC).  For now, think of a UDC as a file that can be included
      in another file.  To save this, press <b>File</b> and
      then <b>Export FeatureTree</b> and use the name
      <code>triangle.udc</code>.  You will get a warning about losing
      formatting, etc.; this is okay, so just press <b>OK</b>.

    <p>Now we are actually going to create the model (that is,
       the <code>.csm</code>) file by selecting <b>File</b>
       and <b>Edit: &lt;new file&gt;</b>.  Enter the following in the
      editor:
      <pre>
        # wedge
        # written by ...

        DESPMTR   depth   2.0

        UDPRIM    $/triangle

        EXTRUDE   0  0  depth

        END
      </pre>

    <p>Line 4 defines a DesignParameter (as we have seen
       before).  Line 6 is new; the <code>UDPRIM</code> statement
       tells the program to "include" the
       file <code>triangle.udc</code> at this point.  This is followed
       in line 8 by an <code>EXTRUDE</code>ion in the z direction.

    <p>Press <b>Save</b> in the editor, and use the
       name <code>wedge</code>.  You should now see a 3D wedge on your
       screen.  Note that the Faces are now yellow since this is now a
       SolidBody (that is, it encloses a volume).

    <p><img src="pictures/tutorial3-14.png" width="100%"/>

    <p>If you change the value of the <code>depth</code>
       DesignParameter and <b>Press to Re-build</b>, you will see the
       depth of the wedge has changed.  Now we want to
       make <code>length</code> and <code>height</code>
       DesignParameters too.  To do this, we will need to edit
       <code>wedge.csm</code> to be:
       <pre>
        # wedge
        # written by ...

        DESPMTR   length  4.0
        DESPMTR   height  3.0
        DESPMTR   depth   2.0

        UDPRIM    $/triangle

        EXTRUDE   0  0  depth

        END
      </pre>

    <p>Press <b>Save</b>.  Notice that the configuration is not
       automatically re-built since we have more than one file in the
       session.  Now we will edit <code>triangle.udc</code> and remove
       the two <code>SET</code> statements near the top.
       Again <b>Save</b>.

    <p>Finally, when you press <b>Press to Re-build</b> you will see a
       fully parametric wedge.  Try changing the DesignParameter
       and/or get the sensitivities (which, you may recall, is done by
       editing a DesignParameter and then choosing either <b>Compute
       geom sens</b> or <b>Compute tess sens</b>.  Here is what the
       tessellation sensitivities look like with respect to
      the <code>length</code>.

    <p><img src="pictures/tutorial3-15.png" width="100%"/>

    <p><h4>Sketch for tire</h4>

    <p>The next thing we are going to do is to make a copy of
       our <code>../data/tutorial2.csm</code> file, and call
      it <code>temp.csm</code>. To do this:
      <ul>
        <li>press <b>File</b> and <b>Edit: &lt;new file&gt;</b>;</li>
        <li><b>Insert</b> the file <code>../data/tutorial2.csm</code>
            (or <code>..\data\tutorial2.csm</code> on Windows); and
        <li><b>Save</b> the file as <code>temp.csm</code>.
      </ul>

    <p>After you have done that, we will make our sketch of the
       cross-section of the tire.  This is done by
       pressing <b>File</b> and then <b>New</b> (thereby removing from
       memory anything we have already done).

    <p>We are going to need a few DesignParameters for our sketch.
       But for now, we are going to make them LocalVariables
       with <code>SET</code> statements.  (The reason for doing this
       is because we are really going to want to have the
       DesignParameter in the main script, and not in the sketch UDC
      that we will now be building.)

    <p>Using <b>Branches</b>, create the following </code>SET</code>
      statements:
      <ul>
        <li><code>tire:wid_outer</code> with the
            value <code>12.0</code>;</li>
        <li><code>tire:wid_inner</code> with the
            value <code>10.0</code>;</li>
        <li><code>tire:fillet</code> with the
            value <code>1.0</code>;</li>
        <li><code>tire:diam_outer</code> with the
            value <code>30.0</code>; and</li>
        <li><code>tire:diam_inner</code> with the
            value <code>22.0</code>.</li>
      </ul>

    <p><b>Press to Re-build</b> so that <code>ESP</code> now knows
       about these DesignParameters.

    <p>Now make the sketch (by adding a <code>SKBEG</code> Branch),
       with the
       arguments <code>0</code>, <code>tire:diam_inner/2</code>,
       <code>0</code>, and <code>1</code>, that
       looks like:

    <p><img src="pictures/tutorial3-16.png" width="100%"/>

    <p>The constraints associated with this sketch are:
      <ul>
        <li>the length of the lower segment is
            <code>tire:wid_inner/2</code>;</li>
        <li>the length of the left-hand segment
            is <code>(tire:diam_outer-tire:diam_inner)/2</code>;</li>
        <li>the radius of the upper-right circular segment
            is <code>tire:fillet</code>;</li>
        <li>the "width" of the configuration
            is <code>tire:wid_outer/2</code>; and</li>
        <li>the "sweep" of the upper-right arc is <code>90</code>.</li>
      </ul>
      Note that you make the "width" constraint by hitting <b>W</b> at
      the top-left point and then clicking the mouse on the
      farthest-right point, and then entering the value.  Also, do not
      forget to add the two "tangency" constraints.

    <p>Then <b>Sketch</b>, <b>Save</b>, (ignore the warning)
       and <b>Press to Re-build</b>. In order to save our work,
       use <b>File</b>, <b>Export FeatureTree</b> and
       enter <code>temp_sketch.udc</code> as the filename.

    <p>Now we want to include this sketch in our bigger model file.
       To do this, <b>File</b> and <b>Open</b> and
       choose <code>temp</code>.  (If you followed the
       directions above, you should now see the same model that you
       had at the end of Tutorial 2.)

    <p>After changing the name of the file in the first line (which is
       not actually needed, but which is a best practice), we are
       going to change our definitions of the DesignParameters (which
       are in lines 5 through 7), to:
      <pre>
        DESPMTR   tire:wid_outer     12.0      # outer width of tire
        DESPMTR   tire:wid_inner     10.0      # inner width of tire
        DESPMTR   tire:fillet         1.0      # fillet rad  of tire
        DESPMTR   tire:diam_outer    30.0      # outer diam  of tire
        DESPMTR   tire:diam_inner    22.0      # inner diam  of tire
      </pre>

    <p>The only other thing we need to do is to change the definition
       of the cross-section.  Change the first <code>BOX</code>
       statement (line 21) to read:
      <pre>
        UDPRIM   $/temp_sketch
      </pre>

    <p>When you <b>Save</b> out of the code editor, you will get an
       error (MessageWindow will end with ||), telling you that something
       went wrong.  (What went wrong is that the <code>SET</code>
       statements in the UDC are trying to set a new value for a
       DesignParameter).  It will also seem to "lock up" the GUI.  To
       clear this lock, press <b>Re-building...</b> and ignore the
       warning.

    <p>Now edit <code>temp_sketch.udc</code> and remove
       the <code>SET</code> statements near the top (since they will
       be DesignParameters in <code>temp.csm</code>).
       Press <b>Save</b> and <b>Press to Re-build</b> and you should
       now see your tire with an updated cross-section.

    <p>But, you will notice that notice that the MessageWindow has
       turned yellow, indicating that there was an error encountered.
       If you double-click on the yellow window, the code editor will
       automatically open up to the offending line.  In this case, we
       no longer have a parameter named <code>tire:width</code>; it
       has been renamed to <code>tire:wid_outer</code>.  Make the
       change, <b>Save</b>, and <b>Press to Re-build</b>.

    <p><h4>Adding in spokes</h4>

    <p>The next thing we are going to do is to add spokes to our
       configuration.  At this time, <b>File</b> and <b>Open</b> the
       model <code>../data/tutorial3</code>
       (or <code>..\data\tutorial3</code>).  Now <b>File</b>
       and <b>Edit: ../data/tutorial3.csm</b>.

    <p>To add the spokes, the following changes were made:
      <ul>
        <li>new DesignParameters were added in lines 20 through
          22;</li>
        <pre>
        CFGPMTR   spoke:num          10        # number of spokes
        DESPMTR   spoke:rim           1.0      # rim left after spokes cutout
        DESPMTR   spoke:rad           0.2      # radius of each spoke
        </pre>
        <li>lines 88 and 118:
          <pre>
        IFTHEN    spoke:num GT 0

        ENDIF
          </pre>
            define an <code>IFTHEN</code> block so
            that the spokes will only be added if the user supplies a
            positive number of spokes;</li>
        <li>lines 89 and 90:
          <pre>
        SET    rmin  hole:diam_circ/2+hole:rad+spoke:rim
        SET    rmax  tire:diam_inner/2-disk:chamfer-spoke:rim
          </pre>
          define the minimum and maximum radii of
            the spokes;</li>
        <li>lines 92 and 93:
          <pre>
        CYLINDER  -disk:width  0  0  +disk:width  0  0  rmax
        SUBTRACT
          </pre>
            make a <code>CYLINDER</code> and <code>SUBTRACT</code> it
            from the overall "SolidModel";</li>
        <li>lines 94 and 95:
          <pre>
        SELECT    FACE   @nbody-1  0     # comes from cylinder
        ATTRIBUTE _color $cyan
          </pre>
            color the newly created Faces cyan.  Note
            that the Faces that we want to color actually come from
            the <code>CYLINDER</code>, so we must <code>SELECT</code>
            using the <code>@nbody-1</code> Body.  Also, we want all
            Faces that came from the <code>CYLINDER</code>, so we use
            a <code>_faceID</code> of <code>0</code>;</li>
        <li>the first spoke is generated in line 97:
          <pre>
        CYLINDER  0  rmin-0.1  0  0  rmax+0.1  0  spoke:rad
          </pre>
            and Attributed in
          lines 98 and 99:
          <pre>
        ATTRIBUTE myPart $spoke
        ATTRIBUTE _color $cyan
          </pre>
            Note that we slightly adjusted the
            extents of the <code>CYLINDER</code> by <code>0.1</code>
            to make sure we would get clean Boolean operations;</li>
        <li>the new spoke is <code>UNION</code>ed with the rest of the
          configuration in line 101</li>
        <pre>
        UNION
        </pre>
        <li>the original "SolidModel" is <code>RESTORE</code>d in line
          103:
          <pre>
        RESTORE SolidModel
          </pre>
          and then a smaller <code>CYLINDER</code>
          is <code>INTERSECT</code>ed with it in lines 104 and 105:
          <pre>
        CYLINDER  -disk:width  0  0  +disk:width  0  0  rmin
        INTERSECT
          </pre>
            Again, the exposed Faces are Attributed in lines 106 and
          107:</li>
        <pre>
        SELECT    FACE   @nbody-1  0     # comes from cylinder
        ATTRIBUTE _color $cyan
        </pre>
        <li> the hub (that was just made) is then <code>UNION</code>ed
          with the rest of the configuration in line 108:</li>
        <pre>
        UNION
        </pre>
        <li>then there is a pattern to make each of the
            other <code>spoke:num-1</code> spokes (in lines 111
            through 113):
          <pre>
        CYLINDER  0  rmin-0.1  0  0  rmax+0.1  0  spoke:rad
        ATTRIBUTE myPart $spoke
        ATTRIBUTE _color $cyan
          </pre>
            <code>ROTATEX</code> each into its final
            position (in line 115):
            <pre>
        ROTATEX   360*ispoke/spoke:num  0  0
            </pre>
            and <code>UNION</code> each into
            the rest of the configuration (in line 116):
            <pre>
        UNION
            </pre>
            and</li>
        <li>finally the resulting model is <code>STORE</code>d in
            "SolidModel 0" and a copy of it is left on the Stack.</li>
      </ul>

    <p><h3 id="sec2.4">2.4 Fourth Tutorial: RULEs, BLENDs, and error checking</h3>

    <p>In this fourth tutorial, we are going to focus on Bodys that
       are made by growing from lower-dimensional Bodys.  Specifically
       we are going to look at <code>EXTRUDE</code>
       and <code>REVOLVE</code>, which we have already seen, and then
       two new important construction techniques: <code>RULE</code>
       and <code>BLEND</code>.

    <p>All of these techniques can be used to make a WireBody out of a
       series of NodeBodys, or a SheetBody out of a series of
       WireBodys, or a SolidBody out of a series of SheetBodys.

    <p>Before continuing, it is instructive to define what we mean by
       the various Body types:
      <ul>
        <li><i>NodeBody</i> refers to a Body that is a single point in
            space.  NodyBodys are most often generated with
            the <code>POINT</code> command;</li>
        <li><i>WireBody</i> refers to a Body that is composed of only
            Edges, and the Edges must be connected end to end.
            WireBodys are often created by open sketches, or by
            the <code>BOX</code> command, or by one of the airfoil
            generators for the case where the thickness is zero, or by
            one of the user-defined primitives (such
            as <code>bezier</code> or <code>freeform</code>);</li>
        <li><i>SheetBody</i> refers to a Body that is composed of
            Faces that are connected to each other along common Edges.
            It is possible for a SheetBody to be closed, but
            generally they are open (that is, they have Edges that
            support only one Face).  The most common ways of making
            SheetBodys are with the <code>BOX</code> command, by the
            sketcher, or by one of the user-defined primitives (such
            as the airfoils generators); and</li>
        <li><i>SolidBody</i> refers to a closed Body that has an
            inside and an outside.  The vast majority of the Bodys
            produced by an <code>ESP</code> model are SolidBodys.</li>
        </ul>
      The examples in this Tutorial all make SolidBodys out of
      SheetBodys.

    <p>Let us start with a simple rectangle, which can easily be made
       with the <code>BOX</code> command.  Press <b>File</b>,
       then <b>New</b>, then <b>Edit &lt;new file&gt;</b> and put the
       following in the editor:
      <pre>
        BOX        1.0 4.0 0.0   2.0 3.0 0.0
        EXTRUDE    0.0 1.0 4.0
        END
      </pre>
       and <b>Save</b> to the file <code>temp</code>.  The first line
       makes a 2-by-3 SheetBody that lies in the x-y plane and whose
       lower left corner is at (1.0,4.0,0.0).  The second
       line <code>EXTRUDE</code>s the SheetBody into a SolidBody by
       implicitly making a second copy that is at (0.0,1.0,4.0)
       relative to the original SheetBody and then connecting the
       SheetBodys.

    <p>Instead of an <code>EXTRUDE</code>ion, we can make a body of
      revolution by changing the second line to:
      <pre>
        REVOLVE    0.0 0.0 0.0   1.0 0.0 0.0  90.0
      </pre>
       which takes the SheetBody and <code>REVOLVE</code>s it by 90
       degrees about an axis that goes through the point (0.0,0.0,0.0)
       and which is in the (1.0,0.0,0.0) direction (that is, parallel
       to the <i>x</i> axis).  If you do not remember the arguments
       for any command, remember that you can press the <b>Hint</b>
       button at the top of the editor.

    <p>We could also rotate it about the y axis by changing to:
      <pre>
        REVOLVE    0.0 0.0 0.0   0.0 1.0 0.0  90.0
      </pre>

    <p>Note that both of these commands pop a SheetBody off the Stack
       and put the resulting SolidBody back onto the Stack.

    <p><h4>Basic RULEs and BLENDs</h4>

    <p>Now we will make more a more interesting Body by starting with
       a super-ellipse, which is an ellipse-like shape, where the
       exponent (<code>n</code>) may not be <code>2</code>.

    <p>Delete all the lines in the editor and add (possibly
       using <b>Copy</b> and <b>Paste</b> to make your life easier):
      <pre>
        UDPRIM    supell   rx 3.0   ry 2.0   n 5.0

        UDPRIM    supell   rx 3.0   ry 2.0   n 3.0
        TRANSLATE 0  0  1

        UDPRIM    supell   rx 3.0   ry 2.0   n 2.0
        TRANSLATE 0  0  2

        UDPRIM    supell   rx 3.0   ry 2.0   n 1.5
        TRANSLATE 0  0  3

        UDPRIM    supell   rx 3.0   ry 2.0   n 1.0
        TRANSLATE 0  0  4
      </pre>
      The first line generates a super-ellipse in the <i>xy</i> plane that
      is 6 wide, 4 tall, and has a power of 5.  The third line
      generates another super-ellipse, but with a power of 3; this
      super-ellipse is then brought forward
      by <code>TRANSLATE</code>ing it in the <i>z</i> direction.  This is
      then followed by three more super-ellipses.  Note how the higher
      the power, the more squared-off the super-ellipse is.

    <p><img src="pictures/tutorial4-01.png" width="100%"/>

    <p>Now we want to use these by <code>RULE</code>ing them into a
       SolidBody.  This can be done by adding the statement
      <pre>
        RULE
      </pre>
       to the end of your script.  The resulting <code>RULE</code>d
       Edges are all straight.

    <p><img src="pictures/tutorial4-02.png" width="100%"/>

    <p><code>ESP</code> requires that all the Bodys that
       are <code>RULE</code>d have the same number of segments (in
       this case, Edges).  It <code>RULE</code>s together all the
       Bodys on the Stack, unless there is a <code>MARK</code> on the
       Stack; in this case, it just <code>RULE</code>s the Bodys back
       to the Mark.  To see this in action, add the line:
      <pre>
        MARK
      </pre>
       between the first and third lines and see what happens.  (The
       first SheetBody remains on the stack and the other four
       are <code>RULE</code>d together to form the SolidBody).

    <p>The types of the Bodys that are <code>RULE</code>d together all
       have to be of the same type (NodeBody, WireBody, or SheetBody),
       with one exception: the first and/or last Body could be a
       NodeBody.  To see this in action add the line:
      <pre>
        POINT     0  0  5
      </pre>
       just before the line with the <code>RULE</code>.  Note how the
       Body now comes to a point (pun not intended).

    <p><img src="pictures/tutorial4-03.png" width="100%"/>

    <p>The other very popular command is <code>BLEND</code>, which
       follows basically all the same rules as <code>RULE</code>; the
       difference is that <code>BLEND</code> uses cubic BSplines to
       connect the sections (instead of straight lines as was done
       for <code>RULE</code>).  Change the <code>RULE</code>
       to <code>BLEND</code> in the code editor and see what happens.

    <p><img src="pictures/tutorial4-04.png" width="100%"/>

    <p><h4>Using user-defined primitives and components</h4>

    <p>In Tutorial 3 we used the <code>UDPRIM</code> statement to
       include a user-defined component (UDC).  Then in the section
       above we used the same <code>UDPRIM</code> statement to call a
       user-defined primitive (UDP).  Both UDCs and UDPs are ways
      that <code>ESP</code> can be extended by the user.

    <p>The first argument of the <code>UDPRIM</code> is the name of
       the UDP, UDF, or UDC; which one it is depends on the way the
       <i>primtype</i> is specified:
       <ul>
         <li>if <i>primtype</i> starts with a letter, then it is the
             name of a UDP (or UDF).  UDPs are C- or FORTRAN-applets
             that can either be one shipped with <code>ESP</code> (see
             the <a href="#sec5.5">User-defined Primitives/Functions
             shipped with OpenCSM</a> for a listing) or one written by
             you or someone in your organization.  They are only
             loaded dynamically into <code>ESP</code> when
             needed;</li>
         <li>if <i>primtype</i> starts with a slash (/), then it is a UDC
             that is located in the current directory;</li>
         <li>if <i>primtype</i> starts with a dollar-slash ($/), then it
             is a UDC that is located in the same directory as
             the <code>.csm</code> or <code>.udc</code> file; and</li>
         <li>if <i>primtype</i> starts with a dollar-dollar-slash ($$/),
             then it is a UDC that is located in the ESP root
             directory.</li>
       </ul>

    <p>In case you are curious, a user-defined function (UDF) is just
       like a user-defined primitive (UDP), except it consumes one or
       more Bodys from the Stack; recall that UDPs do not consume any
       Bodys from the Stack.

    <p>The second through ninth arguments come in <i>name/value</i>
       pairs.  The <code>UDPRIM</code> statement has enough room to
       have four pairs of them.  But some UDPs and UDCs can have more
       than four possible arguments.  To get around this limitation,
       there is a companion <code>UDPARG</code> statement that must
       precede the <code>UDPRIM</code> statement, and must have the
       same <i>primtype</i>.  The pairs of <i>name/value</i>s are
       processed in order, with the last value being used.  Thus the
       codes:
      <pre>
        UDPRIM   supell   rx 3.0   ry 2.0   n 2.0
      </pre>
       and
      <pre>
        UDPARG   supell   rx 3.0
        UDPARG   supell   ry 2.0
        UDPRIM   supell   n  2.0
      </pre>
       and
      <pre>
        UDPARG   supell   rx 0.0   ry 8.0   n 3.0
        UDPARG   supell   rx 3.0   ry 2.0   n 2.0
        UDPRIM   supell
      </pre>
      are all equivalent.

    <p>There is one more point, specifically about UDCs.  UDCs come in
       two types:
      <ul>
        <li><i>include-type</i> in which the lines of the script in
            the <code>.udc</code> file are inserted into the script at
            the point at the location of the <code>UDPRIM</code>
            statement.  This is the type of UDC that we used in
            Tutorial 3.  These UDCs are identified by the statement
          <pre>
        INTERFACE  .  ALL
          </pre>
            at the top of the UDC; and</li>
        <li><i>function-type</i> in which arguments are passed into
            the UDC (like in a function in other languages) through
            statements in the UDC such as:
          <pre>
        INTERFACE name IN default
          </pre>
            and results are returned (like in a function in other
            languages) through statements in t he UDC such as:
          <pre>
        INTERFACE name OUT default
          </pre>
            The LocalVariables defined within the UDC have local scope
            (that is they are not shared with the script that called
            it).</li>
      </ul>

    <p>Before we return to the main tutorial, we will take a quick
       look at another popular UDP: <code>NACA</code>.  <b>File</b> and
       <b>Edit</b> and delete you current script and add:
       <pre>
         UDPRIM    naca   thickness 0.12   camber 0.04   sharpte 1

         UDPRIM    naca   thickness 0.06   camber 0.0    sharpte 1
         SCALE     0.6
         TRANSLATE 0.5  0.1  3.0

         RULE
       </pre>
       which makes a swept tapered wing with a sharp trailing edge.
       Note that without the <code>sharpte</code> option,
       the <code>NACA</code> UDP generates an airfoil with a blunt
       trailing edge, which is consistent with the original definition
       by NACA.

    <p><img src="pictures/tutorial4-05.png" width="100%"/>

    <p><h4>Adding a spindle</h4>

    <p>Now it it time to turn to Tutorial 4.  Press <b>File</b>,
       then <b>Open</b>, choose <code>../data/tutorial4</code>
       (or <code>..\data\tutorial4.csm</code>)and
       then <b>File</b> <b>Edit: ../data/tutorial4.csm</b> The first
       change is in lines 37 through 57:
      <pre>
        CFGPMTR   spindle:Cfront      2        # blend continuity at front transition
        LBOUND    spindle:Cfront      0
        UBOUND    spindle:Cfront      2
        CFGPMTR   spindle:Cback       2        # blend continuity at back  transition
        LBOUND    spindle:Cback       0
        UBOUND    spindle:Cback       2
        DESPMTR   spindle:rad_nose    0        # nose radius
        LBOUND    spindle:rad_nose    0
        DESPMTR   spindle:clear       0.1      # clearance between spindle and disk
        LBOUND    spindle:clear       0.0

        CONPMTR   spindle:nsect       4        # number of cross-sections
        DIMENSION spindle:xloc              1  spindle:nsect
        DIMENSION spindle:yrad              1  spindle:nsect
        DIMENSION spindle:zrad              1  spindle:nsect
        DIMENSION spindle:n                 1  spindle:nsect
        DESPMTR   spindle:xloc     "-4.0; -3.0; -1.0; +1.0;"   # x-locations
        DESPMTR   spindle:yrad     " 0.5;  0.5;  1.0;  1.0;"   # radii in y-direction
        LBOUND    spindle:yrad       0.0
        DESPMTR   spindle:n          5.0                       # super-ellipse power
        LBOUND    spindle:n          1.0
      </pre>
       which define the DesignParameters for the spindle.  (For now,
       ignore the <code>LBOUND</code> and <code>UBOUND</code>
       statements.)  Pay particular attention to lines 37 and 40:
      <pre>
        CFGPMTR   spindle:Cfront      2        # blend continuity at front transition

        CFGPMTR   spindle:Cback       2        # blend continuity at back  transition
     </pre>
       which define ConfigurationParameters.  Recall that a
       ConfigurationParameter is like a DesignParameter in all ways
       except that you cannot find the sensitivity with respect to it.
       We will see in a few minutes what <code>spindle:Cfront</code>
       and <code>spindle:Cback</code> are, and why it does not make
       sense to find the sensitivity with respect to them.

    <p>Line 48
      <pre>
        CONPMTR   spindle:nsect       4        # number of cross-sections
      </pre>
       defines a ConstantParameter, which must be a single number.  It
       has global scope, meaning that it is visible in the top-level
       script as well as any UDCs that may be loaded.

    <p>Lines 49 through 52
      <pre>
        DIMENSION spindle:xloc              1  spindle:nsect
        DIMENSION spindle:yrad              1  spindle:nsect
        DIMENSION spindle:zrad              1  spindle:nsect
        DIMENSION spindle:n                 1  spindle:nsect
      </pre>
       contain <code>DIMENSION</code> statements, which
       tell <code>ESP</code> to reserve enough space to hold a
       multi-valued parameter.  The first argument
       to <code>DIMENSION</code> is the name of the DesignParameter,
       ConfiguratonParameter, or LocalVariable; the second and third
       arguments are the number of rows and the number of columns,
      respectively.

    <p>Lines 53, 54, and, 56
      <pre>
        DESPMTR   spindle:xloc     "-4.0; -3.0; -1.0; +1.0;"   # x-locations
        DESPMTR   spindle:yrad     " 0.5;  0.5;  1.0;  1.0;"   # radii in y-direction

        DESPMTR   spindle:n          5.0                       # super-ellipse power
      </pre>
       assign the (multiple) values to their respective
       DesignParameters.  The values are separated by a semi-colon,
       and since there are spaces to improve readability, we need to
       enclose the whole argument in quotation marks (" ").  If there
       are more values given than the size of the parameter, the extra
       ones are ignored.  Similarly, if there are fewer values given,
       the last given value is used in all the remaining locations.
       So, in line 56, a single value (<code>5.0</code>) is given, and
      all four entries in <code>spindle:n</code> get that value.

    <p>Look at the <code>SET</code> statement in line 62
      <pre>
        SET       spindle:zrad   spindle:yrad
      </pre>
      This statement sets all of the <code>spindle:zrad</code> values
      to be the same as the <code>spindle:yrad</code> values.

    <p>The actual construction of the spindle occurs in lines 65
       through 95
      <pre>
        MARK

           # if a nose is given, create an initial point
           IFTHEN    spindle:rad_nose GT 0
              POINT  spindle:xloc-2*max(spindle:yrad,spindle:zrad)   0   0
           ENDIF

           PATBEG    isect  spindle:nsect
              IFTHEN    isect GT 1   AND   spindle:xloc[isect] LE spindle:xloc[isect-1]
                 MESSAGE   spindle:xloc[+isect+$]&lt;spindle:xloc[+(isect-1)+$]
                 THROW     -998
              ENDIF

              # basic cross-section
              UDPRIM supell   rx spindle:zrad[isect]   ry spindle:yrad[isect]   n spindle:n[isect]
              ROTATEY  90  0  0
              TRANSLATE spindle:xloc[isect]  0  0

              # add in extra copies for front transition continuity
              IFTHEN    isect EQ 2
                 PATBEG    icopy   2-max(spindle:Cfront,0)
                    RESTORE .
                 PATEND

              # add in extra copies for back transition continuity
              ELSEIF   isect EQ spindle:nsect-1
                 PATBEG    icopy   2-max(spindle:Cback,0)
                    RESTORE .
                 PATEND
              ENDIF
           PATEND
      </pre>
       First turn your attention to the pattern
       (outer <code>PATBEG</code> through <code>PATEND</code>).  It
       loops for <code>spindle:nsect</code> sections, and creates them
       with the <code>UDPRIM supell</code> statement in line 79:
      <pre>
         UDPRIM supell   rx spindle:zrad[isect]   ry spindle:yrad[isect]   n spindle:n[isect]
      </pre>
       Since the UDP creates the SheetBody in the <i>xy</i>-plane, and
       since we really want in in the <i>zx</i>-plane, we need
       to <code>ROTATEX</code> it 90 degrees and
       then <code>TRANSLATE</code> it to the correct location.

    <p>As was mentioned above, the <code>BLEND</code> command uses
       cubic BSplines to connect the sections.  By definition the cubic
       BSplines have continuous curvatures ("C2").  If we wanted to build
       a Body that had lesser continuity (slope continuity is "C1" and
       just point continuity is "C0"), we can do that
       in <code>BLEND</code> by repeating the sections.  The code in
       lines 84 through 94
      <pre>
        IFTHEN    isect EQ 2
           PATBEG    icopy   2-max(spindle:Cfront,0)
              RESTORE .
           PATEND

        # add in extra copies for back transition continuity
        ELSEIF   isect EQ spindle:nsect-1
           PATBEG    icopy   2-max(spindle:Cback,0)
              RESTORE .
           PATEND
        ENDIF
      </pre>
       allows you to control the continuity at the interior sections.
       If the user sets <code>spindle:Cfront</code> to <code>1</code>,
       then the <code>PATBEG</code> at line 85 executes once.
       The <code>RESTORE .</code> command puts another copy of the
       second cross-section (SheetBody) on the Stack;
       if <code>spindle:Cfront</code> is <code>0</code>, then two
       copies of the SheetBody are put on the Stack.  Lines 91 through
       93:
      <pre>
        PATBEG    icopy   2-max(spindle:Cback,0)
           RESTORE .
        PATEND
      </pre>
       do the same for the second-to-last cross-section.

    <p>To see how this works, first set <b>makeSpindle</b>
       to <code>-1</code> (more on his later) and <b>Press to
       re-build</b>. Try various combinations
       of <code>spindle:Cfront</code> and
       <code>spindle:Cback</code> and see how the spindle shape
       changes.

    <p><img src="pictures/tutorial4-06.png" width="100%"/>

    <p><img src="pictures/tutorial4-07.png" width="100%"/>

    <p><img src="pictures/tutorial4-08.png" width="100%"/>

    <p>A quick note: while it is possible to get a <code>RULE</code>d
       Body by using <code>BLEND</code> with all the interior SheetBodys
       duplicated twice, doing it this way is much less efficient and may
       cause problems in your build later on.  So it is best to use
       <code>RULE</code> if appropriate.

    <p>The concept of a Group is introduced in line 99:
      <pre>
        GROUP
      </pre>
       A Group is a collection of Bodys that work as a single entity
       in <code>STORE</code>, <code>RESTORE</code>, and all the
       transformations (such as <code>TRANSLATE</code>
       and <code>SCALE</code>).  It works by taking all the Bodys back
       to the <code>MARK</code> (in line 65), or to the bottom of the
       Stack if no <code>MARK</code> is found, and collects them.  The
       statement following the <code>GROUP</code> command
       is <code>STORE xsects 0 1</code> (in line 100),
       which <code>STORE</code>s the entire Group in storage "xsects
       0", and leaves a copy of the Group on the Stack (since the
       third argument is <code>1</code>).

    <p>The actual <code>BLEND</code> is done in lines 103 through 110:
      <pre>
        MARK
        RESTORE  xsects
        IFTHEN    spindle:rad_nose GT 0
           BLEND  "spindle:rad_nose; 0; 1; 0;\
                   spindle:rad_nose; 0; 0; 1"
        ELSE
           BLEND
        ENDIF
      </pre>
       First, the <code>MARK</code> is set, then a copy of the whole Group in
       "xsects 0" is placed in the Stack.  Then, most often,
       the <code>BLEND</code> in line 109:
      <pre>
        BLEND
      </pre>
       is executed to generate the <code>BLEND</code>.

    <p>By the way, if you are wondering why we made a copy of the
       Group of cross-sections, it was done so that you could see the
       original cross-sections, along with the <code>BLEND</code>,
       when you were looking above at the effect of
       changing <code>spindle:Cfront</code>
       and <code>spindle:Cback</code>.

    <p>There is one more complication in this code that will be
       explained now.  <code>BLEND</code> has the ability to be
       rounded over at either the beginning or end or both; the code
       here does it at the beginning of the <code>BLEND</code>.  The
       first thing that is required is a user-defined switch to turn
       this feature on and off.  This switch is defined in line 43:
      <pre>
        DESPMTR   spindle:rad_nose    0        # nose radius
      </pre>
       The second thing that needs to be done is in lines 68 to 70:
      <pre>
        IFTHEN    spindle:rad_nose GT 0
           POINT  spindle:xloc-2*max(spindle:yrad,spindle:zrad)   0   0
        ENDIF
      </pre>
       If the user specified a positive <code>spindle:rad_nose</code>,
       then a <code>POINT</code> is created upstream of the first
       cross-section.  The last step is the actual <code>BLEND</code>
       statement in lines 106 and 107:
      <pre>
        BLEND  "spindle:rad_nose; 0; 1; 0;\
                spindle:rad_nose; 0; 0; 1"
      </pre>
       If you get a <b>Hint</b> on the <code>BLEND</code>, you will
       see that the first (optional) argument is
       the <code>begList</code>; see the documentation in
       <a href="#sec5.4">Valid CSM statements</a> for a full
       description.

    <p>Once the spindle is created, it is <code>STORE</code>d away
       in line 123:
      <pre>
        STORE    Spindle
      </pre>

    <p>There is another feature of the code that also needs explanation
       here. You will notice that you were told above to
       set <code>makeSpindle</code> to <code>-1</code>.  If you read
      the comment on line 5:
      <pre>
        CFGPMTR   makeSpindle         1        # =-1 to make and stop, =0 to skip, =1 to make
      </pre>
      you will see why.  Specifically, if <code>makeSpindle</code>
       is <code>1</code> (the default), then the spindle is built; it
      is skipped via the <code>IFTHEN</code> statement in line 60:
      <pre>
        IFTHEN    makeSpindle NE 0
      </pre>
      if it is <code>0</code>.  But what happens if the user sets it
      to <code>-1</code>?  That little magic happens in lines 117 to
      120:
      <pre>
        IFTHEN    makeSpindle LT 0
           MESSAGE Stopping_after_spindle_generation
           THROW   -999
        ENDIF
      </pre>
      If <code>makeSpindle</code> is negative, then
      a <code>MESSAGE</code> is posted in the MessageWindow and a
      signal -999 is <code>THROW</code>n.  The effect
      of <code>THROW</code>ing this signal is that all following
      statements are skipped until the matching <code>CATCH</code> is
      encountered in lines 259 and 260:
      <pre>
        CATBEG    -999
        CATEND
      </pre>
      There is nothing between these two statements, except that the -999
      signal is canceled.  The net effect is that the build will not
      be considered a failure.  (In retrospect, it might have been
      better to put the <code>MESSAGE</code> statement between
      the <code>CATBEG</code> and <code>CATEND</code>, but the code as given
      here works nonetheless.)

    <p>Lastly, once the spindle is created, a hole (with a specified clearance,
       <code>spindle:clear</code>) needs to be placed in the overall
       tire-like Body (SolidModel) to make room for the spindle.  This
       is done by lines 196 to 199
       <pre>
         RESTORE   Spindle

         HOLLOW    +spindle:clear
         SUBTRACT
       </pre>
       which first puts a copy of the Spindle on the Stack, then
       "grows" the copy by <code>spindle:clear</code> via
       the <code>HOLLOW</code> command, and
       finally <code>SUBTRACT</code>s the grown Body from the
       SolidModel.

    <p><h4>Adding error checking</h4>

    <p>The writer of an <code>ESP</code> model often knows something
       about some of the DesignParameters and ConfigurationParameters,
       and writes the model with that knowledge in mind.  In order to
       protect the model from bad user inputs, one can
       add <code>LBOUND</code> and <code>UBOUND</code> statements.  If
       these are present, <code>ESP</code> will check to make sure
       that the user does not violate these bounds.  Near the top of
       the <code>tutorial4.csm</code> there are several such
       statements, such as in lines 38 and 39:
      <pre>
        LBOUND    spindle:Cfront      0
        UBOUND    spindle:Cfront      2
      </pre>
       which restrict the user to consider only C0, C1, or C2
      continuity in the <code>BLEND</code> while making the Spindle.

    <p>More (run-time) error checking is done by lines 73 through 76
      <pre>
        IFTHEN    isect GT 1   AND   spindle:xloc[isect] LE spindle:xloc[isect-1]
           MESSAGE   spindle:xloc[+isect+$]&lt;spindle:xloc[+(isect-1)+$]
           THROW     -998
         ENDIF
      </pre>
       which check that the <code>spindle:xloc</code>s are
      monotonically increasing.

    <p><h3 id="sec2.5">2.5 Fifth Tutorial: Multi-models</h3>

    <p>This fifth tutorial introduces the concept of
       a <i>multi-model</i>, which is a series of models that are
       driven by the same set of Configuration and DesignParameters,
       and which have Node, Edge, and Faces marked with Attributes so
       that some later analysis will know how to transfer data from
       one model (for example, for a CFD solver) to another (for
       example, a structural solver).

    <p>For the current Tutorial, two models will be created:
      <ul>
        <li><i>SolidModel</i> is the model that we developed in
            Tutorials 2 through 4; and</li>
        <li><i>SheetModel</i>, which a a SheetBody of the
            center-plane of the disk and the tread Faces.</li>
      </ul>

    <p>Press <b>File</b>, <b>Open</b>, and
       select <code>../data/tutorial5</code>
       (or <code>..\data\tutorial5</code>).

    <p>The first big change (relative to <code>tutorial4</code>) is
       in lines 170 to 178:
      <pre>
        UDPARG    supell   rx tire:diam_outer/2   ry tire:diam_outer/2
        UDPRIM    supell   n  2
        ATTRIBUTE myTag  $disc
        ROTATEY   90     0  0

        SELECT    FACE
        ATTRIBUTE myPart $disk

        STORE     disc
      </pre>
      Here we create a circular SheetBody via the <code>supell</code>
      UDP, put a <code>myTag</code> Attribute on
      it, <code>ROTATEY</code> it, give the (only) Face
      a <code>myPart</code> Attribute, and <code>STORE</code> it away.

    <p>The next major change is in lines 264 to 276:
      <pre>
        RESTORE   SolidModel
        SELECT    FACE  $myTag  $tread
        EXTRACT   @sellist

        # split the SheetBody into 4 pieces (so that its Nodes line up with the discs Nodes)
        BOX       -2*tire:diam_outer  0  -2*tire:diam_outer \
                   4*tire:diam_outer  0   4*tire:diam_outer
        SUBTRACT

        # union this with the disc into a complete skeleton
        RESTORE   disc
        JOIN      1e-2
        STORE     SheetModel
      </pre>
      It begins by <code>EXTRACT</code>ing the Faces from the
      SolidModel that have a <code>myTag</code> Attribute whose value
      is the string <code>tread</code>.  This is done
      by <code>SELECT</code>ing those Faces (which puts their Face
      number into the AtParameter <code>@sellist</code>), and then
      using the <code>@sellist</code> in the <code>EXTRACT</code>
      command.

    <p>We eventually want to <code>JOIN</code> these Faces to the disk
       created above, but we have a problem.  Recall
       that <code>JOIN</code> expects there to be a match between
       either Edges or Faces in the Bodys that are to
       be <code>JOIN</code>ed.  You will see that the disk has four
       Edges (and four Nodes), whereas the treads that we just
       <code>EXTRACT</code>ed only have two circumferentially.  To get
       around that, we need to split the tread Faces; this can be done
       with the <code>SUBTRACT</code> command.  Specifically, if you
       have two SheetBodys that are not co-planar, then the result of
       the <code>SUBTRACT</code> will be the first input SheetBody
       that has been "scribed" at the places where it intersects the
       second Body.  We do that here in lines 269 to 271:
       <pre>
         BOX       -2*tire:diam_outer  0  -2*tire:diam_outer \
                    4*tire:diam_outer  0   4*tire:diam_outer
         SUBTRACT
       </pre>

    <p>In lines 274 to 276:
      <pre>
        RESTORE   disc
        JOIN      1e-2
        STORE     SheetModel
      </pre>
       the "disc" that was <code>STORE</code>d above
       is <code>RESTORE</code>d and <code>JOIN</code>ed with the tread
       Faces.  Finally the whole SheetModel is <code>STORE</code>d
       away.

    <p>The only other change is in lines 279 to 290:
      <pre>
        IFTHEN    theView EQ 1  OR  theView EQ 3
           RESTORE          SheetModel
           ATTRIBUTE _name $SheetModel
        ENDIF
        IFTHEN    theView EQ 2  OR  theView EQ 3
           RESTORE          SolidModel
           ATTRIBUTE _name $SolidModel
           RESTORE          Spindle
           ATTRIBUTE _name $Spindle
           CATBEG    $name_not_found    # needed for cases where spindle was not created
           CATEND
        ENDIF
      </pre>
       which put the appropriate Bodys on the Stack.  This is done via
       the <code>theView</code> DesignParameter, which is defined in
       line 5.  By now, most of the code in lines 279 to 290 should be
       self-explanatory.  The only exception might be lines 288 and
       289:
      <pre>
        CATBEG    $name_not_found    # needed for cases where spindle was not created
        CATEND
      </pre>
       If the user had set <code>makeSpindle</code>
       to <code>0</code>, then the spindle would not have been created
       and the <code>RESTORE</code> command in line 286 would have
       raised the <code>name_not_found</code> signal.
       The <code>CATBEG</code> statement catches (and cancels) that
      signal so that the rest of the script can be executed.

    <p>As you can see by going through these tutorials, writing
       an <code>ESP</code> script is not too difficult, if you do it step
       by step.  That is how this Tutorial script was developed: step
      by step.

    <p>Most of the scripts that you write initially will be
       much simpler than the script that we used here.   Feel free to
       use the <b>Hint</b> button in the script editor, look up the
       commands in this Help document (below), use
       the <Code>ESP_QuickReference</code>, and contact the authors
       if you are not sure how to do something.  It is only by
       frequent contact with the users that <code>ESP</code> can be
       made better for the kinds of things that you want to do.

    <p><h3 id="sec2.6">2.6 Sixth tutorial: Integrated Design Environment</h3>

    <p>This tutorial uses <code>ESP</code>'s Integrated Design
       Environment (IDE), which allows a user to incrementally build
       geometric models and perform analyses via the Computational
       Aerospace Prototype Syntheses (<code>CAPS</code>) system.  The
       goals of this new IDE are to:
      <ul>
        <li>be a tool that can be used by all individuals involved
            in a design and its processes</li>
        <li>be a central repository of all design data, including
            mission and functional requirements</li>
        <li>provide a mechanism for the user to document the "how" and
            "why" design decisions were made</li>
        <li>allow geometric models to evolve over time</li>
        <li>maintain history of the evolving design and design
            decisions</li>
        <li>support user-written workflows via Python scripts</li>
        <li>support various optimization schemes and provide
            sensitivities when available</li>
        <li>allow a user to suspend a session and be able to restart
            (including after an abort)</li>
        <li>give user methods to interactively visualize the geometry and
            analysis results at any stage of the design</li>
        <li>allow the user to generate simple graphs</li>
        <li>support branching, merging, and pruning of the design decision
            tree</li>
        <li>allow collaboration by geographically-dispersed users</li>
     </ul>

    <p>Work in the IDE is organized in Phases, which are the atomic pieces of
       work that keep track of a design as it evolves from a very
       simple initial concept through its final design.  A Phase keeps
       track of the evolution of the geometric model
       (in <code>ESP</code> </code>.csm</code> files) as well as the
       Python scripts that tie the geometric model with analysis
       software through the <code>CAPS</code>
       system.  <code>CAPS</code> includes links to analysis software
       such a Computational Fuild Dynamics (CFD) and Finite Element
       Analysis (FEA) programs.  (We will be using the Athena Vortex
       Lattice (AVL) analysis later in this tutorial.)

    <p>In many ways, a Phase resembles the version-control snapshots
       (or commits) of a software project in a revision-control system
       such as Git or Subversion.  Like these version-control systems,
       the Phases in the IDE can be organized in Branches, and are
       named with the Branch number, followed by a dot, followed by
       the Revision number.  The first Phase is always named "1.1",
       which means the first Revision on the first Branch.  Subsequent
       Phases in the main Branch are numbered sequentially, such as
       "1.2", "1.3", etc.  The Branches are also numbered
       sequentially, and always start at revision 1, such as "2.1".
       All Phases (except "1.1") have a parent Phase, which is either
       the prior Revision in the current Branch or the Branch.Revision
       from which a new Branch was greated. For example, the parent of
       Phase "3.6" is always "3.5".  The parent of the first Revision
       of any Branch can be any previously existing Phase.

    <p>A Phase can be in several states:
      <ul>
        <li><b>Closed</b> - which means that the Phase is complete and
            cannot be changed (much like a "commit" in a
            version-control system).  A Closed Phase can be used as the
            starting point for any new Phase;</li>
        <li><b>Open</b> - which means that further work can be done on
            the Phase.  Note that only the last Revision in any Branch
            can be Open; and</li>
        <li><b>Locked</b> - which is just like an Open Phase, except
            it was not properly suspended or in use by another
            session; this can happen when something
            in <code>serveESP</code> or in an analysis executed from
            the IDE crashes or is killed in some way.  When trying to
            access a Locked Phase, the user will be asked if they want
            to steal the lock.  If they answer "yes", then the Phase
            can be editted just like any Open Phase.</li>
      </ul>

    <p>When working on a Phase in the IDE, a user has four options to
       leave the Phase:
      <ul>
        <li><b>Caps->CommitPhase</b> - which closes the phase (and
            cannot be further editted);</li>
        <li><b>Caps->QuitPhase</b> - which removes all the work done
            during the Phase from the system.  It also removes the
            .csm from <code>ESP</code>, which can be re-loaded
            with <b>File</b> and <b>Open</b>;</li>
        <li><b>Caps->SuspendPhase</b> - which leaves the Phase Open
            (and can be further editted); and</li>
        <li>close <code>serveESP</code> while the IDE is still active,
            which is equivalent to explicitly suspending the Phase.</li>
      </ul>
      Also, as noted above, in the event that the program crashes or
      is killed, the Phase will be left Locked (but otherwise Open).

    <p><h4>Design problem</h4>

    <p>The design exercise that we will be looking at in this tutorial
       is a rubber-powered, hand-launched aircraft that carries golf
       balls.  The design will be scored as the product of the square
       of the time aloft beyond 3 seconds and the number of golf balls
       carried.

    <p><h4>First model (simple rectangular wing)</h4>

    <p>We are going to start this tutorial by clicking on
       the <code>ESP_121</code> icon on the Desktop.  (Note that since
       we be re-entering <code>serveESP</code> several times and will
       using the <code>phaseUtil</code> program, it is not advisable
       to use the <code>runESP_121</code> icon for this tutorial.)

    <p>After clicking the <code>ESP_121</code> icon, a terminal window
       will open. Since there will be lots of files used in this
       tutorial, it is convenient to set an environment varaible that
       tells <code>serveESP</code> where to find the various files that
       we will be using.  Issue the command:
<pre>
        setenv ESP_PREFIX ../data/tutorial6/       (in a tcsh on Mac or LINUX)
</pre>
       or
<pre>
        export ESP_PREFIX=../data/tutorial6/       (in a bash shell on Mac or LINUX)
</pre>
       or
<pre>
        set ESP_PREFIX=..\data\tutorial6\          (on Windows)
</pre>

    <p><b>Special note:</b> In what follows, the separator between a
       file and its directory (folder) will be shown as a
       forward-slash (<code>/</code>).  If you are using Windows,
       please use the back-slash (<code>\</code>) instead.

    <p>We will start the tutorial by using a very simple wing model.
       Start the program by typing:
<pre>
       serveESP ../data/tutorial6/model1.csm
</pre>
    <p>You will see the normal <code>ESP</code> screen, which looks
       like:
    <p><img src="pictures/tutorial6-01.png" width="100%"/>

    <p>Note that the <code>ESP</code> window looks the same as in the
       previous tutorials and that you can do anything you want with
       the model.

    <p>To examine the <code>.csm</code> file (which is used to define
       the geometric model), click on <b>File</b> and <b>Edit:
       ../data/tutorial6/model1.csm</b>, which will open the code editor.

    <p>Notice that we have four Design Parameters
       ("wing:area", "wing:aspect", "wing:thick", and "wing:camber"), each
       with its own default values, defined in lines 8 through 11 by:
<pre>
        DESPMTR   wing:area    20.0
        DESPMTR   wing:aspect   4.0
        DESPMTR   wing:thick   0.01
        DESPMTR   wing:camber  0.06
</pre>
       Note that the prefix "wing:" is not essential, but
       helps to organize the Design Parameters in the <code>ESP</code>
       viewer.

    <p>This is followed by lines 14 through 17:
<pre>
        SET       wing:span    sqrt(wing:area*wing:aspect)
        SET       wing:chord   wing:area/wing:span

        OUTPMTR   wing:span
</pre>
       which compute the "span" and "chord" from the area and aspect
       ratio, and further makes the "span" an Output Parameter, which
       means that its value is accessible outside the model build
       process.

    <p>The actual build is done in lines 20 to 27:
<pre>
        UDPARG    naca         thickness wing:thick
        UDPARG    naca         camber    wing:camber
        UDPRIM    naca         sharpte   1
        ROTATEX   90
        SCALE     wing:chord
        TRANSLATE 0   -wing:span/2   0

        EXTRUDE   0    wing:span     0
</pre>
       which generates a NACA airfoil, ROTATEs it to the <em>x-z</em>
       plane, SCALEs it by the "chord", TRANSLATEs it half the "span",
       and then EXTRUDEs it for the full "span".  This is technique is
       not the traditional way of creating a wing, but is used here
       for illustriative purposes.  Press the <b>Cancel</b> button to
       get the view shown above.

    <p>We are now going to enter the IDE by
       pressing <b>Tool</b> and <b>Caps</b>.  The first thing you are asked for is
       the name of your project, optionally followed by a colon
       (":") and the Branch number, then optionally followed by
       a dot (".") and the Revision number, all optionally
       followed by an asterisk ("*").  If the Branch is not
       given, it defaults to Branch 1; if a Revision is not given, it
       defaults to the last Revision in the Branch.  The asterisk
       tells the IDE to ignore the model currently on the screen, and
       instead use the model associated with the Branch.Revision given
       (or implied).  More on this later.

    <p>For this tutorial, we are going to call the project "ostrich"

    <p><img src="pictures/tutorial6-02.png" width="100%"/>

    <p>We then get another prompt that asks us to describe the intent
       (our intention) during this Phase.  This information is saved
       by the system and displayed at various times.  For this
       tutorial, our intent will be "initial sizing of rectangular
       wing", as in:
    <p><img src="pictures/tutorial6-03.png" width="100%"/>

    <p>Note the changes to the display:
      <ul>
        <li>there is a green button at the top of the TreeWindow that
            can be pressed to execute various of the IDE
            functions;</li>
        <li>there is a yellow rectange that shows the name of the
            project, the current Branch (in this case "1"),
            and the current Revision (in this case
            also "1");</li>
        <li>there is a new entry, <b>Caps Values</b>, in the tree;
            and</li>
        <li>the <b>Branches</b> entry is not in the tree (since the
            user cannot manipulate the geometric build process while
            in the IDE).</li>
      </ul>

    <p>The first thing we are going to do is to create a CapsValue
       named "nball".  This is done (in an analogous way to
       creating a new DesignParmeter) by pressing on the words <b>Caps
       Values</b>, entering the name "nball", entering the
       value "1" in the form, and then pressing
       the <b>OK</b> button.

    <p>We can also add a row-vector by pressing <b>Caps Values</b>,
       entering the name "badValue", pressing the <b>Add
       column</b> button twice, and then filling in the values, such
       as:
    <p><img src="pictures/tutorial6-04.png" width="100%"/>
       We can press <b>OK</b> to save our change.  If we then
       press <b>ExpandAll</b> to the right of <b>Caps Values</b>
       and <b>Design Parameters</b>, we should see:
    <p><img src="pictures/tutorial6-05.png" width="100%"/>
       Note that the "wing:area" is "20"
       and "wing:aspect" is "4", as was
       prescribed in the <code>.csm</code> file.

    <p>Now we are going to maniulate the model in <code>CAPS</code>
       (via its Python interface called <code>pyCAPS</code>).  This is
       done by pressing <b>Tool</b> followed by <b>Pyscript</b>, which
       brings up a prompt that looks like:
    <p><img src="pictures/tutorial6-06.png" width="100%"/>
       You can enter "../data/tutorial6/sizeWing.py".  By
       the way, if you leave the <code>.py</code> extension off, the
       IDE will provide it for you.

    <p>Lines 1 through 7 are typical Python comments that describe the
       purpose of the file:
<pre>
        ###################################################################
        #                                                                 #
        # sizeWing.py - pick (S, AR, V) to maximize L/D                   #
        #                                                                 #
        #              Written by John Dannenhoffer @ Syracuse University #
        #                                                                 #
        ###################################################################
</pre>

    <p>Lines 10 and 11 get the Python script access to the various
       needed Python libraries:
<pre>
        import pyCAPS
        from   pyOCSM import esp
</pre>

    <p>As we will see below, we need to take the square-root of a
      number, so line 14 gives us access to Python's math library:
<pre>
        import math
</pre>

    <p>The first real interaction with <code>CAPS</code> occurs in
      lines 17 to 19:
<pre>
        myProblem = pyCAPS.Problem(problemName = "RunWithoutESP",
                                   capsFile    = "../data/tutorial6/model1.csm",
                                   outLevel    = 1)
</pre>
    <p>These lines are interpreted differently if running in the IDE
       or if running from a stand-alone Python prompt:
      <ul>
        <li>if running in the IDE, these lines simply tell Python to
            generate a handle to the <code>CAPS</code> problem that is
            currently running, and to call that
            handle "myProblem"; or</li>
        <li>if running from a Python prompt, create a
            new <code>CAPS</code> problem
            named "RunWithoutESP", using
            the <code>.csm</code> file
            named "../data/tutorial6/mode1.csm", and
            to use "myProblem" as its handle.</li>
      </ul>

    <p>In this script, the wing is sized by doing a full-factorial
       design of experiments, with the independent variables being
       wing area, aspect ratio, and cruise velocity.  The value that
       is being maximized is the lift-to-drag ratio.

    <p>We start off in lines 22 to 28 by defining the density of air,
       the weight of a ball, the fixed weight of the aircraft, a
       wing-weight mutiplier, the zero-lift drag coefficient, target
       oswald efficiency factor, and maximum lift coefficient:
<pre>
        rho      = 0.002377       # slug/ft3
        Wball    = 0.10           # lb/ball
        Wfixed   = 0.02           # lb
        Wwing    = 0.03           # lb/ft3
        CD0      = 0.04
        oswald   = 0.90
        CL_max   = 1.00
</pre>

    <p>Lines 31 to 34:
<pre>
        if ("nball" in myProblem.parameter):
            nball = myProblem.parameter["nball"].value
        else:
            nball = 2
</pre>

        are used to create a local Python variable, "nball",
        from the CapsValues (if it exists) or to use a default value
        of "2".  The value is then printed in the
        MessageWindow by:
<pre>
        print("nball", nball)
</pre>

    <p>Before the full-factorial search, we need to initialize the
       best-we-have-seen-so-far in lines 39 to 44:
<pre>
        S_best   = 0
        AR_best  = 0
        V_best   = 0
        W_best   = 0
        CL_best  = 0
        LoD_best = 0
</pre>

    <p>The full-factorial search is carried out in lines 47 to 66:
<pre>
        for S in [0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75, 2.00, 2.25, 2.50, 2.75, 3.00]:
            for AR in [3, 4, 5, 6, 7, 8]:
                for V in [2.5, 5.0, 7.5, 10.0, 12.5, 15.0, 17.5, 20.0]:

                    # compute performance
                    b   = math.sqrt(S * AR)
                    q   = 0.5 * rho * V**2
                    W   = Wfixed + nball * Wball + S * b * Wwing
                    CL  = W / (q * S)
                    CD  = CD0 + CL**2 / (math.pi * AR * oswald)
                    LoD = CL / CD

                    # save if best result so far
                    if (LoD > LoD_best and CL <= CL_max):
                        S_best   = S
                        AR_best  = AR
                        W_best   = W
                        V_best   = V
                        CL_best  = CL
                        LoD_best = LoD
</pre>
       where we start with the three nested loops, we compute the
       performance (lift-to-drag ratio), and then remember this case
       if it is the best we've seen so far.

    <p>Then the "best" results are reported to the user in the
        MessageWindow by:
<pre>
        print("S_best  =", S_best  )
        print("AR_best =", AR_best )
        print("W_best  =", W_best  )
        print("V_best  =", V_best  )
        print("CL_best =", CL_best )
        print("LoD_best=", LoD_best)
</pre>
    <p>Finally the best results are returned to the IDE by lines 77 to
       83:
<pre>
        myProblem.geometry.despmtr["wing:area"  ].value = S_best
        myProblem.geometry.despmtr["wing:aspect"].value = AR_best

        if "CLcruise" in myProblem.parameter:
            myProblem.parameter["CLcruise"].value = CL_best
        else:
            myProblem.parameter.create("CLcruise", CL_best)
</pre>
       The first two lines update the DesignParameters and then the
       last 4 lines either update the "CLcruise" if it already exists
       or creates a new CapsValue and sets its value.

    <p>If we <b>ExpandAll</b> the CapsValues and DesignParameters, we
       should see:
    <p><img src="pictures/tutorial6-07.png" width="100%"/>

       Note that the values in the TreeWindow have been updated
       (the "wing:area" is "2" and the
       "wing:aspect" is "8", but that the image
       has not been updated, since <code>CAPS</code> only re-builds
       the geometry on demand; that is, the geometry is only rebuilt
       when a downstream process needs the geometry to be updated.

    <p>One such downstream process is leaving the IDE.  We are going
       to do this now by pressing <b>Caps</b>, followed by <b>Commit
       Phase</b>.  This will both Close this Phase (so that no further
       edits can be done to it) and will update the geometry, as in:
    <p><img src="pictures/tutorial6-08.png" width="100%"/>

    <p>We have now returned to the normal <code>ESP</code> display.

    <p>Now, let's say that we want to remove the "badValue"
       that we created earlier.  To do this, we can
       enter <code>CAPS</code> again by pressing <b>Caps</b>, entering
       "ostrich" as our project, and "mark badValue for deletion" as
       our intent phrase.  Note that since we only entered "ostrich"
       above, it was assumed to be on Branch "1" and to
       start after the last Revision ("1").  (We could have
       had a similar result by entering "ostrich:1" or "ostrich:1.1")

    <p> Once we are back in the IDE, we can press <b>Tool</b> and
        <b>Pyscript</b> on the
        file "../data/tutorial6/stub.py".
    <p><img src="pictures/tutorial6-09.png" width="100%"/>
        Lines 9 through 16 are the usual hook-up to <code>CAPS</code>:
<pre>
        # get access to pyCAPS
        import pyCAPS
        from   pyOCSM import esp

        # if running in serveESP, the following load is ignored
        myProblem = pyCAPS.Problem(problemName = "RunWithoutESP",
                                   capsFile    = "../data/tutorial6/model1.csm",
                                   outLevel    = 1)
</pre>

    <p>Line 20 is commented out:
<pre>
        #--- myProblem.parameter["badValue"].markForDelete()
</pre>
        but we want it un-commented (since we want to
        mark "badValue" for deletion).  This is done by
        placing the cursor somewhere on Line 20 and pressing
        the <b>Comment</b> button.  This function looks at the first
        highlighted line, and if it is a comment, it un-comments the
        whole highlighted region.  Alternatively if the first line in
        the highligted region is not a comment, the region is
        commented.  We can use this to comment the lines:
<pre>
        myProblem.analysis["skeletonAIM_1"].markForDelete()
        myProblem.analysis["skeletonAIM_2"].markForDelete()
        myProblem.bound["upperWing"].markForDelete()
</pre>
       by highlighting them and pressing <b>Comment</b>, yielding:
    <p><img src="pictures/tutorial6-10.png" width="100%"/>

    <p>We can execute this script by pressing the <b>Save and run</b>
       button.  You can look at the bottom of the screen (in the
       MessageWindow) and see that the pyscript completed successfully.

    <p>If you <b>ExpandAll</b> the CapsValues, you will see
       that "badValue" is still there, but will be deleted
       when the Phase is Committed.

    <p>Now let us look at two other commands that become available
       when you press the  <b>Caps</b> button:
      <ul>
        <li><b>List Phases</b> lists all the Phases in the current
            project in the MessageWindow; and</li>
        <li><b>List Analyses</b> lists all the Analyses in the current
          project.</li>
      </ul>
    <p><img src="pictures/tutorial6-11.png" width="100%"/>

    <p>If you look in the MessageWindow, you will see that there are
       two Phases:
      <ul>
        <li>Phase 1.1 has a dash to its left, indicating that it is
            a predecessor of the current Phase; and</li>
        <li>Phase 1.2 has an asterisk to its left, indicating that it
          is the current Phase.</li>
      </ul>
       The MessageWindow also says that we do not yet have any active
       Analyses (yet).

    <p>We are going to commit the Phase by pressing <b>Caps</b>
       and <b>Commit Phase</b>

    <p><h4>Second model (simple tapered wing)</h4>

    <p>In a real design environment, the design process can take days
       or weeks to execute, and so to simulate that we are gong to
       exit <code>serveESP</code> by closing the browser and then
       opening <code>serveESP</code> again by typing:
      <pre>
        serveESP ../data/tutorial6/model2a
      </pre>
       or its equivalent.  You will notice that we are
       starting <code>serveESP</code> with a different model file,
       which is a slightly different representation of the same wing.
       Expanding the Design Parameters shows that we have a new
       DesignParameter called "wing:taper", which is
       initialized to "1".

    <p><img src="pictures/tutorial6-12.png" width="100%"/>

       To see  the differences between this new file (model2a)
       and the original file (model1), press <b>File</b>
       and <b>model2a.csm</b>.  The new DesignParameter
       ("wing:taper") is defined in line 10:
      <pre>
        DESPMTR   wing:taper   1.00
      </pre>
       Lines 15 through 18 are slightly different from before:
      <pre>
        SET       wing:span    sqrt(wing:area*wing:aspect)
        SET       wing:croot   wing:area/wing:span*2/(wing:taper+1)
        SET       wing:ctip    wing:croot*wing:taper
        SET       wing:xtip   (wing:croot-wing:ctip)/2
      </pre>
       where the differences account for the fact that the wing root
       chord and wing tip chord are related by the taper ratio.

    <p>The big difference is in the construction of the wing in lines
       26 through 46:
      <pre>
        MARK
           # left tip
           UDPARG    naca         thickness wing:thick
           UDPARG    naca         camber    wing:camber
           UDPRIM    naca         sharpte   1
           ROTATEX   90
           SCALE     wing:ctip
           TRANSLATE wing:xtip   -wing:span/2   0

           # root
           UDPARG    naca         thickness wing:thick
           UDPARG    naca         camber    wing:camber
           UDPRIM    naca         sharpte   1
           ROTATEX   90
           SCALE     wing:croot

           # rite tip
           UDPARG    naca         thickness wing:thick
           UDPARG    naca         camber    wing:camber
           UDPRIM    naca         sharpte   1
           ROTATEX   90
           SCALE     wing:ctip
           TRANSLATE wing:xtip   +wing:span/2   0
        RULE
      </pre>

    <p>Instead of an EXTRUDE, the new construction will be a RULE
       between the left tip cross-section, the root cross-section, and
       the right-tip cross-section.  The left-tip cross-section is a
       NACA airfoil (in lines 25 through 27), that is ROTATEd, SCALEd,
       and TRANSLATEd as before in lines 28 through 30.  Similar
       statements create the root and right-tip cross-sections.  These
       three cross-sections are then RULEd together by line 46 (back
       to the MARK in line 23). Hit <b>Cancel</b> to get out of the
       code editor.

    <p>In order to find the "optimal" taper, we are going to vary the
       taper ratio to get the maximum Oswald efficiency factor, as
       predicted by the Athena Vortex Lattice (AVL) method.  The
       representation of the aircraft that AVL uses as its input is
       simply cross-sections that describe the various lifting
       surfaces. To see how to do this, we will be modifying our
       model, as is done in "model2b.csm".
       Press <b>File</b> and <b>Open</b> and
       enter "../data/tutorial6/model2b" and a new model
       should appear on the screen, which has 4 Bodys; one Body is the
       outer mold line (OML) and the other three are the
      cross-sections for AVL.

    <p>The changes to the <code>.csm</code> file start in lines 12 and
       13:
      <pre>
        CFGPMTR   view:OML      1
        CFGPMTR   view:AVL      1
      </pre>
       which define ConfigurationParameters that tell if we want to
       view the OML and if we want to view the AVL cross-sections.
       As you can see, both of these are non-zero, and hence we see
       the 4 Bodys on the display.

    <p>The next set of changes is (for example) in line 39:
      <pre>
           STORE     wing  -1  1
      </pre>
       which STOREs a copy of the cross-section in the first available
      "wing" storage location (which in this case is "0").  The final
      "1" in the STORE command says to leave a copy of the Body on the
      stack (so that it can be used by the subsequent RULE).  Similar
      storage is done in lines 47 and 56.  Line 58:
      <pre>
        STORE     OML
      </pre>
      STOREs the OML after it has been created.

    <p>Lines 61 to 68:
      <pre>
        IFTHEN view:AVL NE 0
           RESTORE  wing -1
        ENDIF

        # to view OML, restore the OML
        IFTHEN view:OML NE 0
           RESTORE   OML
        ENDIF
      </pre>
      are used to RESTORE the Bodys that we want left on the stack.
      Note that the RESTORE in line 62 RESTOREs all the AVL sections
      (as indicated by the second argument being "-1").
      Press <b>Cancel</b> to get out of the code editor.

    <p>The final thing that we need to do to run AVL is to add
       Attributes as done in <code>model2c.csm</code>.  To get this
       file into <code>ESP</code> we are going to use a slightly
       different process from above.  Press <b>File</b> and
       then <b>Edit: &lt; new file&gt;</b>, to give you a
       blank <code>.csm</code> file.  Press the <b>Insert</b> button
       at the top of the editor and
       enter "../data/tutorial6/model2c.csm" in the prompt
       that appears.

    <p>The first set of differences can be seen in lines 38 to 40,
       lines 50 to 52, and lines 61 to 63:
      <pre>
              ATTRIBUTE capsAIM           $avlAIM
              ATTRIBUTE capsIntent        $wing
              ATTRIBUTE capsGroup         $wing
      </pre>
       which set Attributes on the airfoil sections immediately after
       they are created.  Creating Attributes as early as possible is a
       best practice in using <code>ESP</code>.  You can look at the
       documentation of the AVL Analysis Interface Module (AIM) in
       the <code>ESP</code> documentation suite for full details on
       these Attributes.

    <p>The next difference is in line 69:
      <pre>
              ATTRIBUTE capsGroup    $wing
      </pre>
      which attributes the OML and then in lines 75 to 78:
      <pre>
              ATTRIBUTE capsReferenceArea  wing:area
              ATTRIBUTE capsReferenceSpan  wing:span
              ATTRIBUTE capsReferenceChord wing:croot
              ATTRIBUTE capsReferenceX     wing:croot/4
      </pre>
      which set the reference quatities that AVL will need.

    <p>Press <b>Save</b> to exit the code editor.
       Since <code>ESP</code> does not know the name of the new file,
       it prompts you for it; enter "model2.csm" (which
       will save the file in your current working directory).

    <p>Notice in the TreeWindow that we have four Bodys.  If we turn
       the visibility of Body 22 (the OML) off by pressing
       the <b>Viz</b> to the right of <code>Body 22</code> we will see
       the tip and root cross-sections, which after rotating the
       display looks like
    <p><img src="pictures/tutorial6-13.png" width="100%"/>

    <p>Turning the visibility of Body 22 back on gives:
    <p><img src="pictures/tutorial6-14.png" width="100%"/>

    <p>The first thing we need to do is to hook up to
       our <code>CAPS</code> project by pressing <b>Tool</b>
       and <b>Caps</b> and entering "ostrich" as our
       project name.  When asked for our intent, enter "find
       taper to maximize oswald".  You will notice in the
       MessageWindow that it says that "CAPS overrides .csm value for
       wing:area", and "wing:aspect" and that the updated values are
       shown in the dislay.
    <p><img src="pictures/tutorial6-15.png" width="100%"/>

    <p>In order to "optimize" the taper, we are going to execute AVL
       for taper ratios from 0.2 to 1.0 and are going to remember the
       "best".  A script that does this can be launched by
       pressing <b>Tool</b> and <b>Pyscript</b> and
       typing "../data/tutorial6/optTaper.py".  As you
       can see in the code editor, lines 10 through 18 are the usual
       hook-ups to the model currently in <code>ESP</code>.

    <p>Lines 21 through 25:
      <pre>
        if ("avl" in myProblem.analysis):
            avl = myProblem.analysis["avl"]
        else:
            avl = myProblem.analysis.create(aim  = "avlAIM",
                                            name = "avl")
      </pre>
      either get access to an AVL AIM named "avl" (from a previous
      analysis), or create a new AVL AIM.  In both cases, the python
      variable "avl" is a handle to the AIM.

    <p>Then in lines 28 through 31:
      <pre>
        if ("CLcriuse" in myProblem.parameter):
            avl.input["CL"].value = myProblem.parameter["CLcruise"].value
        else:
            avl.input["CL"].value = 0.95
      </pre>
       we get the target cruise lift coefficient, either from the
       CapsValue we set earlier (when we ran
       "../data/tutorial6/sizeWing.py") or using the default value of 0.95.
       Other inputs needed by AVL are given in lines 33 to 36:
      <pre>
        avl.input["Mach"].value = 0
        avl.input["Beta"].value = 0
        avl.input.AVL_Surface   = {"wing" : {"numChord"     : 4,
                                             "numSpanTotal" : 24}}
      </pre>

    <p>In lines 39 and 40:
      <pre>
        taper_best  = 0
        oswald_best = 0
      </pre>
      we initialize the best we have seen so far, and in lines 43 and
      44:
      <pre>
        taper_data  = ""
        oswald_data = ""
      </pre>
      we initialize the strings in which we remember all the cases we
      have run (so that we can plot them below).

    <p>The "optimization" loop that actually does the AVL calculation
      starts in lines 47 through 52:
      <pre>
        for taper in [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]:
            print("executing taper =", taper)

            # compute performance (getting output automagically runs AVL)
            myProblem.geometry.despmtr["wing:taper"].value = taper
            oswald = avl.output["e"].value
      </pre>
      Note that the use of the AVL output valiable "e" in line 52 is
      what actually focees AVL to be executed.

    <p>Lines 55 and 56:
      <pre>
            taper_data  += str(taper)  + ";"
            oswald_data += str(oswald) + ";"
      </pre>
      keep track of all the calculations so far, and lines 59 to 61:
      <pre>
            if (oswald > oswald_best):
                taper_best  = taper
                oswald_best = oswald
      </pre>
      keep track of the "best" so far.  The "sleep" in line 64 is not
      necessary, but is included here so that you can actually see
      when the AVL is executed.

    <p>The next major block of code is in lines 67 through 72:
      <pre>
        esp.TimLoad("plotter", esp.GetEsp("pyscript"), "")
        esp.TimMesg("plotter", "new|Taper optimization|taper ratio|oswald|")
        esp.TimMesg("plotter", "add|"+taper_data+"|"+oswald_data+"|k:+|")
        esp.TimMesg("plotter", "add|"+str(taper_best)+"|"+str(oswald_best)+"|ro|")
        esp.TimMesg("plotter", "show")
        esp.TimQuit("plotter")
      </pre>
      which loads the line plotter, stars a new plot with the title
      "Taper optimization", with the horizonal axis label "taper
      ratio" and vertical axis label "oswald".  The first line in the
      plot is the remembered data (from above), drawn as a black
      ("k") dotted line (":") with plus symbols
      ("+").  The second line is simply the best, shown as
      a red ("r") circle ("o").  The resulting plot is:
    <p><img src="pictures/tutorial6-16.png" width="100%"/>
      and the plotter is closed.

    <p>The script finally reports the best results in the
      MessageWindow:
      <pre>
        print("taper_best =", taper_best )
        print("oswald_best=", oswald_best)
      </pre>
      and puts the best results into the CAPS problem:
      <pre>
        print("re-setting optimal taper")
        myProblem.geometry.despmtr["wing:taper"].value = taper_best
        myProblem.geometry.build()

        if ("oswald" in myProblem.parameter):
            myProblem.parameter["oswald"].value = oswald_best
        else:
            myProblem.parameter.create("oswald", oswald_best)
      </pre>
      This script is execute by pressing <b>Save and run</b>.  After
      some computations you will see the plot given above.  Press the
      green <b>Exit plotter</b> button and the dispaly will change to
      the optimized tapered wing:
    <p><img src="pictures/tutorial6-17.png" width="100%"/>
      Note that the "optimal" geometry is shown since we forced a
      re-build in line 81.  The last lines either update or create a
      new CapsValue in which the best oswald efficiency factor will be
      stored.

    <p>If you select <b>Caps</b> then <b>List Phases</b>
       and <b>Caps</b> then <b>List Analyses</b> you will see in the
       MessageWindow that we have three Phases (the first two of which
       use "model1" and the third uses "model2") and that we now have an
       Analysis Object named "avl", which was created in Phase "1.3".
       Note also the intent phrases associated with the three Phases.
    <p><img src="pictures/tutorial6-18.png" width="100%"/>

    <p>Commit this Phase (that is, make it read-only) by
       pressing <b>Caps</b> and <b>Commit Phase</b>.

    <p><h4>Third model (bent tapered wing)</h4>

    <p>You may notice that the wing is very thin, and so we expect
       that there is considerable flexibility that we must account
       for. To do this, we have further enhanced our model in
       "../data/tutorial6/model3.csm", which can be loaded by
       pressing <b>File</b> and then <b>Open</b>.  This model looks
       very similar to the above, except there are more cross-sections
       and there is a new DesignParameter named "wing:ztip", which is
      the vertical tip deflection.

    <p>If you <b>File</b> and <b>Edit model3</b>, the major changes from
       the above are the addition of cross-sections at the
       quarter-semi-span and mid-semi-span locations, and the use of a
       BLEND instead of the RULE.  Note that in order to make sure
       that we got the slope discontinuity at the root, we have added
       (in lines 80 and 81 ):
      <pre>
        RESTORE  .
        RESTORE  .
      </pre>
       to make the two extra copies on the root Body, which is needed
       to make the continuity of the BLEND only C0 (value continuous).
       The values of "wing:area", "wing:aspect", and "wing:taper" are
       from the <code>.csm</code> file.
    <p><img src="pictures/tutorial6-19.png" width="100%"/>

    <p>When we start the IDE by pressing <b>Tool</b> and <b>Caps</b>
       and entering "ostrich" (or "ostrich:1" or "ostrich:1.3"), with
       the intent phrase "account for wing flexibility", we get the
       latest versions of the wing variables, giving us:
    <p><img src="pictures/tutorial6-20.png" width="100%"/>
       Note the MessageWindow which says that <code>CAPS</code>
       over-rides the previous values.

    <p>We now are going to run a pyscript to deflect the wing.  This
       is done by pressing <b>Tool</b> and <b>Pyscript</b> and entering
        "../data/tutorial6/bendWing.py".  Lines 10 through 18 are the
        regular hook-up to <code>CAPS</code>.  Line 21:
      <pre>
        Eyoung   = 77.5e6         # lb/ft2
      </pre>
      sets the Youngs modulus for balsa wood, lines 24 to 26:
      <pre>
        sparrad  = 0.0104         # ft
        W        = 0.36           # lb
        b        = myProblem.geometry.outpmtr["wing:span"].value
      </pre>
      sets (or looks up) other design variables.

    <p>The actual structural calculations are done in lines 29 and 30:
      <pre>
        Inertia  = math.pi / 4 * sparrad**4
        deflect  = (W/2) * (b/2)**3 / (3 * Eyoung * Inertia)
      </pre>
      for a round cantilevered beam.  Finally, in lines 33 to 36:
      <pre>
        print("deflect=", deflect)

        # put the result into the CAPS Problem
        myProblem.geometry.despmtr["wing:ztip"].value = deflect
      </pre>
      the results are printed in the MessageWindow and returned to the
      IDE and the configuration is rebuilt in line 37:
      <pre>
        myProblem.geometry.build()
      </pre>
      Pressing <b>Save and run</b> and expanding the <b>Caps
      Values</b> and <b>Design Parameters</b> produces:
    <p><img src="pictures/tutorial6-21.png" width="100%"/>

    <p>Instead of leaving <code>CAPS</code> mode by choosing one of
       the options in the <b>Caps</b> menu, we are simply going to
       close the browser.  This is essentially the same as if we had
       chosen <b>Suspend Phase</b>.

    <p>To look at the status of our project, we can type (in the
      command or terminal window):
      <pre>
        phaseUtil ostrich
      </pre>
      which produces:
      <pre>
         phaseUtil for ESP Rev 1.21

                          Phase Name:                    Parent Name:
                           -------------------------------------------
                  Closed   1.1
                  Closed   1.2                            1.1
                  Closed   1.3                            1.2
                           1.4                            1.3
      </pre>
      You can see that Phases "1.1", "1.2", and "1.3" are Closed 
      and that Phase "1.4" is not Closed.  This means that the
      next time we enter the IDE, we can continue Phase 1.4.

    <p>Reenter <code>serveESP</code> (without file name) and then
       press <b>Tool</b> and <b>Caps</b> with the project "ostrich".
       You can see that it picks up where we left off.  The Message
       Window includes a message that says that Phase "1.4" is being
       continued.  Let us now commit the Phase by pressing <b>Caps</b>
       and <b>Commit Phase</b>.

    <p>If we get out of <code>serveESP</code> by closing the browser
       and then type:
      <pre>
        phaseUtil ostrich
      </pre>
       you can see that Phase 1.4 is now Closed too.  Recall that a
       Closed Phase cannot be editted but can be used as a starting
       Phase for a new Phase.

    <p><h4>Fourth model (inclusion of tail)</h4>

    <p>Re-start <code>serveESP</code> by typing:
      <pre>
        serveESP ../data/tutorial6/model4
      </pre>
      which brings up a wing and tail, as in:
    <p><img src="pictures/tutorial6-22.png" width="100%"/>
      Note that this looks rather odd, since it is using the
      DesignParameters from "model4.csm" and that the DesignParameters
      for the wing are the originals whereas those for the tail are
      associated with the updated wing.  (You can see this in the
      TreeWindow.) To make them consistent (that
      is, use the latest values for the wing), simply enter the IDE by
      pressing <b>Tool</b> and <b>Caps</b> and using project "ostrich"
      with the intent phrase "set up AVL and view Modl and AVL
      Bodys".  You can see that the wing values from <code>CAPS</code>
      override that values in the <code>.csm</code> file and that the
      wing and tail are now consistent.
    <p><img src="pictures/tutorial6-23.png" width="100%"/>
      This image also includes a rendition of the location of the golf
      ball.

    <p>If we <b>File</b> and <b>Edit model4</b>, we can see in lines
      17 to 22:
      <pre>
        DESPMTR   tail:len     2.00
        DESPMTR   tail:Vh      0.45
        DESPMTR   tail:Vv      0.025
        DESPMTR   tail:aspect  5.00
        DESPMTR   tail:thick   0.02
        DESPMTR   tail:camber  0.02
      </pre>
      the DesignParameters associated with the tail, and in lines 25
      and 26:
      <pre>
        DESPMTR   ball:xloc    0.00
        CFGPMTR   ball:radius  0.05
      </pre>
      those DesignParameters associated with the golf ball(s).

    <p>The construction of the tail is given in lines 143 to 192:
      <pre>
        # horizontal tail local variables
        SET       htail:area      tail:Vh*(wing:croot+wing:ctip)/2*wing:area/tail:len
        SET       htail:span      sqrt(htail:area*tail:aspect)
        SET       htail:chord     htail:area/htail:span
        SET       tail:xloc       tail:len+wing:croot/4-htail:chord/4

        # construct horizontal tail
        MARK
           UDPARG    naca         thickness tail:thick
           UDPARG    naca         camber    tail:camber
           UDPRIM    naca         sharpte   1
              ATTRIBUTE capsAIM           $avlAIM
              ATTRIBUTE capsIntent        $htail;tail
              ATTRIBUTE capsGroup         $htail
           ROTATEX   90
           SCALE     htail:chord
           TRANSLATE tail:xloc  -htail:span/2  0
           STORE     htail -1  1

           RESTORE   .
           TRANSLATE 0          htail:span    0
           STORE     htail -1  1
        RULE
           ATTRIBUTE _name             $htail
           ATTRIBUTE capsGroup         $htail
        STORE     htailOML

        # vertical tail local variables (same chord as htail)
        SET       vtail:area      tail:Vv*wing:span*wing:area/tail:len
        SET       vtail:chord     htail:chord
        SET       vtail:span      vtail:area/vtail:chord

        # construct vertical tail
        MARK
           UDPARG    naca         thickness tail:thick
           UDPRIM    naca         sharpte   1
              ATTRIBUTE capsAIM           $avlAIM
              ATTRIBUTE capsIntent        $vtail;tail
              ATTRIBUTE capsGroup         $vtail
           SCALE     vtail:chord
           TRANSLATE tail:xloc  0  0
           STORE     vtail -1  1

           RESTORE   .
           TRANSLATE 0         0  vtail:span
           STORE     vtail -1  1
        RULE
           ATTRIBUTE _name             $vtail
           ATTRIBUTE capsGroup         $vtail
        STORE     vtailOML
      </pre>
      Note in particular that the tail has a different "capsIntent"
      and "capsGroup" Attribute than the wing; this will be important
      momentarily.

    <p>The ball is created in lines 195 to 198:
      <pre>
        SPHERE    ball:xloc  0  0  ball:radius
           ATTRIBUTE _color $blue
           ATTRIBUTE _name  $ball
        STORE     ball
      </pre>

    <p>The only other change is in the view section, where everywhere
       we were previously RESTOREing the "wing", we now also need to
       RESTORE the "htail" and "vtail".

    <p>Special note: when editing a <code>.csm</code> file while
       in <code>CAPS</code> mode, you may NOT edit and <b>Save</b>;
       the only action you may take is to <b>Quit</b>, which you
       should do now.

    <p>We are now going to set up two analysis objects for subsequent
       calculations (which are beyond this tutorial).  In particular,
       we are going to be setting up "avlWing" for wing-only analyses
       and "avlAll" to include the tails. We are then going to use the
       integrated viewer to see these.

    <p>Press <b>Tool</b> and <b>Pyscript</b> and enter
       "../data/tutorial6/viewBodys.py"   This pyscript starts with
      the usual preamble in lines 10 through 16.  Line 19:
      <pre>
        esp.TimLoad("viewer", esp.GetEsp("pyscript"), "")
      </pre>
      loads the integrated viewer.  Lines 22 and 23:
      <pre>
        print("==> Viewing all Bodys on te stack")
        esp.TimMesg("viewer", "MODL")
      </pre>
      will print a message in the MessageWindow and display all the
      Bodys in the Modl (that is, on the stack), which should look
      exactly the same as the display before the pyscript was executed.

    <p>Lines 27 to 30:
      <pre>
        if ("avlAIM" not in myProblem.analysis):
            myProblem.analysis.create(aim        = "avlAIM",
                                      capsIntent = "wing",
                                      name       = "avlWing")
      </pre>
      create a new analysis object for the "avlAIM" AIM (if it does
      not already exist), using all the Bodys with a "capsAim" equal
      to "avlAIM" and with a "capsIntent" equal to "wing"; the new
      analysis object will have the name "avlWing".  These Bodys can
      be viewed in line 33:
      <pre>
        esp.TimMesg("viewer", "AIM|avlWing|")
      </pre>
      which shows all Bodys associated with "avlWing".
    <p><img src="pictures/tutorial6-24.png" width="100%"/>

    <p>Lines 37 to 40:
      <pre>
        if ("avlAIM" not in myProblem.analysis):
            myProblem.analysis.create(aim        = "avlAIM",
                                      capsIntent = "",
                                      name       = "avlAll")
      </pre>
      create another analysis object, named "avlAll", that contains
      all Bodys with "capsAIM" equal to "avlAIM", regardless of their
      "capsIntent".
      Line 42:
      <pre>
        esp.TimMesg("viewer", "AIM|avlAll|")
      </pre>
      shows these Bodys associated with both the wing and tail.
    <p><img src="pictures/tutorial6-25.png" width="100%"/>
      Selecting Bodys by Attribute is a powerful capability
      in <code>CAPS</code>; now you can probably understand why we
      spent the time in "model4.csm" to put the Attributures on the
      Bodys that we did.

    <p>Finally in line 44:
      <pre>
        esp.TimQuit("viewer")
      </pre>
      we quit the viewer.

    <p>When we press <b>Save and run</b>, we will see the various
      displays shown above.  Note that to go from one display to the
      next, we will have to press the green <b>Exit viewer</b> button.

    <p>Commit this Phase by pressing <b>Caps</b> and <b>Commit
        Phase</b> and exit <code>ESP</code> by closing the browser.

    <p><h4>Fifth model (flowchart and data transfers)</h4>

    <p>The next model is quite a bit more complicated than before
      because it uses user-defined components (UDCs) from the standard
      library, from the same folder as the <code>.csm</code> file, and
      from the current working directory.  To get the file we need in
      the current working directory, type (in the terminal or command
      window):
      <pre>
        cp ../data/tutorial6/model5a.udc_orig ./model5a.udc
      </pre>
      or if on Windows
      <pre>
        copy ..\data\tutorial6\model5a.udc_orig .\model5a.udc
      </pre>

    <p>If we now type:
      <pre>
        phaseUtil ostrich
      </pre>
      you can see that we have Phases 1.1 to 1.5 and that all the
      Phases are Closed (which means that they can no longer be
      editted).

    <p>Start <code>serveESP</code> by typing:
      <pre>
        serveESP ../data/tutorial6/model5
      </pre>
      If you look in the MessageWindow, you can see that "model5" uses
      four UDCs.  You can also see that there are two Bodys on the
      stack (although they look like only one because they are located
      at the same location).

    <p>Up until now, every time we started <code>CAPS</code>, we did
      so on the main Branch; that is, the Revisions were named "1.1",
      "1.2", "1.3", "1.4", and "1.5".  This time we are going to do
      something different.  We are going to create a new Branch,
      starting at Revision "1.2".  <code>serveESP</code> knows that we
      want a new Branch since the Revision after "1.2" would normally
      be "1.3", but "1.3" already exists.  Therefore a new Branch will
      be created, with the name "2.1".

    <p>Press <b>Tool</b> and <b>Caps</b> and enter "ostrich:1.2" as the
      project name.  Our intent will be "interpolate upper".  Body 7
      is (essentially) out original EXTRUDEd wing and Body 28 is a
      RULEd wing made from five cross-sections.  Turn the visibility
      on and off (by pressing <b>Viz</b>) to see these Bodys.

    <p>Body 7 looks like:
    <p><img src="pictures/tutorial6-26.png" width="100%"/>

      and Body 28 looks like:
    <p><img src="pictures/tutorial6-27.png" width="100%"/>

    <p>The reason we have to similar wings is that we want to test out
      the various schemes in <code>CAPS</code> for transferring data
      from one representation to another.  This capability is
      essential if one is trying to perform a fluid/structures
      interaction, where one Body (say Body 7) is associated with the
      aerodynamic analysis and the other Body (Body 28) is associated
      with the structures analysis.

    <p>Instead of using a real aerodynamic or structure analysis, we
      are going to use a testing AIM, named "skeletonAIM", which has:
      <ul>
        <li>an input scalar number named "num";</li>
        <li>an output scalar number named "sqrtNum";</li>
        <li>input scalar datasets named "in1", "in2", "in3", and
          "in4";</li>
        <li>an output scalar dataset named "x", which is simply
          the <em>x</em> coordinates;</li>
        <li>an output scalar dataset named "y", which is simply
          the <em>y</em> coordinates;</li>
        <li>an output scalar dataset named "z", which is simply
          the <em>z</em> coordinates; and</li>
        <li>an output scalar dataset named "pi", which is the constant
          3.14159...</li>
      </ul>

    <p>Press <b>Tool</b> and <b>Pyscript</b> and enter
      "../data/tutorial6/interpolateUpper".  Lines 10 through 16 are
      the usual hook-up to the model currently in memory.

    <p>Lines 17 through 27:
      <pre>
        if ("skeletonAIM_1" not in myProblem.analysis):
            myProblem.analysis.create(aim        = "skeletonAIM",
                                      capsIntent = "Body_1",
                                      name       = "skeletonAIM_1")

        if ("skeletonAIM_2" not in myProblem.analysis):
            myProblem.analysis.create(aim        = "skeletonAIM",
                                     capsIntent = "Body_2",
                                     name       = "skeletonAIM_2")
      </pre>
      create two analysis objects, "skeletonAIM_1" and
      "skeletonAIM_2", which are associated with the Body that has
      "capsIntent" equal to "Body_1" (ie, Body 7) and with the Body
      that has "capsIntent" equal to "Body_2" (ie, Body 28).  Both of
      these analysis objects are created if they do not already exist.

    <p>Lines 30 to 33:
      <pre>
        if ("upperWing" not in myProblem.bound):
            boundUpper = myProblem.bound.create("upperWing")
        else:
            boundUpper = myProblem.bound["upperWing"]
      </pre>
      create (or re-use) a Bound, or collection of Faces in the
      various Bodys, named "upperWing", with the handle "boundUpper".

    <p>Lines 35 and 36:
      <pre>
        vset1 = boundUpper.vertexSet.create(myProblem.analysis["skeletonAIM_1"])
        vset2 = boundUpper.vertexSet.create(myProblem.analysis["skeletonAIM_2"])
      </pre>
      makes two vertex sets --- one associated with each of the AIMs.

    <p>Lines 38 to 40:
      <pre>
        dset1x = vset1.dataSet.create("x",   pyCAPS.fType.FieldOut)
        dset2x = vset2.dataSet.create("in1", pyCAPS.fType.FieldIn)
        dset2x.link(dset1x, "Interpolate")
      </pre>
      create data sets that tie together "x" in "skeletonAIM_1" with
      "in1" in "skeletonAIM_2", and do the transfer via
      interpolation.  Similar tansfers are done in lines 42 to 52 for
      the other variables.  Finaly the Bound object is closed in line
      54:
      <pre>
        boundUpper.close()
      </pre>

    <p>Lines 57 to 59:
      <pre>
        myProblem.analysis["skeletonAIM_1"].input.num = 16
        value = myProblem.analysis["skeletonAIM_1"].output.sqrtNum
        print("Computed sqrt =", value)
      </pre>
      are needed to actually make the AIMs execute.  Recall that AIMs
      only execute when explicitly told to do so; using the output
      "sqrtNum" in line 58 is such an example.  Alternatively, we
      could have used a statement such as in the comment on line 60:
      <pre>
        #myProblem.analysis["skeletonAIM_1"].execute()
      </pre>
      to force the execution.

    <p>After all this setup, this pyscript starts by showing a
      flowchart of the analysis objects (shown as rectangles) and
      Bounds (shown as arrows) in lines 63 to 65:
      <pre>
        esp.TimLoad("flowchart", esp.GetEsp("pyscript"), "")
        esp.TimMesg("flowchart", "show");
        esp.TimQuit("flowchart");
      </pre>
    <p><img src="pictures/tutorial6-28.png" width="100%"/>
      Moving the mouse over one of the AIMs or the Bound brings up a
      pop-up that shows associated information.
    <p><img src="pictures/tutorial6-29.png" width="100%"/>
      The flowchart is brought up in a separate browser tab, which you
      can either close or leave open.  In either case, in the original
      tab you will need to press <b>Exit flowchart</b> to continue
      execution.

    <p>Then in line 68 we load the integrated viewer:
      <pre>
        esp.TimLoad("viewer", esp.GetEsp("pyscript"), "")
      </pre>
      and in lines 71 and 72:
      <pre>
        print("==> Viewing x in skeletonAIM_1")
        esp.TimMesg("viewer", "BOUND|upperWing|skeletonAIM_1|x")
      </pre>
      we show the "x" in "skeletonAIM_1"
    <p><img src="pictures/tutorial6-30.png" width="100%"/>
      and in lines 74 and 75:
      <pre>
        print("==> Viewing in1 in skeletonAIM_2 (interpolate)")
        esp.TimMesg("viewer", "BOUND|upperWing|skeletonAIM_2|in1")
      </pre>
        we show the intepolated version of it (that is, "in1" in
      "skeletonAIM_2").
    <p><img src="pictures/tutorial6-31.png" width="100%"/>
      Notice how well the interpolation works.  Remember to
      press <b>Exit viewer</b> to exit the viewer after each display.

    <p>The rest of the pyscript does the same thing for the other
      variables.  It finally closes the viewer in line 95.

    <p>This Phase has been enlighting, but what we really want to do
      is to look at the effect of a conservative data transfer.
      Therefore we can <b>Caps</b> and <b>Quit Phase</b> to throw away
      everything we have done since starting this Phase.  Since
      quitting a Phase removes the model from memory, we need
      to <b>File</b> and <b>Open</b> "../data/tutorial6/model5".  Then
      start a new Phase by pressing <b>Tool</b> and <b>Caps</b>, again
      entering "ostrich:1.2", with the intent phrase "conserve
      upper".  If you press <b>Caps</b> and <b>List Analyses</b> you
      will see that the analysis objects that we previously created
      are gone.

    <p>Next, press <b>Tool</b> and <b>Pyscript</b> and enter
      "../data/tutorial6/conserveUpper".  If you look at this file, it
      is the same as "interpolateUpper", except the link statements
      in lines 42, 48, 52, and 56 say something like:
      <pre>
        dset2x.link(dset1x, "Conserve")
      </pre>
      instead of:
      <pre>
        dset2x.link(dset1x, "Interpolate")
      </pre>

    <p>Press <b>Save and run</b> to see the effect of the conservative
      data transfer.  (A conservative data transfer is one in which
      the integral of the scalar field in the source and target
      match.  This kind of transfer is essential in order to make sure
      that the total aerodynamic load is transferred to the structural
      calculation.) The disadvantages of the conservative data
      transfer are that it is quite a bit slower than straight
      iterpolation and that the transferred data is not quite as
      smooth.  For example, "in1" now looks like:
    <p><img src="pictures/tutorial6-32.png" width="100%"/>
      and "in4" looks like:
    <p><img src="pictures/tutorial6-33.png" width="100%"/>
      While this initially looks quite disturbing (since the input was
      the constant "pi"), if you look at the KeyWindow you will see
      that all the values vary between 3.14056 and 3.14159 --- so it
      is essentially constant.  The differences stem from the fact that
      the discrete surface areas in the two models are slightly different.

    <p>If we now <b>Caps</b> and <b>List Phases</b>
    <p><img src="pictures/tutorial6-34.png" width="100%"/> you can see
      in the MessageWindow that the current Phase is "2.1" and that it
      predecessors are "1.1" and "1.2".  Pressing <b>Caps</b>
      and <b>List Analyses</b> and <b>Caps</b> and <b>List Bounds</b>
      produces:
    <p><img src="pictures/tutorial6-35.png" width="100%"/>
      Note that we have two analyses and one Bound.

    <p>We can <b>Caps</b> and <b>Commit Phase</b> to complete this
      Phase.  Then exit the browser.

    <p><h4>Parametric variations</h4>

    <p>During the process of design, one often wants to do a what-if
      experiment, in which various alternatives are explored in an
      effort to justify or update earlier assumptions. You might
      remember from earlier in this tutorial that all of our analysis
      has been done for one ball.  We are now going to look at the
      effect of two and three balls.  Each of these what-ifs will be
      done in a separate Phase.

    <p>To begin, start by typing:
      <pre>
        phaseUtil ostrich
      </pre>
      which shows that we have Phases "1.1" to "1.5", and Phase "2.1",
      and that all the Phases are Closed.  We will start our
      exploration in a new Branch by typing:
      <pre>
        serveESP
      </pre>
      and then pressing <b>Tool</b> and <b>Caps</b> and "ostrich:1.3".
      Recall that Phase 1.4 already exists, so this will create the
      first Revision on a new Branch ("3.1").  We will use the intent
      phrase "look at 2 balls".  Recall that Phase 1.3 was the Phase
      in which we optimized the taper by running AVL.

    <p>In the TreeWindow, press on <b>ExpandAll</b> associated with
      the CaspsValues, press on <b>nball</b> and change the value to
      "2".  Resize the wing by pressing <b>Tool</b>
      and <b>Pyscript</b> and "../data/tutorial6/sizeWing".  (Do not
      forget to press <b>Save and run</b> to execute.) You can see the
      results of this operation both in the MessageWindow and in the
      displayed Body.
    <p><img src="pictures/tutorial6-36.png" width="100%"/>

    <p>Then re-optimize the taper by
      pressing <b>Tool</b>, <b>Pyscript</b>, and
      "../data/tutorial6/optTaper".  You can see in the MessageWindow
      each of the AVL cases as it runs (with the 2 second delay).
      Then, as before, this latter pyscript will produce a plot of
      "oswald" vs. "taper ratio".  (Remember to press <b>Exit
        plotter</b> to continue.)
    <p><img src="pictures/tutorial6-37.png" width="100%"/>

    <p>In order to show what happens when we suspend a Phase,
      press <b>Caps</b> and <b>Suspend Phase</b> and exit the
      browser.  If you type:
      <pre>
        phaseUtil ostrich
      </pre>
      you can see that Phase "3.1" is not Closed.

    <p>We can once again start by typing:
      <pre>
        serveESP
      </pre>
      and enter the IDE by pressing <b>Tool</b> and <b>Caps</b> and
      entering "ostrich:3".  This will either start on the last
      Revision in Phase "3" if it is not Closed, or will create a new
      Revision at the end of Branch "3" if the last Revision in this
      Branch is Closed.  The former is the case, so we will be picking
      up where we left off.  If you look in the MessageWindow, you
      will see messages such as:
      <pre>
        excuuting taper = 0.2
      </pre>
      with no itermediate builds.
    <p><img src="pictures/tutorial6-38.png" width="100%"/>
      This is because in continuation mode, <code>CAPS</code> will
      reuse (or recycle) as many operations (in this case analyses) as
      possible.  Also, at the end of this process, the plot will not
      be displayed since overlays (such as the "viewer", "plotter",
      and "flowchart") are not executed in continuation mode.

    <p>If you now press <b>Caps</b> and <b>List Phases</b> you should see
    <p><img src="pictures/tutorial6-39.png" width="100%"/> which shows
      that we are working on Phase "3.1", with predecessors "1.1",
      "1.2" and "1.3".  We can <b>Caps</b> and <b>List Analyses</b> to
      see that we still have the "avl" analysis object.  Now
      press <b>Caps</b> and <b>List History</b> to show the evolution
      of any value.  We are going to look at the history of
      "CLcruise".  You can see the values at the end of Phases 1.3
      (for which "nball" was "1") and Phase 3.1 (for which "nball" was
      "2").

    <p>We can <b>Caps</b>, then <b>Commit Phase</b>, and then start a new
      Phase in which we set "nball" to "3".  We can follow the same
      steps as above during this new Phase ("3.2").  While "optTaper"
      is running in this Phase, kill <code>serveESP</code>, resulting
      in a screen that says that the server has died.
    <p><img src="pictures/tutorial6-40.png" width="100%"/>
      Note that <code>serveESP</code> can die if you encounter an error
      (which you should report to the developers), or for a
      long-running job, or via an explicit kill, as was done here.
      This will leave the current phase not Closed, but more
      importantly will leave it "Locked".  A Locked Phase means that
      it was not put into a safe state by some user.  You can see the
      status of the various Phases by typing:
      <pre>
        phaseUtil ostrich
      </pre>
      Note that Phase 3.2 is Locked.

    <p>If we re-start by typing:
      <pre>
        serveESP
      </pre>
      and then <b>Tool</b>, <b>Caps</b>, and "ostrich:3", you will be
      told that the current Phase is Locked:
    <p><img src="pictures/tutorial6-41.png" width="100%"/>
      Since you know why it is Locked, you can safely "steal the lock"
      and continue on as usual.  If you look in the MessageWindow, you
      will see that some of the analyses are recycled and others are
      executed; how many of each depends on when you
      killed <code>serveESP</code>.  After the pyscript completes, you
      can look at the history of "wing:area" (a CapsValue) and
      "wing:span" (an OutputParameter) to see how they evolved over time.
    <p><img src="pictures/tutorial6-42.png" width="100%"/>

    <p>Commit this Phase.  (Hopefully by now you know how to do this.)

    <p><h4>Working with Phases</h4>

    <p>Then restart the IDE (<b>Tool</b> and <b>Caps</b>) and give it
      the project "ostrich*".  (Recall that the default Branch is "1"
      and the default Revision is the last in the given Branch, so this
      is exactly equivalent to typing "ostrich:1*" or "ostrich:1.5*".
    <p><img src="pictures/tutorial6-43.png" width="100%"/>

    <p> What the "*" means is "do not use the model shown on the
      screen, but instead use the model from the given Phase".  So for
      this case, it will use "model4".  We can use the intent phrase
      "back to Branch 1".

    <p>Let us quit this Phase, and reload "../data/tutorial6/model4"
      (which is the wing and tail).  Start a new Phase starting at
      "ostrich:2*".  Recall that this means to start at the end of
      Branch "2", but do not use "model4" (which we just loaded), but
      instead use "model5" (from the parent Phase).  Use the intent
      phrase "back to Branch 2".  If you <b>List Phases</b>
    <p><img src="pictures/tutorial6-44.png" width="100%"/>
      you will see that we are in Phase "2.2", which uses "model5",
      and that its predecessors are "1.1", "1.2", and "2.1".  If we
      now <b>List Analyses</b> and <b>List Bounds</b>
    <p><img src="pictures/tutorial6-45.png" width="100%"/>
      you can recall that "2.1" was the one where we were looking at
      the effect of conservative data transfers between the two
      "sekelton" AIMs.

    <p>Now we can <b>Caps</b> and <b>Update intent</b> to update the
      intent phrase to "back to Branch 2; remove analyses and bound"
    <p><img src="pictures/tutorial6-46.png" width="100%"/>

    <p>Re-run "../data/tutorial6/stub6.py" and comment out line 20 (by
      highlighting the line and pressing <b>Comment</b>) and uncomment
      lines 22 through 24 by highlighting them and
      pressing <b>Comment</b>; this will un-comment these lines since
      line 20 was a comment.
    <p><img src="pictures/tutorial6-47.png" width="100%"/>
      This pyscript will mark the analysis objects and bound for
      deletion; the deletion will occur when we <b>Commit
      Phase</b>. You can check this starting a new Phase and <b>List
        Analyses</b> and/or <b>List Bounds</b>

    <p>This rather-long tutorial has touched upon many aspects of the
      new Integrated Design Environment (IDE).  Since it is so new,
      comments, suggestion, corrections, etc. are welcome by the
      developer at jfdannen@syr.edu

    <p><h3>Legacy Tutorials</h3>

    <p>If you are new to <code>ESP</code> and planning on following
       current best practices, you can skip the legacy tutorials.  But
       if you want to see how to use <code>ESP</code> with the
       look-and-feel of a traditional CAD program, it might be worth
       your while to spend some time with the legacy tutorials.  Note
       that these legacy tutorial HAVE NOT been updated for the latest
       version of <code>ESP</code>, meaning that you might be missing
       descriptions of some of the latest additions
       to <code>ESP</code>.  Also, your screen might look a little
       different from the pictures, but the basic functionality should
       be the same.

    <p><h3 id="sec2.7">2.7 First legacy tutorial: Basic usage</h3>

    <p>This tutorial will help you understand the use of
       <code>serveESP</code> and <code>ESP</code> for a variety of
       tasks.  Details about the <a href="#sec3">Command
       Line</a>, <a href="#sec4">cursor and keyboard options</a>, and
       the <a href="#sec6">Example <code>.csm</code> file</a> are
       contained in sections that follow this tutorial.

    <p>The tutorial starts with a pre-made part that is defined by the
       file <code>tutorial1.csm</code>.  (See <a href="#sec6">
       Example <code>.csm</code> file</a> below for a listing of this
       file.)

    <p>To start <code>ESP</code> there are two steps: (1) start the
       "server" and (2) start the "browser".  This can be done in a
       variety of ways, but the two most common follow.

    <p><b>Technique 1:</b> issue the two commands:
      <pre>
        setenv ESP_START "open -a /Applications/Firefox.app ../ESP/ESP.html"
        serveESP ../data/legacy/tutorial1
      </pre>
      if using a c-shell; make appropriate changes for your shell
      and/or operating system.

    <p>The first of these tells <code>serveESP</code> to open FireFox
       on the file <code>../ESP/ESP.html</code>
       when <code>serveESP</code> has generated a graphical
       representation of the configuration.  The second of these
       actually starts the <code>serveESP</code> server.  As long as
       the browser stays connected
       to <code>serveESP</code>, <code>serveESP</code> will stay alive
       and handle requests sent to it from the browser.  Once the last
       browser that is connected to <code>serveESP</code>
       exits, <code>serveESP</code> will shut down.

    <p><b>Technique 2:</b> issue the command:
       <pre>
         serveESP ../data/legacy/tutorial1
       </pre>
       Once the server starts, start a browser (for example, FireFox)
       and open the page <code>ESP/ESP.html</code>.  As
       above, <code>serveESP</code> will stay alive as long as there
       is a browser attached to it.

    <p>Note that the default "port" used by <code>serveESP</code> is
       7681.  One can change the port in the call
       to <code>serveESP</code> with a command such as:
       <pre>
         serveESP ../data/legacy/tutorial1 -port 7788
       </pre>

    <p>Once the browser starts, you will be prompted for a
       "hostname:port" as in:
    <p><img src="pictures/legacy1-01.png" width="100%"/>

    <p>Most of the time, the "hostname" will be "Localhost" (meaning
       that <code>serveESP</code> and the browser are on the same
       computer).  It is possible to attach to <code>serveESP</code>
       that is running on another computer by giving an appropriate
       "hostname".

    <p>As mentioned above, it is possible to change the "port" with a
       command line argument when starting <code>serveESP</code>; if
       that is done, then the alternative "port" must be included in
      <code>ESP</code>'s prompt.

    <p>Once all the setup is done, the browser then presents the
       following 4 windows:
    <p><img src="pictures/legacy1-02.png" width="100%"/>

    <p>The window on the top left is called the "Tree" window.  At the
       top of this window is a series of buttons.  Below that is a
       scrollable tree-like listing of the Parameters and Branches in
       the Model.  It also contains the controls for the "Graphics"
       window.

    <p>The window on the top right is called the "Graphics" window,
       which contains one of the following:
      <ul>
        <li>a graphical representation of the current configuration,
            in three dimensions;</li>
        <li>a 2D Sketcher; or</li>
        <li>a form (such as when adding or editing a Branch); when a
            form is present, you must press "<b>Cancel</b>"
            or "<b>OK</b>" in the form to return to the
            graphical representation.</li>
      </ul>

    <p>The window on the bottom left is the "Key" window.  Like the
       "Graphics" window, its contents will be one of:
      <ul>
        <li>the <code>ESP</code> logo;</li>
        <li>an annotated spectrum (that describes the mapping between
            sensitivity values and colors in the "Graphics" window);
            or</li>
        <li>the status of the Sketcher and a listing of the available
            Sketcher commands</li>
      </ul>

    <p>The window on the bottom right is called the "Messages" window.
       It contains the messages that <code>ESP</code> posts for the
       user.

    <p>The first thing to do is to play with the image in the
       "Graphics" window.  This is done with the mouse in the
       following ways:
      <ul>
        <li><b>Drag</b>: translate the graphical image</li>
        <li><b>Shift-Drag</b>: moving mouse up while
          dragging zooms in while moving the mouse down while dragging
          zooms out.  Note that the mouse wheel can also be used to
          zoom in and out.</li>
        <li><b>Ctrl-Drag</b>: rotate the object about its
          center (see below for more details)</li>
        <li><b>Alt-Drag</b>: rotate the view about an axis
          that is perpendicular to the screen.
          (Use <b>Option-Drag</b> on Mac OSX)</li>
      </ul>
      It is suggested that you use the left or middle mouse button for
      these operations, since in most browsers the right mouse button
      will post a popup menu.

    <p>When using the mouse, it is possible to enter "flying mode", in
       which the view continually changes until the mouse button is
       released.  Flying mode is particularly useful when one needs to
       translate a long distance.  Toggling flying mode is done by
       pressing the "<b>!</b>" key in the "Graphics" window.

    <p>At any time, a user might want to "save" a view for later use
       in the browser session.  This is done by pressing the
       "<b>&gt;</b>" key in the "Graphics" window; the
       "saved" view can be retrieved by pressing the
       "<b>&lt;</b>" key.

    <p>You can also save a view into a file with the
       "<b>&lt;Ctrl-&lt;&gt;</b>" or "<b>,</b>"
       keys, which will prompt you for a filename.  You can read a
       view file with the "<b>&lt;Ctrl-&gt&gt</b>" or
       "<b>.</b>" keys, which will prompt you for the view
       filename.  If the file does not exist, nothing will happen.

    <p>The default (home) view can be obtained by pressing either
       "<b>&lt;Home&gt;</b>",
       "<b>&lt;Ctrl-h&gt;</b>",
       "<b>&lt;Ctrl-f&gt;</b>", or the "<b>H</b>"
       button near the top of the "Tree" window.  (The home view is
       one in which the x-coordinate increases from left to right and
       the y-coordinate increases from bottom to top.)  One can also
       get the top view by pressing "<b>&lt;Ctrl-t&gt;</b>"
       or the "<b>T</b>" button, the bottom view by pressing
       "<b>&lt;Ctrl-b&gt;</b>" or the "<b>B</b>"
       button, the left side view by pressing
       "<b>&lt;Ctrl-l&gt;</b>" or the "<b>L</b>",
       or the right side view by pressing
       "<b>&lt;Ctrl-r&gt;</b>" or the "<b>R</b>"
       button.

    <p>The function of the arrow keys depends on whether "flying mode"
       is active or not.  For example, if "flying mode" is not active
       (the default), pressing the "<b>&lt;Left&gt;</b>" key
       causes the object to rotate to the left by 30 degrees; if
       "flying mode" is active (because the "<b>!</b>" key
       was pressed), then pressing the "<b>&lt;Left&gt;</b>"
       key causes the object on the screen to translate to the left.
       If the "<b>Shift</b>" is held while
       the "<b>&lt;Left&gt;</b>" key is pressed, the
       increments are 5 degrees and the translations are also smaller.

    <p>The "<b>&lt;PgUp&gt;</b>" or
       "<b>&lt;Ctrl-i&gt;</b>" keys or the
       "<b>+</b>" button can be used to zoom in and the
       "<b>&lt;PgDn&gt;</b>" or
       "<b>&lt;Ctrl-o&gt;</b>" key or the
       "<b>-</b>" button can be used to zoom out.  The
       behavior of these keys/buttons does not depend on the current
       "flying mode".

    <p>To re-center the image at a given point and simultaneously
       reset the point about which mouse rotations will occur, point
       to any location in the "Graphics" window and press
       "<b>*</b>" or "<b>8</b>"; the image will be
       recentered and a message will be posted in the "Messages"
       window.

    <p>To determine the identity of any object in the "Graphics"
       window, simply put your cursor on the object and press
       "<b>^</b>" or "<b>6</b>"; a summary of the
       identified object is shown in the "Messages" window.  (Note
       that if the cursor is not exactly over any object, the message
       will only be posted once the mouse passes over a graphic
       object.)

    <p>To determine the approximate coordinates of any location in the
       "Graphics" window, simply put your cursor on the location and
       press "<b>@</b>" or "<b>2</b>"; the
       approximate coordinates of the location are shown in the
       "Messages" window.

    <p>To add an Attribute to any Face or Edge, simply put your cursor
       on the object in the "Graphics" window and press
       "<b>A</b>" (upper case A). You will then be asked for
       the name of the new Attribute as well of its value, which can
       either be a string (if is starts with a $) or a semi-colon
       separated list of expressions.

    <p>Lastly, to get help on the commands that are available in the
       "Graphics" window, press "<b>?</b>" and a short
       listing will be given in the "Messages" window.

    <p>The results of several of these commands is shown in:
    <p><img src="pictures/legacy1-03.png" width="100%"/>

    <p>Now it is time to understand the "Tree" window.  When not in
       the Sketcher (the default), at the top of
       the "Tree" window is a series of buttons:
      <ul>
        <li>"<b>File</b>": this button pops up a menu that
        contains:
          <ul>
            <li>"<b>New</b>": this button removes the
              current Model (after prompting the user) and starts a
              new Model</li>
            <li>"<b>Open</b>": this button removes the
              current Model (after prompting the user) and opens the
              user-specified <code>.csm</code> file and builds its
              Model</li>
            <li>"<b>Export FeatureTree</b>": allows a user
              to save the current Feature Tree and Parameters into
              a <code>.csm</code> file.  Beware that using this option
              will over-write any file, causing you to lose any
              formatting or comments that may be in the original
              file</li>

            <li>"<b>Edit</b>": allows a user to edit the
              current <code>.csm</code> file</li>
            </ul>
            The <b>File</b> menu can be removed by
            re-pressing the "<b>File</b>" button.
        <li>"<b>StepThru</b>": this button enters StepThru
            mode (described below)</li>
        <li>"<b>Help</b>": this button opens up
            the <code>ESP</code> HELP document (that you are now
            reading)</li>
        <li>"<b>Up to date</b>": the meaning and text on this
            button will change (as described below)</li>
        <li>"<b>Undo</b>": allows a user to un-do any changes
            to the Model (as described below)</li>
        <li>"<b>H</b>": return to the home (front) view  ("x"
            right and "y" up)</li>
        <li>"<b>L</b>": left-side view ("z" right and "y"
            up)</li>
        <li>"<b>R</b>": right-side view ("z" left and "y"
            up)</li>
        <li>"<b>B</b>": bottom view ("x" right and "z"
            up)</li>
        <li>"<b>T</b>": top view ("x" right and "z"
            down)</li>
        <li>"<b>+</b>": zoom in</li>
        <li>"<b>-</b>": zoom out</li>
      </ul>
      One can verify the view with the little axes at the bottom-left
      corner of the "Graphics" window.  The red axis corresponds to
      "x", the green axis corresponds to "y", and the blue axis
      corresponds to "z".

    <p>Below the buttons is a tree-like representation of the "Design
       Parameters", "Local Variables", and "Branches" that describe
       the current Model.  In all cases, pressing the
       "<b>+</b>" at the beginning of any line expands
       (opens up) that particular entry in the tree; pressing the
       "<b>-</b>" at the beginning of any line collapses
       (closes) that particular entry.

    <p>Start off by pressing the "<b>+</b>" to the left of
       the words "Design Parameters".  When this is done, all the
       Design Parameters in the current Model are displayed as shown
       in:
    <p><img src="pictures/legacy1-04.png" width="100%"/>

    <p>Notice that the Design Parameter names are shown in green type;
       this indicates that the Parameter can be "edited" by the user;
       the Local Variable names are listed in black type and cannot be
       edited.

    <p>Now there are two ways to proceed.  The following paragraphs
       describe the legacy method, using
       the <code>ESP</code> user interface.  This method is similar to
       other CAD systems, but experienced users find that using the
       integrated <code>.csm</code> editor to be much faster and
       easier to debug; it is described at the end of this tutorial.

    <p>Press on the label "Lbar" to edit the Parameter named "Lbar".
       When this is done, the user is provided with an editing form
       that asks for the new value; the current value is pre-loaded in
       this window, as in:
    <p><img src="pictures/legacy1-05.png" width="100%"/>

    <p>For now change the value from "6" to "9" and  press the
       "<b>OK</b>" button or press the "<b>Enter</b>"
       key.  Note that the Parameter name is now listed in red (to
       indicate that it has been changed) and that the button at the
       top of the "Tree" window has changed to a green button that
       says "<b>Press to Re-build</b>".  This tells the user
       that changes have been made (to either a design Parameter or
       Feature Tree), but that the configuration shown in the
       "Graphics" window has not been updated.  (The reason this is
       done is that a user might want to make several changes to the
       "Model" before spending the CPU time necessary to re-build.)

    <p>Press the "<b>Press to Re-build</b>" button and
       notice that it first turns yellow while the configuration is
       being rebuilt.  Then (after a few seconds) the image in the
       "Graphics" window will be updated and the "Design Parameters"
       will no longer be red.

    <p>We will now change the value of "Lbar" back to "6".  (Do not
       re-build yet.)

    <p>Collapse the Parameters by pressing the "<b>-</b>" to
       the left of the word "Design Parameters" and expand the
       Branches by pressing the "<b>+</b>" to the left of
       the word "Branches".  This will result in a screen that looks
       like:
    <p><img src="pictures/legacy1-06.png" width="100%"/>

    <p>There is an "Undo" button near the top of the "Tree" window.
       This button un-does your last change; an example of using this
       is shown later in this tutorial; for now, try not to use this
       button.

    <p>We are going to want to add a SPHERE to this configuration.
       Do this by pressing "<b>Branches</b>", giving you:
    <p><img src="pictures/legacy1-07.png" width="100%"/>

    <p>The different types of Branches that can be added are listed in
       groups.  The groups at the top, which are labeled, generally
       construct or modify Bodys.  The Branches listed at the bottom
       are utilities, which generally effect the order in which the
       Branches are executed.  Those Branches marked with a star (*)
       are deprecated, meaning that they may be removed in future
       versions of ESP.

    <p>We will choose a SPHERE and press the "<b>OK</b>"
       button (or press the "<b>Enter</b>" key), giving us:
    <p><img src="pictures/legacy1-08.png" width="100%"/>

    <p>Now fill in the entries with "xcent" set to "1", "ycent" set to
       "0", "zcent" set to "0", and "radius" set to "2".  An easy way
       to cycle through the various entries is to press
       the "<b>Tab</b>" key. Press the "<b>OK</b>"
       button (or "<b>Enter</b>" key) and then "<b>Press
       to Re-build</b>" and you should see:
    <p><img src="pictures/legacy1-09.png" width="100%"/>

    <p>Now let's look at the "Display" part of the "Tree" window.  By
       default "Display" is expanded and you can see that you have two
       bodies named "Body 10" and "Body 9".  Expand the listing for
       Body 9 by pressing the "<b>+</b>" to the left of
       "Body 9" and you will see entries for Faces, Edges, Nodes, and
       Csystems.  To the right of "Faces" (below "Body 9") you will
       see three items:
      <ul>
        <li><b>Viz</b>: toggles the visibility of all Faces
          associated with Body 9</li>
        <li><b>Grd</b>: toggles the grids associated with all
          the Faces in Body 9</li>
        <li><b>Trn</b>: toggles the pseudo-transparency of
          all the Faces associated with Body 9</li>
      </ul>
      Try each of these and see what happens.  (Notice that Body 9 is
      the original solid and Body 10 is the new sphere.)

      In addition, you can also change the display characteristics
      with key-presses in the Graphic window.  Hover over an entity
      and press:
      <ul>
        <li>"<b>v</b>" to toggle the visibility (Note that
          you will need to turn visibility on in the Tree Window since
          there is nothing to point to to turn it on in the Graphics
          Window.)</li>
        <li>"<b>g</b>" to toggle the grid</li>
        <li>"<b>t</b>" to toggle the transparency</li>
        <li>"<b>o</b>" to toggle the orientation</li>
      </ul>

    <p>Notice also that there is a "<b>+</b>" to the left of
       "Faces", which indicates that you can interact with the object
       on a Face-by-Face basis.  The basic rules here are:
      <ul>
        <li>changes made to a specific entity (such as a Face or Edge)
          applies only to that entity</li>
        <li>changes made to the heading (such as "Faces") applies
          to all Faces in the group</li>
        <li>changes made at the Body level applies to all Faces and
          Edges in the body</li>
      </ul>

    <p>When you have a configuration with lots of Bodys, it is
       sometimes useful to turn the visibility of all Faces, Edges, or
       Nodes (in all Bodys) on or off.  This can be done by pressing
       on the word "<b>Display</b>" in the Key Window.

    <p>Now let's combine the sphere and the original solid by adding a
       UNION Branch.  (Press "<b>Branches</b>" and add a
       UNION).  This operation wants to know if the operation should
       be applied to the top two Bodys on the stack (tomark=0) or to
       all the Bodys on the stack since the last mark (tomark=1).  For
       now, we want to use the default (tomark=0).  Also, we want an
       untrimmed union (the default), and so set (trimList=0).
       Lastly, we do not want to modify the tolerances associated with
       this operation, so use the default (maxtol=0).  Re-build the
       configuration and you should get the solid shown in:
    <p><img src="pictures/legacy1-10.png" width="100%"/>

    <p>Note that we now only have one body. (Body 11)

    <p>After some thought you realize that you really didn't want the
       union (or fusion) of these two volumes, but instead you wanted
       the solid that is common to them (that is, their intersection).
       First, remove the UNION; this can easily be done by clicking on
       "Brch_00012" and then choosing "Delete this Branch".
       (Alternatively you could press the "Undo" button at the top of
       the "Tree" window; but if you use "Undo" the Branch numbering
       will be slightly different, making it slightly more difficult
       to follow the directions in this tutorial.)

    <p>Now add the intersection by pressing
       "<b>Branches</b>" and then choosing INTERSECT.
       This operation wants to know what happens if more than one
       solid is produced by the operation.  Specifically, the "$order"
       argument describes how the bodies that are produced should be
       ordered: for example in order of volume, surface area, ...  The
       "index" argument tells which body in the list should be
       selected.  Since we are only expecting one body to be produced,
       we can leave the defaults.  Also, for now we do not want to
       modify the tolerances, so leave the default (maxtol=0) and then
       "<b>Press to Re-build</b>", producing:
    <p><img src="pictures/legacy1-11.png" width="100%"/>

    <p>You notice that the "head" is too thin, and so you change the
       "radius" of the SPHERE to "2.3".  (Press "Brch_000011" and
       change the "radius".)  While you are at it, change the
       Parameter "Rbar" to "0.4" (you will need to expand the Design
       Parameters) and rebuild, producing:
    <p><img src="pictures/legacy1-12.png" width="100%"/>

    <p>Now we want to drill a hole through the center of the shaft;
       this is done by subtracting a cylinder from the solid.  Create
       a cylinder by selecting "<b>Branches</b>" and
       CYLINDER.  We want the hole to go the entire length of the
       configuration (which is centered and whose length is 2*L), and
       so we enter "-1.2*L" for "xbeg" and "+1.2*L" for "xend"; the
       "1.2" simply ensures that the cylinder extends beyond the end
       of the configuration.  Since it is on the centerline, set
       "ybeg", "zbeg", "ybeg", and "yend" all to "0", and finally the
       "radius" to "0.2".

    <p>Note that any argument can either be entered as a numeric
       constant or as an expression (using Matlab-like syntax),
       possibly using the name of a Design Parameter (such as "L") or
       a Local Variable.

    <p>To add the SUBTRACT Branch, we will click on
       "<b>Branches</b>" and then choose SUBTRACT, use the
       defaults and rebuild, producing:
    <p><img src="pictures/legacy1-13.png" width="100%"/>

    <p>You can now proceed to the <a href="#sec2.7c">common part of
       the tutorial</a> or take a detour to explore the new
       integrated <code>.csm</code> editor (which is next).

    <p>Now we want to create a series (pattern) of small holes that
       are drilled across the shaft.  Start by creating a new
       Parameter (by clicking on "<b>Design Parameters</b>")
       and name it "Rhole".  The rules for names is that they must
       start with a letter and contain up to 32 letters, digits,
       colons, and underscores.  By default the new "<b>Design
       Parameter</b>" contains only one value (that is, it is a
       scalar).  (Aside: If one wants a row vector, a column vector,
       or a 2D matrix, press the "<b>Add row</b>" or
       "<b>Add column</b>" button before entering values in
       the table.)

    <p>Since we only want a scalar, just use the standard form, such
       as:
    <p><img src="pictures/legacy1-14.png" width="100%"/>

    <p>Set the (only) value to "0.08".  You can either press the
       "<b>OK</b>" button or press
       the "<b>Enter</b>" key to save this value.

    <p>Now we are going to add a pattern of holes.  Do this by adding
       a new PATBEG Branch; the "$pmtrName" will be "i" and the
       "ncopy" will be 7 (since we want 7 holes).  (The "$" at the
       beginning of "$pmtrName" says that this is the name of the
       Parameter that will be created rather than the value of the
       Parameter "i").  This will produce a warning in the Messages
       window that informs us that we do not yet have a matching
       PATEND statement yet.

    <p>Also add a CYLINDER with "xbeg" and "xend" set to "i/3", "ybeg"
       and "yend" set to "0", "zbeg" set to "-1", "zend" set to "+1",
       and "radius" set to "Rhole".  Press "<b>OK</b>" or
       "<b>Enter</b>".  Again you will get the warning
       telling you that you still do not have a matching PATEND.

    <p>We would now like to name this Branch.  To do this, edit the
       Branch (by pressing "Brch_000017") and change its "Name" to
       "small_holes".  (Notice that we could not name it when we
       created it since the names are originally auto-created to
       ensure that we do not get an illegal name.)

    <p>Next add another SUBTRACT Branch (with the default arguments)
       and finally a PATEND Branch and then re-build (which will take
       several seconds), giving:
    <p><img src="pictures/legacy1-15.png" width="100%"/>

    <p>Now we want to change the hole in the center of the shaft into
       a hole that starts at "xbeg" equal to "0".  Make the change to
       "Brch_000014" and re-build.  To see if you were successful,
       change the visibility of the faces and ensure that you have the
       correct hole, as in:
    <p><img src="pictures/legacy1-16.png" width="100%"/>

    <p>Now change the cylindrical hole into a conical hole.  To do
       this, we must delete the cylinder hole (which is Brch_000014).
       Click on "Brch_000014" and choose "Delete this Branch".  Notice
       that doing this warns you that the Branches are not properly
       nested.  To fix the error, add a conical hole after
       "Brch_000013" by clicking "Brch_000013" and choosing "Add new
       Branch after this Branch", as in:
    <p><img src="pictures/legacy1-17.png" width="100%"/>

    <p>Re-build and notice that the vertex of the cone is near the
       head; you will have to change the visibility of the Faces to
       see this.  We had meant to do it the other way, so change
       "xvrtx" to "0" and "xbase" to "1.2*L" and re-build, producing
       (after manipulating the display):
    <p><img src="pictures/legacy1-18.png" width="100%"/>

    <p>A new ESP feature is to visually step through the build
       process.  This is particularly useful when you want to
       understand the build process that was used in
       a <code>.csm </code> file that you acquired from another
       source.  To do this press the "<b>StepThru</b>"
       button and you should see:
    <p><img src="pictures/legacy1-19.png" width="100%"/>

    <p>This is the result of executing the first Branch that created a
       Body. You can now press "<b>NextStep</b>" four times
       and you should see:
    <p><img src="pictures/legacy1-20.png" width="100%"/>

    <p>You can either continue pressing the
       "<b>NextStep</b>" button (or press the
       "<b>n</b>" key in the Graphics window (for next))
       until you get to the end of the build, you can press the
       "<b>p</b>" key for previous, or you can press
       "<b>Cancel StepThru</b>" in the Tree Window to return
       to the normal viewing mode.

    <p>By now you probably have noticed that the Branches with a
       pattern (that is, between the PATBEG and PATEND) are hidden; to
       see these, press the <b>+</b> to the left
       of <b>Brch_000016</b>. Now let's rotate the small
       holes, so after the "small_holes" Branch, add a ROTATEX with
       arguments "-15*(i-1)", "0", and "0", and rebuild, producing:
    <p><img src="pictures/legacy1-21.png" width="100%"/>

    <p>Now we will experiment with the "activity" of the Branches.  A
       Branch that is "suppressed" is skipped during the re-build
       process. So click on "Brch_000021" (you will need to
       expand the listing of the pattern first) and change the
       "Activity" from "Active" to "Suppressed", and select
       "<b>OK</b>" or press "<b>Enter</b>".  When
       you rebuild, you should see:
    <p><img src="pictures/legacy1-22.png" width="100%"/>

    <p>Re-activate "Brch_000021" and re-build.

    <p>Another feature is <code>ESP</code> allows a user to only build
       part of the configuration.  This is done by clicking on a
       Branch (for example, "Brch_000010") and choosing "Build to this
       Branch", giving:
    <p><img src="pictures/legacy1-23.png" width="100%"/>

    <p>To rebuild the whole configuration, either re-build to the last
       Branch by clicking it and choosing "Build to this Branch" or
       press the "Up to date" button (which will ask if you are sure
       before regenerating the configuration).

    <p>The next part of the <code>ESP</code> tutorial involves
       Attributes.  Each Branch can have zero or more Attributes
       associated with it that are carried throughout the build
       process.  Open the "Brch_000009" Branch for editing and press
       "<b>Show Attributes/Csystems</b>".  You will see that
       this Branch has an Attribute ("clipper") that has the value
       "1".  Change the Attribute to "10", and
       press <b>OK</b>.

    <p>We can add an Attribute to "Brch_000009" by editing it,
       pressing "<b>Show Attributes/Csystems</b>", and then
       "<b>Add Attribute/Csystem</b>".  The first choice is
       whether we want to add an Attribute or a Csystem; we want to
       enter "1"; we will use the name "test" and the value "ESP".
       After some thought, you realize that "ESP" is not defined (that
       is, does not have a value), so you can "undo" this change by
       pressing the "Undo" button at the top of the "Tree" window.
       Re-build.

    <p>Now point to the face that represents the corner of the head
       (as shown with its grid here) and press the
       "<b>^</b>" or "<b>6</b>" key, producing:
    <p><img src="pictures/legacy1-24.png" width="100%"/>

    <p>(Depending on the version of OpenCASCADE that you are using,
       the face number that is returned may be different.)

    <p>Note that the "Messages" window contains a description of the
       face including the Attribute that we edited ("clipper" is "10")
       as well as a "_body" and "_brch" Attribute.  The latter tells
       which Branch ("Brch_000009") was responsible for generating
       that face.

    <p>You can also add Attributes graphically.  Point to the same
       Face and press the "<b>A</b>" key.  When prompted for
       an Attribute name, enter "partID", and when prompted for the
       Attribute value, enter the semicolon-separated list
       "1;2;sqrt(3)".  (Alternatively, you could have entered
       "$1;2;sqrt(3)" to add that string value, as signified by the
       leading dollar sign ($)). Rebuild.  Then press
       the "<b>^</b>" key to verify that the Face has your
       new Attribute.

    <p>A unique feature of ESP is that it allows a user to compute the
       geometric sensitivity of the configuration with respect to any
       perturbation in the specified Parameters.  Most often this is
       done by clicking on a the name of one of the Design Parameters
       and selecting "<b>Compute Sensitivity</b>".

    <p>For the current case, expand the Parameters list (in the Tree
       window) and click on "Rbar" and select "<b>Compute
       Sensitivity</b>".  ESP notes this by putting a caret
       before the "Rbar" and then will automatically compute the
       sensitivity and display, in the Graphics window, an updated
       configuration that is colored based upon the change in the
       local surface normal; positive sensitivity indicates that the
       surface will tend to move in the direction of the outward
       normal.  The Key window will show the meanings of the various
       colors and will be titled "d(norm)/d(Rbar)", as in:
    <p><img src="pictures/legacy1-25.png" width="100%"/>

    <p>To change the limits of the color spectrum, left click in the
       Key window and you will be prompted for the minimum value
       (associated with blue) and the maximum value (associated with
       red). Try clicking on the Key window and set the limits to
       "-0.5" and "+0.5" and see how the display changes.

    <p>Now ask for the sensitivity with respect to "D" (click on "D"
       and select "<b>Compute Sensitivity</b>") and again
       the display will automatically update.

    <p>Occasionally one wants to know the change in the configuration
       based upon the perturbation of more than one Parameter (at the
       same time).  To do this, first click on "Rbar" and clear all
       the Design Velocities by clicking on "<b>Clear Design
       Velocities</b>", and then "<b>Set Design
       Velocity</b>" to 1; then click on "Rhole" and "<b>Set
       Design Velocity</b>" to 1.5.  Now manually re-build the
       configuration (since you may want to set the Design Velocity
       for multiple Parameters before rebuilding).  Note that the
       legend in the Key window will now be "d(norm)/d(***)",
       indicating that there was either more than one Design Parameter
       for which the Design Velocity was set (see that Rbar and Rhole
       both are pre-pended with a caret to indicate this), or there is
       one Parameter whose Design Velocity is not unity (and hence the
       color does not show sensitivity but rather a scaled
       sensitivity.)

    <p>Save your work by pressing the "<b>File</b>" button,
       then the "<b>ExportFeatureTree</b>" button, and
       finally entering "tutorial1_new.csm" as the name of the new
       file.

    <p>Now explore the <b>.csm</b> editor.  Choose
       "<b>File</b>" button, then the
       "<b>Edit</b>" button.  The version of your file will
       be displayed.  The buttons across the top perform various
       editing tasks.
    <p><img src="pictures/legacy1-26.png" width="100%"/>

    <p>The integrated editor has a row of buttons at the top:
      <ul>
        <li>"<b>Copy</b>": take highlighted text and puts a
          copy of it into the clipboard
        <li>"<b>Cut</b>": remove highlighted text and put it
          into the clipboard
        <li>"<b>Paste</b>": put copy of the clipboard at the
          current cursor location
        <li>"<b>Search</b>": look for a string (see prompt
          near top of screen). The search is case sensitive.
        <li>"<b>Prev</b>": look for previous occurrence of
          current search string
        <li>"<b>Next</b>": look for next occurence of
          current search string
        <li>"<b>Replace</b>": replace current search string
          with the replacement text (see prompt near top of screen)
        <li>"<b>Comment</b>": for the current highlighted
        text
          <ul>
            <li>if the first line is uncommented, comment all lines that
              are highlighted
            <li>if the first line is commented, uncomment all lines
              that are highlighted (if possible)
          </ul>
        <li>"<b>Indent</b>": use standard indentation for
          all highlight lines
        <li>"<b>Hint</b>": provide a hint of the arguments
          associated with the line at the current cursor (see top of
          screen for hint)
        <li>"<b>Undo</b>": undo the last change
        <li>"<b>Cancel</b>": exit the editor and do not save
          changes
        <li>"<b>Save</b>": save the changes and exit the
        editor
          <ul>
            <li>if editing the <code>.csm</code> file and there are no
              current <code>.udc</code> files, then the configuration
              is automatically rebuilt
            <li>otherwise, you will need to press "<b>Press to
                Rebuild</b>" to rebuild the configuration
          </ul>
      </ul>

    <p>Note that the text in the file is colored:
      <ul>
        <li>comments are show in <b>grey</b>
        <li>command names are shown in <b>blue</b> (this is
          an easy way to check that you have spelled the command name
          correctly)
        <li>parameter names are shown in <b>yellow</b>
        <li>numbers are shown in <b>green</b>
        <li>strings are shown in <b>magenta</b>
        <li>quotation marks (which show the extent of an argument) are
          shown in <b>cyan</b>
      </ul>

    <p>Start by highlighting lines 12 and 13 and then press the
       "<b>Copy</b>" button.  You can then move your  cursor
       to the beginning of line 14 and press "<b>Paste</b>",
       which will insert the copied text.  Highlight lines 14 and 15
       and press "<b>Cut</b>" to remove the text you just
       added.

    <p>Place your cursor on somewhere on line 1 and press the
       "<b>Search</b>" button.  At the top, enter "Rbar" and
       press <b>Enter</b>.  You can press
       "<b>Next</b>" and "<b>Prev</b>" to go to
       the next and previous occurrences.  You can replace text using
       the "<b>Replace</b>" button.

    <p>You can provide block-comments.  Highlight lines 42 through 44
       and press the "<b>Comment</b>" button to add a
       block-comment.  If you now highlight line 43 and press
       "<b>Comment</b>" again, you will see that line 43 was
       uncommented (since the first highlighted line contains a
       block-comment). Remove the whole block-comment by highlighting
       lines 42 through 44 and pressing "<b>Comment</b>"
       again.

    <p>The "<b>Hint</b>" button gives you a hint on the
       current command.  For example, pressing the button with the
       cursor somewhere on line 29 show the hint for the CYLINDER
       command at the top of the editor window.

    <p>Finally exit the browser and you should see
       that <code>serveESP</code> also shuts down.

    <p>If we now rename the file journal file (which was automatically
       generated while you were running ESP) with:
      <pre>
        mv port7681.jrnl tutorial1.jrnl
      </pre>
      we can replay our session by the command:
      <pre>
        serveESP ../data/legacy/tutorial1 -jrnl tutorial1.jrnl
      </pre>
      This replays all your operations, so it may take a while to
      execute.

    <p>Alternatively, we can start with the new
      <code>tutorial1_new.csm</code> file (which we just created
      above) with the command:
      <pre>
        serveESP tutorial1_new
      </pre>
      This will run more quickly since it simply executes the final
      Feature Tree (of Branches).

    <p>This tutorial covered most of <code>ESP</code>'s user
       interface.  Further details are contained in the sections that
       follow.

    <p>Now we will learn how to develop a configuration using the
       integrated editor.  Make a copy of the
       original <code>.csm</code> file and
       restart <code>serveESP</code>.
      <pre>
       cp       ../data/legacy/tutorial1.csm ../data/legacy/tutorial1_temp.csm
       serveESP ../data/legacy/tutorial1_temp
      </pre>
      or
      <pre>
       copy     ..\data\legacy\tutorial1.csm ..\data\legacy\tutorial1_temp.csm
       serveESP ..\data\legacy\tutorial1_temp
      </pre>

    <p>Start by pressing the "<b>File</b>" button and then
       "<b>Edit: ../data/legacy/tutorial1_temp.csm</b>".  This will
       display the contents of the (original) tutorial file in code
       form. Notice at the top you have Design Parameters with their
       given values which are followed by the Branches and their
       arguments.

    <p>Start by finding the Design Parameter "Lbar", shown in the line
       "<code>despmtr Lbar 6.00</code>" on your screen. You can edit
       this parameter by simply changing the number. Do this now,
       change the "6.00" to "9.00" and then press
       "<b>Save</b>". This will change the length of the bar
       and automatically rebuild the model.

    <p>Return to "<b>Edit</b>" and change the value of
       “Lbar” back to “6.00”, but do not save yet. We will now add a
       SPHERE branch to the model. To do this, add a line under the
       "intersect" corresponding to "clip weights with outer cylinder"
       that reads "SPHERE".  This branch needs four arguments, which
       are "xcent", "ycent", "zcent" and "radius". If you would like
       to see for yourself, put your cursor somewhere in the word
       "SPHERE" and then press the "<b>Hint</b>" button at
       the top of the screen. This button will tell you the required
       arguments for any branch you add. Now set these arguments as
       "xcent" set to "1", "ycent" set to "0", "zcent" set to "0", and
       "radius" set to "2"; in other words, add the line "<code>SPHERE
       1 0 0 2</code>" and press "<b>Save</b>".

    <p>Now try to combine the sphere and the original solid by adding
       a "UNION" Branch under the line that starts with
       "SPHERE". Re-build by saving the edits. Notice that this is not
       the shape we wanted. To fix this replace the "UNION" Branch
       with an "INTERSECT" Branch and save again.

    <p>Now you can see that the head of our shape is too thin, so
       increase the radius of the sphere from "2" to "2.3", and while
       you are at it change the design parameter "Rbar" to "0.4".

    <p>The next step is to create a hole through the center of the
       shaft. To do this we will create a CYLINDER and then SUBTRACT
       it from the solid. Create a new "CYLINDER" Branch with
       the arguments "-1.2*L" and "+1.2*L" for "xbeg" and "xend"
       respectively, as well as "0" for "ybeg", "zbeg", "yend", and
       "zend". Finally, set "radius" to "0.2".  Remove the material in
       this new
       cylinder from the existing solid by adding a "SUBTRACT" Branch under the
       new "CYLINDER" line.  In other words, add the lines
      <pre>
       CYLINDER  -1.2*L  0.0  0.0  +1.2*L  0.0  0.0  0.2
       SUBTRACT
      </pre>
       and "<b>Save</b>".

    <p>As you can see, the ideas are the same as using
       the <code>ESP</code> Tree Window, but experienced users find it
       much faster using the integrated editor.

    <p><h3 id="sec2.8">2.8 Second legacy tutorial: Sketcher</h3>

    <p>For the second tutorial, we will start <code>serveESP</code>
       without a <code>.csm</code> file and investigate the use of the
       Sketcher.

    <p>Start <code>ESP</code> by issuing the command:
      <pre>
        serveESP
      </pre>

    <p>If you have not set the <code>ESP_START</code> environment
       variable, you will have to open a browser on a file
       named <code>../ESP/ESP.html</code> and select the default
       hostname and port (Localhost:7681).  A blank
       <code>ESP</code> should open up for you.

    <p>We are going to start with an empty sketch.  To do this we will
       first add a SKBEG Branch by pressing
       "<b>Branches</b>", selecting a SKBEG, and making
       the "x", "y", and "z" all zero.  The final
       argument, <code>relative</code>, is set to 1 to indicate that
       all coordinates in the sketch are relative to the coordinates
       that were contained in the SKBEG statement.

    <p>When a SKBEG Branch is added, ESP now automatically adds the
       matching SKEND Branch and automatically enters the Sketcher.

    <p>There are several changes between normal 3D mode and the
       Sketcher.  The first difference are the buttons on the top of
       the "Tree" window.  A second button has now appeared that is
       labeled "<b>Sketch</b>", which will pop up a menu
       with the entries:
      <ul>
        <li>"<b>Save</b>": this will save the current Sketch
          and exit the Sketcher</li>
        <li>"<b>Quit</b>": this will exit the Sketcher (with
          all the work done in the Sketcher being lost)</li>
      </ul>

    <p>The legend on another button has now changed to
       "<b>Drawing...</b>", which describes the status of
       the Sketcher.

    <p>Also, the "Key" window now lists the Sketcher's status, in
       terms of the number of degrees of freedom (<code>ndof</code>)
       and the number of constraints (<code>ncon</code>).  This is
       followed by a listing of the available commands in the
       Sketcher.

    <p>Within the Sketcher (which is displayed in the "Graphics"
       window), there is a point at the center that has the legend
       "XY" and a blue line between that point and the current cursor
       location.  As you move the cursor around in the Sketcher, you
       will notice that the blue line follows the cursor.  You will
       also notice that if the line is approximately horizontal or
       vertical, it will change from blue to orange; this is an
       indication that if the current cursor location is chosen (see
       below), an implicit "horizontal" or "vertical" constraint will
       be created.

    <p>As you can see in the "Key" window, you have 6 choices:
      <ul>
        <li><b>l</b> - create a line segment (LINSEG) in the
          sketch</li>
        <li><b>c</b> - create a circular arc (ARC) in the
          sketch</li>
        <li><b>s</b> - add a spline point (SPLINE) to the
          sketch</li>
        <li><b>b</b> - add a Bezier control point (BEZIER)
          to the sketch</li>
        <li><b>z</b> - add a zero-length segment</li>
        <li><b>o</b> - finish the sketch (that is, leave a
          sketch open)</li>
      </ul>

    <p>If you just press the mouse button, the "<b>l</b>"
       option will be chosen for you.  So now, draw the sketch shown
       in:
    <p><img src="pictures/legacy2-01.png" width="100%"/>
    <p>in a counter-clockwise direction, starting at the point with
       the label "XY".  Make sure that when you have completed the
       closed sketch, the last point should be the same as the first
       point.  You can ensure this by noting that a circle is placed
       around the first point if the last point is "close enough".

    <p>Notice that several of the line segments have either the letter
       "H" or "V" associated with them.  These "horizontal" or
       "vertical" constraints were automatically added for you since
       you pressed "<b>l</b>" or the mouse button when the
       line was orange.  Also notice that since you "closed" the
       sketch, it got filled in with grey.  (If you had left it open
       by pressing the "o" key, there would be no filling.)

    <p>Your completed sketch should now have 16 degrees of freedom
       (since there are 8 points and no arcs) and 10 constraints.  To
       see what the meaning of the various constraint letters are,
       notice that the "Key" window has now changed to explain the
       meaning of the constraints.  In summary, at the first point,
       both the "x" and "y" coordinates are fixed.  The other
       constraints are that certain line segments are either
       constrained to be horizontal (H) or vertical(V).

    <p>Since the number of constraints is fewer than the number of
       degrees of freedom, we will have to add more constraints.

    <p>If you do not know what constraint(s) to add, press the
       "<b>Constraining...</b>" button and several choices
       will be presented to you (in green), as in:
    <p><img src="pictures/legacy2-02.png" width="100%"/>
    <p>We will choose the following:
      <ul>
        <li>put the cursor over the middle of the bottom segment and
          press "<b>L</b>" (which will set its length) and
          enter "4" in the pop-up</li>
        <li>put the cursor over the left vertical line, press
          "<b>L</b>" and enter "3"</li>
        <li>put the cursor over the right vertical line, press
          "<b>L</b>" and enter "3"</li>
        <li>put the cursor over the horizontal segment at the
          top-left, press "<b>L</b>", and enter "1"</li>
        <li>put the cursor over the horizontal segment at the
          top-right, press "<b>L</b>", and enter "1"</li>
        <li>put the cursor over the vertical segment on the left side
          of the slot, press "<b>L</b>", and enter "2"</li>
      </ul>

    <p>Since the number of constraints matches the number of degrees
       of freedom, the grey fill has changed to a light green fill and
       the first button has turned green with the legend
       "<b>Press to Solve</b>".  Press that button and
       (hopefully) your sketch will solve.  (If it does not, you can
       always remove constraints by moving the cursor over the
       constraint and pressing "<", which deletes selected constraints
       at that point or on that segment.)  To center the image, either
       press <Ctrl-H> or press the "<b>H</b>" button.  You
       screen should look like:

    <p><img src="pictures/legacy2-03.png" width="100%"/>

    <p>We are now finished with the Sketcher (for now), so press
       "<b>Sketch</b>" and then "<b>Save</b>" to
       return to the normal 3D view.  You can now press "<b>Press
       to Re-build</b>" to rebuild the 3D object, giving a screen
       that looks like:

    <p><img src="pictures/legacy2-04.png" width="100%"/>

    <p>You will notice that we hard-coded dimensions into our sketch.
       To make the sketch more useful, it would be convenient to drive
       it with Design Parameters.  To do this, we first have to create
       them.  This is done (as in tutorial 1) by pressing
       "<b>Design Parameters</b>" in the "Tree" window,
       entering "length" as the Parameter name and setting its value
       to "4".

    <p>In a similar way, create a "height" Design Parameter whose
       value is "3" and a "thick" Design Parameter whose value is
       "0.5".

    <p>Now, let's use these Design Parameters in the sketch.  To do
       this, choose one of the statements between the SKBEG and
       SKEND.  I suggest choosing "Branch_00003", which is the
       SKVAR statement (which shows the default locations of each of
       the sketch points).  Select "<b>Enter Sketcher</b>".

    <p>We are now going to change the various "L" constraints, by
       moving the mouse over the "L", pressing "<b>L</b>"
       and entering the new value.  Specifically, you should change
       the "L" constrains as follows:
      <ul>
        <li>bottom should have length set to "length"</li>
        <li>left should have its length set to "height"</li>
        <li>right should have its length set to "height"</li>
        <li>top-left should have its length set  to "thick"</li>
        <li>top-right should have its length set  to "thick"</li>
        <li>left side of slot should have its length set to
          "height-thick"</li>
      </ul>

    <p>"<b>Press to Solve</b>", giving:

    <p><img src="pictures/legacy2-05.png" width="100%"/>

    <p>"<b>Sketch</b>" and "<b>Save</b>" (to exit
      the Sketcher) and "<b>Press to Re-build</b>" to use
      the latest changes.

    <p>Think about what we have done.  We have made a U-shaped channel
       whose overall length and height were given, and whose channel
       walls were all set to "thick".  Suppose instead that the
       "design intent" of the channel was to create a channel of a
       given slot width.  In this case, we would want to constrain the
       sketch differently.

    <p>Start by creating a Design Parameter named "slot" whose single
       value was "1".  Now select "Branch_000002" and "<b>Enter
       Sketcher</b>".  We are going to have to remove the "L"
       constraints from the top two horizontal segments, so go to each
       and press "<b>&lt;</b>".  Since there are two
       constraints here, you are asked which constraint to remove.
       Simply enter "L" at the prompt and the length constraint will
       be removed by the horizontal constraint will remain.  If you
       want to remove all constraints, press "<b>&lt;</b>"
       multiple times.

    <p>Now move the mouse over the horizontal segment at the bottom of
       the slot and press "<b>L</b>" and set the length to
       "slot".  You will notice that the sketch is under-constrained
       (is grey).  We need to add a constraint that the slot is
       centered.  To do this, we are going to make the lengths of the
       two small horizontal segments near the top on each side of the
       U equal to each other.  The first step here is to identify one
       of the segments.  This is done with the "<b>?</b>"
       command.  So, move the cursor over the top-left horizontal
       segment and press "?".  You will notice in the "Messages"
       window that this is segment 7.  Now move over the top-right
       horizontal segment and enter the length "::L[7]", which tells
       it to use the same length as segment 7.  "<b>Press to
       Solve</b>" to give:

    <p><img src="pictures/legacy2-06.png" width="100%"/>

    <p>"<b>Sketch</b>" and "<b>Save</b>" and
       "<b>Press to Re-build</b>".

    <p>Now open the list of Design Parameters (using the
       "<b>+</b>" to the left of "Design Parameters") and
       change the value of "slot" to "2".  "<b>Press to
       Re-build</b>" to see the effect of this change.

    <p>We will now experiment with some of the other constraints.
       Specifically we will be removing some of our "H" and "V"
       constraints and instead add constraints at some of the points.
       Re-enter the Sketcher and move the cursor over the right-hand
       segment, press "<b>&lt;</b>" to remove the vertical
       constraint.  Similarly remove the horizontal constraint from
       the top-right horizontal segment.

    <p>The sketch is under-constrained (is grey).  We are going to add
       a perpendicularity constraint at the point at the lower-right
       corner by moving the mouse over the point and pressing
       "<b>P</b>".  Just to be different, at the top-right
       point we are going to add an "angle" constraint by pressing
       "<b>A</b>" and adding a value of "90".

    <p>"<b>Press to Solve</b>" and "<b>Sketch</b>"
       and "<b>Save</b>".

    <p>We are now going to extrude the sketch into a solid.  This is
       done by first creating a Design Parameter named "depth" and
       giving it a default value of "3".  Then add an EXTRUDE
       Branch, whose arguments are "dx"="0", "dy"="0", and
       "dz"="depth".  This will extrude the sketch in the "z"
       direction (out of the screen).  "<b>Press to
       Re-build</b>", yielding:

    <p><img src="pictures/legacy2-07.png" width="100%"/>

    <p>As with most programs, it makes sense to periodically save your
       work, so press "<b>File</b>", "<b>Export
       FeatureTree</b>", and save the current model in a file
       named "<code>../data/legacy/tutorial2</code>".  (Note that the
       "<code>.csm</code>" suffix will automatically be added for
       you.)

    <p>To see the <code>.csm</code> file associated with the current
       model, press the "<b>File</b>" and
       "<b>Edit</b>" buttons.  At the top of the file, all
       the Design Parameters are defined (along with their current
       values).  This is followed by the Branches in the Feature Tree.
       Note that the sketch starts with a SKBEG statement.  This is
       followed by a SKVAR statement that specifies the initial
       locations of the various points in the sketch.  (These
       positions were automatically set up for you when you drew the
       sketch).  Following that , there is a series of SKCON
       statements that define the various constraints in the Sketcher.
       The first argument of each SKCON statement is the constraint
       type (which corresponds with the letters in the Sketcher),
       followed by the point (or segment) number and the value; again
       these were automatically set up for you when you drew the
       sketch and constrained it.  This is then followed by a series
       of LINSEG Branches, which say that our current sketch is made
       up of a series of line segments.  Again the number of the
       points to use in the LINSEG Branches was set up automatically
       for you.

    <p>Press "<b>Cancel</b>" to exit the editor and return
       to the normal view.

    <p>We are now going to create another sketch, which will be used
       to cut a hole in the bracket's left upright. This cut will be
       parameterized with a Design Parameter named "rad" whose sole
       value is "0.5".  (You can create that now.)

    <p>Now we want to create a new sketch.  We do this by adding a
       SKBEG Branch (with all "0" arguments).

    <p>The sketch that we are going to create consists of a
       race-track-shape curve, as shown in:

    <p><img src="pictures/legacy2-08.png" width="100%"/>

    <p>This is done with the following actions. Draw a horizontal
       segment off to the right (make sure the line from the last
       point is drawn in orange) and press "<b>L</b>" (or
       click the mouse) to create the first horizontal segment.  Then
       move the mouse up and press the "<b>C</b>" key to
       create a circular arc segment.  When you have done that, the
       segment that you just created turns red and follows the cursor;
       move the cursor and see how it changes.  Once it is located at
       approximately the correct location, press the mouse button.
       Then sketch the horizontal line segment to the left, a circular
       arc on the left end, and finally a line segment back to the
       original point.

    <p>You might be wondering why the bottom of the racetrack was
       created with two LINSEGs.  The reason is that we are
       ultimately going to want to center the sketch on the left-leg
       of the bracket, so having a point at the "center" of the sketch
       will be convenient.

    <p>We are now going to constrain the sketch as follows:
      <ul>
        <li>"L" constraint on bottom-left horizontal segment set to
          "rad"</li>
        <li> "L" constraint on bottom-right horizontal segment set to
          "rad"</li>
        <li>"R" constraint on the right-hand circle set to "rad" (that
          is, you set the circular arc's radius)</li>
        <li>"T" constraint (tangency) at the point at the bottom of
          the left-hand arc</li>
        <li>"T" constraint (tangency) at the point at the bottom of
          the right-hand arc</li>
        <li>"T" constraint (tangency) at the point at the top of the
          left-hand arc</li>
        <li>"T" constraint (tangency) at the point at the top of the
          right-hand arc</li>
      </ul>

    <p>"<b>Press to Solve</b>", zoom in (using the
       "<b>+</b>" button) and center the sketch in the
       window (using the "<b>H</b>") button, yielding:

    <p><img src="pictures/legacy2-09.png" width="100%"/>

    <p>"<b>Sketch</b>" and "<b>Save</b>" and
       "<b>Press to Re-build</b>". If you turn the
       configuration around, you will see the sketch at the back left
       bottom corner, as in:

    <p><img src="pictures/legacy2-10.png" width="100%"/>

    <p>We want to rotate this to be parallel with the <em>y-z</em>
       plane by adding a ROTATEY Branch (with arguments "90", "0",
       "0"), move it to its proper location by adding a TRANSLATE
       Branch (with arguments "0", "height-3*rad", and "depth/2").  If
       you "<b>Press to Re-build</b>" you will see that the
       sketch is now properly positioned.  We can then add an
       EXTRUDE Branch (with arguments "length/2", "0", and "0") and
       finally subtract that new volume by adding a SUBTRACT Branch
       (with the default arguments).  If you "<b>Press to
       Re-build</b>", you should get:

    <p><img src="pictures/legacy2-11.png" width="100%"/>

    <p>Now we will add a chamfer at the edges of the cut-out that the
       just made.  Add a Design Parameter named "filrad" whose sole
       value is "0.1" and a new CHAMFER Branch whose arguments are
       "filrad" and "0" (meaning all Edges).  "<b>Press to
       Re-build</b>", yielding:

    <p><img src="pictures/legacy2-12.png" width="100%"/>

    <p>We are now going to make another cut-out for the right leg of
       the bracket.  As usual, make a SKBEG Branch (with all zero
       arguments). The figure that we want to sketch looks like:

    <p><img src="pictures/legacy2-13.png" width="100%"/>

    <p>To make this, start by drawing a horizontal line segment to the
       right (by pressing the "<b>L</b>" key).  We are now
       going to set the control points for a Bezier curve.  Do this by
       moving the cursor above the original point and pressing
       "<b>B</b>".  We then continue to add one
       "<b>B</b>" to the left, one below it (to the left of
       the original point) and one halfway back to the original point.
       Finally move the cursor over the original point (the one
       labeled "XY") and press "<b>L</b>".

    <p>You can put the cursor over any of the points and "drag" it to a
       new location.  This movement will effect the display, but will
       likely be over-written when the sketch is ultimately solved.

    <p>Constrain the sketch as follows:
      <ul>
        <li>"L" constraint on bottom-left horizontal segment set to
          "depth/4"</li>
        <li>"L" constraint on bottom-center horizontal segment set to
          "depth/4"</li>
        <li>"L" constraint on bottom-right horizontal segment set to
          "depth/4"</li>
        <li>"L" constraint on top horizontal segment set to
          "depth/2"</li>
        <li>"L" constraint on left segment set to "depth/4"</li>
      </ul>

    <p>"<b>Press to Solve</b>", "<b>Sketch</b>",
      "<b>Save</b>", and "<b>Press to Re-build</b>".
      You should see:

    <p><img src="pictures/legacy2-14.png" width="100%"/>

    <p>Again, we want to rotate and translate the sketch, extrude it, and
       subtract it, by adding the Branches:
      <ul>
        <li>ROTATEY with arguments "90", "0", and "0"</li>
        <li>TRANSLATE with arguments "length", "height-3*rad", and
          "depth/2"</li>
        <li>EXTRUDE with arguments "-length/2", "0", and "0"</li>
        <li>SUBTRACT with arguments "none", "1", and "0"</li>
      </ul>

    <p>"<b>Press to Re-build</b>", giving:

    <p><img src="pictures/legacy2-15.png" width="100%"/>

    <p>Finally, we want to modify the original bracket to put fillets
       along the bottom of the slot.  To do this, we have to go back
       and add a FILLET Branch immediately after the EXTRUDE that
       created the bracket.  If we look back through the Feature Tree,
       we see the first EXTRUDE is at "Branch_000103".  (To verify
       this, select "Branch_000103" and "Build to this Branch").  We
       are going to want to add a FILLET statement after this Branch,
       but first we must determine the identity of the Edges that we
       want filleted.  To do this, press the "<b>+</b>" to
       the left of the Body (near the bottom of the "Tree" window), turn
       the visibility of the Faces off (press "<b>Viz</b>"
       to the right of Faces), and query the two Edges shown in:

    <p><img src="pictures/legacy2-16.png" width="100%"/>

    <p>Identifying them is done by pressing "<b>^</b>" over
       the two Edges.  (In the picture above, these Edges were
       identified for you by turning their "<b>Grd</b>" on
       before capturing the screen; these Edges will likely not be
       highlighted on your screen.)  You will notice in the "Messages"
       window that the Branches have an "edgeID" set to "11 6 11 7 1"
       and "11 7 11 8 1".  This means (for example) that the first
       Edge was created at the intersection of Faces 6 and 7 of Body
       11.

    <p>We can now create the FILLET Branch (edit "Branch_000103" and
       press "<b>Add new Branch after this Branch</b>"),
       with arguments "filrad" (which was set above for the CHAMFER)
       and "6;7;7;8;" (which selects the Edges between Faces 6 and 7
       and between 7 and 8.  "<b>Press to Re-build</b>".

    <p>Finally, we might want to see the geometric sensitivity of this
       configuration with respect to some of the Design
       Parameters. This is done exactly as in the first tutorial (by
       selecting a Design Parameter and pressing "<b>Compute
       sensitivity</b>").

    <p><img src="pictures/legacy2-17.png" width="100%"/>

    <p>We can now save our <code>.csm</code> file by choosing
       "<b>File->Export FeatureTree</b>" with the filename
       "<code>../data/legacy/tutorial2</code>".  Close the browser and
       serveESP should close automatically.

    <p><h3 id="sec2.9">2.9 Third legacy tutorial: Aircraft example</h3>

    <p>For the third tutorial, we will start <code>serveESP</code>
       with the file <code>data/legacy/tutorial3.csm</code>, which represents
       a fighter-like aircraft using blends and ruled surfaces.

    <p>Start <code>serveESP</code> with commands such as
      <pre>
        serveESP ../data/legacy/tutorial3 -dumpEgads
      </pre>
      After a few minutes, the following will appear:
    <p><img src="pictures/legacy3-01.png" width="100%"/>

    <p>The <code>-dumpEgade</code> tells <code>serveESP</code> to dump
       a file with the name <code>Body_xxxxxx.egads</code> whenever a
       new Body is created; here, <code>xxxxxx</code> is replaced with
       the current Body number.  This is a very useful option to use
       if you have a long build and want to "see" the current process
       (in another invocation of <code>serveESP</code> (which uses a
       different port number).  It is also useful in conjunction with
       the <code>-loadEgads</code> option described below.

    <p>We are going to modify this case by using the
       "<b>File->Edit</b>" button.  Pressing it gives:
    <p><img src="pictures/legacy3-02.png" width="100%"/>

    <p>Listed in the "Graphics" window is a listing of
       the <code>tutorial3.csm</code> file.  We will dissect this file
       in a few minutes.  But first, edit the file by adding the
       following after line 2:
      <pre>
        # this is an added line
      </pre>

    <p>If you now press the "<b>Cancel</b>" button, the change
       you made will not be saved and the original aircraft picture
       will appear.  To see this, press the "<b>File->Edit</b>"
       button again and you will see that we have the
       original <code>tutorial3.csm</code> file.  Now edit the file by
       adding the following after line 2:
      <pre>
        # this is another added line
      </pre>
       Press the "<b>ExportFeatureTree</b>" button and the
       file will be updated and the configuration will rebuild with
       the updated file.  (This happens now even though the changes
       were inconsequential because all we did is added a comment.)

    <p>Now add a new Design Parameter called "xyz" that has 1 row and
       3 columns, with the values "11", "22", and "33". (Recall that
       this done by clicking on "<b>Design Parameters</b>"
       in the "Tree" window.)

    <p>If we try to "<b>File->Edit</b>" the file
       again, <code>ESP</code> will inform you that you made changes
       interactively and that you must save those changes first (or
       else lose them).  "<b>Cancel</b>" out of this and
       then press the <b>"File->Export FeatureTree"</b>
       button and give the new file the name "<code>foo</code>".

    <p>If you now press "<b>File->Edit</b>", you will see
       that the new current file is <code>foo.csm</code>.  You will
       also see that this file is formatted differently from your
       original <code>tutorial3.csm</code> file.  For example, the
       arguments in <code>foo.csm</code> are not nicely spaced as they
       were in the original <code>tutorial3.csm</code> file.  As a
       result, you will probably find it easier to only make changes
       via the user interface (as you did in tutorial 1) or to edit
       the file directly using the "<b>File->Edit</b>"
       button.  You can now "<b>Cancel</b>" out of the
       editor, bringing back the picture of the airplane.

    <p>In addition to understanding how
       to "<b>Edit</b>" <code>.csm</code> files, this tutorial
       also describes best practices when writing a <code>.csm</code>
       file.  So let's now dissect the
       original <code>tutorial3.csm</code> file.

    <p>As a good practice, it is suggested that you add comments to
     the top of the file, such as:
      <!-- extract from tutorial3.csm -->
      <pre>
# tutorial3
# written by John Dannenhoffer
      </pre>

    <p>This is then followed by the Design Parameters.  Those that
     describe the fuselage are given by:
      <!-- extract from tutorial3.csm -->
      <pre>
# design parameters associated with fuselage
#                      x      y    zmin   zmax
dimension fuse      15  4  1
despmtr   fuse     " 1.00; -0.40; -0.20;  0.25;\
                     2.00; -0.60; -0.30;  0.50;\
                     3.00; -0.60; -0.30;  0.80;\
                     4.00; -0.60; -0.30;  1.20;\
                     5.00; -0.60; -0.20;  1.20;\
                     6.00; -0.60; -0.10;  1.00;\
                     7.00; -0.60;  0.00;  0.80;\
                     8.00; -0.50;  0.00;  0.70;\
                     9.00; -0.40;  0.00;  0.60;\
                    10.00; -0.30;  0.00;  0.60;\
                    11.00; -0.30;  0.00;  0.60;\
                    12.00; -0.30;  0.00;  0.60;\
                    13.00; -0.30;  0.00;  0.60;\
                    13.90; -0.30;  0.00;  0.60;\
                    14.00; -0.30;  0.00;  0.60;"

dimension  noseList 2  4  1
despmtr    noseList "0.10; 0; 1; 0;\
                     0.05; 0; 0; 1"
      </pre>
       Here, <code>fuse</code> is a 15 row, 4 column, Design Parameter
       with the given values.  The values are listed across rows, with
       semi-colons between the various entries.  Since spaces are used
       to enhance readability, the entire list of values is placed
       between quotation marks.  Also, since the inputs are split
       across multiple lines, the backslash character is used to
       denote that the next line should be concatenated with the
       current line before processing; all characters starting at the
       backslash are ignored.  The <code>noseList</code> Design
       Parameter has 2 rows and 4 columns.  (More on the use of these
       Design Parameters below.)

    <p>The Design Parameters that describe the wing, horizontal and
       vertical tails are given by:
      <!-- extract from tutorial3.csm -->
      <pre>
# design parameters associated with wing
despmtr   series_w  4409

dimension  wing     3  5  1

#                     x       y      z   chord  angle
despmtr    wing    " 4.00;  0.00;  0.20;  6.00;  0.00;\
                     7.00;  1.00;  0.20;  3.00;  0.00;\
                     9.00;  4.60;  0.10;  1.00; 20.00;"

# design parameters associated with htail
despmtr   series_h  0406
despmtr   xroot_h  12.10
despmtr   zroot_h   0.20
despmtr   aroot_h   0.00
despmtr   area_h    7.28
despmtr   taper_h   0.55
despmtr   aspect_h  3.70
despmtr   sweep_h  25.00
despmtr   dihed_h   3.00
despmtr   twist_h   2.00

set       cbar_h    sqrt(area_h/aspect_h)
set       span_h    cbar_h*aspect_h
set       croot_h   (2*cbar_h)/(taper_h+1)
set       ctip_h    taper_h*croot_h
set       xtip_h    xroot_h+(span_h/2)*tand(sweep_h)
set       ytip_h    span_h/2
set       ztip_h    zroot_h+(span_h/2)*tand(dihed_h)
set       atip_h    aroot_h+twist_h

# design parameters associated with vtail
despmtr   series_v  0404
despmtr   xroot_v  11.20
despmtr   zroot_v   0.50
despmtr   area_v    9.60
despmtr   taper_v   0.30
despmtr   aspect_v  3.00
despmtr   sweep_v  45.00

set       cbar_v    sqrt(area_v/aspect_v)
set       span_v    cbar_v*aspect_v
set       croot_v   (2*cbar_v)/(taper_v+1)
set       ctip_v    taper_v*croot_v
set       xtip_v    xroot_v+(span_v/2)*tand(sweep_v)
set       ztip_v    zroot_v+span_v/2
      </pre>

    <p>Notice the SET statements that compute Local Variables in
       terms of the Design Variables.  For example, the mean-chord of
       the horizontal tail (<code>cbar_h</code>) is computed as the
       square-root of the ratio of the tail area and the tail aspect
       ratio.

    <p>Now we are going to build the fuselage.  This will be done
       using by blending data from various cross-sections.  The
       sections that will ultimately be blended are those created after
       the previous MARK.  Creating the mark is done with the code:
      <!-- extract from tutorial3.csm -->
      <pre>
# build the fuselage
mark
      </pre>

    <p>We want to begin the fuselage at a point.  This is accomplished
       by using a POINT statement:
      <!-- extract from tutorial3.csm -->
      <pre>
   point     0  0  0
      </pre>
       This creates a point at the origin.

    <p>Then we need to generate the remaining 15 cross-sections.  This
       is done with a "pattern" (similar to a "for" loop in other
       programming languages):
      <!-- extract from tutorial3.csm -->
      <pre>
   patbeg    i  fuse.nrow
      udprim ellipse   ry  abs(fuse[i,2])  rz  (fuse[i,4]-fuse[i,3])/2
      translate        fuse[i,1]  0            (fuse[i,4]+fuse[i,3])/2
   patend
      </pre>
       Within the pattern we create an ellipse (using the "ellipse"
       user-defined primitive) with its Parameters taken from the
       second, third, and fourth columns of the <code>fuse</code>
       Design Parameter.  Each cross-section is then translated into
       its final position using the TRANSLATE statement.
       The <code>patend</code> statement closes the pattern.  (Although
       not used here, it is possible to enclose patterns within
       patterns.)

    <p>Finally we will generate the fuselage by blending the point and
       15 sections (everything since the <code>mark</code>) using:
      <!-- extract from tutorial3.csm -->
      <pre>
blend     noseList
      </pre>

    <p>At this point it is worth looking into
       the <code>noseList</code>.  The first four entries (the first
       row) contain the nose radius in the direction specified (in
       this case, "0,1,0", which is a vector in the "y"-direction).
       The next four entries contain the nose radius in the "0,0,1"
       direction (which is the "z"-direction).  Similar coding would
       be used at the tail if a <code>tailList</code> had been
       specified as the second argument in the <code>BLEND</code>
       command.

    <p>The wing is built in a similar manner using a ruled surface.
       The code here is:
      <!-- extract from tutorial3.csm -->
      <pre>
# build the wing
mark
   udprim    naca      Series    series_w
   rotatez   -wing[3,5]   0   0
   rotatex   90           0   0
   scale     wing[3,4]
   translate wing[3,1]    -wing[3,2]   wing[3,3]

   udprim    naca      Series    series_w
   rotatez   -wing[2,5]   0   0
   rotatex   90           0   0
   scale     wing[2,4]
   translate wing[2,1]    -wing[2,2]   wing[2,3]

   udprim    naca      Series    series_w
   rotatez   -wing[1,5]   0   0
   rotatex   90           0   0
   scale     wing[1,4]
   translate wing[1,1]    wing[1,2]   wing[1,3]

   udprim    naca      Series    series_w
   rotatez   -wing[2,5]   0   0
   rotatex   90           0   0
   scale     wing[2,4]
   translate wing[2,1]    +wing[2,2]   wing[2,3]

   udprim    naca      Series    series_w
   rotatez   -wing[3,5]   0   0
   rotatex   90           0   0
   scale     wing[3,4]
   translate wing[3,1]    +wing[3,2]   wing[3,3]
rule
      </pre>
       Notice here that instead of using a pattern, the five sections
       were explicitly created; this was done to ensure that the left
       and right wings were the same.  Also note that
       the <code>naca</code> user-defined primitive was used to
       generate the cross-sections.

    <p>The next statement:
      <!-- extract from tutorial3.csm -->
      <pre>
union   # with fuselage
      </pre>
       combines the fuselage and wing into a single Body.

    <p>The code for the tails is:
      <!-- extract from tutorial3.csm -->
      <pre>
# build the horizontal tail
mark
   udprim    naca      Series    series_h
   rotatez   -atip_h   0         0
   rotatex   90        0         0
   scale     ctip_h
   translate xtip_h   -ytip_h    ztip_h

   udprim    naca      Series    series_h
   rotatez   -aroot_h  0         0
   rotatex   90        0         0
   scale     croot_h
   translate xroot_h   0         zroot_h

   udprim    naca      Series    series_h
   rotatez   -atip_h   0         0
   rotatex   90        0         0
   scale     ctip_h
   translate xtip_h    ytip_h    ztip_h
rule
union   # with wing/fuselage

# build  the vertical tail
mark
   udprim    naca      Series    series_v
   scale     croot_v
   translate xroot_v   0         zroot_v

   udprim    naca      Series    series_v
   scale     ctip_v
   translate xtip_v    0         ztip_v
rule
union   # with wing/fuselage
      </pre>

    <p>The <code>tutorial3.csm</code> file completes with the
       statement:
      <!-- extract from tutorial3.csm -->
      <pre>
end
      </pre>
       Although such a statement is not required, it is good practice
       to use it.

    <p>Feel free to experiment by modifying this file.

    <p>Finally we are going to run <code>serveESP</code> with
       the <code>-loadEgads</code> option, as in:
      <pre>
serveESP ../data/legacy/tutorial3 -loadEgads
      </pre>

    <p>This will rerun the <code>tutorial3</code> case, but will read
       Bodys from the <code>Body_xxxxxx.egads</code> files instead of
       generating, generally making it much faster.  Checks are made
       to ensure that the <code>Body_xxxxxx.egads</code> files match
       the expected Branch type and arguments.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec3">3.0: Command Line</h2>

    <p>To start <code>serveESP</code>, one uses the command:
      <!-- extract from serveESP.c -->
      <pre>
        serveESP [casename[.csm]] [options...]
           where [options...] = -addVerify
                                -allVels
                                -batch
                                -checkMass
                                -checkPara
                                -despmtrs despname
                                -dict dictname
                                -dumpEgads
                                -dxdd despmtr
                                -egg eggname
                                -help  -or-  -h
                                -histDist dist
                                -jrnl jrnlname
                                -loadEgads
                                -onormal
                                -outLevel X
                                -plot plotfile
                                -plotBDF BDFname
                                -plotCP
                                -plugs npass
                                -port X
                                -printStack
                                -ptrb ptrbname
                                -skipBuild
                                -skipTess
                                -tess tessfile
                                -verify
                                -version  -or-  -v  -or-  --version
      </pre>

    <p>The <code>-addVerify</code> option tells <code?serveESP</code>
       to write a <code>.csm_verify</code> file that contains
       information about the Bodys on the stack.  This information can
       be used in a subsequent call (using the <code>-verify</code>
       flag) to verify that the results are "close enough" to a
       previous run.

    <p>The <code>-allVels</code> option displays Node and Edge
       velocities (in addition to Face velocities).

    <p>If the <code>-batch</code> option is given,
       <code>serveESP</code> is started without any graphical user
       interface.  This option is useful for regenerating
       configurations as part of a bigger process, such as for testing
       or within an MDAO environment.

   <p>The <code>-despmtrs</code> option causes the specified file to
       be read to override any DESPMTR and CFGPMTR values in
       the <code>.csm</code> file.

    <p>The <code>-dict</code> option tells <code>serveESP</code> to
       read the <code>dictname</code> file to define constant
       Parameters that should be defined before the configuration is
       built.  The format of the <code>dictname</code> file is a
       series of lines, where each line contains a constant name and a
       value, separated by white space; these Parameters are defined
       after the <code>.csm</code> is read but before it is executed.

    <p>The <code>-dumpEgads</code> option tells <code>serveESP</code>
       to write an EGADS file named "Body_xxxxxx.egads" to the current
       working directory every time a new Body is built.  This option
       is useful if one wants to see the progress so far during a long
       build or in conjunction with the <code>-loadEgads</code>
       option.

    <p>The <code>-egg</code> option tells <code>serveESP</code> to use
       the <code>eggname</code> external grid generator instead of the
       built-in <code>EGADS</code> tessellator.

    <p>The <code>-help</code> option produces a listing of the command
       line options.

    <p>the <code>-histDist</code> option produces a histogram of the
       distances of all point in a plotfile (specified with
       the <code>-plot</code> option) from the current configuration.

    <p>The <code>-jrnl</code> option is useful for replaying a
       previous session.  This journal file is an ASCII file that can
       be created with any text-editor.  But more typically, a user
       modifies the <code>portX.jrnl</code> file that is automatically
       produced every time <code>serveESP</code> is started.  (Note:
       be sure to copy and/or rename this file before using it as an
       input to <code>serveESP</code>, since the
       next <code>serveESP</code> will overwrite this file.)

    <p>The<code>-loadEgads</code> option tells <code>serveESP</code>
       to try to read file named "Body_xxxxxx.egads" during the build
       process, thereby bypassing possibly long operations.  There are
       safeguards to ensure that the Branch type and arguments match
       before the file is loaded.

    <p>The <code>-onormal</code> option tells <code>serveESP</code> to
       move the user's eye away from the configuration, making the
       display almost orthonormal (instead of perspective).

    <p>The <code>-outLevel</code> option sets the level of output (0
       to 3) that the server should produce during its execution.
       Higher numbers are useful for debugging and should seldom be
       used by most users.

    <p>The <code>-plot</code> option provides a <code>plotfile</code>
       file that contains X,Y,Z triplets of points to be plotted in
       ESP with the label <code>plotdata</code>.
       See <a href="#sec5.12">Section 5.12</a> for details.

    <p>The <code>-plotBDF</code> option plots the GRIDs, CRODs, and
       CQUAD4s in the associated <code>.bdf</code> file (which can be
       written by the <code>createBEM</code> UDP).

    <p>The <code>-plotCP</code> option plots the control polygons
       associated with all Bspline Faces.

    <p>The <code>-plugs</code> option starts Plugs, which is a tool
       for modifying the DESPMTRs in a configuration so that the
       distances from the points in a plotfile (specified via
       the <code>-plot</code> option) to the configuration is
       minimized in a least-squares sense.  This option is still
       experimental and should be used with caution.

    <p>The <code>-port</code> option tells <code>serveESP</code> with
       which port to connect.  If a port other than the default is
       used, be certain to use that same port number
       in <code>ESP</code>'s initial prompt.

    <p>The <code>-printStack</code> option tells <code>OpenCSM</code>
        to print out the contents of the stack after every command is
        executed.

    <p>The <code>-ptrb</code> option causes a perturbed configration
       (defined by the specified file) to be generated and the maximum
       distance between it and the base case to be printed.

    <p>The <code>-skipBuild</code> flag tells <code>serveESP</code> to
       skip the initial build.  This is useful when the user knows
       that some DESPMTRs will be changed before the build.

    <p>The <code>-skipTess</code> option is used when you want to
       run <code>OpenCSM</code> in <code>-batch</code> mode and you do
       not want it to create the tessellation of all the Bodys on the
       stack.

    <p>The <code>-tess</code> option reads the specified file and
       overwrites the tessellation on the last Body on the stack.

    <p>The <code>-verify</code> is typically used during testing to
       verify that the Bodys that are produced "match" those that were
       produced when the <code>-addVerify</code> flag was used.  It
       does this by actually checking the ASSERT Branches
       whose <code>verify</code> option is set to 1.

    <p>The <code>-version</code> (or <code>-v</code>
       or <code>--version</code>) flag is used to print version
       information for the user.

    <p><code>OpenCSM</code> ignores the <code>--</code> flag.

    <p>The options <code>-checkMass</code>, <code>-checkPara</code>,
       and <code>-ptrb</code> are basically used during development,
       and users should generally not need to use them.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec4">4.0: Interactive Options</h2>

    <p>The <a href="#sec2.1">first Tutorial</a> (above) gives an
       overview of nearly all the interactive commands that are
       available in <code>ESP</code>.  Future versions of this
       document will add more details here.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec5">5.0: Format of the <code>.csm</code>
        and <code>.udc</code> Files</h2>

    <p><h3 id="sec5.1">5.1: Format of the <code>.csm</code> file</h3>

    <p>The <code>.csm</code> file contains a series of statements.

    <p>If a line contains a hash (#), all characters starting at the
       hash are ignored.

    <p>If a line contains a backslash, all characters starting at the
       backslash are ignored and the next line is appended; spaces at
       the beginning of the next line are treated normally.

    <p>All statements begin with a keyword (described below) and must
       contain at least the indicated number of arguments.

    <p>The keywords may either be all lowercase or all UPPERCASE.

    <p>Any CSM statement can be used except the INTERFACE statement.

    <p>Blocks of statements must be properly nested.  The Blocks are
      bounded by PATBEG/PATEND, IFTHEN/ELSEIF/ELSE/ENDIF,
      SOLBEG/SOLEND, and CATBEG/CATEND.

    <p>Extra arguments in a statement are discarded.  If one wants to
       add a comment, it is recommended to begin it with a hash (#) in
       case optional arguments are added in future releases.

    <p>Any statements after an END statement are ignored.

    <p>All arguments must not contain any spaces or must be enclosed
       in a pair of double quotes (for example, "a + b").

    <p>Parameters are evaluated in the order that they appear in the
       file, using MATLAB-like syntax (see
       <a href="#sec5.10">'Expression rules'</a> below).

    <p>During the build process, <code>OpenCSM</code> maintains a LIFO
       'Stack' that can contain Bodies and Sketches.

    <p>The csm statements are executed in a stack-like way, taking
       their inputs from the Stack and depositing their results onto
       the Stack.

    <p>The default name for each Branch is 'Brch_xxxxxx', where xxxxxx
       is a unique sequence number.

    <p><h3 id="sec5.2">5.2: Format of the <code>.udc</code> file</h3>

    <p>A <code>.udc</code> file follows the rules of
       a <code>.csm</code> file, EXCEPT:

    <p>Zero or more INTERFACE statements must preceed any other
       non-comment statement.

    <p>Any CSM statement can be used except the DIMENSION, CONPMTR,
       DESPMTR, LBOUND, and UBOUND statements.

    <p>SET statements define parameters that are visible only within
       the <code>.udc</code> file (that is, parameters have local
       scope).

    <p>Parameters defined outside the <code>.udc</code> file are not
       available, except those passed in via INTERFACE statements.

    <p><code>.udc</code> files can be nested to a depth of 10 levels.

    <p><code>.udc</code> files are executed via a UDPRIM statement.

    <p><h3 id="sec5.3">5.3: Special characters</h3>
      <!-- extract from OpenCSM.h -->
      <pre>
   #          introduces comment
   "          ignore spaces until following "
   \          ignore this and following characters and concatenate next line
   <space>    separates arguments in .csm file (except between " and ")

   0-9        digits used in numbers and in names
   A-Z a-z    letters used in names
   _ : @      characters used in names (see rule for names)
   ? % =      characters used in strings
   .          decimal separator (used in numbers), introduces dot-suffixes
                 (in names)
   ,          separates function arguments and row/column in subscripts
   ;          multi-value item separator
   ( )        groups expressions and function arguments
   [ ]        specifies subscripts in form [row,column] or [index]
   { } < >    characters used in strings
   + - * / ^  arithmetic operators
   $          as first character, introduces a string that is terminated
                 by end-of-line or un-escaped plus, comma, or open-bracket
   @          as first character, introduces @-parameters (see below)
   '          used to escape comma, plus, or open-bracket within strings
   !          if first character of implicit string, ignore $! and treat
                 as an expression

   |          cannot be used (reserved for OpenCSM internals)
   ~          cannot be used (reserved for OpenCSM internals)
   &          cannot be used (reserved for OpenCSM internals)
      </pre>

    <p><h3 id="sec5.4">5.4: Valid CSM statements</h3>

    <p>The current CSM statements are listed here, grouped by type.  A
      full alphabetical description of any command can be obtained by
      clicking on the command name.

    <p>For a convenient Quick Reference,
       see <code>$ESP_ROOT/doc/ESP_QuickReference.pdf</code>, which is
       a two-page summary of the various <code>.csm</code> commands,
       built-in functions, dot-suffixes, the <code>ESP</code>
       character set, and a brief summary of the meanings of the various
       keypresses in <code>ESP</code>.

    <p>In the descriptions below, the conventions used are:
      <ul>
        <li>command name can eiter be UPPERCASE or lowercase, but not
          mixed</li>
        <li>arguments that start with a dollar-sign ($) are character
          strings.  Note that the user does not type the
          dollar-sign.  If you want to use a string-valued expression
          instead of an implicit string, start the argument with an
          exclamation point (!).</li>
        <li> arguments without a dollar sign ($) can be either a
          numeric value, a variable name, or an expression</li>
        <li>the default values for arguments are shown after the
          equal-signs</li>
        <li>arguments that take a list can either refer to a
          multi-valued Parameter or can be a semi-colon-separated list
          of values and/or expressions</li>
      </ul>

      <table>
        <tr>
          <td><b>Primitives</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#point">point</a></td>
          <td>xloc yloc zloc</td>
        </tr>
        <tr><td></td>
          <td><a href="#box">box</a></td>
          <td>xbase ybase zbase dx dy dz</td>
        </tr>
        <tr><td></td>
          <td><a href="#sphere">sphere</a></td>
          <td>xcent ycent zcent radius</td>
        </tr>
        <tr><td></td>
          <td><a href="#cone">cone</a></td>
          <td>xvrtx yvrtx zvrtx xbase ybase zbase radius</td>
        </tr>
        <tr><td></td>
          <td><a href="#cylinder">cylinder</a></td>
          <td>xbeg ybeg zbeg xend yend zend radius</td>
        </tr>
        <tr><td></td>
          <td><a href="#torus">torus</a></td>
          <td>xcent ycent zcent dxaxis dyaxis dzaxis majorRad
          minorRad</td>
        </tr>
        <tr><td></td>
          <td><a href="#import">import</a></td>
          <td>$filename bodynumber=1</td>
        </tr>
        <tr><td></td>
          <td><a href="#restore">restore</a></td>
          <td>$name index=0</td>
          </tr>
        <tr>
        <tr><td></td>
          <td><a href="#udprim">udprim</a></td>
          <td>$primtype $argName1 argValue1 $argName2 argValue2
          $argName3 argValue3 $argName4 argValue4</td>
        </tr>
          <td><b>Grown</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#extrude">extrude</a></td>
          <td>dx dy dz</td>
        </tr>
        <tr><td></td>
          <td><a href="#rule">rule</a></td>
          <td>reorder=0 periodic=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#blend">blend</a></td>
          <td>begList=0 endList=0 reorder=0 oneFace=0 periodic=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#revolve">revolve</a></td>
          <td>xorig yorig zorig dxaxis dyaxis dzaxis angDeg</td>
        </tr>
        <tr><td></td>
          <td><a href="#sweep">sweep</a></td>
        </tr>
        <tr>
          <td><b>Applied</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#fillet">fillet</a></td>
          <td>radius edgeList=0 listStyle=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#chamfer">chamfer</a></td>
          <td>radius edgeList=0 listStyle=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#hollow">hollow</a></td>
          <td>thick faceList=0 listStyle=0</td>
        </tr>
        <tr>
          <td><b>Booleans</b></td>
        <tr>
        <tr><td></td>
          <td><a href="#intersect">intersect</a></td>
          <td>$order=none index=1 maxtol=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#subtract">subtract</a></td>
          <td>$order=none index=1 maxtol=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#union">union</a></td>
          <td>toMark=0 trimList=0 maxtol=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#join">join</a></td>
          <td>toler=0 toMark=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#connect">connect</a></td>
          <td>faceList1 faceList2 edgeList1=0 edgeList2=0 toler=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#extract">extract</a></td>
          <td>entList</td>
        </tr>
        <tr><td></td>
          <td><a href="#combine">combine</a></td>
          <td>toler=0</td>
        </tr>
        <tr>
          <td><b>Transform</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#translate">translate</a></td>
          <td>dx dy dz</td>
        </tr>
        <tr><td></td>
          <td><a href="#rotatex">rotatex</a></td>
          <td>angDeg yaxis=0 zaxis=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#rotatey">rotatey</a></td>
          <td>angDeg zaxis=0 xaxis=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#rotatez">rotatez</a></td>
          <td>angDeg xaxis=0 yaxis=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#scale">scale</a></td>
          <td>fact xcent=0 ycent=0 zcent=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#mirror">mirror</a></td>
          <td>nx ny nz dist=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#applycsys">applycsys</a></td>
          <td>$csysName ibody=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#reorder">reorder</a></td>
          <td>ishift iflip=0</td>
        </tr>
        <tr>
          <td><b>Sketch</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#skbeg">skbeg</a></td>
          <td>x y z relative=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#skvar">skvar</a></td>
          <td>$type valList</td>
        </tr>
        <tr><td></td>
          <td><a href="#skcon">skcon</a></td>
          <td>$type index1 index2=-1 $value=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#linseg">linseg</a></td>
          <td>x y z</td>
        </tr>
        <tr><td></td>
          <td><a href="#cirarc">cirarc</a></td>
          <td>xon yon zon xend yend zend</td>
        </tr>
        <tr><td></td>
          <td><a href="#arc">arc</a></td>
          <td>xend yend zend dist $plane=xy</td>
        </tr>
        <tr><td></td>
          <td><a href="#spline">spline</a></td>
          <td>x y z</td>
        </tr>
        <tr><td></td>
          <td><a href="#sslope">sslope</a></td>
          <td>dx dy dz</td>
        </tr>
        <tr><td></td>
          <td><a href="#bezier">bezier</a></td>
          <td>x y z</td>
        </tr>
        <tr><td></td>
          <td><a href="#skend">skend</a></td>
          <td>wireonly=0</td>
        </tr>
        <tr>
          <td><b>Solver</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#solbeg">solbeg</a></td>
          <td>$varList</td>
        </tr>
        <tr><td></td>
          <td><a href="#solcon">solcon</a></td>
          <td>$expr</td>
        </tr>
        <tr><td></td>
          <td><a href="#solend">solend</a></td>
        </tr>
        <tr>
          <td><b>Utilities</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#set">set</a></td>
          <td>$pmtrName exprs</td>
        </tr>
        <tr><td></td>
          <td><a href="#assert">    assert    </a></td>
          <td>arg1 arg2 toler=0 verify=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#udparg">udparg</a></td>
          <td>$primtype $argName1 argValue1 $argName2 argValue2
          $argName3 argValue3 $argName4 argValue4</td>
        </tr>
        <tr><td></td>
          <td><a href="#mark">mark</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#group">group</a></td>
          <td>nbody=0</td>
        </tr><td></td>
        <td><a href="#patbeg">patbeg</a></td>
          <td>$pmtrName ncopy</td>
        </tr>
        <tr><td></td>
          <td><a href="#patbreak">patbreak</a></td>
          <td>expr</td>
        </tr>
        <tr><td></td>
          <td><a href="#patend">patend</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#evaluate">evaluate</a></td>
          <td>$type arg1 ...</td>
        </tr>
        <tr><td></td>
          <td><a href="#ifthen">ifthen</a></td>
          <td>val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#elseif">elseif</a></td>
          <td>val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#else">else</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#endif">endif</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#store">store</a></td>
          <td>$name index=0 keep=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#dump">dump</a></td>
          <td>$filename remove=0 toMark=0 withTess=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#select">select</a></td>
          <td>$type ...</td>
        </tr>
        <tr><td></td>
          <td><a href="#getattr">getattr</a></td>
          <td>$pmtrName attrID global=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#project">project</a></td>
          <td>x y z dx dy dz useEdges=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#throw">throw</a></td>
          <td>sigCode</td>
        </tr>
        <tr><td></td>
          <td><a href="#catbeg">catbeg</a></td>
          <td>sigCode</td>
        </tr>
        <tr><td></td>
          <td><a href="#catend">catend</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#message">message</a></td>
          <td>$text $schar=_</td>
        </tr>
        <tr>
          <td><b>Declarations</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#cfgpmtr">cfgpmtr</a></td>
          <td>$pmtrName value</td>
        </tr>
        <tr><td></td>
          <td><a href="#conpmtr">conpmtr</a></td>
          <td>$pmtrName value</td>
        </tr>
        <tr><td></td>
          <td><a href="#despmtr">despmtr</a></td>
          <td>$pmtrName values</td>
        </tr>
        <tr><td></td>
          <td><a href="#outpmtr">outpmtr</a></td>
          <td>$pmtrName</td>
        </tr>
        <tr><td></td>
          <td><a href="#lbound">lbound</a></td>
          <td>$pmtrName bounds</td>
        </tr>
        <tr><td></td>
          <td><a href="#ubound">ubound</a></td>
          <td>$pmtrName bounds</td>
        </tr>
        <tr><td></td>
          <td><a href="#dimension">dimension</a></td>
          <td>$pmtrName nrow ncol</td>
        </tr>
        <tr><td></td>
          <td><a href="#name">name</a></td>
          <td>$branchName</td>
        </tr>
        <tr><td></td>
          <td><a href="#attribute">attribute</a></td>
          <td>$attrName attrList</td>
        </tr>
        <tr><td></td>
          <td><a href="#csystem">csystem</a></td>
          <td>$csysName csysList</td>
        </tr>
        <tr><td></td>
          <td><a href="#interface">interface</a></td>
          <td>$argName $argType default</td>
        </tr>
        <tr><td></td>
          <td><a href="#end">end</a></td>
        </tr>
        <tr>
          <td><b>Deprecated</b></td>
        </tr>
        <tr><td></td>
          <td><a href="#loft">loft</a></td>
          <td>smooth</td>
        </tr>
        <tr><td></td>
          <td><a href="#macbeg">macbeg</a></td>
          <td>imacro</td>
        </tr>
        <tr><td></td>
          <td><a href="#macend">macend</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#recall">recall</a></td>
          <td>imacro</td>
        </tr>
      </table>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <p><h3 id="applycsys">applycsys</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
APPLYCSYS $csysName ibody=0
          use:    transforms Group on top of stack so that their
                      origins/orientations coincide with given csys
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  if ibody>0, use csys associated with that Body
                  if ibody==0, then search for csys backward from
                     next-to-last Body on stack
                  if ibody==-1, transform Body on top of stack so
                     that its csys is moved to the origin
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $body_not_found
                     $insufficient_bodys_on_stack
                     $name_not_found
        </pre>
      <p><h3 id="arc">arc</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ARC       xend yend zend dist $plane=xy
          use:    create a new circular arc to the new point, with a
                     specified distance between the mid-chord and mid-arc
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  $plane must be xy, yz, or zx
                  if dist>0, sweep is counterclockwise
                  sensitivity computed w.r.t. xend, yend, zend, dist
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="assert">assert</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ASSERT    arg1 arg2 toler=0 verify=0
          use:    return error if arg1 and arg2 differ
          pops:   -
          pushes: -
          notes:  if toler==0, set toler=1e-6
                  if toler<0, set toler=abs(arg1*toler)
                  if (abs(arg1-arg2) > toler) return an error
                  only executed if verify<=MODL->verify
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="attribute">attribute</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ATTRIBUTE $attrName attrValue
          use:    sets an Attribute for the Group on top of Stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  if first char of attrValue is '$', then string Attribute
                  elseif attrValue is a Parameter name, all its elements
                     are stored in Attribute
                  otherwise attrValue is a semicolon-separated list of
                     scalar numbers/expressions
                  does not create a Branch
                  if before first Branch that creates a Body,
                     the Attribute is a string-valued global Attribute
                  if after BLEND, BOX, CHAMFER, COMBINE, CONE, CONNECT,
                        CYLINDER, EXTRUDE, FILLET, HOLLOW, IMPORT, LOFT,
                        RESTORE, REVOLVE, RULE, SPHERE, SWEEP, TORUS,
                        or UDPRIM
                     the Attribute is added to the Body and its Faces
                  else
                     the Attribute is only added to the Body
                  is applied to selected Nodes, Edges, or Faces if after a
                     SELECT statement
        </pre>
      <p><h3 id="bezier">bezier</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
BEZIER    x y z
          use:    add a Bezier control point
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  sensitivity computed w.r.t. x, y, z
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="blend">blend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
BLEND     begList=0 endList=0 reorder=0 oneFace=0 periodic=0
          use:    create a Body by blending through Xsects since Mark
          pops:   Xsect1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  all Xsects must have the same number of Edges
                  if all Xsects are NodeBodys
                     a WireBody is created
                  elseif all Xsects are WireBodys (or a NodeBody at one end)
                     a SheetBody is created
                  else
                     a SolidBody is created
                  Xsects cannot be non-manifold WireBody
                  if the first Xsect is a point
                      if begList is 0
                          pointed end is created
                      elseif begList contains 8 values
                          begList contains rad1;dx1;dy1;dz1;rad2;dx2;dy2;dz2
                          rounded end is created
                  elseif first Xsect is a WireBody
                      created SheetBody is open at the beginning
                  elseif first Xsect is a SheetBody
                      if begList is 0
                          created Body included SheetBody at its beginning
                      elseif begList contains 2 values and first is -1
                          begList contains -1;aspect
                          rounded end with approximately given aspect ratio
                  if first Xsect is a WireBody or SheetBody
                      if begList contains 3 values
                          begList describes inward tangency at beginning
                  if the last Xsect is a point
                      if endList is 0
                          pointed end is created
                      elseif endList contains 8 values
                          endList contains rad1;dx1;dy1;dz1;rad2;dx2;dy2;dz2
                          rounded end is created
                  elseif last Xsect is a WireBody
                      created SheetBody is open at the end
                  elseif last Xsect is a SheetBody
                      if endList is 0
                          created Body included SheetBody at its end
                      elseif endList contains 2 values and first is -1
                          endList contains -1;aspect
                          rounded end with approximately given aspect ratio
                  if last Xsect is a WireBody or SheetBody
                      if endList contains 3 values
                          endList describes inward tangency at end
                  if begList!=0 and endList!=0, there must be at least
                     three interior Xsects
                  interior Xsects can be repeated once for C1 continuity
                  interior Xsects can be repeated twice for C0 continuity
                  if reorder!=0 then Xsects are reordered to minimize Edge
                     lengths in the direction between Xsects
                  first Xsect is unaltered if reorder>0
                  last  Xsect is unaltered if reorder<0
                  if oneFace==1 then do not split at C0 (multiplicity=3)
                  if periodic=1 then connect the first and last Xsects
                  sensitivity computed w.r.t. begList, endList
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Xsects are maintained
                  face-order is: (base), (end), feat1:part1,
                     feat1:part2, ... feat2:part1, ...
                  signals that may be thrown/caught:
                     $error_in_bodys_on_stack
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="box">box</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
BOX       xbase ybase zbase dx dy dz
          use:    create a box SolidBody or planar SheetBody
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if one of dx, dy, or dz is zero, a SheetBody is created
                  if two of dx, dy, or dz is zero, a WireBody  is created
                  if dx, dy, dz      are all zero, a NodeBody  is creates
                  sensitivity computed w.r.t. xbase, ybase, zbase, dx, dy, dz
                  computes Face, Edge, and Node sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: xmin, xmax, ymin, ymax, zmin, zmax
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="catbeg">catbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CATBEG    sigCode
          use:    execute Block of Branches if current signal matches
                     sigCode
          pops:   -
          pushes: -
          notes:  sigCode can be an integer or one of:
                     $all
                     $body_not_found
                     $colinear_sketch_points
                     $created_too_many_bodys
                     $did_not_create_body
                     $edge_not_found
                     $error_in_bodys_on_stack
                     $face_not_found
                     $file_not_found
                     $func_arg_out_of_bounds
                     $illegal_argument
                     $ilegal_attribute
                     $illegal_csystem
                     $illegal_pmtr_index
                     $illegal_pmtr_name
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $name_not_found
                     $node_not_found
                     $non_coplanar_sketch_points
                     $no_selection
                     $underconstrained
                     $overconstrained
                     $not_converged
                     $self_intersecting
                     $wrong_types_on_stack
                     $assert_failed
                  if sigCode does not match current signal, skip to matching
                     CATEND
                  Block contains all Branches up to matching CATEND
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="catend">catend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CATEND
          use:    designates the end of a CATBEG Block
          pops:   -
          pushes: -
          notes:  inner-most Block must be a CATBEG Block
                  closes CATBEG Block
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="cfgpmtr">cfgpmtr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CFGPMTR   $pmtrName value
          use:    define a configuration Paramater
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a .udc file
                  pmtrName must be in form 'name'
                  pmtrName must not start with '@'
                  pmtrName must not refer to an LOCALVAR/OUTPMTR/CONPMTR
                  pmtrName will be marked as CFGPMTR
                  pmtrName is used directly (without evaluation)
                  if value already exists, it is not overwritten
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="chamfer">chamfer</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CHAMFER   radius edgeList=0
          use:    apply a chamfer to a Body
          pops:   Body
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if listStyle==0
                     if previous operation is boolean, apply to all new Edges
                     edgeList=0 is the same as edgeList=[0;0]
                     edgeList is a multi-value Parameter or a semicolon-separated
                        list
                     pairs of edgeList entries are processed in order
                     pairs of edgeList entries are interpreted as follows:
                        col1  col2   meaning
                         =0    =0    add all Edges
                         >0    >0    add    Edges between iford=+icol1
                                                      and iford=+icol2
                         <0    <0    remove Edges between iford=-icol1
                                                      and iford=-icol2
                         >0    =0    add    Edges adjacent to iford=+icol1
                         <0    =0    remove Edges adjacent to iford=-icol1
                  else
                     edgeList contains Edge number(s)
                  sensitivity computed w.r.t. radius
                  sets up @-parameters
                  new Faces all receive the Branch's Attributes
                  face-order is based upon order that is returned from EGADS
                  signals that may be thrown/caught:
                     $illegal_argument
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="cirarc">cirarc</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CIRARC    xon yon zon xend yend zend
          use:    create a new circular arc, using the previous point
                     as well as the two points specified
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  sensitivity computed w.r.t. xon, yon, zon, xend, yend, zend
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="combine">combine</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
COMBINE   toler=0
          use:    combine Bodys since Mark into next higher type
          pops:   Body1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  Mark must be set
                  if all Bodys since Mark are SheetBodys
                     create either a SolidBody from closed Shell or an
                     (open) SheetBody
                  elseif there is 1 planar WireBody that is closed
                     create SheetBody from Loop
                  elseif there is 1 planar WireBody that is open
                     create SheetBody from Loop after closing Loop first
                  elseif there are multiple planar WireBodys that are closed
                     create SheetBody from closed Loop
                  elseif there are multiple WireBodys that have common Nodes
                     create non-manifold WireBody
                  endif
                  if maxtol>0, then tolerance can be relaxed until successful
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="cone">cone</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CONE      xvrtx yvrtx zvrtx xbase ybase zbase radius
          use:    create a cone Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xvrtx, yvrtx, zvrtz, xbase, ybase,
                     zbase, radius
                  computes Face, Edge, and Node sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: (empty), base, umin, umax
                     if x-aligned: umin=ymin, umax=ymax
                     if y-aligned: umin=xmax, umax=xmin
                     if z-aligned: umin=ymax, umax=ymin
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="connect">connect</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CONNECT   faceList1 faceList2 edgeList1=0 edgeList2=0 toler=0
          use:    connects two Bodys with bridging Faces
          pops:   Body1 Body2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  faceList1 and faceList2 must have the same length
                  edgeList1 and edgeList2 must have the same length
                  edgeList1[i] corresponds to edgeList2[i]
                  faceList1[i] corresponds to faceList2[i]
                  if Body1 is a Mark, left and rite Bodys are the same
                  if edgeLists are given
                      Body1 is either WireBody, SheetBody, or SolidBody
                      Body2 is same type as Body1
                      Body  is same type as Body1
                      Face in faceLists are removed
                      bridging Faces are made between edgeList pairs
                      a zero in an edgelist creates a degenerate Face
                  else
                      Body1 and Body2 must both be SolidBodys
                      Faces within each faceList must be contiguous
                      bridging Faces between exposed Edges are created
                  new Faces all receive the Branch's Attributes
                  sets up @-parameters
                  if edgeLists are given
                      face-order is same as edgeList
                  else
                      face-order is arbitrary
                  signals that may be thrown/caught:
                     $illegal_argument
                     $illegal_value
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="conpmtr">conpmtr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CONPMTR   $pmtrName values
          use:    define a constant Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a .udc file
                  pmtrName must be in form 'name'
                  pmtrName must not start with '@'
                  pmtrName must not refer to an LOCALVAR/OUTPMTR/DESPMTR
                  pmtrName will be marked as CONPMTR
                  pmtrName is used directly (without evaluation)
                  pmtrName is available within .csm and .udc files
                  value(s) must be numbers
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="csystem">csystem</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CSYSTEM   $csysName csysList
          use:    attach a Csystem to Body on top of stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  if     csysList contains 9 entries:
                     {x0, y0, z0, dx1, dy1, dz1, dx2, dy2, dz2}
                     origin is at (x0,y0,z0)
                     dirn1  is in (dx1,dy1,dz1) direction
                     dirn2  is part of (dx2,dy2,dz2) that is orthog. to dirn1
                  elseif csysList contains 5 entries and first is positive
                     {+iface, ubar0, vbar0, du2, dv2}
                     origin is at normalized (ubar0,vbar0) in iface
                     dirn1  is normal to Face
                     dirn2  is in (du2,dv2) direction
                  elseif csyList contains 5 entries and first is negative
                     {-iedge, tbar, dx2, dy2, dz2}
                     origin is at normalized (tbar) in iedge
                     dirn1  is tangent to Edge
                     dirn2  is part of (dx2,dy2,dz2) that is orthog. to dirn1
                  elseif csysList contains 7 entries
                     {inode, dx1, dy1, dz1, dx2, dy2, dz2}
                     origin is at Node inode
                     dirn1  is in (dx1,dy1,dz1) direction
                     dirn2  is part of (dx2,dy2,dz2) that is orthog. to dirn1
                  else
                     error
                  semicolon-sep lists can instead refer to
                     multi-valued Parameter
                  dirn3 is formed by (dirn1)-cross-(dirn2)
                  does not create a Branch
        </pre>
      <p><h3 id="cylinder">cylinder</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CYLINDER  xbeg ybeg zbeg xend yend zend radius
          use:    create a cylinder Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xbeg, ybeg, zbeg, xend, yend,
                     zend, radius
                  computes Face, Edge, and Node sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: beg, end, umin, umax
                     if x-aligned: umin=ymin, umax=ymax
                     if y-aligned: umin=xmax, umax=xmin
                     if z-aligned: umin=ymax, umax=ymin
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="despmtr">despmtr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
DESPMTR   $pmtrName values
          use:    define a design Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a function-type .udc file
                  pmtrName can be in form 'name' or 'name[irow,icol]'
                  pmtrName must not start with '@'
                  pmtrName must not refer to an LOCALVAR/OUTPMTR/CONPMTR
                  pmtrName will be marked as DESPMTR
                  pmtrName is used directly (without evaluation)
                  irow and icol cannot contain a comma or open bracket
                  if irow is a colon (:), then all rows    are input
                  if icol is a colon (:), then all columns are input
                  pmtrName[:,:] is equivalent to pmtrName
                  values cannot refer to any other Parameter
                  if value already exists, it is not overwritten
                  values are defined across rows, then across columns
                  if values has more entries than needed, extra values
                     are lost
                  if values has fewer entries than needed, last value
                     is repeated
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="dimension">dimension</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
DIMENSION $pmtrName nrow ncol
          use:    set up or redimensions an array Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  nrow >= 1
                  ncol >= 1
                  pmtrName must not start with '@'
                  if applied to a DESPMTR or CFGPMTR, must be in either
                      .csm file or top-level include-style .udc file
                  a legacy fourth argument (despmtr) is no longer used
                  old values are not overwritten
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="dump">dump</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
DUMP      $filename remove=0 toMark=0 withTess=0
          use:    write a file that contains the Body
          pops:   Body1 (if remove=1)
          pushes: -
          notes:  Solver may not be open
                  if file exists, it is overwritten
                  filename is used directly (without evaluation)
                  if filename starts with '$/', it is prepended with path of
                     the .csm file
                  if remove=1, then Body1 is removed after dumping
                  if toMark=1, all Bodys back to the Mark (or all if no Mark)
                     are combined into a single model
                  if toMark=1, the remove flag is ignored
                  if withTess!=0, add tessellations to .egads file
                  for .ugrid files, toMark must be 0
                  valid filetypes are:
                     .brep   .BREP   --> OpenCASCADE output
                     .bstl   .BSTL   --> binary stl  output
                     .egads  .EGADS  --> EGADS       output
                     .egg    .EGG    --> EGG restart output
                     .iges   .IGES   --> IGES        output
                     .igs    .IGS    --> IGES        output
                     .plot   .PLOT   --> ASCII plot  output
                     .sens   .SENS   --> ASCII sens  output
                     .step   .STEP   --> STEP        output
                     .stl    .STL    --> ASCII stl   output
                     .stp    .STP    --> STEP        output
                     .tess   .TESS   --> ASCII tess  output
                     .ugrid  .UGRID  --> ASCII AFRL3 output
                  if .bstl, use _stlColor from Face, Body, or 0 for color
                  if .egads, set _despmtr_* and _outpmtr_ Attributes on Model
                  signals that may be thrown/caught:
                     $file_not_found
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="else">else</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ELSE
          use:    execute or skip a Block of Branches
          pops:   -
          pushes: -
          notes:  inner-most Block must be an Ifthen Block
                  must follow an IFTHEN or ELSEIF statment
                  if preceeding (matching) IFTHEN or ELSEIF evaluated true,
                     then skip Branches up to the matching ENDIF
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="elseif">elseif</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ELSEIF    val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0
          use:    execute or skip a sequence of Branches
          pops:   -
          pushes: -
          notes:  inner-most Block must be an Ifthen Block
                  must follow an IFTHEN or ELSEIF statement
                  if preceeding (matching) IFTHEN or ELSEIF evaluated true,
                     then skip Branches up to matching ENDIF
                  op1 must be one of: lt LT le LE eq EQ ge GE gt GT ne NE
                  op2 must be one of: or OR and AND xor XOR
                  op3 must be one of: lt LT le LE eq EQ ge GE gt GT ne NE
                  if expression evaluates false, skip Branches up to next
                     ELSEIF, ELSE, or ENDIF
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="end">end</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
END
          use:    signifies end of .csm or .udc file
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  Bodys on Stack are returned last-in-first-out
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="endif">endif</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ENDIF
          use:    terminates an Ifthen Block of Branches
          pops:   -
          pushes: -
          notes:  inner-most Block must be an Ifthen Block
                  must follow an IFTHEN, ELSEIF, or ELSE
                  closes Ifthen Block
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="evaluate">evaluate</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
EVALUATE  $type arg1 ...
          use:    evaluate coordinates of NODE, EDGE, or FACE
          pops:   -
          pushes: -
          notes:  if     arguments are: "node ibody inode"
                     ibody is Body number (1:nbody)
                     inode is Node number (1:nnode)
                     return in @edata:
                        x, y, z
                  elseif arguments are: "edge ibody iedge t"
                     ibody is Body number (1:nbody)
                     iedge is Edge number (1:nedge)
                     evaluate Edge at given t
                     return in @edata:
                        t (clipped),
                        x,      y,      z,
                        dxdt,   dydt,   dzdt,
                        d2xdt2, d2ydt2, d2zdt2
                  elseif arguments are: "edge ibody iedge $beg"
                     ibody is Body number (1:nbody)
                     iedge is Edge number (1:nedge)
                     evaluate Edge at beginning
                     return in @edata:
                        t (clipped),
                        x,      y,      z,
                        dxdt,   dydt,   dzdt,
                        d2xdt2, d2ydt2, d2zdt2
                  elseif arguments are: "edge ibody iedge $end"
                     ibody is Body number (1:nbody)
                     iedge is Edge number (1:nedge)
                     evaluate Edge at end
                     return in @edata:
                        t (clipped),
                        x,      y,      z,
                        dxdt,   dydt,   dzdt,
                        d2xdt2, d2ydt2, d2zdt2
                  elseif arguments are: "edgerng ibody iedge"
                     ibody is Body number (1:nbody)
                     iedge is Edge number (1:nedge)
                     return in @edata:
                        tmin, tmax
                  elseif arguments are: "edgeinv ibody iedge x y z"
                     ibody is Body number (1:nbody)
                     iedge is Edge number (1:nedge)
                     inverse evaluate Edge at given (x,y,z)
                     return in @edata:
                        t,
                        xclose,  yclose,  zclose
                  elseif arguments are: "face ibody iface u v"
                     ibody is Body number (1:nbody)
                     iface is Face number (1:nface)
                     evaluate Face at given (u,v)
                     return in @edata:
                        u (clipped), v (clipped),
                        x,       y,       z,
                        dxdu,    dydu,    dzdu,
                        dxdv,    dydv,    dzdv,
                        d2xdu2,  d2ydu2,  d2zdu2,
                        d2xdudv, d2ydudv, d2zdudv,
                        d2xdv2,  d2ydv2,  d2zdv2,
                        normx,   normy,   normz
                  elseif arguments are: "facerng ibody iface"
                     ibody is Body number (1:nbody)
                     iface is Face number (1:nface)
                     return in @edata:
                        umin, umax, vmin, vmax
                  elseif arguments are: "faceinv ibody iface x y z"
                     ibody is Body number (1:nbody)
                     iface is Face number (1:nface)
                     inverse evaluate Face at given (x,y,z)
                     return in @edata:
                        u,       v,
                        xclose,  yclose,  zclose
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  signals that may be thrown/caught:
                     $body_not_found
                     $edge_not_found
                     $face_not_found
                     $node_not_found
        </pre>
      <p><h3 id="extract">extract</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
EXTRACT   entList
          use:    extract Face(s) or Edge(s) from a Body
          pops:   Body1
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  all members of entList must have the same sign
                  Body1 must be a SolidBody or a SheetBody
                  if     entList entries are all positive
                     create SheetBody from entList Face(s) of Body1
                  elseif entList entries are all negative
                     create WireBody from -entList Edge(0) of Body1
                  elseif Body1=SolidBody and entList=0
                     create SheetBody from outer Shell of Body1
                  elseif Body1=SheetBody and entList=0
                     create WireBody from outer Loop of Body1
                  endif
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
                     $did_not_create_body
                     $illegal_value
                     $edge_not_found
                     $face_not_found
        </pre>
      <p><h3 id="extrude">extrude</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
EXTRUDE   dx dy dz
          use:    create a Body by extruding an Xsect
          pops:   Xsect
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if Xsect is a SheetBody, then a SolidBody is created
                  if Xsect is a WireBody, then a SheetBody is created
                  if Xsect is a NodeBody, then a WireBody is created
                  sensitivity computed w.r.t. dx, dy, dz
                  computes Face sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Xsect Face are placed on both beg and end Faces
                  Attributes on Xsect Edges that do not start with
                     . or _ are placed on the associated Faces
                  Attributes on Xsect Edges are not placed on Edges
                  face-order is: (base), (end), feat1, ...
                  signals that may be thrown/caught:
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="fillet">fillet</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
FILLET    radius edgeList=0 listStyle=0
          use:    apply a fillet to a Body
          pops:   Body
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if listStyle==0
                     if previous operation is boolean, apply to all new Edges
                     edgeList=0 is the same as edgeList=[0;0]
                     edgeList is a multi-value Parameter or a semicolon-separated
                        list
                     pairs of edgeList entries are processed in order
                     pairs of edgeList entries are interpreted as follows:
                        col1  col2   meaning
                         =0    =0    add all Edges
                         >0    >0    add    Edges between iford=+icol1
                                                      and iford=+icol2
                         <0    <0    remove Edges between iford=-icol1
                                                      and iford=-icol2
                         >0    =0    add    Edges adjacent to iford=+icol1
                         <0    =0    remove Edges adjacent to iford=-icol1
                  else
                     edgeList contains Edge number(s)
                  sensitivity computed w.r.t. radius
                  sets up @-parameters
                  new Faces all receive the Branch's Attributes
                  face-order is based upon order that is returned from EGADS
                  signals that may be thrown/caught:
                     $illegal_argument
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="getattr">getattr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
GETATTR   $pmtrName attrID global=0
          use:    store an Attribute value(s) in a LOCALVAR
          pops:   -
          pushes: -
          Notes:  pmtrName must be in form 'name', without subscripts
                  pmtrName must not start with '@'
                  pmtrName must not refer to an DESPMTR/CONPMTR Parameter
                  pmtrName will be marked as LOCALVAR (or OUTPMTR)
                  pmtrName is used directly (without evaluation)
                  the type of pmtrName is changed to match the result
                  if global==0, then
                     applies to Attributes on the selected Body
                  else
                     applies to global Attributes
                  if attrID is $_nattr_ then number of Attributes
                     will be retrieved into a scalar or indexed entry
                  if attrID is an integer (i), then the name of the
                     i'th (bias-1) Attribute will be retreived into a
                     string Parameter
                  Attributes are retrieved from last Body or from a Body,
                     Face, or Edge if it follows a SELECT statement
                  signals that may be thrown/caught:
                     $illegal_pmtr_index, $illegal_attribute
        </pre>
      <p><h3 id="group">group</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
GROUP     nbody=0
          use:    create a Group of Bodys since Mark for subsequent
                     transformations
          pops:   Body1 ... Mark  -or-  Body1 ...
          pushes: Body1 ...
          notes:  Sketch may not be open
                  Solver may not be open
                  if nbody>0,   then nbody Bodys on stack are in Group
                  if nbody<0,   then Bodys are ungrouped
                  if no Mark on stack, all Bodys on stack are in Group
                  the Mark is removed from the stack
                  Attributes are set on all Bodys in Group
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="hollow">hollow</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
HOLLOW    thick=0 entList=0 listStyle=0
          use:    hollow out a SolidBody or SheetBody
          pops:   Body
          pushes: Body
          notes:  results can be unpredictable due to OpenCASCADE issues
                  Sketch may not be open
                  Solver may not be open
                  if SolidBody (radius is ignored)
                     if thick=0 and entList==0         (case A)
                         convert to SheetBody
                     if thick=0 and entList!=0         (case B)
                        convert to SheetBody without Faces in entList (if connected)
                     if thick>0 and entList==0         (case C)
                        larger offset Body is created
                     if thick<0 and entList==0         (case D)
                        smaller offset Body is created
                     if thick>0 and entList!=0         (case E)
                        hollow (removing entList) with new Faces inside  original Body
                     if thick<0 and entList!=0         (case F)
                        hollow (removing entList) with new Faces outside original Body
                  if a SheetBody with only one Face
                     if thick=0 and entList==0         (case G)
                        convert to WireBody (if connected)
                     if thick=0 and entList!=0         (case H)
                        convert to WireBody without Edges in entList (if connected)
                     if thick>0 and entList==0         (case I)
                        hollow with new Edges inside  original Body
                     if thick<0 and entList==0         (case J)
                        hollow with new Edges outside original Body
                     if thick>0 and entList!=0         (case K)
                        hollow (removing entList) with new Edges inside  original Body
                     if thick<0 and entList!=0         (case L)
                        hollow (removing entList) with new Edges outside original Body
                  if a SheetBody with multiple Faces
                     if thick=0 and entList!=0         (case M)
                        remove Faces in entList (if connected)
                     if thick>0 and entList==0         (case N)
                        hollow all Faces with new Edges inside original Faces
                     if thick>0 and entList!=0         (case P)
                        hollow Faces in entList with new Edges inside original Faces
                  entList is multi-valued Parameter, or a semicolon-separated list
                  if listStyle==0 and a SolidBody
                     pairs of entList entries are processed in order
                        the first  entry in a pair indicates the Body when
                           Face was generated (see first number in _body Attribute)
                        the second entry in a pair indicates the face-order (see
                           second number in _body Attribute)
                  otherwise
                     entries in entList are Edge or Face numbers
                  sensitivity computed w.r.t. thick
                  sets up @-parameters
                  new Faces all receive the Branch's Attributes
                  face-order is based upon order that is returned from EGADS
                  signals that may be thrown/caught:
                     $illegal_argument
                     $did_not_create_body
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="ifthen">ifthen</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
IFTHEN    val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0
          use:    execute or skip a Block of Branches
          pops:   -
          pushes: -
          notes:  works in combination with ELSEIF, ELSE, and ENDIF statements
                  op1 must be one of: lt LT le LE eq EQ ge GE gt GT ne NE
                  op2 must be one of: or OR and AND xor XOR
                  op3 must be one of: lt LT le LE eq EQ ge GE gt GT ne NE
                  if expression evaluates false, skip Block of Branches up
                     to next (matching) ELSEIF, ELSE, or ENDIF are skipped
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="import">import</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
IMPORT    $filename bodynumber=1
          use:    import from filename
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  filename is used directly (without evaluation)
                  if filename starts with '$$/', use path relative to .csm file
                  if bodynumber=-1, then all Bodys are returned in one Group
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is based upon order in file
                  signals that may be thrown/caught:
                     $did_not_create_body
                     udp-specific code
        </pre>
      <p><h3 id="interface">interface</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
INTERFACE $argName $argType default=0
          use:    defines an argument for a .udc file
          pops:   -
          pushes: -
          notes:  only allowed in a .udc file
                  must be placed before any executable statement
                  argType must be "in", "out", "dim", or "all"
                  argType="dim" is obsolete, use DIMENSION instead
                  if argType=="all", a new scope is not created (and
                                     $argName is ignored)
                  a string variable can be passed into UDC if default
                     is a string
                  a string varaible can be passed out of UDC
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  signals that may be thrown/caught:
                     $pmtr_is_conpmtr
        </pre>
      <p><h3 id="intersect">intersect</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
INTERSECT $order=none index=1 maxtol=0
          use:    perform Boolean intersection (Body2 & Body1)
          pops:   Body1 Body2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if     Body1=SolidBody and Body2=SolidBody
                     create SolidBody that is common part of Body1 and Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=SolidBody and Body2=SheetBody
                     create SheetBody that is the part of Body2 that is
                        inside Body1
                     if index=-1, then all Bodys are returned
                  elseif Body1=SolidBody and Body2=WireBody
                     create WireBody that is the part of Body2 that is
                        inside Body1
                     if index=-1, then all Bodys are returned
                  elseif Body1=SheetBody and Body2=SolidBody
                     create SheetBody that is the part of Body1 that is
                        inside Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=SheetBody and Body2=SheetBody and Bodys are
                        co-planar
                     create SheetBody that is common part of Body1 and Body2
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body1=SheetBody and Body2=SheetBody and Bodys are not
                        co-planar
                     create WireBody at the intersection of Body1 and Body2
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body1=SheetBody and Body2=WireBody
                     create WireBody that is the part of Body2 that is
                        inside Body1
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body1=WireBody and Body2=SolidBody
                     create WireBody that is the part of Body1 that is
                        inside Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=WireBody and Body2=SheetBody
                     create WireBody that is the part of Body1 that is
                        inside Body2
                     CURRENTLY NOT IMPLEMENTED
                  endif
                  if intersection does not produce at least index Bodys, an
                     error is returned
                  order may be one of:
                     none    same order as returned from geometry engine
                     xmin    minimum xmin   is first
                     xmax    maximum xmax   is first
                     ymin    minimum ymin   is first
                     ymax    maximum ymax   is first
                     zmin    minimum zmin   is first
                     zmax    maximum zmax   is first
                     amin    minimum area   is first
                     amax    maximum area   is first
                     vmin    minimum volume is first
                     vmax    maximum volume is first
                  order is used directly (without evaluation)
                  if maxtol>0, then tolerance can be relaxed until successful
                  if maxtol<0, then use -maxtol as only tolerance to use
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="join">join</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
JOIN      toler=0 toMark=0
          use:    join two Bodys at a common Edge or Face
          pops:   Body1 Body2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if toMark=1 and all Bodys to Mark are SheetBodys
                     create SheetBody
                  elseif toMark=1 and all Bodys to Mark are WireBodys
                     create WireBody
                  elseif Body1=SolidBody and Body2=SolidBody
                     create SolidBody formed by joining Body1 and Body2 at
                        common Faces
                  elseif Body1=SheetBody and Body2=SheetBody
                     create SheetBody formed by joining Body1 and Body2 at
                        common Edges
                  elseif Body1=WireBody and Body2=WireBody
                     create WireBody formed by joining Body1 and Body2 at
                        common end Node
                  endif
                  change in v1.19: if common Edges are not found, return
                                   $edge_not_found
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $created_too_many_bodys
                     $did_not_create_body
                     $edge_not_found
                     $face_not_found
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="lbound">lbound</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
LBOUND    $pmtrName bounds
          use:    defines a lower bound for a DESPMTR or CFGPMTR
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a function-type .udc file
                  if value of Parameter is smaller than bounds, a warning is
                     generated
                  pmtrName must have been defined previously by DESPMTR
                     statement
                  pmtrName can be in form 'name' or 'name[irow,icol]'
                  pmtrName must not start with '@'
                  pmtrName is used directly (without evaluation)
                  irow and icol cannot contain a comma or open bracket
                  if irow is a colon (:), then all rows    are input
                  if icol is a colon (:), then all columns are input
                  pmtrName[:,:] is equivalent to pmtrName
                  bounds cannot refer to any other Parameter
                  bounds are defined across rows, then across columns
                  if bounds has more entries than needed, extra bounds
                     are lost
                  if bounds has fewer entries than needed, last bound
                     is repeated
                  any previous bounds are overwritten
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="linseg">linseg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
LINSEG    x y z
          use:    create a new line segment, connecting the previous
                     and specified points
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  sensitivity computed w.r.t. x, y, z
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="loft">loft</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
LOFT      smooth
          use:    create a Body by lofting through Xsects since Mark
          pops:   Xsect1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  all Xsects must have the same number of Segments
                  if Xsect is a SheetBody, then a SolidBody is created
                  if Xsect is a WireBody, then a SheetBody is created
                  Xsects cannot be non-manifold WireBody
                  the Faces all receive the Branch's Attributes
                  Attributes on Xsects are not maintained
                  face-order is: (base), (end), feat1, ...
                  if NINT(smooth)=1, then sections are smoothed
                  the first and/or last Xsect can be a point

                  LOFT (through OpenCASCADE) is not very robust
                  use BLEND or RULE if possible
                  sets up @-parameters
                  MAY BE DEPRECATED (use RULE or BLEND)
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="macbeg">macbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MACBEG    imacro
          use:    marks the start of a macro
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  imacro must be between 1 and 100
                  cannot overwrite a previous macro
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  MAY BE DEPRECATED (use UDPRIM)
        </pre>
      <p><h3 id="macend">macend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MACEND
          use:    ends a macro
          pops:   -
          pushes: -
          notes:  cannot be followed by ATTRIBUTE or CSYSTEM
                  MAY BE DEPRECATED (use UDPRIM)
        </pre>
      <p><h3 id="mark">mark</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MARK
          use:    used to identify groups such as in RULE, BLEND, or GROUP
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="message">message</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MESSAGE   $text $schar=_
          use:    generate a message to be displayed
          pops:   -
          pushes: -
          notes:  schar must contain a single character
                  any character in text that matches schar will
                     be converted to a space
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="mirror">mirror</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MIRROR    nx ny nz dist=0
          use:    mirrors Group on top of Stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  normal of the mirror plane is given by nx,ny,nz
                  mirror plane is dist from origin
                  sensitivity computed w.r.t. nx, ny, nz, dist
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="name">name</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
NAME      $branchName
          use:    names the entry on top of Stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  does not create a Branch
        </pre>
      <p><h3 id="outpmtr">outpmtr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
OUTPMTR   $pmtrName
          use:    define an OUTPMTR
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a .udc file
                  pmtrName must be in form 'name'
                  pmtrName must not start with '@'
                  pmtrName will be marked as OUTPMTR
                  pmtrName is used directly (without evaluation)
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="patbeg">patbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
PATBEG    $pmtrName ncopy
          use:    execute a Block of Branches ncopy times
          pops:   -
          pushes: -
          notes:  Solver may not be open
                  Block contains all Branches up to matching PATEND
                  pmtrName must not start with '@'
                  pmtrName takes values from 1 to ncopy (see below)
                  pmtrName is used directly (without evaluation)
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="patbreak">patbreak</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
PATBREAK  expr
          use:    break out of inner-most Patbeg Block if expr>0
          pops:   -
          pushes: -
          notes:  Solver may not be open
                  must be in a Patbeg Block
                  skip to Branch after matching PATEND if expr>0
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="patend">patend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
PATEND
          use:    designates the end of a Patbeg Block
          pops:   -
          pushes: -
          notes:  Solver may not be open
                  inner-most Block must be a Patbeg Block
                  closes Patbeg Block
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="point">point</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
POINT     xloc yloc zloc
          use:    create a single point Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xloc, yloc, zloc
                  computes Node sensitivity analytically
                  sets up @-parameters
        </pre>
      <p><h3 id="project">project</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
PROJECT   x y z dx dy dz useEdges=0
          use:    find the first projection from given point in given
                     direction
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  if useEdges!=1
                      look for intersections with Faces and overwrite @iface
                  else
                      look for intersections with Edges and overwrite @iedge
                  endif
                  over-writes the following @-parameters: @xcg, @ycg, and @zcg
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  signals that may be thrown/caught:
                     $face_not_found
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="recall">recall</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
RECALL    imacro
          use:    recalls copy of macro from a storage location imacro
          pops:   -
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  storage location imacro must have been previously filled by
                     a MACBEG statement
                  MAY BE DEPRECATED (use UDPRIM)
        </pre>
      <p><h3 id="reorder">reorder</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
REORDER   ishift iflip=0
          use:    change the order of Edges in a Body
          pops:   Body1
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  it is generally better to use reorder argument in
                     RULE and BLEND than this command
                  Body1 must be either WireBody or SheetBody Body
                  Body1 must contain 1 Loop
                  if the Loop is open, ishift must be 0
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="restore">restore</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
RESTORE   $name index=0
          use:    restores Body(s) that was/were previously stored
          pops:   -
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  $name is used directly (without evaluation)
                  if $name is . (dot), then duplicate Body on stack
                  if index<0, get all Bodys that match $name
                  sets up @-parameters
                  error results if nothing has been stored in name
                  the Faces all receive the Branch's Attributes
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
                     $name_not_found
        </pre>
      <p><h3 id="revolve">revolve</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
REVOLVE   xorig yorig zorig dxaxis dyaxis dzaxis angDeg
          use:    create a Body by revolving an Xsect around an axis
          pops:   Xsect
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if Xsect is a SheetBody, then a SolidBody is created
                  if Xsect is a WireBody, then a SheetBody is created
                  sensitivity computed w.r.t. xorig, yorig, zorig, dxaxis,
                     dyaxis, dzaxis, andDeg
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Xsect Face are placed on both beg and end Faces
                  Attributes on Xsect Edges that do not start with
                     . or _ are placed on the associated Faces
                  Attributes on Xsect Edges are not placed on Edges
                  face-order is: (base), (end), feat1, ...
                  signals that may be thrown/caught:
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="rotatex">rotatex</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ROTATEX   angDeg yaxis=0 zaxis=0
          use:    rotates Group on top of Stack around an axis that
                  passes through (0, yaxis, zaxis) and is parallel
                  to the x-axis
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. angDeg, yaxis, zaxis
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="rotatey">rotatey</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ROTATEY   angDeg zaxis=0 xaxis=0
          use:    rotates Group on top of Stack around an axis that
                  passes through (xaxis, 0, zaxis) and is parallel
                  to the y-axis
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. angDeg, zaxis, xaxis
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="rotatez">rotatez</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ROTATEZ   angDeg xaxis=0 yaxis=0
          use:    rotates Group on top of Stack around an axis that
                  passes tgrough (xaxis, yaxis, 0) and is parallel
                  to the z-axis
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. angDeg, xaxis, yaxis
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="rule">rule</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
RULE      reorder=0 periodic=0
          use:    create a Body by creating ruled surfaces thru Xsects
                     since Mark
          pops:   Xsect1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if reorder!=0 then Xsects are reordered to minimize Edge
                     lengths
                  first Xsect is unaltered if reorder>0
                  last  Xsect is unaltered if reorder<0
                  all Xsects must have the same number of Edges
                  Xsects cannot be non-manifold WireBody
                  if all Xsects are NodeBodys
                     a WireBody is created
                  elseif all Xsects are WireBodys (or a NodeBody at one end)
                     a SheetBody is created
                  else
                     a SolidBody is created
                  the first and/or last Xsect can be a NodeBody
                  if periodic=1 then connect the first and last Xsects
                  computes Face sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Xsects are maintained
                  face-order is: (base), (end), feat1:part1,
                     feat1:part2, ... feat2:part1, ...
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $error_in_bodys_on_stack
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="scale">scale</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SCALE     fact xcent=0 ycent=0 zcent=0
          use:    scales Group on top of Stack around given point
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  (xcent,ycent,zcent are not yet implemented)
                  sensitivity computed w.r.t. fact
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="select">select</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SELECT    $type arg1 ...
          use:    selects entity for which @-parameters are evaluated
          pops:   -
          pushes: -
          notes:  if     arguments are: "body"
                     sets @seltype to -1
                     sets @selbody to @nbody
                     sets @sellist to -1
                  elseif arguments are: "body ibody"
                     sets @seltype to -1
                     sets @selbody to ibody
                     sets @sellist to -1
                  elseif arguments are: "body -n"
                     sets @seltype to -1
                     sets @selbody to the nth from the top of the stack
                     sets @sellist to -1
                  elseif arguments are: "body attrName1    attrValue1
                                              attrName2=$* attrValue2=$*
                                              attrName3=$* attrValue3=$*"
                     sets @seltype to -1
                     uses @selbody to Body that match all Attributes
                     sets @sellist to -1
                  elseif arguments are: "face"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist to all Faces
                  elseif arguments are: "face iface"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist to iface
//$$$                  elseif arguments are: "face 0 iford1" or
//$$$                                        "face ibody1 0"
//$$$                     sets @seltype to 2
//$$$                     uses @selbody
//$$$                     sets @sellist with Faces in @selbody that matches ibody1/iford1
//$$$                                   (with 0 being treated as a wildcard)
                  elseif arguments are: "face ibody1 iford1 iseq=1"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist with Face in @selbody that matches ibody1/iford1
                     (note that 0 can be used as a wildcard in any numeric field)
                     (note that if any fields are 0, the default iseq=0)
                  elseif arguments are: "face xmin xmax ymin ymax zmin zmax"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist to Faces whose bboxs are completely in given range
                  elseif arguments are: "face attrName1    attrValue1
                                              attrName2=$* attrValue2=$*
                                              attrName3=$* attrValue3=$*"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist to Faces in @selbody that match all Attributes
                  elseif arguments are: "edge"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to all Edges
                  elseif arguments are: "edge iedge"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to iedge
//$$$                  elseif arguments are: "edge 0 iford1 ibody2 iford2" or
//$$$                                        "edge ibody1 0 ibody2 iford2" or
//$$$                                        "edge ibody1 iford1 0 iford2" or
//$$$                                        "edge ibody1 iford1 ibody2 0" or
//$$$                                        "edge ibody1 0 ibody2 0"
//$$$                     sets @seltype to 1
//$$$                     uses @selbody
//$$$                     sets @sellist to Edge in @selbody that adjoins Faces
//$$$                        ibody1/iford1 and ibody2/iford2 (with 0 being treated as wildcard)
                  elseif arguments are: "edge ibody1 iford1 ibody2 iford2 iseq=1"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edge in @selbody that adjoins Faces
                        ibody1/iford1 and ibody2/iford2
                     (note that 0 can be used as a wildcard in any numeric field)
                     (note that if any fields are 0, the default iseq=0)
                  elseif arguments are: "edge xmin xmax ymin ymax zmin zmax"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edges whose bboxs are completely in given range
                  elseif arguments are: "edge attrName1    attrValue1
                                              attrName2=$* attrValue2=$*
                                              attrName3=$* attrValue3=$*"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edges in @selbody that match all Attributes
                  elseif arguments are: "edge x y z"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edge whose center is closest to (x,y,z)
                  elseif arguments are: "loop iface iloop"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edges in order in the Loop
                  elseif arguments are: "node"
                     sets @seltype to 0
                     uses @selbody
                     sets @sellist to all Nodes
                  elseif arguments are: "node inode"
                     sets @seltype to 0
                     uses @selbody
                     sets @sellist to inode
                  elseif arguments are: "node x y z"
                     sets @seltype to 0
                     uses @selbodt
                     sets @sellist to Node closest to (x,y,z)
                  elseif arguments are: "node xmin xmax ymin ymax zmin zmax"
                     sets @seltype to 0
                     uses @selbody
                     sets @sellist to Nodes that are in given range
                  elseif arguments are: "node attrName1    attrValue1
                                              attrName2=$* attrValue2=$*
                                              attrName3=$* attrValue3=$*"
                     sets @seltype to 0
                     uses @selbody
                     sets sellist to Nodes in @selbody that match all Attributes
                  elseif arguments are: "add attrName1    attrValue1
                                             attrName2=$* attrValue2=$*
                                             attrName3=$* attrValue3=$*"
                     uses @seltype
                     uses @selbody
                     appends to @selList the Nodes/Edges/Faces that match all Attributes
                  elseif arguments are: "add ibody1 iford1 iseq=1" and @seltype is 2
                     uses @selbody
                     appends to @sellist the Face in @selbody that matches ibody1/iford1
                     (a 0 matches ibody1=0 amd/or iford1=0)
                  elseif arguments are: "add ibody1 iford1 ibody2 iford2 iseq=1" and @seltype is 1
                     uses @selbody
                     appends to @sellist the Edge in @selbody that adjoins Faces
                     (a 0 matches ibody1=0, iford1=0, ibody2=0, and/or iford2=0)
                  elseif arguments are: "add iface" and @seltype is 2
                     uses @selbody
                     appends to @sellist Face iface in @selbody
                     (wildcarding is not allowed)
                  elseif arguments are: "add iedge" and @seltype is 1
                     uses @selbody
                     appends to @sellist Edge iedge in @selbody
                     (wildcarding is not allowed)
                  elseif arguments are: "add inode" and @seltype is 0
                     uses @selbody
                     appends to @sellist Node inode in @selbody
                     (wildcarding is not allowed)
                  elseif arguments are: "sub attrName1    attrValue1
                                             attrName2=$* attrValue2=$*
                                             attrName3=$* attrValue3=$*"
                     uses @seltype
                     uses @selbody
                     removes from @sellist the Nodes/Edges/Faces that match all Attributes
                  elseif arguments are: "sub ibody1 iford1 iseq=1" and @seltype is 2
                     uses @selbody
                     removes from @sellist the Face in @selbody that matches ibody1/iford1
                     (a 0 matches ibody1=0 amd/or iford1=0)
                  elseif arguments are: "sub ibody1 iford1 ibody2 iford2 iseq=1" and @seltype is 1
                     uses @selbody
                     removes from @sellist the Edge in @selbody that adjoins Faces
                     (a 0 matches ibody1=0, iford1=0, ibody2=0, and/or iford2=0)
                  elseif arguments are: "sub ient" and ient is in @sellist
                     removes from @sellist ient
                     (wildcarding is not allowed)
                  elseif arguments are: "sort $key"
                     sorts @sellist based upon $key which can be: $xmin, $ymin, $zmin,
                        $xmax, $ymax, $zmax, $xcg, $ycg, $zcg, $area, or $length

                  Face specifications are stored in _faceID Attribute
                  Edge specifications are stored in _edgeID Attribute
//                Node specifications are stored in _nodeID Attribute
                  iseq selects from amongst multiple Faces/Edges/Nodes that
                     match the ibody/iford specifications
                  attrNames and attrValues can be wild-carded with $*
                  avoid using forms "SELECT face iface" and "SELECT edge iedge"
                     since iface and iedge are not guaranteed to be the same during
                     rebuilds or on different OpenCASCADE versions or computers
                  sets up @-parameters
                  cannot be followed by CSYSTEM
                  signals that may be thrown/caught:
                     $body_not_found
                     $edge_not_found
                     $face_not_found
                     $node_not_found
        </pre>
      <p><h3 id="set">set</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SET       $pmtrName exprs
          use:    define or update a (redefinable) local or output variable
          pops:   -
          pushes: -
          notes:  Solver may not be open
                  pmtrName can be in form 'name', 'name[irow]', or 'name[irow,icol]'
                  pmtrName must not start with '@'
                  pmtrName must not refer to an DESPMTR/CONPMTR Parameter
                  pmtrName will be marked as LOCALVAR (or OUTPMTR)
                  pmtrName is used directly (without evaluation)
                  irow and icol cannot contain a comma or open bracket
                  if exprs has multiple values (separated by ;), then
                     any subscripts in pmtrName are ignored
                  if exprs starts with $ (or evaluates to a string), then any
                     subscripts in pmtrName are ignored and a string value is defined
                  if exprs is the name of a multi-valued parameter, it is
                      treated as if its values were listed as a semi-colon-
                      separated list
                  if pmtrName is in the form 'name' or 'name[0]' or 'name[0,0]'
                     if exprs is longer than Parameter size, extra exprs are lost
                     if exprs is shorter than Parameter size, last expr is repeated
                  if pmtrName is in the form 'name[irow]' or 'name[irow,0]', then
                     the irow'th element is defined (where elements are counted
                     across rows)
                  if pmtrName is in the form 'name[irow,icol]' and irow is between
                     1 and nrow and icol is between 1 and ncol, then the
                     [irow,icol]th element is set
                  if no Bodys have been created yet
                     associated ATTRIBUTEs are global Attributes
                  otherwise
                     cannot be followed by ATTRIBUTE
                  cannot be folowed by CSYSTEM
        </pre>
      <p><h3 id="skbeg">skbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SKBEG     x y z relative=0
          use:    start a new Sketch with the given point
          pops:   -
          pushes: -
          notes:  opens Sketch
                  Solver may not be open
                  if relative=1, then all values in sketch are relative to x,y,z
                  sensitivity computed w.r.t. x, y, z
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="skcon">skcon</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SKCON     $type index1 index2=-1 $value=0
          use:    creates a Sketch constraint
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  may only follow SKVAR or another SKCON statement
                  $type
                     X  ::x[index1]=value
                     Y  ::y[index1]=value
                     Z  ::z[index1]=value
                     P  segments adjacent to point index1 are perpendicular
                     T  segments adjacent to point index1 are tangent
                     A  segments adjacent to point index1 have
                                                           angle=$value (deg)
                     W  width:  ::x[index2]-::x[index1]=value  if plane==xy
                                ::y[index2]-::y[index1]=value  if plane==yz
                                ::z[index2]-::z[index1]=value  if plane==zx
                     D  depth:  ::y[index2]-::y[index1]=value  if plane==xy
                                ::z[index2]-::z[index1]=value  if plane==zx
                                ::x[index2]-::x[index1]=value  if plane==zx
                     H  segment from index1 and index2 is horizontal
                     V  segment from index1 and index2 is vertical
                     I  segment from index1 and index2 has
                                                     inclination=$value (deg)
                     L  segment from index1 and index2 has length=$value
                     R  cirarc  from index1 and index2 has radius=$value
                     S  cirarc  from index1 and index2 has sweep=$value (deg)
                  index=1 refers to point in SKBEG statement
                  $value can include the following variables
                     ::x[i]  X-coordinate of point i
                     ::y[i]  Y-coordinate of point i
                     ::z[i]  Z-coordinate of point i
                     ::d[i]  dip associated with segment starting at point i
                  $value can include the following shorthands
                     ::L[i]  length      of segment starting at point i
                     ::I[i]  inclination of segment starting at point i  (degrees)
                     ::R[i]  radius of arc          starting at point i
                     ::S[i]  sweep  of rc           starting at point i  (degrees)
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="skend">skend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SKEND     wireonly=0
          use:    completes a Sketch
          pops:   -
          pushes: Sketch
          notes:  Sketch must be open
                  Solver may not be open
                  if Sketch contains SKVAR/SKCON, then Sketch variables are
                     updated first
                  if wireonly=0, all LINSEGs and CIRARCs must be x-, y-, or
                     z-co-planar
                  if Sketch is     closed and wireonly=0,
                     then a SheetBody is created
                  if Sketch is     closed and wireonly=1,
                     then a WireBody  is created
                  if Sketch is not closed,
                     then a WireBody  is created
                  if SKEND immediately follows SKBEG, then a NODE is created
                     (which can be used at either end of a LOFT or BLEND)
                  closes Sketch
                  new Face receives the Branch's Attributes
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $underconstrained
                     $overconstrained
                     $not_converged
                     $colinear_sketch_points
                     $non_coplnar_sketch_points
                     $self_intersecting
        </pre>
      <p><h3 id="skvar">skvar</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SKVAR     $type valList
          use:    create multi-valued Sketch variables and their initial
                     values
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  may only follow SKBEG statement
                  $type
                     xy valList contains ::x[1]; ::y[1]; ::d[1]; ::x[2]; ...
                     yz valList contains ::y[1]; ::z[1]; ::d[1]; ::y[2]; ...
                     zx valList contains ::z[1]; ::x[1]; ::d[1]; ::z[2]; ...
                  valList is a semicolon-separated list
                  valList must end with a semicolon
                  the number of entries in valList is taken from number of
                     semicolons
                  the number of entries in valList must be evenly divisible by 3
                  enter :d[i] as zero for LINSEGs
                  values of ::x[1], ::y[1], and ::z[1] are overwritten by
                     values in SKBEG
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="solbeg">solbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SOLBEG    $varList
          use:    starts a Solver Block
          pops:   -
          pushes: -
          notes:  Solver must not be open
                  opens the Solver
                  varList is a list of semicolon-separated LOCALVARs
                  varList must end with a semicolon
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="solcon">solcon</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SOLCON    $expr
          use:    constraint used to set Solver parameters
          pops:   -
          pushes: -
          notes:  Sketch must not be open
                  Solver must be open
                  SOLEND will drive expr to zero
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="solend">solend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SOLEND
          use:    designates the end of a Solver Block
          pops:   -
          pushes: -
          notes:  Sketch must not be open
                  inner-most Block must be a Solver Block
                  adjust parameters to drive constraints to zero
                  closes Solver Block
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="sphere">sphere</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SPHERE    xcent ycent zcent radius
          use:    create a sphere Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xcent, ycent, zcent, radius
                  computes Face, Edge, and Node sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: ymin, ymax
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="spline">spline</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SPLINE    x y z
          use:    add a point to a spline
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  sensitivity computed w.r.t. x, y, z
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="sslope">sslope</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SSLOPE    dx dy dz
          use:    define the slope at the beginning or end of a SPLINE
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  for defining slope at beginning:
                      must not follow a SPLINE statement
                      must    precede a SPLINE statement
                  for definiing slope at end:
                      must      follow a SPLINE statement
                      must not precede a SPLINE statement
                  dx, dy, and dz must not all be zero
                  sensitivity computed w.r.t. x, y, z
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="store">store</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
STORE     $name index=0 keep=0
          use:    stores Group on top of Stack
          pops:   any
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  $name is used directly (without evaluation)
                  if index<0, use first available index
                  previous Group in name/index is overwritten
                  if $name=.   then Body is popped off stack
                                    but not actually stored
                  if $name=..  then pop Bodys off stack back
                                    to the Mark
                  if $name=... then the stack is cleared
                  if keep==1, the Group is not popped off stack
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="subtract">subtract</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SUBTRACT  $order=none index=1 maxtol=0
          use:    perform Boolean subtraction (Body2 - Body1)
          pops:   Body1 Body2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if     Body1=SolidBody and Body2=SolidBody
                     create SolidBody that is the part of Body1 that is
                        outside Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=SolidBody and Body2=SheetBody
                     create SolidBody that is Body1 scribed with Edges at
                        intersection with Body2
                  elseif Body1=SheetBody and Body2=SolidBody
                     create SheetBody that is part of Body1 that is
                        outside Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=SheetBody and Body2=SheetBody
                     create SheetBody that is Body1 scribed with Edges at
                        intersection with Body2
                  elseif Body1=WireBody and Body2=SolidBody
                     create WireBody that is part of Body1 that is outside Body2
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body1=WireBody and Body2=SheetBody
                     create WireBody that is Body1 scribed with Nodes at
                        intersection with Body2
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body2=NodeBody
                     split Edges in Body1 at Body2
                  endif
                  if subtraction does not produce at least index Bodys,
                     an error is returned
                  order may be one of:
                     none    same order as returned from geometry engine
                     xmin    minimum xmin   is first
                     xmax    maximum xmax   is first
                     ymin    minimum ymin   is first
                     ymax    maximum ymax   is first
                     zmin    minimum zmin   is first
                     zmax    maximum zmax   is first
                     amin    minimum area   is first
                     amax    maximum area   is first
                     vmin    minimum volume is first
                     vmax    maximum volume is first
                  if maxtol>0, then tolerance can be relaxed until successful
                  if maxtol<0, then use -maxtol as only tolerance to use
                  sets up @-parameters
                  order is used directly (without evaluation)
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="sweep">sweep</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SWEEP
          use:    create a Body by sweeping an Xsect along an Xsect
          pops:   Xsect1 Xsect2
          pushes: Body
          notes:  results can be unpredictable due to OpenCASCADE issues
                  Sketch may not be open
                  Solver may not be open
                  Xsect1 must be either a SheetBody or non-manifold WireBody
                  Xsect2 must be a WireBody
                  if Xsect2 is not slope-continuous, result may not be
                     as expected
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Xsect are maintained
                  face-order is: (base), (end), feat1a, feat1b, ...
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="throw">throw</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
THROW     sigCode
          use:    set current signal to sigCode
          pops:   -
          pushes: -
          notes:  skip statements until a matching CATBEG Branch is found
                  sigCode>0 are usually user-generated signals
                  sigCode<0 are usually system-generated signals
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="torus">torus</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
TORUS     xcent ycent zcent dxaxis dyaxis dzaxis majorRad minorRad
          use:    create a torus Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xcent, ycent, zcent, dxaxis,
                     dyaxis, dzaxis, majorRad, minorRad
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: xmin/ymin, xmin/ymax, xmax/ymin, xmax/ymax
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="translate">translate</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
TRANSLATE dx dy dz
          use:    translates Group on top of Stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. dx, dy, dz
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="ubound">ubound</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
UBOUND    $pmtrName bounds
          use:    defines an upper bound for a DESPMTR or CFGPMTR
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a function-type .udc file
                  if value of Parameter is larger than bounds, a warning is
                     generated
                  pmtrName must have been defined previously by DESPMTR
                     statement
                  pmtrName can be in form 'name' or 'name[irow,icol]'
                  pmtrName must not start with '@'
                  pmtrName is used directly (without evaluation)
                  irow and icol cannot contain a comma or open bracket
                  if irow is a colon (:), then all rows    are input
                  if icol is a colon (:), then all columns are input
                  pmtrName[:,:] is equivalent to pmtrName
                  bounds cannot refer to any other Parameter
                  bounds are defined across rows, then across columns
                  if bounds has more entries than needed, extra bounds
                     are lost
                  if bounds has fewer entries than needed, last bound
                     is repeated
                  any previous bounds are overwritten
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="udparg">udparg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
UDPARG    $primtype $argName1 argValue1 $argName2 argValue2 ...
                    $argName3 argValue3 $argName4 argValue4
          use:    pre-set arguments for next UDPRIM statement
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  there can be no statements except other UDPARGs before the
                     next matching UDPRIM
                  primtype determines the type of primitive
                  primtype must match primtype of next UDPRIM statement
                  primtype is used directly (without evaluation)
                  arguments are specified in name/value pairs and are
                      not positional
                  argName#  is used directly (without evaluation)
                  argValue# is used directly if it starts with '$', otherwise it
                     is evaluated
                  if argValue starts with '$$/', use path relative to .csm file
                  arguments for following UDPRIM statement are evaluated
                     in the order they are encountered (UDPARG first)
                  sensitivity computed w.r.t. argValue1, argValue2, argValue3,
                     argValue4
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="udprim">udprim</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
UDPRIM    $primtype $argName1 argValue1 $argName2 argValue2 ...
                    $argName3 argValue3 $argName4 argValue4
          use:    create a Body by executing a UDP, UDC, or UDF
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  primtype  determines the type of primitive and the number of
                     argName/argValue pairs
                  if primtype begins with a letter
                     then a compiled udp whose name is primtype.so is used
                  if primtype starts with a /
                     then a .udc file in the current directory will be used
                  if primtype starts with $/
                     then a .udc file in the parent (.csm or .udc)
                     directory will be used
                  if primtype starts with $$/
                     then a .udc file in ESP_ROOT/udc will be used
                  primtype  is used directly (without evaluation)
                  arguments are specified in name/value pairs and are
                      not positional
                  argName#  is used directly (without evaluation)
                  argValue# is used directly if it starts with '$', otherwise it
                     is evaluated
                  if argValue# is <<, use data to matching >> as inline file
                  if argValue# starts with '$$/', use path relative to .csm file
                  extra arguments can be set with UDPARG statement
                  when called to execute a .udc file:
                     the level is incremented
                     LOCALVARs are created for all INTERFACE stmts
                        for "in"  the value is set to its default
                        for "out" the value is set to its default
                        for "dim" an array is created (of size=value) with
                           value=dot=0
                     the associated UDPARG and UDPRIM statements are processed
                        in order
                        if argName matches a Parameter created by an INTERFACE
                           statement
                           if argValueX matches the name of a Parameter at
                              level-1
                              the values are copied into the new Parameter
                           else
                              argValueX is evalued and stored in the new
                                 Parameter
                        else
                           an error is returned
                     the statements in the .udc are executed until an END
                        statement
                        a SET statement either creates a new Parameter or
                           overwrites a value
                     during the execution of the END statement
                        for values associated with an INTERFACE "out" statement
                           the value is copied to the appropriate @@-parameter
                              (at level-1)
                        all Parameters at the current level are destroyed
                        the level is decremented
                  sensitivity computed w.r.t. argValue1, argValue2, argValue3,
                     argValue4
                  computes Face and Edge sensitivities analytically (if supplied
                     by the udp)
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is based upon order returned from UDPRIM
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $insufficient_bodys_on_stack
                     udp-specific code
                  see udp documentation for full information
        </pre>
      <p><h3 id="union">union</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
UNION     toMark=0 trimList=0 maxtol=0
          use:    perform Boolean union
          pops:   Body1 Body2  -or-  Body1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if     toMark=1
                     create SolidBody that is combination of SolidBodys
                        since Mark
                  elseif Body1=SolidBody and Body2=SolidBody
                     if trimList=0
                        create SolidBody that us combination of Body1 and Body2
                     else
                        create SolidBody that is trimmed combination of Body1
                           and Body2
                        trimList contains x;y;z;dx;dy;dz where
                           (x,y,z) is inside the Body to be trimmed
                           (dx,dy,dz) is step toward the trimming Body
                     endif
                  elseif Body1=SheetBody and Body2=SheetBody
                     create SheetBody that is the combination of Bodys with
                        possible new Edges
                  endif
                  if maxtol>0, then tolerance can be relaxed until successful
                  if maxtol<0, then use -maxtol as only tolerance to use
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>

    <p><h3 id="sec5.5">5.5: User-Defined Primitives/Functions shipped with OpenCSM</h3>

      <pre>
UDPRIM bezier
       input arguments (specified as name/value pairs):
           filename   name of bezier file (prepended with '$' or '$$/')
           debug      =0 for no debug, =1 for debug   [default 0]
       output arguments:
           imax       number of points in i direction
           jmax       number of points in j direction
       usage:
           read imax, jmax
           for (j=0; j < jmax; j++)
               for (i=0; i < imax; i++)
                   read x(i,j), y(i,j), z(i,j)
               endfor
           endfor

           if (jmax==1)
               generate WIRE Body
           elseif (surface is open)
               generate SHEET Body
           else
               generate SOLID Body
           endif
       notes:
           vsp files can be converted to this format by vsp2csm

UDPRIM biconvex
       input arguments (specified as name/value pairs):
           thick      maximum thickness      [default 0]
           camber     maximum camber         [default 0]
       output arguments:
       notes:
           thick  must be positive
           leading edge at (0,0,0)
           trailing edge at (1,0,0)
           airfoil generated in x-y plane

UDPRIM box
       input arguments (specified as name/value pairs):
           dx         width in x-direction   [default 0]
           dy         width in y-direction   [default 0]
           dz         width in z-direction   [default 0]
           rad        corner radius          [default 0]
       output arguments:
           area       overall surface area
           volume     enclosed volume
       usage:
           if     (dx>0 && dy>0 && dz>0)
               if (2*rad>dx && 2*rad>dy && 2*rad>dz)
                   ERROR
               elseif (rad>0)
                   generate SOLID Body with rounded edges
               else
                   generate SOLID Body
               endif
           elseif (dx==0 && dy>0 && dz>0)
               if (2*rad>dy && 2*rad>dz)
                   generate SHEET Body in yz-plane with rounded corners
               else
                   generate SHEET Body iy yz-plane
               endif
           elseif (dx>0 && dy==0 && dz>0)
               if (2*rad>dx && 2*rad>dz)
                   generate SHEET Body in xz-plane with rounded corners
               else
                   generate SHEET Body iy xz-plane
               endif
           elseif (dx>0 && dy>0 && dz==0)
               if (2*rad>dx && 2*rad>dy)
                   generate SHEET Body in xy-plane with rounded corners
               else
                   generate SHEET Body in xy-plane
               endif
           elseif (dx==0 && dy==0 && dz>0)
               generate WIRE Body along z-axis
           elseif (dx>0 && dy==0 && dz==0)
               generate WIRE Body along x-axis
           elseif (dx==0 && dy>0 && dz==0)
               generate WIRE Body along y-axis
           else
               ERROR
           endif
       notes:
           all Bodys are centered at origin

UDPRIM catmull
       input arguments (specified as name/value pairs):
          nsubdiv     number of subdivisions  [default 1]
          progress    level of outpus         [default 0]
       output arguments:
       usage:
          performs Catmull-Clark subdivisions on Body on top of stack
        notes:
          if a Face has a limitFace attribute
             the motion of points are limited in X, Y, and/or Z

UDPRIM createBEM
       input arguments (specified as name/value pairs):
          filename    name of output file
          space       nominal spacing         [default 0]
          imin        minimum points on Edge  [default 3]
          imax        maximum points on Edge  [default 5]
       output arguments:
       usage:
          creates a NASTRAN-stype BEM file from Body on stack

UDPRIM createPoly
       input arguments (specified as name/value pairs):
           filename   name of output file
           hole       coordinates of "hole"   [default 0;0;0]
       output arguments:
       usage:
           pops 2 Bodys from stack
           writes a AFLR .poly file between the two Bodys
           pushes the inner Body back onto the stack

UDPRIM csm
       input arguments (specified as name/value pairs):
           filename   name of .csm file
           pmtrname   semi-colon-separated list of Design
                         Parameters in filename
           pmtrvalue  multi-value list of Design Parameter
                         values
       output arguments:
           volume     volume of Body created
       usage:
           runs filename in a sub-process and returns
              last Body on the stack

UDPRIM droop
       input arguments (specified as name/value pairs):
          xle        percent x at LE         [default -100]
          thetale    LE droop angle (deg)    [default    0]
          xte        percent x at TE         [default  100]
          thetate    TE droop angle (deg)    [default    0]
       output arguments:
       usage:
           droops airfoil on stack forward of xle and rearward of xte

UDPRIM editAttr
       input arguments (specified as name/value pairs):
          attrname    name of Attribute to edit
          input       string containing D B N E F characters
          output      string containing   B N E F characters
          overwrite   overwrite flag          [default 0]
                      0 do not overwrite
                      1        overwrite
                      2 use smaller value (or first alphabetical)
                      3 use larger  value (or last  alphabetical)
                      4 use sum                (or concatenation)
          filename    alternative file-base specification
                      (see wingAttrTest for an example)
          verbose     =1 to watch progress
       output arguments:
          nchange     number of changes made
       usage:
          attrname can use * as wildcard for zero or more chars
          attrname can use + as wildcard for one  or more chars
          attrname can use ? as wildcard for exactly one  char
          input and output must be same length or single character
          pops Body from stack
          loop through each character in input and output
              if (input[i]=D)
                 delete attribute from output[i]
              elseif (input[i]=B)
                 propagate Body attribute to output[i]
              elseif (input[i]=N)
                 propagate Node attribute to output[i]
              elseif (input[i]=E)
                 propagate Edge attribute to output[i]
              elseif (input[i]=F)
                 propagate Face attribute to output[i]
          pushes Attributed Body onto stack
       note:
          Attributes on Nodes and/or Edges may get lost during
             subsequent regeneration

UDPRIM ellipse
       input arguments (specified as name/value pairs):
           rx         radius in x-direction   [default 0]
           ry         radius in y-direction   [default 0]
           rz         radius in z-direction   [default 0]
           nedge      number of Edges         [default 2]
           thbeg      theta for first Node    [default 0]
           theta      optional array of thetas[default 0]
           theta[]    array of thetas
       output arguments:
       usage:
           if     (rx==0 && ry>0 && rz>0)
               generate an elliptical SHEET Body in yz-plane
           elseif (rx>0 && ry==0 && rz>0)
               generate an elliptical SHEET Body in xz-plane
           elseif (rx>0 && ry>0 && rz==0)
               generate an elliptical SHEET Body in xy-plane
          else
               ERROR
          endif
       note:
           all Bodys are centered at origin

UDPRIM fitcurve
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
           ncp        number of control points    [default 0]
           ordered    =0 means points not ordered [default 1]
           periodic   =1 means periodicity at ends[default 0]
           split      point indices (bias-1) to
                      split into multiple Edges   [default 0]
           xform      3*4 transformation matrix   [default 0]
       output arguments:
           npnt       number of point in file
           rms        rms of distances from points to curve
       usage:
           read points (X, Y, Z) from filename (one point per line)
           repeated points designate Node locations (which
              separate Edges)
           the Bspline is defined to be C2-continuous everywhere
           if (first and last points are the same)
              if (there are no repeated points)
                  ERROR (need at least two Edges)
              elseif (the points are planar)
                  a SheetBody is created
              else
                  ERROR (do not know how to "fill in" for Face)
              endif
           else
              a WireBody is created
           endif

UDPRIM flend
       input arguments (specified as name/value pairs):
           slopea     slopea factor for Body A          [default 1]
           slopeb     slopea factor for Body B          [default 1]
           toler      matching tolerance during sew     [default 1e-6]
           equis      spacing method (see below)        [default 0]
           npnt       number of sample points           [default 33]
           plot       =1 to write flend.plot            [default 0]
       output arguments:
       usage:
           pops up to 2 Bodys back to mark from stack
           pushes FLENDed Body back onto stack
           if equis=0, equal t-spacing on both A and B
           if equis=1, equal arc-length spacing on both Bodys
           if equis=2, equal t-spacing on A; B matches arc-length
           if equis=3, equal t-spacing on B; A matches arc-length

UDPRIM freeform
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
           imax       number of points in i-direction   [default 1]
           jmax       number of points in j-direction   [default 1]
           kmax       number of points in k-direction   [default 1]
           xyz        coordinates
       output arguments:
       usage:
           if (filename exists)
               read imax, jmax, kmax
               if (kmax <= 1)
                   for (k=0; k < kmax; k++)
                       for (j=0; j < jmax; j++)
                           for (i=0; i < imax; i++)
                               if (i==0 || i==imax-1 ||
                                   j==0 || j==jmax-1 ||
                                   k==0 || k==kmax-1   )
                                   read x(i,j,k), y(i,j,k), z(i,j,k)
                               endif
                           endfor
                       endfor
                   endfor
               else
                   for (j=0; j < jmax; j++)
                       for (i=0; i < imax; i++)
                           read x(i,j,0), y(i,j,0), z(i,j,0)
                       endfor
                   endfor
               endif
           else
               for (k=0; k < kmax; k++)
                   for (j=0; j < jmax; j++)
                       for (i=0; i < imax; i++)
                           x(i,j,k) = xyz[3*(i+imax*(j+jmax*k)  ]
                           y(i,j,k) = xyz[3*(i+imax*(j+jmax*k)+1]
                           z(i,j,k) = xyz[3*(i+imax*(j+jmax*k)+2]
                       endfor
                   endfor
               endfor
           endif

           if     (jmax <= 1)
               generate WIRE Body
           elseif (kmax <= 1)
               generate SHEET Body
           else
               generate SOLID Body from outer planes of data
           endif

UDPRIM ganged Mark, Body1, ...
       input arguments (specified as name/value pairs):
           $op        SUBTRACT or UNION
           toler      tolerance                 [default 0]
       output arguments:
           area       surface area
           volume     volume of Body created
       usage:
           pops Bodys back to Mark
           uses first Body as a common Body for SUBTRACT or UNION

UDPRIM guide Body1 Body2
       input arguments (specified as name/value pairs):
           nxsect     number of xsections to create [default 5]
           origin     x;y;z in Body1 for beginning of guide curve
           axis       translation type (see below)
       output arguments:
       usage:
           Body1 is profile
           Body2 is guide curve
           if     axis=x;y;z;1;0;0
           elseif axis=x;y;z;0;1;0
           elseif axis=x;y;z;0;0;1
           else

UDPRIM hex
       input arguments (specified as name/value pairs):
           corners    coordinate values at corners (24 values)
                         x0, y0, z0, x1, y1, z1, ...

                               ^ V
                               |
                               2----------3
                              /:         /|
                             / :        / |
                            /  :       /  |
                           6----------7   |
                           |   0------|---1  --> U
                           |  '       |  /
                           | '        | /
                           |'         |/
                           4----------5
                          /
                         W

           uknots     optional list of knots in U direction
           vknots     optional list of knots in V directtion
           wknots     optional list of knots in W directtion
       output arguments:
           area       surface area
           volume     volume of Body created
       usage:
           generates a hexahedron
           there are no check for duplicate vertices
           sensitvities not computed

UDPRIM import
       input arguments (specified as name/value pairs):
           filename   name of file1 (prepended with '$' or '$$/')
           bodynumber number of body within filename (bias-1)   [default 1]
                  if bodynumber=-1, then all Bodys are returned in one Group
       output arguments:
           numbodies  number of bodys in file
       usage:
           read the .egads or .stp file
           extract the bodynumber'th Body

UDPRIM kulfan
       input arguments (specified as name/value pairs):
           class      class function at leading and trailing edge (2 values)
           ztail      height of upper and lower trailing edge (2 values)
           aupper     vector of control points for upper surface
           alower     vector of control points fpr lower surface
           numpts     number of points used to define spline [default 101]
       output arguments:
       notes:
            always generates airfoil with 3 edges (upper, lower, TE)
            leading edge is at (0,0,0)
            airfoil generated in x-y plane

UDPRIM naca
       input arguments (specified as name/value pairs):
           series     NACA 4-digit designator             [default 0012]
           camber     maximum camber    (percent chord)   [default 0.0]
           maxloc     location of max camber  (% chord)   [default 0.4]
           thickness  maximum thickness (percent chord)   [default 0.0]
           offset     create offset (>0 for larger)       [default 0.0]
           sharpte    =1 to change thickness for sharp TE [default 0  ]
       output arguments:
       usage:
           if (camber == 0 && maxloc == 0.4 && thickness <= 0)
               extract camber, maxloc, and thickness from series
           endif
           if (thickness==0)
               generate WIRE Body of camber line in xy-plane
           else
               generate SHEET Body in xy-plane
           endif
       notes:
           leading  edge is at (0,0,0)
           trailing edge is at (1,0,0)
           airfoil generated in x-y plane
           if sharpte=1, the x^4 coefficient in thickness eqn is changed

UDPRIM naca456
       input arguments (specified as name/value pairs):
           thkcode    thickness code: $4, $4M, $63, $63A, $64, $64A, $65, $65A,
                         $66, or $67
           toc        thickness/chord ratio
           xmaxt      chordwise location of maximum thickness (only for $4M)
           leindex    leading edge raius parameter (only for $4M)
           camcode    camber code: $0, $2, $3, $3R, $6 or $6M
           cmax       maximum camber/chord
           xmaxc      chordwise location of maximum camber (only for $2)
           cl         design lift coefficient (only for $3, $3R, $6x, and $6xA)
           a          extent of constant loading (only for $6x and $6xA)
       output arguments:
       usage:
           NACA 00tt    -> thkcode=$4,   toc=tt/100,
                           camcode=$0
           NACA mptt    -> thkcode=$4,   toc=tt/100,
                           camcode=$2,   cmax=m/100, xmaxc=p/10
           NACA mptt-lx -> thkcode=$4M,  toc=tt/100, leindex=l, xmaxt=x,
                           camcode=$2,   cmax=m/100, xmaxc=p/10
           NACA mp0tt   -> thkcode=$4,   toc=tt/100,
                           camcode=$3,   cl=m*.15,   xmaxc=p/20
           NACA mp1tt   -> thkcode=$4,   toc=tt/100,
                           camcode=$3R,  cl=m*.15,   xmaxc=p/20
           NACA 63-mtt  -> thkcode=$63,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
           NACA 63Amtt  -> thkcode=$63A, toc=tt/100,
                           camcode=$6M,  cl=m/10,    a=0.8
           NACA 64-mtt  -> thkcode=$64,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
           NACA 64Amtt  -> thkcode=$64A, toc=tt/100,
                           camcode=$6M,  cl=m/10,    a=0.8
           NACA 65-mtt  -> thkcode=$65,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
           NACA 65Amtt  -> thkcode=$65A, toc=tt/100,
                           camcode=$6M,  cl=m/10,    a=0.8
           NACA 66-mtt  -> thkcode=$66,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
           NACA 67-mtt  -> thkcode=$67,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
       notes:
           NACA 5-series are described above as mp0tt and mp1tt
           leading  edge is at (0,0,0)
           trailing edge is at (1,0,0)
           airfoil generated in x-y plane

UDPRIM nurbbody
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
       output arguments:
       usage:
           build a SolidBody with untrimmed specified in filename
           for each Nurb, file contains 7-integer head followed
              by the real data as specified in egads.pdf file

UDPRIM parabaloid
       input arguments (specified as name/value pairs):
           xlength    length along axis in X direction
           yradius    radius in Y-direction
           zradius    radius in Z-direction
       output arguments:
       usage:
           if yadius>0 and zradius>0
               build a parabaloid (SolidBody)
           elseif yradius>0
               build a parabola (SheetBody) in x-z plane
           elseif zradius>0
               build a parabola (SheetBody) in x-y plane

UDPRIM nuscale
       input arguments (specified as name/value pairs):
           xscale     scale factor in X-direction       [default 1]
           yscale     scale factor in Y-direction       [default 1]
           zscale     scale factor in Z-direction       [default 1]
           xcent      center of scaling in X-direction  [default 0]
           ycent      center of scaling in Y-direction  [default 0]
           zcent      center of scaling in Z-direction  [default 0]
       output arguments:
       usage:
           converts Body on stack to BSplines
           pushes modified Body onto stack

UDPRIM parsec
       input arguments (specified as name/value pairs):
           yte        trailing edge height   [default 0]
           param      Sobiesky's parameters  [no defaults]
                      [1] = rle
                      [2] = xtop
                      [3] = ytop
                      [4] = d2x/dy2 at top
                      [5] = top theta at trailing edge (degrees)
                      [6] = xbot
                      [7] = ybot
                      [8] = d2x/dy2 at bot
                      [9] = bot theta at trailing edge (degrees)
           poly       polynomial coefficient [no defaults]
                      [  1 to  n] for top polynomial
                      [n+1 to 2n] for bot polynomial
           ztail      height of upper and lower trailing edge (2 values)
       output arguments:
       usage:
           either param or poly (but not both) must be specified
       notes:
           leading  edge is at (0,0,0)
           trailing edge is at (1,yte,0)
           airfoil generated in x-y plane

UDPRIM pod
       input arguments (specified as name/value pairs):
           length     length of pod          [default 0]
           fineness   fineness ratio         [default 0]
       output arguments:
           volume     enclosed volume
       usage:
           creates VSP-style pod
       notes:
           leading  edge is at (0,0,0)
           trailing edge is at (1,length,0)

UDPRIM poly
       input arguments (specified as name/value pairs):
           points     array of points (x,y,z,x,...)
       output arguments:
       usage:
           generate general polyhedron
       notes:
           npoints=1   point
           npoints=2   line
           npoints=3   triangle
           npoints=4   quadrilateral
           npoints=5   pyramid
           npoints=6   wedge
           npoints=8   hexahedron
           duplicate points allowed

UDPRIM printBbox
       input arguments (specified as name/value pairs):
       output arguments:
       usage:
           prints bounding box info for Body on top of stack

UDPRIM printBrep
       input arguments (specified as name/value pairs):
       output arguments:
       usage:
           prints BREP info for Body on top of stack

UDPRIM printEgo
       input arguments (specified as name/value pairs):
       output arguments:
       usage:
           prints Ego info for Body on top of stack

UDPRIM prop
       input arguments (specified as name/value pairs):
           nblade     number of blades       [default 2]
           cpower     power coefficient
           lambda     advance ratio
           reyr       reynolds number based on
                         tip radius and freestream
           rtip       tip radius
           rhub       hub radius
           clift      design section lift coefficient
           cdrag      design section drag coefficient
           alfa       design angle of attack (deg)
           shdiam     shaft diameter (or 0)  [default 0]
           shxmin     minimum x of shaft
           shxmax     maximum x of shaft
           spdiam     spinner diameter (or 0)[default 0]
           spxmin     minimum x of spinner
        output arguments:
           cthrust    thrust coefficient
           eff        efficiency
        usage:
           generates a propeller
           if shdiam is positive, a shaft is generated too
           if spdiam is positive, a spinner is generated too
        notes:
           uses design technique by Adkins and Liebeck

UDPRIM radwaf
       input arguments (specified as name/value pairs):
           ysize      y-extent of frames
           zsize      z-extent of frames
           nspoke     number of radial spokes
           xframe     array of frame locations
       output arguments:
       usage:
           generates a series of frames and spokes
           Faces in frames are attributed with:
              frame[0]   frame number   (bias-1)
              frame[1]   segment number (bias-1)
           Faces in slokes are attributed with:
              spoke[0]   spoke number   (bias-1)
              spoke[1]   segment number (bias-1)

UDPRIM sample
       input arguments (specified as name/value pairs):
           dx         size in X direction    [default 0]
           dy         size in Y direction    [default 0]
           dz         size in Z direction    [default 0]
           center     center of Body         [default 0;0;0]
       output arguments:
           area       surface area
           volume     enclosed volume
       usage:
           if center is prescribed, it must contain 3 values
           if all dx, dy, dz are positive
              make SOLID Body centered at center
           elseif two of dx, dy, dz are positive
              make SHEET Body centered at center
           elseif one of dx, dy, dz is positive
              make WIRE Body centered at center
           else
              error
           endif

UDPRIM sew
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
           toler      tolerance
       output arguments:
       usage:
           read the .egads or .stp file
           combines the various bodies into a single SHEET or SOLID Body
           if specified toler is smaller than Face tolers, use Face tolers

UDPRIM shadow
       input arguments (specified as name/value pairs):
           numpts     number of GraphPaper points  [default 1001]
       output arguments:
           area       projected area
           xcent      x-centroid of projected area
           ycent      y-centroid of projected area
           ixx        moment  of inertia
           ixy        product of inertia
           iyy        moment  of inertia
       usage:
           projects Body onto x-y plane and computes mass
               properties of projection

UDPRIM slices
       input arguments (specified as name/value pairs):
           nslice     number of slices
           dirn       direction x, X, y, Y, z, or, Z
       output arguments:
       usage:
           pops one Body off stack
           pushes many Bodys onto stack

UDPRIM stag
       input arguments (specified as name/value pairs):
           rad1       leading edge radius
           beta1      leading edge camber angle
           gama1      part of leading edge circle that is exposed
           rad2       trailing edge radius
           beta2      trailing edge camber angle
           gama2      part of trailing edge circle that is exposed
           alfa       stagger angle (between LE and TE)
           xfrnt      location of forward  control point
           xrear      location of rearward control point
       output arguments:
       usage:
           generate a simple turbomachinery airfoil

UDPRIM stiffener
       input arguments (specified as name/value pairs):
           beg         either 2 values (u;v) or 3 values (x;y;z) at beg
           end         either 2 values (u;v) or 3 values (x;y;z) at end
           depth       depth in direction of midpoint local    [default 0]
           angle       cut-back angles (deg) at end            [default 0]
       output arguments:
       usage:
           create a stiffener for the SheetBody on the stack

UDPRIM supell
       input arguments (specified as name/value pairs):
           rx        width  in X-direction                     [default 0]
           rx_w      width  on left   (west)  side             [default 0]
           rx_e      width  on right  (east)  side             [default 0]
           ry        height in Y-direction                     [default 0]
           ry_s      height on bottom (south) side             [default 0]
           ry_n      height on top    (north) side             [default 0]
           n         superellipse power                        [default 2]
           n_w       superellipse power on left   (west ) side [default 2]
           n_e       superellipse power on right  (east ) side [default 2]
           n_s       superellipse power on bottom (south) side [default 2]
           n_n       superellipse power on top    (north) side [default 2]
           n_sw      superellipse power in southwest quadrant  [default 2]
           n_se      superellipse power in southeast quadrant  [default 2]
           n_nw      superellipse power in northwest quadrant  [default 2]
           n_ne      superellipse power in northeast quadrant  [default 2]
           offset    create offset (>0 for larger)             [default 0]
           nquad     =1 ne wire, =2 ne/nw wire, =4 sheet       [default 4]
           numpnts   number of points in each quadrant         [default 11]
           slpfact   distance at ends to specify slope         [default 0]
       output arguments:
       usage:
           superellipse is generated separately in each quadrant, using:
               edge 1:
                   rx_e  is latest rx or rx_e
                   ry_n  is latest ry or ry_n
                   n_ne  is latest n, n_n, n_e, or n_ne
               edge 2:
                   rx_w  is latest rx or rx_w
                   ry_n  is latest ry or ry_n
                   n_nw  is latest n, n_n, n_w, or n_nw
               edge 3:
                   rx_w  is latest rx or rx_w
                   ry_s  is latest ry or ry_s
                   n_sw  is latest n, n_s, n_w, or n_sw
               edge 4:
                   rx_e  is latest rx or rx_e
                   ry_s  is latest ry or ry_s
                   n_se  is latest n, n_s, n_e, or n_se
           to get a simple ellipse, only need to specify rx and ry
           nquad=1 and nquad=2 create WireBodys, nquad=4 creates SheetBody
       notes:
           negative slpfac prescribes correct slopes at junctions
           super-ellipse centered at (0,0,0)
           super-ellipse generated in x-y plane

UDPRIM tblade
       input arguments (specified as name/value pairs):
           filename       Tblade input file
           auxname        name of either spancontrolinputs or
                             controlinputs file (depending on input file)
           ncp             number of control points in fit
           chord           override values
           thk_c           override values
           inci            override values
           devn            override values
           cur2            override values
           cur3            override values
           cur4            override values
           cur5            override values
           cur6            override values
           cur7            override values
           in_beta         override values
           out_beta        override values
           u2              override values
           u3              override values
           u4              override values
           u5              override values
           u6              override values
           span_in_beta    override values
           span_out_beta   override values
           span_curv_ctrl  override values
       output arguments:
       usage:
           filename is read into Tblade
           values specified in other arguments (such as chord)
              overwrite the values from the file
           Tblade is executed
           airfoils produced in Tblade are fit with ncp control points
           hub and tip are generated from bodies of revolution
           airfoils are blended into a volume

UDPRIM waffle
       input arguments (specified as name/value pairs):
           depth      depth in z-direction   [default 1]
           segments   array of segments
           filename   name of file
           progress   turn on progress print [default 0]
           layout     generate WireBodys instead of waffle [default 0]
       output arguments:
       usage:
           if (segments are set)
               if (length(segments)%4 != 0)
                   ERROR
               else
                   for (i=0; i < length(segments)/4; i++)
                       xbeg=segments[4*i  ]
                       ybeg=segments[4*i+1]
                       xend=segments[4*i+2]
                       yend=segments[4(i+3]
                       generate SHEET Body from (xbeg,ybeg,0) to (xend,yend,depth)
                   endfor
               endif
           elseif (filename is set)
               notes:  keywords can either be lowercase or UPPERCASE (not mixedCase)
               keywords are shown here in UPPERCASE to distinguish them from variables

               POINT  pointname AT xloc           yloc             creates point at <xloc,yloc>
                                AT x@pointname+dx y@pointname+dy   creates point <dx,dy> from named point
                                AT xloc           y@pointname      creates point at same y as named point and at given xloc
                                AT x@pointname    yloc             creates point at same x as named point and at given yloc
                                ON linename FRAC  fractDist        creates point on line at given fractional distance
                                ON linename PERP  pointname        creates point on line that is closest to point
                                ON linename XLOC  xloc             creates point on line at given xloc
                                ON linename YLOC  yloc             creates point on line at given yloc
                                ON linename SAMEX pointname        creates point on line with same x as point
                                ON linename SAMEY pointname        creates point on line with same y as point
                                ON linename XSECT linename         creates point at intersection of two lines

               LINE   linename  pointname pointname [attrName1=attrValue1 [...]]
                                                                   creates line between points with given attributes

               PATH   linename  pointname pointname                creates construction (invisible) line between points

               PATBEG varname ncopy                                loops ncopy times with varname=1,...,ncopy
               PATEND
           endif

           Faces are attributed with:
              segment    arbitrary seq number  (bias-1)
              waffleseg[0]  segment number     (bias-1)
              waffleseg[1]  subpart in segment (bias-1)
       </pre>

    <p><h3 id="sec5.6">5.6: User-Defined Components shipped with OpenCSM</h3>

      <pre>
These UDCs are shipped in the $ESP_ROOT/udc directory and should
be accessed using the $$/ prefix

UDPRIM $$/applyTparams
       input arguments (specified as name/value pairs):
           factor    tessellation scale factor    [default 1]
       output arguments:
       usage:
           modifies .tParams[1] and .tParams[2] by factor
       notes:

UDPRIM $$/biconvex
       input arguments (specified as name/value pairs):
           thick      maximum thickness           [default 0]
       output arguments:
       usage:
           generate unit chord biconvex airfoil
           thick must be positive
           airfoil is generated counterclockwise from TE
       notes:

UDPRIM $$/boxudc
       input arguments (specified as name/value pairs):
           dx         size in x direction         [default 0]
           dy         size in y direction         [default 0]
           dz         size in z direction         [default 0]
       output arguments:
           vol        volume
       usage:
           generate box centered at origin
           dx, dy, and dz must all be positive
       notes:
           this UDC was written as a demonstration

UDPRIM $$/contains
       input arguments (specified as name/value pairs):
       output arguments:
           contains    =0 if Body1 is fully     within Body2
                       =1 if Body1 is not fully within Body2
                       =2 if Body1 is partially within Body2
                       -3 if Body1 is          outside Body2
       usage:
           checks the containment of Body1 w.r.t. Body2
       notes:
           leaves the stack unchanged

UDPRIM $$/diamond
       input arguments (specified as name/value pairs):
           thick      maximum thickness           [default 0]
       output arguments:
       usage:
           generate unit chord diamond airfoil
           thick must be positive
           airfoil is generated counterclockwise from TE
       notes:

UDPRIM $$/flapz
       input arguments (specified as name/value pairs):
           xflap      outline of flap (4 doubles)
           yflap      outline of flap (4 doubles)
           theta      flap defleection            [default 15]
           gap        gap betwen flap and wing    [default 0.01]
           openEnd    =1 to leave gaps at ends    [default 0]
       output arguments:
       usage:
           define (xflap,yflap) counterclockwise
           hinge is between 2nd and 3rd point of (xflap,yflap)
           points 1 and 4 should be downstream of trailing edge
       notes:

UDPRIM $$/gen_rot
       input arguments (specified as name/value pairs):
           xbeg       x-coordinate at beg of axis [default 0]
           ybeg       y-coordinate at beg of axis [default 0]
           zbeg       z-coordinate at beg of axis [default 0]
           xend       x-coordinate at end of axis [default 1]
           yend       y-coordinate at end of axis [default 1]
           zend       z-coorindate at end of axis [default 1]
           rotang     rotation angle (deg)        [default 0]
       output arguments:
           azimuth    azimuth   angle in    x-y plane (deg)
           elevation  elevation angle above x-y plane (deg)
       usage:
           general rotation of Group on top of stack
           beg and end points must not be the same
       notes:

UDPRIM $$/overlaps
       input arguments (specified as name/value pairs):
       output arguments:
           overlaps    =0 if Body1 and Body2 do not overlap
                       =1 if Body1 and Body2 do     overlap
       usage:
           checks for overlap of Body1 and Body2
       notes:
           leaves the stack unchanged

UDPRIM $$/popupz
       input arguments (specified as name/value pairs):
           xbox       outline of popup (4 doubles)
           ybox       outline of popup (4 doubles)
           height     change in z for popup       [default 1]
       output arguments:
       usage:
           scribes a counterclockwise quad and pops it up
       notes:

UDPRIM $$/spoilerz
       input arguments (specified as name/value pairs):
           xbox       outline of spoiler (4 doubles)
           ybox       outline of spolier (4 doubles)
           depth      depth of cutout
           thick      thickness of spoiler cover
           theta      spoiler deflection (deg)
           overlap    overlap at ends of spoiler
           extend     extension near hinge
       output arguments:
       usage:
           scribe a quad in body and remove material
               to given depth
           scribe quad in body and create spoiler of
               given thickness
           spoiler is larger by overlap on ends defined
               by [4-1] and [2-3]
           spoiler is larger by extend on end defined
               by [1-2]
       notes:
           define (xbox,ybox) counterclockwise
           hinge is between 2nd and 3rd point of (xbox,ybox)

UDPRIM $$/swap
       input arguments (specified as name/value pairs):
       output arguments:
       usage:
           swaps two entities on top of stack
       notes:
           entities may be Bodys of marks
       </pre>

    <p><h3 id="sec5.7">5.7: Number rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Numbers:
    start with a digit or decimal (.)
    followed by zero or more digits and/or decimals (.)
    there can be at most one decimal in a number
    optionally followed by an e, e+, e-, E, E+, or E-
    if there is an e or E, it must be followed by one or more digits
      </pre>
    <p><h3 id="sec5.8">5.8: String rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Strings:
    introduced with a dollar sign ($) that is not part of the value
    followed by one to 128 characters from the set
       letter                     a-z or A-Z
       digit                      0-9
       at-sign                    @
       underscore                 _
       colon                      :
       semicolon                  ;
       dollar-sign                $
       period                     .
       escaped comma              ',
       escaped plus               '+
       minus                      -
       star                       *
       slash                      /
       caret                      ^
       question                   ?
       percent                    %
       open-parenthesis           (
       escaped close-parenthesis  ')
       open-bracket               [
       close-bracket              ]
       open-brace                 {
       close-brace                }
       less-than                  <
       greater-than               >
       equal                      =
    the following characters are not allowed in strings
       apostrophe                 '  (except to escape ', '+ or ') )
       quotation                  "
       hashtag                    #
       backslash                  \
       vertical bar               |
       tilde                      ~
       ampersand                  &
       exclamation                !
      </pre>
      <!-- " -->

    <p><h3 id="sec5.9">5.9: Parameter rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Valid names:
    start with a letter, colon(:), or at-sign(@)
    contains letters, digits, at-signs(@), underscores(_), and colons(:)
    contains fewer than 64 characters
    names that start with an at-sign cannot be set by a CONPMTR, DESPMTR,
       SET, PATBEG, or GETATTR statement
    if a name has a dot-suffix, a property of the name (and not its
        value) is returned
       x.nrow   number of rows     in x or 0 if a string
       x.ncol   number of columns  in x or 0 if a string
       x.size   number of elements in x (=x.nrow*x.ncol) or
                     length of string x
       x.sum    sum of elements    in x
       x.norm   norm of elements   in x (=sqrt(x[1]^2+x[2]^2+...))
       x.min    minimum value      in x
       x.max    maximum value      in x
       x.dot    velocity           of x

Array names:
    basic format is: name[irow,icol] or name[ielem]
    name must follow rules above
    irow, icol, and ielem must be valid expressions
    irow, icol, and ielem start counting at 1
    values are stored across rows ([1,1], [1,2], ..., [2,1], ...)

Types:
    DESPMTR
        declared by a DESPMTR statement only at the top level
        if a scalar, declared and defined by a DESPMTR statement
        if an array, declared by a DIMENSION statement
            values defined by one or more DESPMTR statements
        each value can only be defined in one DESPMTR statement
        values are not over-written by subsequent DESPMTR statements
        can have an optional lower bound
        can have an optional upper bound
        is only available at the top level
        can be set  outside ocsmBuild by a call to ocsmSetValu
        can be read outside ocsmBuild by a call to ocsmGetValu
        can be used to find sensitivities
    CFGPMTR
        declared by a CFGPMTR statement only at the top level
        if a scalar, declared and defined by a CFGPMTR statement
        if an array, declared by a DIMENSION statement
            values defined by one or more CFGPMTR statements
        each value can only be defined in one CFGPMTR statement
        values are not over-written by subsequent CFGPMTR statements
        can have an optional lower bound
        can have an optional upper bound
        is only available at the top level
        can be set  outside ocsmBuild by a call to ocsmSetValu
        can be read outside ocsmBuild by a call to ocsmGetValu
    CONPMTR
        declared by a CONPMTR statement at the top level or
            via ocsmLoadDict
        cannot be declared in a DIMENSION statment
        is available everywhere
        can be set  outside ocsmBuild by a call to ocsmSetValu
        can be read outside ocsmBuild by a call to ocsmGetValu
    OUTPMTR
        declared by a OUTPMTR statement only at the top level
        can only be set at the top level
        can be read outside ocsmBuild by a call to ocsmGetValu
    LOCALVAR
        if a scalar, declared and defined by a SET, PATBEG, or
            GETATTR statement or via an INTERFACE IN statement
        if an array, declared by a DIMENSION statement
            values defined by one or more SET statements
        can have a string value
        values can be overwritten by subsequent statements
        are only available in the .csm or .udc file in which
            it is defined or in an include-type UDC that is
            called by the program unit in which iit was defined
    SOLVER
        is a scalar defined by a SOLBEG statement
        only available between SOLBEG and SOLEND

                                                            L
                                                D  C  C  O  O
                                                E  F  O  U  C
                                                S  G  N  T  A
                                                P  P  P  P  L
                                                M  M  M  M  V
                                                T  T  T  T  A
                                                R  R  R  R  R
                                                -  -  -  -  -
      Can be vector or array of numbers         Y  Y  Y  Y  Y
      Can have a string value                   N  N  N  Y  Y
      Can be restricted by LBOUND or UBOUND     Y  Y  N  N  N
      Scope (T=top-level, G=global, L=local)    T  T  G  L  L
      Defined during ocsmLoad or ocsmLoadDict   Y  Y  Y  N  N
      Can be set via ocsmSetValu(D)             Y  Y  N  N  N
      Defined and set during ocsmBuild          N  N  N  Y  Y
      Can be read via ocsmGetValu(S)            Y  Y  Y  Y  N
      Can find associated sensitivity           Y  N  N  N  N

    @-parameters depend on the last SELECT statement(s).
        each time a new Body is added to the Stack, 'SELECT body' is
            implicitly called
        depending on last SELECT statement, the values of the
             @-parameters are given by:

               body face edge node  <- last SELECT

        @seltype -1    2    1    0   selection type (0=node,1=edge,2=face)
        @selbody  x    -    -    -   current Body
        @sellist -1    x    x    x   list of Nodes/Edges/Faces

        @nbody    x    x    x    x   number of Bodys
        @ibody    x    x    x    x   current   Body
        @nface    x    x    x    x   number of Faces in @ibody
        @iface   -1    x   -1   -1   current   Face  in @ibody (or -2)
        @nedge    x    x    x    x   number of Edges in @ibody
        @iedge   -1   -1    x   -1   current   Edge  in @ibody (or -2)
        @nnode    x    x    x    x   number of Nodes in @ibody
        @inode   -1   -1   -1    x   current   Node  in @ibody (or -2)
        @igroup   x    x    x    x   group of @ibody
        @itype    x    x    x    x   0=NodeBody, 1=WireBody,
                                                 2=SheetBody, 3=SolidBody
        @nbors   -1    x    -    x   number of incident Edges
        @nbors   -1    -    x    -   number of incident Faces

        @ibody1  -1    x    x   -1   1st element of 'Body' Attr in @ibody
        @ibody2  -1    x    x   -1   2nd element of 'Body' Attr in @ibody

        @xmin     x    x    *    x   x-min of bboxes or x at beg of Edge
        @ymin     x    x    *    x   y-min of bboxes or y at beg of Edge
        @zmin     x    x    *    x   z-min of bboxes or z at beg of Edge
        @xmax     x    x    *    x   x-max of bboxes or x at end of Edge
        @ymax     x    x    *    x   y-max of bboxes or y at end of Edge
        @zmax     x    x    *    x   z-max of bboxes or z at end of Edge

        @length   0    0    x    0   length of Edges
        @area     x    x    0    0   area of Faces or surface area of body
        @volume   x    0    0    0   volume of body (if a solid)

        @xcg      x    x    x    x   location of center of gravity
        @ycg      x    x    x    x
        @zcg      x    x    x    x

        @Ixx      x    x    x    0   centroidal moment of inertia
        @Ixy      x    x    x    0
        @Ixz      x    x    x    0
        @Iyx      x    x    x    0
        @Iyy      x    x    x    0
        @Iyz      x    x    x    0
        @Izx      x    x    x    0
        @Izy      x    x    x    0
        @Izz      x    x    x    0

        @toler    x    x    x    0   maximum tolerance (at last SELECT)
        @signal   x    x    x    x   current signal code
        @nwarn    x    x    x    x   number of warnings (at last SELECT)

        @edata                       only set up by EVALUATE statement
        @stack                       Bodys on stack; 0=Mark; -1=none
        @scope                       scoping level (at last SELECT)
        @version                     version number

        in above table:
           x -> value is set
           - -> value is unchanged
           * -> special value is set (if single Edge)
           0 -> value is set to  0
          -1 -> value is set to -1
      </pre>

    <p><h3 id="sec5.10">5.10: Expression rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Valid operators (in order of precedence):
    ( )            parentheses, inner-most evaluated first
    func(a,b)      function arguments, then function itself
    ^              exponentiation             (evaluated left to right)
    * /            multiply and divide        (evaluated left to right)
    + -            add/concat and subtract    (evaluated left to right)

    An expression that consists of only the name of a Parameter my be
    prepended by a unary + or -

Valid function calls:
    pi(x)                        3.14159...*x
    min(x,y)                     minimum of x and y
    max(x,y)                     maximum of x and y
    sqrt(x)                      square root of x
    abs(x)                       absolute value of x
    int(x)                       integer part of x  (3.5 -> 3, -3.5 -> -3)
                                     produces derivative=0
    nint(x)                      nearest integer to x
                                     produces derivative=0
    ceil(x)                      smallest integer not less than x
                                     produces derivative=0
    floor(x)                     largest integer not greater than x
                                     produces derivative=0
    mod(a,b)                     mod(a/b), with same sign as a and b>=0
    sign(test)                   returns -1, 0, or +1
                                     produces derivative=0
    exp(x)                       exponential of x
    log(x)                       natural logarithm of x
    log10(x)                     common logarithm of x
    sin(x)                       sine of x          (in radians)
    sind(x)                      sine of x          (in degrees)
    asin(x)                      arc-sine of x      (in radians)
    asind(x)                     arc-sine of x      (in degrees)
    cos(x)                       cosine of x        (in radians)
    cosd(x)                      cosine of x        (in degrees)
    acos(x)                      arc-cosine of x    (in radians)
    acosd(x)                     arc-cosine of x    (in degrees)
    tan(x)                       tangent of x       (in radians)
    tand(x)                      tangent of x       (in degrees)
    atan(x)                      arc-tangent of x   (in radians)
    atand(x)                     arc-tangent of x   (in degrees)
    atan2(y,x)                   arc-tangent of y/x (in radians)
    atan2d(y,x)                  arc-tangent of y/x (in degrees)
    hypot(x,y)                   hypotenuse: sqrt(x^2+y^2)
    hypot3(x,y,z)                hypotenuse: sqrt(x^2+y^2+z^2)
    incline(xa,ya,dab,xb,yb)     inclination of chord (in degrees)
                                     produces derivative=0
    Xcent(xa,ya,dab,xb,yb)       X-center of circular arc
                                     produces derivative=0
    Ycent(xa,ya,dab,xb,yb)       Y-center of circular arc
                                     produces derivative=0
    Xmidl(xa,ya,dab,xb,yb)       X-point at midpoint of circular arc
                                     produces derivative=0
    Ymidl(xa,ya,dab,xb,yb)       Y-point at midpoint of circular arc
                                     produces derivative=0
    seglen(xa,ya,dab,xb,yb)      length of segment
                                     produces derivative=0
    radius(xa,ya,dab,xb,yb)      radius of curvature (or 0 for LINSEG)
                                     produces derivative=0
    sweep(xa,ya,dab,xb,yb)       sweep angle of circular arc (in degrees)
                                     produces derivative=0
    turnang(xa,ya,dab,xb,yb,...
                     dbc,xc,yc)  turnnig angle at b (in degrees)
                                     produces derivative=0
    dip(xa,ya,xb,yb,rad)         acute dip between arc and chord
                                     produces derivative=0
    smallang(x)                  ensures -180<=x<=180
    val2str(num,digits)          convert num to string ("%d" if digits=0,
                                     "%f" if digits>0, "%e" if digits<0)
    str2val(string)              convert string to value
    findstr(str1,str2)           find locn of str2 in str1 (bias-1 or 0)
    slice(str,ibeg,iend)         substring of str from ibeg to iend
                                     (bias-1)
    path($pwd)                   returns present working directory
    path($csm)                   returns directory of current .csm,
                                     .cpc, or .udc file
    path($root)                  returns $ESP_ROOT
    path($file)                  returns name of .csm, .cpc, or .udc file
    ifzero(test,ifTrue,ifFalse)  if test=0, return ifTrue, else ifFalse
    ifpos(test,ifTrue,ifFalse)   if test>0, return ifTrue, else ifFalse
    ifneg(test,ifTrue,ifFalse)   if test<0, return ifTrue, else ifFalse
    ifmatch(str,pat,ifTrue,...
                      ifFalse)   if str match pat, return ifTrue,
                                     else ifFalse
                                        ? matches any one character
                                       '+ matches one  or more characters
                                        * matches zero or more characters
    ifnan(test,ifTrue,ifFalse)   if test is NaN, return ifTrue,
                                     else ifFalse
      </pre>

    <p><h3 id="sec5.11">5.11: Attribute rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Attributes assigned to Bodys:

    _body       Body index (1:nbody)

    _brch       Branch index (1:nbrch)

    _tParams    tessellation parameters that were used

    _csys_*     arguments when CSYSTEM was defined

    _hist       history for WireBodys only

    <any>       all global Attributes

    <any>       all Attributes associated with Branch that created Body

    <any>       all Attributes associated with "SELECT $body" statement

                Note: if the Attribute name is ".tParams", then its
                      corresponding values are:
                       .tParams[1] = maximum triangle side length
                       .tParams[2] = maximum sag (distance between
                                                  chord and arc)
                       .tParams[3] = maximum angle between edge
                                                  segments (deg)

                Note: if the Attribute name is ".qParams" and it
                      value is any string, then the tessellation
                      templates are not used

                Note: if the Attribute name is ".qParams", then its
                      corresponding values are:
                      .qParams[1] = Edge matching expressed as the
                                    deviation from alignment
                      .qParams[2] = maximum quad side ratio point
                                    count to allow
                      .qParams[3] = number of smoothing iterations

Special User-defined Attributes for Bodys:

    _makeQuads  to make new-style quads on all Faces in Body
                (.tessType is set to "Quad" and .mixed is created)

    _name       string used in ESP interface for a Body

    _stlColor   color to use for all Faces in an .stl file

Attributes assigned to Faces:

    _body       non-unique 2-tuple associated with first Face creation
        [0]     Body index in which Face first existed (1:nbody)
        [1]     face-order associated with creation (see above)

    _brch       non-unique even-numbered list associated with Branches
                   that are active when the Face is created (most
                   recent Branch is listed first)
        [2*i  ] Branch index (1:nbrch)
        [2*i+1] (see below)

                Branches that contribute to brch Attribute are
                   primitive  (for which _brch[2*i+1] is face-order)
                   UDPRIM.udc (for which _brch[2*i+1] is 1)
                   grown      (for which _brch[2*i+1] is face-order)
                   applied    (for which _brch[2*i+1] is face-order)
                   sketch     (for which _brch[2*i+1] is Sketch primitive
                               if making WireBody)
                   PATBEG     (for which _brch[2*i+1] is pattern index)
                   IFTHEN     (for which _brch[2*i+1] is -1)
                   RECALL     (for which _brch[2*i+1] is +1)
                   RESTORE    (for which _brch[2*i+1] is Body numr stored)

    _faceID     unique 3-tuple that is assigned automatically
          [0]   _body[0]
          [1]   _body[1]
          [2]   sequence number

                if multiple Faces have same _faceID[0] and _faceID[1],
                   then the sequence number is defined based upon the
                   first rule that applies:
                   * Face with smaller xcg  has lower sequence number
                   * Face with smaller ycg  has lower sequence number
                   * Face with smaller zcg  has lower sequence number
                   * Face with smaller area has lower sequence number

    _hist       list of Bodys that contained this Face (oldest to newest)

    <any>       all Attributes associated with Branch that first
                    created Face
                    (BOX, CONE, CYLINDER, IMPORT, SPHERE, TORUS, UDPRIM)
                    (BLEND, EXTRUDE, LOFT, REVOLVE, RULE, SWEEP)
                    (SKEND)
                    (CHAMFER, CONNECT, FILLET, HOLLOW)

    <any>       all Attributes associated with Branch if a RESTORE
                    statement

    <any>       all Attributes associated with "SELECT FACE" statement

Special User-defined Attributes for Faces:

    _color      color of front of Face in ESP
                either R,G,B in three 0-1 reals
                or $red, $green, $blue, $yellow, $magenta,
                $cyan, $white, or $black

    _bcolor     color of back of Face in ESP (see _color)

    _gcolor     color of grid of Face in ESP (see _color)

    _makeQuads  to make old-style quads for this Face.  This is only
                available if there is no _makeQuads Attribute on the Body.
                Also, quads made by this option cannot be DUMPed to a
                .egads file.

    _stlColor   color to use for this Face in an .stl file

Attributes assigned to Edges:

    _body       non-unique 2-tuple associated with first Edge creation
        [0]     Body index in which Edge first existed (1:nbody)
        [1]     10000 * min(_body[1][ileft],_body[1][irite])
                      + max(_body[1][ileft],_body[1][irite])
                (or -3 if non-manifold)

    _edgeID     unique 5-tuple that is assigned automatically
          [0]   _faceID[0] of Face 1 (or 0 if non-manifold)
          [1]   _faceID[1] of Face 1 (or 0 if non-manifold)
          [2]   _faceID[0] of Face 2 (or 0 if non-manifold)
          [3]   _faceID[1] of Face 2 (or 0 if non-manifold)
          [4]   sequence number

                _edgeID[0]/[1] swapped with edge[2]/[3]
                   10000*_edgeID[0]+_edgeID[1] > 10000*_edgeID[2]+_edgeID[3]
                if multiple Edges have same _edgeID[0], _edgeID[1],
                   _edgeID[2], and _edgeID[3], then the sequence number
                   is defined based upon the first rule that applies:
                   * Edge with smaller xcg    has lower sequence number
                   * Edge with smaller ycg    has lower sequence number
                   * Edge with smaller zcg    has lower sequence number
                   * Edge with smaller length has lower sequence number

    _nface      number of incident Faces

    <any>       all Attributes associated with "SELECT EDGE" statement

Special User-defined Attributes for Edges:

    _color      color of front of Edge in ESP
                either R,G,B in three 0-1 reals
                or $red, $green, $blue, $yellow, $magenta,
                $cyan, $white, or $black

    _gcolor     color of grid of Edge in ESP (see _color)

Attributes assigned to Nodes:

    _nodeID     unique integer that is assigned automatically

    _nedge      number of incident Edges

    <any>       all Attributes associated with "SELECT FACE" statement

Special User-defined Attributes for Nodes:

    _color      color of Node in ESP
                either R,G,B in three 0-1 reals
                or $red, $green, $blue, $yellow, $magenta,
                $cyan, $white, or $black
      </pre>

    <p>Back to <a href="#sec0">Table of Contents</a>

    <p><h3 id="sec5.12">5.12: Format of plotfile</h3>

    <p>A plotfile is a file that is specified via the
      <code>-plot</code> command line option
      to <code>serveESP</code>.
      The contents of this file is used for either plotting in
      <code>ESP</code> and/or as input for the <code>-histDist</code>
      or <code>-plugs</code> command line options.

      The plotfile contains a series of blocks of data with the
      format:
      <pre>
        imax  jmax  name
      </pre>
      The <code>name</code> is a character string (without white
      spaces) that will be listed in the <code>ESP</code> Display
      list; this name must be unique.  The entity will be colored
      black unless it ends in one of the following sequences:
      <pre>
        |r   red
        |g   green
        |b   blue
        |c   cyan
        |m   magenta
        |y   yellow
        |w   white
      </pre>
      If the name ends in one of the above sequences, the sequence
      will be removed from the name.  The meaning of <code>imax</code>
      and <code>jmax</code> depends on the type of data, as described
      below.

    <h4>Series of points</h4>
    <p>Here <code>imax</code> is the number points
      and <code>jmax</code> must be <code>0</code>.  This is also the
      data block type used by the <code>-histDist</code>
      and <code>-plugs</code> options.  There are <code>imax</code>
      3-D coordinates.

    <h4>Polyline</h4>
    <p>Here <code>imax</code> is the number points in the line
      and <code>jmax</code> must be <code>1</code>.  There are
      <code>imax</code> 3-D coordinates specified.

    <h4>Series of 2-point lines</h4>
    <p>Here <code>imax</code> is the number 2-point lines
      and <code>jmax</code> must be <code>-1</code>.  There are two
      3-D coordinates for each line; that is, there are
      <code>2*imax</code> 3-D coordinates specified.

    <h4>Series of shaded triangles</h4>
    <p>Here <code>imax</code> is the number of triangles
      and <code>jmax</code> must be <code>-3</code>.  There are 12
      numbers for each triangle: x1, y1, z1, f1, x2, y2, z2, f2, z3,
      y3, z3, and f3.  The functions (f) are in the
      range <code>-1</code> (for blue) through <code>+1</code> for
      red.

    <h4>Series of shaded quadrilaterals</h4>
    <p>Here <code>imax</code> is the number of quadrilaterals
      and <code>jmax</code> must be <code>-4</code>.  There are 16
      numbers for each quad: x1, y1, z1, f1, x2, y2, z2, f2, z3, y3,
      z3, f3, x4, y4, z4, and f4.  The points are around the quad.
      The functions (f) are in the range <code>-1</code> (for blue)
      through <code>+1</code> for red.

    <h4>Series of triangles</h4>
    <p>Here <code>imax</code> is the number triangles
      and <code>jmax</code> must be <code>-2</code>.  There are three
      3-D coordinates for each triangle; that is, there are
      <code>3*imax</code> 3-D coordinates specified.

    <h4>Grid of quadrilaterals</h4>
    <p>Here <code>imax</code> is the number i-lines (in the j
      direction) and <code>jmax</code> is the number of j-lines (in
      the i direction).  There are <code>imax*jmax</code> 3-D
      coordinates specified.

    <h4>End of data blocks</h4>
    <p>Here <code>imax</code> and <code>jmax</code> must
      be <code>0</code>.  Use of this block is optional.

    <p>Following the data block header is a series of 3-D coordinates
      specified as <code>x y z</code>.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec6">6.0: Example <code>.csm</code> file</h2>

    <p>The following is a copy of <code>tutorial1.csm</code>
      <!-- extract from tutorial1.csm -->
      <pre>
# tutorial1
# written by John Dannenhoffer

# default design parameters
despmtr   Lbar      6.00      # length of bar
despmtr   Rbar      0.15      # radius of bar
despmtr   T         0.50      # thickness of weights
despmtr   D         2.00      # diameter  of weights
despmtr   Rout      1.20      # outer radius (for intersection)
despmtr   Rfil      0.10      # fillet radius at end of bar

set       L         Lbar/2

# shaft
cylinder  -L        0.0       0.0       +L        0.0       0.0       Rbar
   name      shaft
   attribute shaft     1

# left weight
box       -L-T/2    -D/3      -D        T         D*2/3     2*D
   name      left_weight
   attribute weight    1
union
fillet    Rfil

# rite weight
box       +L-T/2    -D/2      -D/2      T         D         D
   name      rite_weight
   attribute weight    2
union
fillet    Rfil

# clip weights with outer cylinder
cylinder  -L-T      0.00      0.00      +L+T      0.00      0.00      Rout
   attribute clipper   1
intersect

end
      </pre>

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec7">7.0: Frequently Asked Questions (FAQ)</h2>

<!--
    <p>What is the difference between a udp and a udc?

    <p>How do I write a udp?

    <p>How do I write a udc?

    <p>What is the difference between RULE, BLEND, and LOFT?

    <p>What is the difference between UNION and JOIN?

    <p>What do I need to know about tolerances?

    <p>If one of the boolean operations (UNION, SUBTRACT, or
      INTERSECT) fails, what can I do?

    <p>How does solver work and what is it good for?

    <p>What does the SELECT command use for, and how does it interact
      with the @-parameters?

    <p>How can I control the tessellation?

    <p>What are Attributes and how do I set and use them?

    <p>How can I break a spline (in the sketcher) into two splines?
-->

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec8">8.0: Release Notes</h2>

    <p><h3 id="sec8.1"> 8.1: New/extended features in v1.21</h3>

    <p><h4>New/updated commands/statements and functions</h4>

    <p>put note in ESP-help and OpenCSM.h that warns users that
       results from HOLLOW and SWEEP may be unpredicable due to
       OpenCASCADE issues

    <p>add SELECT LOOP to get Edges associated with a Loop in a Face

    <p>extend STORE such that if index=-1, the first available index
       is used

    <p>allow wild-carding (with 0) in SELECT ADD and SELECT SUB

    <p>restrict SPHEREs to have a positive radius

    <p>extend COMBINE to make a non-manifold WireBody for a set of
       contiguous WireBodys

    <p>allow CONPMTR statement if at top-level scope; update scope
       test case

    <p>allow default xaxis=0, yaxis=0, and zaxis=0 in ROTATEX,
       ROTATEY, and ROTATEZ

    <p>allow unary + or - in front of (multi-valued) Parameter when
       used alone in an expression

    <p>index.lt.0 in RESTORE is now a wildcard, meaning that Bodys
       in all storages that match name are put onto the stack

    <p>make INTERFACE DIM obsolete; issue WARNING to use DIMESNION
       statement instead

    <p>do not allow non-manifold WireBodys in RULE, BLEND, LOFT, and
       SWEEP

    <p><h4>New/modified command line arguments</h4>

    <p>change serveCSM to serveESP

    <p>allow serveESP to start with a .py file

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>COMPARE: group bad points based upon the magnitude of the error

    <P>COMPARE: check distances from Nodes and Edges as
       well as distances from Faces

    <p>ELLIPSE: remove upper limit check on NEDGE

    <p>GUIDE: fix bug that did not work properly for an input SheetBody

    <p>GUIDE: change NXSECT argument to ATTRREAL so that finite
       difference sensitivities are triggered

    <p>KULFAN: add NUMPTS argument, which helps avoid small
       dimples near the leading edge of a very thin section

    <p>NACELLE: new UDF

    <p>NUSCALE: fix bug when ZSCALE=0

    <p>NUSCALE: require positive scale factors when applied to
       a SolidBody

    <p>SHADOW: new UDF

    <p>WAFFLE: add IFTHEN/ENDIF construct

    <p><h4>OpenCSM updates</h4>

    <p>add @scope at-parameter; add scope test case

    <p>improve sensitivities associated with tip treatments in
       BLEND

    <p>fix typo in error message associated with COMBINE command

    <p>add documentation about what happens for a 0 in either SELECT
       ADD or SELECT SUB statement

    <p>update documentation for DUMP in OpenCSM.h

    <p>allow DIMENSIONed variable to be returned from a UDC; update
       expressions test case to demonstrate multi-value returns

    <p><h4>ESP updates</h4>

    <p>create CAPS TIM to run the new Integaretd Design Environment (IDE)

    <p>create pyscript TIM to asynchronously run python

    <p>add a context-sensitive python editor

    <p>create viewer TIM to view AIMS and Bounds in CAPS mode

    <p>create plotter TIM to generate (multi-)line plots

    <p>create flowchart TIM to examine AIMs and Bounds

    <p>add Debug option in ESP editor

    <p>update ESP editor so that users without the ball can see the
       edits as they happen

    <p>allow non-*host* to initiate file editting

    <p>modify visualization of grids on Faces in serveESP

    <p>update ESP so that double-clicking in MessageWindow takes you
       to filename:linenum that is clicked on, else takes you to
       last filename:linenum in MessageWindow

    <p>add tufts for Nodes when displaying tessellation
       sesnitivities in serveESP

    <p>only show Display table entries (Node/Edge/Face/Csystem/Pips)
       if it contains any child entities

    <p><h4>Miscellaneous updates</h4>

    <p>add ocsmLoadFromModel function

    <p><h3 id="sec8.2"> 8.2: Bug fixes since v1.20</h3>

    <p><h4>OpenCSM bug fixes</h4>

    <p>fix bug that did not compute sensitivities correctly for UDFs
       when one (or more) of the input Bodys had non-zero velocities

    <p>compute sensitivity correctly with udfCreateBEM,
       udfCreatePoly, udfEditAttr, udfPrintBbox, udfPrintBrep, and
       udoPrintEgo

    <p>fix bug associated with (FD) sensitivities for a MODL with a
       OUTPMTR being set before a FILLET or CHAMFER

    <p>fix bug that did not compute sensitivity correctly when a
       DESPMTR was used in an include-type UDC

    <p>fix bug that did not remove UDP cache entries when a Body was
       deleted (such as during recycling)

    <p>fix bug that re-computed velocities when re-computation was
       not necessary

    <p>fix bug associated with sensitivities of mass properties

    <p> give @version a value before the first Body is built

    <p>improve tessellation sensitivities for Edges and Faces that
       are not trimmed by a boolean operation

    <p>fix tessellation sensitivity bug associated with SheetBodys
       that are INTERSECTed with a SolidBody

    <p>fix Node sensitivity for two parallel Edges

    <p>ensure that tessellation sensitivities on the boundaries of
       Face and ends of Edges agree with Edge and Node
       sensitivities

    <p>for a UDP/UDF, only use finite differences if one of its
       arguements is ATTRREAL and has non-zero dots

    <p>fix bug in ocsmPrintEgo when called on BSPLINE Curve or
       Surface

    <p>improve error message generated when SKVAR does not contain
       triplets

    <p>fix bug in ocsmSave that did not write DIMENSION statements
       correctly when writing either a .csm or .cpc file with a
       variable nrow and/or ncol

    <p>fix bugs in File-Open and File-Edit for cases with and
       without UDCs

    <p>fix bug that did not profile MESSAGE statements

    <p>fix bug that did not print OUTPMTRs during call to
       ocsmPrintPmtrs

    <p>fix sensitivity bug associated with UDP/UDFs that requires
       finite differences coupled with an OUTPMTR that is tied to
       a mass property

    <p>fix bug that did not persist attributes on scribed Edges
       during a boolean operation


    <p><h4>ESP bug fixes</h4>

    <p>fix hint for SCALE in ESP

    <p>shorten hint time-out in ESP to 15 sec

    <p>fix bug if user with ball loaded a new .csm file and then
       editted (where user without ball saw wrong file)

    <p>change display scaling so that if there is only one NodeBody
       it still gets displayed

    <p><h3 id="sec8.3"> 8.3: New/extended features in v1.20</h3>

    <p><h4>New/updated commands/statements and functions</h4>

    <p> extend CONNECT so that it can CONNECT Faces in a single Body
        if there is a Mark before the last SolidBody

    <p>add toler=0 argument to CONNECT command

    <p>extend CONNECT to work with WireBodys

    <p>add Curve, Pcurve, and Surface printouts to ocsmPrintEgo

    <p>extend COMBINE command to close WireBody if needed; add
       combine8* test cases

    <p>add normals to output from EVALUATE FACE command

    <p>when SUBTRACTing co-planar SheetBodys, make sure result has
       same normal as the outer SheetBody; add subtract6j-k test cases

    <p>apply attributes on LINSEG, ARC, CIRARC, BEZIER, SPLINE, and
       SSLOPE Branches to the Edge that they create

    <p><h4>New/modified command line arguments</h4>

    <p>allow -dxdd option to be applied to subscripted DESPMTRs

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>improve speed of udfEditAttr and udpWaffle (on LINUX) when
       script is very long

    <p>fix comments in contains.udc and overlaps.udc

    <p>add theta[] argument to udpEllipse; add ellipse2 test case

    <p>add .tParams attribute to Body too in applyTparams.udc

    <p>in udfSlices, if there is a .tParams attribute on the input
       Body, put it on the slices too

    <p>fix token parsing associated with DOS CR (carriage return) in
       udpWaffle and udfEditAttr

    <p>match slopes and curvatures at seams in UdpSupell when
       slpfact is negative

    <p>improve accuracy of udpFreeform; update associated
       verification data

    <p>add udpParabaloid and test case

    <p><h4>OpenCSM updates</h4>

    <p>improve detection of matching Edges in CONNECT

    <p>allow CATBEG to catch overconstrained and underconstrained
       errors

    <p>generate underconstrained, overconstrained, or not_converged
       signals from SKEND

    <p>improve convergence tolerance in sketcher

    <p>check if a user gave an illegal $order to SUBTRACT

    <p><h4>ESP updates</h4>

    <p>add plotting of normals to DisplayType

    <p><h4>Miscellaneous updates</h4>

    <p><h3 id="sec8.4"> 8.4: Bug fixes since v1.19</h3>

    <p><h4>OpenCSM bug fixes</h4>

    <p>fix memory error associated with reordering senses in loops
       (inletWithWalls1)

    <p>fix seg fault if $order in INTERSECT is given as $xmin (and not
       xmin); check that only valid $order are given; fix test cases
       that used invalid $order

    <p>fix sign of dip to minimize residual for S and R constraints
       in sketcher

    <p>ensure that sweep() function always gives sign that is the
       same as dab

    <p>fix bugs associated with SSLOPE statement (especially when a
       sketch is flipped); add sketch10* test cases

    <p>fix bug that prematurely exits if UDP does not exist and we
       are recycling

    <p>fix bug in mass property derivatives

    <p>fix bug when starting serveESP on Windoze from an .egads, .igs,
       or .stp file for filename with backslashes; add autoStart test
       case

    <p>fix bug associated with -dxdd option (incorrectly wrote .tess
       file instead of .sens file)

    <p>fix memory leak associated when COMBINE closes a WireBody in
       order to make a SheetBody

    <p>fix bug that did not readjust the level when returning from a
       UDC

    <p>fix bug when the last line of a UDC (without an END statement)
       calls a UDC (with an END statement)

    <p>significantly speed up recycling

    <p>fix CONNECT errors associated with non-contiguous Faces; add
       connect7f test case

    <p>preserve orientation of Faces during EXTRACT; add extract4
       test case

    <p>do not include SSLOPE statements when determining if Sketch
       points are co-planar

    <p>change number of reclassified points in Plugs to be the larger
       of 5 and a fraction of area associated with a Face

    <p>fix bug that sometimes uses FD sensitivities when analytic
       derivatives could be used instead (associated with UDPARG
       statements)

    <p>remove inside-out test for SolidBodys to improve performance

    <p>do not add _tParams attribute unless the Body will be
       tessellated; remove coarseBox test case

    <p>fix ocsmGetName prototype in ocsm.py

    <p>fix bug in JOIN associated with Faces that share Edges but
       which have bounding boxes that differ

    <p><h4>ESP bug fixes</h4>

    <p>fix Hint associated with CONNECT command

    <p>broadcast view matrix to partners when cursor leaves canvas
       before mouse up event

    <p>fix long delay when browser without ball syncs display

    <p><h3 id="sec8.5"> 8.5: New/extended features in v1.19</h3>

    <p><h4>New/updated commands/statements and functions</h4>

    <p>BLEND: creates WireBody if all inputs are NodeBodys

    <p>BLEND: if begList and/or endList contains 3 values, it
       specifies the inward tangent vector

    <p>BLEND: new periodic=0 argument

    <p>BOX: can create a NodeBody

    <p>CFGPMTR: value follow same rule as DESPMTR

    <p>CONPMTR: value can be array of numbers

    <p>DIMENSION: (of a DESPMTR or CFGPMTR) can have an expression for
       nrow and/or ncol

    <p>DIMENSION: ignore despmtr=0 argument

    <p>EXTRUDE: creates WireBody if all inputs are NodeBodys

    <p>JOIN: only works if there are common Edges in SheetBodys or
       Faces in SolidBodys

    <p>MESSAGE: new command to print message both to transcript and in
       the ESP MessageWindow

    <p>RESTORE: $name can not be . (dot) to duplicate the Body on top
       of stack

    <p>RULE: can work for two WireBodys with coincident endpoints

    <p>RULE: creates WireBody if all inputs are NodeBodys

    <p>RULE: new periodic=0 argument

    <p>SELECT: allow 0 as wildcard in any or all fields in SELECT EDGE
       ibody1 iford1 ibody2 iford2 iseq=1 statement

    <p>SELECT: allow 0 as wildcard in any or all fields in SELECT FACE
       ibody iford iseq=1 statement

    <p>SELECT: allow any attribute matches in SELECT ADD and SELECT
       SUB

    <p>SET: can copy a whole parameter even if some of the elements
       are undefined

    <p>SOLBEG: semi-colon at end of $varList is not required

    <p>SUBTRACT: if Body2 is a NodeBody, split Edges in Body1 at Body2

    <p>UDPARG: argument names are case-insensitive

    <p>UDPRIM: argument names are case-insensitive

    <p><h4>New/modified command line arguments</h4>

    <p>-allVels to compute velocities for Edges and Nodes as well as
       Faces

    <p>-dxdd to automatically generate a .sens file for the given
       DESPMTR

    <p>-tess to read tessellation and overwrite last Body on stack

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>BEZIER: inline-file does not crate a temporary file

    <p>BICONVEX: remove restriction on camber

    <p>CONTAINS: now leave stack unchanged

    <p>EDITATTR: inline-file does not create a temporary file

    <p>FITCURVE: add split option to

    <p>FITCURVE: inline-file does not crate a temporary file

    <p>FLEND: complete update

    <p>FREEFORM: inline-file does not crate a temporary file

    <p>IMPORT: fix documentation associated when numbodies argument is
       -1 (to return all Bodys in a Group)

    <p>IMPORT: uses tessellation if .egads file contains one or more
       tessellations

    <p>NURBBODY: inline-file does not crate a temporary file

    <p>NUSCALE: new UDF to non-uniformly scale a Body (after
       converting it to all BSPLINES)

    <p>OVERLAPS: now leaves stack unchanged

    <p>PARSEC: new ztail option added

    <p>PRINTEGO: new UDF to print contents of an EGO

    <p>PROP: new UDP top create a propeller

    <p>SLICES: new UDF to create slices of the Body on the top of the
       stack

    <p>SUPELL: new option to get better end-slopes, which is sometimes
       needed for very large n and high apsect ratios

    <p>SWAP: new udc to swap Bodys/Marks on top of stack

    <p>WAFFLE: allow comments to not start in column 1

    <p>WAFFLE: inline-file does not crate a temporary file

    <p><h4>OpenCSM updates</h4>

    <p>add colors.dict, which defines the standard RGB color table, to
       the data directory

    <p>add @version at-parameter

    <p>add @toler to get largest tolerance associated with @sellist

    <p>add Node, Edge, and Face counts every time a Body is created

    <p>allow ocsmUpdateDespmtrs to work with subscripted DESPMTRS and
       CFGPMTRs

    <p>add oscmSaveDespmtrs to save the current DESPMTRs and CFGPMTRs

    <p>extend val2str to use e notation if ndigits is negative

    <p>add ocsmUpdateTess to overwrite a tessellation

    <p>add ocsmRegSizeCB to OpenCSM API to register a callback that
       gets called if the size of a DESPMTR changes

    <p>allow one to retrieve the velocities of the @parameters
       associated with the mass properties

    <p>add ocsmGetTessNpnt and ocsmGetEnt to OpenCSM API

    <p>change function signatures of ocsmPrintAttrs, ocsmPrintBodys,
       ocsmPrintBrchs, ocsmPrintBrep and ocsmPrintPmtrs to use a
       filename instead of a file pointer

    <p>rename ocsmGetEnt to ocsmFindEnt to make its name more
       representative of what it does

    <p>extend ocsmNewBrch to add all the appropriate Branches if a UDC
       is added

    <p>report an error if the child script in udpCsm.c does not leave
       a Body on the stack

    <p>disable recycling if a file edited in ESP editor changes the
       type, name, any arguments, or any attributes on a Branch

    <p>change offset in Edge.iford from 100 to 10000

    <p>increase MAX_NAME_LEN from 32 to 64

    <p>change ocsmGetEgo to return a copy of a Body, Tessellation,
       Face, Edge, or Node

    <p>add ocsmSetBnds to ocsm.def

    <p>add udfPrintEgo to Makefile and NMakefile

    <p>add ocsmMakeEBody to OpenCSM API

    <p>allow color names to be specified in either lowercase or
       UPPERCASE

    <p>add ocsmSetEgo to OpenCSM API, pyOCSM, and test_pyOCSM

    <p>change the name of configuration sensitivities to geometric
       sensitivities

    <p>keep as many values as possible when resizing a Parameter via a
       DIMENSION statement; if after resizing the number of values is
       larger, repeat the last value

    <p>require DESPMTR or CFGPMTR statement before LBOUND or UBOUND is
       specified

    <p>make illegal_pmtr_index a catchable signal

    <p>check for repeated Xsects at beginning and end of RULE and
       BLEND

    <p><h4>ESP updates</h4>

    <p>allow plotting of NodeBodys in StepThru mode

    <p>tell user which block is open when issuing error

    <p>change color of Faces in SheetBodys to a light pink

    <p>in the ESP .csm editor, return to the past location in the file
       when starting editor

    <p>simplify the method for setting design velocities for
       multi-valued DESPMTRs in ESP

    <p>add capability to ESP to show table of OUTPMTR values and
       velocities; add pmtrtest2 test case

    <p>add printout of velocities of OUTPMTRs to serveESPs output

    <p>allow the ESP DisplayFilter to numerically compare values if
       attrValue is numeric

    <p>change message associated with locating to explicitly say that
       the reported value is approximate

    <p>when changing DisplayType to 0 in ESP, do not ask for upper and
       lower limits

    <p>improve ESP MessageWindow messages when there is a problem in a
       UDP/UDF

    <p>first implementation of ErepEd; add ereped* test cases

    <p>add new DisplayType (6) in ESP to visualize EBodys if they
       exist

    <p>allow user to show either configuration or tessellation
       sensitivities in ESP (and make the -tessel flag obsolete in
       serveESP)

    <p>fix bug in flend that caused out-of-bounds error

    <p>first cut at multi-user collaboration in ESP

    <p>add ExpandAll/CollapseAll buttons for DesignParameters,
       LocalVariables, and Branches

    <p>return an error from ESP if despmtr change is illegal (such as
       out of range)

    <p><h4>Miscellaneous updates</h4>

    <p>studentGallery: add A12 and espRacer

    <p>Gloves: add many options

    <p>serveESP: allow plotting of shaded triangles (jmax=-3) and
       quadrilaterals (jmax=-4) in the plotfile in ESP

    <p>pyOCSM: new capability that exactly mimics OpenCSM API

    <p>Plugs: improve cloud point reclassification process; write
       plugs.despmtrs file at end

    <p><h3 id="sec8.6"> 8.6: Bug fixes since v1.18</h3>

    <p><h4>OpenCSM bug fixes</h4>

    <p>Numerous bug fixes associated with sensitivities

    <p>implement simple and Laplace smoothing in createTessVels

    <p>fix message in udpWaffle to list CPOINT as a valid statement
       type

    <p>fix bug that did not clear local Parameters associated with a
       UDC if an error was thrown in a UDC

    <p>fix bug in constraint solver if given Incidence was not between
       -180 and +180

    <p>fix bug in constraint solver if given Angle was not between
       -180 and +180

    <p>allow spaces and tabs before >> for inline files

    <p>fix bug in ocsmSave that wrote DIMENSIONs associated with
       DESPMTRs and CFGPMTRs twice

    <p>fix bug associated with DIMENSIONing a Parameter that had
       previously contained a string value

    <p>fix bug in COMBINE that restricted input SheetBodys to only
       have one Face each

    <p>fix bug associated with EVALUATE EDGERNG and EVALUATE FACERNG

    <p>fix bug that used an undefined variable when returning from an
       include-type UDC

    <p>fix bug that properly reDIMENSIONs DESPMTRs if a CFGPMTR or
       another DESPMTR is changed

    <p>fix error handling when EG_hollowBody fails

    <p>fix bug that sometimes incorrectly set the .ibody or .iford for
       Edges

    <p>fix _edgeID for cases with a BOOLEAN after multiple RESTOREs

    <p>fix bug when SWEEPing a WireBody; update sweep0a verification
       data

    <p>adjust tolerance for detecting colinear points in CIRARC in
       sketcher

    <p>issue error message if problem generating SPLINE with specified
       SSLOPE

    <p>fix bug associated with flipped Sketch containing an SSLOPE
       statement; add sslope5* test cases

    <p>fix bug that improperly colored Edges after call to udfEditAttr

    <p>fix bug associated with Edge attributes when Body was recycled
       via -loadEgads

    <p>signal an error when attempting to EXTRACT a degenerate Edge

    <p>fix bug in JOIN if toMark is set but there is only one Body
       after the mark

    <p>fix bug in ocsmGetTessVels that did not rebuild perturbation
       for cases where a UDPARG contained an argument that could not
       be computed analytically

    <p>fix bug in STORE when overwriting a storage location with a
       GROUP that contains a different number of Bodys; add group6
       test case

    <p><h4>ESP bug fixes</h4>

    <p>fix bug in StepThru mode if configuration started off with a
       Sketch

    <p>fix indentation associated with CATEND in .csm editor

    <p>add a hint for PATBEG in .csm editor

    <p>allow user to edit .csm if it only contains DESPMTR statements

    <p>fix drawing of Axes so that they always extend to the origin

    <p>report errors in ocsmLoad to user and set up GUI so that file
       can be editted

    <p>use Bodys and plotdata to set initial view

    <p>fix bug that caused a iparent=-1 message if a DESPMTR and Body
       had the same name

    <p>fix bug that could give nonsense message in MessageWindow if a
       bad file is read

    <p>fix Edge blue/green coloring

    <p>fix first-column coloring when editing  DesignParameter

    <p><h3 id="sec8.7"> 8.7: New/extended features in v1.18</h3>

    <p><h4>New/updated commands/statements and functions</h4>

    <p>Node, Edges, and Faces can now be SELECTed by bounding boxes

    <p>SUBTRACT can now be applied to coplanar SheetBodys

    <p>SCALE can now scale about a scaling center

    <p>SELECT ADD can now add Faces, Edges, or Nodes by index

    <p>SELECT SUB can now subtract entities by index

    <p>GROUP with a negative argument ungroups

    <p>CONNECT generates degenerate Faces when edgeList* contains
             a zero

    <p>SWEEP can be applied to a FaceBody

    <p>new SSLOPE allows a user to specify the slope at the beginning
       or end of a SPLINE in a sketch

    <p>COMBINE command now returns a SheetBody if the Shell created is
       not closed

    <p>SELECTing via attributes has been extended to have attribute
             values that are strings, integer(s), or real(s)

    <p><h4>New command line arguments</h4>

    <p>-skipTess allows a user to skip the tessellation on the Bodys on
        the stack at the end

    <p>-printStack allows a user to print the contants of the stack
        after every Branch

    <p>-batch is automatically selected when -skipTess is specified

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>applyTparams.udc puts .tParams on Body based upon its size

    <p>calcCG.udc computes the CG of all Bodys on the stack

    <p>udpEllipse is modified to have nedge and thbeg input parameters

    <p>editAttrUdf now allows PATBEG/PATEND statements

    <p><h4>OpenCSM updates</h4>

    <p>update default tessellation parameters

    <p>allow UDFs to receive any number of input Bodys (back to Mark
       or beginning of stack)

    <p>add ocsmUpdateDespmtrs to allow a user to update the DESPMTR
       values from a file

    <p>add __filename__ to files processed by -loadEgads and
       -dumpEgads

    <p>remove tmp_OpenCSM files at beginning of ocsmLoad

    <p>Edges that come from Booleans no longer have the Attributes
       of possibly-coincident Edges in one of the parents

    <p>significatly speed up finishing all Bodys

    <p><h4>ESP updates</h4>

    <p>allow user to add an EVALUATE statement from ESP interface

    <p>add CFGPMTR highlighting and hints in ESP

    <p>unpost File or Tool menu if File, Tool, StepThur, Help,
             UpToDate, or Undo button is pressed

    <p>make groups for at- and at-at-parameters in ESP

    <p>in serveESP -sensTess, show Face tufts in blue and Edge tufts
             in red

    <p>add option to ESP to turn on/off all Nodes, Edges, Faces, or
             Csystems

    <p>allow plotfile to contain triangles (if jmax==-2)

    <p><h3 id="sec8.8"> 8.8: Bug fixes since v1.17</h3>

    <p>throw error if sketch solver does not converge

    <p>allow user to create a SELECT statement in ESP with any
       number of arguments

    <p>fix bug in udfPrintBrep which mistakenly printed info for the
       next-to-last Body on the stack

    <p>fix ESP bug that displayed the wrong file (such as wrong
       .udc) after saving with no changes

    <p>fix algorithm for finding of .ibody and .iford to avoid
       warnings

    <p>fix bug in path(csm) that returns wrong value if .csm file is
       in pwd

    <p>fix bug that did not store at-at-parameters when a Body is
       recycled

    <p>fix memory leaks in udpSew

    <p>disable -loadEgads when the user uses File->Edit

    <p>fix bug associated with Edge attributes

    <p>fix bug that did not ignore degenerate Edges in CONNECT

    <p>fix bug that did not restore csystems in RESTORE command

    <p>do not delete Edge Attributes that are returned from a
       UDP/UDF

    <p>fix ESP bug that stored wrong values for D and W options

    <p>fix bug that does not re-set at-at-paraneters when UDP is
       called from UDC from File->Edit

    <p>fix bug that cause undefined behavior if a .csm file was
       edited in ESP and the new file became much shorter

    <p>fix bug that did not add all Bodys to the stack that were
       recycled in a RESTORE command

    <p>fix bug that sometimes seg faulted when recycling after a
       CATBEG

    <p>fix bug that caused an error when recycling a case with a UDC
       that had a string-valued output paremeter

    <p>fix bug that did not reinitialize the size of INTERNAL and
       OUTPUT Paremeters at the beginning of ocsmBuild

    <p>fix memory leak when EXTRACT detected an error

    <p>never recycle UDPARG statements

    <p>avoid divide by zero while setting up at-parameters if no
       entities are selected

    <p>maintain Edge attributes when IMPORTing .egads file

    <p>fix bug associated with recycling when IMPORT or UDPRIM
       returns multiple Bodys

    <p>fix bug that did not clear Bodys from stack when recycling in
       a JOIN

    <p>remove Mark from stack when a UDPRIM that uses all Bodys to
       the Mark is recycled

    <p>remove STOREage when ocsmBuild starts

    <p>fix memory leak associated with clearing storage at the
       beginning of ocsmBuild

    <p>fix bug when there is a sketch and the user SELECTs a Body
       via attributes

    <p>fix bug that incorrectly identified a Body made by a REVOLVE
       as a Body made by an EXTRUDE

    <p>fix bug that did not sort the @sellist properly when Nodes
       are selected and the sort key is xcg, ycg, or zcg

    <p>fix bug that did not properly process tessellations for
       perturbed Body (for finite differences)

    <p>fix bug that did not skip degenerate Edges in createTessVels

    <p>fix bug that did not close a -jrnl if an error was detected
       while the jrnl was being processed

    <p>fix bug associated with tessellation sensitivities for an
       EXTRUDE, RULE, or BLEND when applied to a planar sketch that
       was scaled

    <p>fix bug that hangs ESP if FileOpen does not work

    <p>fix bug after FileEdit when one of the skteches in a RULE or
       BLEND could not be recycled

    <p><h3 id="sec8.9"> 8.9: New/extended features in v1.17</h3>

    <p><h4>New/updated commands/statements and functions</h4>

    <p>allow 0 to be wildcard in SELECT face ibody1... and SELECT
             edge ibody1...

    <p>check for negative radius in CYLINDER, CONE, and TORUS

    <p>add CFGPMTR statement

    <p>check for non-positive fact in SCALE

    <p>modify EXTRACT command to simultaneously extract several Faces
      (into SheetBody) or Edges (into WireBody)

    <p>change SOLEND to use levenberg-marquardt to improve its
      robustness

    <p>update named errors in CATBEG statement

    <p>extend DUMP to write .plot files

    <p>add path() function to return various path or file names;
      modify expressions.csm to test path() function

    <p>allow DESPMTR, LBOUND, and UBOUND statements in include-type
      UDCs that operate at global scope

    <p>add global=0 argument to GETATTR statement

    <p>allow ATTRIBUTE statement on a SET statement to create a global
      Attribute if no Bodys have been created yet

    <p>document how to allow string variables to be passed into UDCs

    <p>allow string variable returns from UDCs

    <p>allow Edge SELECTion by (x,y,z) of center

    <p>allow COMBINE to inflate single closed WireBody to SheetBody or
      single closed SheetBody to SolidBody

    <p>add edgelist arguments to CONNECT command

    <p>allow CONNECT to connect SheetBodys

    <p>allow CFGPMTR statment in include-type UDC

    <p>return error if nx=ny=nz=0 in MIRROR

    <p>check for valid values for ibeg and iend in slice function

    <p>allow illegal_pmtr_name, illegal_value, and func_out_of_bounds
      errors to be caught when evaluating expressions during ocsmBuild

    <p><h4>New command line arguments</h4>

    <p>autogenerate autoStep.csm input file if user gives filename
      in the form *.stp, *.STP, *.step, or *.STEP

    <p>autogenerate autoIges.csm input file if user gives filename
      in the form *.igs, *.IGS, *.iges, or *.IGES

    <p>autogenerate autoEgads.csm input file if user gives filename
      in the form *.egads, or *.EGADS

    <p>add -checkPara option to check for possible parallelism

    <p>add -plugs argument to run PLUGS

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>change udpPoly to create linear Bsplines instead of calling
      EG_isoCline

    <p>generate @@-parameters for all model attributes in an IMPORTed
      .egads fileq

    <p>change udpNaca so that sensitivities wrt MAXLOC are forced to
      be finite differenced

    <p>change udfEditAttr, udfFreeform, and udpWaffle to recognize
      outLevel

    <p>add udfFlend

    <p>modify udfEditAttr to be able to delete an attribute

    <p><h4>OpenCSM updates</h4>

    <p>add summary CPU information to serveESP

    <p>add geometry info in output produced by ocsmPrintEgo

    <p>add ocsmSetBnds

    <p>return ILLEGAL_VALUE from ocsmSetValu, ocsmSetValuD, or
      ocsmSetBnds if value violates the bounds

    <p>add moments of inertia to -chcckMass option in serveESP

    <p>print message out outLevel=0 when an error is caught

    <p><h4>ESP updates</h4>

    <p>allow multi-segment line plotting in serveESP

    <p><h3 id="sec8.10"> 8.10: Bug fixes since v1.16</h3>

    <p>fix bug that did not allow sensitivity calculations if there
      was a NodeBody on the stack

    <p>fix memory leaks associated with fgets

    <p>restart (rewind) journal file whenever user issues FileNew,
      FileOpen, or FileEdit in ESP

    <p>fix bug that do not allow import of .egads files with long
      Attribute names

    <p>remove mallocs for non-DESPMTRs

    <p>clean up data associated with all Bodys beyond nbody

    <p>fix bug that incorrectly set ichld for an EXTRACT

    <p>fix bug that sometimes listed a filename several times in
      filelist used in File->Edit

    <p>fix bug that allowed only the first 12 files to be editted in
      ESP

    <p>fix bug that created seg fault when modifying a DESPMTR after
      an error is encountered

    <p>fix bug that sometime caused INTERFACE statement to use the
      wrong Parameter index during rebuilds

    <p>fix bug that caused THROW to not raise a signal that ESP knew
      how to handle

    <p>fix memory leak that did not clean up SketchBodys

    <p>fix array bounds error associated with tesselation velocities
     for non-manifold Edges

    <p>clean up memory associated with NULL_BODYs

    <p>clean up memory associated with NULL_BODYs

    <p>fix bug that sometimes printed ego info after SUBTRACT, even
      when outLevel=0

    <p>fix bug in ocsmFree that caused an error for a Body that was
      created and an error occurred in an attached CSYSTEM statement

    <p>add checks to make sure stack does not exceed MAX_STACK_SIZE
      when Branch creates more than one Body

    <p>make SOLEND errors catchable

    <p>fix bug in EXTRACT if some Face or Edge index is out of range

    <p>fix bug associated with at-stack and at-edata in ocsmCopy

    <p>fix slashes for Windoze when reading from ESP_ROOT/udc

    <p>fix memory leak associated with GETATTR statement

    <p>fix typo associated with ALL argument to INTERFACE statement

    <p>fix sensitivities for EXTRUDEs with SCALEd sketches

    <p>fix bug that did not free memory after an error was detected
      during argument evaluations

    <p><h3 id="sec8.11"> 8.11: New/extended features in v1.16</h3>

    <p>add ESP_QuickReference

    <p><h4>New commands/statements</h4>

    <p>allow CSYS info to be returned from GETATTR

    <p>if SELECTing Nodes, Edges, or Faces by attribute, if
      attrValue=*, then match entity that has any type of
      attribute

    <p><h4>New arguments to commands</h4>

    <p>implement SELECT SORT $xmin, $xmax, $xcg, ...,
      $area, $length

    <p>put global Attributes on model when DUMPing

    <p>allow SOLCON to take a string variable as its input

    <p>allow SELECT BODY -n to the select the Body that is the nth
      from the top of the stack

    <p>if SELECT BODY -n points to a Mark, return @selbody=0

    <p><h4>New command line arguments</h4>

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>add udfMatchBodys to find Face, Edge, and Node matches
      between two Bodys

    <p>allow user to match/set numeric attributes in udfEditAttr

    <p><h4>ESP updates</h4>

    <p>make ToolTips text more explicit

    <p>only let t option in ESP toggle the transparency of Faces

    <p>only let o option in ESP toggle the orientation of Edges

    <p>fix bug to clear yellow background whenever a build is successful

    <p>pressing Re-building... should allow user to reset the ESP
      interface

    <p>fix bug so that pressing Constraining... suggests the needed
      constraints in Sketcher

    <p>compute analytic sensisitivities for udpBiconvex

    <p><h3 id="sec8.12"> 8.12: Bug fixes since v1.15</h3>

    <p>fix bug in Sketcher to use atan2d for ::I[]

    <p>fix dbest initialization error in -histDist option to
      serveESP

    <p>add one more level to printouts in ocsmPrintEgo so that
      Nodes get printed when the input is a Model

    <p>fix bug that caused Bodys to not be recycled after File->Edit

    <p>fix memory leak when a UDP or UDF returns multiple Bodys
      (such as in udfMatchBodys)

    <p>fix bug that did not make signals from EVALUATE, GETATTR, and
      SELECT catchable

    <p>fix bug that did not reorder loops properly in RULE and BLEND
      when the sketches had only two Nodes

    <p>fix bug in finding setting sequence numbers associated with
      _edgeID and _faceID

    <p>fix bug that did not list LocalVariables properly if last
      last variable is string valued

    <p>fix bug that did not throw a catchable error when RESTORE
      could not find a matching Body that was STOREd

    <p>fix bug associated with making a copy of the Body that was
             returned from a UDP, which forced finite difference
             sensitivities since the ebodys did not match

    <p>fix bug that caused seg fault when computing sensitivities in
      some cases with UDCs

    <p>fix bug that did not maintain correct velocities after a
      STORE/RESTORE

    <p>fix bug that only allowed str2val to evalaute a string that
      was a number (and not ageneral expression)

    <p>fix bug associated with consecutive multi-Body IMPORTs from
      different files

    <p>fix sensitivity bug for EXTRUDEs in which its sketch has been
      transformed

    <p>fix memory leak in udfMatchBodys

    <p>fix possible infinite loop when assigning sequence numbers
      for _edgeID or _faceID

    <p>fix divide-by-zero bug for sensitivity at C0 Nodes of a BLEND

    <p>improve accuracy of senitivities for RULEs

    <p>fix divide by zero for Edges with C0 end in createTessVels

    <p>fix bug that did not update Local Variables after FILE->Edit in
 `    ESP

    <p><h3 id="sec8.13"> 8.13: New/extended features in v1.15</h3>

    <p><h4>New commands/statements</h4>

    <p>add @signal to keep track of latest signal

    <p>add @nwarn to keep track of number of warnings

    <p><h4>New arguments to commands</h4>

    <p>add listStyle arguments to FILLET and CHAMFER

    <p>allow INTERSECT and SUBTRACT to return multiple Bodys (if
      index=-1)

    <p>update IMPORT and UDPRIM statements so that they can return
      multiple Bodys

    <p>if sigCode=0 or $all in CATBEG, all signals are caught

    <p>modify PROJECT command results so that they lie on the
      analytical Curves/Surfaces and not the tessellation

    <p>allow APPLYCSYS to move Body so that its CSYS is moved to
      origin and aligned with axes

    <p>allow lowercase or UPPERCASE arguments in ARC command

    <p>make optional argument mandatory in EXTRACT command

    <p>allow type argument in SKVAR be either lowercase or UPPERCASE

    <p>add sketch Attributes to ending Face of an EXTRUDE and
      REVOLVE

    <p><h4>New command line arguments</h4>

    <p>add -histDist flag to serveESP

    <p>allow -addVerify and -verify to use verification files that
      depend on the version of OpenCASCADE being used

    <p>add -checkMass flag to serveESP

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>fix bugs in gen_rot associated with z-aligned rotations

    <p>add udfCatmull and catmull test cases

    <p>update udpImport to cache previous read in case we ask to
      reread the file

    <p>update udpImport so that it can return all Bodys

    <p>add udpPoly and poly3 and poly4 test cases

    <p>when OFFSET>0 in udpNaca, extend the airfoil surfaces by
      OFFSET

    <p><h4>ESP updates</h4>

    <p>be able to toggle plotting of control points in ESP

    <p>add distance between last two at-keypresses in message printed
      in ESP

    <p>fix parent/child indications in TreeWindow in ESP

    <p>if .csm file calls a UDC, do not automatically rebuild after
      editing .csm or .udc file - activate the Re-build button instead

    <p>allow sketcher to be launched from within editPmtr or from
      button on top of Tree window

    <p>in StepThru mode, keypress f (lowercase F) goes to first step
      and keypress l (lowercase L) goes to last step

    <p>post help message when entering StepThru mode

    <p>fix bug that did not let the visibility of Csystems be
      changed in ESP

    <p>modify DisplayFilter in ESP so that if Body has a matching
      attribute, all its constituents are shown

    <p>rename File->Save button to ExportFeatureTree and emphasize,
      in confirmation dialog, that previous file formatting
      will be lost

    <p>rename editCSM->OK button to Save and remove confirmation
      dialog

    <p>fix bug that could have incorrectly added file to the
      filelist, which would cause user to not be able to edit
      all UDCs in ESP

    <p>report filename and line number when an error is detected

    <p>add active line highlighting to csm file editor

    <p>double-clicking in MessageWindow open up csm file editor at
      line that contained last error

    <p>fix erroneous messages that got reported in MessageWindow
      when a problem was encountered during a load/check/build

    <p>make , a synonym for Ctrl-&lt; (read view from file) and . a
      synonym for Ctrl-&gt; (save view to file) in ESP

    <p>use save.view as default filename in read view from file and
      save view to file

    <p>fix out-of-date message when ESP starts without a file or
      after File->New

    <p>instead of posting an alert when a load/check/build error
      occurs, turn the MessageWindow light yellow (to draw
      user's attentiom)

    <p>raise signals during ocsmLoad and ocsmCheck (to aid in
      debugging)

    <p>allow StepThru mode to show WireBodys

    <p><h3 id="sec8.14"> 8.14: Bug fixes since v1.14</h3>

    <p>fix erroneous error message ass≈oociated with UNION of
      SheetBodys or WireBodys with the tomark flag

    <p>remove memory leak associated with UDFs forgetting to remove
      tessellation objects

    <p>set imax and jmax outputs from udpBezier when creating WireBody

    <p>fix some memory leaks in sensCSM

    <p>fix misspelling of CHAMFER in ocsmLoad

    <p>fix a few typos in chamfer-related error messages

    <p>fix typo in description of ATTRIBUTE statement

    <p>move stack checking from ocsmCheck to ocsmBuild

    <p>check for existence of UDPs, UDFs, and UDCs during ocsmBuild
      and not during ocsmCheck

    <p>improve Branch status indications in ocsmPrintBrchs

    <p>move ocsmPrinBrchs to after ocsmBuild in serveESP

    <p>fix writing of NodeBody info during -dumpEgads

    <p>fix bug in at-paramaters associated with NodeBodys

    <p>fix bug that wrote nedge=1 for NodeBodys during -addVerify

    <p>check that DESPMTR, UBOUND, and LBOUND statements only
      contains proper numbers

    <p>treat tabs as spaces in OpenCSM, udpEditAttr, and udpWaffle

    <p>fix bug that only colorized first Face after SELECT FACE

    <p>fix bug that only colorized first Edge after SELECT EDGE

    <p>close .csm file if an error occurs during read

    <p>allow recycling for CONNECT command

    <p>fix bug that did not allow a NODE_BODY to be returned from a
      UDP or UDF

    <p>fix bug associated with statically allocated arrays in CONNECT
      command

    <p>fix bug associated with uppercase OR in IFTHEN and ELSEIF
      statements

    <p>fix bug that did not clear IFTHEN statement from pattern-stack
      while executing CATBEG (which causes an erroneous
      NESTED_TOO_DEEPLY error)

    <p>do not allow search for CATBEG to enter a UDC or another
      block of code

    <p>fix bug associated with errors thrown within a UDC

    <p>fix bug that caused seg faults when UNION errors occurred

    <p>fix bug that caused DUMP to fail if an OUTPMTR is a string

    <p>fix bug that caused error if SELECTing a Body by Attribute in
      cases with a UDPARG statement

    <p>fix bug that did not propagate sensitivity info correctly
      into a UDC in all cases

    <p>use analytic sensitivities if produced by UDP/UDFs

    <p>change default finite difference dtime to 1e-6

    <p>fix bug associated with velocities from EXTRUDEs

    <p>remove incorrect error-checking code during input for CIRARC
      command

    <p>fix bug that did not properly check the number of arguments
      to the IFTHEN and ELSEIF commands

    <p>fix bug that improerly check for XOR operators in IFTHEN and
      ELSEIF commands

    <p>fix bug associated with JOINing WireBodys

    <p>fix velocities for BOX command that produces a SheetBody

    <p>fix sensitivity bug associated with UDPARG/UDPRIM arguments

    <p>for Edges that are supported by only one Face, set the Edge
      velocity to the Face velocity

    <p>remove analytic computation of sensitivities from
      udpBiconvex, udpKulfan, and udpParsec

    <p>fix sensitivity from udpBox, udpEllipse, udpNaca, and
      udpSupell

    <p>fix sensitivity bug associated with lines that are EXTRUDEd

    <p>fix sensitivity bug associated with scaled planar Surfaces

    <p>force finite difference sensitivities for RESTORE command

    <p>fix typos associated with LINT in Makefile.DARWIN64

    <p><h3 id="sec8.15"> 8.15: New/extended features in v1.14</h3>

    <p><h4>New commands/statements</h4>

    <p>Allow SET and PATBEG statements within SKBEG/SKEND

    <p>Allow $beg or $end as t in EVALUATE EDGE statement

    <p>If $name is . (period) in STORE, then Body is popped off stack
       and nothing is stored

    <p>Allow BOX to create an axis-aligned WireBody

    <p>Make INTERSECT operation commutative

    <p>Allow INTERSECTion of SolidBody and WireBody

    <p>Allow attribute name to be an implicit string

    <p>Allow SELECT to select node by (x,y,z)

    <p>Add @nbors at-parameter

    <p>Propagate Edge Attributes to Faces during EXTRUDE and REVOLVE

    <p>Add _despmtr_ and _outpmtr_ Attributes to Model during DUMP

    <p>Lazily evaluate arguments left-to-right in IFTHEN and ELSEIF
       statements

    <p>Add OUTPMTR statement

    <p>Add _bcolor and _gcolor Attribites to Faces to color backside
       and grid

    <p>Add _gcolor Attribute to Edges to color grid points

    <p><h4>New arguments to commands</h4>

    <p>In INTERFACE statement, change default to default=0

    <p>Implement INTERFACE . ALL for include-like UDC (which does not
       create a new scope)

    <p>Allow lowercase or UPPERCASE arguments in INTERFACE statement

    <p>Add toMark argument to JOIN for WireBodys and SheetBodys

    <p>Improve STORE to (..) remove Bodys to Mark or (...) all Bodys
       from stack

    <p>Add edgerng and facerng to EVALUATE command

    <p><h4>New command line arguments</h4>

    <p>Add -skipBuild command line option to serveESP

    <p>Add -onormal command line option

    <p>Remove -printBbox command line argument from serveESP

    <p>Remove -printBrep command line argument from serveESP

    <p>Remove -checkMass command line option from serveESP

    <p>Add -plotBDF flag to serveESP so that contents of BDF file can
             be visualized

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>udpWaffle: upgrade file format; fix nested PATBEG

    <p>udfPrintBbox: new UDF to replace serveESP's -printBbox command
        line argument

    <p>udfPrintBrep: new UDF to replace serveESP/s -printBrep command

    <p>udpSupell: add offset argument

    <p>udpNaca: add offset argument


    <p>udfDroop: new UDF to modify airfoil leading- or trailing- edges

    <p>udfCreateBEM: allow Nodes, Edges, and/or Faces to be ignored

    <p>udfEditAttr: add verbose argument; skip statements when
       nothing is selected; update error numbers returned; allow
       attrName or attrValu to be an expression if it starts with an
       exclamation point; add ANDNOT keyword

    <p>udfStiffener: new UDF to create stiffener and given location
       on Face

    <p>udpFitcurve: added optional xform argument

    <p><h4>ESP updates</h4>

    <p>Move Cancel and OK buttons to top of frames when editing
       Branch, Attribute, or Design Parameter

    <p>When multiple Bodys have the same name, produce a warning that
       latter ones will be referred to as Body X

    <p>Add ability to edit .udc files from within ESP (incl .udc
       files added to .csm file via the editor)

    <p>Allow question mark in DisplayFilter in ESP to list all
       possibilities

    <p>When MODL in iterface and .csm files are inconsistent, warn
       user about inconsistency instead of refusing to File-Edit the
       .csm file

    <p>Allow visibility of NodeBodys to be toggled in ESP

    <p><h3 id="sec8.16"> 8.16: Bug fixes since v1.13</h3>

    <p>Fix error statement associated with mis-matched argument in
       call to UDC

    <p>Fix bug that caused Body_xxxxxx.egads to be loaded many times
       when -loadEgads flag is set

    <p>Fix bug that caused name_not_found if an empty file

    <p>Fix typo for highlighting CONNECT in code editor

    <p>Fix bug associated with putting Attributes on NodeBodys

    <p>Fix indexing error for row-wise Parameters in ocsmSetVel(D)

    <p>Fix infinte loop identified in store2.csm (for -outLevel 0)

    <p>Fix bug that causes Node attribute to not persist properly

    <p>Fix bug that gets wrong value for at-parameters in ATTRIBUTE
       statements (caused by attributes being assigned before
       at-parameters were computed)

    <p>Fix bug where pointers were not NULLed when a Parameter or
       Branch was deleted

    <p>Improve speed of process for setting sequence numbers in
       finishBody

    <p>Fix bug that printed error messages when visualizing
       NodeBodys

    <p>Fix memory leaks associated with lazy evaluations of IFTHEN
       and ELSEIF statements

    <p>Fix bug in assignment of sequence numbers for _faceID and
       _edgeID attributes

    <p>Fix bug in plotting NodeBodys in ESP

    <p>Apply FILLET or CHAMFER to all Edges if parent is RESTORE

    <p>Fix bug that occasionally crashed after using File-Edit on
        .csm file

    <p>Fix bug that did not properly update selbody when Body loaded
       via -loadEgads flag

    <p>Fix bug that errored for -loadEgads and -dumpEgads flags for
       cases with UNION toMark=1

    <p>Fix error that did not display Variables correctly in ESP if
       any Variable was string-valued

    <p>Fix bug that did not re-initialize size of local variables
       when rebuilding (such as when computing sensitivities)

    <p>Fix bug that does not allow a string value to be set for a
       local variables that previously held an array (modify
       expressions.csm to test)

    <p>Fix bug that does not allow one to set a single number to a
       local variable that previously held a string

    <p>Fdd tests to expressions.csm to test conversions to/from
       strings and to/from vectors

    <p>Fix bug that does not allow $pmtrName to be an implicit string
       in SET statement (modify implicitStrings.csm to test)

    <p>Fonvert left-over variables to scalars instead of deleting
       them at start of ocsmBuild

    <p>Fix bug that did not allow editing of .csm file after saving a
       view file

    <p>Fix bug that caused loadEgads/dumpEgads to not work after
       udpEditAttr

    <p>Fix bug associated with degenerate Edges in udfCreateBEM

    <p>Fix bug that caused loadEgads/dumpEgads to not work with
       returned values from UDPs and UDFs

    <p>Fix bug that caused loadEgads/dumpEgads to not work with
       Groups

    <p>Fix bug that casued -dumpEgads to not work with booleans that
       required loosening of tolerances

    <p>Fix memory leak in unionAll

    <p>Fix -loadEgads/-dumpEgads associated with Sketches

    <p>Fix undefined variable when using the BOX command to make a
       WireBody

    <p>Femove Math.floor in sketcher so that sketches with very small
       dimensions do not cause errors

    <p>Fix bug that ESP does not does not properly work when
       ComputeSensitivity or SetDesignVelocity is pressed for a
       Design Parameter whose name includes a colon

    <p>Fix bug that does not allow a user to add a Design Parameter
       with a colon from the ESP GUI

    <p>Fix uninitialized varaible when ocsmSetVelD is called with all
       zero arguments

    <p>Handle reading of DOS-encoded .csm files correctly t18 fix bug
       that did not recycle EXTRACTs properly

    <p>Report a warning (possible memory leak) if newBody() is called
       but the Body already exists

    <p>Fix bug when recycling cases with UDPARG statements

    <p>Fix Face and Edge coloring bugs in ESP

    <p>Fix bug that truncated last line in File-Edit if the line did
       not end with a CR

    <p>Fix bug that caused seg fault if edit window was cleared in
       File-Edit

    <p>Fix bug that could leave a .csm file open if a failure occurred
       during ocsmSave

    <p>Fix bug that truncated long filenames in ESP Edit-File

    <p><h3 id="sec8.17"> 8.17: New/extended features in v1.13</h3>

    <p><h4>New commands/statements</h4>

    <p>JOIN can be used to join WireBodys

    <p>EVALUATE can be used to evaluate coordinates at a Node or on an
       Edge or Face

    <p>REVOLVE can now be applies to WireBodys

    <p>FaceOrders are now consistent between EXTRUDE, REVOLVE, RULE,
       and BLEND from a WireBody

    <p><h4>New arguments to commands</h4>

    <p>toler=0 argument was added to COMBINE

    <p><h4>New command line arguments</h4>

    <p>-- is ignored as a command line argument

    <p>-printBboxs option was added to print bounding boxes for all
       Nodes, Edges, and Faces associated with Bodys on the stack

    <p>-checkMass option enables a check for the mass properties
       computed internally with those computed via surface integrals

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>A simple turbomachinery airfoil generator (STAG) UDP was added

    <p>A UDF for tiling was added

    <p>The editAttr UDF can now gets its specification from a file

    <p>A new csm UDP allows recursive calls to <code>OpenCSM</code>

    <p>The hex UDP was added to create general hexahedra

    <p>The radwaf UDP was added to create radial waffles (for fuselage
       structures)

    <p>The nocrod argument was added to createBEM

    <p>The nquad argument was added to supell

    <p>The waffle UDP was modified to accept input from a file

    <p><h4>ESP updates</h4>

    <p>The .csm file editor now is context-sensitive and has many new
       features

    <p>The Branch assiociated with the Body being shown when in
       StepThru mode is highlighted

    <p>An _nface Attribute is added to all Edges

    <p>_nodeID and _nedge Attributes are added to all Nodes

    <p>New-style quadding is used if _makeQuads Attribute is put on
       Body

    <p>Add FJ2 to data/gallery

    <p>The @itype at-parameter was added to tell type of Body

    <p>When in StepThru mode, the "n" and "p" keys can be used for
       next and previous.

    <p>Node attributes are now persistent through rebuilds

    <p>Node Attributes can now be examined/set via ESP

    <p>Use ! character to convert implicit strings (such as $primtype
       in UDPARG and UDPRIM statements) into expressions

    <p>String-valued expressions can now be passed into UDC

    <p>Edges that come from a scribe (SUBTRACT) operation are now
       marked with the Face that made it

    <p>In ESP, provide shortcuts -- 2 for @, 6 for ^, and 8 for *

    <p>Design Parameters are now listed hierarchically in ESP (with
       the hierarcy defined by a colon (:)

    <p><h3 id="sec8.18"> 8.18: Bug fixes since v1.12</h3>

    <p>Fix bug that caused infinite recursion if trying to generate a
       .sens file for a case that required finite difference
       sensitivities

    <p>A bug associated with REORDER applied to planar Faces was fixed

    <p>A bug associated with extracting non-existant Edges or Faces
       was fixed

    <p>Issue WARNING if dumping .sens file and tomark argument is set

    <p>Fix @length calculation for WireBodys

    <p>Fix bug that did not properly set @itype for NodeBodys

    <p>Fix error associated with testing for equality in naca456

    <p>Fix bug that caused divide by zero if abs(dab)==L/2 or
       abs(dbc)==L/2 in turnang fuction

    <p>Fix bug that caused divide by zero in ocsmGetVel when TdotT was
       zero

    <p>Fix header in binary stl writer

    <p>Fix bug that did not reload dictionary after File->New,
       File->Open, and File->Edit->OK

    <p>Fix bug that did not allow UDC name in form /name (from current
       directory)

    <p>Fixed bug that did not set up At-parameters for sketches

    <p>An error is raised if an INTERFACE statement uses name of a
       CONPMTR

    <p><h3 id="sec8.19"> 8.19: New/extended features in v1.12</h3>

    <p><h4>New commands/statements</h4>

    <p>Update list of characters allowed in strings

    <p>Update parser to allow expressions of the forms: 1+2, $1+2,
       1+$2, $1+$2, and ifMatch($abc, $*c, 0, 1)

    <p>Make concatenation of string and number produce different
       results depending on whether number is a whole integer

    <p><h4>New arguments to commands</h4>

    <p>String expressions are now evaluated in ATTRIBUTE statements

    <p>Rounded tip treatment in BLEND statement is now documented

    <p>BOX command can now generate a SheetBody if one of the sizes is
       zero

    <p>CONNECT has been extended to work for Faces that have other
       than 4 Edges

    <p>DIMENSION statement can now re-dimension a local variable

    <p>DUMP command can now write binary stl files (.bstl)

    <p>DUMP statement can now dump .sens (sensitivity) files

    <p>New toMark argument to DUMP command allows writing multi-body
       .stl and .bstl files.

    <p>Added a catchable signal to FILLET and CHAMFER when an error
       is returned from EGADS

    <p>Add optional argument to GROUP statement to tell how many Bodys
       to group (instead of back to the mark)

    <p>Extend HOLLOW so that it can be applied to a FaceBody

    <p>Add radius argument to HOLLOW for SheetBodys

    <p>Change arguments to HOLLOW to allow both old and new styles
       for entList

    <p>JOIN has been extended to SheetBodys

    <p>Allow uppercase BODY, FACE, EDGE, or NODE as first argument to
       SELECT statement

    <p>SELECT FACE, SELECT EDGE, or SELECT NODE now select all Faces,
       Edges, or Nodes in the selected Body

    <p>Implement multi-valued SELECT lists (@sellist)

    <p>Return mass properties for entire @sellist in at-parameters

    <p>Implement SELECT ADD and SELECT SUB to adjust the @sellist

    <p>Allow name[i] in first argument of SET statement

    <p>UDPARG now allows inline files and relative file references (as
       was previously only allowed on the UDPRIM statement)

    <p><h4>New command line arguments</h4>

    <p>-dumpEgads added to write Body_xxxxxx.egads files every time a
       Body is created

    <p>-loadEgads added to read Body_xxxxxx.egads file instead of
       actually creating a new Body (useful for debugging when used in
       combination with -dumpEgads flag).

    <p>-sensTess now displays tufts on display when a sensitivity is
       being displayed

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>Sense of airfoils generated by udpBiconvex is now consistent
       with other airfoil generators

    <p>udfCreateBEM has been updated to write PSHELL and MAT1 cards

    <p>udpTblade now generates SolidBodys, with hub and tip being
       bodies of revolution.

    <p>New inputs have been added to udpTblade

    <p>Modify udpTblade to put all temporary files into ./Tblade_temp

    <p><h4>ESP updates</h4>

    <p>Toggle (v)isibility, (g)rid, (t)ransparency, or (o)rientation
        via key presses

    <p>DisplayFilter allows user to filter display based upon
       Attribute name/value pairs

    <p>Colored contours are now generated on the back of Faces

    <p>A StepThru feature was added to show the build process

    <p>Recycling is used (if possible) after FileEdit

    <p><h3 id="sec8.20"> 8.20: Bug fixes since v1.11</h3>

    <p>Fix many bugs in udpTblade and Tblade itself

    <p>Bug associated with subtracting SheetBody from SolidBody has
       been fixed.

    <p>Change udpNACA to be more reliable when finding leading and
       trailing edges

    <p>Fix big in the way results from SET statement are reported

    <p>Fix bug in slice() function

    <p>Fix bug related to persistence of Attributes when two separate
       Edges have similar edge_IDs

    <p>Skip evaluation on degenerate Edges when computing Node
       sensitivity

    <p>Fix GROUP bug during rebuilds with recycled Bodys

    <p>Fix bug in REORDER command for SheetBodys

    <p>Fix sensitivity bug in udpNaca

    <p>Fix bug associated with UNDO

    <p>Fix bug in computing sensitivities when feature splits (via
       RESTORE) and rejoins (via a Boolean)

    <p>Fix bug that did not remove objects from screen after
       deleting all Branches

    <p>Fixed bug that caused ESP to remain in re-building mode if a
       type is added to a .csm file when using FileEdit

    <p>fixed bug that did not clear scene graph (and occasionally seg
       faulted) after an error encountered during loading a .csm file
       (after FileOpen or FileEdit)

    <p><h3 id="sec8.21"> 8.21: New/extended features in v1.11</h3>

    <p><h4>New commands/statements</h4>

    <p>_name Attribute is now documented

    <p>Line numbers are now listed during ocsmLoad

    <p>Strings can be concatenated with + operator

    <p>Overload .size dot-suffix to return length of string

    <p>Add val2str(), str2val(), findstr() and slice() functions

    <p>Special Attribute name was changed from color to _color and
       acceptable values were documented

    <p><h4>New arguments to commands</h4>

    <p>BLEND now has optional oneFace argument to keep strips as one
       Face when fit is only C0

    <p>ELSEIF can take UPPERCASE or lowercase arguments

    <p>EXTRUDE can now be applied to Faces with holes

    <p>GETATTR statement has been added

    <p>RESTORE statement applies it Attributes to the Body and all
       Faces

    <p>SUBTRACT can subtract a SolidBody from a SheetBody

    <p>UDPRIM uses $$/ prefix to mean to get UDC from ESP_ROOT/udc

    <p><h4>New command line arguments</h4>

    <p>-plot allows over-plotting of points, lines, or grids from a
        file.

    <p>-ptrb flag causes perturbation file to be written

    <p>-sensTess allow tessellation sensitivities to be computed
        (instead of geometric sensitivities)

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>Add udfEditAttr to edit Attributes

    <p>Add udpFitcurve to generate fits

    <p>Add maxloc argument to udpNaca

    <p><h4>ESP updates</h4>

    <p>Color non-manifold Edges (nface.gt.2) orange

    <p>Color non-manifold Edges (nface.lt.2) brown

    <p>DisplayType allow user to plot normalized parametric
       coordinates (u,v) or curvatures

    <p>Adjust text height in buttons so that they take up less space
       and are less likely to overflow available space in ESP

    <p>Allow creation of Attribute (via A option)

    <p>Add ability to save view to and read view from a file

    <p><h3 id="sec8.22"> 8.22: Bug fixes since v1.010</h3>

    <p>Add printing of Node Attributes in ocsmPrintBrep

    <p>Fix bug to allow EQ (as well as eq) in IFTHEN statement

    <p>Fix bug if .cpc file contains a UDC that calls another UDC

    <p>Fix bug when adding verification info to .csm that has END
       (rather than end) statement

    <p>Fix bug when Tree Window is not correct for NodeBodys created
       by SKBEG/SKEND statements (attribute2)

    <p>Fix bug when Tree Window is not correct for NodeBodys created
       by POINT statement (attribute2)

    <p>Fix bug that caused no attributes on NodeBodys created by
       POINT statement (attribute2)

    <p>Change tolerance associated with PROJECT statement

    <p>Fix bug in serevCSM that erroneously tried to visualize Faces
       that have not triangles

    <p>Fix bug that causes ocsmLoad to prematurely exit when UDC's
       last statement is not END and does not have a terminal CR/LF;
       update udcBox.udc to test this

    <p>Fix oscmSave bug when saving model that contains an inline file

    <p>Fix stack overflow error associated with expression parsing

    <p>Fix bug in udpNaca for sensitivity at trailing edges if
       sharpte=1

    <p>Fix bug when specifying partially-non-orthogonal CSYSTEMs

    <p>Return error when either direction in CSYSTEM has zero length

    <p>Fix bug to allow HOLLOW after SKEND

    <p><h3 id="sec8.23"> 8.23: New/extended features in v1.10</h3>

    <p><h4>New commands/statements</h4>

    <p>none

    <p><h4>New arguments to commands</h4>

    <p>The IFTHEN and ELSEIF statements now allow $op2 to be xor

    <p>The IFTHEN and ELSEIF statements allow $op1, $op2, and $op3 to
      be either lowercase or UPPERCASE

    <p><h4>New command line arguments</h4>

    <p>none

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>none

    <p><h4>ESP updates</h4>

    <p>The Sketcher now makes suggestion for constraints to be deleted
      or added in order to be properly constrained

    <p>Show connections between Parameters and Branches in Tree window

    <p>Enable zooming in and out with "+" or "-" in Graphics window

    <p>Allow "+", "-", "PgUp", and "PgDn" to zoom-in and -out in
      Sketcher

    <p>Add _tParams attributes to Bodys to store tessellation
      parameters

    <p>Create File popup menu that allows user to
      <ul>
        <li>New: start a new Model</li>
        <li>Open: read a .csm file and create a new Model</li>
        <li>Save: save a .csm file</li>
        <li>Edit: edit current .csm file</li>
        </ul>

    <p>Add ::I[] (inclination), ::R[] (radius), and ::S[] (sweep)
      shorthands in SKCON statements

    <p>Check for self-intersecting Sketches

    <p>A Body can be named in the Tree window via its _name attribute

    <p>Add ESP logo to browser tag

    <p><h4>Miscellaneous updates</h4>

    <p>Add gallery of cases to ESP-help

    <p><h3 id="sec8.24"> 8.24: Bug fixes since v1.09</h3>

    <p>Fix code when bad expression is detected to not seg fault

    <p>Save file now correctly writes IFTHEN statements

    <p>Distinguish between illegal_pmtr_name and
      func_arg_out_of_bounds in thrown errors

    <p>Many small documentation fixes

    <p>Fix deleteParemater so that is works for newly added Parameters

    <p>Fix arrowhead size in CSYSTEMs

    <p><h3 id="sec8.25"> 8.25: New/extended features in v1.09</h3>

    <p><h4>New commands/statements</h4>

    <p>CONPMTR to define a constant Parameter

    <p>POINT for generating a Node (with its derivatives)

    <p>GROUP for grouping Bodys for STORE, DUMP, and transformations;
      add associated @igroup at-Parameter

    <p>IFTHEN, ELSEIF, ELSE, and ENDIF to conditionally control
      execution of Branches

    <p>THROW, CATBEG, and CATEND to handle errors; also have
      statements throw errors that could be caught

    <p>CSYSTEM and APPLYCSYS to generate and use coordinate systems

    <p><h4>New arguments to commands</h4>

    <p>Allow C1 or C0 continuity in BLEND command by duplicated
      sketeches; add oneFace=0 argument to BLEND

    <p>Add ability to created rounded tips in BLEND command

    <p>Add toler=0 and verify=0 arguments to ASSERT command

    <p>Extend DUMP command to write .stl, .ugrid, .tess and .egg files

    <p>Add toMark=0 argument to DUMP command

    <p>Add useEdges=0 argument to PROJECT command

    <p>Extend SELECT statement to allow a user to apply attributes to
      all Edges or Faces

    <p><h4>New command line arguments</h4>

    <p>--version flag to return version

    <p>-verify and -addVerify flags for verification execution and
      setup

    <p>-egg to suppport external grid generator

    <p>-dict to support dictionary of constant Parameters

    <p>-sensTess to choose between geometric and tessellation
      sensitivities

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>udfCreateBEM to create a BEM and associated file

    <p>udfCreatePoly to write a .poly file

    <p>udpPod to generate a pod (like in VSP)

    <p>udpSample to act as a sample for new user-defined primitives

    <p>Add sharpte argument to udpNaca

    <p>Add sensitivities to udpParsec

    <p>Add attributes to Faces in udpWaffle

    <p><h4>ESP updates</h4>

    <p>Configuration can be colored in Graphics Window if Face has
      "color" attribute

    <p>Post messages in Message Window when ESP is started without a
      .csm file

    <p>Add tooltips to ESP

    <p>Clicking on Body name in Tree Window posts the Body's
      attributes

    <p>Allow complete rebuild (without recycling) in ESP by pressing
      "Up to date"

    <p>Add axis labels to axes in lower-left corner of Graphics Window

    <p>Add (optional) light-grey axes centered at origin

    <p>Allow user to expand/collapse Branch list in ESP

    <p>Add "Show Attributes/Csystem" button in ESP

    <p>Do not allow statements within a UDC to be edited in ESP

    <p>Reorganize and update ESP-help

    <p><h4>Miscellaneous updates</h4>

    <p>Print mass properties (in serveESP) for all Bodys on stack

    <p>Quadrilaterals are generated (and visualized) if a Face has a
      _makeQuads attribute

    <p>Add ocsmSetDtime, ocsmPrintEgo, ocsmGetNorm, ocsmRetCsys,
      ocsmGetCsys, and ocsmSetCsys functions to OpenCSM API

    <p>Add support for an external grid generator (egg) to be used in
      place of the EGADS tessellator; add ocsmSetTess function to API

    <p>Allow all lists to be input either as name of a multi-values
      Parameter or a semicolon-separated list of expressions

    <p>Allow all command names to be specified either in lowercase or
      UPPERCASE

    <p>Add global ID to all Edges and Faces

    <p>Add Body, Face, Edge, and Node attribute printing in
      ocsmPrintBrep

    <p>Update ocsmGetVel so that it returns vector sensitivities

    <p>Add many new test cases, all with verification data

    <p><h3 id="sec8.26"> 8.26: Bug fixes since v1.08</h3>

    <p>Improve robustness of UNION when applied to SheetBodys

    <p>Fix .ibody attribute for Edges associated with a Body that is
      restored more than once

    <p>Fix .ibody attribute for Edges associated with FILLET, CHAMFER,
      HOLLOW, and CONNECT commands

    <p>Fix .ibody attribute for Edges

    <p>Fix ocsmGetUV and ocsmGetXYZ results when uv=NULL

    <p>Fix several memory leaks

    <p>Execute dimension checks at run-time (and not load-time)

    <p>Fix bug that caused SELECT statements to be written incorrectly
      in ocsmSave

    <p>Fix indentation for PATBREAK statement

    <p>Fix bug associated with adding and editing a SELECT statement
      in ESP

    <p>Fix bug associated with single digit attributes

    <p>Fix sensitivity error for end-caps in EXTRUDEs, RULEs, and
      BLENDs

    <p>Fix Face sensitivity info in udpBox

    <p>Remove MACBEG, MACEND, and RECALL statements from ESP

    <p>Mark Branch as dirty if an Attribute or Csystem changes

    <p>Fix erroneous truncation of very long metadata in ESP

    <p><h3 id="sec8.27"> 8.27: New/extended features in v1.08</h3>

    <p>A new ocsmDelPmtr function has been added to the OpenCSM API to
       delete a Design Parameter

    <p>A new ocsmGetTessVel function has been added to the OpenCSM API
       to return the 3D sensitivities at all the tessellation points

    <p>A new biconvex UDP was written

    <p>An additional argument, relative=0, has been added to the SKBEG
       statement.  If set to 1, the coordinates specified by LINSEG,
       CIRARC, ARC, SPLINE, and BEZIER statements are all relative to
       the coorindates in the SKBEG statement

    <p>The DESPMTR, LBOUND, and UBOUND statements have been extended
       to allow specification of a single value, a whole row, a whole
       column, or the whole matrix

    <p>The smallang(ang) function has been added to convert angles
       into the range -180 &lt; ang &lt;= 180

    <p>The hypot3(x,y,z) function has been added for 3D vectors

    <p>The mod(i,j) function has been added

    <p>The x.norm dot suffix has been added to compute the norm of
        array x

    <p>When an edit form is displayed, the first entry box now
       automatically gets focus on entry

    <p>The TAB key now correctly moves between inputs in the edit
       forms in ESP

    <p>Pressing the ENTER key in an edit form is now the same as
       pressing the OK button

    <p>When a SKBEG statement is added in ESP, a matching SKEND is
       automatically added and ESP enters the sketcher automatically

    <p>If a SKBEG Branch is deleted, the whole associated sketch is
       now deleted

    <p>Once a UDPRIM or UDPARG statement has been added, the number of
       name-value pairs cannot be changed.  Add another UDPARG
       statement if more are needed.

    <p>When a new Design Parameter is added, it defaults to be a
       scalar.  New buttons have been added to "Add a Row" or "Add a
       Column"

    <p>The Delete Parameter button has been added to the edit parameter
       form

    <p>5 levels of Undo are now kept in the sketcher

    <p>Circle centers can now be constrained in the sketcher

    <p>The X and Y constraints at the beginning of a relative sketch
       can no longer be deleted

    <p>In the sketcher, the correct sign is suggested for W, D, R, and
        S constraints based pon what user draws

    <p>Arrow keys and PgUp and PgDn can be used to transform the image
       in the sketcher

    <p>Zero-length segments cannot be accidentally drawn via double
       clicks in the Sketcher.  A new "z" command has been added to
       create zero-length segments.

    <p>Pressing ESC in sketcher no longer exits the sketcher

    <p>Pressing &lt; to delete a constraint in the sketcher now gives
       the user the option to select the one constraint to delete if
       there are multiple constraints present

    <p>The <code>@</code> key in the sketcher reports coordinates in
       the Message window

    <p>Descriptions of the supell and kulfan UDPs have been added to
       the help file

    <p>NodeBodys are now left on the stack

    <p>Attributes can now be assigned to NodeBodys

    <p>NodeBodys are now displayed on the screen

    <p>For -outLevel=2 in serveESP, the debug messages now are
       explicit as to which messages are sent by the browser and which
       message are sent by the server

    <p><h3 id="sec8.28"> 8.28: Bug fixes since v1.07</h3>

    <p>Numerous typos were fixed in this help file

    <p>A segmentation fault associated with very large arguments has
       been fixed

    <p>Inclination is now handled consistently in the sketcher and
        OpenCSM

    <p>Temporary sketch variables are freed before starting a new
       sketch

    <p>Trying to save a <code>.csm</code> file to a nonexistent
       directory no longer causes a segmentation fault

    <p>Sensitivities associated with UDCs have been fixed

    <p>A bug that prevented a user from having more than one
       name-value pair in a UDPRIM statement (for a UDC) has been
       fixed

    <p>A memory leak was fixed by freeing of storage associated with
       arguments before stack finalization

    <p>A bug that allowed a udprim to be recycled even when there are
       velocities in its arguments has been fixed

    <p>Analytic sensitivity of EXTRUDE and RULE of a transformed
       sketch are now correct

    <p>A bug associated with the analytic sensitivities for the
       endcaps in EXTRUDE and RULE has been fixed

    <p>Infinite loop in sensitivities for Windows x64, Visual Studio
       12.0 has been fixed

    <p>Finite difference sensitivities for cylinders and cones that
       are almost aligned with an axis are now correct

    <p>Analytic edge sensitivities in the supell UDP are now correct

    <p>Analytic edge sensitivities in ellipse UDP have been corrected
       for cases when DY=0

    <p>A bug that left a picture even after all Branches were deleted
        has been fixed

    <p>Global Attributes are now properly written in .csm files by
       ocsmSave

    <p>A check has been added to make sure that there are at least 2
       sketches between rounded nose and tail points in BLEND

    <p>Spaces have been removed from constraint expressions that the
       user specified in the Sketcher so that the sketch can be saved
       properly

    <p>The upper limit must now be greater than the lower limit when
       changing them in the Key window

    <p>A bug that caused surfaces to always be rendered in grey on
       some Intel graphics devices has been fixed

    <p>A bug that caused tutorial3 to seg fault has been fixed

    <p>A bug that erroneously recycled a UDPRIM if values in the
       UDPARG statement changed was fixed

    <p>Leaving blank entries in a UDPRIM or UDPARG statement no longer
       asks the user for confirmation

    <p>Pressing Undo after solving a sketch now just undoes the solve

    <p>Fixed a bug associated with order of calls during cleanup

    <p>The correct bodyID is now applied to WireBodys

    <p>Body Attributes are now applied directly to Edges if a WireBody
       was created by an open sketch

    <p>The testing process has been changed to better catch errors
       during the execution of the test suite

    <p>Sensitivities are now correctly computed for non-manifold Edges

    <p><h3 id="sec8.29"> 8.29: New/extended features in v1.07</h3>

    <p><code>CAPRI</code> is no longer supported

    <p>serveESP now returns 1 if running in batch and an error is
       encountered

    <p>A warning is issued if a SolidBody has a non-positive volume

    <p>All lists are now semicolon-separated (including in BLEND,
       CHAMFER, CONNECT, FILLET, HOLLOW, and UNION)

    <p>Functions "seglen", "incline", "radius", "sweep", and "dip"
       were added to the expression evaluator

    <p>More checks were added for invalid arguments in the BOX,
       CYLINDER, CONE, SPHERE, TORUS, EXTRUDE, and REVOLVE
       commands

    <p>An ARC statement was added as an alternative to the CIRARC
       statement

    <p>In an ATTRIBUTE statement, if the attrValue is a multi-valued
       parameter, then multiple values will be assigned

    <p>Errors are raised if trying to apply Attributes to an ASSERT,
       DESPMTR, DIMENSION, END, INTERFACE, LBOUND, MACBEG,
       MACEND, MARK, PATBEG, PROJECT, SET, SKBEG, SOLBEG,
       STORE, UBOUND, or UDPARG statement

    <p>Tessellation parameters can be specified in a ".tParams"
       Attribute at either the global, Body, Face, or Edge level (for
       use by the internal tessellator)

    <p>A BEZIER statement was added to create Bezier curves

    <p>A CONNECT statement was added to create a new Body from two
       old Bodys with certain faces "connected" by a local set of Faces
       (see flapz.udc for an example use)

    <p>The INTERFACE statement now supports multi-valued parameters

    <p>Tolerances can be relaxed in INTERSECT statement

    <p>The JOIN command has an optional "tolerance" argument

    <p>A patbreak statement was added to allow one to break out of
       a pattern

    <p>A REORDER statement has been added to reorient faces (such as
       might be needed before a RULE or BLEND)

    <p>Warnings are generated if the REVOLVE statement yields a
       possibly-inside-out Body

    <p>Analytic sensitivities have been added to the RULE statement

    <p>A reorder option was added to RULE and BLEND to allow
       OpenCSM to automatically reorder loops so as to minimize the
       chance of twist

    <p>A SKCON statement was added to allow constraints to be
       defined for the sketch solver

    <p>The number of Edges are reported when executing the SKEND
       statement

    <p>A SKVAR statement was added to initialize sketcher variables

    <p>A "keep" option was added to the STORE command

    <p>Tolerances can be relaxed in SUBTRACT statement

    <p>Added optional "trimList" to UNION operation to allow a user
       to union "up to" the closest intersection to the given point

    <p>Tolerances can be relaxed in UNION statement commands

    <p>The <code>kulfan</code> user-defined primitive (udp) was added
       to create CST airfoils

    <p>The <code>supell</code> user-defined primitive (udp) was added
       to create a super-ellipse (to assist in creating fuselages)

    <p>The <code>biconvex</code> user-defined component (udc) was added
       to create a biconvex airfoil

    <p>The <code>diamond</code> user-defined component (udc) was added
       to create a diamond-shaped airfoil

    <p>The <code>flapz</code> user-defined component (udc) was added
        to add a (possibly-deflected) flap to an existing body

    <p>The <code>popupz</code> user-defined component (udc) was added
       to generate a "pop-up" from an existing surface

    <p>If the server (serveESP) dies, the Messages window turns pink
       and no alert is issued

    <p>Rolling the middle -mouse button zooms in/out

    <p>An interactive sketcher was added

    <p>Buttonslabeled "<b>H</b>", "<b>L</b>",
       "<b>R</b>", "<b>B</b>",
       "<b>T</b>", "<b>+</b>", and
       "<b>-</b>" buttons as an alternative to
       "<b>&lt;Ctrl-h&gt;</b>",
       "<b>&lt;Ctrl-l&gt;</b>",
       "<b>&lt;Ctrl-r&gt;</b>",
       "<b>&lt;Ctrl-b&gt;</b>",
       "<b>&lt;Ctrl-t&gt;</b>",
       "<b>&lt;Ctrl-i&gt;</b>" and
       "<b>&lt;Ctrl-o&gt;</b>" (since some browsers steal
       some of these control sequences)

    <p>The spectrum was changed from blue-green-red to blue-white-red

    <p>The environment variable <code>ESP_START</code> was changed
       to <code>ESP_START</code> (although <code>ESP_START</code> still
       works)

    <p><h3 id="sec8.30"> 8.30: Bug fixes since v1.06</h3>

    <p>A journalling error was associated with the UNION command

    <p>The REVOLVE command did not work if given a SheetBody

    <p>Storage associated with UDPs was not properly released

    <p>Nested UDCs without END statements caused infinite loops

    <p>The PROJECT command could fail in certain situations, such as
       during rebuilds

    <p>Repeated points caused problem when creating a spline (so now
        they are removed)

    <p>Errors were raised for expressions in the form "0^any" (they
       now return "0")

    <p>Multi-valued parameters in UDPs were not handled properly when
       computing sensitivities

    <p>Arrays were flattened when being transferred into UDCs

    <p>Expressions such as "x[i+1]" were not parsed properly

    <p>SheetBodys from BLEND with open sketches were improperly
       classified as SolidBodys

    <p>Infinite loop resulted when an END statement was put into
       a pattern with zero iterates

    <p>The vertical tail was misplaced in myPlane with fidelity set
       to 1 or 2

    <p>Sensitivity failed if using a UDP with an integer or string
       argument

    <p>Default velocity was set to -HUGEQ, causing unset variables to
       inadvertently execute sensitivities (they are now set to "0")

    <p>An error in the first Branch caused ESP to hang

    <p><h3 id="sec8.31"> 8.31: New/extended features in v1.06</h3>

    <p>User-defined components (UDCs) have been implemented to execute
       consistently with user-defined primitives (UDPs).  The main
       difference is that UDCs are defined in scripts (in a file named
       <code>*.udc</code>) whereas UDPs are defined in C-code that is
       pre-compiled.  The first argument of the UDPRIM statement
       selects a UDC if it starts with a "/" or a "$/"; otherwise it
       looks for a UDP.

    <p>The INTERFACE statement has been added to be used within UDCs
       to define the UDC's INTERFACE, including the default values for
       its arguments.

    <p>The JOIN command was added to combine Bodys at common Faces.
       Using the JOIN command is preferred over the UNION command
       when the user expects some of the Faces to match exactly.

    <p>The STORE and RESTORE commands were added to keep copies of
       Bodys in memory (rather than in an external files, as was done
       for DUMP and IMPORT).  The advantage is that the build tree
       information is retained, allowing Bodys to sometimes be reused
       during the regeneration process.

    <p>The EXTRACT command has been added to extract a
       lower-dimension object (for example, an Edge from a Body).

    <p>The COMBINE command has been added to create a
       higher-dimension object (for example, a Faces from a group of
       Edges).

    <p>The ASSERT command has been added to return an error if
       the assertion is not satisfied.

    <p>The direction vectors in the "noselist" and "taillist"
       arguments to the BLEND command no longer need to be
       normalized.

    <p>If the arguments to the SUBTRACT command are a SOLID Body and
       a SHEET Body, then the SOLID Body is scribed with Edges at the
       intersection of the SOLID and SHEET.

    <p>An optional argument (wireonly) has been added to the SKEND
       command; if wireonly is set to 1, then a (possibly non-planar)
       WIRE Body is created instead of a SHEET Body.

    <p>Array elements can be addressed with a single subscript, which
       are numbered across rows.

    <p>Names are allowed to include colons ":", which is useful for
       hierarchically organizing names.

    <p>The "ifnan", "sign", "ceil", and "floor" functions have been
       added to the expression evaluator.

    <p>".nrow", ".ncol", ".size", ".sum", ".min", and ".max"
       dot-suffixes can be appended to variables to return properties
       of the Design Parameter of Local Variable rather than its
       value.

    <p>The "naca456" UDP was added to create NACA-4, -5, and -6 series
       airfoils.

    <p>Global Attributes are placed on all Bodys.

    <p>Keyboard shortcuts were added to the <code>ESP</code> viewer:
      <table>
        <tr>
          <td><b>&lt;Ctrl-h&gt;</b></td>
          <td>home</td>
          <td>(same as <b>&lt;Home&gt;</b>)</td>
        </tr>
        <tr>
          <td><b>&lt;Ctrl-i&gt;</b></td>
          <td>zoom in</td>
          <td>(same as <b>&lt;PgUp&gt;</b>)</td>
        </tr>
        <tr>
          <td><b>&lt;Ctrl-o&gt;</b></td>
          <td>zoom out</td>
          <td>(same as <b>&lt;PgDn&gt;</b>)</td>
        </tr>
        <tr>
          <td><b>&lt;Ctrl-f&gt;</b></td>
          <td>front view</td>
          <td>(same as <b>&lt;Home&gt;</b>)</td>
        </tr>
        <tr>
          <td><b>&lt;Ctrl-t&gt;</b></td>
          <td>top view</td>
        </tr>
        <tr>
          <td><b>&lt;Ctrl-b&gt;</b></td>
          <td>bottom view</td>
        </tr>
        <tr>
          <td><b>&lt;Ctrl-l&gt;</b></td>
          <td>leftside view</td>
        </tr>
        <tr>
          <td><b>&lt;Ctrl-r&gt;</b></td>
          <td>riteside view</td>
        </tr>
      </table>

    <p>When a Branch is edited in ESP, the first field associated
       with the Branch in the Tree window is colored magenta, the
       Branch's parents are colored cyan, and the Branch's child is
       colored yellow.

    <p>When a Design Parameter is edit-ted in ESP, the first field
       associated with the Parameter in the Tree window is colored
       magenta.

    <p>If one selects another Branch or Parameter in the Tree window
       while editting another Branch or Parameter, the current edit is
       cancelled and the new edit started.

    <p>Axes are displayed in ESP.

    <p>Branches are indented (with ">") in Tree Window in ESP.

    <p><h3 id="sec8.32"> 8.32: Bug fixes since v1.05</h3>

    <p>Attribute values can be strings (prepended by "$").

    <p>Improved nose an tail treatment in BLEND.

    <p>A sketch can be composed of a single closed spline.

    <p>Error in face-order for REVOLVE command.

    <p>If a DESPMTR statement tries to redefine a parameter, print
       out warning message that previous values will be used

    <p>Allow filename argument in IMPORT statement to be in form
       $$/filename (to be consistent with UDPRIM import).

    <p>"ifpos", "ifneg", and "ifzero" perform lazy evaluations so that
       errors in unused arguments do not trigger an error.

    <p>Print comment lines that start with a space.

    <p>Report number of segments in blending message.

    <p>Flip sketch so that its normal direction is in the +x, +y, or
       +z direction.

    <p>Remove creation of spurious Bodys created by JOIN command.

    <p>Allow more than one matched Face in JOIN command.

    <p>Allow blanks in SELECT, UDPARG, and UDPRIM statement in
       ESP (but only at end).

    <p>Fix serveESP so that the JSON that it transfers to the browser
       does not contain ",]" nor ",}".

    <p><h3 id="sec8.33"> 8.33: Known problems in v1.09</h3>

    <p>Internet Explorer (11) is not recommended since it sometimes
       stops sending messages to the server.

    <p>When using 64-bit OS X 10.8 or higher, you should use
       OpenCASCADE 6.6.0 (as opposed to 6.8.0).  There is an error
       somewhere that causes "serveESP tutorial1_new" to sometimes
       produces a segmentation fault during rebuilds.

    <p>Edges are not drawn in ESP when running a LINUX64 virtual
       machine under VMware with OSX 10.8 or higher as the host
       operating system.

    <p>The <b>&lt;Ctrl-l&gt;</b> (leftside view) keyboard
       shortcut does not work in Safari (since it appears that Safari
       intercepts the <b>&lt;Ctrl-l&gt;</b> before it gets
       to ESP).  Use the "L" button instead.

    <p>Test cases with the HOLLOW command do not work when using the
       pre-built versions of OpenCASCADE 6.6.0 or 6.8.0 for Windows.

    <p>In OpenCASCADE 6.8.0, the tolerances associated with the sew
       operation cause cases with loose tolerances to no longer work.

    <p>The "Edit" command in ESP can only be used to edit
       the <code>.csm</code> file; any <code>.udc</code> files that
       are opened cannot be edited.

    <p>OpenCASCADE can write .step files that are unreadable by other
       applications (such as an ellipsoid)

    <p>Case design8 in sensCSM has two families of results, depending
       on the version of OS and OCC that is used

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec9">9.0: Error Codes</h2>

    <p><h3 id="sec9.1"> 9.1: OpenCSM error codes</h3>

    <p><code>OpenCSM</code> performs extensive error checking that can issue the
       following error codes:
      <!-- extract from OpenCSM.h -->
      <pre>
SUCCESS                                 0

OCSM_FILE_NOT_FOUND                  -201
OCSM_ILLEGAL_STATEMENT               -202
OCSM_NOT_ENOUGH_ARGS                 -203
OCSM_NAME_ALREADY_DEFINED            -204
OCSM_NESTED_TOO_DEEPLY               -205
OCSM_IMPROPER_NESTING                -206
OCSM_NESTING_NOT_CLOSED              -207
OCSM_NOT_MODL_STRUCTURE              -208
OCSM_PROBLEM_CREATING_PERTURB        -209

OCSM_MISSING_MARK                    -211
OCSM_INSUFFICIENT_BODYS_ON_STACK     -212
OCSM_WRONG_TYPES_ON_STACK            -213
OCSM_DID_NOT_CREATE_BODY             -214
OCSM_CREATED_TOO_MANY_BODYS          -215
OCSM_TOO_MANY_BODYS_ON_STACK         -216
OCSM_ERROR_IN_BODYS_ON_STACK         -217
OCSM_MODL_NOT_CHECKED                -218
OCSM_NEED_TESSELLATION               -219

OCSM_BODY_NOT_FOUND                  -221
OCSM_FACE_NOT_FOUND                  -222
OCSM_EDGE_NOT_FOUND                  -223
OCSM_NODE_NOT_FOUND                  -224
OCSM_ILLEGAL_VALUE                   -225
OCSM_ILLEGAL_ATTRIBUTE               -226
OCSM_ILLEGAL_CSYSTEM                 -227
OCSM_NO_SELECTION                    -228

OCSM_SKETCH_IS_OPEN                  -231
OCSM_SKETCH_IS_NOT_OPEN              -232
OCSM_COLINEAR_SKETCH_POINTS          -233
OCSM_NON_COPLANAR_SKETCH_POINTS      -234
OCSM_TOO_MANY_SKETCH_POINTS          -235
OCSM_TOO_FEW_SPLINE_POINTS           -236
OCSM_SKETCH_DOES_NOT_CLOSE           -237
OCSM_SELF_INTERSECTING               -238
OCSM_ASSERT_FAILED                   -239

OCSM_ILLEGAL_CHAR_IN_EXPR            -241
OCSM_CLOSE_BEFORE_OPEN               -242
OCSM_MISSING_CLOSE                   -243
OCSM_ILLEGAL_TOKEN_SEQUENCE          -244
OCSM_ILLEGAL_NUMBER                  -245
OCSM_ILLEGAL_PMTR_NAME               -246
OCSM_ILLEGAL_FUNC_NAME               -247
OCSM_ILLEGAL_TYPE                    -248
OCSM_ILLEGAL_NARG                    -249

OCSM_NAME_NOT_FOUND                  -251
OCSM_NAME_NOT_UNIQUE                 -252
OCSM_PMTR_IS_EXTERNAL                -253
OCSM_PMTR_IS_INTERNAL                -254
OCSM_PMTR_IS_OUTPUT                  -255
OCSM_PMTR_IS_CONSTANT                -256
OCSM_WRONG_PMTR_TYPE                 -257
OCSM_FUNC_ARG_OUT_OF_BOUNDS          -258
OCSM_VAL_STACK_UNDERFLOW             -259  /* probably not enough args to func */
OCSM_VAL_STACK_OVERFLOW              -260  /* probably too many   args to func */

OCSM_ILLEGAL_BRCH_INDEX              -261  /* should be from 1 to nbrch */
OCSM_ILLEGAL_PMTR_INDEX              -262  /* should be from 1 to npmtr */
OCSM_ILLEGAL_BODY_INDEX              -263  /* should be from 1 to nbody */
OCSM_ILLEGAL_ARG_INDEX               -264  /* should be from 1 to narg  */
OCSM_ILLEGAL_ACTIVITY                -265  /* should OCSM_ACTIVE or OCSM_SUPPRESSED */
OCSM_ILLEGAL_MACRO_INDEX             -266  /* should be between 1 and 100 */
OCSM_ILLEGAL_ARGUMENT                -267
OCSM_CANNOT_BE_SUPPRESSED            -268
OCSM_STORAGE_ALREADY_USED            -269
OCSM_NOTHING_PREVIOUSLY_STORED       -270

OCSM_SOLVER_IS_OPEN                  -271
OCSM_SOLVER_IS_NOT_OPEN              -272
OCSM_TOO_MANY_SOLVER_VARS            -273
OCSM_UNDERCONSTRAINED                -274
OCSM_OVERCONSTRAINED                 -275
OCSM_SINGULAR_MATRIX                 -276
OCSM_NOT_CONVERGED                   -277

OCSM_UDP_ERROR1                      -281
OCSM_UDP_ERROR2                      -282
OCSM_UDP_ERROR3                      -283
OCSM_UDP_ERROR4                      -284
OCSM_UDP_ERROR5                      -285
OCSM_UDP_ERROR6                      -286
OCSM_UDP_ERROR7                      -287
OCSM_UDP_ERROR8                      -288
OCSM_UDP_ERROR9                      -289

OCSM_OP_STACK_UNDERFLOW              -291
OCSM_OP_STACK_OVERFLOW               -292
OCSM_RPN_STACK_UNDERFLOW             -293
OCSM_RPN_STACK_OVERFLOW              -294
OCSM_TOKEN_STACK_UNDERFLOW           -295
OCSM_TOKEN_STACK_OVERFLOW            -296
OCSM_UNSUPPORTED                     -298
OCSM_INTERNAL_ERROR                  -299
      </pre>

    <p><h3 id="sec9.2">9.2: EGADS error codes</h3>

    <p>In addition, sometimes <code>EGADS</code> or <code>CAPRI</code>
       will issue an error code.  The <code>EGADS</code> error codes
       that may be seen from time to time include:
      <!-- extract from egadsErrors.h -->
      <pre>
EGADS_SUCCESS                           0
EGADS_NOTFOUND                         -1
EGADS_NULLOBJ                          -2
EGADS_NOTOBJ                           -3
EGADS_MALLOC                           -4
EGADS_INDEXERR                         -5
EGADS_NONAME                           -6
EGADS_NODATA                           -7
EGADS_MIXCNTX                          -8
EGADS_NOTCNTX                          -9
EGADS_NOTXFORM                        -10
EGADS_REFERCE                         -11
EGADS_NOTTOPO                         -12
EGADS_EMPTY                           -13
EGADS_NOTTESS                         -14
EGADS_NOTGEOM                         -15
EGADS_RANGERR                         -16
EGADS_NOLOAD                          -17
EGADS_NOTMODEL                        -18
EGADS_WRITERR                         -19
EGADS_NOTBODY                         -20
EGADS_GEOMERR                         -21
EGADS_TOPOERR                         -22
EGADS_CONSTERR                        -23
EGADS_DEGEN                           -24
EGADS_NOTORTHO                        -25
EGADS_BADSCALE                        -26
EGADS_OCSEGFLT                        -27
EGADS_TOPOCNT                         -28
EGADS_ATTRERR                         -29
EGADS_EXISTS                          -30
EGADS_TESSTATE                        -31
EGADS_READERR                         -32
      </pre>

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec10">10.0: Bugs Reports and Other Feedback</h2>

    <p>All reports of possible 'bugs' and any other feedback should be
       e-mailed to 'jfdannen@syr.edu' or 'haimes@mit.edu'.  If a bug
       report, please include the version number you are running
       (listed in the title bar at the top of the program), what you
       were doing at the time of the bug, and what happened that you
       didn't expect.  The more information that you include, the
       better the chances that the bug can be reproduced and hence
       fixed.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec11">11.0: Copyright</h2>

    <p>Copyright (C) 2010/2022 John F. Dannenhoffer, III (Syracuse
       University)

    <p>This library is free software; you can redistribute it and/or
       modify it under the terms of the GNU Lesser General Public
       License as published by the Free Software Foundation; either
       version 2.1 of the License, or (at your option) any later
       version.

    <p>This library is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU Lesser General Public License for more details.

    <p>You should have received a copy of the GNU Lesser General
       Public License along with this library; if not, write to the
       Free Software Foundation, Inc., 51 Franklin Street, Fifth
       Floor, Boston, MA 02110-1301 USA

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec12">12.0: Glossary</h2>

      <p><b>@-parameter</b> A local variable that is set by
      the system every time a new Body is created or a SELECT
      statement is executed.  The local variables, which cannot be set
      by the user, contain information such as the identity of various
      entities or mass properties.

      <p><b>argument</b> An expression that is input to an
      CSM statement.  Arguments are positional (that is, their
      meanings are specified by their order).  Optional arguments are
      listed last, and their default values are listed in the
      command's description.

      <p><b>associative</b> A concept that means that an
      entity in one Body is another representation of some other
      entity in some other Body.

      <p><b>autosave.csm</b> A file that contains a snapshot
      of the state of ESP before any command is executed.

      <p><b>Attribute</b> A user-defined name/value pair
      that is associated with a Branch, Body, Face, Edge, or Node.
      Names that begin with an underscore (_) have special meaning to
      CSM and those that begin with a period (.) have special meaning
      to EGADS.  The values associated an attribute can either be a
      string value (prepended by a dollar-sign ($)) or a
      semicolon-separated list of expressions.

      <p><b>activity</b> An characteristic of a Branch which
      tells if the Branch should be executed the next time the Model
      is re-built.  ESP supports 'active' and 'suppressed' activities.

      <p><b>Body</b> An object that is created by ESP to
      represent some physical artifact.  ESP supports SolidBodys,
      SheetBodys (which consist of a collection of connected Faces
      that may or may not be manifold), WireBodys (which consist of a
      collection of connected Edges, where each Edge shares a bounding
      Node with at most one other Edge), and NodeBodys (which consist
      of a single point in space).

      <p><b>Boolean operation</b> An operation that combines
      two Bodys (on the stack).  The UNION operation returns the
      fusion of two Bodys, the INTERSECT operation returns the common
      part of two Bodys, and the SUBTRACT operation returns the
      portion of Body1 that is not in Body2.

      <p><b>Branch</b> An entity in the Model's Feature
      Tree that corresponds to either a primitive solid,
      transformation, Boolean operator, sketch entity, or other
      item used in the construction of a Model.

      <p><b>Brep</b> A boundary representation is a
      collections of Nodes, Edges, and Faces that describe the
      boundary of a Body.

      <p><b>browser</b> A computer program with which a user
      interacts with ESP.  ESP currently runs in FireFox and SeaMonkey.

      <p><b>client</b> A program, typically a web browser,
      with which a user interacts.  The client handles some of ESP's
      operations directly (such as image manipulation), but sends
      messages to the server to perform the majority of ESP's
      operations.

      <p><b>collapse</b> The process of 'closing up' a node
      in a tree so that its children are not displayed.  This is
      accomplished by pressing the <b>-</b> to the left of
      an (expanded) tree node.

      <p><b>command</b> Synonym for statement.

      <p><b>command line</b> The statement typed into a
      terminal window to start <code>serveESP</code>.

      <p><string>Configuation Parameter</b> A value that can be
      set by the user, either programmatically or via the ESP user
      interface, that is used to generate a specific instance of a
      model.  Sensitivities cannot can be found with respect to a
      Configuration Parameter.

      <p><b>constructive solid modeler</b> A process by
      which complex Bodys are created through the combination of
      simpler (primitive) Bodys.

      <p><b>curve</b> A path through space, where the
      locations of points along the curve are given as [x,y,z]=f(t),
      where t is called the parametric coordinate.  Examples of curves
      include lines, conics, and NURBS curves.

      <p><b>degree of freedom</b> A variable in a sketch
      whose value must be computed by satisfying one or more
      constraints.  Each line in a sketch adds 2 degrees of freedom,
      each circular arc adds 3 degrees of freedom, ...

      <p><b>dot-suffix</b> A mechanism through which some
      property of a (multi-values) Parameter or Variable is returns
      (rather than the Parameter's value).  For
      example, <code>x.nrow</code> returns the number of rows
      of <code>x</code>.

      <p><b>drag</b> An operation in which a user presses a
      mouse button and holds it down while moving it to another
      location on the screen.

      <p><b>Design Parameter</b> A value that can be set by
      the user, either programmatically or via the ESP user interface,
      that is used to generate a specific instance of a model.
      Sensitivities of the geometry or tessellation can be found
      with respect to any Design Parameter.

      <p><b>Design Velocity</b> A change in an input
      parameter from which changes in the local surface normals will
      be computed.

      <p><b>Edge</b> The part of a Brep that is associated
      with a curve.  Each Edge has an underlying curve, the parametric
      coordinate (tbeg) at the beginning of the Edge, the parametric
      coordinate (tend) at the end of the Edge, and the Nodes at tbeg
      and tend.  If all the Edges in a Body support exactly two Faces,
      the Body is said to be manifold.

      <p><b>EGADS</b> The Electronic Geometry Aircraft
      Design System, is an open-source geometry interface
      to <code>OpenCASCADE</code>, in which the functionality
      in <code>OpenCASCADE</code> that is needed for construction of
      typical applications is incorporated into about 70 C-functions.

      <p><b>ESP</b> The Engineering Sketch Pad is a
      browser-based software system that allows users create, modify,
      (re-)build, and save constructive solid models built via OpenCSM.

      <p><b>expand</b> The process of 'opening up' a node in
      a tree to see its children nodes.  This is accomplished by
      pressing the <b>+</b> to the left of a (collapsed)
      tree node.

      <p><b>expression</b> An algebraic combination of
      variables and constants that produce a single number.
      Expressions can use any of OpenCSM's built-in functions and/or
      dot-suffixes.  Expressions are used as argument to OpenCSM's
      commands.

      <p><b>Face</b> The part of a Brep that is associated
      with a surface.  Faces are bounded by trimming curves in the
      form of Loops.  Each Face has only one outer Loop and zero or
      more inner Loops (which represent holes).  The trimming curves,
      which corresponds to the Face's bounding Edges, are described
      as a series of Pcurves.

      <p><b>Feature Tree</b> A build prescription that is
      made up of a series of statements (or commands).  The statements
      in the Feature Tree are executed sequentially (with loops being
      represented by patterns and logic represented by IFTHEN
      blocks).  During the execution of the Feature Tree, a stack of
      Bodys are maintained.  Each statement that generates a Body puts
      it onto the stack; statements that modify or combine Bodys get
      their inputs by popping Bodys off the stack (with the most
      recently created being popped off first).  When CSM completes,
      the Bodys that remain on the stack are available as output of
      CSM.

      <p><b>flying mode</b> A way of panning, zooming, and
      rotating a display in which the motion of the image in the
      Graphics Window changes as long as the user holds the mouse
      button.  Use the <b>!</b> key in the Graphics Window
      to toggle flying mode on and off.

      <p><b>function</b> An atomic operation that transforms
      its inputs into a single value.  Example include trigonometric
      operations and single in-line logical constructs.

      <p><b>global Attribute</b> An Attribute that is
      specified before any other CSM command.  Global Attributes are
      added to any Body created by CSM.

      <p><b>Graphics window</b> The window on the top-right
      of the ESP screen that contains a graphical representation of
      the current configuration.

      <p><b>hostname</b> The name of the computer that is
      running the server (typically serveESP).  If using a single
      computer for both the browser and server, use 'Localhost' as the
      hostname.

      <p><b>journal</b> A file that is written (on the
      server) that keeps track of the commands that user executed
      while running ESP.  A user (who has access to the server) can
      copy the journal file to another name and use it to
      automatically replay the session that was journalled during a
      future invocation of serveESP.

      <p><b>Key window</b> The window on the bottom left of
      the ESP screen that contains a spectrum to indicate sensitivity
      values.  If no sensitivity is active, this window in blank.

      <p><b>Local Variable</b> Either an array of numeric
      values (which can contain only one value, in which case it is
      called a scalar) or a string of characters.  Local variables get
      their values via SET and GETATTR statements.  Local variables
      are not accessible outside CSM, but only within CSM while the
      Feature Tree is being executed.

      <p><b>Loop</b> A collection of Edges, arranged end to
      end, where each Edge has exactly two neighboring Edges.  Loops,
      when applied to a surface, tells the part of the surface that is
      inside the Face.

      <p><b>manifold solid</b> A manifold solid is
      represented by a Brep, whose Edges all support two Faces.

      <p><b>Messages window</b> The window on the bottom
      right of the ESP screen that contains status information and
      other messages to the user.

      <p><b>Model</b> A container that contains the
      Parameters and (Feature Tree) Branches.

      <p><b>Node</b> The topological entity associated with
      a single location in space.  Nodes can be free-standing, such as
      in a NodeBody, but usually are at the ends of Edges.

      <p><b>OpenCASCADE</b> An open-source geometry system
      on which EGADS is built.

      <p><b>OpenCSM</b> The open-source constructive solid
      modeler that is a feature-based, associative, and parametric and
      which build Bodys that are either manifold solids (the typical
      output) or non-manifold sheets and wires (such as may be needed
      for representing wake sheets and antennae).

      <p><b>Parameter</b> A two-dimensional array of
      floating-point numbers that is used during the build process to
      generate a specific instance of a Model.

      <p><b>pattern</b> A looping construct, originally used
      to generate a series of features on a Body (such as a
      regularly-space series of holes).

      <p><b>point</b> A location in space either at a Node,
      along an Edge (or curve), or on a Face (or surface).

      <p><b>port</b> The port number on which the server
      (typically serveESP) is listening for requests by the browser.
      serveESP uses 7681 as its default port.

      <p><b>primitive</b> A CSM statement that generates
      either a box, sphere, cylinder, cone, or torus, or a
      user-defined primitive.

      <p><b>semicolon-separated list</b> A list of
      expressions (that evaluate to numeric values) that are written
      with semicolons (;) between entries.  A semicolon-separated list
      may optionally be terminated with a semicolon.

      <p><b>sensitivity</b> The derivative of the location
      on a Body with respect to one or more of the Design Parameters.

      <p><b>server</b> A computer program in which OpenCSM
      runs and which 'serves' Models and Boundary Representations to
      ESP.  The program 'serveESP' is the initial server for ESP.

      <p><b>sketch</b> A 2-D drawing composed of lines,
      circular arcs, a splines, that is used to define a SheetBody
      (with a single Face) or WireBody.  Sketches are typically used
      as the basis of grown solids such as EXTRUDE, REVOLVE, RULE, and
      BLEND.  (The latter two of these actually use a series of
      sketches.)

      <p><b>sketch constraint</b> A rule for specifying the
      relationships between sketch variables.

      <p><b>sketch variable</b> A degree of freedom within a
      sketch.  There are two sketch variables associated with the
      point between each pair of sketch segments and one additional
      sketch variable associated with each circular arc segment.

      <p><b>stack</b> A construct used with the build
      process to establish parent-child relationships between various
      features in the Feature Tree.  Primitive statements, which create
      Bodys, push them onto the top of the stack.  Transformation
      statements pop the top Body (or group) from the stack, transform
      it/them, and then pushes the transformed result back onto the
      stack.  Boolean operation pop two (or more) Bodys from the top
      of the stack and push the resultant Body back onto the stack.

      <p><b>statement</b> A line of CSM code that
      corresponds to one of the steps in the build process in the
      Feature Tree.

      <p><b>suppressed</b> A possible state for a Branch;
      Branches that are suppressed are not executed when the Feature
      Tree is executed.  Suppression is typically used to temporarily
      remove a feature during a build.

      <p><b>surface</b> A sheet in space, where the
      locations of points on the surface are given as [x,y,z]=f(u,v),
      where u and v are called the parametric coordinates.  Examples
      of surfaces include planes, cylindrical surface, and
      tensor-product NURBS surfaces.

      <p><b>transformation</b> A type of CSM statement that
      pops a Body (or group) from the top of the stack, modifies it,
      and then pushes the modified Body (or group) back onto the
      stack.  Examples of transformations include TRANSLATE, ROTATE*,
      and SCALE.

      <p><b>Tree window</b> The window on the top-left of
      the ESP screen that contains command buttons, a tree-like view
      of the current Parameters, a tree-like view of the current
      Branches (of the Feature Tree), and a tree-like view of the
      display settings.

      <p><b>UDC</b> User-defined component.  This is
      essentially a macro that is stored in a .udc file.  It is
      execute with a UDPRIM statement, where the primtype either
      starts with / or $/

      <p><b>UDF</b> User-defined function.  The difference
      between a UDF and a UDP is that a UDP does not get any of its
      inputs from the stack, whereas a UDF consumes one or more Bodys
      from the stack.

      <p><b>UDP</b> User-defined primitive.  This is a
      user-supplied compiled file (from C or FORTRAN) that creates a
      non-standard primitive.  It is executed with a UDPRIM statement,
      where the primtype starts with a letter

      <p><b>WebViewer</b> A piece of software, built upon
      the standard WebGL, that allows for the real-time view angle
      changes in a browser.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

  </body>
</html>
