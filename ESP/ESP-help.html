<?xml version="1.0"?>
<!DOCTYPE HTML PUBLIC "~//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta charset="UTF-8">

<!--
// help file for ESP and OpenCSM
// written by John Dannenhoffer
-->

<html>
  <head>
    <title>ESP User's Manual</title>

    <style type="text/css">
      body {font-size: 12pt;}
    </style>
  </head>

  <body>
    <p><h1 align=center>Engineering Sketch Pad (ESP) Version 1.18</h1>
    <p><h3>Authors: John F. Dannenhoffer, III (Syracuse University) and Bob Haimes (MIT)</h3>
    <p><h3>Date: June 2020.</h3>

    <p><h3 align=center><img src="esp_logo.png" width="400"/></h3>

    <p><h2 id="sec0">0.0 Table of Contents</h2>
    <p><a href="#sec1">1.0 Overview</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec1.1">1.1 Gallery of cases</a>
    <p><a href="#sec2">2.0 Tutorials</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.1">2.1 First tutorial: Basic usage</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.2">2.2 Second tutorial: Sketcher</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec2.3">2.3 Third tutorial: Aircraft example</a>
    <p><a href="#sec3">3.0 Command Line</a>
    <p><a href="#sec4">4.0 Interactive Options</a>
    <p><a href="#sec5">5.0 Format of the <code>.csm</code> and <code>.udc</code> Files</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.1">5.1 Format of the <code>.csm</code> file</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.2">5.2 Format of the <code>.udc</code> file</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.3">5.3 Special characters</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.4">5.4 Valid CSM statements</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.5">5.5 User-defined Primitives shipped with OpenCSM</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.6">5.6 User-defined Components shipped with OpenCSM</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.7">5.7 Number rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.8">5.8 String rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.9">5.9 Parameter rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.10">5.10 Expression rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.11">5.11 Attribute rules</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec5.12">5.12 Format of the plotfile</a>
    <p><a href="#sec6">6.0 Example <code>.csm</code> file</a>
    <p><a href="#sec7">7.0 Frequently Asked Questions</a>
    <p><a href="#sec8">8.0 Release notes</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.1">8.1 New/extended features in v1.18</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.2">8.2 Bug fixes since v1.17</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.3">8.3 New/extended features in v1.17</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.4">8.4 Bug fixes since v1.16</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.5">8.5 New/extended features in v1.16</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.6">8.6 Bug fixes since v1.15</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.7">8.7 New/extended features in v1.15</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.8">8.8 Bug fixes since v1.14</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.9">8.9 New/extended features in v1.14</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.10">8.10 Bug fixes since v1.13</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.11">8.11 New/extended features in v1.13</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.12">8.12 Bug fixes since v1.12</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.13">8.13 New/extended features in v1.12</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.14">8.14 Bug fixes since v1.11</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.15">8.15 New/extended features in v1.11</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.16">8.16 Bug fixes since v1.10</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.17">8.17 New/extended features in v1.10</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.18">8.18 Bug fixes since v1.09</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.19">8.19 New/extended features in v1.09</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.20">8.20 Bug fixes since v1.08</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.21">8.21 New/extended features in v1.08</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.22">8.22 Bug fixes since v1.07</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.23">8.23 New/extended features in v1.07</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.24">8.24 Bug fixes since v1.06</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.25">8.25 New/extended features in v1.06</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.26">8.26 Bug fixes since v1.05</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec8.27">8.27 Known problems in v1.09</a>
    <p><a href="#sec9">9.0 Error Codes</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec9.1">9.1 OpenCSM error codes</a>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec9.2">9.2 EGADS error codes</a>
    <p><a href="#sec10">10.0 Bug Reports and Other Feedback</a>
    <p><a href="#sec11">11.0 Copyright</a>
    <p><a href="#sec12">12.0 Glossary</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec1">1.0: Overview</h2>

    <p>The Engineering Sketch Pad (<code>ESP</code>) is a
       browser-based program for creating, editing, and generating
       constructive solid models for use in the multi-disciplinary
       analysis and optimization of engineered systems.  It is built
       using a client-server architecture.

    <p>The server consists of a back-end program
       (<code>serveCSM</code>) that performs the majority of the
       computational work; the server has been designed to work on a
       variety of compute platforms, including UNIX, LINUX, OSX, and
       Windows.  As will be described below, the user
       of <code>ESP</code> typically starts a session by starting the
       server.

    <p>The client, which is built within a web browser, provides the
       graphical user interface with which most users will provide
       inputs and receive outputs.  The supported browsers include
       recent versions of FireFox, Google Chrome, and Safari.
       (Internet Explorer and Edge are not supported because of a bug
       within the WebSockets layer provided by the browser).

    <p><code>ESP</code> is technically just the user-interface to a
      system of software packages, including:
      <ul>
        <li><code>WebViewer</code> is a package for generating complex
            three-dimensional representations of geometry within a web
            Browser.  It consists of software that is incorporated
            into the server as well as a series of JavaScript
            functions that operate in the web Browser via
            <code>WebGL</code>.</li>
        <li><code>OpenCSM</code> is a feature-based, associative,
            parametric solid modeler that supports manifold solids
            (the typical output) and non-manifold sheets and wires
            (such as may be needed for representing wake sheets and
            antennae).  The inputs to <code>OpenCSM</code> is an
            ASCII, human-readable <code>.csm</code> file, in which
            the model is described by a series of design Parameters
            and a Feature Tree (or build prescription).  The Feature
            Tree consists of a user-specified series of standard
            primitives, Boolean operators, and transformations.
            <code>OpenCSM</code> also includes the ability for users
            to define their own user-defined primitives (via compiled
            code) and user-defined components (via scripts).  The
            persistence of Attributes, even through regenerations,
            directly supports the use of <code>OpenCSM</code> within
            multi-fidelity and multi-disciplinary analysis and
            design. <code>OpenCSM</code> also provides the ability
            for a user to compute the sensitivity of a configuration
            with respect to (any combination of) the design
            Parameters, often without regeneration; these
            sensitivities can then be used by a grid-generator so that
            the sensitivity of the grid with respect to the design
            Parameters can be computed.</li>
        <li><code>EGADS</code>, the Electronic Geometry Aircraft
            Design System, is an open-source geometry interface
            to <code>OpenCASCADE</code>, in which the functionality
            in <code>OpenCASCADE</code> that is needed for
            construction of typical applications is incorporated into
            about 70 C-functions.  These functions support a "bottom
            up" approach to configuration construction, in which the
            boundary representation (BRep) is built up from nodes, to
            curves, to edges, to loops, to surfaces, to faces, to
            shells, to bodies.  <code>EGADS</code> also supports a
            "top-down" approach, which directly maps
            to <code>OpenCSM</code>'s Feature
            Tree.  <code>EGADS</code> provides persistent user-defined
            Attributes on all topological entities.</li>
        <li><code>OpenCASCADE</code> is a large, openly-available
            geometry engine on which the rest of the system is
            built.  <code>OpenCASCADE</code> is the only part of
            the <code>ESP</code> system that needs to be acquired from
            an outside source.  See the <code>README.txt</code> file
            associated with the <code>ESP</code> distribution for
            details.</li>
      </ul>

    <p>All the parts of the <code>ESP</code> system are distributed as
       source code that is licensed via the LGPL 2.1 license.  See
       the <a href="#sec11">Copyright</a> section below for details.

    <p>In most cases, a user will start with a configuration that is
       described in a <code>.csm</code> file and then modify it and/or
       build it via <code>OpenCSM</code>'s various commands.

    <p>For a convenient Quick Reference,
       see <code>$ESP_ROOT/doc/ESP_QuickReference.pdf</code>, which is
       a two-page summary of the various <code>.csm</code> commands,
       built-in functions, dot-suffixes, the <code>ESP</code>
       character set, and a brief summary of the meanings of the various
       keypresses in <code>ESP</code>.

    <p><h3 id="sec1.1">1.1 Gallery of cases</h3>

    <p><code>ESP</code> ships with a assortment of
       <code>.csm</code> files, as shown below. Feel free to open them
       in your favorite text editor to see how they were constructed.

       <h4>CanardFighter.csm</h4>
       <img src="gallery/CanardFighter.png" width="100%"/>

       <h4>Cobra.csm</h4>
       <img src="gallery/Cobra.png" width="100%"/>

       <h4>Dragon.csm</h4>
       <img src="gallery/Dragon.png" width="100%"/>

       <h4>FJ2.csm</h4>
       <img src="gallery/FJ2.png" width="100%"/>

       <h4>Hypersonic.csm</h4>
       <img src="gallery/Hypersonic.png" width="100%"/>

       <h4>JMR3.csm</h4>
       <img src="gallery/JMR3.png" width="100%"/>

       <h4>Lander.csm</h4>
       <img src="gallery/Lander.png" width="100%"/>

       <h4>OrionLEV.csm</h4>
       <img src="gallery/OrionLEV.png" width="100%"/>

       <h4>RM-10.csm</h4>
       <img src="gallery/RM-10.png" width="100%"/>

       <h4>Xwing.csm</h4>
       <img src="gallery/Xwing.png" width="100%"/>

    <p>In addition, several students have created models of a variety
       of configurations.  The <code>.csm</code> files for these cases
       are not included in the distribution since they have not been
       cleaned up; nevertheless, the models are very impressive.

      <h4>BulletTrain</h4>
      <img src="studentGallery/BulletTrain.png" width="100%"/>

      <h4>Cessna162</h4>
      <img src="studentGallery/Cessna162.png" width="100%"/>

      <h4>F117</h4>
      <img src="studentGallery/F117.png" width="100%"/>

      <h4>GenericFighter</h4>
      <img src="studentGallery/GenericFighter.png" width="100%"/>

      <h4>LunarLander_11</h4>
      <img src="studentGallery/LunarLander_11.png" width="100%"/>

      <h4>PittsSpecial</h4>
      <img src="studentGallery/PittsSpecial.png" width="100%"/>

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec2">2.0: Tutorials</h2>

    <p>The following tutorials have been designed to walk a
       new <code>ESP</code> user through the basic capabilities that
       are available through the user interface.  The tutorials have
       been designed to be executed in order, since latter tutorials
       assume that the user knows how to perform certain actions that
       were learned in an earlier tutorial. Additional information and
       examples can be found in the training section of the
       <code>ESP</code> distribution.

    <p>Users of <code>ESP</code> who do not plan on using the user
       interface are still encouraged to execute the tutorials, since
       many of the ideas used within <code>OpenCSM</code> (the
       underlying constructive solid modeler) are described in the
       tutorials.

    <p><h3 id="sec2.1">2.1 First tutorial: Basic usage</h3>

    <p>This tutorial will help you understand the use of
       <code>serveCSM</code> and <code>ESP</code> for a variety of
       tasks.  Details about the <a href="#sec3">Command
       Line</a>, <a href="#sec4">cursor and keyboard options</a>, and
       the <a href="#sec6">Example <code>.csm</code> file</a> are
       contained in sections that follow this tutorial.

    <p>The tutorial starts with a pre-made part that is defined by the
       file <code>tutorial1.csm</code>.  (See <a href="#sec6">
       Example <code>.csm</code> file</a> below for a listing of this
       file.)

    <p>To start <code>ESP</code> there are two steps: (1) start the
       "server" and (2) start the "browser".  This can be done in a
       variety of ways, but the two most common follow.

    <p><strong>Technique 1:</strong> issue the two commands:
      <pre>
        setenv ESP_START "open -a /Applications/Firefox.app ../ESP/ESP.html"
        serveCSM ../data/tutorial1
      </pre>
      if using a c-shell; make appropriate changes for your shell
      and/or operating system.

    <p>The first of these tells <code>serveCSM</code> to open FireFox
       on the file <code>../ESP/ESP.html</code>
       when <code>serveCSM</code> has generated a graphical
       representation of the configuration.  The second of these
       actually starts the <code>serveCSM</code> server.  As long as
       the browser stays connected
       to <code>serveCSM</code>, <code>serveCSM</code> will stay alive
       and handle requests sent to it from the browser.  Once the last
       browser that is connected to <code>serveCSM</code>
       exits, <code>serveCSM</code> will shut down.

    <p><strong>Technique 2:</strong> issue the command:
       <pre>
         serveCSM ../data/tutorial1
       </pre>
       Once the server starts, start a browser (for example, FireFox)
       and open the page <code>ESP/ESP.html</code>.  As
       above, <code>serveCSM</code> will stay alive as long as there
       is a browser attached to it.

    <p>Note that the default "port" used by <code>serveCSM</code> is
       7681.  One can change the port in the call
       to <code>serveCSM</code> with a command such as:
       <pre>
         serveCSM ../data/tutorial1 -port 7788
       </pre>

    <p>Once the browser starts, you will be prompted for a
       "hostname:port" as in:
    <p><img src="pictures/ESP-fig01.png" width="100%"/>

    <p>Most of the time, the "hostname" will be "Localhost" (meaning
       that <code>serveCSM</code> and the browser are on the same
       computer).  It is possible to attach to <code>serveCSM</code>
       that is running on another computer by giving an appropriate
       "hostname".

    <p>As mentioned above, it is possible to change the "port" with a
       command line argument when starting <code>serveCSM</code>; if
       that is done, then the alternative "port" must be included in
      <code>ESP</code>'s prompt.

    <p>Once all the setup is done, the browser then presents the
       following 4 windows:
    <p><img src="pictures/ESP-fig02.png" width="100%"/>

    <p>The window on the top left is called the "Tree" window.  At the
       top of this window is a series of buttons.  Below that is a
       scrollable tree-like listing of the Parameters and Branches in
       the Model.  It also contains the controls for the "Graphics"
       window.

    <p>The window on the top right is called the "Graphics" window,
       which contains one of the following:
      <ul>
        <li>a graphical representation of the current configuration,
            in three dimensions;</li>
        <li>a 2D Sketcher; or</li>
        <li>a form (such as when adding or editing a Branch); when a
            form is present, you must press "<strong>Cancel</strong>"
            or "<strong>OK</strong>" in the form to return to the
            graphical representation.</li>
      </ul>

    <p>The window on the bottom left is the "Key" window.  Like the
       "Graphics" window, its contents will be one of:
      <ul>
        <li>the <code>ESP</code> logo;</li>
        <li>an annotated spectrum (that describes the mapping between
            sensitivity values and colors in the "Graphics" window);
            or</li>
        <li>the status of the Sketcher and a listing of the available
            Sketcher commands</li>
      </ul>

    <p>The window on the bottom right is called the "Messages" window.
       It contains the messages that <code>ESP</code> posts for the
       user.

    <p>The first thing to do is to play with the image in the
       "Graphics" window.  This is done with the mouse in the
       following ways:
      <ul>
        <li><strong>Drag</strong>: translate the graphical image</li>
        <li><strong>Shift-Drag</strong>: moving mouse up while
          dragging zooms in while moving the mouse down while dragging
          zooms out.  Note that the mouse wheel can also be used to
          zoom in and out.</li>
        <li><strong>Ctrl-Drag</strong>: rotate the object about its
          center (see below for more details)</li>
        <li><strong>Alt-Drag</strong>: rotate the view about an axis
          that is perpendicular to the screen.
          (Use <strong>Option-Drag</strong> on Mac OSX)</li>
      </ul>
      It is suggested that you use the left or middle mouse button for
      these operations, since in most browsers the right mouse button
      will post a popup menu.

    <p>When using the mouse, it is possible to enter "flying mode", in
       which the view continually changes until the mouse button is
       released.  Flying mode is particularly useful when one needs to
       translate a long distance.  Toggling flying mode is done by
       pressing the "<strong>!</strong>" key in the "Graphics" window.

    <p>At any time, a user might want to "save" a view for later use
       in the browser session.  This is done by pressing the
       "<strong>&gt;</strong>" key in the "Graphics" window; the
       "saved" view can be retrieved by pressing the
       "<strong>&lt;</strong>" key.

    <p>You can also save a view into a file with the
       "<strong>&lt;Ctrl-&lt;&gt;</strong>" or "<strong>,</strong>"
       keys, which will prompt you for a filename.  You can read a
       view file with the "<strong>&lt;Ctrl-&gt&gt</strong>" or
       "<strong>.</strong>" keys, which will prompt you for the view
       filename.  If the file does not exist, nothing will happen.

    <p>The default (home) view can be obtained by pressing either
       "<strong>&lt;Home&gt;</strong>",
       "<strong>&lt;Ctrl-h&gt;</strong>",
       "<strong>&lt;Ctrl-f&gt;</strong>", or the "<strong>H</strong>"
       button near the top of the "Tree" window.  (The home view is
       one in which the x-coordinate increases from left to right and
       the y-coordinate increases from bottom to top.)  One can also
       get the top view by pressing "<strong>&lt;Ctrl-t&gt;</strong>"
       or the "<strong>T</strong>" button, the bottom view by pressing
       "<strong>&lt;Ctrl-b&gt;</strong>" or the "<strong>B</strong>"
       button, the left side view by pressing
       "<strong>&lt;Ctrl-l&gt;</strong>" or the "<strong>L</strong>",
       or the right side view by pressing
       "<strong>&lt;Ctrl-r&gt;</strong>" or the "<strong>R</strong>"
       button.

    <p>The function of the arrow keys depends on whether "flying mode"
       is active or not.  For example, if "flying mode" is not active
       (the default), pressing the "<strong>&lt;Left&gt;</strong>" key
       causes the object to rotate to the left by 30 degrees; if
       "flying mode" is active (because the "<strong>!</strong>" key
       was pressed), then pressing the "<strong>&lt;Left&gt;</strong>"
       key causes the object on the screen to translate to the left.
       If the "<strong>Shift</strong>" is held while
       the "<strong>&lt;Left&gt;</strong>" key is pressed, the
       increments are 5 degrees and the translations are also smaller.

    <p>The "<strong>&lt;PgUp&gt;</strong>" or
       "<strong>&lt;Ctrl-i&gt;</strong>" keys or the
       "<strong>+</strong>" button can be used to zoom in and the
       "<strong>&lt;PgDn&gt;</strong>" or
       "<strong>&lt;Ctrl-o&gt;</strong>" key or the
       "<strong>-</strong>" button can be used to zoom out.  The
       behavior of these keys/buttons does not depend on the current
       "flying mode".

    <p>To re-center the image at a given point and simultaneously
       reset the point about which mouse rotations will occur, point
       to any location in the "Graphics" window and press
       "<strong>*</strong>" or "<strong>8</strong>"; the image will be
       recentered and a message will be posted in the "Messages"
       window.

    <p>To determine the identity of any object in the "Graphics"
       window, simply put your cursor on the object and press
       "<strong>^</strong>" or "<strong>6</strong>"; a summary of the
       identified object is shown in the "Messages" window.  (Note
       that if the cursor is not exactly over any object, the message
       will only be posted once the mouse passes over a graphic
       object.)

    <p>To determine the approximate coordinates of any location in the
       "Graphics" window, simply put your cursor on the location and
       press "<strong>@</strong>" or "<strong>2</strong>"; the
       approximate coordinates of the location are shown in the
       "Messages" window.

    <p>To add an Attribute to any Face or Edge, simply put your cursor
       on the object in the "Graphics" window and press
       "<strong>A</strong>" (upper case A). You will then be asked for
       the name of the new Attribute as well of its value, which can
       either be a string (if is starts with a $) or a semi-colon
       separated list of expressions.

    <p>Lastly, to get help on the commands that are available in the
       "Graphics" window, press "<strong>?</strong>" and a short
       listing will be given in the "Messages" window.

    <p>The results of several of these commands is shown in:
    <p><img src="pictures/ESP-fig03.png" width="100%"/>

    <p>Now it is time to understand the "Tree" window.  When not in
       the Sketcher (the default), at the top of
       the "Tree" window is a series of buttons:
      <ul>
        <li>"<strong>File</strong>": this button pops up a menu that
        contains:
          <ul>
            <li>"<strong>New</strong>": this button removes the
              current Model (after prompting the user) and starts a
              new Model</li>
            <li>"<strong>Open</strong>": this button removes the
              current Model (after prompting the user) and opens the
              user-specified <code>.csm</code> file and builds its
              Model</li>
            <li>"<strong>Export FeatureTree</strong>": allows a user
              to save the current Feature Tree and Parameters into
              a <code>.csm</code> file.  Beware that using this option
              will over-write any file, causing you to lose any
              formatting or comments that may be in the original
              file</li>

            <li>"<strong>Edit</strong>": allows a user to edit the
              current <code>.csm</code> file</li>
            </ul>
            The <strong>File</strong> menu can be removed by
            re-pressing the "<strong>File</strong>" button.
        <li>"<strong>StepThru</strong>": this button enters StepThru
            mode (described below)</li>
        <li>"<strong>Help</strong>": this button opens up
            the <code>ESP</code> HELP document (that you are now
            reading)</li>
        <li>"<strong>Up to date</strong>": the meaning and text on this
            button will change (as described below)</li>
        <li>"<strong>Undo</strong>": allows a user to un-do any changes
            to the Model (as described below)</li>
        <li>"<strong>H</strong>": return to the home (front) view  ("x"
            right and "y" up)</li>
        <li>"<strong>L</strong>": left-side view ("z" right and "y"
            up)</li>
        <li>"<strong>R</strong>": right-side view ("z" left and "y"
            up)</li>
        <li>"<strong>B</strong>": bottom view ("x" right and "z"
            up)</li>
        <li>"<strong>T</strong>": top view ("x" right and "z"
            down)</li>
        <li>"<strong>+</strong>": zoom in</li>
        <li>"<strong>-</strong>": zoom out</li>
      </ul>
      One can verify the view with the little axes at the bottom-left
      corner of the "Graphics" window.  The red axis corresponds to
      "x", the green axis corresponds to "y", and the blue axis
      corresponds to "z".

    <p>Below the buttons is a tree-like representation of the "Design
       Parameters", "Local Variables", and "Branches" that describe
       the current Model.  In all cases, pressing the
       "<strong>+</strong>" at the beginning of any line expands
       (opens up) that particular entry in the tree; pressing the
       "<strong>-</strong>" at the beginning of any line collapses
       (closes) that particular entry.

    <p>Start off by pressing the "<strong>+</strong>" to the left of
       the words "Design Parameters".  When this is done, all the
       Design Parameters in the current Model are displayed as shown
       in:
    <p><img src="pictures/ESP-fig04.png" width="100%"/>

    <p>Notice that the Design Parameter names are shown in green type;
       this indicates that the Parameter can be "edited" by the user;
       the Local Variable names are listed in black type and cannot be
       edited.

    <p>Now there are two ways to proceed.  The following paragraphs 
       describe the legacy method, using
       the <code>ESP</code> user interface.  This method is similar to
       other CAD systems, but experienced users find that using the
       integrated <code>.csm</code> editor to be much faster and
       easier to debug; it is described at the end of this tutorial.

    <p>Press on the label "Lbar" to edit the Parameter named "Lbar".
       When this is done, the user is provided with an editing form
       that asks for the new value; the current value is pre-loaded in
       this window, as in:
    <p><img src="pictures/ESP-fig05.png" width="100%"/>

    <p>For now change the value from "6" to "9" and  press the
       "<strong>OK</strong>" button or press the "<strong>Enter</strong>"
       key.  Note that the Parameter name is now listed in red (to
       indicate that it has been changed) and that the button at the
       top of the "Tree" window has changed to a green button that
       says "<strong>Press to Re-build</strong>".  This tells the user
       that changes have been made (to either a design Parameter or
       Feature Tree), but that the configuration shown in the
       "Graphics" window has not been updated.  (The reason this is
       done is that a user might want to make several changes to the
       "Model" before spending the CPU time necessary to re-build.)

    <p>Press the "<strong>Press to Re-build</strong>" button and
       notice that it first turns yellow while the configuration is
       being rebuilt.  Then (after a few seconds) the image in the
       "Graphics" window will be updated and the "Design Parameters"
       will no longer be red.

    <p>We will now change the value of "Lbar" back to "6".  (Do not
       re-build yet.)

    <p>Collapse the Parameters by pressing the "<strong>-</strong>" to
       the left of the word "Design Parameters" and expand the
       Branches by pressing the "<strong>+</strong>" to the left of
       the word "Branches".  This will result in a screen that looks
       like:
    <p><img src="pictures/ESP-fig06.png" width="100%"/>

    <p>There is an "Undo" button near the top of the "Tree" window.
       This button un-does your last change; an example of using this
       is shown later in this tutorial; for now, try not to use this
       button.

    <p>We are going to want to add a SPHERE to this configuration.
       Do this by pressing "<strong>Branches</strong>", giving you:
    <p><img src="pictures/ESP-fig07.png" width="100%"/>

    <p>The different types of Branches that can be added are listed in
       groups.  The groups at the top, which are labeled, generally
       construct or modify Bodys.  The Branches listed at the bottom
       are utilities, which generally effect the order in which the
       Branches are executed.  Those Branches marked with a star (*)
       are deprecated, meaning that they may be removed in future
       versions of ESP.

    <p>We will choose a SPHERE and press the "<strong>OK</strong>"
       button (or press the "<strong>Enter</strong>" key), giving us:
    <p><img src="pictures/ESP-fig08.png" width="100%"/>

    <p>Now fill in the entries with "xcent" set to "1", "ycent" set to
       "0", "zcent" set to "0", and "radius" set to "2".  An easy way
       to cycle through the various entries is to press
       the "<strong>Tab</strong>" key. Press the "<strong>OK</strong>"
       button (or "<strong>Enter</strong>" key) and then "<strong>Press
       to Re-build</strong>" and you should see:
    <p><img src="pictures/ESP-fig09.png" width="100%"/>

    <p>Now let's look at the "Display" part of the "Tree" window.  By
       default "Display" is expanded and you can see that you have two
       bodies named "Body 10" and "Body 9".  Expand the listing for
       Body 9 by pressing the "<strong>+</strong>" to the left of
       "Body 9" and you will see entries for Faces, Edges, Nodes, and
       Csystems.  To the right of "Faces" (below "Body 9") you will
       see three items:
      <ul>
        <li><strong>Viz</strong>: toggles the visibility of all Faces
          associated with Body 9</li>
        <li><strong>Grd</strong>: toggles the grids associated with all
          the Faces in Body 9</li>
        <li><strong>Trn</strong>: toggles the pseudo-transparency of
          all the Faces associated with Body 9</li>
      </ul>
      Try each of these and see what happens.  (Notice that Body 9 is
      the original solid and Body 10 is the new sphere.)

      In addition, you can also change the display characteristics
      with key-presses in the Graphic window.  Hover over an entity
      and press:
      <ul>
        <li>"<strong>v</strong>" to toggle the visibility (Note that
          you will need to turn visibility on in the Tree Window since
          there is nothing to point to to turn it on in the Graphics
          Window.)</li>
        <li>"<strong>g</strong>" to toggle the grid</li>
        <li>"<strong>t</strong>" to toggle the transparency</li>
        <li>"<strong>o</strong>" to toggle the orientation</li>
      </ul>

    <p>Notice also that there is a "<strong>+</strong>" to the left of
       "Faces", which indicates that you can interact with the object
       on a Face-by-Face basis.  The basic rules here are:
      <ul>
        <li>changes made to a specific entity (such as a Face or Edge)
          applies only to that entity</li>
        <li>changes made to the heading (such as "Faces") applies
          to all Faces in the group</li>
        <li>changes made at the Body level applies to all Faces and
          Edges in the body</li>
      </ul>

    <p>When you have a configuration with lots of Bodys, it is
       sometimes useful to turn the visibility of all Faces, Edges, or
       Nodes (in all Bodys) on or off.  This can be done by pressing
       on the word "<strong>Display</strong>" in the Key Window.

    <p>Now let's combine the sphere and the original solid by adding a
       UNION Branch.  (Press "<strong>Branches</strong>" and add a
       UNION).  This operation wants to know if the operation should
       be applied to the top two Bodys on the stack (tomark=0) or to
       all the Bodys on the stack since the last mark (tomark=1).  For
       now, we want to use the default (tomark=0).  Also, we want an
       untrimmed union (the default), and so set (trimList=0).
       Lastly, we do not want to modify the tolerances associated with
       this operation, so use the default (maxtol=0).  Re-build the
       configuration and you should get the solid shown in:
    <p><img src="pictures/ESP-fig10.png" width="100%"/>

    <p>Note that we now only have one body. (Body 11)

    <p>After some thought you realize that you really didn't want the
       union (or fusion) of these two volumes, but instead you wanted
       the solid that is common to them (that is, their intersection).
       First, remove the UNION; this can easily be done by clicking on
       "Brch_00012" and then choosing "Delete this Branch".
       (Alternatively you could press the "Undo" button at the top of
       the "Tree" window; but if you use "Undo" the Branch numbering
       will be slightly different, making it slightly more difficult
       to follow the directions in this tutorial.)

    <p>Now add the intersection by pressing
       "<strong>Branches</strong>" and then choosing INTERSECT.
       This operation wants to know what happens if more than one
       solid is produced by the operation.  Specifically, the "$order"
       argument describes how the bodies that are produced should be
       ordered: for example in order of volume, surface area, ...  The
       "index" argument tells which body in the list should be
       selected.  Since we are only expecting one body to be produced,
       we can leave the defaults.  Also, for now we do not want to
       modify the tolerances, so leave the default (maxtol=0) and then
       "<strong>Press to Re-build</strong>", producing:
    <p><img src="pictures/ESP-fig11.png" width="100%"/>

    <p>You notice that the "head" is too thin, and so you change the
       "radius" of the SPHERE to "2.3".  (Press "Brch_000011" and
       change the "radius".)  While you are at it, change the
       Parameter "Rbar" to "0.4" (you will need to expand the Design
       Parameters) and rebuild, producing:
    <p><img src="pictures/ESP-fig12.png" width="100%"/>

    <p>Now we want to drill a hole through the center of the shaft;
       this is done by subtracting a cylinder from the solid.  Create
       a cylinder by selecting "<strong>Branches</strong>" and
       CYLINDER.  We want the hole to go the entire length of the
       configuration (which is centered and whose length is 2*L), and
       so we enter "-1.2*L" for "xbeg" and "+1.2*L" for "xend"; the
       "1.2" simply ensures that the cylinder extends beyond the end
       of the configuration.  Since it is on the centerline, set
       "ybeg", "zbeg", "ybeg", and "yend" all to "0", and finally the
       "radius" to "0.2".

    <p>Note that any argument can either be entered as a numeric
       constant or as an expression (using Matlab-like syntax),
       possibly using the name of a Design Parameter (such as "L") or
       a Local Variable.

    <p>To add the SUBTRACT Branch, we will click on
       "<strong>Branches</strong>" and then choose SUBTRACT, use the
       defaults and rebuild, producing:
    <p><img src="pictures/ESP-fig13.png" width="100%"/>

    <p>You can now proceed to the <a href="#sec2.1c">common part of
       the tutorial</a> or take a detour to explore the new
       integrated <code>.csm</code> editor (which is next).

    <p>Now we want to create a series (pattern) of small holes that
       are drilled across the shaft.  Start by creating a new
       Parameter (by clicking on "<strong>Design Parameters</strong>")
       and name it "Rhole".  The rules for names is that they must
       start with a letter and contain up to 32 letters, digits,
       colons, and underscores.  By default the new "<strong>Design
       Parameter</strong>" contains only one value (that is, it is a
       scalar).  (Aside: If one wants a row vector, a column vector,
       or a 2D matrix, press the "<strong>Add row</strong>" or
       "<strong>Add column</strong>" button before entering values in
       the table.)

    <p>Since we only want a scalar, just use the standard form, such
       as:
    <p><img src="pictures/ESP-fig14.png" width="100%"/>

    <p>Set the (only) value to "0.08".  You can either press the
       "<strong>OK</strong>" button or press
       the "<strong>Enter</strong>" key to save this value.

    <p>Now we are going to add a pattern of holes.  Do this by adding
       a new PATBEG Branch; the "$pmtrName" will be "i" and the
       "ncopy" will be 7 (since we want 7 holes).  (The "$" at the
       beginning of "$pmtrName" says that this is the name of the
       Parameter that will be created rather than the value of the
       Parameter "i").  This will produce a warning in the Messages
       window that informs us that we do not yet have a matching
       PATEND statement yet.

    <p>Also add a CYLINDER with "xbeg" and "xend" set to "i/3", "ybeg"
       and "yend" set to "0", "zbeg" set to "-1", "zend" set to "+1",
       and "radius" set to "Rhole".  Press "<strong>OK</strong>" or
       "<strong>Enter</strong>".  Again you will get the warning
       telling you that you still do not have a matching PATEND.

    <p>We would now like to name this Branch.  To do this, edit the
       Branch (by pressing "Brch_000017") and change its "Name" to
       "small_holes".  (Notice that we could not name it when we
       created it since the names are originally auto-created to
       ensure that we do not get an illegal name.)

    <p>Next add another SUBTRACT Branch (with the default arguments)
       and finally a PATEND Branch and then re-build (which will take
       several seconds), giving:
    <p><img src="pictures/ESP-fig15.png" width="100%"/>

    <p>Now we want to change the hole in the center of the shaft into
       a hole that starts at "xbeg" equal to "0".  Make the change to
       "Brch_000014" and re-build.  To see if you were successful,
       change the visibility of the faces and ensure that you have the
       correct hole, as in:
    <p><img src="pictures/ESP-fig16.png" width="100%"/>

    <p>Now change the cylindrical hole into a conical hole.  To do
       this, we must delete the cylinder hole (which is Brch_000014).
       Click on "Brch_000014" and choose "Delete this Branch".  Notice
       that doing this warns you that the Branches are not properly
       nested.  To fix the error, add a conical hole after
       "Brch_000013" by clicking "Brch_000013" and choosing "Add new
       Branch after this Branch", as in:
    <p><img src="pictures/ESP-fig17.png" width="100%"/>

    <p>Re-build and notice that the vertex of the cone is near the
       head; you will have to change the visibility of the Faces to
       see this.  We had meant to do it the other way, so change
       "xvrtx" to "0" and "xbase" to "1.2*L" and re-build, producing
       (after manipulating the display):
    <p><img src="pictures/ESP-fig18.png" width="100%"/>

    <p>A new ESP feature is to visually step through the build
       process.  This is particularly useful when you want to
       understand the build process that was used in
       a <code>.csm </code> file that you acquired from another
       source.  To do this press the "<strong>StepThru</strong>"
       button and you should see:
    <p><img src="pictures/ESP-fig19.png" width="100%"/>

    <p>This is the result of executing the first Branch that created a
       Body. You can now press "<strong>NextStep</strong>" four times
       and you should see:
    <p><img src="pictures/ESP-fig20.png" width="100%"/>

    <p>You can either continue pressing the
       "<strong>NextStep</strong>" button (or press the
       "<strong>n</strong>" key in the Graphics window (for next))
       until you get to the end of the build, you can press the
       "<strong>p</strong>" key for previous, or you can press
       "<strong>Cancel StepThru</strong>" in the Tree Window to return
       to the normal viewing mode.

    <p>By now you probably have noticed that the Branches with a
       pattern (that is, between the PATBEG and PATEND) are hidden; to
       see these, press the <strong>+</strong> to the left
       of <strong>Brch_000016</strong>. Now let's rotate the small
       holes, so after the "small_holes" Branch, add a ROTATEX with
       arguments "-15*(i-1)", "0", and "0", and rebuild, producing:
    <p><img src="pictures/ESP-fig21.png" width="100%"/>

    <p>Now we will experiment with the "activity" of the Branches.  A
       Branch that is "suppressed" is skipped during the re-build
       process. So click on "Brch_000021" (you will need to
       expand the listing of the pattern first) and change the
       "Activity" from "Active" to "Suppressed", and select
       "<strong>OK</strong>" or press "<strong>Enter</strong>".  When
       you rebuild, you should see:
    <p><img src="pictures/ESP-fig22.png" width="100%"/>

    <p>Re-activate "Brch_000021" and re-build.

    <p>Another feature is <code>ESP</code> allows a user to only build
       part of the configuration.  This is done by clicking on a
       Branch (for example, "Brch_000010") and choosing "Build to this
       Branch", giving:
    <p><img src="pictures/ESP-fig23.png" width="100%"/>

    <p>To rebuild the whole configuration, either re-build to the last
       Branch by clicking it and choosing "Build to this Branch" or
       press the "Up to date" button (which will ask if you are sure
       before regenerating the configuration).

    <p>The next part of the <code>ESP</code> tutorial involves
       Attributes.  Each Branch can have zero or more Attributes
       associated with it that are carried throughout the build
       process.  Open the "Brch_000009" Branch for editing and press
       "<strong>Show Attributes/Csystems</strong>".  You will see that
       this Branch has an Attribute ("clipper") that has the value
       "1".  Change the Attribute to "10", and
       press <strong>OK</strong>.

    <p>We can add an Attribute to "Brch_000009" by editing it,
       pressing "<strong>Show Attributes/Csystems</strong>", and then
       "<strong>Add Attribute/Csystem</strong>".  The first choice is
       whether we want to add an Attribute or a Csystem; we want to
       enter "1"; we will use the name "test" and the value "ESP".
       After some thought, you realize that "ESP" is not defined (that
       is, does not have a value), so you can "undo" this change by
       pressing the "Undo" button at the top of the "Tree" window.
       Re-build.

    <p>Now point to the face that represents the corner of the head
       (as shown with its grid here) and press the
       "<strong>^</strong>" or "<strong>6</strong>" key, producing:
    <p><img src="pictures/ESP-fig24.png" width="100%"/>

    <p>(Depending on the version of OpenCASCADE that you are using,
       the face number that is returned may be different.)

    <p>Note that the "Messages" window contains a description of the
       face including the Attribute that we edited ("clipper" is "10")
       as well as a "_body" and "_brch" Attribute.  The latter tells
       which Branch ("Brch_000009") was responsible for generating
       that face.

    <p>You can also add Attributes graphically.  Point to the same
       Face and press the "<strong>A</strong>" key.  When prompted for
       an Attribute name, enter "partID", and when prompted for the
       Attribute value, enter the semicolon-separated list
       "1;2;sqrt(3)".  (Alternatively, you could have entered
       "$1;2;sqrt(3)" to add that string value, as signified by the
       leading dollar sign ($)). Rebuild.  Then press
       the "<strong>^</strong>" key to verify that the Face has your
       new Attribute.

    <p>A unique feature of ESP is that it allows a user to compute the
       sensitivity of the configuration with respect to any
       perturbation in the specified Parameters.  Most often this is
       done by clicking on a the name of one of the Design Parameters
       and selecting "<strong>Compute Sensitivity</strong>".

    <p>For the current case, expand the Parameters list (in the Tree
       window) and click on "Rbar" and select "<strong>Compute
       Sensitivity</strong>".  ESP notes this by putting a caret
       before the "Rbar" and then will automatically compute the
       sensitivity and display, in the Graphics window, an updated
       configuration that is colored based upon the change in the
       local surface normal; positive sensitivity indicates that the
       surface will tend to move in the direction of the outward
       normal.  The Key window will show the meanings of the various
       colors and will be titled "d(norm)/d(Rbar)", as in:
    <p><img src="pictures/ESP-fig25.png" width="100%"/>

    <p>To change the limits of the color spectrum, left click in the
       Key window and you will be prompted for the minimum value
       (associated with blue) and the maximum value (associated with
       red). Try clicking on the Key window and set the limits to
       "-0.5" and "+0.5" and see how the display changes.

    <p>Now ask for the sensitivity with respect to "D" (click on "D"
       and select "<strong>Compute Sensitivity</strong>") and again
       the display will automatically update.

    <p>Occasionally one wants to know the change in the configuration
       based upon the perturbation of more than one Parameter (at the
       same time).  To do this, first click on "Rbar" and clear all
       the Design Velocities by clicking on "<strong>Clear Design
       Velocities</strong>", and then "<strong>Set Design
       Velocity</strong>" to 1; then click on "Rhole" and "<strong>Set
       Design Velocity</strong>" to 1.5.  Now manually re-build the
       configuration (since you may want to set the Design Velocity
       for multiple Parameters before rebuilding).  Note that the
       legend in the Key window will now be "d(norm)/d(***)",
       indicating that there was either more than one Design Parameter
       for which the Design Velocity was set (see that Rbar and Rhole
       both are pre-pended with a caret to indicate this), or there is
       one Parameter whose Design Velocity is not unity (and hence the
       color does not show sensitivity but rather a scaled
       sensitivity.)

    <p>Save your work by pressing the "<strong>File</strong>" button,
       then the "<strong>ExportFeatureTree</strong>" button, and
       finally entering "tutorial1_new.csm" as the name of the new
       file.

    <p>Now explore the <strong>.csm</strong> editor.  Choose
       "<strong>File</strong>" button, then the
       "<strong>Edit</strong>" button.  The version of your file will
       be displayed.  The buttons across the top perform various
       editing tasks.
    <p><img src="pictures/ESP-fig26.png" width="100%"/>

    <p>The integrated editor has a row of buttons at the top:
      <ul>
        <li>"<strong>Copy</strong>": take highlighted text and puts a
          copy of it into the clipboard
        <li>"<strong>Cut</strong>": remove highlighted text and put it
          into the clipboard
        <li>"<strong>Paste</strong>": put copy of the clipboard at the
          current cursor location
        <li>"<strong>Search</strong>": look for a string (see prompt
          near top of screen). The search is case sensitive.
        <li>"<strong>Prev</strong>": look for previous occurrence of
          current search string
        <li>"<strong>Next</strong>": look for next occurence of
          current search string
        <li>"<strong>Replace</strong>": replace current search string
          with the replacement text (see prompt near top of screen)
        <li>"<strong>Comment</strong>": for the current highlighted
        text
          <ul>
            <li>if the first line is uncommented, comment all lines that
              are highlighted
            <li>if the first line is commented, uncomment all lines
              that are highlighted (if possible)
          </ul>
        <li>"<strong>Indent</strong>": use standard indentation for
          all highlight lines
        <li>"<strong>Hint</strong>": provide a hint of the arguments
          associated with the line at the current cursor (see top of
          screen for hint)
        <li>"<strong>Undo</strong>": undo the last change
        <li>"<strong>Cancel</strong>": exit the editor and do not save
          changes
        <li>"<strong>Save</strong>": save the changes and exit the
        editor
          <ul>
            <li>if editing the <code>.csm</code> file and there are no
              current <code>.udc</code> files, then the configuration
              is automatically rebuilt
            <li>otherwise, you will need to press "<strong>Press to
                Rebuild</strong>" to rebuild the configuration
          </ul>
      </ul>

    <p>Note that the text in the file is colored:
      <ul>
        <li>comments are show in <strong>grey</strong>
        <li>command names are shown in <strong>blue</strong> (this is
          an easy way to check that you have spelled the command name
          correctly)
        <li>parameter names are shown in <strong>yellow</strong>
        <li>numbers are shown in <strong>green</strong>
        <li>strings are shown in <strong>magenta</strong>
        <li>quotation marks (which show the extent of an argument) are
          shown in <strong>cyan</strong>
      </ul>

    <p>Start by highlighting lines 12 and 13 and then press the
       "<strong>Copy</strong>" button.  You can then move your  cursor
       to the beginning of line 14 and press "<strong>Paste</strong>",
       which will insert the copied text.  Highlight lines 14 and 15
       and press "<strong>Cut</strong>" to remove the text you just
       added.

    <p>Place your cursor on somewhere on line 1 and press the
       "<strong>Search</strong>" button.  At the top, enter "Rbar" and
       press <strong>Enter</strong>.  You can press
       "<strong>Next</strong>" and "<strong>Prev</strong>" to go to
       the next and previous occurrences.  You can replace text using
       the "<strong>Replace</strong>" button.

    <p>You can provide block-comments.  Highlight lines 42 through 44
       and press the "<strong>Comment</strong>" button to add a
       block-comment.  If you now highlight line 43 and press
       "<strong>Comment</strong>" again, you will see that line 43 was
       uncommented (since the first highlighted line contains a
       block-comment). Remove the whole block-comment by highlighting
       lines 42 through 44 and pressing "<strong>Comment</strong>"
       again.

    <p>The "<strong>Hint</strong>" button gives you a hint on the
       current command.  For example, pressing the button with the
       cursor somewhere on line 29 show the hint for the CYLINDER
       command at the top of the editor window.

    <p>Finally exit the browser and you should see
       that <code>serveCSM</code> also shuts down.

    <p>If we now rename the file journal file (which was automatically
       generated while you were running ESP) with:
      <pre>
        mv port7681.jrnl tutorial1.jrnl
      </pre>
      we can replay our session by the command:
      <pre>
        serveCSM ../data/tutorial1 -jrnl tutorial1.jrnl
      </pre>
      This replays all your operations, so it may take a while to
      execute.

    <p>Alternatively, we can start with the new
      <code>tutorial1_new.csm</code> file (which we just created
      above) with the command:
      <pre>
        serveCSM tutorial1_new
      </pre>
      This will run more quickly since it simply executes the final
      Feature Tree (of Branches).

    <p>This tutorial covered most of <code>ESP</code>'s user
       interface.  Further details are contained in the sections that
       follow.

    <p>Now we will learn how to develop a configuration using the
       integrated editor.  Make a copy of the
       original <code>.csm</code> file and
       restart <code>serveCSM</code>.
      <pre>
       cp       ../data/tutorial1.csm ../data/tutorial1_temp.csm
       serveCSM ../data/tutorial1_temp
      </pre>
      or
      <pre>
       copy     ..\data\tutorial1.csm ..\data\tutorial1_temp.csm
       serveCSM ..\data\tutorial1_temp
      </pre>

    <p>Start by pressing the "<strong>File</strong>" button and then
       "<strong>Edit: ../data/tutorial1_temp.csm</strong>".  This will
       display the contents of the (original) tutorial file in code
       form. Notice at the top you have Design Parameters with their
       given values which are followed by the Branches and their
       arguments.

    <p>Start by finding the Design Parameter "Lbar", shown in the line
       "<code>despmtr Lbar 6.00</code>" on your screen. You can edit
       this parameter by simply changing the number. Do this now,
       change the "6.00" to "9.00" and then press
       "<strong>Save</strong>". This will change the length of the bar
       and automatically rebuild the model.

    <p>Return to "<strong>Edit</strong>" and change the value of
       Lbar back to 6.00, but do not save yet. We will now add a
       SPHERE branch to the model. To do this, add a line under the
       "intersect" corresponding to "clip weights with outer cylinder"
       that reads "SPHERE".  This branch needs four arguments, which
       are "xcent", "ycent", "zcent" and "radius". If you would like
       to see for yourself, put your cursor somewhere in the word
       "SPHERE" and then press the "<strong>Hint</strong>" button at
       the top of the screen. This button will tell you the required
       arguments for any branch you add. Now set these arguments as
       "xcent" set to "1", "ycent" set to "0", "zcent" set to "0", and
       "radius" set to "2"; in other words, add the line "<code>SPHERE
       1 0 0 2</code>" and press "<strong>Save</strong>".

    <p>Now try to combine the sphere and the original solid by adding
       a "UNION" Branch under the line that starts with
       "SPHERE". Re-build by saving the edits. Notice that this is not
       the shape we wanted. To fix this replace the "UNION" Branch
       with an "INTERSECT" Branch and save again.

    <p>Now you can see that the head of our shape is too thin, so
       increase the radius of the sphere from "2" to "2.3", and while
       you are at it change the design parameter "Rbar" to "0.4".

    <p>The next step is to create a hole through the center of the
       shaft. To do this we will create a CYLINDER and then SUBTRACT
       it from the solid. Create a new "CYLINDER" Branch with
       the arguments "-1.2*L" and "+1.2*L" for "xbeg" and "xend"
       respectively, as well as "0" for "ybeg", "zbeg", "yend", and
       "zend". Finally, set "radius" to "0.2".  Remove the material in
       this new
       cylinder from the existing solid by adding a "SUBTRACT" Branch under the
       new "CYLINDER" line.  In other words, add the lines
      <pre>
       CYLINDER  -1.2*L  0.0  0.0  +1.2*L  0.0  0.0  0.2
       SUBTRACT
      </pre>
       and "<strong>Save</strong>".

    <p>As you can see, the ideas are the same as using
       the <code>ESP</code> Tree Window, but experienced users find it
       much faster using the integrated editor.

    <p><h3 id="sec2.2">2.2 Second tutorial: Sketcher</h3>

    <p>For the second tutorial, we will start <code>serveCSM</code>
       without a <code>.csm</code> file and investigate the use of the
       Sketcher.

    <p>Start <code>ESP</code> by issuing the command:
      <pre>
        serveCSM
      </pre>

    <p>If you have not set the <code>ESP_START</code> environment
       variable, you will have to open a browser on a file
       named <code>../ESP/ESP.html</code> and select the default
       hostname and port (Localhost:7681).  A blank
       <code>ESP</code> should open up for you.

    <p>We are going to start with an empty sketch.  To do this we will
       first add a SKBEG Branch by pressing
       "<strong>Branches</strong>", selecting a SKBEG, and making
       the "x", "y", and "z" all zero.  The final
       argument, <code>relative</code>, is set to 1 to indicate that
       all coordinates in the sketch are relative to the coordinates
       that were contained in the SKBEG statement.

    <p>When a SKBEG Branch is added, ESP now automatically adds the
       matching SKEND Branch and automatically enters the Sketcher.

    <p>There are several changes between normal 3D mode and the
       Sketcher.  The first difference are the buttons on the top of
       the "Tree" window.  A second button has now appeared that is
       labeled "<strong>Sketch</strong>", which will pop up a menu
       with the entries:
      <ul>
        <li>"<strong>Save</strong>": this will save the current Sketch
          and exit the Sketcher</li>
        <li>"<strong>Quit</strong>": this will exit the Sketcher (with
          all the work done in the Sketcher being lost)</li>
      </ul>

    <p>The legend on another button has now changed to
       "<strong>Drawing...</strong>", which describes the status of
       the Sketcher.

    <p>Also, the "Key" window now lists the Sketcher's status, in
       terms of the number of degrees of freedom (<code>ndof</code>)
       and the number of constraints (<code>ncon</code>).  This is
       followed by a listing of the available commands in the
       Sketcher.

    <p>Within the Sketcher (which is displayed in the "Graphics"
       window), there is a point at the center that has the legend
       "XY" and a blue line between that point and the current cursor
       location.  As you move the cursor around in the Sketcher, you
       will notice that the blue line follows the cursor.  You will
       also notice that if the line is approximately horizontal or
       vertical, it will change from blue to orange; this is an
       indication that if the current cursor location is chosen (see
       below), an implicit "horizontal" or "vertical" constraint will
       be created.

    <p>As you can see in the "Key" window, you have 6 choices:
      <ul>
        <li><strong>l</strong> - create a line segment (LINSEG) in the
          sketch</li>
        <li><strong>c</strong> - create a circular arc (ARC) in the
          sketch</li>
        <li><strong>s</strong> - add a spline point (SPLINE) to the
          sketch</li>
        <li><strong>b</strong> - add a Bezier control point (BEZIER)
          to the sketch</li>
        <li><strong>z</strong> - add a zero-length segment</li>
        <li><strong>o</strong> - finish the sketch (that is, leave a
          sketch open)</li>
      </ul>

    <p>If you just press the mouse button, the "<strong>l</strong>"
       option will be chosen for you.  So now, draw the sketch shown
       in:
    <p><img src="pictures/ESP-fig27.png" width="100%"/>
    <p>in a counter-clockwise direction, starting at the point with
       the label "XY".  Make sure that when you have completed the
       closed sketch, the last point should be the same as the first
       point.  You can ensure this by noting that a circle is placed
       around the first point if the last point is "close enough".

    <p>Notice that several of the line segments have either the letter
       "H" or "V" associated with them.  These "horizontal" or
       "vertical" constraints were automatically added for you since
       you pressed "<strong>l</strong>" or the mouse button when the
       line was orange.  Also notice that since you "closed" the
       sketch, it got filled in with grey.  (If you had left it open
       by pressing the "o" key, there would be no filling.)

    <p>Your completed sketch should now have 16 degrees of freedom
       (since there are 8 points and no arcs) and 10 constraints.  To
       see what the meaning of the various constraint letters are,
       notice that the "Key" window has now changed to explain the
       meaning of the constraints.  In summary, at the first point,
       both the "x" and "y" coordinates are fixed.  The other
       constraints are that certain line segments are either
       constrained to be horizontal (H) or vertical(V).

    <p>Since the number of constraints is fewer than the number of
       degrees of freedom, we will have to add more constraints.

    <p>If you do not know what constraint(s) to add, press the
       "<strong>Constraining...</strong>" button and several choices
       will be presented to you (in green), as in:
    <p><img src="pictures/ESP-fig28.png" width="100%"/>
    <p>We will choose the following:
      <ul>
        <li>put the cursor over the middle of the bottom segment and
          press "<strong>L</strong>" (which will set its length) and
          enter "4" in the pop-up</li>
        <li>put the cursor over the left vertical line, press
          "<strong>L</strong>" and enter "3"</li>
        <li>put the cursor over the right vertical line, press
          "<strong>L</strong>" and enter "3"</li>
        <li>put the cursor over the horizontal segment at the
          top-left, press "<strong>L</strong>", and enter "1"</li>
        <li>put the cursor over the horizontal segment at the
          top-right, press "<strong>L</strong>", and enter "1"</li>
        <li>put the cursor over the vertical segment on the left side
          of the slot, press "<strong>L</strong>", and enter "2"</li>
      </ul>

    <p>Since the number of constraints matches the number of degrees
       of freedom, the grey fill has changed to a light green fill and
       the first button has turned green with the legend
       "<strong>Press to Solve</strong>".  Press that button and
       (hopefully) your sketch will solve.  (If it does not, you can
       always remove constraints by moving the cursor over the
       constraint and pressing "<", which deletes selected constraints
       at that point or on that segment.)  To center the image, either
       press <Ctrl-H> or press the "<strong>H</strong>" button.  You
       screen should look like:

    <p><img src="pictures/ESP-fig29.png" width="100%"/>

    <p>We are now finished with the Sketcher (for now), so press
       "<strong>Sketch</strong>" and then "<strong>Save</strong>" to
       return to the normal 3D view.  You can now press "<strong>Press
       to Re-build</strong>" to rebuild the 3D object, giving a screen
       that looks like:

    <p><img src="pictures/ESP-fig30.png" width="100%"/>

    <p>You will notice that we hard-coded dimensions into our sketch.
       To make the sketch more useful, it would be convenient to drive
       it with Design Parameters.  To do this, we first have to create
       them.  This is done (as in tutorial 1) by pressing
       "<strong>Design Parameters</strong>" in the "Tree" window,
       entering "length" as the Parameter name and setting its value
       to "4".

    <p>In a similar way, create a "height" Design Parameter whose
       value is "3" and a "thick" Design Parameter whose value is
       "0.5".

    <p>Now, let's use these Design Parameters in the sketch.  To do
       this, choose one of the statements between the SKBEG and
       SKEND.  I suggest choosing "Branch_00003", which is the
       SKVAR statement (which shows the default locations of each of
       the sketch points).  Select "<strong>Enter Sketcher</strong>".

    <p>We are now going to change the various "L" constraints, by
       moving the mouse over the "L", pressing "<strong>L</strong>"
       and entering the new value.  Specifically, you should change
       the "L" constrains as follows:
      <ul>
        <li>bottom should have length set to "length"</li>
        <li>left should have its length set to "height"</li>
        <li>right should have its length set to "height"</li>
        <li>top-left should have its length set  to "thick"</li>
        <li>top-right should have its length set  to "thick"</li>
        <li>left side of slot should have its length set to
          "height-thick"</li>
      </ul>

    <p>"<strong>Press to Solve</strong>", giving:

    <p><img src="pictures/ESP-fig31.png" width="100%"/>

    <p>"<strong>Sketch</strong>" and "<strong>Save</strong>" (to exit
      the Sketcher) and "<strong>Press to Re-build</strong>" to use
      the latest changes.

    <p>Think about what we have done.  We have made a U-shaped channel
       whose overall length and height were given, and whose channel
       walls were all set to "thick".  Suppose instead that the
       "design intent" of the channel was to create a channel of a
       given slot width.  In this case, we would want to constrain the
       sketch differently.

    <p>Start by creating a Design Parameter named "slot" whose single
       value was "1".  Now select "Branch_000002" and "<strong>Enter
       Sketcher</strong>".  We are going to have to remove the "L"
       constraints from the top two horizontal segments, so go to each
       and press "<strong>&lt;</strong>".  Since there are two
       constraints here, you are asked which constraint to remove.
       Simply enter "L" at the prompt and the length constraint will
       be removed by the horizontal constraint will remain.  If you
       want to remove all constraints, press "<strong>&lt;</strong>"
       multiple times.

    <p>Now move the mouse over the horizontal segment at the bottom of
       the slot and press "<strong>L</strong>" and set the length to
       "slot".  You will notice that the sketch is under-constrained
       (is grey).  We need to add a constraint that the slot is
       centered.  To do this, we are going to make the lengths of the
       two small horizontal segments near the top on each side of the
       U equal to each other.  The first step here is to identify one
       of the segments.  This is done with the "<strong>?</strong>"
       command.  So, move the cursor over the top-left horizontal
       segment and press "?".  You will notice in the "Messages"
       window that this is segment 7.  Now move over the top-right
       horizontal segment and enter the length "::L[7]", which tells
       it to use the same length as segment 7.  "<strong>Press to
       Solve</strong>" to give:

    <p><img src="pictures/ESP-fig32.png" width="100%"/>

    <p>"<strong>Sketch</strong>" and "<strong>Save</strong>" and
       "<strong>Press to Re-build</strong>".

    <p>Now open the list of Design Parameters (using the
       "<strong>+</strong>" to the left of "Design Parameters") and
       change the value of "slot" to "2".  "<strong>Press to
       Re-build</strong>" to see the effect of this change.

    <p>We will now experiment with some of the other constraints.
       Specifically we will be removing some of our "H" and "V"
       constraints and instead add constraints at some of the points.
       Re-enter the Sketcher and move the cursor over the right-hand
       segment, press "<strong>&lt;</strong>" to remove the vertical
       constraint.  Similarly remove the horizontal constraint from
       the top-right horizontal segment.

    <p>The sketch is under-constrained (is grey).  We are going to add
       a perpendicularity constraint at the point at the lower-right
       corner by moving the mouse over the point and pressing
       "<strong>P</strong>".  Just to be different, at the top-right
       point we are going to add an "angle" constraint by pressing
       "<strong>A</strong>" and adding a value of "90".

    <p>"<strong>Press to Solve</strong>" and "<strong>Sketch</strong>"
       and "<strong>Save</strong>".

    <p>We are now going to extrude the sketch into a solid.  This is
       done by first creating a Design Parameter named "depth" and
       giving it a default value of "3".  Then add an EXTRUDE
       Branch, whose arguments are "dx"="0", "dy"="0", and
       "dz"="depth".  This will extrude the sketch in the "z"
       direction (out of the screen).  "<strong>Press to
       Re-build</strong>", yielding:

    <p><img src="pictures/ESP-fig33.png" width="100%"/>

    <p>As with most programs, it makes sense to periodically save your
       work, so press "<strong>File</strong>", "<strong>Export
       FeatureTree</strong>", and save the current model in a file
       named "<code>../data/tutorial2</code>".  (Note that the
       "<code>.csm</code>" suffix will automatically be added for
       you.)

    <p>To see the <code>.csm</code> file associated with the current
       model, press the "<strong>File</strong>" and
       "<strong>Edit</strong>" buttons.  At the top of the file, all
       the Design Parameters are defined (along with their current
       values).  This is followed by the Branches in the Feature Tree.
       Note the the sketch starts with a SKBEG statement.  This is
       followed by a SKVAR statement that specifies the initial
       locations of the various points in the sketch.  (These
       positions were automatically set up for you when you drew the
       sketch).  Following that , there is a series of SKCON
       statements that define the various constraints in the Sketcher.
       The first argument of each SKCON statement is the constraint
       type (which corresponds with the letters in the Sketcher),
       followed by the point (or segment) number and the value; again
       these were automatically set up for you when you drew the
       sketch and constrained it.  This is then followed by a series
       of LINSEG Branches, which say that our current sketch is made
       up of a series of line segments.  Again the number of the
       points to use in the LINSEG Branches was set up automatically
       for you.

    <p>Press "<strong>Cancel</strong>" to exit the editor and return
       to the normal view.

    <p>We are now going to create another sketch, which will be used
       to cut a hole in the bracket's left upright. This cut will be
       parameterized with a Design Parameter named "rad" whose sole
       value is "0.5".  (You can create that now.)

    <p>Now we want to create a new sketch.  We do this by adding a
       SKBEG Branch (with all "0" arguments).

    <p>The sketch that we are going to create consists of a
       race-track-shape curve, as shown in:

    <p><img src="pictures/ESP-fig34.png" width="100%"/>

    <p>This is done with the following actions. Draw a horizontal
       segment off to the right (make sure the line from the last
       point is drawn in orange) and press "<strong>L</strong>" (or
       click the mouse) to create the first horizontal segment.  Then
       move the mouse up and press the "<strong>C</strong>" key to
       create a circular arc segment.  When you have done that, the
       segment that you just created turns red and follows the cursor;
       move the cursor and see how it changes.  Once it is located at
       approximately the correct location, press the mouse button.
       Then sketch the horizontal line segment to the left, a circular
       arc on the left end, and finally a line segment back to the
       original point.

    <p>You might be wondering why the bottom of the racetrack was
       created with two LINSEGs.  The reason is that we are
       ultimately going to want to center the sketch on the left-leg
       of the bracket, so having a point at the "center" of the sketch
       will be convenient.

    <p>We are now going to constrain the sketch as follows:
      <ul>
        <li>"L" constraint on bottom-left horizontal segment set to
          "rad"</li>
        <li> "L" constraint on bottom-right horizontal segment set to
          "rad"</li>
        <li>"R" constraint on the right-hand circle set to "rad" (that
          is, you set the circular arc's radius)</li>
        <li>"T" constraint (tangency) at the point at the bottom of
          the left-hand arc</li>
        <li>"T" constraint (tangency) at the point at the bottom of
          the right-hand arc</li>
        <li>"T" constraint (tangency) at the point at the top of the
          left-hand arc</li>
        <li>"T" constraint (tangency) at the point at the top of the
          right-hand arc</li>
      </ul>

    <p>"<strong>Press to Solve</strong>", zoom in (using the
       "<strong>+</strong>" button) and center the sketch in the
       window (using the "<strong>H</strong>") button, yielding:

    <p><img src="pictures/ESP-fig35.png" width="100%"/>

    <p>"<strong>Sketch</strong>" and "<strong>Save</strong>" and
       "<strong>Press to Re-build</strong>". If you turn the
       configuration around, you will see the sketch at the back left
       bottom corner, as in:

    <p><img src="pictures/ESP-fig36.png" width="100%"/>

    <p>We want to rotate this to be parallel with the <em>y-z</em>
       plane by adding a ROTATEY Branch (with arguments "90", "0",
       "0"), move it to its proper location by adding a TRANSLATE
       Branch (with arguments "0", "height-3*rad", and "depth/2").  If
       you "<strong>Press to Re-build</strong>" you will see that the
       sketch is now properly positioned.  We can then add an
       EXTRUDE Branch (with arguments "length/2", "0", and "0") and
       finally subtract that new volume by adding a SUBTRACT Branch
       (with the default arguments).  If you "<strong>Press to
       Re-build</strong>", you should get:

    <p><img src="pictures/ESP-fig37.png" width="100%"/>

    <p>Now we will add a chamfer at the edges of the cut-out that the
       just made.  Add a Design Parameter named "filrad" whose sole
       value is "0.1" and a new CHAMFER Branch whose arguments are
       "filrad" and "0" (meaning all Edges).  "<strong>Press to
       Re-build</strong>", yielding:

    <p><img src="pictures/ESP-fig38.png" width="100%"/>

    <p>We are now going to make another cut-out for the right leg of
       the bracket.  As usual, make a SKBEG Branch (with all zero
       arguments). The figure that we want to sketch looks like:

    <p><img src="pictures/ESP-fig39.png" width="100%"/>

    <p>To make this, start by drawing a horizontal line segment to the
       right (by pressing the "<strong>L</strong>" key).  We are now
       going to set the control points for a Bezier curve.  Do this by
       moving the cursor above the original point and pressing
       "<strong>B</strong>".  We then continue to add one
       "<strong>B</strong>" to the left, one below it (to the left of
       the original point) and one halfway back to the original point.
       Finally move the cursor over the original point (the one
       labeled "XY") and press "<strong>L</strong>".

    <p>You can put the cursor over any of the points and "drag" it to a
       new location.  This movement will effect the display, but will
       likely be over-written when the sketch is ultimately solved.

    <p>Constrain the sketch as follows:
      <ul>
        <li>"L" constraint on bottom-left horizontal segment set to
          "depth/4"</li>
        <li>"L" constraint on bottom-center horizontal segment set to
          "depth/4"</li>
        <li>"L" constraint on bottom-right horizontal segment set to
          "depth/4"</li>
        <li>"L" constraint on top horizontal segment set to
          "depth/2"</li>
        <li>"L" constraint on left segment set to "depth/4"</li>
      </ul>

    <p>"<strong>Press to Solve</Strong>", "<strong>Sketch</strong>",
      "<strong>Save</strong>", and "<strong>Press to Re-build</strong>".
      You should see:

    <p><img src="pictures/ESP-fig40.png" width="100%"/>

    <p>Again, we want to rotate and translate the sketch, extrude it, and
       subtract it, by adding the Branches:
      <ul>
        <li>ROTATEY with arguments "90", "0", and "0"</li>
        <li>TRANSLATE with arguments "length", "height-3*rad", and
          "depth/2"</li>
        <li>EXTRUDE with arguments "-length/2", "0", and "0"</li>
        <li>SUBTRACT with arguments "none", "1", and "0"</li>
      </ul>

    <p>"<strong>Press to Re-build</strong>", giving:

    <p><img src="pictures/ESP-fig41.png" width="100%"/>

    <p>Finally, we want to modify the original bracket to put fillets
       along the bottom of the slot.  To do this, we have to go back
       and add a FILLET Branch immediately after the EXTRUDE that
       created the bracket.  If we look back through the Feature Tree,
       we see the first EXTRUDE is at "Branch_000103".  (To verify
       this, select "Branch_000103" and "Build to this Branch").  We
       are going to want to add a FILLET statement after this Branch,
       but first we must determine the identity of the Edges that we
       want filleted.  To do this, press the "<strong>+</strong>" to
       the left of the Body (near the bottom of the "Tree" window), turn
       the visibility of the Faces off (press "<strong>Viz</strong>"
       to the right of Faces), and query the two Edges shown in:

    <p><img src="pictures/ESP-fig42.png" width="100%"/>

    <p>Identifying them is done by pressing "<strong>^</strong>" over
       the two Edges.  (In the picture above, these Edges were
       identified for you by turning their "<strong>Grd</strong>" on
       before capturing the screen; these Edges will likely not be
       highlighted on your screen.)  You will notice in the "Messages"
       window that the Branches have an "edgeID" set to "11 6 11 7 1"
       and "11 7 11 8 1".  This means (for example) that the first
       Edge was created at the intersection of Faces 6 and 7 of Body
       11.

    <p>We can now create the FILLET Branch (edit "Branch_000103" and
       press "<strong>Add new Branch after this Branch</strong>"),
       with arguments "filrad" (which was set above for the CHAMFER)
       and "6;7;7;8;" (which selects the Edges between Faces 6 and 7
       and between 7 and 8.  "<strong>Press to Re-build</strong>".

    <p>Finally, we might want to see the sensitivity of this
       configuration with respect to some of the Design
       Parameters. This is done exactly as in the first tutorial (by
       selecting a Design Parameter and pressing "<strong>Compute
       sensitivity</strong>").

    <p><img src="pictures/ESP-fig43.png" width="100%"/>

    <p>We can now save our <code>.csm</code> file by choosing
       "<strong>File->Export FeatureTree</strong>" with the filename
       "<code>../data/tutorial2</code>".  Close the browser and
       serveCSM should close automatically.

    <p><h3 id="sec2.3">2.3 Third tutorial: Aircraft example</h3>

    <p>For the third tutorial, we will start <code>serveCSM</code>
       with the file <code>data/tutorial3.csm</code>, which represents
       a fighter-like aircraft using blends and ruled surfaces.

    <p>Start <code>serveCSM</code> with commands such as
      <pre>
        serveCSM ../data/tutorial3 -dumpEgads
      </pre>
      After a few minutes, the following will appear:
    <p><img src="pictures/ESP-fig44.png" width="100%"/>

    <p>The <code>-dumpEgade</code> tells <code>serveCSM</code> to dump
       a file with the name <code>Body_xxxxxx.egads</code> whenever a
       new Body is created; here, <code>xxxxxx</code> is replaced with
       the current Body number.  This is a very useful option to use
       if you have a long build and want to "see" the current process
       (in another invocation of <code>serveCSM</code> (which uses a
       different port number).  It is also useful in conjunction with
       the <code>-loadEgads</code> option described below.

    <p>We are going to modify this case by using the
       "<strong>File->Edit</strong>" button.  Pressing it gives:
    <p><img src="pictures/ESP-fig45.png" width="100%"/>

    <p>Listed in the "Graphics" window is a listing of
       the <code>tutorial3.csm</code> file.  We will dissect this file
       in a few minutes.  But first, edit the file by adding the
       following after line 2:
      <pre>
        # this is an added line
      </pre>

    <p>If you now press the "<strong>Cancel</strong>" button, the change
       you made will not be saved and the original aircraft picture
       will appear.  To see this, press the "<strong>File->Edit</strong>"
       button again and you will see that we have the
       original <code>tutorial3.csm</code> file.  Now edit the file by
       adding the following after line 2:
      <pre>
        # this is another added line
      </pre>
       Press the "<strong>ExportFeatureTree</strong>" button and the
       file will be updated and the configuration will rebuild with
       the updated file.  (This happens now even though the changes
       were inconsequential because all we did is added a comment.)

    <p>Now add a new Design Parameter called "xyz" that has 1 row and
       3 columns, with the values "11", "22", and "33". (Recall that
       this done by clicking on "<strong>Design Parameters</strong>"
       in the "Tree" window.)

    <p>If we try to "<strong>File->Edit</strong>" the file
       again, <code>ESP</code> will inform you that you made changes
       interactively and that you must save those changes first (or
       else lose them).  "<strong>Cancel</strong>" out of this and
       then press the <strong>"File->Export FeatureTree"</strong>
       button and give the new file the name "<code>foo</code>".

    <p>If you now press "<strong>File->Edit</strong>", you will see
       that the new current file is <code>foo.csm</code>.  You will
       also see that this file is formatted differently from your
       original <code>tutorial3.csm</code> file.  For example, the
       arguments in <code>foo.csm</code> are not nicely spaced as they
       were in the original <code>tutorial3.csm</code> file.  As a
       result, you will probably find it easier to only make changes
       via the user interface (as you did in tutorial 1) or to edit
       the file directly using the "<strong>File->Edit</strong>"
       button.  You can now "<strong>Cancel</strong>" out of the
       editor, bringing back the picture of the airplane.

    <p>In addition to understanding how
       to "<strong>Edit</strong>" <code>.csm</code> files, this tutorial
       also describes best practices when writing a <code>.csm</code>
       file.  So let's now dissect the
       original <code>tutorial3.csm</code> file.

    <p>As a good practice, it is suggested that you add comments to
     the top of the file, such as:
      <!-- extract from tutorial3.csm -->
      <pre>
# tutorial3
# written by John Dannenhoffer
      </pre>

    <p>This is then followed by the Design Parameters.  Those that
     describe the fuselage are given by:
      <!-- extract from tutorial3.csm -->
      <pre>
# design parameters associated with fuselage
#                      x      y    zmin   zmax
dimension fuse      15  4  1
despmtr   fuse     " 1.00; -0.40; -0.20;  0.25;\
                     2.00; -0.60; -0.30;  0.50;\
                     3.00; -0.60; -0.30;  0.80;\
                     4.00; -0.60; -0.30;  1.20;\
                     5.00; -0.60; -0.20;  1.20;\
                     6.00; -0.60; -0.10;  1.00;\
                     7.00; -0.60;  0.00;  0.80;\
                     8.00; -0.50;  0.00;  0.70;\
                     9.00; -0.40;  0.00;  0.60;\
                    10.00; -0.30;  0.00;  0.60;\
                    11.00; -0.30;  0.00;  0.60;\
                    12.00; -0.30;  0.00;  0.60;\
                    13.00; -0.30;  0.00;  0.60;\
                    13.90; -0.30;  0.00;  0.60;\
                    14.00; -0.30;  0.00;  0.60;"

dimension  noseList 2  4  1
despmtr    noseList "0.10; 0; 1; 0;\
                     0.05; 0; 0; 1"
      </pre>
       Here, <code>fuse</code> is a 15 row, 4 column, Design Parameter
       with the given values.  The values are listed across rows, with
       semi-colons between the various entries.  Since spaces are used
       to enhance readability, the entire list of values is placed
       between quotation marks.  Also, since the inputs are split
       across multiple lines, the backslash character is used to
       denote that the next line should be concatenated with the
       current line before processing; all characters starting at the
       backslash are ignored.  The <code>noseList</code> Design
       Parameter has 2 rows and 4 columns.  (More on the use of these
       Design Parameters below.)

    <p>The Design Parameters that describe the wing, horizontal and
       vertical tails are given by:
      <!-- extract from tutorial3.csm -->
      <pre>
# design parameters associated with wing
despmtr   series_w  4409

dimension  wing     3  5  1

#                     x       y      z   chord  angle
despmtr    wing    " 4.00;  0.00;  0.20;  6.00;  0.00;\
                     7.00;  1.00;  0.20;  3.00;  0.00;\
                     9.00;  4.60;  0.10;  1.00; 20.00;"

# design parameters associated with htail
despmtr   series_h  0406
despmtr   xroot_h  12.10
despmtr   zroot_h   0.20
despmtr   aroot_h   0.00
despmtr   area_h    7.28
despmtr   taper_h   0.55
despmtr   aspect_h  3.70
despmtr   sweep_h  25.00
despmtr   dihed_h   3.00
despmtr   twist_h   2.00

set       cbar_h    sqrt(area_h/aspect_h)
set       span_h    cbar_h*aspect_h
set       croot_h   (2*cbar_h)/(taper_h+1)
set       ctip_h    taper_h*croot_h
set       xtip_h    xroot_h+(span_h/2)*tand(sweep_h)
set       ytip_h    span_h/2
set       ztip_h    zroot_h+(span_h/2)*tand(dihed_h)
set       atip_h    aroot_h+twist_h

# design parameters associated with vtail
despmtr   series_v  0404
despmtr   xroot_v  11.20
despmtr   zroot_v   0.50
despmtr   area_v    9.60
despmtr   taper_v   0.30
despmtr   aspect_v  3.00
despmtr   sweep_v  45.00

set       cbar_v    sqrt(area_v/aspect_v)
set       span_v    cbar_v*aspect_v
set       croot_v   (2*cbar_v)/(taper_v+1)
set       ctip_v    taper_v*croot_v
set       xtip_v    xroot_v+(span_v/2)*tand(sweep_v)
set       ztip_v    zroot_v+span_v/2
      </pre>

    <p>Notice the SET statements that compute Local Variables in
       terms of the Design Variables.  For example, the mean-chord of
       the horizontal tail (<code>cbar_h</code>) is computed as the
       square-root of the ratio of the tail area and the tail aspect
       ratio.

    <p>Now we are going to build the fuselage.  This will be done
       using by blending data from various cross-sections.  The
       sections that will ultimately be blended are those created after
       the previous MARK.  Creating the mark is done with the code:
      <!-- extract from tutorial3.csm -->
      <pre>
# build the fuselage
mark
      </pre>

    <p>We want to begin the fuselage at a point.  This is accomplished
       by using a POINT statement:
      <!-- extract from tutorial3.csm -->
      <pre>
   point     0  0  0
      </pre>
       This creates a point at the origin.

    <p>Then we need to generate the remaining 15 cross-sections.  This
       is done with a "pattern" (similar to a "for" loop in other
       programming languages):
      <!-- extract from tutorial3.csm -->
      <pre>
   patbeg    i  fuse.nrow
      udprim ellipse   ry  abs(fuse[i,2])  rz  (fuse[i,4]-fuse[i,3])/2
      translate        fuse[i,1]  0            (fuse[i,4]+fuse[i,3])/2
   patend
      </pre>
       Within the pattern we create an ellipse (using the "ellipse"
       user-defined primitive) with its Parameters taken from the
       second, third, and fourth columns of the <code>fuse</code>
       Design Parameter.  Each cross-section is then translated into
       its final position using the TRANSLATE statement.
       The <code>patend</code> statement closes the pattern.  (Although
       not used here, it is possible to enclose patterns within
       patterns.)

    <p>Finally we will generate the fuselage by blending the point and
       15 sections (everything since the <code>mark</code>) using:
      <!-- extract from tutorial3.csm -->
      <pre>
blend     noseList
      </pre>

    <p>At this point it is worth looking into
       the <code>noseList</code>.  The first four entries (the first
       row) contain the nose radius in the direction specified (in
       this case, "0,1,0", which is a vector in the "y"-direction).
       The next four entries contain the nose radius in the "0,0,1"
       direction (which is the "z"-direction).  Similar coding would
       be used at the tail if a <code>tailList</code> had been
       specified as the second argument in the <code>BLEND</code>
       command.

    <p>The wing is built in a similar manner using a ruled surface.
       The code here is:
      <!-- extract from tutorial3.csm -->
      <pre>
# build the wing
mark
   udprim    naca      Series    series_w
   rotatez   -wing[3,5]   0   0
   rotatex   90           0   0
   scale     wing[3,4]
   translate wing[3,1]    -wing[3,2]   wing[3,3]

   udprim    naca      Series    series_w
   rotatez   -wing[2,5]   0   0
   rotatex   90           0   0
   scale     wing[2,4]
   translate wing[2,1]    -wing[2,2]   wing[2,3]

   udprim    naca      Series    series_w
   rotatez   -wing[1,5]   0   0
   rotatex   90           0   0
   scale     wing[1,4]
   translate wing[1,1]    wing[1,2]   wing[1,3]

   udprim    naca      Series    series_w
   rotatez   -wing[2,5]   0   0
   rotatex   90           0   0
   scale     wing[2,4]
   translate wing[2,1]    +wing[2,2]   wing[2,3]

   udprim    naca      Series    series_w
   rotatez   -wing[3,5]   0   0
   rotatex   90           0   0
   scale     wing[3,4]
   translate wing[3,1]    +wing[3,2]   wing[3,3]
rule
      </pre>
       Notice here that instead of using a pattern, the five sections
       were explicitly created; this was done to ensure that the left
       and right wings were the same.  Also note that
       the <code>naca</code> user-defined primitive was used to
       generate the cross-sections.

    <p>The next statement:
      <!-- extract from tutorial3.csm -->
      <pre>
union   # with fuselage
      </pre>
       combines the fuselage and wing into a single Body.

    <p>The code for the tails is:
      <!-- extract from tutorial3.csm -->
      <pre>
# build the horizontal tail
mark
   udprim    naca      Series    series_h
   rotatez   -atip_h   0         0
   rotatex   90        0         0
   scale     ctip_h
   translate xtip_h   -ytip_h    ztip_h

   udprim    naca      Series    series_h
   rotatez   -aroot_h  0         0
   rotatex   90        0         0
   scale     croot_h
   translate xroot_h   0         zroot_h

   udprim    naca      Series    series_h
   rotatez   -atip_h   0         0
   rotatex   90        0         0
   scale     ctip_h
   translate xtip_h    ytip_h    ztip_h
rule
union   # with wing/fuselage

# build  the vertical tail
mark
   udprim    naca      Series    series_v
   scale     croot_v
   translate xroot_v   0         zroot_v

   udprim    naca      Series    series_v
   scale     ctip_v
   translate xtip_v    0         ztip_v
rule
union   # with wing/fuselage
      </pre>

    <p>The <code>tutorial3.csm</code> file completes with the
       statement:
      <!-- extract from tutorial3.csm -->
      <pre>
end
      </pre>
       Although such a statement is not required, it is good practice
       to use it.

    <p>Feel free to experiment by modifying this file.

    <p>Finally we are going to run <code>serveCSM</code> with
       the <code>-loadEgads</code> option, as in:
      <pre>
serveCSM ../data/tutorial3 -loadEgads
      </pre>

    <p>This will rerun the <code>tutorial3</code> case, but will read
       Bodys from the <code>Body_xxxxxx.egads</code> files instead of
       generating, generally making it much faster.  Checks are made
       to ensure that the <code>Body_xxxxxx.egads</code> files match
       the expected Branch type and arguments.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec3">3.0: Command Line</h2>

    <p>To start <code>serveCSM</code>, one uses the command:
      <!-- extract from serveCSM.c -->
      <pre>
        serveCSM [casename[.csm]] [options...]
           where [options...] = -addVerify
                                -batch
                                -checkMass
                                -checkPara
                                -despmtrs despname
                                -dict dictname
                                -dumpEgads
                                -egg eggname
                                -help  -or-  -h
                                -histDist dist
                                -jrnl jrnlname
                                -loadEgads
                                -onormal
                                -outLevel X
                                -plot plotfile
                                -plotBDF BDFname
                                -plotCP
                                -plugs npass
                                -port X
                                -printStack
                                -ptrb ptrbname
                                -sensTess
                                -skipBuild
                                -skipTess
                                -verify
                                -version  -or-  -v  -or-  --version
      </pre>

    <p>The <code>-addVerify</code> option tells <code?serveCSM</code>
       to write a <code>.csm_verify</code> file that contains
       information about the Bodys on the stack.  This information can
       be used in a subsequent call (using the <code>-verify</code>
       flag) to verify that the results are "close enough" to a
       previous run.

    <p>If the <code>-batch</code> option is given,
       <code>serveCSM</code> is started without any graphical user
       interface.  This option is useful for regenerating
       configurations as part of a bigger process, such as for testing
       or within an MDAO environment.

    <p>The <code>-dict</code> option tells <code>serveCSM</code> to
       read the <code>dictname</code> file to define constant
       Parameters that should be defined before the configuration is
       built.  The format of the <code>dictname</code> file is a
       series of lines, where each line contains a constant name and a
       value, separated by white space; these Parameters are defined
       after the <code>.csm</code> is read but before it is executed.

    <p>The <code>-dumpEgads</code> option tells <code>serveCSM</code>
       to write an EGADS file named "Body_xxxxxx.egads" to the current
       working directory every time a new Body is built.  This option
       is useful if one wants to see the progress so far during a long
       build or in conjunction with the <code>-loadEgads</code>
       option.

    <p>The <code>-egg</code> option tells <code>serveCSM</code> to use
       the <code>eggname</code> external grid generator instead of the
       built-in <code>EGADS</code> tessellator.

    <p>The <code>-help</code> option produces a listing of the command
       line options.

    <p>the <code>-histDist</code> option produces a histogram of the
       distances of all point in a plotfile (specified with
       the <code>-plot</code> option) from the current configuration.

    <p>The <code>-jrnl</code> option is useful for replaying a
       previous session.  This journal file is an ASCII file that can
       be created with any text-editor.  But more typically, a user
       modifies the <code>portX.jrnl</code> file that is automatically
       produced every time <code>serveCSM</code> is started.  (Note:
       be sure to copy and/or rename this file before using it as an
       input to <code>serveCSM</code>, since the
       next <code>serveCSM</code> will overwrite this file.)

    <p>The<code>-loadEgads</code> option tells <code>serveCSM</code>
       to try to read file named "Body_xxxxxx.egads" during the build
       process, thereby bypassing possibly long operations.  There are
       safeguards to ensure that the Branch type and arguments match
       before the file is loaded.

    <p>The <code>-onormal</code> option tells <code>serveCSM</code> to
       move the user's eye away from the configuration, making the
       display almost orthonormal (instead of perspective).

    <p>The <code>-outLevel</code> option sets the level of output (0
       to 3) that the server should produce during its execution.
       Higher numbers are useful for debugging and should seldom be
       used by most users.

    <p>The <code>-plot</code> option provides a <code>plotfile</code>
       file that contains X,Y,Z triplets of points to be plotted in
       ESP with the label <code>plotdata</code>.
       See <a href="#sec5.12">Section 5.12</a> for details.

    <p>The <code>-plotBDF</code> option plots the GRIDs, CRODs, and
       CQUAD4s in the associated <code>.bdf</code> file (which can be
       written by the <code>createBEM</code> UDP).

    <p>The <code>-plotCP</code> option plots the control polygons
       associated with all Bspline Faces.

    <p>The <code>-plugs</code> option starts Plugs, which is a tool
       for modifying the DESPMTRs in a configuration so that the
       distances from the points in a plotfile (specified via
       the <code>-plot</code> option) to the configuration is
       minimized in a least-squares sense.  This option is still
       experimental and should be used with caution.

    <p>The <code>-port</code> option tells <code>serveCSM</code> with
       which port to connect.  If a port other than the default is
       used, be certain to use that same port number
       in <code>ESP</code>'s initial prompt.

    <p>The <code>-printStack</code> option tells <code>OpenCSM</code>
        to print out the contents of the stack after every command is
        executed.

    <p>The <code>-sensTess</code> flag allows a user to select
       "configuration" sensitivities instead of the (default)
       "tessellation" sensitivities.

    <p>The <code>-skipBuild</code> flag tells <code>serveCSM</code> to
       skip the initial build.  This is useful when the user knows
       that some DESPMTRs will be changed before the build.

    <p>The <code>-skipTess</code> option is used when you want to
       run <code>OpenCSM</code> in <code>-batch</code> mode and you do
       not want it to create the tessellation of all the Bodys on the
       stack.

    <p>The <code>-verify</code> is typically used during testing to
       verify that the Bodys that are produced "match" those that were
       produced when the <code>-addVerify</code> flag was used.  It
       does this by actually checking the ASSERT Branches
       whose <code>verify</code> option is set to 1.

    <p>The <code>-version</code> (or <code>-v</code>
       or <code>--version</code>) flag is used to print version
       information for the user.

    <p><code>OpenCSM</code> ignores the <code>--</code> flag.

    <p>The options <code>-checkMass</code>, <code>-checkPara</code>,
       <code>-despmtrs</code> and <code>-ptrb</code> are basically
       used during development, and users should generally not need to
       use them.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec4">4.0: Interactive Options</h2>

    <p>The tutorial (above) gives an overview of nearly all the
       interactive commands that are available in <code>ESP</code>.
       Future versions of this document will add more details here.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec5">5.0: Format of the <code>.csm</code>
        and <code>.udc</code> Files</h2>

    <p><h3 id="sec5.1">5.1: Format of the <code>.csm</code> file</h3>

    <p>The <code>.csm</code> file contains a series of statements.

    <p>If a line contains a hash (#), all characters starting at the
       hash are ignored.

    <p>If a line contains a backslash, all characters starting at the
       backslash are ignored and the next line is appended; spaces at
       the beginning of the next line are treated normally.

    <p>All statements begin with a keyword (described below) and must
       contain at least the indicated number of arguments.

    <p>The keywords may either be all lowercase or all UPPERCASE.

    <p>Any CSM statement can be used except the INTERFACE statement.

    <p>Blocks of statements must be properly nested.  The Blocks are
      bounded by PATBEG/PATEND, IFTHEN/ELSEIF/ELSE/ENDIF,
      SOLBEG/SOLEND, and CATBEG/CATEND.

    <p>Extra arguments in a statement are discarded.  If one wants to
       add a comment, it is recommended to begin it with a hash (#) in
       case optional arguments are added in future releases.

    <p>Any statements after an END statement are ignored.

    <p>All arguments must not contain any spaces or must be enclosed
       in a pair of double quotes (for example, "a + b").

    <p>Parameters are evaluated in the order that they appear in the
       file, using MATLAB-like syntax (see
       <a href="#sec5.10">'Expression rules'</a> below).

    <p>During the build process, <code>OpenCSM</code> maintains a LIFO
       'Stack' that can contain Bodies and Sketches.

    <p>The csm statements are executed in a stack-like way, taking
       their inputs from the Stack and depositing their results onto
       the Stack.

    <p>The default name for each Branch is 'Brch_xxxxxx', where xxxxxx
       is a unique sequence number.

    <p><h3 id="sec5.2">5.2: Format of the <code>.udc</code> file</h3>

    <p>A <code>.udc</code> file follows the rules of
       a <code>.csm</code> file, EXCEPT:

    <p>Zero or more INTERFACE statements must preceed any other
       non-comment statement.

    <p>Any CSM statement can be used except the DIMENSION, CONPMTR,
       DESPMTR, LBOUND, and UBOUND statements.

    <p>SET statements define parameters that are visible only within
       the <code>.udc</code> file (that is, parameters have local
       scope).

    <p>Parameters defined outside the <code>.udc</code> file are not
       available, except those passed in via INTERFACE statements.

    <p><code>.udc</code> files can be nested to a depth of 10 levels.

    <p><code>.udc</code> files are executed via a UDPRIM statement.

    <p><h3 id="sec5.3">5.3: Special characters</h3>
      <!-- extract from OpenCSM.h -->
      <pre>
   #          introduces comment
   "          ignore spaces until following "
   \          ignore this and following characters and concatenate next line
   <space>    separates arguments in .csm file (except between " and ")

   0-9        digits used in numbers and in names
   A-Z a-z    letters used in names
   _ : @      characters used in names (see rule for names)
   ? % =      characters used in strings
   .          decimal separator (used in numbers), introduces dot-suffixes
                 (in names)
   ,          separates function arguments and row/column in subscripts
   ;          multi-value item separator
   ( )        groups expressions and function arguments
   [ ]        specifies subscripts in form [row,column] or [index]
   { } < >    characters used in strings
   + - * / ^  arithmetic operators
   $          as first character, introduces a string that is terminated
                 by end-of-line or un-escaped plus, comma, or open-bracket
   @          as first character, introduces @-parameters (see below)
   '          used to escape comma, plus, or open-bracket within strings
   !          if first character of implicit string, ignore $! and treat
                 as an expression

   |          cannot be used (reserved for OpenCSM internals)
   ~          cannot be used (reserved for OpenCSM internals)
   &          cannot be used (reserved for OpenCSM internals)
      </pre>

    <p><h3 id="sec5.4">5.4: Valid CSM statements</h3>

    <p>The current CSM statements are listed here, grouped by type.  A
      full alphabetical description of any command can be obtained by
      clicking on the command name.

    <p>For a convenient Quick Reference,
       see <code>$ESP_ROOT/doc/ESP_QuickReference.pdf</code>, which is
       a two-page summary of the various <code>.csm</code> commands,
       built-in functions, dot-suffixes, the <code>ESP</code>
       character set, and a brief summary of the meanings of the various
       keypresses in <code>ESP</code>.

    <p>In the descriptions below, the conventions used are:
      <ul>
        <li>command name can eiter be UPPERCASE or lowercase, but not
          mixed</li>
        <li>arguments that start with a dollar-sign ($) are character
          strings.  Note that the user does not type the
          dollar-sign.  If you want to use a string-valued expression
          instead of an implicit string, start the argument with an
          exclamation point (!).</li>
        <li> arguments without a dollar sign ($) can be either a
          numeric value, a variable name, or an expression</li>
        <li>the default values for arguments are shown after the
          equal-signs</li>
        <li>arguments that take a list can either refer to a
          multi-valued Parameter or can be a semi-colon-separated list
          of values and/or expressions</li>
      </ul>

      <table>
        <tr>
          <td><strong>Primitives</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#point">point</a></td>
          <td>xloc yloc zloc</td>
        </tr>
        <tr><td></td>
          <td><a href="#box">box</a></td>
          <td>xbase ybase zbase dx dy dz</td>
        </tr>
        <tr><td></td>
          <td><a href="#sphere">sphere</a></td>
          <td>xcent ycent zcent radius</td>
        </tr>
        <tr><td></td>
          <td><a href="#cone">cone</a></td>
          <td>xvrtx yvrtx zvrtx xbase ybase zbase radius</td>
        </tr>
        <tr><td></td>
          <td><a href="#cylinder">cylinder</a></td>
          <td>xbeg ybeg zbeg xend yend zend radius</td>
        </tr>
        <tr><td></td>
          <td><a href="#torus">torus</a></td>
          <td>xcent ycent zcent dxaxis dyaxis dzaxis majorRad
          minorRad</td>
        </tr>
        <tr><td></td>
          <td><a href="#import">import</a></td>
          <td>$filename bodynumber=1</td>
        </tr>
        <tr><td></td>
          <td><a href="#restore">restore</a></td>
          <td>$name index=0</td>
          </tr>
        <tr>
        <tr><td></td>
          <td><a href="#udprim">udprim</a></td>
          <td>$primtype $argName1 argValue1 $argName2 argValue2
          $argName3 argValue3 $argName4 argValue4</td>
        </tr>
          <td><strong>Grown</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#extrude">extrude</a></td>
          <td>dx dy dz</td>
        </tr>
        <tr><td></td>
          <td><a href="#rule">rule</a></td>
          <td>reorder=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#blend">blend</a></td>
          <td>begList=0 endList=0 reorder=0 oneFace=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#revolve">revolve</a></td>
          <td>xorig yorig zorig dxaxis dyaxis dzaxis angDeg</td>
        </tr>
        <tr><td></td>
          <td><a href="#sweep">sweep</a></td>
        </tr>
        <tr>
          <td><strong>Applied</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#fillet">fillet</a></td>
          <td>radius edgeList=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#chamfer">chamfer</a></td>
          <td>radius edgeList=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#hollow">hollow</a></td>
          <td>thick faceList=0</td>
        </tr>
        <tr>
          <td><strong>Booleans</strong></td>
        <tr>
        <tr><td></td>
          <td><a href="#intersect">intersect</a></td>
          <td>$order=none index=1 maxtol=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#subtract">subtract</a></td>
          <td>$order=none index=1 maxtol=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#union">union</a></td>
          <td>toMark=0 trimList=0 maxtol=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#join">join</a></td>
          <td>toler=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#connect">connect</a></td>
          <td>faceList1 faceList2</td>
        </tr>
        <tr><td></td>
          <td><a href="#extract">extract</a></td>
          <td>index</td>
        </tr>
        <tr><td></td>
          <td><a href="#combine">combine</a></td>
        </tr>
        <tr>
          <td><strong>Transform</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#translate">translate</a></td>
          <td>dx dy dz</td>
        </tr>
        <tr><td></td>
          <td><a href="#rotatex">rotatex</a></td>
          <td>angDeg yaxis zaxis</td>
        </tr>
        <tr><td></td>
          <td><a href="#rotatey">rotatey</a></td>
          <td>angDeg zaxis xaxis</td>
        </tr>
        <tr><td></td>
          <td><a href="#rotatez">rotatez</a></td>
          <td>angDeg xaxis yaxis</td>
        </tr>
        <tr><td></td>
          <td><a href="#scale">scale</a></td>
          <td>fact</td>
        </tr>
        <tr><td></td>
          <td><a href="#mirror">mirror</a></td>
          <td>nx ny nz dist=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#applycsys">applycsys</a></td>
          <td>$csysName ibody=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#reorder">reorder</a></td>
          <td>ishift iflip=0</td>
        </tr>
        <tr>
          <td><strong>Sketch</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#skbeg">skbeg</a></td>
          <td>x y z relative=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#skvar">skvar</a></td>
          <td>$type valList</td>
        </tr>
        <tr><td></td>
          <td><a href="#skcon">skcon</a></td>
          <td>$type index1 index2=-1 $value=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#linseg">linseg</a></td>
          <td>x y z</td>
        </tr>
        <tr><td></td>
          <td><a href="#cirarc">cirarc</a></td>
          <td>xon yon zon xend yend zend</td>
        </tr>
        <tr><td></td>
          <td><a href="#arc">arc</a></td>
          <td>xend yend zend dist $plane=xy</td>
        </tr>
        <tr><td></td>
          <td><a href="#spline">spline</a></td>
          <td>x y z</td>
        </tr>
        <tr><td></td>
          <td><a href="#sslope">sslope</a></td>
          <td>dx dy dz</td>
        </tr>
        <tr><td></td>
          <td><a href="#bezier">bezier</a></td>
          <td>x y z</td>
        </tr>
        <tr><td></td>
          <td><a href="#skend">skend</a></td>
          <td>wireonly=0</td>
        </tr>
        <tr>
          <td><strong>Solver</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#solbeg">solbeg</a></td>
          <td>$varList</td>
        </tr>
        <tr><td></td>
          <td><a href="#solcon">solcon</a></td>
          <td>$expr</td>
        </tr>
        <tr><td></td>
          <td><a href="#solend">solend</a></td>
        </tr>
        <tr>
          <td><strong>Utilities</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#set">set</a></td>
          <td>$pmtrName exprs</td>
        </tr>
        <tr><td></td>
          <td><a href="#assert">    assert    </a></td>
          <td>arg1 arg2 toler=0 verify=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#udparg">udparg</a></td>
          <td>$primtype $argName1 argValue1 $argName2 argValue2
          $argName3 argValue3 $argName4 argValue4</td>
        </tr>
        <tr><td></td>
          <td><a href="#mark">mark</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#group">group</a></td>
        </tr><td></td>
        <td><a href="#patbeg">patbeg</a></td>
          <td>$pmtrName ncopy</td>
        </tr>
        <tr><td></td>
          <td><a href="#patbreak">patbreak</a></td>
          <td>expr</td>
        </tr>
        <tr><td></td>
          <td><a href="#patend">patend</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#evaluate">evaluate</a></td>
          <td>$type arg1 ...</td>
        </tr>
        <tr><td></td>
          <td><a href="#ifthen">ifthen</a></td>
          <td>val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#elseif">elseif</a></td>
          <td>val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#else">else</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#endif">endif</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#store">store</a></td>
          <td>$name index=0 keep=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#dump">dump</a></td>
          <td>$filename remove=0 toMark=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#select">select</a></td>
          <td>$type ...</td>
        </tr>
        <tr><td></td>
          <td><a href="#getattr">getattr</a></td>
          <td>$pmtrName attrID</td>
        </tr>
        <tr><td></td>
          <td><a href="#project">project</a></td>
          <td>x y z dx dy dz useEdges=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#throw">throw</a></td>
          <td>sigCode</td>
        </tr>
        <tr><td></td>
          <td><a href="#catbeg">catbeg</a></td>
          <td>sigCode</td>
        </tr>
        <tr><td></td>
          <td><a href="#catend">catend</a></td>
        </tr>
        <tr>
          <td><strong>Declarations</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#cfgpmtr">cfgpmtr</a></td>
          <td>$pmtrName value</td>
        </tr>
        <tr><td></td>
          <td><a href="#conpmtr">conpmtr</a></td>
          <td>$pmtrName value</td>
        </tr>
        <tr><td></td>
          <td><a href="#despmtr">despmtr</a></td>
          <td>$pmtrName values</td>
        </tr>
        <tr><td></td>
          <td><a href="#outpmtr">outpmtr</a></td>
          <td>$pmtrName</td>
        </tr>
        <tr><td></td>
          <td><a href="#lbound">lbound</a></td>
          <td>$pmtrName bounds</td>
        </tr>
        <tr><td></td>
          <td><a href="#ubound">ubound</a></td>
          <td>$pmtrName bounds</td>
        </tr>
        <tr><td></td>
          <td><a href="#dimension">dimension</a></td>
          <td>$pmtrName nrow ncol despmtr=0</td>
        </tr>
        <tr><td></td>
          <td><a href="#name">name</a></td>
          <td>$branchName</td>
        </tr>
        <tr><td></td>
          <td><a href="#attribute">attribute</a></td>
          <td>$attrName attrList</td>
        </tr>
        <tr><td></td>
          <td><a href="#csystem">csystem</a></td>
          <td>$csysName csysList</td>
        </tr>
        <tr><td></td>
          <td><a href="#interface">interface</a></td>
          <td>$argName $argType default</td>
        </tr>
        <tr><td></td>
          <td><a href="#end">end</a></td>
        </tr>
        <tr>
          <td><strong>Deprecated</strong></td>
        </tr>
        <tr><td></td>
          <td><a href="#loft">loft</a></td>
          <td>smooth</td>
        </tr>
        <tr><td></td>
          <td><a href="#macbeg">macbeg</a></td>
          <td>imacro</td>
        </tr>
        <tr><td></td>
          <td><a href="#macend">macend</a></td>
        </tr>
        <tr><td></td>
          <td><a href="#recall">recall</a></td>
          <td>imacro</td>
        </tr>
      </table>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <p><h3 id="applycsys">applycsys</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
APPLYCSYS $csysName ibody=0
          use:    transforms Group on top of stack so that their
                      origins/orientations coincide with given csys
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  if ibody>0, use csys associated with that Body
                  if ibody==0, then search for csys backward from
                     next-to-last Body on stack
                  if ibody==-1, transform Body on top of stack so
                     that its csys is moved to the origin
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $body_not_found
                     $insufficient_bodys_on_stack
                     $name_not_found
        </pre>
      <p><h3 id="arc">arc</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ARC       xend yend zend dist $plane=xy
          use:    create a new circular arc to the new point, with a
                     specified distance between the mid-chord and mid-arc
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  $plane must be xy, yz, or zx
                  if dist>0, sweep is counterclockwise
                  sensitivity computed w.r.t. xend, yend, zend, dist
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="assert">assert</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ASSERT    arg1 arg2 toler=0 verify=0
          use:    return error if arg1 and arg2 differ
          pops:   -
          pushes: -
          notes:  if toler==0, set toler=1e-6
                  if toler<0, set toler=abs(arg1*toler)
                  if (abs(arg1-arg2) > toler) return an error
                  only executed if verify<=MODL->verify
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="attribute">attribute</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ATTRIBUTE $attrName attrValue
          use:    sets an Attribute for the Group on top of Stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  if first char of attrValue is '$', then string Attribute
                  elseif attrValue is a Parameter name, all its elements
                     are stored in Attribute
                  otherwise attrValue is a semicolon-separated list of
                     scalar numbers/expressions
                  does not create a Branch
                  if before first Branch that creates a Body,
                     the Attribute is a string-valued global Attribute
                  if after BLEND, BOX, CHAMFER, COMBINE, CONE, CONNECT,
                        CYLINDER, EXTRUDE, FILLET, HOLLOW, IMPORT, LOFT,
                        RESTORE, REVOLVE, RULE, SPHERE, SWEEP, TORUS,
                        or UDPRIM
                     the Attribute is added to the Body and its Faces
                  else
                     the Attribute is only added to the Body
                  is applied to selected Nodes, Edges, or Faces if after a
                     SELECT statement
        </pre>
      <p><h3 id="bezier">bezier</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
BEZIER    x y z
          use:    add a Bezier control point
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  sensitivity computed w.r.t. x, y, z
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="blend">blend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
BLEND     begList=0 endList=0 reorder=0 oneFace=0
          use:    create a Body by blending through Sketches since Mark
          pops:   Sketch1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  all Sketches must have the same number of Edges
                  if all Sketches are WireBodys, then a SheetBody is created
                     otherwise a SolidBody is created
                  if the first Sketch is a point
                      if begList is 0
                          pointed end is created
                      elseif begList contains 8 values
                          begList contains rad1;dx1;dy1;dz1;rad2;dx2;dy2;dz2
                          rounded end is created
                  elseif first Sketch is a WireBody
                      created SheetBody is open at the beginning
                  elseif first Sketch is a SheetBody
                      if begList is 0
                          created Body included SheetBody at its beginning
                      elseif begList contains 2 values and first is -1
                          begList contains -1;aspect
                          rounded end with approximately given aspect ratio
                  if the last Sketch is a point
                      if endList is 0
                          pointed end is created
                      elseif endList contains 8 values
                          endList contains rad1;dx1;dy1;dz1;rad2;dx2;dy2;dz2
                          rounded end is created
                  elseif last Sketch is a WireBody
                      created SheetBody is open at the end
                  elseif last Sketch is a SheetBody
                      if endList is 0
                          created Body included SheetBody at its end
                      elseif endList contains 2 values and first is -1
                          endList contains -1;aspect
                          rounded end with approximately given aspect ratio
                  if begList!=0 and endList!=0, there must be at least
                     three interior sketches
                  interior sketches can be repeated once for C1 continuity
                  interior sketches can be repeated twice for C0 continuity
                  if reorder!=0 then Sketches are reordered to minimize Edge
                     lengths in the direction between Sketches
                  first Sketch is unaltered if reorder>0
                  last  Sketch is unaltered if reorder<0
                  if oneFace==1 then do not split at C0 (multiplicity=3)
                  sensitivity computed w.r.t. begList, endList
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Sketches are maintained
                  face-order is: (base), (end), feat1:part1,
                     feat1:part2, ... feat2:part1, ...
                  signals that may be thrown/caught:
                     $error_in_bodys_on_stack
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="box">box</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
BOX       xbase ybase zbase dx dy dz
          use:    create a box SolidBody or planar SheetBody
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if one of dx, dy, or dz is zero, a SheetBody is created
                  if two of dx, dy, or dz is zero, a WireBody is created
                  sensitivity computed w.r.t. xbase, ybase, zbase, dx, dy, dz
                  computes Face, Edge, and Node sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: xmin, xmax, ymin, ymax, zmin, zmax
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="catbeg">catbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CATBEG    sigCode
          use:    execute Block of Branches if current signal matches
                     sigCode
          pops:   -
          pushes: -
          notes:  sigCode can be an integer or one of:
                     $all
                     $body_not_found
                     $colinear_sketch_points
                     $created_too_many_bodys
                     $did_not_create_body
                     $edge_not_found
                     $error_in_bodys_on_stack
                     $face_not_found
                     $file_not_found
                     $func_arg_out_of_bounds
                     $illegal_argument
                     $ilegal_attribute
                     $illegal_csystem
                     $illegal_pmtr_name
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $name_not_found
                     $node_not_found
                     $non_coplanar_sketch_points
                     $no_selection
                     $not_converged
                     $self_intersecting
                     $wrong_types_on_stack
                  if sigCode does not match current signal, skip to matching
                     CATEND
                  Block contains all Branches up to matching CATEND
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="catend">catend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CATEND
          use:    designates the end of a CATBEG Block
          pops:   -
          pushes: -
          notes:  inner-most Block must be a CATBEG Block
                  closes CATBEG Block
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="cfgpmtr">cfgpmtr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CFGPMTR   $pmtrName value
          use:    define a (constant) CONFIG design Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a .udc file
                  pmtrName must be in form 'name'
                  pmtrName must not start with '@'
                  pmtrName must not refer to an INTERNAL/OUTPUT/CONSTANT
                      Parameter
                  pmtrName will be marked as CONFIG
                  pmtrName is used directly (without evaluation)
                  if value already exists, it is not overwritten
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="chamfer">chamfer</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CHAMFER   radius edgeList=0
          use:    apply a chamfer to a Body
          pops:   Body
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if previous operation is boolean, apply to all new Edges
                  edgeList=0 is the same as edgeList=[0;0]
                  edgeList is a multi-value Parameter or a semicolon-separated
                     list
                  pairs of edgeList entries are processed in order
                  pairs of edgeList entries are interpreted as follows:
                     col1  col2   meaning
                      =0    =0    add all Edges
                      >0    >0    add    Edges between iford=+icol1
                                                   and iford=+icol2
                      <0    <0    remove Edges between iford=-icol1
                                                   and iford=-icol2
                      >0    =0    add    Edges adjacent to iford=+icol1
                      <0    =0    remove Edges adjacent to iford=-icol1
                  sensitivity computed w.r.t. radius
                  sets up @-parameters
                  new Faces all receive the Branch's Attributes
                  face-order is based upon order that is returned from EGADS
                  signals that may be thrown/caught:
                     $illegal_argument
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="cirarc">cirarc</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CIRARC    xon yon zon xend yend zend
          use:    create a new circular arc, using the previous point
                     as well as the two points specified
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  sensitivity computed w.r.t. xon, yon, zon, xend, yend, zend
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="combine">combine</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
COMBINE   toler=0
          use:    combine Bodys since Mark into next higher type
          pops:   Body1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  Mark must be set
                  if all Bodys since Mark are SheetBodys
                     create either a SolidBody from closed Shell or an
                     (open) SheetBody
                  elseif all Bodys since Mark are WireBodys and are co-planar
                     create SheetBody from closed Loop
                  endif
                  if maxtol>0, then tolerance can be relaxed until successful
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="cone">cone</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CONE      xvrtx yvrtx zvrtx xbase ybase zbase radius
          use:    create a cone Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xvrtx, yvrtx, zvrtz, xbase, ybase,
                     zbase, radius
                  computes Face, Edge, and Node sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: (empty), base, umin, umax
                     if x-aligned: umin=ymin, umax=ymax
                     if y-aligned: umin=xmax, umax=xmin
                     if z-aligned: umin=ymax, umax=ymin
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="connect">connect</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CONNECT   faceList1 faceList2 edgeList1=0 edgeList2=0
          use:    connects two Bodys with bridging Faces
          pops:   Body1 Body2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  faceList1 and faceList2 must have the same length
                  edgeList1 and edgeList2 must have the same length
                  edgeList1[i] corresponds to edgeList2[i]
                  faceList1[i] corresponds to faceList2[i]
                  if edgeLists are given
                      Body1 is either SheetBody or SolidBody
                      Body2 is same type as Body1
                      Body  is same type as Body1
                      Face in faceLists are removed
                      bridging Faces are made between edgeList pairs
                      a zero in an edgelist creates a degenerate Face
                  else
                      Body1 and Body2 must both be SolidBodys
                      Faces within each faceList must be contiguous
                      bridging Faces between exposed Edges are created
                  new Faces all receive the Branch's Attributes
                  sets up @-parameters
                  if edgeLists are given
                      face-order is same as edgeList
                  else
                      face-order is arbitrary
                  signals that may be thrown/caught:
                     $illegal_argument
                     $illegal_value
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="conpmtr">conpmtr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CONPMTR   $pmtrName value
          use:    define a CONSTANT Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a .udc file
                  pmtrName must be in form 'name'
                  pmtrName must not start with '@'
                  pmtrName must not refer to an INTERNAL/OUTPUT/EXTERNAL
                      Parameter
                  pmtrName will be marked as CONSTANT
                  pmtrName is used directly (without evaluation)
                  pmtrName is available within .csm and .udc files
                  value must be a number
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="csystem">csystem</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CSYSTEM   $csysName csysList
          use:    attach a Csystem to Body on top of stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  if     csysList contains 9 entries:
                     {x0, y0, z0, dx1, dy1, dz1, dx2, dy2, dz2}
                     origin is at (x0,y0,z0)
                     dirn1  is in (dx1,dy1,dz1) direction
                     dirn2  is part of (dx2,dy2,dz2) that is orthog. to dirn1
                  elseif csysList contains 5 entries and first is positive
                     {+iface, ubar0, vbar0, du2, dv2}
                     origin is at normalized (ubar0,vbar0) in iface
                     dirn1  is normal to Face
                     dirn2  is in (du2,dv2) direction
                  elseif csyList contains 5 entries and first is negative
                     {-iedge, tbar, dx2, dy2, dz2}
                     origin is at normalized (tbar) in iedge
                     dirn1  is tangent to Edge
                     dirn2  is part of (dx2,dy2,dz2) that is orthog. to dirn1
                  elseif csysList contains 7 entries
                     {inode, dx1, dy1, dz1, dx2, dy2, dz2}
                     origin is at Node inode
                     dirn1  is in (dx1,dy1,dz1) direction
                     dirn2  is part of (dx2,dy2,dz2) that is orthog. to dirn1
                  else
                     error
                  semicolon-sep lists can instead refer to
                     multi-valued Parameter
                  dirn3 is formed by (dirn1)-cross-(dirn2)
                  does not create a Branch
        </pre>
      <p><h3 id="cylinder">cylinder</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
CYLINDER  xbeg ybeg zbeg xend yend zend radius
          use:    create a cylinder Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xbeg, ybeg, zbeg, xend, yend,
                     zend, radius
                  computes Face, Edge, and Node sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: beg, end, umin, umax
                     if x-aligned: umin=ymin, umax=ymax
                     if y-aligned: umin=xmax, umax=xmin
                     if z-aligned: umin=ymax, umax=ymin
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="despmtr">despmtr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
DESPMTR   $pmtrName values
          use:    define a (constant) EXTERNAL design Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a function-type .udc file
                  pmtrName can be in form 'name' or 'name[irow,icol]'
                  pmtrName must not start with '@'
                  pmtrName must not refer to an INTERNAL/OUTPUT/CONSTANT
                      Parameter
                  pmtrName will be marked as EXTERNAL
                  pmtrName is used directly (without evaluation)
                  irow and icol cannot contain a comma or open bracket
                  if irow is a colon (:), then all rows    are input
                  if icol is a colon (:), then all columns are input
                  pmtrName[:,:] is equivalent to pmtrName
                  values cannot refer to any other Parameter
                  if value already exists, it is not overwritten
                  values are defined across rows, then across columns
                  if values has more entries than needed, extra values
                     are lost
                  if values has fewer entries than needed, last value
                     is repeated
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="dimension">dimension</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
DIMENSION $pmtrName nrow ncol despmtr=0
          use:    set up or redimensions an array Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  if despmtr=1, may not be used in a .udc file
                  nrow >= 1
                  ncol >= 1
                  pmtrName must not start with '@'
                  if despmtr=0, then marked as INTERNAL
                  if despmtr=1, then marked as EXTERNAL
                  if despmtr=1, then may not be used in a .udc file
                  if despmtr=1, then does not create a Branch
                  old values are not overwritten
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="dump">dump</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
DUMP      $filename remove=0 toMark=0
          use:    write a file that contains the Body
          pops:   Body1 (if remove=1)
          pushes: -
          notes:  Solver may not be open
                  if file exists, it is overwritten
                  filename is used directly (without evaluation)
                  if filename starts with '$/', it is prepended with path of
                     the .csm file
                  if remove=1, then Body1 is removed after dumping
                  if toMark=1, all Bodys back to the Mark (or all if no Mark)
                     are combined into a single model
                  if toMark=1, the remove flag is ignored
                  for .ugrid files, toMark must be 0
                  valid filetypes are:
                     .brep   .BREP   --> OpenCASCADE output
                     .bstl   .BSTL   --> binary stl  output
                     .egads  .EGADS  --> EGADS       output
                     .egg    .EGG    --> EGG restart output
                     .iges   .IGES   --> IGES        output
                     .igs    .IGS    --> IGES        output
                     .sens   .SENS   --> ASCII sens  output
                     .step   .STEP   --> STEP        output
                     .stl    .STL    --> ASCII stl   output
                     .stp    .STP    --> STEP        output
                     .tess   .TESS   --> ASCII tess  output
                     .ugrid  .UGRID  --> ASCII AFRL3 output
                  if .bstl, use _stlColor from Face, Body, or 0 for color
                  if .egads, set _despmtr_* and _outpmtr_ Attributes on Model
                  signals that may be thrown/caught:
                     $file_not_found
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="else">else</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ELSE
          use:    execute or skip a Block of Branches
          pops:   -
          pushes: -
          notes:  inner-most Block must be an Ifthen Block
                  must follow an IFTHEN or ELSEIF statment
                  if preceeding (matching) IFTHEN or ELSEIF evaluated true,
                     then skip Branches up to the matching ENDIF
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="elseif">elseif</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ELSEIF    val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0
          use:    execute or skip a sequence of Branches
          pops:   -
          pushes: -
          notes:  inner-most Block must be an Ifthen Block
                  must follow an IFTHEN or ELSEIF statement
                  if preceeding (matching) IFTHEN or ELSEIF evaluated true,
                     then skip Branches up to matching ENDIF
                  op1 must be one of: lt LT le LE eq EQ ge GE gt GT ne NE
                  op2 must be one of: or OR and AND xor XOR
                  op3 must be one of: lt LT le LE eq EQ ge GE gt GT ne NE
                  if expression evaluates false, skip Branches up to next
                     ELSEIF, ELSE, or ENDIF
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="end">end</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
END
          use:    signifies end of .csm or .udc file
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  Bodys on Stack are returned last-in-first-out
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="endif">endif</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ENDIF
          use:    terminates an Ifthen Block of Branches
          pops:   -
          pushes: -
          notes:  inner-most Block must be an Ifthen Block
                  must follow an IFTHEN, ELSEIF, or ELSE
                  closes Ifthen Block
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="evaluate">evaluate</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
EVALUATE  $type arg1 ...
          use:    evaluate coordinates of NODE, EDGE, or FACE
          pops:   -
          pushes: -
          notes:  if     arguments are: "node ibody inode"
                     ibody is Body number (bias-1)
                     inode is Node number (bias-1)
                     return in @edata:
                        x, y, z
                  elseif arguments are: "edge ibody iedge t"
                     ibody is Body number (bias-1)
                     iedge is Edge number (bias-1)
                     evaluate Edge at given t
                     return in @edata:
                        t (clipped),
                        x,      y,      z,
                        dxdt,   dydt,   dzdt,
                        d2xdt2, d2ydt2, d2zdt2
                  elseif arguments are: "edge ibody iedge $beg"
                     ibody is Body number (bias-1)
                     iedge is Edge number (bias-1)
                     evaluate Edge at given t
                     return in @edata:
                        t (clipped),
                        x,      y,      z,
                        dxdt,   dydt,   dzdt,
                        d2xdt2, d2ydt2, d2zdt2
                  elseif arguments are: "edge ibody iedge $end"
                     ibody is Body number (bias-1)
                     iedge is Edge number (bias-1)
                     evaluate Edge at given t
                     return in @edata:
                        t (clipped),
                        x,      y,      z,
                        dxdt,   dydt,   dzdt,
                        d2xdt2, d2ydt2, d2zdt2
                  elseif arguments are: "edgerng ibody iedge"
                     ibody is Body number (bias-1)
                     iedge is Edge number (bias-1)
                     return in @edata:
                        tmin, tmax
                  elseif arguments are: "edgeinv ibody iedge x y z"
                     ibody is Body number (bias-1)
                     iedge is Edge number (bias-1)
                     inverse evaluate Edge at given (x,y,z)
                     return in @edata:
                        t,
                        xclose,  yclose,  zclose
                  elseif arguments are: "face ibody iface u v"
                     ibody is Body number (bias-1)
                     iface is Face number (boas-1)
                     evaluate Face at given (u,v)
                     return in @edata:
                        u (clipped), v (clipped),
                        x,       y,       z,
                        dxdu,    dydu,    dzdu,
                        dxdv,    dydv,    dzdv,
                        d2xdu2,  d2ydu2,  d2zdu2,
                        d2xdudv, d2ydudv, d2zdudv,
                        d2xdv2,  d2ydv2,  d2zdv2
                  elseif arguments are: "facerng ibody iface"
                     ibody is Body number (bias-1)
                     iface is Face number (bias-1)
                     return in @edata:
                        umin, umax, vmin, vmax
                  elseif arguments are: "faceinv ibody iface x y z"
                     ibody is Body number (bias-1)
                     iface is Face number (boas-1)
                     inverse evaluate Face at given (x,y,z)
                     return in @edata:
                        u,       v,
                        xclose,  yclose,  zclose
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  signals that may be thrown/caught:
                     $body_not_found
                     $edge_not_found
                     $face_not_found
                     $node_not_found
        </pre>
      <p><h3 id="extract">extract</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
EXTRACT   entList
          use:    extract Face(s) or Edge(s) from a Body
          pops:   Body1
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  all members of entList must have the same sign
                  Body1 must be a SolidBody or a SheetBody
                  if     entList entries are all positive
                     create SheetBody from entList Face(s) of Body1
                  elseif entList entries are all negative
                     create WireBody from -entList Edge(0) of Body1
                  elseif Body1=SolidBody and entList=0
                     create SheetBody from outer Shell of Body1
                  elseif Body1=SheetBody and entList=0
                     create WireBody from outer Loop of Body1
                  endif
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
                     $did_not_create_body
                     $illegal_value
                     $edge_not_found
                     $face_not_found
        </pre>
      <p><h3 id="extrude">extrude</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
EXTRUDE   dx dy dz
          use:    create a Body by extruding a Sketch
          pops:   Sketch
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if Sketch is a SheetBody, then a SolidBody is created
                  if Sketch is a WireBody, then a SheetBody is created
                  sensitivity computed w.r.t. dx, dy, dz
                  computes Face sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Sketch are maintained
                  face-order is: (base), (end), feat1, ...
                  signals that may be thrown/caught:
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="fillet">fillet</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
FILLET    radius edgeList=0 listStyle=0
          use:    apply a fillet to a Body
          pops:   Body
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if listStyle==0
                     if previous operation is boolean, apply to all new Edges
                     edgeList=0 is the same as edgeList=[0;0]
                     edgeList is a multi-value Parameter or a semicolon-separated
                        list
                     pairs of edgeList entries are processed in order
                     pairs of edgeList entries are interpreted as follows:
                        col1  col2   meaning
                         =0    =0    add all Edges
                         >0    >0    add    Edges between iford=+icol1
                                                      and iford=+icol2
                         <0    <0    remove Edges between iford=-icol1
                                                      and iford=-icol2
                         >0    =0    add    Edges adjacent to iford=+icol1
                         <0    =0    remove Edges adjacent to iford=-icol1
                  else
                     edgeList contains Edge number(s)
                  sensitivity computed w.r.t. radius
                  sets up @-parameters
                  new Faces all receive the Branch's Attributes
                  face-order is based upon order that is returned from EGADS
                  signals that may be thrown/caught:
                     $illegal_argument
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="getattr">getattr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
GETATTR   $pmtrName attrID global=0
          use:    store an Attribute value(s) in an INTERNAL Parameter
          pops:   -
          pushes: -
          Notes:  pmtrName must be in form 'name', without subscripts
                  pmtrName must not start with '@'
                  pmtrName must not refer to an EXTERNAL/CONSTANT Parameter
                  pmtrName will be marked as INTERNAL (or OUTPUT)
                  pmtrName is used directly (without evaluation)
                  the type of pmtrName is changed to match the result
                  if global==0, then
                     applies to Attributes on the selected Body
                  else
                     applies to global Attributes
                  if attrID is $_nattr_ then number of Attributes
                     will be retrieved into a scalar or indexed entry
                  if attrID is an integer (i), then the name of the
                     i'th (bias-1) Attribute will be retreived into a
                     string Parameter
                  Attributes are retrieved from last Body or from a Body,
                     Face, or Edge if it follows a SELECT statement
                  signals that may be thrown/caught:
                     $illegal_pmtr_index, $illegal_attribute
        </pre>
      <p><h3 id="group">group</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
GROUP     nbody=0
          use:    create a Group of Bodys since Mark for subsequent
                     transformations
          pops:   Body1 ... Mark  -or-  Body1 ...
          pushes: Body1 ...
          notes:  Sketch may not be open
                  Solver may not be open
                  if nbody>0,   then nbody Bodys on stack are in Group
                  if nbody<0,   then Bodys are ungrouped
                  if no Mark on stack, all Bodys on stack are in Group
                  the Mark is removed from the stack
                  Attributes are set on all Bodys in Group
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="hollow">hollow</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
HOLLOW    thick=0 entList=0 listStyle=0
          use:    hollow out a SolidBody or SheetBody
          pops:   Body
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if SolidBody (radius is ignored)
                     if thick=0 and entList==0
                         convert to SheetBody
                     if thick=0 and entList!=0
                        convert to SheetBody without Faces in entList (if connected)
                     if thick>0 and entList==0
                        smaller offset Body is created
                     if thick<0 and entList==0
                        larger offset Body is created
                     if thick>0 and entList!=0
                        hollow (removing entList) with new Faces inside  original Body
                     if thick<0 and entList!=0
                        hollow (removing entList) with new Faces outside original Body
                  if a SheetBody with only one Face
                     if thick=0 and entList==0
                        convert to WireBody (if connected)
                     if thick=0 and entList!=0
                        convert to WireBody without Edges in entList (if connected)
                     if thick>0 and entList==0
                        smaller offset Body is created
                     if thick<0 and entList==0
                        larger offset Body is created
                     if thick>0 and entList!=0
                        hollow (removing entList) with new Edges inside  original Body
                     if thick<0 and entList!=0
                        hollow (removing entList) with new Edges outside original Body
                  if a SheetBody with multiple Faces
                     if thick=0 and entList!=0
                        remove Faces in entList (if connected)
                     if thick>0 and entList==0
                        hollow all Faces with new Edges inside original Faces
                     if thick>0 and entList!=0
                        hollow Faces in entList with new Edges inside original Faces
                  entList is multi-valued Parameter, or a semicolon-separated list
                  if listStyle==0 and a SolidBody
                     pairs of entList entries are processed in order
                        the first  entry in a pair indicates the Body when
                           Face was generated (see first number in _body Attribute)
                        the second entry in a pair indicates the face-order (see
                           second number in _body Attribute)
                  otherwise
                     entries in entList are Edge or Face numbers
                  sensitivity computed w.r.t. thick
                  sets up @-parameters
                  new Faces all receive the Branch's Attributes
                  face-order is based upon order that is returned from EGADS
                  signals that may be thrown/caught:
                     $illegal_argument
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="ifthen">ifthen</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
IFTHEN    val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0
          use:    execute or skip a Block of Branches
          pops:   -
          pushes: -
          notes:  works in combination with ELSEIF, ELSE, and ENDIF statements
                  op1 must be one of: lt LT le LE eq EQ ge GE gt GT ne NE
                  op2 must be one of: or OR and AND xor XOR
                  op3 must be one of: lt LT le LE eq EQ ge GE gt GT ne NE
                  if expression evaluates false, skip Block of Branches up
                     to next (matching) ELSEIF, ELSE, or ENDIF are skipped
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="import">import</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
IMPORT    $filename bodynumber=1
          use:    import from filename
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  filename is used directly (without evaluation)
                  if filename starts with '$$/', use path relative to .csm file
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is based upon order in file
                  signals that may be thrown/caught:
                     $did_not_create_body
                     udp-specific code
        </pre>
      <p><h3 id="interface">interface</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
INTERFACE $argName $argType default=0
          use:    defines an argument for a .udc file
          pops:   -
          pushes: -
          notes:  only allowed in a .udc file
                  must be placed before any executable statement
                  argType must be "in", "out", "dim", or "all"
                  if argType=="dim", then default contains number of elements
                  if argType=="dim", the default values are zero
                  if argType=="all", a new scope is not created (and
                                     $argName is ignored)
                  a string variable can be passed into UDC if default
                     is a string
                  a string varaible can be passed out of UDC
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  signals that may be thrown/caught:
                     $pmtr_is_constant
        </pre>
      <p><h3 id="intersect">intersect</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
INTERSECT $order=none index=1 maxtol=0
          use:    perform Boolean intersection (Body2 & Body1)
          pops:   Body1 Body2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if     Body1=SolidBody and Body2=SolidBody
                     create SolidBody that is common part of Body1 and Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=SolidBody and Body2=SheetBody
                     create SheetBody that is the part of Body2 that is
                        inside Body1
                     if index=-1, then all Bodys are returned
                  elseif Body1=SolidBody and Body2=WireBody
                     create WireBody that is the part of Body2 that is
                        inside Body1
                     if index=-1, then all Bodys are returned
                  elseif Body1=SheetBody and Body2=SolidBody
                     create SheetBody that is the part of Body1 that is
                        inside Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=SheetBody and Body2=SheetBody and Bodys are
                        co-planar
                     create SheetBody that is common part of Body1 and Body2
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body1=SheetBody and Body2=SheetBody and Bodys are not
                        co-planar
                     create WireBody at the intersection of Body1 and Body2
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body1=SheetBody and Body2=WireBody
                     create WireBody that is the part of Body2 that is
                        inside Body1
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body1=WireBody and Body2=SolidBody
                     create WireBody that is the part of Body1 that is
                        inside Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=WireBody and Body2=SheetBody
                     create WireBody that is the part of Body1 that is
                        inside Body2
                     CURRENTLY NOT IMPLEMENTED
                  endif
                  if intersection does not produce at least index Bodys, an
                     error is returned
                  order may be one of:
                     none    same order as returned from geometry engine
                     xmin    minimum xmin   is first
                     xmax    maximum xmax   is first
                     ymin    minimum ymin   is first
                     ymax    maximum ymax   is first
                     zmin    minimum zmin   is first
                     zmax    maximum zmax   is first
                     amin    minimum area   is first
                     amax    maximum area   is first
                     vmin    minimum volume is first
                     vmax    maximum volume is first
                  order is used directly (without evaluation)
                  if maxtol>0, then tolerance can be relaxed until successful
                  if maxtol<0, then use -maxtol as only tolerance to use
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="join">join</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
JOIN      toler=0 toMark=0
          use:    join two Bodys at a common Edge or Face
          pops:   Body1 Body2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if toMark=1 and all Bodys to Mark are SheetBodys
                     create SheetBody
                  elseif toMark=1 and all Bodys to Mark are WireBodys
                     create WireBody
                  elseif Body1=SolidBody and Body2=SolidBody
                     create SolidBody formed by joining Body1 and Body2 at
                        common Faces
                  elseif Body1=SheetBody and Body2=SheetBody
                     create SheetBody formed by joining Body1 and Body2 at
                        common Edges
                  elseif Body1=WireBody and Body2=WireBody
                     create WireBody formed by joining Body1 and Body2 at
                        common end Node
                  endif
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $created_too_many_bodys
                     $did_not_create_body
                     $face_not_found
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="lbound">lbound</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
LBOUND    $pmtrName bounds
          use:    defines a lower bound for a design or configuration Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a function-type .udc file
                  if value of Parameter is smaller than bounds, a warning is
                     generated
                  pmtrName must have been defined previously by DESPMTR
                     statement
                  pmtrName can be in form 'name' or 'name[irow,icol]'
                  pmtrName must not start with '@'
                  pmtrName is used directly (without evaluation)
                  irow and icol cannot contain a comma or open bracket
                  if irow is a colon (:), then all rows    are input
                  if icol is a colon (:), then all columns are input
                  pmtrName[:,:] is equivalent to pmtrName
                  bounds cannot refer to any other Parameter
                  bounds are defined across rows, then across columns
                  if bounds has more entries than needed, extra bounds
                     are lost
                  if bounds has fewer entries than needed, last bound
                     is repeated
                  any previous bounds are overwritten
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="linseg">linseg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
LINSEG    x y z
          use:    create a new line segment, connecting the previous
                     and specified points
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  sensitivity computed w.r.t. x, y, z
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="loft">loft</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
LOFT      smooth
          use:    create a Body by lofting through Sketches since Mark
          pops:   Sketch1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  all Sketches must have the same number of Segments
                  if Sketch is a SheetBody, then a SolidBody is created
                  if Sketch is a WireBody, then a SheetBody is created
                  the Faces all receive the Branch's Attributes
                  Attributes on Sketches are not maintained
                  face-order is: (base), (end), feat1, ...
                  if NINT(smooth)=1, then sections are smoothed
                  the first and/or last Sketch can be a point

                  LOFT (through OpenCASCADE) is not very robust
                  use BLEND or RULE if possible
                  sets up @-parameters
                  MAY BE DEPRECATED (use RULE or BLEND)
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="macbeg">macbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MACBEG    imacro
          use:    marks the start of a macro
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  imacro must be between 1 and 100
                  cannot overwrite a previous macro
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  MAY BE DEPRECATED (use UDPRIM)
        </pre>
      <p><h3 id="macend">macend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MACEND
          use:    ends a macro
          pops:   -
          pushes: -
          notes:  cannot be followed by ATTRIBUTE or CSYSTEM
                  MAY BE DEPRECATED (use UDPRIM)
        </pre>
      <p><h3 id="mark">mark</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MARK
          use:    used to identify groups such as in RULE, BLEND, or GROUP
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="mirror">mirror</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
MIRROR    nx ny nz dist=0
          use:    mirrors Group on top of Stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  normal of the mirror plane is given by nx,ny,nz
                  mirror plane is dist from origin
                  sensitivity computed w.r.t. nx, ny, nz, dist
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="name">name</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
NAME      $branchName
          use:    names the entry on top of Stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  does not create a Branch
        </pre>
      <p><h3 id="outpmtr">outpmtr</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
OUTPMTR   $pmtrName
          use:    define an output INTERNAL Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a .udc file
                  pmtrName must be in form 'name'
                  pmtrName must not start with '@'
                  pmtrName will be marked as OUTPUT
                  pmtrName is used directly (without evaluation)
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="patbeg">patbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
PATBEG    $pmtrName ncopy
          use:    execute a Block of Branches ncopy times
          pops:   -
          pushes: -
          notes:  Solver may not be open
                  Block contains all Branches up to matching PATEND
                  pmtrName must not start with '@'
                  pmtrName takes values from 1 to ncopy (see below)
                  pmtrName is used directly (without evaluation)
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="patbreak">patbreak</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
PATBREAK  expr
          use:    break out of inner-most Patbeg Block if expr>0
          pops:   -
          pushes: -
          notes:  Solver may not be open
                  must be in a Patbeg Block
                  skip to Branch after matching PATEND if expr>0
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="patend">patend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
PATEND
          use:    designates the end of a Patbeg Block
          pops:   -
          pushes: -
          notes:  Solver may not be open
                  inner-most Block must be a Patbeg Block
                  closes Patbeg Block
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="point">point</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
POINT     xloc yloc zloc
          use:    create a single point Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xloc, yloc, zloc
                  computes Node sensitivity analytically
                  sets up @-parameters
        </pre>
      <p><h3 id="project">project</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
PROJECT   x y z dx dy dz useEdges=0
          use:    find the first projection from given point in given
                     direction
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  if useEdges!=1
                      look for intersections with Faces and overwrite @iface
                  else
                      look for intersections with Edges and overwrite @iedge
                  endif
                  over-writes the following @-parameters: @xcg, @ycg, and @zcg
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  signals that may be thrown/caught:
                     $face_not_found
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="recall">recall</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
RECALL    imacro
          use:    recalls copy of macro from a storage location imacro
          pops:   -
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  storage location imacro must have been previously filled by
                     a MACBEG statement
                  MAY BE DEPRECATED (use UDPRIM)
        </pre>
      <p><h3 id="reorder">reorder</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
REORDER   ishift iflip=0
          use:    change the order of Edges in a Body
          pops:   Body1
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  it is generally better to use reorder argument in
                     RULE and BLEND than this command
                  Body1 must be either WireBody or SheetBody Body
                  Body1 must contain 1 Loop
                  if the Loop is open, ishift must be 0
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="restore">restore</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
RESTORE   $name index=0
          use:    restores Body(s) that was/were previously stored
          pops:   -
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  $name is used directly (without evaluation)
                  sets up @-parameters
                  error results if nothing has been stored in name
                  the Faces all receive the Branch's Attributes
                  signals that may be thrown/caught:
                     $name_not_found
        </pre>
      <p><h3 id="revolve">revolve</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
REVOLVE   xorig yorig zorig dxaxis dyaxis dzaxis angDeg
          use:    create a Body by revolving a Sketch around an axis
          pops:   Sketch
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if Sketch is a SheetBody, then a SolidBody is created
                  if Sketch is a WireBody, then a SheetBody is created
                  sensitivity computed w.r.t. xorig, yorig, zorig, dxaxis,
                     dyaxis, dzaxis, andDeg
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Sketch are maintained
                  face-order is: (base), (end), feat1, ...
                  signals that may be thrown/caught:
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="rotatex">rotatex</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ROTATEX   angDeg yaxis zaxis
          use:    rotates Group on top of Stack around x-like axis
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. angDeg, yaxis, zaxis
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="rotatey">rotatey</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ROTATEY   angDeg zaxis xaxis
          use:    rotates Group on top of Stack around y-like axis
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. angDeg, zaxis, xaxis
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="rotatez">rotatez</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
ROTATEZ   angDeg xaxis yaxis
          use:    rotates Group on top of Stack around z-like axis
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. angDeg, xaxis, yaxis
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="rule">rule</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
RULE      reorder=0
          use:    create a Body by creating ruled surfaces thru Sketches
                     since Mark
          pops:   Sketch1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if reorder!=0 then Sketches are reordered to minimize Edge
                     lengths
                  first Sketch is unaltered if reorder>0
                  last  Sketch is unaltered if reorder<0
                  all Sketches must have the same number of Edges
                  if all Sketches are WireBodys, then a SheetBody is created
                     otherwise a SolidBody is created
                  the first and/or last Sketch can be a point
                  computes Face sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Sketch are maintained
                  face-order is: (base), (end), feat1:part1,
                     feat1:part2, ... feat2:part1, ...
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $error_in_bodys_on_stack
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="scale">scale</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SCALE     fact xcent=0 ycent=0 zcent=0
          use:    scales Group on top of Stack around given point
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  (xcent,ycent,zcent are not yet implemented)
                  sensitivity computed w.r.t. fact
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="select">select</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SELECT    $type arg1 ...
          use:    selects entity for which @-parameters are evaluated
          pops:   -
          pushes: -
          notes:  if     arguments are: "body"
                     sets @seltype to -1
                     sets @selbody to @nbody
                     sets @sellist to -1
                  elseif arguments are: "body ibody"
                     sets @seltype to -1
                     sets @selbody to ibody
                     sets @sellist to -1
                  elseif arguments are: "body -n"
                     sets @seltype to -1
                     sets @selbody to the nth from the top of the stack
                     sets @sellist to -1
                  elseif arguments are: "body attrName1    attrValue1
                                              attrName2=$* attrValue2=$*
                                              attrName3=$* attrValue3=$*"
                     sets @seltype to -1
                     uses @selbody to Body that match all Attributes
                     sets @sellist to -1
                  elseif arguments are: "face"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist to all Faces
                  elseif arguments are: "face iface"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist to iface
                  elseif arguments are: "face 0 iford1" or
                                        "face ibody1 0"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist with Faces in @selbody that matches ibody1/iford1
                                   (with 0 being treated as a wildcard)
                  elseif arguments are: "face ibody1 iford1 iseq=1"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist with Face in @selbody that matches ibody1/iford1
                  elseif arguments are: "face xmin xmax ymin ymax zmin zmax"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist to Faces whose bboxs are in given range
                  elseif arguments are: "face attrName1    attrValue1
                                              attrName2=$* attrValue2=$*
                                              attrName3=$* attrValue3=$*"
                     sets @seltype to 2
                     uses @selbody
                     sets @sellist to Faces in @selbody that match all Attributes
                  elseif arguments are: "edge"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to all Edges
                  elseif arguments are: "edge iedge"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to iedge
                  elseif arguments are: "edge 0 iford1 ibody2 iford2" or
                                        "edge ibody1 0 ibody2 iford2" or
                                        "edge ibody1 iford1 0 iford2" or
                                        "edge ibody1 iford1 ibody2 0" or
                                        "edge ibody1 0 ibody2 0"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edge in @selbody that adjoins Faces
                        ibody1/iford1 and ibody2/iford2 (with 0 being treated as wildcard)
                  elseif arguments are: "edge ibody1 iford1 ibody2 iford2 iseq=1"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edge in @selbody that adjoins Faces
                        ibody1/iford1 and ibody2/iford2
                  elseif arguments are: "edge xmin xmax ymin ymax zmin zmax"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edges whose bboxs are in given range
                  elseif arguments are: "edge attrName1    attrValue1
                                              attrName2=$* attrValue2=$*
                                              attrName3=$* attrValue3=$*"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edges in @selbody that match all Attributes
                  elseif arguments are: "edge x y z"
                     sets @seltype to 1
                     uses @selbody
                     sets @sellist to Edge whose center is closest to (x,y,z)
                  elseif arguments are: "node"
                     sets @seltype to 0
                     uses @selbody
                     sets @sellist to all Nodes
                  elseif arguments are: "node inode"
                     sets @seltype to 0
                     uses @selbody
                     sets @sellist to inode
                  elseif arguments are: "node x y z"
                     sets @seltype to 0
                     uses @selbodt
                     sets @sellist to Node closest to (x,y,z)
                  elseif arguments are: "node xmin xmax ymin ymax zmin zmax"
                     sets @seltype to 0
                     uses @selbody
                     sets @sellist to Nodes whose bboxs are in given range
                  elseif arguments are: "node attrName1    attrValue1
                                              attrName2=$* attrValue2=$*
                                              attrName3=$* attrValue3=$*"
                     sets @seltype to 0
                     uses @selbody
                     sets sellist to Nodes in @selbody that match all Attributes
                  elseif arguments are: "add attrName1    attrValue1
                                             attrName2=$* attrValue2=$*
                                             attrName3=$* attrValue3=$*"
                     uses @seltype
                     uses @selbody
                     appends to @selList the Nodes/Edges/Faces that match all Attributes
                  elseif arguments are: "add ibody1 iford1 iseq=1" and @seltype is 2
                     uses @selbody
                     appends to @sellist the Face in @selbody that matches ibody1/iford1
                  elseif arguments are: "add ibody1 iford1 ibody2 iford2 iseq=1" and @seltype is 1
                     uses @selbody
                     appends to @sellist the Edge in @selbody that adjoins Faces
                  elseif arguments are: "add iface" and @seltype is 2
                     uses @selbody
                     appends to @sellist Face iface in @selbody
                  elseif arguments are: "add iedge" and @seltype is 1
                     uses @selbody
                     appends to @sellist Edge iedge in @selbody
                  elseif arguments are: "add inode" and @seltype is 0
                     uses @selbody
                     appends to @sellist Node inode in @selbody
                  elseif arguments are: "sub attrName1    attrValue1
                                             attrName2=$* attrValue2=$*
                                             attrName3=$* attrValue3=$*"
                     uses @seltype
                     uses @selbody
                     removes from @sellist the Nodes/Edges/Faces that match all Attributes
                  elseif arguments are: "sub ibody1 iford1 iseq=1" and @seltype is 2
                     uses @selbody
                     removes from @sellist the Face in @selbody that matches ibody1/iford1
                  elseif arguments are: "sub ibody1 iford1 ibody2 iford2 iseq=1" and @seltype is 1
                     uses @selbody
                     removes from @sellist the Edge in @selbody that adjoins Faces
                  elseif arguments are: "sub ient" and ient is in @sellist
                     removes from @sellist ient
                  elseif arguments are: "sort $key"
                     sorts @sellist based upon $key which can be: $xmin, $ymin, $zmin,
                        $xmax, $ymax, $zmax, $xcg, $ycg, $zcg, $area, or $length

                  Face specifications are stored in _faceID Attribute
                  Edge specifications are stored in _edgeID Attribute
//                Node specifications are stored in _nodeID Attribute
                  iseq selects from amongst multiple Faces/Edges/Nodes that
                     match the ibody/iford specifications
                  attrNames and attrValues can be wild-carded
                  avoid using forms "SELECT face iface" and "SELECT edge iedge"
                     since iface and iedge are not guaranteed to be the same during
                     rebuilds or on different OpenCASCADE versions or computers
                  sets up @-parameters
                  cannot be followed by CSYSTEM
                  signals that may be thrown/caught:
                     $body_not_found
                     $edge_not_found
                     $face_not_found
                     $node_not_found
        </pre>
      <p><h3 id="set">set</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SET       $pmtrName exprs
          use:    define a (redefinable) INTERNAL Parameter
          pops:   -
          pushes: -
          notes:  Solver may not be open
                  pmtrName can be in form 'name', 'name[irow]', or 'name[irow,icol]'
                  pmtrName must not start with '@'
                  pmtrName must not refer to an EXTERNAL/CONSTANT Parameter
                  pmtrName will be marked as INTERNAL
                  pmtrName is used directly (without evaluation)
                  irow and icol cannot contain a comma or open bracket
                  if in form 'name[irow]' then icol=1
                  if exprs starts with $, then a string value is defined
                  string values can only have one row and one column
                  if exprs has multiple values (separated by ;), then
                     any subscripts in pmtrName are ignored
                  multi-valued parameters can be copied as a whole
                  exprs are defined across rows
                  if exprs is longer than Parameter size, extra exprs are lost
                  if exprs is shorter than Parameter size, last expr is repeated
                  if no Bodys have been created yet
                     associated ATTRIBUTEs are global Attributes
                  otherwise
                     cannot be followed by ATTRIBUTE
                  cannot be folowed by CSYSTEM
        </pre>
      <p><h3 id="skbeg">skbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SKBEG     x y z relative=0
          use:    start a new Sketch with the given point
          pops:   -
          pushes: -
          notes:  opens Sketch
                  Solver may not be open
                  if relative=1, then all values in sketch are relative to x,y,z
                  sensitivity computed w.r.t. x, y, z
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="skcon">skcon</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SKCON     $type index1 index2=-1 $value=0
          use:    creates a Sketch constraint
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  may only follow SKVAR or another SKCON statement
                  $type
                     X  ::x[index1]=value
                     Y  ::y[index1]=value
                     Z  ::z[index1]=value
                     P  segments adjacent to point index1 are perpendicular
                     T  segments adjacent to point index1 are tangent
                     A  segments adjacent to point index1 have
                                                           angle=$value (deg)
                     W  width:  ::x[index2]-::x[index1]=value  if plane==xy
                                ::y[index2]-::y[index1]=value  if plane==yz
                                ::z[index2]-::z[index1]=value  if plane==zx
                     D  depth:  ::y[index2]-::y[index1]=value  if plane==xy
                                ::z[index2]-::z[index1]=value  if plane==zx
                                ::x[index2]-::x[index1]=value  if plane==zx
                     H  segment from index1 and index2 is horizontal
                     V  segment from index1 and index2 is vertical
                     I  segment from index1 and index2 has
                                                     inclination=$value (deg)
                     L  segment from index1 and index2 has length=$value
                     R  cirarc  from index1 and index2 has radius=$value
                     S  cirarc  from index1 and index2 has sweep=$value (deg)
                  index=1 refers to point in SKBEG statement
                  $value can include the following variables
                     ::x[i]  X-coordinate of point i
                     ::y[i]  Y-coordinate of point i
                     ::z[i]  Z-coordinate of point i
                     ::d[i]  dip associated with segment starting at point i
                  $value can include the following shorthands
                     ::L[i]  length      of segment starting at point i
                     ::I[i]  inclination of segment starting at point i  (degrees)
                     ::R[i]  radius of arc          starting at point i
                     ::S[i]  sweep  of rc           starting at point i  (degrees)
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="skend">skend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SKEND     wireonly=0
          use:    completes a Sketch
          pops:   -
          pushes: Sketch
          notes:  Sketch must be open
                  Solver may not be open
                  if Sketch contains SKVAR/SKCON, then Sketch variables are
                     updated first
                  if wireonly=0, all LINSEGs and CIRARCs must be x-, y-, or
                     z-co-planar
                  if Sketch is     closed and wireonly=0,
                     then a SheetBody is created
                  if Sketch is     closed and wireonly=1,
                     then a WireBody  is created
                  if Sketch is not closed,
                     then a WireBody  is created
                  if SKEND immediately follows SKBEG, then a NODE is created
                     (which can be used at either end of a LOFT or BLEND)
                  closes Sketch
                  new Face receives the Branch's Attributes
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $colinear_sketch_points
                     $non_coplnar_sketch_points
                     $self_intersecting
        </pre>
      <p><h3 id="skvar">skvar</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SKVAR     $type valList
          use:    create multi-valued Sketch variables and their initial
                     values
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  may only follow SKBEG statement
                  $type
                     xy valList contains ::x[1]; ::y[1]; ::d[1]; ::x[2]; ...
                     yz valList contains ::y[1]; ::z[1]; ::d[1]; ::y[2]; ...
                     zx valList contains ::z[1]; ::x[1]; ::d[1]; ::z[2]; ...
                  valList is a semicolon-separated list
                  valList must end with a semicolon
                  the number of entries in valList is taken from number of
                     semicolons
                  the number of entries in valList must be evenly divisible by 3
                  enter :d[i] as zero for LINSEGs
                  values of ::x[1], ::y[1], and ::z[1] are overwritten by
                     values in SKBEG
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="solbeg">solbeg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SOLBEG    $varList
          use:    starts a Solver Block
          pops:   -
          pushes: -
          notes:  Solver must not be open
                  opens the Solver
                  varList is a list of semicolon-separated INTERNAL parameters
                  varList must end with a semicolon
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="solcon">solcon</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SOLCON    $expr
          use:    constraint used to set Solver parameters
          pops:   -
          pushes: -
          notes:  Sketch must not be open
                  Solver must be open
                  SOLEND will drive expr to zero
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="solend">solend</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SOLEND
          use:    designates the end of a Solver Block
          pops:   -
          pushes: -
          notes:  Sketch must not be open
                  inner-most Block must be a Solver Block
                  adjust parameters to drive constraints to zero
                  closes Solver Block
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="sphere">sphere</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SPHERE    xcent ycent zcent radius
          use:    create a sphere Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xcent, ycent, zcent, radius
                  computes Face, Edge, and Node sensitivities analytically
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: ymin, ymax
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="spline">spline</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SPLINE    x y z
          use:    add a point to a spline
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  sensitivity computed w.r.t. x, y, z
                  signals that may be thrown/caught:
        </pre>
      <p><h3 id="sslope">sslope</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SSLOPE    dx dy dz
          use:    define the slope at the beginning or end of a SPLINE
          pops:   -
          pushes: -
          notes:  Sketch must be open
                  Solver may not be open
                  for defining slope at beginning:
                      must not follow a SPLINE statement
                      must    precede a SPLINE statement
                  for definiing slope at end:
                      must      follow a SPLINE statement
                      must not precede a SPLINE statement
                  dx, dy, and dz must not all be zero
                  sensitivity computed w.r.t. x, y, z
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="store">store</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
STORE     $name index=0 keep=0
          use:    stores Group on top of Stack
          pops:   any
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  $name is used directly (without evaluation)
                  previous Group in name/index is overwritten
                  if $name=.   then Body is popped off stack
                                    but not actually stored
                  if $name=..  then pop Bodys off stack back
                                    to the Mark
                  if $name=... then the stack is cleared
                  if keep==1, the Group is not popped off stack
                  cannot be followed by ATTRIBUTE or CSYSTEM
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="subtract">subtract</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SUBTRACT  $order=none index=1 maxtol=0
          use:    perform Boolean subtraction (Body2 - Body1)
          pops:   Body1 Body2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if     Body1=SolidBody and Body2=SolidBody
                     create SolidBody that is the part of Body1 that is
                        outside Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=SolidBody and Body2=SheetBody
                     create SolidBody that is Body1 scribed with Edges at
                        intersection with Body2
                  elseif Body1=SheetBody and Body2=SolidBody
                     create SheetBody that is part of Body1 that is
                        outside Body2
                     if index=-1, then all Bodys are returned
                  elseif Body1=SheetBody and Body2=SheetBody
                     create SheetBody that is Body1 scribed with Edges at
                        intersection with Body2
                  elseif Body1=WireBody and Body2=SolidBody
                     create WireBody that is part of Body1 that is outside Body2
                     CURRENTLY NOT IMPLEMENTED
                  elseif Body1=WireBody and Body2=SheetBody
                     create WireBody that is Body1 scribed with Nodes at
                        intersection with Body2
                     CURRENTLY NOT IMPLEMENTED
                  endif
                  if subtraction does not produce at least index Bodys,
                     an error is returned
                  order may be one of:
                     none    same order as returned from geometry engine
                     xmin    minimum xmin   is first
                     xmax    maximum xmax   is first
                     ymin    minimum ymin   is first
                     ymax    maximum ymax   is first
                     zmin    minimum zmin   is first
                     zmax    maximum zmax   is first
                     amin    minimum area   is first
                     amax    maximum area   is first
                     vmin    minimum volume is first
                     vmax    maximum volume is first
                  if maxtol>0, then tolerance can be relaxed until successful
                  if maxtol<0, then use -maxtol as only tolerance to use
                  sets up @-parameters
                  order is used directly (without evaluation)
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="sweep">sweep</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
SWEEP
          use:    create a Body by sweeping a Sketch along a Sketch
          pops:   Sketch1 Sketch2
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  Sketch1 must be either a SheetBody or WireBody
                  Sketch2 must be a WireBody
                  if Sketch2 is not slope-continuous, result may not be
                     as expected
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  Attributes on Sketch are maintained
                  face-order is: (base), (end), feat1a, feat1b, ...
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>
      <p><h3 id="throw">throw</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
THROW     sigCode
          use:    set current signal to sigCode
          pops:   -
          pushes: -
          notes:  skip statements until a matching CATBEG Branch is found
                  sigCode>0 are usually user-generated signals
                  sigCode<0 are usually system-generated signals
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="torus">torus</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
TORUS     xcent ycent zcent dxaxis dyaxis dzaxis majorRad minorRad
          use:    create a torus Body
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. xcent, ycent, zcent, dxaxis,
                     dyaxis, dzaxis, majorRad, minorRad
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is: xmin/ymin, xmin/ymax, xmax/ymin, xmax/ymax
                  signals that may be thrown/caught:
                     $illegal_value
        </pre>
      <p><h3 id="translate">translate</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
TRANSLATE dx dy dz
          use:    translates Group on top of Stack
          pops:   any
          pushes: any
          notes:  Sketch may not be open
                  Solver may not be open
                  sensitivity computed w.r.t. dx, dy, dz
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $insufficient_bodys_on_stack
        </pre>
      <p><h3 id="ubound">ubound</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
UBOUND    $pmtrName bounds
          use:    defines an upper bound for a design or configuration Parameter
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  statement may not be used in a function-type .udc file
                  if value of Parameter is larger than bounds, a warning is
                     generated
                  pmtrName must have been defined previously by DESPMTR
                     statement
                  pmtrName can be in form 'name' or 'name[irow,icol]'
                  pmtrName must not start with '@'
                  pmtrName is used directly (without evaluation)
                  irow and icol cannot contain a comma or open bracket
                  if irow is a colon (:), then all rows    are input
                  if icol is a colon (:), then all columns are input
                  pmtrName[:,:] is equivalent to pmtrName
                  bounds cannot refer to any other Parameter
                  bounds are defined across rows, then across columns
                  if bounds has more entries than needed, extra bounds
                     are lost
                  if bounds has fewer entries than needed, last bound
                     is repeated
                  any previous bounds are overwritten
                  does not create a Branch
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="udparg">udparg</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
UDPARG    $primtype $argName1 argValue1 $argName2 argValue2 ...
                    $argName3 argValue3 $argName4 argValue4
          use:    pre-set arguments for next UDPRIM statement
          pops:   -
          pushes: -
          notes:  Sketch may not be open
                  Solver may not be open
                  there can be no statements except other UDPARGs before the
                     next matching UDPRIM
                  primtype determines the type of primitive
                  primtype must match primtype of next UDPRIM statement
                  primtype is used directly (without evaluation)
                  arguments are specified in name/value pairs and are
                      not positional
                  argName#  is used directly (without evaluation)
                  argValue# is used directly if it starts with '$', otherwise it
                     is evaluated
                  if argValue starts with '$$/', use path relative to .csm file
                  arguments for following UDPRIM statement are evaluated
                     in the order they are encountered (UDPARG first)
                  sensitivity computed w.r.t. argValue1, argValue2, argValue3,
                     argValue4
                  cannot be followed by ATTRIBUTE or CSYSTEM
        </pre>
      <p><h3 id="udprim">udprim</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
UDPRIM    $primtype $argName1 argValue1 $argName2 argValue2 ...
                    $argName3 argValue3 $argName4 argValue4
          use:    create a Body by executing a UDP, UDC, or UDF
          pops:   -
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  primtype  determines the type of primitive and the number of
                     argName/argValue pairs
                  if primtype begins with a letter
                     then a compiled udp whose name is primtype.so is used
                  if primtype starts with a /
                     then a .udc file in the current directory will be used
                  if primtype starts with $/
                     then a .udc file in the parent (.csm or .udc)
                     directory will be used
                  if primtype starts with $$/
                     then a .udc file in ESP_ROOT/udc will be used
                  primtype  is used directly (without evaluation)
                  arguments are specified in name/value pairs and are
                      not positional
                  argName#  is used directly (without evaluation)
                  argValue# is used directly if it starts with '$', otherwise it
                     is evaluated
                  if argValue# is <<, use data to matching >> as inline file
                  if argValue# starts with '$$/', use path relative to .csm file
                  extra arguments can be set with UDPARG statement
                  when called to execute a .udc file:
                     the level is incremented
                     INTERNAL Parameters are created for all INTERFACE stmts
                        for "in"  the value is set to its default
                        for "out" the value is set to its default
                        for "dim" an array is created (of size=value) with
                           value=dot=0
                     the associated UDPARG and UDPRIM statements are processed
                        in order
                        if argName matches a Parameter created by an INTERFACE
                           statement
                           if argValueX matches the name of a Parameter at
                              level-1
                              the values are copied into the new Parameter
                           else
                              argValueX is evalued and stored in the new
                                 Parameter
                        else
                           an error is returned
                     the statements in the .udc are executed until an END
                        statement
                        a SET statement either creates a new Parameter or
                           overwrites a value
                     during the execution of the END statement
                        for values associated with an INTERFACE "out" statement
                           the value is copied to the appropriate @@-parameter
                              (at level-1)
                        all Parameters at the current level are destroyed
                        the level is decremented
                  sensitivity computed w.r.t. argValue1, argValue2, argValue3,
                     argValue4
                  computes Face and Edge sensitivities analytically (if supplied
                     by the udp)
                  sets up @-parameters
                  the Faces all receive the Branch's Attributes
                  face-order is based upon order returned from UDPRIM
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $insufficient_bodys_on_stack
                     udp-specific code
                  see udp documentation for full information
        </pre>
      <p><h3 id="union">union</h3>
        <!-- extract from OpenCSM.h -->
        <pre>
UNION     toMark=0 trimList=0 maxtol=0
          use:    perform Boolean union
          pops:   Body1 Body2  -or-  Body1 ... Mark
          pushes: Body
          notes:  Sketch may not be open
                  Solver may not be open
                  if     toMark=1
                     create SolidBody that is combination of SolidBodys
                        since Mark
                  elseif Body1=SolidBody and Body2=SolidBody
                     if trimList=0
                        create SolidBody that us combination of Body1 and Body2
                     else
                        create SolidBody that is trimmed combination of Body1
                           and Body2
                        trimList contains x;y;z;dx;dy;dz where
                           (x,y,z) is inside the Body to be trimmed
                           (dx,dy,dz) is step toward the trimming Body
                     endif
                  elseif Body1=SheetBody and Body2=SheetBody
                     create SheetBody that is the combination of Bodys with
                        possible new Edges
                  endif
                  if maxtol>0, then tolerance can be relaxed until successful
                  if maxtol<0, then use -maxtol as only tolerance to use
                  sets up @-parameters
                  signals that may be thrown/caught:
                     $did_not_create_body
                     $illegal_value
                     $insufficient_bodys_on_stack
                     $wrong_types_on_stack
        </pre>

    <p><h3 id="sec5.5">5.5: User-Defined Primitives shipped with OpenCSM</h3>

      <pre>
UDPRIM bezier
       input arguments (specified as name/value pairs):
           filename   name of bezier file (prepended with '$' or '$$/')
           debug      =0 for no debug, =1 for debug   [default 0]
       output arguments:
           imax       number of points in i direction
           jmax       number of points in j direction
       usage:
           read imax, jmax
           for (j=0; j < jmax; j++)
               for (i=0; i < imax; i++)
                   read x(i,j), y(i,j), z(i,j)
               endfor
           endfor

           if (jmax==1)
               generate WIRE Body
           elseif (surface is open)
               generate SHEET Body
           else
               generate SOLID Body
           endif
       notes:
           vsp files can be converted to this format by vsp2csm

UDPRIM biconvex
       input arguments (specified as name/value pairs):
           thick      maximum thickness      [default 0]
           camber     maximum camber         [default 0]
       output arguments:
       notes:
           thick  must be positive
           camber must not exceed thick/2
           leading edge at (0,0,0)
           trailing edge at (1,0,0)
           airfoil generated in x-y plane

UDPRIM box
       input arguments (specified as name/value pairs):
           dx         width in x-direction   [default 0]
           dy         width in y-direction   [default 0]
           dz         width in z-direction   [default 0]
           rad        corner radius          [default 0]
       output arguments:
           area       overall surface area
           volume     enclosed volume
       usage:
           if     (dx>0 && dy>0 && dz>0)
               if (2*rad>dx && 2*rad>dy && 2*rad>dz)
                   ERROR
               elseif (rad>0)
                   generate SOLID Body with rounded edges
               else
                   generate SOLID Body
               endif
           elseif (dx==0 && dy>0 && dz>0)
               if (2*rad>dy && 2*rad>dz)
                   generate SHEET Body in yz-plane with rounded corners
               else
                   generate SHEET Body iy yz-plane
               endif
           elseif (dx>0 && dy==0 && dz>0)
               if (2*rad>dx && 2*rad>dz)
                   generate SHEET Body in xz-plane with rounded corners
               else
                   generate SHEET Body iy xz-plane
               endif
           elseif (dx>0 && dy>0 && dz==0)
               if (2*rad>dx && 2*rad>dy)
                   generate SHEET Body in xy-plane with rounded corners
               else
                   generate SHEET Body in xy-plane
               endif
           elseif (dx==0 && dy==0 && dz>0)
               generate WIRE Body along z-axis
           elseif (dx>0 && dy==0 && dz==0)
               generate WIRE Body along x-axis
           elseif (dx==0 && dy>0 && dz==0)
               generate WIRE Body along y-axis
           else
               ERROR
           endif
       notes:
           all Bodys are centered at origin

UDPRIM catmull
       input arguments (specified as name/value pairs):
          nsubdiv     number of subdivisions  [default 1]
          progress    level of outpus         [default 0]
       output arguments:
       usage:
          performs Catmull-Clark subdivisions on Body on top of stack
        notes:
          if a Face has a limitFace attribute
             the motion of points are limited in X, Y, and/or Z

UDPRIM createBEM
       input arguments (specified as name/value pairs):
          filename    name of output file
          space       nominal spacing         [default 0]
          imin        minimum points on Edge  [default 3]
          imax        maximum points on Edge  [default 5]
       output arguments:
       usage:
          creates a NASTRAN-stype BEM file from Body on stack

UDPRIM createPoly
       input arguments (specified as name/value pairs):
           filename   name of output file
           hole       coordinates of "hole"   [default 0;0;0]
       output arguments:
       usage:
           pops 2 Bodys from stack
           writes a AFLR .poly file between the two Bodys
           pushes the inner Body back onto the stack

UDPRIM csm
       input arguments (specified as name/value pairs):
           filename   name of .csm file
           pmtrname   semi-colon-separated list of Design
                         Parameters in filename
           pmtrvalue  multi-value list of Design Parameter
                         values
       output arguments:
           volume     volume of Body created
       usage:
           runs filename in a sub-process and returns
              last Body on the stack

UDPRIM editAttr
       input arguments (specified as name/value pairs):
          attrname    name of Attribute to edit
          input       string containing D B N E F characters
          output      string containing   B N E F characters
          overwrite   overwrite flag          [default 0]
                      0 do not overwrite
                      1        overwrite
                      2 use smaller value (or first alphabetical)
                      3 use larger  value (or last  alphabetical)
                      4 use sum                (or concatenation)
          filename    alternative file-base specification
                      (see wingAttrTest for an example)
          verbose     =1 to watch progress
       output arguments:
          nchange     number of changes made
       usage:
          attrname can use * as wildcard for zero or more chars
          attrname can use + as wildcard for one  or more chars
          attrname can use ? as wildcard for exactly one  char
          input and output must be same length or single character
          pops Body from stack
          loop through each character in input and output
              if (input[i]=D)
                 delete attribute from output[i]
              elseif (input[i]=B)
                 propagate Body attribute to output[i]
              elseif (input[i]=N)
                 propagate Node attribute to output[i]
              elseif (input[i]=E)
                 propagate Edge attribute to output[i]
              elseif (input[i]=F)
                 propagate Face attribute to output[i]
          pushes Attributed Body onto stack
       note:
          Attributes on Nodes and/or Edges may get lost during
             subsequent regeneration

UDPRIM ellipse
       input arguments (specified as name/value pairs):
           rx         radius in x-direction   [default 0]
           ry         radius in y-direction   [default 0]
           rz         radius in z-direction   [default 0]
           nedge      number of Edges         [default 2]
           thbeg      theta for first Node    [default 0]
       output arguments:
       usage:
           if     (rx==0 && ry>0 && rz>0)
               generate an elliptical SHEET Body in yz-plane
           elseif (rx>0 && ry==0 && rz>0)
               generate an elliptical SHEET Body in xz-plane
           elseif (rx>0 && ry>0 && rz==0)
               generate an elliptical SHEET Body in xy-plane
          else
               ERROR
          endif
       note:
           all Bodys are centered at origin

UDPRIM fitcurve
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
           ncp        number of control points    [default 0]
           ordered    =0 means points not ordered [default 1]
           periodic   =1 means periodicity at ends[default 0]
           xform      3*4 transformation matrix   [default 0]
       output arguments:
           npnt       number of point in file
           rms        rms of distances from points to curve
       usage:
           read points (X, Y, Z) from filename (on point per line)
           repeated points designate Node locations (which
              separate Edges)
           the Bspline is defined to be C2-continuous everywhere
           if (first and last points are the same)
              if (there are no repeated points)
                  ERROR (need at least two Edges)
              elseif (the points are planar)
                  a SheetBody is created
              else
                  ERROR (do not know how to "fill in" for Face)
              endif
           else
              a WireBody is created
           endif

UDPRIM freeform
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
           imax       number of points in i-direction   [default 1]
           jmax       number of points in j-direction   [default 1]
           kmax       number of points in k-direction   [default 1]
           xyz        coordinates
       output arguments:
       usage:
           if (filename exists)
               read imax, jmax, kmax
               if (kmax <= 1)
                   for (k=0; k < kmax; k++)
                       for (j=0; j < jmax; j++)
                           for (i=0; i < imax; i++)
                               if (i==0 || i==imax-1 ||
                                   j==0 || j==jmax-1 ||
                                   k==0 || k==kmax-1   )
                                   read x(i,j,k), y(i,j,k), z(i,j,k)
                               endif
                           endfor
                       endfor
                   endfor
               else
                   for (j=0; j < jmax; j++)
                       for (i=0; i < imax; i++)
                           read x(i,j,0), y(i,j,0), z(i,j,0)
                       endfor
                   endfor
               endif
           else
               for (k=0; k < kmax; k++)
                   for (j=0; j < jmax; j++)
                       for (i=0; i < imax; i++)
                           x(i,j,k) = xyz[3*(i+imax*(j+jmax*k)  ]
                           y(i,j,k) = xyz[3*(i+imax*(j+jmax*k)+1]
                           z(i,j,k) = xyz[3*(i+imax*(j+jmax*k)+2]
                       endfor
                   endfor
               endfor
           endif

           if     (jmax <= 1)
               generate WIRE Body
           elseif (kmax <= 1)
               generate SHEET Body
           else
               generate SOLID Body from outer planes of data
           endif

UDPRIM hex
       input arguments (specified as name/value pairs):
           corners    coordinate values at corners (24 values)
                         x0, y0, z0, x1, y1, z1, ...

                               ^ Y
                               |
                               2----------3
                              /:         /|
                             / :        / |
                            /  :       /  |
                           6----------7   |
                           |   0------|---1  --> X
                           |  '       |  /
                           | '        | /
                           |'         |/
                           4----------5
                          /
                         Z

       output arguments:
           area       surface area
           volume     volume of Body created
       usage:
           generates a hexahedron
           there are no check for duplicate vertices
           sensitvities not computed

UDPRIM import
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
           bodynumber number of body within filename (bias-1)   [default 1]
       output arguments:
           numbodies  number of bodys in file
       usage:
           read the .egads or .stp file
           extract the bodynumber'th Body

UDPRIM kulfan
       input arguments (specified as name/value pairs):
           class      class function at leading and trailing edge (2 values)
           ztail      height of upper and lower trailing edge (2 values)
           aupper     vector of control points for upper surface
           alower     vector of control points fpr lower surface
       output arguments:
       notes:
            always generates airfoil with 3 edges (upper, lower, TE)
            leading edge is at (0,0,0)
            airfoil generated in x-y plane

UDPRIM naca
       input arguments (specified as name/value pairs):
           series     NACA 4-digit designator             [default 0012]
           camber     maximum camber    (percent chord)   [default 0.0]
           maxloc     location of max camber  (% chord)   [default 0.4]
           thickness  maximum thickness (percent chord)   [default 0.0]
           offset     create offset (>0 for larger)       [default 0.0]
           sharpte    =1 to change thickness for sharp TE [default 0  ]
       output arguments:
       usage:
           if (camber == 0 && maxloc == 0.4 && thickness <= 0)
               extract camber, maxloc, and thickness from series
           endif
           if (thickness==0)
               generate WIRE Body of camber line in xy-plane
           else
               generate SHEET Body in xy-plane
           endif
       notes:
           leading  edge is at (0,0,0)
           trailing edge is at (1,0,0)
           airfoil generated in x-y plane
           if sharpte=1, the x^4 coefficient in thickness eqn is changed

UDPRIM naca456
       input arguments (specified as name/value pairs):
           thkcode    thickness code: $4, $4M, $63, $63A, $64, $64A, $65, $65A,
                         $66, or $67
           toc        thickness/chord ratio
           xmaxt      chordwise location of maximum thickness (only for $4M)
           leindex    leading edge raius parameter (only for $4M)
           camcode    camber code: $0, $2, $3, $3R, $6 or $6M
           cmax       maximum camber/chord
           xmaxc      chordwise location of maximum camber (only for $2)
           cl         design lift coefficient (only for $3, $3R, $6x, and $6xA)
           a          extent of constant loading (only for $6x and $6xA)
       output arguments:
       usage:
           NACA 00tt    -> thkcode=$4,   toc=tt/100,
                           camcode=$0
           NACA mptt    -> thkcode=$4,   toc=tt/100,
                           camcode=$2,   cmax=m/100, xmaxc=p/10
           NACA mptt-lx -> thkcode=$4M,  toc=tt/100, leindex=l, xmaxt=x,
                           camcode=$2,   cmax=m/100, xmaxc=p/10
           NACA mp0tt   -> thkcode=$4,   toc=tt/100,
                           camcode=$3,   cl=m*.15,   xmaxc=p/20
           NACA mp1tt   -> thkcode=$4,   toc=tt/100,
                           camcode=$3R,  cl=m*.15,   xmaxc=p/20
           NACA 63-mtt  -> thkcode=$63,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
           NACA 63Amtt  -> thkcode=$63A, toc=tt/100,
                           camcode=$6M,  cl=m/10,    a=0.8
           NACA 64-mtt  -> thkcode=$64,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
           NACA 64Amtt  -> thkcode=$64A, toc=tt/100,
                           camcode=$6M,  cl=m/10,    a=0.8
           NACA 65-mtt  -> thkcode=$65,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
           NACA 65Amtt  -> thkcode=$65A, toc=tt/100,
                           camcode=$6M,  cl=m/10,    a=0.8
           NACA 66-mtt  -> thkcode=$66,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
           NACA 67-mtt  -> thkcode=$67,  toc=tt/100,
                           camcode=$6,   cl=m/10,    a=??
       notes:
           NACA 5-series are described above as mp0tt and mp1tt
           leading  edge is at (0,0,0)
           trailing edge is at (1,0,0)
           airfoil generated in x-y plane

UDPRIM nurbbody
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
       output arguments:
       usage:
           build a SolidBody with untrimmed specified in filename
           for each Nurb, file contains 7-integer head followed
              by the real data as specified in egads.pdf file

UDPRIM parsec
       input arguments (specified as name/value pairs):
           yte        trailing edge height   [default 0]
           param      Sobiesky's parameters  [no defaults]
                      [1] = rle
                      [2] = xtop
                      [3] = ytop
                      [4] = d2x/dy2 at top
                      [5] = top theta at trailing edge (degrees)
                      [6] = xbot
                      [7] = ybot
                      [8] = d2x/dy2 at bot
                      [9] = bot theta at trailing edge (degrees)
           poly       polynomial coefficient [no defaults]
                      [  1 to  n] for top polynomial
                      [n+1 to 2n] for bot polynomial
       output arguments:
       usage:
           either param or poly (but not both) must be specified
       notes:
           leading  edge is at (0,0,0)
           trailing edge is at (1,yte,0)
           airfoil generated in x-y plane

UDPRIM pod
       input arguments (specified as name/value pairs):
           length     length of pod          [default 0]
           fineness   fineness ratio         [default 0]
       output arguments:
           volume     enclosed volume
       usage:
           creates VSP-style pod
       notes:
           leading  edge is at (0,0,0)
           trailing edge is at (1,length,0)

UDPRIM printBrep
       input arguments (specified as name/value pairs):
       output arguments:
       usage:
           prints BREP info for Body on top of stack

UDPRIM printBbox
       input arguments (specified as name/value pairs):
       output arguments:
       usage:
           prints bounding box info for Body on top of stack

UDPRIM radwaf
       input arguments (specified as name/value pairs):
           ysize      y-extent of frames
           zsize      z-extent of frames
           nspoke     number of radial spokes
           xframe     array of frame locations
       output arguments:
       usage:
           generates a series of frames and spokes
           Faces in frames are attributed with:
              frame[0]   frame number   (bias-1)
              frame[1]   segment number (bias-1)
           Faces in slokes are attributed with:
              spoke[0]   spoke number   (bias-1)
              spoke[1]   segment number (bias-1)

UDPRIM sample
       input arguments (specified as name/value pairs):
           dx         size in X direction    [default 0]
           dy         size in Y direction    [default 0]
           dz         size in Z direction    [default 0]
           center     center of Body         [default 0;0;0]
       output arguments:
           area       surface area
           volume     enclosed volume
       usage:
           if center is prescribed, it must contain 3 values
           if all dx, dy, dz are positive
              make SOLID Body centered at center
           elseif two of dx, dy, dz are positive
              make SHEET Body centered at center
           elseif one of dx, dy, dz is positive
              make WIRE Body centered at center
           else
              error
           endif

UDPRIM sew
       input arguments (specified as name/value pairs):
           filename   name of file (prepended with '$' or '$$/')
           toler      tolerance
       output arguments:
       usage:
           read the .egads or .stp file
           combines the various bodies into a single SHEET or SOLID Body
           if specified toler is smaller than Face tolers, use Face tolers

UDPRIM stag
       input arguments (specified as name/value pairs):
           rad1       leading edge radius
           beta1      leading edge camber angle
           gama1      part of leading edge circle that is exposed
           rad2       trailing edge radius
           beta2      trailing edge camber angle
           gama2      part of trailing edge circle that is exposed
           alfa       stagger angle (between LE and TE)
           xfrnt      location of forward  control point
           xrear      location of rearward control point
       output arguments:
       usage:
           generate a simple turbomachinery airfoil

UDPRIM stiffener
       input arguments (specified as name/value pairs):
           beg         either 2 values (u;v) or 3 values (x;y;z) at beg
           end         either 2 values (u;v) or 3 values (x;y;z) at end
           depth       depth in direction of midpoint local    [default 0]
           angle       cut-back angles (deg) at end            [default 0]
       output arguments:
       usage:
           create a stiffener for the SheetBody on the stack

UDPRIM supell
       input arguments (specified as name/value pairs):
           rx        width  in X-direction                     [default 0]
           rx_w      width  on left   (west)  side             [default 0]
           rx_e      width  on right  (east)  side             [default 0]
           ry        height in Y-direction                     [default 0]
           ry_s      height on bottom (south) side             [default 0]
           ry_n      height on top    (north) side             [default 0]
           n         superellipse power                        [default 2]
           n_w       superellipse power on left   (west ) side [default 2]
           n_e       superellipse power on right  (east ) side [default 2]
           n_s       superellipse power on bottom (south) side [default 2]
           n_n       superellipse power on top    (north) side [default 2]
           n_sw      superellipse power in southwest quadrant  [default 2]
           n_se      superellipse power in southeast quadrant  [default 2]
           n_nw      superellipse power in northwest quadrant  [default 2]
           n_ne      superellipse power in northeast quadrant  [default 2]
           offset    create offset (>0 for larger)             [default 0]
           nquad     =1 ne wire, =2 ne/nw wire, =4 sheet       [default 4]
       output arguments:
       usage:
           superellipse is generated separately in each quadrant, using:
               edge 1:
                   rx_e  is latest rx or rx_e
                   ry_n  is latest ry or ry_n
                   n_ne  is latest n, n_n, n_e, or n_ne
               edge 2:
                   rx_w  is latest rx or rx_w
                   ry_n  is latest ry or ry_n
                   n_nw  is latest n, n_n, n_w, or n_nw
               edge 3:
                   rx_w  is latest rx or rx_w
                   ry_s  is latest ry or ry_s
                   n_sw  is latest n, n_s, n_w, or n_sw
               edge 4:
                   rx_e  is latest rx or rx_e
                   ry_s  is latest ry or ry_s
                   n_se  is latest n, n_s, n_e, or n_se
           to get a simple ellipse, only need to specify rx and ry
           nquad=1 and nquad=2 create WirwBodys, nquad=4 creates SheetBody
       notes:
           super-ellipse centered at (0,0,0)
           super-ellipse generated in x-y plane

UDPRIM tblade
       input arguments (specified as name/value pairs):
           filename       Tblade input file
           auxname        name of either spancontrolinputs or
                             controlinputs file (depending on input file)
           ncp             number of control points in fit
           chord           override values
           thk_c           override values
           inci            override values
           devn            override values
           cur2            override values
           cur3            override values
           cur4            override values
           cur5            override values
           cur6            override values
           cur7            override values
           in_beta         override values
           out_beta        override values
           u2              override values
           u3              override values
           u4              override values
           u5              override values
           u6              override values
           span_in_beta    override values
           span_out_beta   override values
           span_curv_ctrl  override values
       output arguments:
       usage:
           filename is read into Tblade
           values specified in other arguments (such as chord)
              overwrite the values from the file
           Tblade is executed
           airfoils produced in Tblade are fit with ncp control points
           hub and tip are generated from bodies of revolution
           airfoils are blended into a volume

UDPRIM waffle
       input arguments (specified as name/value pairs):
           depth      depth in z-direction   [default 1]
           segments   array of segments
           filename   name of file
           progress   turn on progress print [default 0]
       output arguments:
       usage:
           if (segments are set)
               if (length(segments)%4 != 0)
                   ERROR
               else
                   for (i=0; i < length(segments)/4; i++)
                       xbeg=segments[4*i  ]
                       ybeg=segments[4*i+1]
                       xend=segments[4*i+2]
                       yend=segments[4(i+3]
                       generate SHEET Body from (xbeg,ybeg,0) to (xend,yend,depth)
                   endfor
               endif
           elseif (filename is set)
               notes:  keywords can either be lowercase or UPPERCASE (not mixedCase)
               keywords are shown here in UPPERCASE to distinguish them from variables

               POINT  pointname AT xloc           yloc             creates point at <xloc,yloc>
                                AT x@pointname+dx y@pointname+dy   creates point <dx,dy> from named point
                                AT xloc           y@pointname      creates point at same y as named point and at given xloc
                                AT x@pointname    yloc             creates point at same x as named point and at given yloc
                                ON linename FRAC  fractDist        creates point on line at given fractional distance
                                ON linename PERP  pointname        creates point on line that is closest to point
                                ON linename XLOC  xloc             creates point on line at given xloc
                                ON linename YLOC  yloc             creates point on line at given yloc
                                ON linename SAMEX pointname        creates point on line with same x as point
                                ON linename SAMEY pointname        creates point on line with same y as point
                                ON linename XSECT linename         creates point at intersection of two lines

               LINE   linename  pointname pointname [attrName1=attrValue1 [...]]
                                                                   creates line between points with given attributes

               PATH   linename  pointname pointname                creates construction (invisible) line between points

               PATBEG varname ncopy                                loops ncopy times with varname=1,...,ncopy
               PATEND
           endif

           Faces are attributed with:
              segment    arbitrary seq number  (bias-1)
              waffleseg[0]  segment number     (bias-1)
              waffleseg[1]  subpart in segment (bias-1)
       </pre>

    <p><h3 id="sec5.6">5.6: User-Defined Components shipped with OpenCSM</h3>

      <pre>
These UDCs are shipped in the $ESP_ROOT/udc directory and should
be accessed using the $$/ prefix

UDPRIM $$/biconvex
       input arguments (specified as name/value pairs):
           thick      maximum thickness           [default 0]
       output arguments:
       usage:
           generate unit chord biconvex airfoil
           thick must be positive
           airfoil is generated counterclockwise from TE
       notes:

UDPRIM $$/boxudc
       input arguments (specified as name/value pairs):
           dx         size in x direction         [default 0]
           dy         size in y direction         [default 0]
           dz         size in z direction         [default 0]
       output arguments:
           vol        volume
       usage:
           generate box centered at origin
           dx, dy, and dz must all be positive
       notes:
           this UDC was written as a demonstration

UDPRIM $$/diamond
       input arguments (specified as name/value pairs):
           thick      maximum thickness           [default 0]
       output arguments:
       usage:
           generate unit chord diamond airfoil
           thick must be positive
           airfoil is generated counterclockwise from TE
       notes:

UDPRIM $$/flapz
       input arguments (specified as name/value pairs):
           xflap      outline of flap (4 doubles)
           yflap      outline of flap (4 doubles)
           theta      flap defleection            [default 15]
           gap        gap betwen flap and wing    [default 0.01]
           openEnd    =1 to leave gaps at ends    [default 0]
       output arguments:
       usage:
           define (xflap,yflap) counterclockwise
           hinge is between 2nd and 3rd point of (xflap,yflap)
           points 1 and 4 should be downstream of trailing edge
       notes:

UDPRIM $$/gen_rot
       input arguments (specified as name/value pairs):
           xbeg       x-coordinate at beg of axis [default 0]
           ybeg       y-coordinate at beg of axis [default 0]
           zbeg       z-coordinate at beg of axis [default 0]
           xend       x-coordinate at end of axis [default 1]
           yend       y-coordinate at end of axis [default 1]
           zend       z-coorindate at end of axis [default 1]
           rotang     rotation angle (deg)        [default 0]
       output arguments:
           azimuth    azimuth   angle in    x-y plane (deg)
           elevation  elevation angle above x-y plane (deg)
       usage:
           general rotation of Group on top of stack
           beg and end points must not be the same
       notes:

UDPRIM $$/popupz
       input arguments (specified as name/value pairs):
           xbox       outline of popup (4 doubles)
           ybox       outline of popup (4 doubles)
           height     change in z for popup       [default 1]
       output arguments:
       usage:
           scribes a counterclockwise quad and pops it up
       notes:

UDPRIM $$/spoilerz
       input arguments (specified as name/value pairs):
           xbox       outline of spoiler (4 doubles)
           ybox       outline of spolier (4 doubles)
           depth      depth of cutout
           thick      thickness of spoiler cover
           theta      spoiler deflection (deg)
           overlap    overlap at ends of spoiler
           extend     extension near hinge
       output arguments:
       usage:
           scribe a quad in body and remove material
               to given depth
           scribe quad in body and create spoiler of
               given thickness
           spoiler is larger by overlap on ends defined
               by [4-1] and [2-3]
           spoiler is larger by extend on end defined
               by [1-2]
       notes:
           define (xbox,ybox) counterclockwise
           hinge is between 2nd and 3rd point of (xbox,ybox)
       </pre>

    <p><h3 id="sec5.7">5.7: Number rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Numbers:
    start with a digit or decimal (.)
    followed by zero or more digits and/or decimals (.)
    there can be at most one decimal in a number
    optionally followed by an e, e+, e-, E, E+, or E-
    if there is an e or E, it must be followed by one or more digits
      </pre>
    <p><h3 id="sec5.8">5.8: String rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Strings:
    introduced with a dollar sign ($) that is not part of the value
    followed by one to 128 characters from the set
       letter                     a-z or A-Z
       digit                      0-9
       at-sign                    @
       underscore                 _
       colon                      :
       semicolon                  ;
       dollar-sign                $
       period                     .
       escaped comma              ',
       escaped plus               '+
       minus                      -
       star                       *
       slash                      /
       caret                      ^
       question                   ?
       percent                    %
       open-parenthesis           (
       escaped close-parenthesis  ')
       open-bracket               [
       close-bracket              ]
       open-brace                 {
       close-brace                }
       less-than                  <
       greater-than               >
       equal                      =
    the following characters are not allowed in strings
       apostrophe                 '  (except to escape ', '+ or ') )
       quotation                  "
       hashtag                    #
       backslash                  \
       vertical bar               |
       tilde                      ~
       ampersand                  &
       exclamation                !
      </pre>
      <!-- " -->

    <p><h3 id="sec5.9">5.9: Parameter rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Valid names:
    start with a letter, colon(:), or at-sign(@)
    contains letters, digits, at-signs(@), underscores(_), and colons(:)
    contains fewer than 32 characters
    names that start with an at-sign cannot be set by a CONPMTR, DESPMTR,
       or SET statement
    if a name has a dot-suffix, a property of the name (and not its
        value) is returned
       x.nrow   number of rows     in x or 0 if a string
       x.ncol   number of columns  in x or 0 if a string
       x.size   number of elements in x (=x.nrow*x.ncol) or
                     length of string x
       x.sum    sum of elements    in x
       x.norm   norm of elements   in x (=sqrt(x[1]^2+x[2]^2+...))
       x.min    minimum value      in x
       x.max    maximum value      in x
       x.dot    velocity           of x

Array names:
    basic format is: name[irow,icol] or name[ielem]
    name must follow rules above
    irow, icol, and ielem must be valid expressions
    irow, icol, and ielem start counting at 1
    values are stored across rows ([1,1], [1,2], ..., [2,1], ...)

Types:
    CONSTANT
        declared and defined by a CONPMTR statement
        must be a scalar
        is available at both .csm and .udc file level
        can be set  outside ocsmBuild by a call to ocsmSetValu
        can be read outside ocsmBuild by a call to ocsmGetValu
    EXTERNAL
        if a scalar, declared and defined by a DESPMTR statement
        if an array, declared by a DIMENSION statement (with despmtr=1)
                     values defined by one or more DESPMTR statements
        each value can only be defined in one DESPMTR statement
        can have an optional lower bound
        can have an optional upper bound
        is only available at the .csm file level
        can be set  outside ocsmBuild by a call to ocsmSetValu
        can be read outside ocsmBuild by a call to ocsmGetValu
    INTERNAL
        if a scalar, declared and defined by a SET statement
        if an array, declared by a DIMENSION statement (with despmtr=0)
                     values defined by one or more SET statements
        values can be overwritten by subsequent SET statements
        are created by an INTERFACE statement in a .udc file
        see scope rules (below)
    OUTPUT
        if a scalar, declared and defined by a OUTPMTR statement
        values can be overwritten by subsequent SET statements
        see scope rules (below)
    SOLVER
        not implemented yet

    @-parameters depend on the last SELECT statement(s).
        each time a new Body is added to the Stack, 'SELECT body' is
            implicitly called
        depending on last SELECT statement, the values of the
             @-parameters are given by:

               body face edge node  <- last SELECT

        @seltype -1    2    1    0   selection type (0=node,1=edge,2=face)
        @selbody  x    -    -    -   current Body
        @sellist -1    x    x    x   list of Nodes/Edges/Faces

        @nbody    x    x    x    x   number of Bodys
        @ibody    x    x    x    x   current   Body
        @nface    x    x    x    x   number of Faces in @ibody
        @iface   -1    x   -1   -1   current   Face  in @ibody (or -2)
        @nedge    x    x    x    x   number of Edges in @ibody
        @iedge   -1   -1    x   -1   current   Edge  in @ibody (or -2)
        @nnode    x    x    x    x   number of Nodes in @ibody
        @inode   -1   -1   -1    x   current   Node  in @ibody (or -2)
        @igroup   x    x    x    x   group of @ibody
        @itype    x    x    x    x   0=NodeBody, 1=WireBody,
                                                 2=SheetBody, 3=SolidBody
        @nbors   -1    x    -    x   number of incident Edges
        @nbors   -1    -    x    -   number of incident Faces

        @ibody1  -1    x    x   -1   1st element of 'Body' Attr in @ibody
        @ibody2  -1    x    x   -1   2nd element of 'Body' Attr in @ibody

        @xmin     x    x    *    x   x-min of bboxes or x at beg of Edge
        @ymin     x    x    *    x   y-min of bboxes or y at beg of Edge
        @zmin     x    x    *    x   z-min of bboxes or z at beg of Edge
        @xmax     x    x    *    x   x-max of bboxes or x at end of Edge
        @ymax     x    x    *    x   y-max of bboxes or y at end of Edge
        @zmax     x    x    *    x   z-max of bboxes or z at end of Edge

        @length   0    0    x    0   length of Edges
        @area     x    x    0    0   area of Faces or surface area of body
        @volume   x    0    0    0   volume of body (if a solid)

        @xcg      x    x    x    x   location of center of gravity
        @ycg      x    x    x    x
        @zcg      x    x    x    x

        @Ixx      x    x    x    0   centroidal moment of inertia
        @Ixy      x    x    x    0
        @Ixz      x    x    x    0
        @Iyx      x    x    x    0
        @Iyy      x    x    x    0
        @Iyz      x    x    x    0
        @Izx      x    x    x    0
        @Izy      x    x    x    0
        @Izz      x    x    x    0

        @signal   x    x    x    x   current signal code
        @nwarn    x    x    x    x   number of warnings

        @edata                       only set up by EVALUATE statement
        @stack                       Bodys on stack; 0=Mark; -1=none

        in above table:
           x -> value is set
           - -> value is unchanged
           * -> special value is set (if single Edge)
           0 -> value is set to  0
          -1 -> value is set to -1

Scope:
    CONSTANT parameters are available everywhere
    EXTERNAL parameters are only usable within the .csm file
    INTERNAL within a .csm file
                created by a DIMENSION or SET statement
                values are usable only within the .csm file
             within a .udc file
                created by an INTERFACE of SET statament
                values are usable only with the current .udc file
    OUTPUT within a .csm file
                created by a OUTPMTR statement
                values are available anywhere
    SOLVER   parameters are only accessible between SOLBEG and
                SOLEND statements
      </pre>

    <p><h3 id="sec5.10">5.10: Expression rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Valid operators (in order of precedence):
    ( )            parentheses, inner-most evaluated first
    func(a,b)      function arguments, then function itself
    ^              exponentiation             (evaluated left to right)
    * /            multiply and divide        (evaluated left to right)
    + -            add/concat and subtract    (evaluated left to right)

Valid function calls:
    pi(x)                        3.14159...*x
    min(x,y)                     minimum of x and y
    max(x,y)                     maximum of x and y
    sqrt(x)                      square root of x
    abs(x)                       absolute value of x
    int(x)                       integer part of x  (3.5 -> 3, -3.5 -> -3)
                                     produces derivative=0
    nint(x)                      nearest integer to x
                                     produces derivative=0
    ceil(x)                      smallest integer not less than x
                                     produces derivative=0
    floor(x)                     largest integer not greater than x
                                     produces derivative=0
    mod(a,b)                     mod(a/b), with same sign as a and b>=0
    sign(test)                   returns -1, 0, or +1
                                     produces derivative=0
    exp(x)                       exponential of x
    log(x)                       natural logarithm of x
    log10(x)                     common logarithm of x
    sin(x)                       sine of x          (in radians)
    sind(x)                      sine of x          (in degrees)
    asin(x)                      arc-sine of x      (in radians)
    asind(x)                     arc-sine of x      (in degrees)
    cos(x)                       cosine of x        (in radians)
    cosd(x)                      cosine of x        (in degrees)
    acos(x)                      arc-cosine of x    (in radians)
    acosd(x)                     arc-cosine of x    (in degrees)
    tan(x)                       tangent of x       (in radians)
    tand(x)                      tangent of x       (in degrees)
    atan(x)                      arc-tangent of x   (in radians)
    atand(x)                     arc-tangent of x   (in degrees)
    atan2(y,x)                   arc-tangent of y/x (in radians)
    atan2d(y,x)                  arc-tangent of y/x (in degrees)
    hypot(x,y)                   hypotenuse: sqrt(x^2+y^2)
    hypot3(x,y,z)                hypotenuse: sqrt(x^2+y^2+z^2)
    incline(xa,ya,dab,xb,yb)     inclination of chord (in degrees)
                                     produces derivative=0
    Xcent(xa,ya,dab,xb,yb)       X-center of circular arc
                                     produces derivative=0
    Ycent(xa,ya,dab,xb,yb)       Y-center of circular arc
                                     produces derivative=0
    Xmidl(xa,ya,dab,xb,yb)       X-point at midpoint of circular arc
                                     produces derivative=0
    Ymidl(xa,ya,dab,xb,yb)       Y-point at midpoint of circular arc
                                     produces derivative=0
    seglen(xa,ya,dab,xb,yb)      length of segment
                                     produces derivative=0
    radius(xa,ya,dab,xb,yb)      radius of curvature (or 0 for LINSEG)
                                     produces derivative=0
    sweep(xa,ya,dab,xb,yb)       sweep angle of circular arc (in degrees)
                                     produces derivative=0
    turnang(xa,ya,dab,xb,yb,...
                     dbc,xc,yc)  turnnig angle at b (in degrees)
                                     produces derivative=0
    dip(xa,ya,xb,yb,rad)         acute dip between arc and chord
                                     produces derivative=0
    smallang(x)                  ensures -180<=x<=180
    val2str(num,digits)          convert num to string
    str2val(string)              convert string to value
    findstr(str1,str2)           find locn of str2 in str1 (bias-1 or 0)
    slice(str,ibeg,iend)         substring of str from ibeg to iend
                                     (bias-1)
    path($pwd)                   returns present working directory
    path($csm)                   returns directory of current .csm,
                                     .cpc, or .udc file
    path($root)                  returns $ESP_ROOT
    path($file)                  returns name of .csm, .cpc, or .udc file
    ifzero(test,ifTrue,ifFalse)  if test=0, return ifTrue, else ifFalse
    ifpos(test,ifTrue,ifFalse)   if test>0, return ifTrue, else ifFalse
    ifneg(test,ifTrue,ifFalse)   if test<0, return ifTrue, else ifFalse
    ifmatch(str,pat,ifTrue,...
                      ifFalse)   if str match pat, return ifTrue,
                                     else ifFalse
                                        ? matches any one character
                                       '+ matches one  or more characters
                                        * matches zero or more characters
    ifnan(test,ifTrue,ifFalse)   if test is NaN, return ifTrue,
                                     else ifFalse
      </pre>

    <p><h3 id="sec5.11">5.11: Attribute rules</h3>

    <p>The following is taken from the <code>OpenCSM.h</code> file:
      <!-- extract from OpenCSM.h -->
      <pre>
Attributes assigned to Bodys:

    _body       Body index (bias-1)

    _brch       Branch index (bias-1)

    _tParams    tessellation parameters that were used

    _csys_*     arguments when CSYSTEM was defined

    <any>       all global Attributes

    <any>       all Attributes associated with Branch that created Body

    <any>       all Attributes associated with "SELECT $body" statement

                Note: if the Attribute name is ".tParams", then its
                      corresponding values are:
                       .tParams[1] = maximum triangle side length
                       .tParams[2] = maximum sag (distance between
                                                  chord and arc)
                       .tParams[3] = maximum angle between edge
                                                  segments (deg)

                Note: if the Attribute name is ".qParams" and it
                      value is any string, then the tessellation
                      templates are not used

                Note: if the Attribute name is ".qParams", then its
                      corresponding values are:
                      .qParams[1] = Edge matching expressed as the
                                    deviation from alignment
                      .qParams[2] = maximum quad side ratio point
                                    count to allow
                      .qParams[3] = number of smoothing iterations

Special User-defined Attributes for Bodys:

    _makeQuds   to make quads on all Faces in Body

    _name       string used in ESP interface for a Body

    _stlColor   color to use for all Faces in an .stl file

Attributes assigned to Faces:

    _body       non-unique 2-tuple associated with first Face creation
        [0]     Body index in which Face first existed (bias-1)
        [1]     face-order associated with creation (see above)

    _brch       non-unique even-numbered list associated with Branches
                   that are active when the Face is created (most
                   recent Branch is listed first)
        [2*i  ] Branch index (bias-1)
        [2*i+1] (see below)

                Branches that contribute to brch Attribute are
                   primitive  (for which _brch[2*i+1] is face-order)
                   UDPRIM.udc (for which _brch[2*i+1] is 1)
                   grown      (for which _brch[2*i+1] is face-order)
                   applied    (for which _brch[2*i+1] is face-order)
                   sketch     (for which _brch[2*i+1] is Sketch primitive
                               if making WireBody)
                   PATBEG     (for which _brch[2*i+1] is pattern index)
                   IFTHEN     (for which _brch[2*i+1] is -1)
                   RECALL     (for which _brch[2*i+1] is +1)
                   RESTORE    (for which _brch[2*i+1] is Body numr stored)

    _faceID     unique 3-tuple that is assigned automatically
          [0]   _body[0]
          [1]   _body[1]
          [2]   sequence number

                if multiple Faces have same _faceID[0] and _faceID[1],
                   then the sequence number is defined based upon the
                   first rule that applies:
                   * Face with smaller xcg  has lower sequence number
                   * Face with smaller ycg  has lower sequence number
                   * Face with smaller zcg  has lower sequence number
                   * Face with smaller area has lower sequence number

    _hist       list of Bodys that contained this Face (oldest to newest)

    <any>       all Attributes associated with Branch that first
                    created Face
                    (BOX, CONE, CYLINDER, IMPORT, SPHERE, TORUS, UDPRIM)
                    (BLEND, EXTRUDE, LOFT, REVOLVE, RULE, SWEEP)
                    (SKEND)
                    (CHAMFER, CONNECT, FILLET, HOLLOW)

    <any>       all Attributes associated with Branch if a RESTORE
                    statement

    <any>       all Attributes associated with "SELECT FACE" statement

Special User-defined Attributes for Faces:

    _color      color of front of Face in ESP
                either R,G,B in three 0-1 reals
                or $red, $green, $blue, $yellow, $magenta,
                $cyan, $white, or $black

    _bcolor     color of back of Face in ESP (see _color)

    _gcolor     color of grid of Face in ESP (see _color)

    _makeQuds   to make quads for this Face

    _stlColor   color to use for this Face in an .stl file

Attributes assigned to Edges:

    _body       non-unique 2-tuple associated with first Edge creation
        [0]     Body index in which Edge first existed (bias-1)
        [1]     100 * min(_body[1][ileft],_body[1][irite])
                    + max(_body[1][ileft],_body[1][irite])
                (or -3 if non-manifold)

    _edgeID     unique 5-tuple that is assigned automatically
          [0]   _faceID[0] of Face 1 (or 0 if non-manifold)
          [1]   _faceID[1] of Face 1 (or 0 if non-manifold)
          [2]   _faceID[0] of Face 2 (or 0 if non-manifold)
          [3]   _faceID[1] of Face 2 (or 0 if non-manifold)
          [4]   sequence number

                _edgeID[0]/[1] swapped with edge[2]/[3]
                   100*_edgeID[0]+_edgeID[1] > 100*_edgeID[2]+_edgeID[3]
                if multiple Edges have same _edgeID[0], _edgeID[1],
                   _edgeID[2], and _edgeID[3], then the sequence number
                   is defined based upon the first rule that applies:
                   * Edge with smaller xcg    has lower sequence number
                   * Edge with smaller ycg    has lower sequence number
                   * Edge with smaller zcg    has lower sequence number
                   * Edge with smaller length has lower sequence number

    _nface      number of incident Faces

    <any>       all Attributes associated with "SELECT EDGE" statement

Special User-defined Attributes for Edges:

    _color      color of front of Edge in ESP
                either R,G,B in three 0-1 reals
                or $red, $green, $blue, $yellow, $magenta,
                $cyan, $white, or $black

    _gcolor     color of grid of Edge in ESP (see _color)

Attributes assigned to Nodes:

    _nodeID     unique integer that is assigned automatically

    _nedge      number of incident Edges

    <any>       all Attributes associated with "SELECT FACE" statement

Special User-defined Attributes for Nodes:

    _color      color of Node in ESP
                either R,G,B in three 0-1 reals
                or $red, $green, $blue, $yellow, $magenta,
                $cyan, $white, or $black
      </pre>

    <p>Back to <a href="#sec0">Table of Contents</a>

    <p><h3 id="sec5.12">5.12: Format of plotfile</h3>

    <p>A plotfile is a file that is specified via the
      <code>-plot</code> command line option
      to <code>serveCSM</code>.
      The contents of this file is used for either plotting in
      <code>ESP</code> and/or as input for the <code>-histDist</code>
      or <code>-plugs</code> command line options.

      The plotfile contains a series of blocks of data with the
      format:
      <pre>
        imax  jmax  name
      </pre>
      The <code>name</code> is a character string (without white
      spaces) that will be listed in the <code>ESP</code> Display
      list; this name must be unique.  The meaning of
      <code>imax</code> and <code>jmax</code> depends on the type
      of data, as described below.

    <h4>Series of points</h4>
    <p>Here <code>imax</code> is the number points
      and <code>jmax</code> must be <code>0</code>.  This is also the
      data block type used by the <code>-histDist</code>
      and <code>-plugs</code> options.  There are <code>imax</code>
      3-D coordinates.

    <h4>Polyline</h4>
    <p>Here <code>imax</code> is the number points in the line
      and <code>jmax</code> must be <code>1</code>.  There are
      <code>imax</code> 3-D coordinates specified.

    <h4>Series of 2-point lines</h4>
    <p>Here <code>imax</code> is the number 2-point lines
      and <code>jmax</code> must be <code>-1</code>.  There are two
      3-D coordinates for each line; that is, there are
      <code>2*imax</code> 3-D coordinates specified.

    <h4>Series of triangles</h4>
    <p>Here <code>imax</code> is the number triangles
      and <code>jmax</code> must be <code>-2</code>.  There are three
      3-D coordinates for each triangle; that is, there are
      <code>3*imax</code> 3-D coordinates specified.

    <h4>Grid of quadrilaterals</h4>
    <p>Here <code>imax</code> is the number i-lines (in the j
      direction) and <code>jmax</code> is the number of j-lines (in
      the i direction).  There are <code>imax*jmax</code> 3-D
      coordinates specified.

    <h4>End of data blocks</h4>
    <p>Here <code>imax</code> and <code>jmax</code> must
      be <code>0</code>.  Use of this block is optional.

    <p>Following the data block header is a series of 3-D coordinates
      specified as <code>x y z</code>.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec6">6.0: Example <code>.csm</code> file</h2>

    <p>The following is a copy of <code>tutorial1.csm</code>
      <!-- extract from tutorial1.csm -->
      <pre>
# tutorial1
# written by John Dannenhoffer

# default design parameters
despmtr   Lbar      6.00      # length of bar
despmtr   Rbar      0.15      # radius of bar
despmtr   T         0.50      # thickness of weights
despmtr   D         2.00      # diameter  of weights
despmtr   Rout      1.20      # outer radius (for intersection)
despmtr   Rfil      0.10      # fillet radius at end of bar

set       L         Lbar/2

# shaft
cylinder  -L        0.0       0.0       +L        0.0       0.0       Rbar
   name      shaft
   attribute shaft     1

# left weight
box       -L-T/2    -D/3      -D        T         D*2/3     2*D
   name      left_weight
   attribute weight    1
union
fillet    Rfil

# rite weight
box       +L-T/2    -D/2      -D/2      T         D         D
   name      rite_weight
   attribute weight    2
union
fillet    Rfil

# clip weights with outer cylinder
cylinder  -L-T      0.00      0.00      +L+T      0.00      0.00      Rout
   attribute clipper   1
intersect

end
      </pre>

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec7">7.0: Frequently Asked Questions (FAQ)</h2>

<!--
    <p>What is the difference between a udp and a udc?

    <p>How do I write a udp?

    <p>How do I write a udc?

    <p>What is the difference between RULE, BLEND, and LOFT?

    <p>What is the difference between UNION and JOIN?

    <p>What do I need to know about tolerances?

    <p>If one of the boolean operations (UNION, SUBTRACT, or
      INTERSECT) fails, what can I do?

    <p>How does solver work and what is it good for?

    <p>What does the SELECT command use for, and how does it interact
      with the @-parameters?

    <p>How can I control the tessellation?

    <p>What are Attributes and how do I set and use them?

    <p>How can I break a spline (in the sketcher) into two splines?
-->

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec8">8.0: Release Notes</h2>

    <p><h3 id="sec8.1"> 8.1: New/extended features in v1.18</h3>

    <p><h4>New/updated commands/statements and functions</h4>

    <p>Node, Edges, and Faces can now be SELECTed by bounding boxes

    <p>SUBTRACT can now be applied to coplanar SheetBodys

    <p>SCALE can now scale about a scaling center

    <p>SELECT ADD can now add Faces, Edges, or Nodes by index

    <p>SELECT SUB can now subtract entities by index

    <p>GROUP with a negative argument ungroups

    <p>CONNECT generates degenerate Faces when edgeList* contains
             a zero

    <p>SWEEP can be applied to a FaceBody

    <p>new SSLOPE allows a user to specify the slope at the beginning
       or end of a SPLINE in a sketch

    <p>COMBINE command now returns a SheetBody if the Shell created is
       not closed

    <p>SELECTing via attributes has been extended to have attribute
             values that are strings, integer(s), or real(s)

    <p><h4>New command line arguments</h4>

    <p>-skipTess allows a user to skip the tessellation on the Bodys on
        the stack at the end

    <p>-printStack allows a user to print the contants of the stack
        after every Branch

    <p>-batch is automatically selected when -skipTess is specified

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>applyTparams.udc puts .tParams on Body based upon its size

    <p>calcCG.udc computes the CG of all Bodys on the stack

    <p>udpEllipse is modified to have nedge and thbeg input parameters

    <p>editAttrUdf now allows PATBEG/PATEND statements

    <p><h4>OpenCSM updates</h4>

    <p>update default tessellation parameters

    <p>allow UDFs to receive any number of input Bodys (back to Mark
       or beginning of stack)

    <p>add ocsmUpdateDespmtrs to allow a user to update the DESPMTR
       values from a file

    <p>add __filename__ to files processed by -loadEgads and
       -dumpEgads

    <p>remove tmp_OpenCSM files at beginning of ocsmLoad

    <p>Edges that come from Booleans no longer have the Attributes
       of possibly-coincident Edges in one of the parents

    <p>significatly speed up finishing all Bodys

    <p><h4>ESP updates</h4>

    <p>allow user to add an EVALUATE statement from ESP interface

    <p>add CFGPMTR highlighting and hints in ESP

    <p>unpost File or Tool menu if File, Tool, StepThur, Help,
             UpToDate, or Undo button is pressed

    <p>make groups for at- and at-at-parameters in ESP

    <p>in serveCSM -sensTess, show Face tufts in blue and Edge tufts
             in red

    <p>add option to ESP to turn on/off all Nodes, Edges, Faces, or
             Csystems

    <p>allow plotfile to contain triangles (if jmax==-2)

    <p><h3 id="sec8.2"> 8.2: Bug fixes since v1.17</h3>

    <p>throw error if sketch solver does not converge

    <p>allow user to create a SELECT statement in ESP with any
       number of arguments

    <p>fix bug in udfPrintBrep which mistakenly printed info for the
       next-to-last Body on the stack

    <p>fix ESP bug that displayed the wrong file (such as wrong
       .udc) after saving with no changes

    <p>fix algorithm for finding of .ibody and .iford to avoid
       warnings

    <p>fix bug in path(csm) that returns wrong value if .csm file is
       in pwd

    <p>fix bug that did not store at-at-parameters when a Body is
       recycled

    <p>fix memory leaks in udpSew

    <p>disable -loadEgads when the user uses File->Edit

    <p>fix bug associated with Edge attributes

    <p>fix bug that did not ignore degenerate Edges in CONNECT

    <p>fix bug that did not restore csystems in RESTORE command

    <p>do not delete Edge Attributes that are returned from a
       UDP/UDF

    <p>fix ESP bug that stored wrong values for D and W options

    <p>fix bug that does not re-set at-at-paraneters when UDP is
       called from UDC from File->Edit

    <p>fix bug that cause undefined behavior if a .csm file was
       edited in ESP and the new file became much shorter

    <p>fix bug that did not add all Bodys to the stack that were
       recycled in a RESTORE command

    <p>fix bug that sometimes seg faulted when recycling after a
       CATBEG

    <p>fix bug that caused an error when recycling a case with a UDC
       that had a string-valued output paremeter

    <p>fix bug that did not reinitialize the size of INTERNAL and
       OUTPUT Paremeters at the beginning of ocsmBuild

    <p>fix memory leak when EXTRACT detected an error

    <p>never recycle UDPARG statements

    <p>avoid divide by zero while setting up at-parameters if no
       entities are selected

    <p>maintain Edge attributes when IMPORTing .egads file

    <p>fix bug associated with recycling when IMPORT or UDPRIM
       returns multiple Bodys

    <p>fix bug that did not clear Bodys from stack when recycling in
       a JOIN

    <p>remove Mark from stack when a UDPRIM that uses all Bodys to
       the Mark is recycled

    <p>remove STOREage when ocsmBuild starts

    <p>fix memory leak associated with clearing storage at the
       beginning of ocsmBuild

    <p>fix bug when there is a sketch and the user SELECTs a Body
       via attributes

    <p>fix bug that incorrectly identified a Body made by a REVOLVE
       as a Body made by an EXTRUDE

    <p>fix bug that did not sort the @sellist properly when Nodes
       are selected and the sort key is xcg, ycg, or zcg

    <p>fix bug that did not properly process tessellations for
       perturbed Body (for finite differences)

    <p>fix bug that did not skip degenerate Edges in createTessVels

    <p>fix bug that did not close a -jrnl if an error was detected
       while the jrnl was being processed

    <p>fix bug associated with tessellation sensitivities for an
       EXTRUDE, RULE, or BLEND when applied to a planar sketch that
       was scaled

    <p>fix bug that hangs ESP if FileOpen does not work

    <p>fix bug after FileEdit when one of the skteches in a RULE or
       BLEND could not be recycled

    <p><h3 id="sec8.3"> 8.3: New/extended features in v1.17</h3>

    <p><h4>New/updated commands/statements and functions</h4>

    <p>allow 0 to be wildcard in SELECT face ibody1... and SELECT
             edge ibody1...

    <p>check for negative radius in CYLINDER, CONE, and TORUS

    <p>add CFGPMTR statement

    <p>check for non-positive fact in SCALE

    <p>modify EXTRACT command to simultaneously extract several Faces
      (into SheetBody) or Edges (into WireBody)

    <p>change SOLEND to use levenberg-marquardt to improve its
      robustness

    <p>update named errors in CATBEG statement

    <p>extend DUMP to write .plot files

    <p>add path() function to return various path or file names;
      modify expressions.csm to test path() function

    <p>allow DESPMTR, LBOUND, and UBOUND statements in include-type
      UDCs that operate at global scope

    <p>add global=0 argument to GETATTR statement

    <p>allow ATTRIBUTE statement on a SET statement to create a global
      Attribute if no Bodys have been created yet

    <p>document how to allow string variables to be passed into UDCs

    <p>allow string variable returns from UDCs

    <p>allow Edge SELECTion by (x,y,z) of center

    <p>allow COMBINE to inflate single closed WireBody to SheetBody or
      single closed SheetBody to SolidBody

    <p>add edgelist arguments to CONNECT command

    <p>allow CONNECT to connect SheetBodys

    <p>allow CFGPMTR statment in include-type UDC

    <p>return error if nx=ny=nz=0 in MIRROR

    <p>check for valid values for ibeg and iend in slice function

    <p>allow illegal_pmtr_name, illegal_value, and func_out_of_bounds
      errors to be caught when evaluating expressions during ocsmBuild

    <p><h4>New command line arguments</h4>

    <p>autogenerate autoStep.csm input file if user gives filename
      in the form *.stp, *.STP, *.step, or *.STEP

    <p>autogenerate autoIges.csm input file if user gives filename
      in the form *.igs, *.IGS, *.iges, or *.IGES

    <p>autogenerate autoEgads.csm input file if user gives filename
      in the form *.egads, or *.EGADS

    <p>add -checkPara option to check for possible parallelism

    <p>add -plugs argument to run PLUGS

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>change udpPoly to create linear Bsplines instead of calling
      EG_isoCline

    <p>generate @@-parameters for all model attributes in an IMPORTed
      .egads fileq

    <p>change udpNaca so that sensitivities wrt MAXLOC are forced to
      be finite differenced

    <p>change udfEditAttr, udfFreeform, and udpWaffle to recognize
      outLevel

    <p>add udfFlend

    <p>modify udfEditAttr to be able to delete an attribute

    <p><h4>OpenCSM updates</h4>

    <p>add summary CPU information to serveCSM

    <p>add geometry info in output produced by ocsmPrintEgo

    <p>add ocsmSetBnds

    <p>return ILLEGAL_VALUE from ocsmSetValu, ocsmSetValuD, or
      ocsmSetBnds if value violates the bounds

    <p>add moments of inertia to -chcckMass option in serveCSM

    <p>print message out outLevel=0 when an error is caught

    <p><h4>ESP updates</h4>

    <p>allow multi-segment line plotting in serveCSM


    <p><h3 id="sec8.4"> 8.4: Bug fixes since v1.16</h3>

    <p>fix bug that did not allow sensitivity calculations if there
      was a NodeBody on the stack

    <p>fix memory leaks associated with fgets

    <p>restart (rewind) journal file whenever user issues FileNew,
      FileOpen, or FileEdit in ESP

    <p>fix bug that do not allow import of .egads files with long
      Attribute names

    <p>remove mallocs for non-DESPMTRs

    <p>clean up data associated with all Bodys beyond nbody

    <p>fix bug that incorrectly set ichld for an EXTRACT

    <p>fix bug that sometimes listed a filename several times in
      filelist used in File->Edit

    <p>fix bug that allowed only the first 12 files to be editted in
      ESP

    <p>fix bug that created seg fault when modifying a DESPMTR after
      an error is encountered

    <p>fix bug that sometime caused INTERFACE statement to use the
      wrong Parameter index during rebuilds

    <p>fix bug that caused THROW to not raise a signal that ESP knew
      how to handle

    <p>fix memory leak that did not clean up SketchBodys

    <p>fix array bounds error associated with tesselation velocities
     for non-manifold Edges

    <p>clean up memory associated with NULL_BODYs

    <p>clean up memory associated with NULL_BODYs

    <p>fix bug that sometimes printed ego info after SUBTRACT, even
      when outLevel=0

    <p>fix bug in ocsmFree that caused an error for a Body that was
      created and an error occurred in an attached CSYSTEM statement

    <p>add checks to make sure stack does not exceed MAX_STACK_SIZE
      when Branch creates more than one Body

    <p>make SOLEND errors catchable

    <p>fix bug in EXTRACT if some Face or Edge index is out of range

    <p>fix bug associated with at-stack and at-edata in ocsmCopy

    <p>fix slashes for Windoze when reading from ESP_ROOT/udc

    <p>fix memory leak associated with GETATTR statement

    <p>fix typo associated with ALL argument to INTERFACE statement

    <p>fix sensitivities for EXTRUDEs with SCALEd sketches

    <p>fix bug that did not free memory after an error was detected
      during argument evaluations

    <p><h3 id="sec8.5"> 8.5: New/extended features in v1.16</h3>

    <p>add ESP_QuickReference

    <p><h4>New commands/statements</h4>

    <p>allow CSYS info to be returned from GETATTR

    <p>if SELECTing Nodes, Edges, or Faces by attribute, if
      attrValue=*, then match entity that has any type of
      attribute

    <p><h4>New arguments to commands</h4>

    <p>implement SELECT SORT $xmin, $xmax, $xcg, ...,
      $area, $length

    <p>put global Attributes on model when DUMPing

    <p>allow SOLCON to take a string variable as its input

    <p>allow SELECT BODY -n to the select the Body that is the nth
      from the top of the stack

    <p>if SELECT BODY -n points to a Mark, return @selbody=0

    <p><h4>New command line arguments</h4>

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>add udfMatchBodys to find Face, Edge, and Node matches
      between two Bodys

    <p>allow user to match/set numeric attributes in udfEditAttr

    <p><h4>ESP updates</h4>

    <p>make ToolTips text more explicit

    <p>only let t option in ESP toggle the transparency of Faces

    <p>only let o option in ESP toggle the orientation of Edges

    <p>fix bug to clear yellow background whenever a build is successful

    <p>pressing Re-building... should allow user to reset the ESP
      interface

    <p>fix bug so that pressing Constraining... suggests the needed
      constraints in Sketcher

    <p>compute analytic sensisitivities for udpBiconvex

    <p><h3 id="sec8.6"> 8.6: Bug fixes since v1.15</h3>

    <p>fix bug in Sketcher to use atan2d for ::I[]

    <p>fix dbest initialization error in -histDist option to
      serveCSM

    <p>add one more level to printouts in ocsmPrintEgo so that
      Nodes get printed when the input is a Model

    <p>fix bug that caused Bodys to not be recycled after File->Edit

    <p>fix memory leak when a UDP or UDF returns multiple Bodys
      (such as in udfMatchBodys)

    <p>fix bug that did not make signals from EVALUATE, GETATTR, and
      SELECT catchable

    <p>fix bug that did not reorder loops properly in RULE and BLEND
      when the sketches had only two Nodes

    <p>fix bug in finding setting sequence numbers associated with
      _edgeID and _faceID

    <p>fix bug that did not list LocalVariables properly if last
      last variable is string valued

    <p>fix bug that did not throw a catchable error when RESTORE
      could not find a matching Body that was STOREd

    <p>fix bug associated with making a copy of the Body that was
             returned from a UDP, which forced finite difference
             sensitivities since the ebodys did not match

    <p>fix bug that caused seg fault when computing sensitivities in
      some cases with UDCs

    <p>fix bug that did not maintain correct velocities after a
      STORE/RESTORE

    <p>fix bug that only allowed str2val to evalaute a string that
      was a number (and not ageneral expression)

    <p>fix bug associated with consecutive multi-Body IMPORTs from
      different files

    <p>fix sensitivity bug for EXTRUDEs in which its sketch has been
      transformed

    <p>fix memory leak in udfMatchBodys

    <p>fix possible infinite loop when assigning sequence numbers
      for _edgeID or _faceID

    <p>fix divide-by-zero bug for sensitivity at C0 Nodes of a BLEND

    <p>improve accuracy of senitivities for RULEs

    <p>fix divide by zero for Edges with C0 end in createTessVels

    <p>fix bug that did not update Local Variables after FILE->Edit in
 `    ESP

    <p><h3 id="sec8.7"> 8.7: New/extended features in v1.15</h3>

    <p><h4>New commands/statements</h4>

    <p>add @signal to keep track of latest signal

    <p>add @nwarn to keep track of number of warnings

    <p><h4>New arguments to commands</h4>

    <p>add listStyle arguments to FILLET and CHAMFER

    <p>allow INTERSECT and SUBTRACT to return multiple Bodys (if
      index=-1)

    <p>update IMPORT and UDPRIM statements so that they can return
      multiple Bodys

    <p>if sigCode=0 or $all in CATBEG, all signals are caught

    <p>modify PROJECT command results so that they lie on the
      analytical Curves/Surfaces and not the tessellation

    <p>allow APPLYCSYS to move Body so that its CSYS is moved to
      origin and aligned with axes

    <p>allow lowercase or UPPERCASE arguments in ARC command

    <p>make optional argument mandatory in EXTRACT command

    <p>allow type argument in SKVAR be either lowercase or UPPERCASE

    <p>add sketch Attributes to ending Face of an EXTRUDE and
      REVOLVE

    <p><h4>New command line arguments</h4>

    <p>add -histDist flag to serveCSM

    <p>allow -addVerify and -verify to use verification files that
      depend on the version of OpenCASCADE being used

    <p>add -checkMass flag to serveCSM

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>fix bugs in gen_rot associated with z-aligned rotations

    <p>add udfCatmull and catmull test cases

    <p>update udpImport to cache previous read in case we ask to
      reread the file

    <p>update udpImport so that it can return all Bodys

    <p>add udpPoly and poly3 and poly4 test cases

    <p>when OFFSET>0 in udpNaca, extend the airfoil surfaces by
      OFFSET

    <p><h4>ESP updates</h4>

    <p>be able to toggle plotting of control points in ESP

    <p>add distance between last two at-keypresses in message printed
      in ESP

    <p>fix parent/child indications in TreeWindow in ESP

    <p>if .csm file calls a UDC, do not automatically rebuild after
      editing .csm or .udc file - activate the Re-build button instead

    <p>allow sketcher to be launched from within editPmtr or from
      button on top of Tree window

    <p>in StepThru mode, keypress f (lowercase F) goes to first step
      and keypress l (lowercase L) goes to last step

    <p>post help message when entering StepThru mode

    <p>fix bug that did not let the visibility of Csystems be
      changed in ESP

    <p>modify DisplayFilter in ESP so that if Body has a matching
      attribute, all its constituents are shown

    <p>rename File->Save button to ExportFeatureTree and emphasize,
      in confirmation dialog, that previous file formatting
      will be lost

    <p>rename editCSM->OK button to Save and remove confirmation
      dialog

    <p>fix bug that could have incorrectly added file to the
      filelist, which would cause user to not be able to edit
      all UDCs in ESP

    <p>report filename and line number when an error is detected

    <p>add active line highlighting to csm file editor

    <p>double-clicking in MessageWindow open up csm file editor at
      line that contained last error

    <p>fix erroneous messages that got reported in MessageWindow
      when a problem was encountered during a load/check/build

    <p>make , a synonym for Ctrl-&lt; (read view from file) and . a
      synonym for Ctrl-&gt; (save view to file) in ESP

    <p>use save.view as default filename in read view from file and
      save view to file

    <p>fix out-of-date message when ESP starts without a file or
      after File->New

    <p>instead of posting an alert when a load/check/build error
      occurs, turn the MessageWindow light yellow (to draw
      user's attentiom)

    <p>raise signals during ocsmLoad and ocsmCheck (to aid in
      debugging)

    <p>allow StepThru mode to show WireBodys

    <p><h3 id="sec8.8"> 8.8: Bug fixes since v1.14</h3>

    <p>fix erroneous error message assoociated with UNION of
      SheetBodys or WireBodys with the tomark flag

    <p>remove memory leak associated with UDFs forgetting to remove
      tessellation objects

    <p>set imax and jmax outputs from udpBezier when creating WireBody

    <p>fix some memory leaks in sensCSM

    <p>fix misspelling of CHAMFER in ocsmLoad

    <p>fix a few typos in chamfer-related error messages

    <p>fix typo in description of ATTRIBUTE statement

    <p>move stack checking from ocsmCheck to ocsmBuild

    <p>check for existence of UDPs, UDFs, and UDCs during ocsmBuild
      and not during ocsmCheck

    <p>improve Branch status indications in ocsmPrintBrchs

    <p>move ocsmPrinBrchs to after ocsmBuild in serveCSM

    <p>fix writing of NodeBody info during -dumpEgads

    <p>fix bug in at-paramaters associated with NodeBodys

    <p>fix bug that wrote nedge=1 for NodeBodys during -addVerify

    <p>check that DESPMTR, UBOUND, and LBOUND statements only
      contains proper numbers

    <p>treat tabs as spaces in OpenCSM, udpEditAttr, and udpWaffle

    <p>fix bug that only colorized first Face after SELECT FACE

    <p>fix bug that only colorized first Edge after SELECT EDGE

    <p>close .csm file if an error occurs during read

    <p>allow recycling for CONNECT command

    <p>fix bug that did not allow a NODE_BODY to be returned from a
      UDP or UDF

    <p>fix bug associated with statically allocated arrays in CONNECT
      command

    <p>fix bug associated with uppercase OR in IFTHEN and ELSEIF
      statements

    <p>fix bug that did not clear IFTHEN statement from pattern-stack
      while executing CATBEG (which causes an erroneous
      NESTED_TOO_DEEPLY error)

    <p>do not allow search for CATBEG to enter a UDC or another
      block of code

    <p>fix bug associated with errors thrown within a UDC

    <p>fix bug that caused seg faults when UNION errors occurred

    <p>fix bug that caused DUMP to fail if an OUTPMTR is a string

    <p>fix bug that caused error if SELECTing a Body by Attribute in
      cases with a UDPARG statement

    <p>fix bug that did not propagate sensitivity info correctly
      into a UDC in all cases

    <p>use analytic sensitivities if produced by UDP/UDFs

    <p>change default finite difference dtime to 1e-6

    <p>fix bug associated with velocities from EXTRUDEs

    <p>remove incorrect error-checking code during input for CIRARC
      command

    <p>fix bug that did not properly check the number of arguments
      to the IFTHEN and ELSEIF commands

    <p>fix bug that improerly check for XOR operators in IFTHEN and
      ELSEIF commands

    <p>fix bug associated with JOINing WireBodys

    <p>fix velocities for BOX command that produces a SheetBody

    <p>fix sensitivity bug associated with UDPARG/UDPRIM arguments

    <p>for Edges that are supported by only one Face, set the Edge
      velocity to the Face velocity

    <p>remove analytic computation of sensitivities from
      udpBiconvex, udpKulfan, and udpParsec

    <p>fix sensitivity from udpBox, udpEllipse, udpNaca, and
      udpSupell

    <p>fix sensitivity bug associated with lines that are EXTRUDEd

    <p>fix sensitivity bug associated with scaled planar Surfaces

    <p>force finite difference sensitivities for RESTORE command

    <p>fix typos associated with LINT in Makefile.DARWIN64

    <p><h3 id="sec8.9"> 8.9: New/extended features in v1.14</h3>

    <p><h4>New commands/statements</h4>

    <p>Allow SET and PATBEG statements within SKBEG/SKEND

    <p>Allow $beg or $end as t in EVALUATE EDGE statement

    <p>If $name is . (period) in STORE, then Body is popped off stack
       and nothing is stored

    <p>Allow BOX to create an axis-aligned WireBody

    <p>Make INTERSECT operation commutative

    <p>Allow INTERSECTion of SolidBody and WireBody

    <p>Allow attribute name to be an implicit string

    <p>Allow SELECT to select node by (x,y,z)

    <p>Add @nbors at-parameter

    <p>Propagate Edge Attributes to Faces during EXTRUDE and REVOLVE

    <p>Add _despmtr_ and _outpmtr_ Attributes to Model during DUMP

    <p>Lazily evaluate arguments left-to-right in IFTHEN and ELSEIF
       statements

    <p>Add OUTPMTR statement

    <p>Add _bcolor and _gcolor Attribites to Faces to color backside
       and grid

    <p>Add _gcolor Attribute to Edges to color grid points

    <p><h4>New arguments to commands</h4>

    <p>In INTERFACE statement, change default to default=0

    <p>Implement INTERFACE . ALL for include-like UDC (which does not
       create a new scope)

    <p>Allow lowercase or UPPERCASE arguments in INTERFACE statement

    <p>Add toMark argument to JOIN for WireBodys and SheetBodys

    <p>Improve STORE to (..) remove Bodys to Mark or (...) all Bodys
       from stack

    <p>Add edgerng and facerng to EVALUATE command

    <p><h4>New command line arguments</h4>

    <p>Add -skipBuild command line option to serveCSM

    <p>Add -onormal command line option

    <p>Remove -printBbox command line argument from serveCSM

    <p>Remove -printBrep command line argument from serveCSM

    <p>Remove -checkMass command line option from serveCSM

    <p>Add -plotBDF flag to serveCSM so that contents of BDF file can
             be visualized

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>udpWaffle: upgrade file format; fix nested PATBEG

    <p>udfPrintBbox: new UDF to replace serveCSM's -printBbox command
        line argument

    <p>udfPrintBrep: new UDF to replace serveCSM/s -printBrep command

    <p>udpSupell: add offset argument

    <p>udpNaca: add offset argument


    <p>udfDroop: new UDF to modify airfoil leading- or trailing- edges

    <p>udfCreateBEM: allow Nodes, Edges, and/or Faces to be ignored

    <p>udfEditAttr: add verbose argument; skip statements when
       nothing is selected; update error numbers returned; allow
       attrName or attrValu to be an expression if it starts with an
       exclamation point; add ANDNOT keyword

    <p>udfStiffener: new UDF to create stiffener and given location
       on Face

    <p>udpFitcurve: added optional xform argument

    <p><h4>ESP updates</h4>

    <p>Move Cancel and OK buttons to top of frames when editing
       Branch, Attribute, or Design Parameter

    <p>When multiple Bodys have the same name, produce a warning that
       latter ones will be referred to as Body X

    <p>Add ability to edit .udc files from within ESP (incl .udc
       files added to .csm file via the editor)

    <p>Allow question mark in DisplayFilter in ESP to list all
       possibilities

    <p>When MODL in iterface and .csm files are inconsistent, warn
       user about inconsistency instead of refusing to File-Edit the
       .csm file

    <p>Allow visibility of NodeBodys to be toggled in ESP

    <p><h3 id="sec8.10"> 8.10: Bug fixes since v1.13</h3>

    <p>Fix error statement associated with mis-matched argument in
       call to UDC

    <p>Fix bug that caused Body_xxxxxx.egads to be loaded many times
       when -loadEgads flag is set

    <p>Fix bug that caused name_not_found if an empty file

    <p>Fix typo for highlighting CONNECT in code editor

    <p>Fix bug associated with putting Attributes on NodeBodys

    <p>Fix indexing error for row-wise Parameters in ocsmSetVel(D)

    <p>Fix infinte loop identified in store2.csm (for -outLevel 0)

    <p>Fix bug that causes Node attribute to not persist properly

    <p>Fix bug that gets wrong value for at-parameters in ATTRIBUTE
       statements (caused by attributes being assigned before
       at-parameters were computed)

    <p>Fix bug where pointers were not NULLed when a Parameter or
       Branch was deleted

    <p>Improve speed of process for setting sequence numbers in
       finishBody

    <p>Fix bug that printed error messages when visualizing
       NodeBodys

    <p>Fix memory leaks associated with lazy evaluations of IFTHEN
       and ELSEIF statements

    <p>Fix bug in assignment of sequence numbers for _faceID and
       _edgeID attributes

    <p>Fix bug in plotting NodeBodys in ESP

    <p>Apply FILLET or CHAMFER to all Edges if parent is RESTORE

    <p>Fix bug that occasionally crashed after using File-Edit on
        .csm file

    <p>Fix bug that did not properly update selbody when Body loaded
       via -loadEgads flag

    <p>Fix bug that errored for -loadEgads and -dumpEgads flags for
       cases with UNION toMark=1

    <p>Fix error that did not display Variables correctly in ESP if
       any Variable was string-valued

    <p>Fix bug that did not re-initialize size of local variables
       when rebuilding (such as when computing sensitivities)

    <p>Fix bug that does not allow a string value to be set for a
       local variables that previously held an array (modify
       expressions.csm to test)

    <p>Fix bug that does not allow one to set a single number to a
       local variable that previously held a string

    <p>Fdd tests to expressions.csm to test conversions to/from
       strings and to/from vectors

    <p>Fix bug that does not allow $pmtrName to be an implicit string
       in SET statement (modify implicitStrings.csm to test)

    <p>Fonvert left-over variables to scalars instead of deleting
       them at start of ocsmBuild

    <p>Fix bug that did not allow editing of .csm file after saving a
       view file

    <p>Fix bug that caused loadEgads/dumpEgads to not work after
       udpEditAttr

    <p>Fix bug associated with degenerate Edges in udfCreateBEM

    <p>Fix bug that caused loadEgads/dumpEgads to not work with
       returned values from UDPs and UDFs

    <p>Fix bug that caused loadEgads/dumpEgads to not work with
       Groups

    <p>Fix bug that casued -dumpEgads to not work with booleans that
       required loosening of tolerances

    <p>Fix memory leak in unionAll

    <p>Fix -loadEgads/-dumpEgads associated with Sketches

    <p>Fix undefined variable when using the BOX command to make a
       WireBody

    <p>Femove Math.floor in sketcher so that sketches with very small
       dimensions do not cause errors

    <p>Fix bug that ESP does not does not properly work when
       ComputeSensitivity or SetDesignVelocity is pressed for a
       Design Parameter whose name includes a colon

    <p>Fix bug that does not allow a user to add a Design Parameter
       with a colon from the ESP GUI

    <p>Fix uninitialized varaible when ocsmSetVelD is called with all
       zero arguments

    <p>Handle reading of DOS-encoded .csm files correctly t18 fix bug
       that did not recycle EXTRACTs properly

    <p>Report a warning (possible memory leak) if newBody() is called
       but the Body already exists

    <p>Fix bug when recycling cases with UDPARG statements

    <p>Fix Face and Edge coloring bugs in ESP

    <p>Fix bug that truncated last line in File-Edit if the line did
       not end with a CR

    <p>Fix bug that caused seg fault if edit window was cleared in
       File-Edit

    <p>Fix bug that could leave a .csm file open if a failure occurred
       during ocsmSave

    <p>Fix bug that truncated long filenames in ESP Edit-File

    <p><h3 id="sec8.11"> 8.11: New/extended features in v1.13</h3>

    <p><h4>New commands/statements</h4>

    <p>JOIN can be used to join WireBodys

    <p>EVALUATE can be used to evaluate coordinates at a Node or on an
       Edge or Face

    <p>REVOLVE can now be applies to WireBodys

    <p>FaceOrders are now consistent between EXTRUDE, REVOLVE, RULE,
       and BLEND from a WireBody

    <p><h4>New arguments to commands</h4>

    <p>toler=0 argument was added to COMBINE

    <p><h4>New command line arguments</h4>

    <p>-- is ignored as a command line argument

    <p>-printBboxs option was added to print bounding boxes for all
       Nodes, Edges, and Faces associated with Bodys on the stack

    <p>-checkMass option enables a check for the mass properties
       computed internally with those computed via surface integrals

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>A simple turbomachinery airfoil generator (STAG) UDP was added

    <p>A UDF for tiling was added

    <p>The editAttr UDF can now gets its specification from a file

    <p>A new csm UDP allows recursive calls to <code>OpenCSM</code>

    <p>The hex UDP was added to create general hexahedra

    <p>The radwaf UDP was added to create radial waffles (for fuselage
       structures)

    <p>The nocrod argument was added to createBEM

    <p>The nquad argument was added to supell

    <p>The waffle UDP was modified to accept input from a file

    <p><h4>ESP updates</h4>

    <p>The .csm file editor now is context-sensitive and has many new
       features

    <p>The Branch assiociated with the Body being shown when in
       StepThru mode is highlighted

    <p>An _nface Attribute is added to all Edges

    <p>_nodeID and _nedge Attributes are added to all Nodes

    <p>New-style quadding is used if _makeQuads Attribute is put on
       Body

    <p>Add FJ2 to data/gallery

    <p>The @itype at-parameter was added to tell type of Body

    <p>When in StepThru mode, the "n" and "p" keys can be used for
       next and previous.

    <p>Node attributes are now persistent through rebuilds

    <p>Node Attributes can now be examined/set via ESP

    <p>Use ! character to convert implicit strings (such as $primtype
       in UDPARG and UDPRIM statements) into expressions

    <p>String-valued expressions can now be passed into UDC

    <p>Edges that come from a scribe (SUBTRACT) operation are now
       marked with the Face that made it

    <p>In ESP, provide shortcuts -- 2 for @, 6 for ^, and 8 for *

    <p>Design Parameters are now listed hierarchically in ESP (with
       the hierarcy defined by a colon (:)

    <p><h3 id="sec8.12"> 8.12: Bug fixes since v1.12</h3>

    <p>Fix bug that caused infinite recursion if trying to generate a
       .sens file for a case that required finite difference
       sensitivities

    <p>A bug associated with REORDER applied to planar Faces was fixed

    <p>A bug associated with extracting non-existant Edges or Faces
       was fixed

    <p>Issue WARNING if dumping .sens file and tomark argument is set

    <p>Fix @length calculation for WireBodys

    <p>Fix bug that did not properly set @itype for NodeBodys

    <p>Fix error associated with testing for equality in naca456

    <p>Fix bug that caused divide by zero if abs(dab)==L/2 or
       abs(dbc)==L/2 in turnang fuction

    <p>Fix bug that caused divide by zero in ocsmGetVel when TdotT was
       zero

    <p>Fix header in binary stl writer

    <p>Fix bug that did not reload dictionary after File->New,
       File->Open, and File->Edit->OK

    <p>Fix bug that did not allow UDC name in form /name (from current
       directory)

    <p>Fixed bug that did not set up At-parameters for sketches

    <p>An error is raised if an INTERFACE statement uses name of a
       CONPMTR

    <p><h3 id="sec8.13"> 8.13: New/extended features in v1.12</h3>

    <p><h4>New commands/statements</h4>

    <p>Update list of characters allowed in strings

    <p>Update parser to allow expressions of the forms: 1+2, $1+2,
       1+$2, $1+$2, and ifMatch($abc, $*c, 0, 1)

    <p>Make concatenation of string and number produce different
       results depending on whether number is a whole integer

    <p><h4>New arguments to commands</h4>

    <p>String expressions are now evaluated in ATTRIBUTE statements

    <p>Rounded tip treatment in BLEND statement is now documented

    <p>BOX command can now generate a SheetBody if one of the sizes is
       zero

    <p>CONNECT has been extended to work for Faces that have other
       than 4 Edges

    <p>DIMENSION statement can now re-dimension a local variable

    <p>DUMP command can now write binary stl files (.bstl)

    <p>DUMP statement can now dump .sens (sensitivity) files

    <p>New toMark argument to DUMP command allows writing multi-body
       .stl and .bstl files.

    <p>Added a catchable signal to FILLET and CHAMFER when an error
       is returned from EGADS

    <p>Add optional argument to GROUP statement to tell how many Bodys
       to group (instead of back to the mark)

    <p>Extend HOLLOW so that it can be applied to a FaceBody

    <p>Add radius argument to HOLLOW for SheetBodys

    <p>Change arguments to HOLLOW to allow both old and new styles
       for entList

    <p>JOIN has been extended to SheetBodys

    <p>Allow uppercase BODY, FACE, EDGE, or NODE as first argument to
       SELECT statement

    <p>SELECT FACE, SELECT EDGE, or SELECT NODE now select all Faces,
       Edges, or Nodes in the selected Body

    <p>Implement multi-valued SELECT lists (@sellist)

    <p>Return mass properties for entire @sellist in at-parameters

    <p>Implement SELECT ADD and SELECT SUB to adjust the @sellist

    <p>Allow name[i] in first argument of SET statement

    <p>UDPARG now allows inline files and relative file references (as
       was previously only allowed on the UDPRIM statement)

    <p><h4>New command line arguments</h4>

    <p>-dumpEgads added to write Body_xxxxxx.egads files every time a
       Body is created

    <p>-loadEgads added to read Body_xxxxxx.egads file instead of
       actually creating a new Body (useful for debugging when used in
       combination with -dumpEgads flag).

    <p>-sensTess now displays tufts on display when a sensitivity is
       being displayed

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>Sense of airfoils generated by udpBiconvex is now consistent
       with other airfoil generators

    <p>udfCreateBEM has been updated to write PSHELL and MAT1 cards

    <p>udpTblade now generates SolidBodys, with hub and tip being
       bodies of revolution.

    <p>New inputs have been added to udpTblade

    <p>Modify udpTblade to put all temporary files into ./Tblade_temp

    <p><h4>ESP updates</h4>

    <p>Toggle (v)isibility, (g)rid, (t)ransparency, or (o)rientation
        via key presses

    <p>DisplayFilter allows user to filter display based upon
       Attribute name/value pairs

    <p>Colored contours are now generated on the back of Faces

    <p>A StepThru feature was added to show the build process

    <p>Recycling is used (if possible) after FileEdit

    <p><h3 id="sec8.14"> 8.14: Bug fixes since v1.11</h3>

    <p>Fix many bugs in udpTblade and Tblade itself

    <p>Bug associated with subtracting SheetBody from SolidBody has
       been fixed.

    <p>Change udpNACA to be more reliable when finding leading and
       trailing edges

    <p>Fix big in the way results from SET statement are reported

    <p>Fix bug in slice() function

    <p>Fix bug related to persistence of Attributes when two separate
       Edges have similar edge_IDs

    <p>Skip evaluation on degenerate Edges when computing Node
       sensitivity

    <p>Fix GROUP bug during rebuilds with recycled Bodys

    <p>Fix bug in REORDER command for SheetBodys

    <p>Fix sensitivity bug in udpNaca

    <p>Fix bug associated with UNDO

    <p>Fix bug in computing sensitivities when feature splits (via
       RESTORE) and rejoins (via a Boolean)

    <p>Fix bug that did not remove objects from screen after
       deleting all Branches

    <p>Fixed bug that caused ESP to remain in re-building mode if a
       type is added to a .csm file when using FileEdit

    <p>fixed bug that did not clear scene graph (and occasionally seg
       faulted) after an error encountered during loading a .csm file
       (after FileOpen or FileEdit)

    <p><h3 id="sec8.15"> 8.15: New/extended features in v1.11</h3>

    <p><h4>New commands/statements</h4>

    <p>_name Attribute is now documented

    <p>Line numbers are now listed during ocsmLoad

    <p>Strings can be concatenated with + operator

    <p>Overload .size dot-suffix to return length of string

    <p>Add val2str(), str2val(), findstr() and slice() functions

    <p>Special Attribute name was changed from color to _color and
       acceptable values were documented

    <p><h4>New arguments to commands</h4>

    <p>BLEND now has optional oneFace argument to keep strips as one
       Face when fit is only C0

    <p>ELSEIF can take UPPERCASE or lowercase arguments

    <p>EXTRUDE can now be applied to Faces with holes

    <p>GETATTR statement has been added

    <p>RESTORE statement applies it Attributes to the Body and all
       Faces

    <p>SUBTRACT can subtract a SolidBody from a SheetBody

    <p>UDPRIM uses $$/ prefix to mean to get UDC from ESP_ROOT/udc

    <p><h4>New command line arguments</h4>

    <p>-plot allows over-plotting of points, lines, or grids from a
        file.

    <p>-ptrb flag causes perturbation file to be written

    <p>-sensTess allow tessellation sensitivities to be computed
        (instead of configuration sensitivities)

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>Add udfEditAttr to edit Attributes

    <p>Add udpFitcurve to generate fits

    <p>Add maxloc argument to udpNaca

    <p><h4>ESP updates</h4>

    <p>Color non-manifold Edges (nface.gt.2) orange

    <p>Color non-manifold Edges (nface.lt.2) brown

    <p>DisplayType allow user to plot normalized parametric
       coordinates (u,v) or curvatures

    <p>Adjust text height in buttons so that they take up less space
       and are less likely to overflow available space in ESP

    <p>Allow creation of Attribute (via A option)

    <p>Add ability to save view to and read view from a file

    <p><h3 id="sec8.16"> 8.16: Bug fixes since v1.010</h3>

    <p>Add printing of Node Attributes in ocsmPrintBrep

    <p>Fix bug to allow EQ (as well as eq) in IFTHEN statement

    <p>Fix bug if .cpc file contains a UDC that calls another UDC

    <p>Fix bug when adding verification info to .csm that has END
       (rather than end) statement

    <p>Fix bug when Tree Window is not correct for NodeBodys created
       by SKBEG/SKEND statements (attribute2)

    <p>Fix bug when Tree Window is not correct for NodeBodys created
       by POINT statement (attribute2)

    <p>Fix bug that caused no attributes on NodeBodys created by
       POINT statement (attribute2)

    <p>Change tolerance associated with PROJECT statement

    <p>Fix bug in serevCSM that erroneously tried to visualize Faces
       that have not triangles

    <p>Fix bug that causes ocsmLoad to prematurely exit when UDC's
       last statement is not END and does not have a terminal CR/LF;
       update udcBox.udc to test this

    <p>Fix oscmSave bug when saving model that contains an inline file

    <p>Fix stack overflow error associated with expression parsing

    <p>Fix bug in udpNaca for sensitivity at trailing edges if
       sharpte=1

    <p>Fix bug when specifying partially-non-orthogonal CSYSTEMs

    <p>Return error when either direction in CSYSTEM has zero length

    <p>Fix bug to allow HOLLOW after SKEND

    <p><h3 id="sec8.17"> 8.17: New/extended features in v1.10</h3>

    <p><h4>New commands/statements</h4>

    <p>none

    <p><h4>New arguments to commands</h4>

    <p>The IFTHEN and ELSEIF statements now allow $op2 to be xor

    <p>The IFTHEN and ELSEIF statements allow $op1, $op2, and $op3 to
      be either lowercase or UPPERCASE

    <p><h4>New command line arguments</h4>

    <p>none

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>none

    <p><h4>ESP updates</h4>

    <p>The Sketcher now makes suggestion for constraints to be deleted
      or added in order to be properly constrained

    <p>Show connections between Parameters and Branches in Tree window

    <p>Enable zooming in and out with "+" or "-" in Graphics window

    <p>Allow "+", "-", "PgUp", and "PgDn" to zoom-in and -out in
      Sketcher

    <p>Add _tParams attributes to Bodys to store tessellation
      parameters

    <p>Create File popup menu that allows user to
      <ul>
        <li>New: start a new Model</li>
        <li>Open: read a .csm file and create a new Model</li>
        <li>Save: save a .csm file</li>
        <li>Edit: edit current .csm file</li>
        </ul>

    <p>Add ::I[] (inclination), ::R[] (radius), and ::S[] (sweep)
      shorthands in SKCON statements

    <p>Check for self-intersecting Sketches

    <p>A Body can be named in the Tree window via its _name attribute

    <p>Add ESP logo to browser tag

    <p><h4>Miscellaneous updates</h4>

    <p>Add gallery of cases to ESP-help

    <p><h3 id="sec8.18"> 8.18: Bug fixes since v1.09</h3>

    <p>Fix code when bad expression is detected to not seg fault

    <p>Save file now correctly writes IFTHEN statements

    <p>Distinguish between illegal_pmtr_name and
      func_arg_out_of_bounds in thrown errors

    <p>Many small documentation fixes

    <p>Fix deleteParemater so that is works for newly added Parameters

    <p>Fix arrowhead size in CSYSTEMs

    <p><h3 id="sec8.19"> 8.19: New/extended features in v1.09</h3>

    <p><h4>New commands/statements</h4>

    <p>CONPMTR to define a constant Parameter

    <p>POINT for generating a Node (with its derivatives)

    <p>GROUP for grouping Bodys for STORE, DUMP, and transformations;
      add associated @igroup at-Parameter

    <p>IFTHEN, ELSEIF, ELSE, and ENDIF to conditionally control
      execution of Branches

    <p>THROW, CATBEG, and CATEND to handle errors; also have
      statements throw errors that could be caught

    <p>CSYSTEM and APPLYCSYS to generate and use coordinate systems

    <p><h4>New arguments to commands</h4>

    <p>Allow C1 or C0 continuity in BLEND command by duplicated
      sketeches; add oneFace=0 argument to BLEND

    <p>Add ability to created rounded tips in BLEND command

    <p>Add toler=0 and verify=0 arguments to ASSERT command

    <p>Extend DUMP command to write .stl, .ugrid, .tess and .egg files

    <p>Add toMark=0 argument to DUMP command

    <p>Add useEdges=0 argument to PROJECT command

    <p>Extend SELECT statement to allow a user to apply attributes to
      all Edges or Faces

    <p><h4>New command line arguments</h4>

    <p>--version flag to return version

    <p>-verify and -addVerify flags for verification execution and
      setup

    <p>-egg to suppport external grid generator

    <p>-dict to support dictionary of constant Parameters

    <p>-sensTess to choose between configuration and tessellation
      sensitivities

    <p><h4>New/updated UDPs, UDCs, or UDFs</h4>

    <p>udfCreateBEM to create a BEM and associated file

    <p>udfCreatePoly to write a .poly file

    <p>udpPod to generate a pod (like in VSP)

    <p>udpSample to act as a sample for new user-defined primitives

    <p>Add sharpte argument to udpNaca

    <p>Add sensitivities to udpParsec

    <p>Add attributes to Faces in udpWaffle

    <p><h4>ESP updates</h4>

    <p>Configuration can be colored in Graphics Window if Face has
      "color" attribute

    <p>Post messages in Message Window when ESP is started without a
      .csm file

    <p>Add tooltips to ESP

    <p>Clicking on Body name in Tree Window posts the Body's
      attributes

    <p>Allow complete rebuild (without recycling) in ESP by pressing
      "Up to date"

    <p>Add axis labels to axes in lower-left corner of Graphics Window

    <p>Add (optional) light-grey axes centered at origin

    <p>Allow user to expand/collapse Branch list in ESP

    <p>Add "Show Attributes/Csystem" button in ESP

    <p>Do not allow statements within a UDC to be edited in ESP

    <p>Reorganize and update ESP-help

    <p><h4>Miscellaneous updates</h4>

    <p>Print mass properties (in serveCSM) for all Bodys on stack

    <p>Quadrilaterals are generated (and visualized) if a Face has a
      _makeQuads attribute

    <p>Add ocsmSetDtime, ocsmPrintEgo, ocsmGetNorm, ocsmRetCsys,
      ocsmGetCsys, and ocsmSetCsys functions to OpenCSM API

    <p>Add support for an external grid generator (egg) to be used in
      place of the EGADS tessellator; add ocsmSetTess function to API

    <p>Allow all lists to be input either as name of a multi-values
      Parameter or a semicolon-separated list of expressions

    <p>Allow all command names to be specified either in lowercase or
      UPPERCASE

    <p>Add global ID to all Edges and Faces

    <p>Add Body, Face, Edge, and Node attribute printing in
      ocsmPrintBrep

    <p>Update ocsmGetVel so that it returns vector sensitivities

    <p>Add many new test cases, all with verification data

    <p><h3 id="sec8.20"> 8.20: Bug fixes since v1.08</h3>

    <p>Improve robustness of UNION when applied to SheetBodys

    <p>Fix .ibody attribute for Edges associated with a Body that is
      restored more than once

    <p>Fix .ibody attribute for Edges associated with FILLET, CHAMFER,
      HOLLOW, and CONNECT commands

    <p>Fix .ibody attribute for Edges

    <p>Fix ocsmGetUV and ocsmGetXYZ results when uv=NULL

    <p>Fix several memory leaks

    <p>Execute dimension checks at run-time (and not load-time)

    <p>Fix bug that caused SELECT statements to be written incorrectly
      in ocsmSave

    <p>Fix indentation for PATBREAK statement

    <p>Fix bug associated with adding and editing a SELECT statement
      in ESP

    <p>Fix bug associated with single digit attributes

    <p>Fix sensitivity error for end-caps in EXTRUDEs, RULEs, and
      BLENDs

    <p>Fix Face sensitivity info in udpBox

    <p>Remove MACBEG, MACEND, and RECALL statements from ESP

    <p>Mark Branch as dirty if an Attribute or Csystem changes

    <p>Fix erroneous truncation of very long metadata in ESP

    <p><h3 id="sec8.21"> 8.21: New/extended features in v1.08</h3>

    <p>A new ocsmDelPmtr function has been added to the OpenCSM API to
       delete a Design Parameter

    <p>A new ocsmGetTessVel function has been added to the OpenCSM API
       to return the 3D sensitivities at all the tessellation points

    <p>A new biconvex UDP was written

    <p>An additional argument, relative=0, has been added to the SKBEG
       statement.  If set to 1, the coordinates specified by LINSEG,
       CIRARC, ARC, SPLINE, and BEZIER statements are all relative to
       the coorindates in the SKBEG statement

    <p>The DESPMTR, LBOUND, and UBOUND statements have been extended
       to allow specification of a single value, a whole row, a whole
       column, or the whole matrix

    <p>The smallang(ang) function has been added to convert angles
       into the range -180 &lt; ang &lt;= 180

    <p>The hypot3(x,y,z) function has been added for 3D vectors

    <p>The mod(i,j) function has been added

    <p>The x.norm dot suffix has been added to compute the norm of
        array x

    <p>When an edit form is displayed, the first entry box now
       automatically gets focus on entry

    <p>The TAB key now correctly moves between inputs in the edit
       forms in ESP

    <p>Pressing the ENTER key in an edit form is now the same as
       pressing the OK button

    <p>When a SKBEG statement is added in ESP, a matching SKEND is
       automatically added and ESP enters the sketcher automatically

    <p>If a SKBEG Branch is deleted, the whole associated sketch is
       now deleted

    <p>Once a UDPRIM or UDPARG statement has been added, the number of
       name-value pairs cannot be changed.  Add another UDPARG
       statement if more are needed.

    <p>When a new Design Parameter is added, it defaults to be a
       scalar.  New buttons have been added to "Add a Row" or "Add a
       Column"

    <p>The Delete Parameter button has been added to the edit parameter
       form

    <p>5 levels of Undo are now kept in the sketcher

    <p>Circle centers can now be constrained in the sketcher

    <p>The X and Y constraints at the beginning of a relative sketch
       can no longer be deleted

    <p>In the sketcher, the correct sign is suggested for W, D, R, and
        S constraints based pon what user draws

    <p>Arrow keys and PgUp and PgDn can be used to transform the image
       in the sketcher

    <p>Zero-length segments cannot be accidentally drawn via double
       clicks in the Sketcher.  A new "z" command has been added to
       create zero-length segments.

    <p>Pressing ESC in sketcher no longer exits the sketcher

    <p>Pressing &lt; to delete a constraint in the sketcher now gives
       the user the option to select the one constraint to delete if
       there are multiple constraints present

    <p>The <code>@</code> key in the sketcher reports coordinates in
       the Message window

    <p>Descriptions of the supell and kulfan UDPs have been added to
       the help file

    <p>NodeBodys are now left on the stack

    <p>Attributes can now be assigned to NodeBodys

    <p>NodeBodys are now displayed on the screen

    <p>For -outLevel=2 in serveCSM, the debug messages now are
       explicit as to which messages are sent by the browser and which
       message are sent by the server

    <p><h3 id="sec8.22"> 8.22: Bug fixes since v1.07</h3>

    <p>Numerous typos were fixed in this help file

    <p>A segmentation fault associated with very large arguments has
       been fixed

    <p>Inclination is now handled consistently in the sketcher and
        OpenCSM

    <p>Temporary sketch variables are freed before starting a new
       sketch

    <p>Trying to save a <code>.csm</code> file to a nonexistent
       directory no longer causes a segmentation fault

    <p>Sensitivities associated with UDCs have been fixed

    <p>A bug that prevented a user from having more than one
       name-value pair in a UDPRIM statement (for a UDC) has been
       fixed

    <p>A memory leak was fixed by freeing of storage associated with
       arguments before stack finalization

    <p>A bug that allowed a udprim to be recycled even when there are
       velocities in its arguments has been fixed

    <p>Analytic sensitivity of EXTRUDE and RULE of a transformed
       sketch are now correct

    <p>A bug associated with the analytic sensitivities for the
       endcaps in EXTRUDE and RULE has been fixed

    <p>Infinite loop in sensitivities for Windows x64, Visual Studio
       12.0 has been fixed

    <p>Finite difference sensitivities for cylinders and cones that
       are almost aligned with an axis are now correct

    <p>Analytic edge sensitivities in the supell UDP are now correct

    <p>Analytic edge sensitivities in ellipse UDP have been corrected
       for cases when DY=0

    <p>A bug that left a picture even after all Branches were deleted
        has been fixed

    <p>Global Attributes are now properly written in .csm files by
       ocsmSave

    <p>A check has been added to make sure that there are at least 2
       sketches between rounded nose and tail points in BLEND

    <p>Spaces have been removed from constraint expressions that the
       user specified in the Sketcher so that the sketch can be saved
       properly

    <p>The upper limit must now be greater than the lower limit when
       changing them in the Key window

    <p>A bug that caused surfaces to always be rendered in grey on
       some Intel graphics devices has been fixed

    <p>A bug that caused tutorial3 to seg fault has been fixed

    <p>A bug that erroneously recycled a UDPRIM if values in the
       UDPARG statement changed was fixed

    <p>Leaving blank entries in a UDPRIM or UDPARG statement no longer
       asks the user for confirmation

    <p>Pressing Undo after solving a sketch now just undoes the solve

    <p>Fixed a bug associated with order of calls during cleanup

    <p>The correct bodyID is now applied to WireBodys

    <p>Body Attributes are now applied directly to Edges if a WireBody
       was created by an open sketch

    <p>The testing process has been changed to better catch errors
       during the execution of the test suite

    <p>Sensitivities are now correctly computed for non-manifold Edges

    <p><h3 id="sec8.23"> 8.23: New/extended features in v1.07</h3>

    <p><code>CAPRI</code> is no longer supported

    <p>serveCSM now returns 1 if running in batch and an error is
       encountered

    <p>A warning is issued if a SolidBody has a non-positive volume

    <p>All lists are now semicolon-separated (including in BLEND,
       CHAMFER, CONNECT, FILLET, HOLLOW, and UNION)

    <p>Functions "seglen", "incline", "radius", "sweep", and "dip"
       were added to the expression evaluator

    <p>More checks were added for invalid arguments in the BOX,
       CYLINDER, CONE, SPHERE, TORUS, EXTRUDE, and REVOLVE
       commands

    <p>An ARC statement was added as an alternative to the CIRARC
       statement

    <p>In an ATTRIBUTE statement, if the attrValue is a multi-valued
       parameter, then multiple values will be assigned

    <p>Errors are raised if trying to apply Attributes to an ASSERT,
       DESPMTR, DIMENSION, END, INTERFACE, LBOUND, MACBEG,
       MACEND, MARK, PATBEG, PROJECT, SET, SKBEG, SOLBEG,
       STORE, UBOUND, or UDPARG statement

    <p>Tessellation parameters can be specified in a ".tParams"
       Attribute at either the global, Body, Face, or Edge level (for
       use by the internal tessellator)

    <p>A BEZIER statement was added to create Bezier curves

    <p>A CONNECT statement was added to create a new Body from two
       old Bodys with certain faces "connected" by a local set of Faces
       (see flapz.udc for an example use)

    <p>The INTERFACE statement now supports multi-valued parameters

    <p>Tolerances can be relaxed in INTERSECT statement

    <p>The JOIN command has an optional "tolerance" argument

    <p>A patbreak statement was added to allow one to break out of
       a pattern

    <p>A REORDER statement has been added to reorient faces (such as
       might be needed before a RULE or BLEND)

    <p>Warnings are generated if the REVOLVE statement yields a
       possibly-inside-out Body

    <p>Analytic sensitivities have been added to the RULE statement

    <p>A reorder option was added to RULE and BLEND to allow
       OpenCSM to automatically reorder loops so as to minimize the
       chance of twist

    <p>A SKCON statement was added to allow constraints to be
       defined for the sketch solver

    <p>The number of Edges are reported when executing the SKEND
       statement

    <p>A SKVAR statement was added to initialize sketcher variables

    <p>A "keep" option was added to the STORE command

    <p>Tolerances can be relaxed in SUBTRACT statement

    <p>Added optional "trimList" to UNION operation to allow a user
       to union "up to" the closest intersection to the given point

    <p>Tolerances can be relaxed in UNION statement commands

    <p>The <code>kulfan</code> user-defined primitive (udp) was added
       to create CST airfoils

    <p>The <code>supell</code> user-defined primitive (udp) was added
       to create a super-ellipse (to assist in creating fuselages)

    <p>The <code>biconvex</code> user-defined component (udc) was added
       to create a biconvex airfoil

    <p>The <code>diamond</code> user-defined component (udc) was added
       to create a diamond-shaped airfoil

    <p>The <code>flapz</code> user-defined component (udc) was added
        to add a (possibly-deflected) flap to an existing body

    <p>The <code>popupz</code> user-defined component (udc) was added
       to generate a "pop-up" from an existing surface

    <p>If the server (serveCSM) dies, the Messages window turns pink
       and no alert is issued

    <p>Rolling the middle -mouse button zooms in/out

    <p>An interactive sketcher was added

    <p>Buttonslabeled "<strong>H</strong>", "<strong>L</strong>",
       "<strong>R</strong>", "<strong>B</strong>",
       "<strong>T</strong>", "<strong>+</strong>", and
       "<strong>-</strong>" buttons as an alternative to
       "<strong>&lt;Ctrl-h&gt;</strong>",
       "<strong>&lt;Ctrl-l&gt;</strong>",
       "<strong>&lt;Ctrl-r&gt;</strong>",
       "<strong>&lt;Ctrl-b&gt;</strong>",
       "<strong>&lt;Ctrl-t&gt;</strong>",
       "<strong>&lt;Ctrl-i&gt;</strong>" and
       "<strong>&lt;Ctrl-o&gt;</strong>" (since some browsers steal
       some of these control sequences)

    <p>The spectrum was changed from blue-green-red to blue-white-red

    <p>The environment variable <code>ESP_START</code> was changed
       to <code>ESP_START</code> (although <code>ESP_START</code> still
       works)

    <p><h3 id="sec8.24"> 8.24: Bug fixes since v1.06</h3>

    <p>A journalling error was associated with the UNION command

    <p>The REVOLVE command did not work if given a SheetBody

    <p>Storage associated with UDPs was not properly released

    <p>Nested UDCs without END statements caused infinite loops

    <p>The PROJECT command could fail in certain situations, such as
       during rebuilds

    <p>Repeated points caused problem when creating a spline (so now
        they are removed)

    <p>Errors were raised for expressions in the form "0^any" (they
       now return "0")

    <p>Multi-valued parameters in UDPs were not handled properly when
       computing sensitivities

    <p>Arrays were flattened when being transferred into UDCs

    <p>Expressions such as "x[i+1]" were not parsed properly

    <p>SheetBodys from BLEND with open sketches were improperly
       classified as SolidBodys

    <p>Infinite loop resulted when an END statement was put into
       a pattern with zero iterates

    <p>The vertical tail was misplaced in myPlane with fidelity set
       to 1 or 2

    <p>Sensitivity failed if using a UDP with an integer or string
       argument

    <p>Default velocity was set to -HUGEQ, causing unset variables to
       inadvertently execute sensitivities (they are now set to "0")

    <p>An error in the first Branch caused ESP to hang

    <p><h3 id="sec8.25"> 8.25: New/extended features in v1.06</h3>

    <p>User-defined components (UDCs) have been implemented to execute
       consistently with user-defined primitives (UDPs).  The main
       difference is that UDCs are defined in scripts (in a file named
       <code>*.udc</code>) whereas UDPs are defined in C-code that is
       pre-compiled.  The first argument of the UDPRIM statement
       selects a UDC if it starts with a "/" or a "$/"; otherwise it
       looks for a UDP.

    <p>The INTERFACE statement has been added to be used within UDCs
       to define the UDC's INTERFACE, including the default values for
       its arguments.

    <p>The JOIN command was added to combine Bodys at common Faces.
       Using the JOIN command is preferred over the UNION command
       when the user expects some of the Faces to match exactly.

    <p>The STORE and RESTORE commands were added to keep copies of
       Bodys in memory (rather than in an external files, as was done
       for DUMP and IMPORT).  The advantage is that the build tree
       information is retained, allowing Bodys to sometimes be reused
       during the regeneration process.

    <p>The EXTRACT command has been added to extract a
       lower-dimension object (for example, an Edge from a Body).

    <p>The COMBINE command has been added to create a
       higher-dimension object (for example, a Faces from a group of
       Edges).

    <p>The ASSERT command has been added to return an error if
       the assertion is not satisfied.

    <p>The direction vectors in the "noselist" and "taillist"
       arguments to the BLEND command no longer need to be
       normalized.

    <p>If the arguments to the SUBTRACT command are a SOLID Body and
       a SHEET Body, then the SOLID Body is scribed with Edges at the
       intersection of the SOLID and SHEET.

    <p>An optional argument (wireonly) has been added to the SKEND
       command; if wireonly is set to 1, then a (possibly non-planar)
       WIRE Body is created instead of a SHEET Body.

    <p>Array elements can be addressed with a single subscript, which
       are numbered across rows.

    <p>Names are allowed to include colons ":", which is useful for
       hierarchically organizing names.

    <p>The "ifnan", "sign", "ceil", and "floor" functions have been
       added to the expression evaluator.

    <p>".nrow", ".ncol", ".size", ".sum", ".min", and ".max"
       dot-suffixes can be appended to variables to return properties
       of the Design Parameter of Local Variable rather than its
       value.

    <p>The "naca456" UDP was added to create NACA-4, -5, and -6 series
       airfoils.

    <p>Global Attributes are placed on all Bodys.

    <p>Keyboard shortcuts were added to the <code>ESP</code> viewer:
      <table>
        <tr>
          <td><strong>&lt;Ctrl-h&gt;</strong></td>
          <td>home</td>
          <td>(same as <strong>&lt;Home&gt;</strong>)</td>
        </tr>
        <tr>
          <td><strong>&lt;Ctrl-i&gt;</strong></td>
          <td>zoom in</td>
          <td>(same as <strong>&lt;PgUp&gt;</strong>)</td>
        </tr>
        <tr>
          <td><strong>&lt;Ctrl-o&gt;</strong></td>
          <td>zoom out</td>
          <td>(same as <strong>&lt;PgDn&gt;</strong>)</td>
        </tr>
        <tr>
          <td><strong>&lt;Ctrl-f&gt;</strong></td>
          <td>front view</td>
          <td>(same as <strong>&lt;Home&gt;</strong>)</td>
        </tr>
        <tr>
          <td><strong>&lt;Ctrl-t&gt;</strong></td>
          <td>top view</td>
        </tr>
        <tr>
          <td><strong>&lt;Ctrl-b&gt;</strong></td>
          <td>bottom view</td>
        </tr>
        <tr>
          <td><strong>&lt;Ctrl-l&gt;</strong></td>
          <td>leftside view</td>
        </tr>
        <tr>
          <td><strong>&lt;Ctrl-r&gt;</strong></td>
          <td>riteside view</td>
        </tr>
      </table>

    <p>When a Branch is edited in ESP, the first field associated
       with the Branch in the Tree window is colored magenta, the
       Branch's parents are colored cyan, and the Branch's child is
       colored yellow.

    <p>When a Design Parameter is edit-ted in ESP, the first field
       associated with the Parameter in the Tree window is colored
       magenta.

    <p>If one selects another Branch or Parameter in the Tree window
       while editting another Branch or Parameter, the current edit is
       cancelled and the new edit started.

    <p>Axes are displayed in ESP.

    <p>Branches are indented (with ">") in Tree Window in ESP.

    <p><h3 id="sec8.26"> 8.26: Bug fixes since v1.05</h3>

    <p>Attribute values can be strings (prepended by "$").

    <p>Improved nose an tail treatment in BLEND.

    <p>A sketch can be composed of a single closed spline.

    <p>Error in face-order for REVOLVE command.

    <p>If a DESPMTR statement tries to redefine a parameter, print
       out warning message that previous values will be used

    <p>Allow filename argument in IMPORT statement to be in form
       $$/filename (to be consistent with UDPRIM import).

    <p>"ifpos", "ifneg", and "ifzero" perform lazy evaluations so that
       errors in unused arguments do not trigger an error.

    <p>Print comment lines that start with a space.

    <p>Report number of segments in blending message.

    <p>Flip sketch so that its normal direction is in the +x, +y, or
       +z direction.

    <p>Remove creation of spurious Bodys created by JOIN command.

    <p>Allow more than one matched Face in JOIN command.

    <p>Allow blanks in SELECT, UDPARG, and UDPRIM statement in
       ESP (but only at end).

    <p>Fix serveCSM so that the JSON that it transfers to the browser
       does not contain ",]" nor ",}".

    <p><h3 id="sec8.27"> 8.27: Known problems in v1.09</h3>

    <p>Internet Explorer (11) is not recommended since it sometimes
       stops sending messages to the server.

    <p>When using 64-bit OS X 10.8 or higher, you should use
       OpenCASCADE 6.6.0 (as opposed to 6.8.0).  There is an error
       somewhere that causes "serveCSM tutorial1_new" to sometimes
       produces a segmentation fault during rebuilds.

    <p>Edges are not drawn in ESP when running a LINUX64 virtual
       machine under VMware with OSX 10.8 or higher as the host
       operating system.

    <p>The <strong>&lt;Ctrl-l&gt;</strong> (leftside view) keyboard
       shortcut does not work in Safari (since it appears that Safari
       intercepts the <strong>&lt;Ctrl-l&gt;</strong> before it gets
       to ESP).  Use the "L" button instead.

    <p>Test cases with the HOLLOW command do not work when using the
       pre-built versions of OpenCASCADE 6.6.0 or 6.8.0 for Windows.

    <p>In OpenCASCADE 6.8.0, the tolerances associated with the sew
       operation cause cases with loose tolerances to no longer work.

    <p>The "Edit" command in ESP can only be used to edit
       the <code>.csm</code> file; any <code>.udc</code> files that
       are opened cannot be edited.

    <p>OpenCASCADE can write .step files that are unreadable by other
       applications (such as an ellipsoid)

    <p>Case design8 in sensCSM has two families of results, depending
       on the version of OS and OCC that is used

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec9">9.0: Error Codes</h2>

    <p><h3 id="sec9.1"> 9.1: OpenCSM error codes</h3>

    <p><code>OpenCSM</code> performs extensive error checking that can issue the
       following error codes:
      <!-- extract from OpenCSM.h -->
      <pre>
SUCCESS                                 0

OCSM_FILE_NOT_FOUND                  -201
OCSM_ILLEGAL_STATEMENT               -202
OCSM_NOT_ENOUGH_ARGS                 -203
OCSM_NAME_ALREADY_DEFINED            -204
OCSM_NESTED_TOO_DEEPLY               -205
OCSM_IMPROPER_NESTING                -206
OCSM_NESTING_NOT_CLOSED              -207
OCSM_NOT_MODL_STRUCTURE              -208
OCSM_PROBLEM_CREATING_PERTURB        -209

OCSM_MISSING_MARK                    -211
OCSM_INSUFFICIENT_BODYS_ON_STACK     -212
OCSM_WRONG_TYPES_ON_STACK            -213
OCSM_DID_NOT_CREATE_BODY             -214
OCSM_CREATED_TOO_MANY_BODYS          -215
OCSM_TOO_MANY_BODYS_ON_STACK         -216
OCSM_ERROR_IN_BODYS_ON_STACK         -217
OCSM_MODL_NOT_CHECKED                -218
OCSM_NEED_TESSELLATION               -219

OCSM_BODY_NOT_FOUND                  -221
OCSM_FACE_NOT_FOUND                  -222
OCSM_EDGE_NOT_FOUND                  -223
OCSM_NODE_NOT_FOUND                  -224
OCSM_ILLEGAL_VALUE                   -225
OCSM_ILLEGAL_ATTRIBUTE               -226
OCSM_ILLEGAL_CSYSTEM                 -227
OCSM_NO_SELECTION                    -228

OCSM_SKETCH_IS_OPEN                  -231
OCSM_SKETCH_IS_NOT_OPEN              -232
OCSM_COLINEAR_SKETCH_POINTS          -233
OCSM_NON_COPLANAR_SKETCH_POINTS      -234
OCSM_TOO_MANY_SKETCH_POINTS          -235
OCSM_TOO_FEW_SPLINE_POINTS           -236
OCSM_SKETCH_DOES_NOT_CLOSE           -237
OCSM_SELF_INTERSECTING               -238
OCSM_ASSERT_FAILED                   -239

OCSM_ILLEGAL_CHAR_IN_EXPR            -241
OCSM_CLOSE_BEFORE_OPEN               -242
OCSM_MISSING_CLOSE                   -243
OCSM_ILLEGAL_TOKEN_SEQUENCE          -244
OCSM_ILLEGAL_NUMBER                  -245
OCSM_ILLEGAL_PMTR_NAME               -246
OCSM_ILLEGAL_FUNC_NAME               -247
OCSM_ILLEGAL_TYPE                    -248
OCSM_ILLEGAL_NARG                    -249

OCSM_NAME_NOT_FOUND                  -251
OCSM_NAME_NOT_UNIQUE                 -252
OCSM_PMTR_IS_EXTERNAL                -253
OCSM_PMTR_IS_INTERNAL                -254
OCSM_PMTR_IS_OUTPUT                  -255
OCSM_PMTR_IS_CONSTANT                -256
OCSM_WRONG_PMTR_TYPE                 -257
OCSM_FUNC_ARG_OUT_OF_BOUNDS          -258
OCSM_VAL_STACK_UNDERFLOW             -259  /* probably not enough args to func */
OCSM_VAL_STACK_OVERFLOW              -260  /* probably too many   args to func */

OCSM_ILLEGAL_BRCH_INDEX              -261  /* should be from 1 to nbrch */
OCSM_ILLEGAL_PMTR_INDEX              -262  /* should be from 1 to npmtr */
OCSM_ILLEGAL_BODY_INDEX              -263  /* should be from 1 to nbody */
OCSM_ILLEGAL_ARG_INDEX               -264  /* should be from 1 to narg  */
OCSM_ILLEGAL_ACTIVITY                -265  /* should OCSM_ACTIVE or OCSM_SUPPRESSED */
OCSM_ILLEGAL_MACRO_INDEX             -266  /* should be between 1 and 100 */
OCSM_ILLEGAL_ARGUMENT                -267
OCSM_CANNOT_BE_SUPPRESSED            -268
OCSM_STORAGE_ALREADY_USED            -269
OCSM_NOTHING_PREVIOUSLY_STORED       -270

OCSM_SOLVER_IS_OPEN                  -271
OCSM_SOLVER_IS_NOT_OPEN              -272
OCSM_TOO_MANY_SOLVER_VARS            -273
OCSM_UNDERCONSTRAINED                -274
OCSM_OVERCONSTRAINED                 -275
OCSM_SINGULAR_MATRIX                 -276
OCSM_NOT_CONVERGED                   -277

OCSM_UDP_ERROR1                      -281
OCSM_UDP_ERROR2                      -282
OCSM_UDP_ERROR3                      -283
OCSM_UDP_ERROR4                      -284
OCSM_UDP_ERROR5                      -285
OCSM_UDP_ERROR6                      -286
OCSM_UDP_ERROR7                      -287
OCSM_UDP_ERROR8                      -288
OCSM_UDP_ERROR9                      -289

OCSM_OP_STACK_UNDERFLOW              -291
OCSM_OP_STACK_OVERFLOW               -292
OCSM_RPN_STACK_UNDERFLOW             -293
OCSM_RPN_STACK_OVERFLOW              -294
OCSM_TOKEN_STACK_UNDERFLOW           -295
OCSM_TOKEN_STACK_OVERFLOW            -296
OCSM_UNSUPPORTED                     -298
OCSM_INTERNAL_ERROR                  -299
      </pre>

    <p><h3 id="sec9.2">9.2: EGADS error codes</h3>

    <p>In addition, sometimes <code>EGADS</code> or <code>CAPRI</code>
       will issue an error code.  The <code>EGADS</code> error codes
       that may be seen from time to time include:
      <!-- extract from egadsErrors.h -->
      <pre>
EGADS_SUCCESS                           0
EGADS_NOTFOUND                         -1
EGADS_NULLOBJ                          -2
EGADS_NOTOBJ                           -3
EGADS_MALLOC                           -4
EGADS_INDEXERR                         -5
EGADS_NONAME                           -6
EGADS_NODATA                           -7
EGADS_MIXCNTX                          -8
EGADS_NOTCNTX                          -9
EGADS_NOTXFORM                        -10
EGADS_REFERCE                         -11
EGADS_NOTTOPO                         -12
EGADS_EMPTY                           -13
EGADS_NOTTESS                         -14
EGADS_NOTGEOM                         -15
EGADS_RANGERR                         -16
EGADS_NOLOAD                          -17
EGADS_NOTMODEL                        -18
EGADS_WRITERR                         -19
EGADS_NOTBODY                         -20
EGADS_GEOMERR                         -21
EGADS_TOPOERR                         -22
EGADS_CONSTERR                        -23
EGADS_DEGEN                           -24
EGADS_NOTORTHO                        -25
EGADS_BADSCALE                        -26
EGADS_OCSEGFLT                        -27
EGADS_TOPOCNT                         -28
EGADS_ATTRERR                         -29
EGADS_EXISTS                          -30
EGADS_TESSTATE                        -31
EGADS_READERR                         -32
      </pre>

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec10">10.0: Bugs Reports and Other Feedback</h2>

    <p>All reports of possible 'bugs' and any other feedback should be
       e-mailed to 'jfdannen@syr.edu' or 'haimes@mit.edu'.  If a bug
       report, please include the version number you are running
       (listed in the title bar at the top of the program), what you
       were doing at the time of the bug, and what happened that you
       didn't expect.  The more information that you include, the
       better the chances that the bug can be reproduced and hence
       fixed.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec11">11.0: Copyright</h2>

    <p>Copyright (C) 2010/2020 John F. Dannenhoffer, III (Syracuse
       University)

    <p>This library is free software; you can redistribute it and/or
       modify it under the terms of the GNU Lesser General Public
       License as published by the Free Software Foundation; either
       version 2.1 of the License, or (at your option) any later
       version.

    <p>This library is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU Lesser General Public License for more details.

    <p>You should have received a copy of the GNU Lesser General
       Public License along with this library; if not, write to the
       Free Software Foundation, Inc., 51 Franklin Street, Fifth
       Floor, Boston, MA 02110-1301 USA

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

    <p><h2 id="sec12">12.0: Glossary</h2>

      <p><strong>@-parameter</strong> A local variable that is set by
      the system every time a new Body is created or a SELECT
      statement is executed.  The local variables, which cannot be set
      by the user, contain information such as the identity of various
      entities or mass properties.

      <p><strong>argument</strong> An expression that is input to an
      CSM statement.  Arguments are positional (that is, their
      meanings are specified by their order).  Optional arguments are
      listed last, and their default values are listed in the
      command's description.

      <p><strong>associative</strong> A concept that means that an
      entity in one Body is another representation of some other
      entity in some other Body.

      <p><strong>autosave.csm</strong> A file that contains a snapshot
      of the state of ESP before any command is executed.

      <p><strong>Attribute</strong> A user-defined name/value pair
      that is associated with a Branch, Body, Face, Edge, or Node.
      Names that begin with an underscore (_) have special meaning to
      CSM and those that begin with a period (.) have special meaning
      to EGADS.  The values associated an attribute can either be a
      string value (prepended by a dollar-sign ($)) or a
      semicolon-separated list of expressions.

      <p><strong>activity</strong> An characteristic of a Branch which
      tells if the Branch should be executed the next time the Model
      is re-built.  ESP supports 'active' and 'suppressed' activities.

      <p><strong>Body</strong> An object that is created by ESP to
      represent some physical artifact.  ESP supports SolidBodys,
      SheetBodys (which consist of a collection of connected Faces
      that may or may not be manifold), WireBodys (which consist of a
      collection of connected Edges, where each Edge shares a bounding
      Node with at most one other Edge), and NodeBodys (which consist
      of a single point in space).

      <p><strong>Boolean operation</strong> An operation that combines
      two Bodys (on the stack).  The UNION operation returns the
      fusion of two Bodys, the INTERSECT operation returns the common
      part of two Bodys, and the SUBTRACT operation returns the
      portion of Body1 that is not in Body2.

      <p><strong>Branch</strong> An entity in the Model's Feature
      Tree that corresponds to either a primitive solid,
      transformation, Boolean operator, sketch entity, or other
      item used in the construction of a Model.

      <p><strong>Brep</strong> A boundary representation is a
      collections of Nodes, Edges, and Faces that describe the
      boundary of a Body.

      <p><strong>browser</strong> A computer program with which a user
      interacts with ESP.  ESP currently runs in FireFox and SeaMonkey.

      <p><strong>client</strong> A program, typically a web browser,
      with which a user interacts.  The client handles some of ESP's
      operations directly (such as image manipulation), but sends
      messages to the server to perform the majority of ESP's
      operations.

      <p><strong>collapse</strong> The process of 'closing up' a node
      in a tree so that its children are not displayed.  This is
      accomplished by pressing the <strong>-</strong> to the left of
      an (expanded) tree node.

      <p><strong>command</strong> Synonym for statement.

      <p><strong>command line</strong> The statement typed into a
      terminal window to start <code>serveCSM</code>.

      <p><string>Configuation Parameter</strong> A value that can be
      set by the user, either programmatically or via the ESP user
      interface, that is used to generate a specific instance of a
      model.  Sensitivities cannot can be found with respect to a
      Configuration Parameter.

      <p><strong>constructive solid modeler</strong> A process by
      which complex Bodys are created through the combination of
      simpler (primitive) Bodys.

      <p><strong>curve</strong> A path through space, where the
      locations of points along the curve are given as [x,y,z]=f(t),
      where t is called the parametric coordinate.  Examples of curves
      include lines, conics, and NURBS curves.

      <p><strong>degree of freedom</strong> A variable in a sketch
      whose value must be computed by satisfying one or more
      constraints.  Each line in a sketch adds 2 degrees of freedom,
      each circular arc adds 3 degrees of freedom, ...

      <p><strong>dot-suffix</strong> A mechanism through which some
      property of a (multi-values) Parameter or Variable is returns
      (rather than the Parameter's value).  For
      example, <code>x.nrow</code> returns the number of rows
      of <code>x</code>.

      <p><strong>drag</strong> An operation in which a user presses a
      mouse button and holds it down while moving it to another
      location on the screen.

      <p><strong>Design Parameter</strong> A value that can be set by
      the user, either programmatically or via the ESP user interface,
      that is used to generate a specific instance of a model.
      Sensitivities of the configuration or tessellation can be found
      with respect to any Design Parameter.

      <p><strong>Design Velocity</strong> A change in an input
      parameter from which changes in the local surface normals will
      be computed.

      <p><strong>Edge</strong> The part of a Brep that is associated
      with a curve.  Each Edge has an underlying curve, the parametric
      coordinate (tbeg) at the beginning of the Edge, the parametric
      coordinate (tend) at the end of the Edge, and the Nodes at tbeg
      and tend.  If all the Edges in a Body support exactly two Faces,
      the Body is said to be manifold.

      <p><strong>EGADS</strong> The Electronic Geometry Aircraft
      Design System, is an open-source geometry interface
      to <code>OpenCASCADE</code>, in which the functionality
      in <code>OpenCASCADE</code> that is needed for construction of
      typical applications is incorporated into about 70 C-functions.

      <p><strong>ESP</strong> The Engineering Sketch Pad is a
      browser-based software system that allows users create, modify,
      (re-)build, and save constructive solid models built via OpenCSM.

      <p><strong>expand</strong> The process of 'opening up' a node in
      a tree to see its children nodes.  This is accomplished by
      pressing the <strong>+</strong> to the left of a (collapsed)
      tree node.

      <p><strong>expression</strong> An algebraic combination of
      variables and constants that produce a single number.
      Expressions can use any of OpenCSM's built-in functions and/or
      dot-suffixes.  Expressions are used as argument to OpenCSM's
      commands.

      <p><strong>Face</strong> The part of a Brep that is associated
      with a surface.  Faces are bounded by trimming curves in the
      form of Loops.  Each Face has only one outer Loop and zero or
      more inner Loops (which represent holes).  The trimming curves,
      which corresponds to the Face's bounding Edges, are described
      as a series of Pcurves.

      <p><strong>Feature Tree</strong> A build prescription that is
      made up of a series of statements (or commands).  The statements
      in the Feature Tree are executed sequentially (with loops being
      represented by patterns and logic represented by IFTHEN
      blocks).  During the execution of the Feature Tree, a stack of
      Bodys are maintained.  Each statement that generates a Body puts
      it onto the stack; statements that modify or combine Bodys get
      their inputs by popping Bodys off the stack (with the most
      recently created being popped off first).  When CSM completes,
      the Bodys that remain on the stack are available as output of
      CSM.

      <p><strong>flying mode</strong> A way of panning, zooming, and
      rotating a display in which the motion of the image in the
      Graphics Window changes as long as the user holds the mouse
      button.  Use the <strong>!</strong> key in the Graphics Window
      to toggle flying mode on and off.

      <p><strong>function</strong> An atomic operation that transforms
      its inputs into a single value.  Example include trigonometric
      operations and single in-line logical constructs.

      <p><strong>global Attribute</strong> An Attribute that is
      specified before any other CSM command.  Global Attributes are
      added to any Body created by CSM.

      <p><strong>Graphics window</strong> The window on the top-right
      of the ESP screen that contains a graphical representation of
      the current configuration.

      <p><strong>hostname</strong> The name of the computer that is
      running the server (typically serveCSM).  If using a single
      computer for both the browser and server, use 'Localhost' as the
      hostname.

      <p><strong>journal</strong> A file that is written (on the
      server) that keeps track of the commands that user executed
      while running ESP.  A user (who has access to the server) can
      copy the journal file to another name and use it to
      automatically replay the session that was journalled during a
      future invocation of serveCSM.

      <p><strong>Key window</strong> The window on the bottom left of
      the ESP screen that contains a spectrum to indicate sensitivity
      values.  If no sensitivity is active, this window in blank.

      <p><strong>Local Variable</strong> Either an array of numeric
      values (which can contain only one value, in which case it is
      called a scalar) or a string of characters.  Local variables get
      their values via SET and GETATTR statements.  Local variables
      are not accessible outside CSM, but only within CSM while the
      Feature Tree is being executed.

      <p><strong>Loop</strong> A collection of Edges, arranged end to
      end, where each Edge has exactly two neighboring Edges.  Loops,
      when applied to a surface, tells the part of the surface that is
      inside the Face.

      <p><strong>manifold solid</strong> A manifold solid is
      represented by a Brep, whose Edges all support two Faces.

      <p><strong>Messages window</strong> The window on the bottom
      right of the ESP screen that contains status information and
      other messages to the user.

      <p><strong>Model</strong> A container that contains the
      Parameters and (Feature Tree) Branches.

      <p><strong>Node</strong> The topological entity associated with
      a single location in space.  Nodes can be free-standing, such as
      in a NodeBody, but usually are at the ends of Edges.

      <p><strong>OpenCASCADE</strong> An open-source geometry system
      on which EGADS is built.

      <p><strong>OpenCSM</strong> The open-source constructive solid
      modeler that is a feature-based, associative, and parametric and
      which build Bodys that are either manifold solids (the typical
      output) or non-manifold sheets and wires (such as may be needed
      for representing wake sheets and antennae).

      <p><strong>Parameter</strong> A two-dimensional array of
      floating-point numbers that is used during the build process to
      generate a specific instance of a Model.

      <p><strong>pattern</strong> A looping construct, originally used
      to generate a series of features on a Body (such as a
      regularly-space series of holes).

      <p><strong>point</strong> A location in space either at a Node,
      along an Edge (or curve), or on a Face (or surface).

      <p><strong>port</strong> The port number on which the server
      (typically serveCSM) is listening for requests by the browser.
      serveCSM uses 7681 as its default port.

      <p><strong>primitive</strong> A CSM statement that generates
      either a box, sphere, cylinder, cone, or torus, or a
      user-defined primitive.

      <p><strong>semicolon-separated list</strong> A list of
      expressions (that evaluate to numeric values) that are written
      with semicolons (;) between entries.  A semicolon-separated list
      may optionally be terminated with a semicolon.

      <p><strong>sensitivity</strong> The derivative of the location
      on a Body with respect to one or more of the Design Parameters.

      <p><strong>server</strong> A computer program in which OpenCSM
      runs and which 'serves' Models and Boundary Representations to
      ESP.  The program 'serveCSM' is the initial server for ESP.

      <p><strong>sketch</strong> A 2-D drawing composed of lines,
      circular arcs, a splines, that is used to define a SheetBody
      (with a single Face) or WireBody.  Sketches are typically used
      as the basis of grown solids such as EXTRUDE, REVOLVE, RULE, and
      BLEND.  (The latter two of these actually use a series of
      sketches.)

      <p><strong>sketch constraint</strong> A rule for specifying the
      relationships between sketch variables.

      <p><strong>sketch variable</strong> A degree of freedom within a
      sketch.  There are two sketch variables associated with the
      point between each pair of sketch segments and one additional
      sketch variable associated with each circular arc segment.

      <p><strong>stack</strong> A construct used with the build
      process to establish parent-child relationships between various
      features in the Feature Tree.  Primitive statements, which create
      Bodys, push them onto the top of the stack.  Transformation
      statements pop the top Body (or group) from the stack, transform
      it/them, and then pushes the transformed result back onto the
      stack.  Boolean operation pop two (or more) Bodys from the top
      of the stack and push the resultant Body back onto the stack.

      <p><strong>statement</strong> A line of CSM code that
      corresponds to one of the steps in the build process in the
      Feature Tree.

      <p><strong>suppressed</strong> A possible state for a Branch;
      Branches that are suppressed are not executed when the Feature
      Tree is executed.  Suppression is typically used to temporarily
      remove a feature during a build.

      <p><strong>surface</strong> A sheet in space, where the
      locations of points on the surface are given as [x,y,z]=f(u,v),
      where u and v are called the parametric coordinates.  Examples
      of surfaces include planes, cylindrical surface, and
      tensor-product NURBS surfaces.

      <p><strong>transformation</strong> A type of CSM statement that
      pops a Body (or group) from the top of the stack, modifies it,
      and then pushes the modified Body (or group) back onto the
      stack.  Examples of transformations include TRANSLATE, ROTATE*,
      and SCALE.

      <p><strong>Tree window</strong> The window on the top-left of
      the ESP screen that contains command buttons, a tree-like view
      of the current Parameters, a tree-like view of the current
      Branches (of the Feature Tree), and a tree-like view of the
      display settings.

      <p><strong>UDC</strong> User-defined component.  This is
      essentially a macro that is stored in a .udc file.  It is
      execute with a UDPRIM statement, where the primtype either
      starts with / or $/

      <p><strong>UDF</strong> User-defined function.  The difference
      between a UDF and a UDP is that a UDP does not get any of its
      inputs from the stack, whereas a UDF consumes one or more Bodys
      from the stack.

      <p><strong>UDP</strong> User-defined primitive.  This is a
      user-supplied compiled file (from C or FORTRAN) that creates a
      non-standard primitive.  It is executed with a UDPRIM statement,
      where the primtype starts with a letter

      <p><strong>WebViewer</strong> A piece of software, built upon
      the standard WebGL, that allows for the real-time view angle
      changes in a browser.

    <p>Back to <a href="#sec0">Table of Contents</a>

    <!---------------------------------------------------------------->

  </body>
</html>
