--------------------------------------------------------------------------------------------

============================================================================================
Utilities and IO Functions
============================================================================================
--------------------------------------------------------------------------------------------
--open

icode = EG_open(ego *context)
icode = IG_open(I*8  context)

Opens and returns a CONTEXT object. Note that the Context is the beginning of the threaded list of objects.

--------------------------------------------------------------------------------------------
--free

     EG_free(void *ptr)
call IG_free(cptr  ptr)

Used to free up a pointer returned from EGADS if marked as freeable

--------------------------------------------------------------------------------------------
--deleteObject

icode = EG_deleteObject(ego object)
icode = IG_deleteObject(I*8 object)

Deletes an Object (if possible). A positive return indicates that the object is still referenced by this number of 
other objects and has not been removed from the context. If the object is the context then all objects in the context a
re deleted except those attached to BODY or MODEL objects.

--------------------------------------------------------------------------------------------
--getContext

icode = EG_getContext(ego object, ego *context)
icode = IG_getContext(I*8 object, I*8  context)

Returns the CONTEXT given an object

--------------------------------------------------------------------------------------------
--setOutLevel

icode = EG_setOutLevel(ego context, int outLevel)
icode = IG_setOutLevel(I*8 context, I*4 outLevel)

Sets the EGADS verbose level (0-silent to 3-debug), The default is 1.
On success it returns the old output level.

--------------------------------------------------------------------------------------------
--close

icode = EG_close(ego context)
icode = IG_close(I*8 context)

Cleans up and closes the CONTEXT

--------------------------------------------------------------------------------------------
--revision

     EG_revision(int *major, int *minor, char **OCCrev)
call IG_revision(I*4  major, I*4  minor, C**    OCCrev)

Returns the version information for EGADS and OpenCASCADE

--------------------------------------------------------------------------------------------
--loadModel

icode = EG_loadModel(ego context, int flags, 
                     char *name,  ego *model)
icode = IG_loadModel(I*8 context, I*4 flags,
                     C** name,    I*8 model)
Loads and returns a MODEL object from disk and put it in the CONTEXT.
flags:
		    1 - Don't split closed and periodic entities
		    2 - Split to maintain at least C1 in BSPLINEs
name: Load by extension
igs/iges
stp/step
brep 	(for native OpenCASCADE files)
egads	(for native files with persistent Attributes, split ignored)

--------------------------------------------------------------------------------------------
--saveModel

icode = EG_saveModel(ego model, char *name)
icode = IG_saveModel(I*8 model, C**   name)

Saves the MODEL to disk based on the filename extension.

--------------------------------------------------------------------------------------------
--getTransformation

icode = EG_getTransformation(ego oform, double *xform) 
icode = IG_getTransformation(I*8 oform, R*8     xform)

Returns the transformation information. This appears like is a column-major matrix that is 4 columns by 3 rows and could be thought of as [3][4] in C (though is flat) and in FORTRAN dimensioned as (4,3).

oform  	the transformation object
xform   	a vector of double precision reals at least 12 in length

--------------------------------------------------------------------------------------------
--makeTransform

icode = EG_makeTransform(ego context, double *xform,
                         ego *oform) 
icode = IG_makeTransform(I*8 context, R*8     xform,
                         I*8  oform)

Creates a TRANSFORM object from the 12 values. The rotation portion [3][3] must be "scaled" orthonormal (orthogonal with a single scale factor).

--------------------------------------------------------------------------------------------
--copyObject

icode = EG_copyObject(ego object, ego oform,
                      ego *newObject) 
icode = IG_copyObject(I*8 object, I*8 oform,
                      I*8  newObject)

Creates a new EGADS object by copying and transforming the input object.

object	the input object (3D geometry or topology)
oform  	the transformation object (may be NULL for a strict copy)
newObject	the resultant new object

--------------------------------------------------------------------------------------------
--flipObject

icode = EG_flipObject(ego object, ego *newObject) 
icode = IG_flipObject(I*8 object, I*8  newObject)

Creates a new EGADS object by copying and reversing the input object.

object	the input object: 3D geometry (flip the parameterization) or topology
 		(reverse the sense). Not for NODE, BODY or MODEL. SURFACEs 
		reverse only the u parameter.
newObject	the resultant new flipped object

--------------------------------------------------------------------------------------------
--getInfo

icode = EG_getInfo(ego object,  int *oclass, int *mtype, 
                   ego *topRef, ego *prev,   ego *next)
icode = IG_getInfo(I*8 object,  I*4 oclass,  I*4 mtype, 
                   I*8 topRef,  I*8 prev,    I*8 next)
Returns information about the object:
oclass   	CONTEXT, TRANSFORM, TESSELLATION, REFERENCE,
             	PCURVE, CURVE, SURFACE,
             	NODE, EGDE, LOOP, FACE, SHELL, BODY, MODEL
mtype   	PCURVE/CURVE 
                  LINE, CIRCLE, ELLIPSE, PARABOLA, HYPERBOLA, TRIMMED,
                  BEZIER, BSPLINE, OFFSET
             	SURFACE
                  PLANE, SPHERICAL, CYLINDER, REVOLUTION, TORIODAL,
                  TRIMMED, BEZIER, BSPLINE, OFFSET, CONICAL, EXTRUSION
             	EDGE is TWONODE, ONENODE or DEGENERATE
             	LOOP is OPEN or CLOSED
             	FACE is either SFORWARD or SREVERSE
             	SHELL is OPEN or CLOSED
             	BODY is either WIREBODY, FACEBODY, SHEETBODY or SOLIDBODY
topRef  	is the top level BODY/MODEL that owns the object or context (if top)
prev      	is the previous object in the threaded list (NULL at CONTEXT)
next      	is the next object in the list (NULL is the end of the list) 

--------------------------------------------------------------------------------------------

============================================================================================
Additional Memory Functions for the FORTRAN Bindings
============================================================================================
--------------------------------------------------------------------------------------------
--alloc

icode = IG_alloc(I*4 nbytes, CPTR ptr)

Allocates a block of memory (FORTRAN Bindings only)

--------------------------------------------------------------------------------------------
--calloc

icode = IG_calloc(I*4 nele, I*4 size, CPTR ptr)

Allocates a zero fills a block of memor (FORTRAN Bindings only)y

--------------------------------------------------------------------------------------------
--reall

icode = IG_reall(CPTR ptr, I*4 nbytes)

Reallocates a block of memor (FORTRAN Bindings only)y

--------------------------------------------------------------------------------------------

============================================================================================
Attribution
============================================================================================
--------------------------------------------------------------------------------------------
--attributeAdd

icode = EG_attributeAdd(ego object, char *name, int atype,
                        int len, int *ints, double *reals,
                        char *string)
icode = IG_attributeAdd(I*8 object, C**   name, I*4 atype, 
                        I*4 len, I*4  ints, R*8     reals,
                        C**   string)

Adds an attribute to the object. If an attribute exists with the name it is overwritten with the new information.

object  	the object
name   	the name of the attribute. Must not contain a space or other special characters 
atype    	must be either:
ATTRINT for integers
ATTRREAL for double precision
ATTRSTRING for a character string
len        	the number of integers or reals (ignored for strings)
ints       	the integers for ATTRINT
reals     	the floating point data for ATTRREAL or ATTRCSYS
string    	the character string for an ATTRSTRING type

	Note: Only the appropriate one (of ints, reals or string) is required

--------------------------------------------------------------------------------------------
--attributeDel

icode = EG_attributeDel(ego object, char *name)
icode = IG_attributeDel(I*8 object, C**   name)

Deletes an attribute from the object. If the name is NULL then all attributes are removed from this object.

object   	the object
name   	the name of the attribute.
           	FORTRAN can use a string containing just space(s)  to indicate NULL

--------------------------------------------------------------------------------------------
--attributeNum

icode = EG_attributeNum(ego object, int *nattr)
icode = IG_attributeNum(I*8 object, I*4  nattr)

Returns the number of attributes found with this object.

object  	the object
nattr     	the number of attributes

--------------------------------------------------------------------------------------------
--attributeGet

icode = EG_attributeGet(ego object, int index, char **name, 
                        int *atype, int *len,  int **pints, 
                        double **preals, char **string)
icode = IG_attributeGet(I*8 object, I*4  index, C**   name, 
                        I*4 atype,  I*4   len,  CPTR pints, 
                        R*8      preals,  C**   string)

Retrieves a specific attribute from the object.

object   	the object
index    	the index (1 to num from attributeNum)
name    	the returned name of the attribute
atype    	the returned type: ATTRINT, ATTRREAL, ATTRSTRING or ATTRCSYS
len        	the returned length for integers or reals
pints     	a pointer to integer(s) for ATTRINT
preals   	a pointer to the floating point data for ATTRREAL or ATTRCSYS
string    	the returned character string for an ATTRSTRING type

Notes: 	(1) Only the appropriate one (of pints, preals or string) is returned
        (2) Care must be taken with name and string in FORTRAN not to 
            overstep the declared CHARACTER length
        (3) The CSys (12 reals) is returned in preals after the len values

--------------------------------------------------------------------------------------------
--attributeRet

icode = EG_attributeRet(ego object, char *name, int *atype, 
                        int *len, int **pints, double **preals,
                        char **string)
icode = IG_attributeRet(I*8 object, C**   name, I*4  atype,
                        I*4  len, CPTR  pints,  R*8     preals,
                        C**    string)

Retrieves an attribute by name from the object.

object   	the object
name    	the name of the attribute to return
atype    	the returned type: ATTRINT, ATTRREAL, ATTRSTRING or ATTRCSYS
len        	the returned length for integers or reals
pints     	a pointer to integer(s) for ATTRINT
preals   	a pointer to the floating point data for ATTRREAL or ATTRCSYS
string    	the returned character string for an ATTRSTRING type

Notes: 	(1) Only the appropriate one (of pints, preals or string) is returned
       	(2) Care must be taken with the string variable in FORTRAN not to
            overstep the declared CHARACTER length
        (3) The CSys (12 reals) is returned in preals after the len values

--------------------------------------------------------------------------------------------
--attributeDup

icode = EG_attributeDup(ego src, ego dst) 
icode = IG_attributeDup(I*8 src, I*8 dst)

Removes all attributes from the destination object, then copies the attributes from the source.

src   	the source object
dst    	the destination object

--------------------------------------------------------------------------------------------

============================================================================================
Geometry
============================================================================================
--------------------------------------------------------------------------------------------
--getGeometry

icode = EG_getGeometry(ego object, int *oclass, int *mtype, 
                       ego *rGeom, int **pinfo, double **prv)
icode = IG_getGeometry(I*8 object, I*4 oclass,  I*4 mtype, 
                       I*8 rGeom,  CPTR pinfo,  CPTR prv)

Returns information about the geometric object:

oclass  	PCURVE, CURVE or SURFACE
mtype   	PCURVE/CURVE 
                  LINE, CIRCLE, ELLIPSE, PARABOLA, HYPERBOLA, TRIMMED,
                  BEZIER, BSPLINE, OFFSET
             	SURFACE
                  PLANE, SPHERICAL, CYLINDER, REVOLUTION, TORIODAL,
                  TRIMMED, BEZIER, BSPLINE, OFFSET, CONICAL, EXTRUSION
rGeom  	is the reference geometry object (if none this is returned as NULL)
pinfo     	is a returned pointer to the block of integer information. Filled for
            	either BEZIER or BSPLINE, and when nonNULL is freeable.
prv       	is the returned pointer to a block of double precision reals. The
            	content and length depends  on the oclass/mtype (freeable).

--------------------------------------------------------------------------------------------
--makeGeometry

icode = EG_makeGeometry(ego contxt, int oclass, int mtype, ego rGeom, 
                        int *pinfo, double *prv, ego *geom)
icode = IG_makeGeometry(I*8 contxt, I*4 oclass, I*4 mtype, I*8 rGeom, 
                        CPTR pinfo, CPTR    prv, I*8 geom)

Creates a geometric object:

contxt    	the CONTEXT object
oclass   	PCURVE, CURVE or SURFACE
mtype   	PCURVE/CURVE 
                   LINE, CIRCLE, ELLIPSE, PARABOLA, HYPERBOLA, TRIMMED,
                   BEZIER, BSPLINE, OFFSET
             	SURFACE
                   PLANE, SPHERICAL, CYLINDER, REVOLUTION, TORIODAL,
                   TRIMMED, BEZIER, BSPLINE, OFFSET, CONICAL, EXTRUSION
rGeom  	is the reference geometry object (if none use NULL)
pinfo     	is a pointer to the block of integer information. Required for
            	either BEZIER or BSPLINE.
prv       	is the pointer to a block of double precision reals. The
            	content and length depends  on the oclass/mtype.
geom   	is the resultant new geometry object

--------------------------------------------------------------------------------------------
--getRange

icode = EG_getRange(ego object, double *range, int *periodic) 
icode = IG_getRange(I*8 object, R*8     range, I*4  periodic) 

Returns the valid range of the object:

object      	may be one of PCURVE, CURVE, SURFACE, EDGE or FACE
range       	for PCURVE, CURVE or EDGE returns 2 values:
             		t-start and t-end
                	for SURFACE or FACE returns 4 values:
			u-min, u-max, v-min and v-max
periodic:  	0 for non-periodic 
                	1 for periodic in t or u
		2 for periodic in v (or-able)

--------------------------------------------------------------------------------------------
--evaluate

icode = EG_evaluate(ego object, double *parms, double *eval) 
icode = IG_evaluate(I*8 object, R*8     parms, R*8     eval) 

Returns the result of evaluating on the object:

object      may be one of PCURVE, CURVE, SURFACE, EDGE or FACE
parms      parameter(s) used to evaluate on the object:
                for PCURVE, CURVE or EDGE the one value is t
                for SURFACE or FACE the 2 values are u then v
eval         the returned position, 1st and 2nd derivatives  (length):

		         PCurve (6)	  Curve (9)	  Surface (18)
Position	 	  [u,v] 	   [x,y,z]	     [x,y,z]	
1st Derivative		 [du,dv]         [dx,dy,dz]        [dux,duy,duz] 
				   		     	   [dvx,dvy,dvz] 
2nd Derivative          [du2,dv2]       [dx2,dy2,dz2]	  [dux2,duy2,duz2] 
						          [duvx,duvy,duvz]
						          [dvx2,dvy2,dvz2] 

--------------------------------------------------------------------------------------------
--invEvaluate

icode = EG_invEvaluate(ego object,    double *pos, 
                       double *parms, double *result) 
icode = IG_invEvaluate(I*8 object,    R*8     pos, 
                       R*8     parms, R*8     result) 

Returns the result of inverse evaluation on the object. For topology the result is limited to inside the EGDE/FACE valid bounds.

object      may be one of PCURVE, CURVE, SURFACE, EDGE or FACE
pos	     is [u,v] for a PCURVE and [x,y,z] for all others
parms      the returned parameter(s) found for the nearest position on the
                object:
                for PCURVE, CURVE or EDGE the one value is t
                for SURFACE or FACE the 2 values are u then v
result       the closest position found is returned:
		     [u,v] for a PCURVE (2) and [x,y,z] for all others (3)

--------------------------------------------------------------------------------------------
--arcLength

icode = EG_arcLength(ego object,  double t1, double t2, double *alen) 
icode = IG_arcLength(I*8 object,  R*8    t1, R*8    t2, R*8     alen) 

Returns the arclength of an object. 

object      may be one of PCURVE, CURVE or EDGE
t1          starting t
t2          terminating t for calculation
result      the arclength computed

--------------------------------------------------------------------------------------------
--curvature

icode = EG_curvature(ego object, double *parms, double *crva) 
icode = IG_curvature(I*8 object, R*8     parms, R*8     crva) 

Returns the curvature and principle directions/tangents:

object      may be one of PCURVE, CURVE, SURFACE, EDGE or FACE
parms      parameter(s) used to evaluate on the object:
                for PCURVE, CURVE or EDGE the one value is t
                for SURFACE or FACE the 2 values are u then v
crva         the returned curvature information  (length):

		              	 Edge  -or-	 	    Face  -or-
	   PCurve (3)	   	 Curve (4)	  	   Surface (8)
           curvature	         curvature	       	    curvature1
	[dir.x, dir.y]      [dir.x ,dir.y, dir.z]      [dir1.x, dir1.y, dir1.z]
							    curvature2
						       [dir2.x, dir2.y, dir2.z]

--------------------------------------------------------------------------------------------
--approximate

icode = EG_approximate(ego context, int mDeg, double tol, 
                       int *sizes, double *xyz, ego *geo) 
icode = IG_approximate(I*8 context, I*4 mDeg, R*8    tol,
                       I*4  sizes, R*8     xyz, I*8  geo) 

Computes and returns the resultant geometry object created by approximating the data by a BSpline.

context	the CONTEXT object used to place the result
mDeg	is the maximum degree used for the approximation [3-8]
	0 -- fixes the bounds and uses natural end conditions
	1 -- fixes the bounds and maintains the slope input at the bounds
	2 -- fixes the bounds and maintains the slope input at 2nd order
tol	is the tolerance to use for the BSpline approximation procedure
	zero for a SURFACE [mDeg 3-8]: the data is fit with a cubic BSpline.
sizes	a vector of 2 integers that specifies the size and dimensionality of
	the data. If the second is zero, then a CURVE is fit and the first 
	integer is the length of the number of [x,y,z] triads. If the second 
	integer is nonzero then the input data reflects a 2D map.
xyz  	the data to fit (3 times the number of points in length)
geo	the returned approximated (or fit) BSpline resultant object

--------------------------------------------------------------------------------------------
--fitTriangles

icode = EG_fitTriangles(ego context, int  len,   double *pxyz, 
                        int ntri,    int *ptris, int *ptric, 
                        double tol,  ego *geo) 
icode = IG_fitTriangles(I*8 context, I*4  len,   R*8     pxyz,
                        I*4 ntri,    I*4  ptris, int  ptric,
                        R*8    tol,  I*8  geo) 

Computes and returns the resultant geometry object created by approximating the triangulation by a BSpline surface.

context	the CONTEXT object used to place the result
len	the number of vertices in the triangulation
pxyz 	the coordinates to fit (3 times len in length)
ntri	the number of triangles
ptris	the pointer to triangle indices (1 bias) (3 times ntri in length)
ptric	the pointer to neighbor triangle indices (1 bias) -- 0 or (-) at bounds
	NULL -- will compute (3 times ntri in length, if not NULL) 
tol	is the tolerance to use for the BSpline approximation procedure
geo	the returned approximated BSpline resultant object

--------------------------------------------------------------------------------------------
--otherCurve

icode = EG_otherCurve(ego surface, ego iCrv, double tol, 
                      ego *oCrv) 
icode = IG_otherCurve(I*8 surface, I*8 iCrv, R*8    tol,
                      I*8  oCrv) 

Computes and returns the other curve that matches the input curve. If the input curve is a PCURVE, the output curve is a 3D CURVE (and vice versa).

surface	the SURFACE object used for the conversion
iCrv	the input PCURVE or CURVE object
tol  	is the tolerance to use when fitting the output curve
oCrv	the returned approximated resultant curve object

--------------------------------------------------------------------------------------------
--isSame

icode = EG_isSame(ego obj1, ego obj2)
icode = IG_isSame(I*8 obj1, I*8 obj2)

Compares two objects for geometric equivalence.

obj1     	an object of type CURVE, EDGE, SURFACE or FACE
obj2     	an object of the same dimensionality

--------------------------------------------------------------------------------------------
--isoCline

icode = EG_isoCline(ego surface, int iUV, double val, ego *oCrv) 
icode = IG_isoCline(I*8 surface, I*4 iUV, R*8    val, I*8  oCrv) 

Computes from the input Surface and returns the isocline curve.

surface	the SURFACE object used for the conversion
iUV	either UISO (0) or VISO (1)
val   	the value of the isocline
oCrv	the returned approximated resultant curve object

--------------------------------------------------------------------------------------------
--convertToBSpline

icode = EG_convertToBSpline(ego geom, ego *bspline) 
icode = IG_convertToBSpline(I*8 geom, I*8  bspline) 

Computes and returns the BSpline representation of the input geometric object.

geom       	can be a CURVE, EDGE, SURFACE or  FACE
bspline     	the returned approximated resultant BSPLINE object

--------------------------------------------------------------------------------------------

============================================================================================
Topology
============================================================================================
--------------------------------------------------------------------------------------------
--getTolerance

icode = EG_getTolerance(ego object, double *tol)
icode = IG_getTolerance(I*8 object, R*8     tol)

Returns the internal tolerance defined for the object.
object  	topological object (all except MODEL)
tol  		the tolerance used to define closure

--------------------------------------------------------------------------------------------
--getTopology

icode = EG_getTopology(ego object, ego    *ref,  int *oclass, 
                       int *mtype, double *data, int *nchild,
                       ego **pchldrn, int **psens)
icode = IG_getTopology(I*8 object, I*8     ref,  I*4  oclass,
                       I*4 mtype,  R*8     data, I*4  nchild,
                       CPTR  pchldrn, CPTR  psens)

Returns information about the topological object:
ref          	is the reference geometry object (if none this is returned as NULL)
oclass    	is NODE, EGDE, LOOP, FACE, SHELL, BODY or MODEL
mtype    	for EDGE is TWONODE, ONENODE or DEGENERATE
              	for LOOP is OPEN or CLOSED
              	for FACE is either SFORWARD or SREVERSE
              	for SHELL is OPEN or CLOSED
              	BODY is either WIREBODY, FACEBODY, SHEETBODY or SOLIDBODY
data       	will retrieve at most 4 doubles:
              	for NODE this contains the [x,y,z] location
              	EDGE is the t-start and t-end (the parametric bounds)
              	FACE returns the [u,v] box (the limits first for u then for v)
nchild    	number of children (lesser) topological objects
pchldrn  	is a returned pointer to the block of children objects. 
              	FORTRAN only note: this pointer is freeable.
psens    	is the returned pointer to a block of integer senses for the children.

--------------------------------------------------------------------------------------------
--makeTopology

icode = EG_makeTopology(ego context, ego ref,  int oclass, 
                        int mtype, double *data, int nchild,
                        ego *chldrn, int *senses, ego *topo)
icode = IG_makeTopology(I*8 context, I*8 ref,  I*4 oclass,
                        I*4 mtype, R*8     data, I*4 nchild,
                        I*8  chldrn, I*4  senses, I*8  topo)

Creates and returns a topological object:
context   the CONTEXT object used to place the result
ref          reference geometry object required for EDGEs and FACEs (optional for LOOP)
oclass    is either NODE, EGDE, LOOP, FACE, SHELL, BODY or MODEL
mtype    for EDGE is TWONODE, ONENODE or DEGENERATE
              for LOOP is OPEN or CLOSED
              for FACE is either SFORWARD or SREVERSE
              for SHELL is OPEN or CLOSED
              BODY is either WIREBODY, FACEBODY, SHEETBODY or SOLIDBODY
data       may be NULL except for:
              NODE which contains the [x,y,z] location
              EDGE is the t-min and t-max (the parametric bounds)
nchild    number of children (lesser) topological objects
chldrn    a vector of children objects (nchild in length) 
              if LOOP and has reference SURFACE, then 2*nchild in length (PCURVES follow)
senses  a vector of integer senses for the children (required for FACES & LOOPs only)
topo       the resultant returned topological object

--------------------------------------------------------------------------------------------
--makeFace

icode = EG_makeFace(ego object, int mtype, double *data, 
                    ego *face)
icode = IG_makeFace(I*8 object, I*4 mtype, R*8     data,
                    I*8  face)

Creates a simple FACE from a LOOP or a SURFACE. Also can be used to hollow a single LOOPed existing FACE. This function creates any required NODEs, EDGEs and LOOPs.

object  	either a LOOP (for a planar cap) or a SURFACE with [u,v] bounds, or
		a FACE to be hollowed out
mtype    	is either SFORWARD or SREVERSE
              	for LOOPs you may want to look at the orientation using getArea,
		ignored when the input object is a FACE
data       	may be NULL for LOOPs but must be the limits for a SURFACE
		(4 values), the hollow/offset distance and fillet radius (zero is for
		no fillets) for a FACE input object (2 values)
face       	the resultant returned topological FACE object object (a return of 
		EGADS_OUTSIDE is the indication that offset distance was too 
		large to produce any cutouts, and this result is the input object)

--------------------------------------------------------------------------------------------
--makeLoop

icode = EG_makeLoop(int nEdge, ego *edges, ego geom, double toler,
                    ego *loop)
icode = IG_makeLoop(I*4 nEdge, I*8  edges, I*8 geom, R*8    toler,
                    I*8  loop)

Creates a LOOP from a list of EDGE Objects, where the EDGEs do 
not have to be topologically connected. The tolerance is used to 
build the NODEs for the LOOP. The orientation is set by the first 
non-NULL entry in the list, which is taken in the positive sense.
This is designed to be executed until all list entries are 
exhausted.

nEdge           the number of EDGE Objects in the list (>= 1)
edges           list of EDGEs, some may be NULL (nEdge in length)
		Note: entries are NULLified when included in LOOPs
geom            SURFACE Object for non-planar LOOPs to be used to
                bound FACEs (can be NULL)
toler           tolerance used for the operation (0.0 - use EDGE
                tolerances)
loop            the resultant LOOP Object 
icode		the number of nonNULL entries in edges when 
		returned or error code

--------------------------------------------------------------------------------------------
--makeSolidBody

icode = EG_makeSolidBody(ego context,  int stype, 
                         double *data, ego *body)
icode = IG_makeSolidBody(I*8 context,  I*4 stype, 
                         R*8     data, I*8  body)

Creates a simple SOLIDBODY. Can be either a box, cylinder, sphere, cone, or torus.

context  	the CONTEXT object used to place the result
stype     	1-box, 2-sphere, 3-cone, 4-cylinder, or 5-torus
data       	depends on stype:
              	box (6):         	[x,y,z] then [dx,dy,dz] for size of box
              	sphere (4):    	[x,y,z] of center then radius
              	cone (7):       	apex [x,y,z], base center [x,y,z], then radius
              	cylinder (7):  	2 axis points and the radius
              	torus (8):       	[x,y,z] of center, direction of rotation, then
                                    	major radius and minor radius
body      	the resultant returned topological BODY object

--------------------------------------------------------------------------------------------
--getBodyTopos

icode = EG_getBodyTopos(ego body,   ego *ref,  int oclass, 
                        int *ntopo, ego **ptopos)
icode = IG_getBodyTopos(I*8 body,   I*8  ref,  I*4 oclass,
                        I*4  ntopo, CPTR  ptopos)

Returns topologically connected objects:

body      	body container object
ref          	is the reference topological object or NULL. This sets the context for the returned objects 
		(i.e. all objects of a class [oclass] in the tree looking towards that class from ref)
              	NULL starts from the BODY (for example all NODEs in the BODY)
oclass    	is NODE, EGDE, LOOP, FACE or SHELL
ntopo     	the returned number of requested topological objects
ptopos   	is a returned pointer to the block of objects (freeable)

--------------------------------------------------------------------------------------------
--indexBodyTopo

index = EG_indexBodyTopo(ego body, ego obj)
index = IG_indexBodyTopo(I*8 body, I*8 obj)

Returns the index (bias 1) of the topological object in the Body:

body      	body container object
obj	   	is the topological object in the Body
index		the index or an error indicator (negative)

--------------------------------------------------------------------------------------------
--objectBodyTopo

index = EG_objectBodyTopo(ego body, int oclass, int index, ego *obj)
index = IG_objectBodyTopo(I*8 body, I*4 oclass, I*4 index, I*8  obj)

Returns the index (bias 1) of the topological object in the Body:

body      	body container object
oclass		is NODE, EGDE, LOOP, FACE or SHELL
index		is the index (bias 1) of the entity requested
obj	   	is the returned topological object in the Body

--------------------------------------------------------------------------------------------
--getArea

icode = EG_getArea(ego object, double *data, double *area)
icode = IG_getArea(I*8 object, R*8     data, R*8     area)

Computes the surface area from a LOOP, a SURFACE or a FACE. When a LOOP is used a planar surface is fit and the resultant area can be negative if the orientation of the fit is opposite of the LOOP.

object    	either a LOOP (for a planar cap), a SURFACE with [u,v] bounds
              	or a FACE
data       	may be NULL except must contain the limits for a SURFACE
area       	the resultant surface area returned

getBoundingBox

icode = EG_getBoundingBox(ego object, double *box)
icode = IG_getBoundingBox(I*8 object, R*8     box)

Computes the Cartesian bounding box around the object:

object    	any topological object
box        	6 doubles reflecting the [x,y,z] min and [x,y,z] max

--------------------------------------------------------------------------------------------
--getMassProperties

icode = EG_getMassProperties(ego topo, double *data)
icode = IG_getMassProperties(I*8 topo, R*8     data)

Computes and returns the physical and inertial properties of a topological object. 

topo       	the object, can be EDGE, LOOP, FACE, SHELL or BODY
data       	the data returned (must be declared to at least 14 doubles):
                 volume, surface area (or length for EDGE, LOOP or WIREBODY)
                 center of gravity (3)
                 inertia matrix at CoG (9)

--------------------------------------------------------------------------------------------
--isEquivalent

icode = EG_isEquivalent(ego topo1, ego topo2)
icode = IG_isEquivalent(I*8 topo1, I*8 topo2)

Compares two topological objects for equivalence.

topo1     	a topological object
topo2     	a topological object of the same class

--------------------------------------------------------------------------------------------
--inTopology

icode = EG_inTopology(ego topo, double *xyz)
icode = IG_inTopology(I*8 topo, R*8     xyz)

Computes whether the point is on or contained within the object. Works with EDGEs and FACEs by projection. SHELLs must be CLOSED.

topo       	the object, can be EDGE, FACE, SHELL or SOLIDBODY
xyz        	the coordinate location to check
icode     	the result or error code

--------------------------------------------------------------------------------------------
--inFace

icode = EG_inFace(ego face, double *uv)
icode = IG_inFace(I*8 face, R*8     uv)

Computes the result of the [u,v] location in the valid part of the FACE.

face       	the FACE object
uv          	the parametric location to check
icode     	the result or error code

--------------------------------------------------------------------------------------------
--getEdgeUV

icode = EG_getEdgeUV(ego face, ego edge, int sense,
                     double t, double *uv)
icode = IG_getEdgeUV(I*8 face, I*8 edge, I*4 sense,
                     R*8    t, R*8     uv)

Computes on the EDGE/PCURVE to get the appropriate [u,v] on the FACE.

face       	the FACE object
edge      	the EDGE object
sense    	can be 0, but must be specified if the EDGE is found the the FACE
              	twice. This uniquely specifies which position to use when the FACE
              	closes on itself.
t             	the parametric value to use for the evaluation
uv          	the resulting [u,v] evaluated at t.

--------------------------------------------------------------------------------------------
--getBody

icode = EG_getBody(ego object, ego *body)
icode = IG_getBody(I*8 object, I*8  body)

Returns the Body containing the Object.

object		the input object
body      	the returned Body object (if in a Body, otherwise NULL)

--------------------------------------------------------------------------------------------
--sewFaces

icode = EG_sewFaces(int nObject, ego *objects, double toler, int flag,
                    ego *model)
icode = IG_sewFaces(I*4 nObject, I*8  objects, R*8    toler, int flag,
                    I*8  model)


Creates a MODEL from a collection of Objects. The Objects can be either BODYs (not WIREBODY), SHELLs and/or FACEs. After the sewing operation, any unconnected Objects are returned as BODYs.

nObject		the number of Object in the list
objects		list of Objects to sew together (nObject in length)
toler		tolerance used for the operation (0.0 - use Face tolerances)
flag		0 - manifold, 1 - allow non-manifold results
model    	the resultant MODEL object
--------------------------------------------------------------------------------------------
--replaceFaces

icode = EG_replaceFaces(ego body, int nFace, ego *faces,
                        ego *result)
icode = IG_replaceFaces(I*8 body, I*4 nFace, I*8  faces,
                        I*8  result)

Creates a new SHEETBODY or SOLIDBODY from an input SHEETBODY or SOLIDBODY and a list of FACEs to modify. The FACEs are input in pairs where the first must be an Object in the BODY and the second either a new FACE or NULL.  The NULL replacement flags removal of the FACE in the BODY.

body		body container object
		Note: SOLIDBODYs must have a single (outer) SHELL
nFace		the number of FACE pairs in the list
faces		list of FACE pairs, where the first must be a FACE in the BODY and
		second is either the FACE to use as a replacement or a NULL which
		indicates that the FACE is to be removed from the BODY
		2*nFace in length
result    	the resultant BODY object, either a SHEETBODY or a SOLIDBODY
		(where the input was a SOLIDBODY and all FACEs are replaced in a
		way that the LOOPs match up)
--------------------------------------------------------------------------------------------
--matchBodyFaces

icode = EG_matchBodyFaces(ego body1,  ego body2, double tol,
                          int *nMatch, int **matches)
icode = IG_matchBodyFaces(I*8 body1,  I*8 body2, R*8    tol,
                          I*4  nMatch, CPTR  matches)

Examines the FACEs in one BODY against all of the FACEs in another. If the number of LOOPs, number of NODEs, the NODE locations, the number of EDGEs and the EDGE bounding boxes as well as the EDGE arc lengths match it is assumed that the FACEs match. A list of pairs of indices are returned.

body1      	first body container object 
body2      	second body container object 
tol		the tolerance used (can be zero)
nMatch		the number of matched FACE pairs in the list
matches		pointer to a list of FACE pairs, returned as NULL if nMatch is 
		zero, otherwise it is a pointer to 2*nMatch integers, where each
		pair is the matching indices in the respective bodies (freeable) 
Note: This is useful for the situation where there are glancing FACEs and a UNION operation fails (or would fail). Simply find the matching FACEs and do not include them in a call to EG_sewFaces.

--------------------------------------------------------------------------------------------
--mapBody

icode = EG_mapBody(ego src, ego dst, char *fAttr, ego *mapped)
icode = IG_mapBody(I*8 src, I*8 dst, C**   fAttr, I*8  mapped)

Checks for topological equivalence between the the BODY src and the BODY dst. If necessary, produces a mapping (indices in src which map to dst) and places these as attributes on the resultant BODY mapped (named .nMap, .eMap and .fMap). Also may modify BSplines associated with FACEs. 

src      	source body object
dst      	destination body object
fAttr		the FACE attribute used to map FACEs
mapped		the mapped resultant BODY object copied from dst
		If NULL and icode == EGADS_SUCCESS, dst is equivalent and can
		be used directly in EG_mapTessBody

Note: It is the responsibility of the caller to have uniquely attributed FACEs in both src and dst to aid in the mapping.

--------------------------------------------------------------------------------------------

============================================================================================
Tessellation
============================================================================================
--------------------------------------------------------------------------------------------
--makeTessGeom

icode = EG_makeTessGeom(ego geom, double *limits, int *sizes,
                        ego *tess)
icode = IG_makeTessGeom(I*8 geom, R*8     limits, I*4  sizes,
                        I*8  tess)

Creates a discretization object from a geometry-based Object.

geom    the input object, may be a CURVE or SURFACE
limits	the bounds of the tessellation (like range)
sizes  	a set of 2 integers that specifies the size and dimensionality of the
       	data. The second is assumed zero for a CURVE and in this case
       	the first integer is the length of the number of evenly spaced (in t)
       	points created. The second integer must be nonzero for SURFACEs
       	and this then specifies the density of the [u,v] map of coordinates
       	produced (again evenly spaced in the parametric space). If a value of
       	sizes is negative, then the fill is reversed for that coordinate.
tess   	the resultant TESSELLATION object

--------------------------------------------------------------------------------------------
--getTessGeom

icode = EG_getTessGeom(ego tess, int *sizes, double **pxyz)
icode = IG_getTessGeom(I*8 tess, I*4  sizes, CPTR     pxyz)

Retrieves the data associated with the discretization of a geometry-based Object.

tess   	the TESSELLATION object
sizes  	a returned set of 2 integers that specifies the size and dimensionality
       	of the data. If the second is zero, then it is from a CURVE and
       	the first integer is the length of the number of [x,y,z] triads. If the 
       	second integer is nonzero then the input data reflects a 2D map of 
       	coordinates.
pxyz   	the returned pointer to the suite of coordinate data.

--------------------------------------------------------------------------------------------
--makeTessBody

icode = EG_makeTessBody(ego body, double *parms, ego *tess)
icode = IG_makeTessBody(I*8 body, R*8     parms, I*8  tess)

Creates a discretization object from a Topologic BODY Object.

body  	the input object, may be a FACEBODY, SHEETBODY or SOLIDBODY.
parms 	a set of 3 parameters that drive the EDGE discretization and the
	FACE triangulation. The first is the maximum length of an EDGE
	segment or triangle side (in physical space). A zero is flag that allows
	for any length. The second is a curvature-based value that looks 
	locally at the deviation between the discrete object and the underlying
	geometry. Any deviation larger than the input value will cause the
	tessellation to be enhanced in those regions. The third is
	the maximum interior dihedral angle (in degrees) between triangle
	facets (or Edge segment tangents for a WIREBODY tessellation),
	note that a zero ignores this phase.
tess   	the resultant TESSELLATION object where each EDGE in the BODY 
	is discretized and each FACE is triangulated.

--------------------------------------------------------------------------------------------
--remakeTess

icode = EG_remakeTess(ego tess, int nobj, ego *facedg, double *parms)
icode = IG_remakeTess(I*8 tess, I*4 nobj, I*8  facedg, R*8     parms)

Redoes the discretization for specified objects from within a BODY TESSELLATION.

tess		the TESSELLATION object to modify.
nobj		number of objects in the face/edge list.
facedg		list of FACE and/or EDGE objects from within the BODY used to create the
		TESSELLATION object. First all specified Edges are rediscretized. Then
		any listed Face and the Faces touched by the retessellated Edges are
		retriangulated. Note that Quad Patches associated with Faces whose Edges
		were redone will be removed.
parms   	a set of 3 parameters that drive the EDGE discretization and the
		FACE triangulation. The first is the maximum length of an EDGE
		segment or triangle side (in physical space). A zero is flag that allows
		for any length. The second is a curvature-based value that looks 
		locally at the deviation between the discrete object and the underlying
		geometry. Any deviation larger than the input value will cause the
		tessellation to be enhanced in those regions. The third is
		the maximum interior dihedral angle (in degrees) between triangle
		facets (or Edge segment tangents for a WIREBODY tessellation),
		note that a zero ignores this phase.

--------------------------------------------------------------------------------------------
--mapTessBody

icode = EG_mapTessBody(ego tess, ego body, ego *mapTess)
icode = IG_mapTessBody(I*8 tess, I*8 body, I*8  mapTess)

Maps the input discretization object to another BODY Object. The topologies of the BODY that created the input tessellation must match the topology of the body argument (the use of EG_mapBody can be used to assist).

tess	input BODY TESSELLATION object
body	the BODY object (with a matching Topology) used to map the tessellation
mapTess	the resultant TESSELLATION object. The triangulation is simply copied
	but the uv and xyz positions reflect the input body

Note: Invoking EG_moveEdgeVert, EG_deleteEdgeVert and/or EG_insertEdgeVerts in the source tessellation before calling this routine invalidates the ability of EG_mapTessBody to perform its function.

--------------------------------------------------------------------------------------------
--locateTessBody

icode = EG_locateTessBody(ego tess, int npts, int *ifaces, double *uvs, 
                          int *itris, double *results)
icode = IG_locateTessBody(I*8 tess, I*4 npts, I*4  ifaces, R*8     uvs,
                          I*4  itris, R*8     results)

Provides the triangle and the vertex weights for each of the input requests or
the evaluated positions in a mapped tessellation.

tess	input BODY TESSELLATION object
npts	the number of input requests
ifaces	the face indices -- minus index refers to the use of a 
	mapped Face index from EG_mapBody and EG_mapTessBody
	(npts in length)
uvs	the UV positions in the face for each request (2*npts in length)
itris	the resultant triangle index (npts in length)
	if input as NULL then this function will perform mapped evaluations
results	the vertex weights in the triangle that refer to the requested position
	(any negative weight indicates that the point was extrapolated)  -or- 
	the evaluated position based on the input uvs (when itris is NULL)
	(3*npts in length)

--------------------------------------------------------------------------------------------
--getTessEdge

icode = EG_getTessEdge(ego tess, int eIndex, int *len,
                       double **pxyz, double **pt)
icode = IG_getTessEdge(I*8 tess, I*4 eIndex, I*4  len,
                       CPTR     pxyz, CPRT     pt)

Retrieves the data associated with the discretization of an EDGE from a Body-based Tessellation Object.

tess       	the TESSELLATION object
eIndex  	the EDGE index (1 bias). The EDGE Objects and number of EDGEs
		can be retrieved via EG_getBodyTopos and/or EG_indexBodyTopo.
		A minus refers to the use of a mapped (+) Edge index from applying
		the functions EG_mapBody and EG_mapTessBody.
len      	the returned number of vertices in the EDGE discretization
pxyz      	the returned pointer to the set of coordinate data.
pt      	the returned pointer to the parameter values associated with each 
		vertex.

--------------------------------------------------------------------------------------------
--getTessFace

icode = EG_getTessFace(ego tess, int fIndex, int *len, double **pxyz,
                       double **puv, int **ptype, int **pindex, 
                       int *ntri, int **ptris, int **ptric)
icode = IG_getTessFace(I*8 tess, I*4 fIndex, I*4  len, CPTR     pxyz,
                       CPRT     puv, CPRT  ptype, CPRT  pindex, 
                       I*4  ntri, CPTR  ptris, CPRT  ptric)

Retrieves the data associated with the discretization of a FACE from a Body-based Tessellation Object.

tess       	the TESSELLATION object
fIndex  	the FACE index (1 bias). The FACE Objects and number of FACEs
		can be retrieved via EG_getBodyTopos and/or EG_indexBodyTopo.
		A minus refers to the use of a mapped (+) Face index (if it exists).
len      	the returned number of vertices in the triangulation
pxyz      	the returned pointer to the set of coordinate data for each vertex
puv     	returned pointer to the parameter values associated with each vertex
ptype 	returned pointer to the vertex type (-1 - internal, 0 - NODE, >0 EDGE)
pindex	returned pointer to vertex index (-1 internal)
ntri		returned number of triangles
ptris	returned pointer to triangle indices (1 bias)
ptric	returned pointer to neighbor information

--------------------------------------------------------------------------------------------
--getTessLoops

icode = EG_getTessLoops(ego tess, int fIndex, int *nloop, int **lIndices)
icode = IG_getTessLoops(I*8 tess, I*4 fIndex, I*4  nloop, I*4   lIndices)

Retrieves the data for the LOOPs associated with the discretization of a FACE from a Body-based Tessellation Object.

tess       	the TESSELLATION object
fIndex  	the FACE index (1 bias). The FACE Objects and number of FACEs
		can be retrieved via EG_getBodyTopos and/or EG_indexBodyTopo.
nloop		the returned number of LOOPs in the FACE triangulation
lIndex		the returned pointer to a vector of the last index (bias 1) for 
		each LOOP (nloop in length). Notes: (1) all boundary vertices 
		are listed first for any FACE tessellation, (2) any outer LOOP 
		is ordered in the counter-clockwise direction, and (3) inner 
		LOOP(s) are ordered in the clockwise direction.

--------------------------------------------------------------------------------------------
--getTessQuads

icode = EG_getTessQuads(ego tess, int *len, int **pindices)
icode = IG_getTessQuads(I*8 tess, I*4  len, CPTR  pindices)

Returns a list of FACE indices found in the Body-based Tessellation Object that has been successfully Quadded.

tess       	the TESSELLATION object
len      	the returned number of FACEs with Quad patches
pindices  	the returned pointer the FACE indices (1 bias). The FACE Objects
		themselves can be retrieved via getBodyTopos. This pointer is
		freeable.

--------------------------------------------------------------------------------------------
--makeQuads

icode = EG_makeQuads(ego tess, double *parms, int fIndex)
icode = IG_makeQuads(I*8 tess, R*8     parms, I*4 fIndex)

Creates Quadrilateral Patches for the indicated FACE and updates the Body-based Tessellation Object.

tess       	the TESSELLATION object
parms   	a set of 3 parameters that drive the Quadrilateral patching for the
		FACE. Any may be set to zero to indicate the use of the default
		value:
		parms[0]	EDGE matching tolerance expressed as the deviation
			from an aligned dot product [default: 0.05]
		parms[1]	Maximum quad side ratio point count to allow
			[default: 3.0]
		parms[2]	Number of smoothing loops [default: 0.0]
fIndex     the FACE index (1 bias)

--------------------------------------------------------------------------------------------
--getQuads

icode = EG_getQuads(ego tess, int fIndex, int *len, 
                    double **pxyz, double **puv, int **ptype, 
                    int **pindex, int *npatch)
icode = IG_getQuads(I*8 tess, I*4 fIndex, I*4  len, 
                    CPTR     pxyz, CPRT     puv, CPRT  ptype,
                    CPRT  pindex, I*4  npatch)

Retrieves the data associated with the Quad-patching of a FACE from a Body-based Tessellation Object.

tess       	the TESSELLATION object
fIndex  	the FACE index (1 bias). The FACE Objects and number of FACEs
		can be retrieved via getBodyTopos.
len      	the returned number of vertices in the patching
pxyz      	the returned pointer to the set of coordinate data for each vertex
puv     	returned pointer to the parameter values associated with each vertex
ptype 	returned pointer to the vertex type (-1 - internal, 0 - NODE, >0 EDGE)
pindex	returned pointer to vertex index (-1 internal)
npatch	returned number of patches

--------------------------------------------------------------------------------------------
--getPatch

icode = EG_getPatch(ego tess, int fIndex, int pIndex, int *n1, 
                    int *n2, int **pvindex, int **pbounds) 
icode = IG_getPatch(I*8 tess, I*4 fIndex, I*4 pIndex, I*4  n1,
                    I*4  n2, CPRT  pvindex, CPRT  pbounds)

Retrieves the data associated with the Patch of a FACE from a Body-based Tessellation Object.

tess       	the TESSELLATION object
fIndex  	the FACE index (1 bias). The FACE Objects and number of FACEs
		can be retrieved via getBodyTopos.
pIndex	the patch index (1-npatch from EG_getQuads)
n1      	the returned patch size in the first direction (indexed by i)
n2		the returned patch size in the second direction (indexed by j)
pvindex 	the returned pointer to n1*n2 indices that define the patch
pbounds	returned pointer to the neighbor bounding information for the patch
		(2*(n1-1)+2*(n2-1) in length). The first represents the segments at the
		base (j at base and increasing in i), the next is at the right (with i
		at max and j increasing). The third is the top (with j at max and i
		decreasing) and finally the left (i at min and j decreasing).

--------------------------------------------------------------------------------------------
--moveEdgeVert

icode = EG_moveEdgeVert(ego tess, int eIndex, int vIndex, double t) 
icode = IG_moveEdgeVert(I*8 tess, I*4 eIndex, I*4 vIndex, R*8    t)

Moves the position of an EDGE vertex in a Body-based Tessellation Object. Will invalidate the Quad patches on any FACEs touching the EDGE.

	tess       	the TESSELLATION object
	eIndex  	the EDGE index (1 bias).
	vIndex		the Vertex index in the EDGE (2 - nVert-1)
	t      		the new parameter value on the EDGE for the point

deleteEdgeVert

icode = EG_deleteEdgeVert(ego tess, int eIndex, int vIndex, int dir) 
icode = IG_deleteEdgeVert(I*8 tess, I*4 eIndex, I*4 vIndex, I*4 dir)

Deletes an EDGE vertex from a Body-based Tessellation Object. Will invalidate the Quad patches on any FACEs touching the EDGE.

	tess       	the TESSELLATION object
	eIndex  	the EDGE index (1 bias).
	vIndex		the Vertex index in the EDGE to delete (2 - nVert-1)
	dir		the direction to collapse any triangles (either -1 or 1)

--------------------------------------------------------------------------------------------
--insertEdgeVerts

icode = EG_insertEdgeVerts(ego tess, int eIndex, int vIndex,
                           int len, double *ts) 
icode = IG_insertEdgeVerts(I*8 tess, I*4 eIndex, I*4 vIndex, 
                           I*4 len, R*8     ts)

Inserts vertices into the EDGE discretization of a Body-based Tessellation Object. This will invalidate the Quad patches on any FACEs touching the EDGE.

tess   	the TESSELLATION object
eIndex 	the EDGE index (1 bias).
vIndex	the Vertex index in the EDGE to insert the points after (1 - nVert-1)
len	the number of points to insert
ts     	the t values for the new points. Must be monotonically increasing and
	be greater than the t of vIndex and less than the t of vIndex+1.

--------------------------------------------------------------------------------------------
--initTessBody

icode = EG_initTessBody(ego body, ego *tess)
icode = IG_initTessBody(I*8 body, I*8  tess)

Creates an empty discretization object for a Topological BODY Object.

body   	the input object, may be any Body type. 
tess   	the resultant empty TESSELLATION object where each EDGE in the BODY
	must be filled via a call to EG_setTessEdge and each FACE must be
	filled 	with invocations of EG_setTessFace. The TESSSELLATION object is 
	considered open until all EDGEs have been set (for a WIREBODY) or all
 	FACEs have been set (for other Body types).

--------------------------------------------------------------------------------------------
--statusTessBody

icode = EG_statusTessBody(ego tess, ego *body, int *stat, int *npts)
icode = IG_statusTessBody(I*8 tess, I*8  body, I*4  stat, i*4  npts)

Returns the status of a TESSELLATION Object.

tess   	the TESSELLATION Object to query.
body    the returned associated BODY Object.
stat    the state of the tessellation: 0 - open, 1 - OK, 2 - displaced.
npts    the number of global points in the tessellation (0 -- open) 
icode   EGADS_SUCCESS -- complete, EGADS_OUTSIDE -- still open.

--------------------------------------------------------------------------------------------
--setTessEdge

icode = EG_setTessEdge(ego tess, int eIndex, int len, double *pxyz, double *pt)
icode = IG_setTessEdge(I*8 tess, I*4 eIndex, I*4 len, CPTR    pxyz, CPRT    pt)

Sets the data associated with the discretization of an EDGE for an open 
Body-based Tessellation Object. 

tess   	the open (not complete) TESSELLATION object
eIndex	the EDGE index (1 bias). The EDGE Objects and number of EDGEs
	can be retrieved via EG_getBodyTopos and/or EG_indexBodyTopo.
	If this EDGE already has assigned data, it is overwritten.
len	the number of vertices in the EDGE discretization.
pxyz   	the pointer to the set of coordinate data.
pt    	the pointer to the parameter values associated with each vertex.

 Notes:	(1) all vertices must be specified in increasing t.
	(2) the coordinates for the first and last vertex MUST match the
	     appropriate NODEs coordinates.
	(3) problems are reported to Standard Out regardless of the OutLevel.

--------------------------------------------------------------------------------------------
--setTessFace

icode = EG_setTessFace(ego tess, int fIndex, int len, double *pxyz,
			double *puv, int ntri, int *ptris)
icode = IG_setTessFace(I*8 tess, I*4 fIndex, I*4 len, CPTR    pxyz,
			CPRT    puv, I*4 ntri, CPTR ptris)

Sets the data associated with the discretization of a FACE for an open 
Body-based Tessellation Object.

tess 	the open (not complete) TESSELLATION object.
fIndex 	the FACE index (1 bias). The FACE Objects and number of FACEs can be
 	retrieved via EG_getBodyTopos and/or EG_indexBodyTopo.
	If this FACE already has assigned data, it is overwritten.
len	the number of vertices in the triangulation.
pxyz  	the pointer to the set of coordinate data for all vertices
	3*len in length.
puv    	the pointer to the vertex parameter values -- 2*len in length.
ntri	the number of triangles.
ptris	returned pointer to triangle vertex indices (1 bias) 
	3*ntri in length.

 Notes:	(1) all EDGEs associated with the FACE must have been set.
	(2) any vertex associated with a NODE or an EDGE must use the 
		coordinates specified by the NODE or the EDGE discretization.
	(3) this function will reorder the vertices to match EGADS internal 
		assumptions.
	(4) problems are reported to Standard Out regardless of the OutLevel.

--------------------------------------------------------------------------------------------
--localToGlobal

icode = EG_localToGlobal(ego tess, int index, int local, int *global) 
icode = IG_localToGlobal(I*8 tess, I*4 index, I*4 local, I*8  global)

Perform Local to Global index lookup. Tessellation Object must be closed.

tess   	the TESSELLATION object
index   the topological index (1 bias) -- (-) Edge, (+) Face
local   the local index
global  the returned global index

--------------------------------------------------------------------------------------------
--getGlobal

icode = EG_getGlobal(ego tess, int global, int *pty, int *pin, double *xyz)
icode = IG_getGlobal(I*8 tess, I*4 global, I*4  pty, I*4  pin, R*8     xyz)

Returns the point type and index (like from EG_getTessFace) with optional coordinates.

tess      the TESSELLATION object
global    the global index (1 bias).
pty       the point type (-) Face local index, (0) Node, (+) Face local index
pin       the point topological index (1 bias)
xyz       the coordinates at this global index (can be NULL for no return)

--------------------------------------------------------------------------------------------

============================================================================================
High-Level Functions
============================================================================================
--------------------------------------------------------------------------------------------
--solidBoolean

icode = EG_solidBoolean(ego src, ego tool, int oper,
                        ego *model)
icode = IG_solidBoolean(I*8 src, I*8 tool, I*4 oper,
                        I*8  model)

Performs the Solid Boolean Operations (SBOs) on the source BODY Object (that has the type SOLIDBODY). The tool object types depend on the operation. This supports Intersection, Subtraction and Union.

src         	the source SOLIDBODY object
tool        	the tool object:
		either a SOLIDBODY for all operators -or-
		a FACE/FACEBODY for Subtraction
oper       	1-Subtraction, 2-Intersection and 3-Fusion
model    	the resultant MODEL object (this is because there may be multiple
              	bodies from either the subtraction or intersection operation).

Note: This may now be called with src being a MODEL. In this case tool may be a SOLIDBODY for Intersection or a FACE/FACEBODY for Fusion. The input MODEL may contain anything, but must not have duplicate topology.

--------------------------------------------------------------------------------------------
--fuseSheets

icode = EG_fuseSheets(ego src, ego tool, ego *sheet)
icode = IG_fuseSheets(I*8 src, I*8 tool, I*8  sheet)

Fuses (unions) two SHEETBODYs resulting in a single SHEETBODY. 

src	the source SHEETBODY object
tool	the tool SHEETBODY object
sheet	the resultant SHEETBODY object

--------------------------------------------------------------------------------------------
--generalBoolean

icode = EG_generalBoolean(ego src, ego tool, int oper,
                          double tol, ego *model)
icode = IG_generalBoolean(I*8 src, I*8 tool, I*4 oper,
                          R*8    tol, I*8  model)

Performs the Boolean Operations on the source BODY Object(s). The tool Object(s) are applied depending on the operation. This supports Intersection, Splitter, Subtraction and Union.

src	the source BODY object(s) in the form of a MODEL or BODY
tool	the tool BODY object(s) in the form of a MODEL or BODY
oper	1-Subtraction, 2-Intersection, 3-Fusion, 4-Splitter
tol	the tolerance applied to perform the operation. If set to zero, the minimum tolerance is applied
model	the resultant MODEL object (this is because there may be multiple bodies from either the subtraction or intersection operation).

Note: The BODY Object(s) for src  and tool can be of any type but the results depend on the operation. Only works for OpenCASCADE 7.3.1 and higher.

--------------------------------------------------------------------------------------------
--intersection

icode = EG_intersection(ego src, ego tool, int *nEdge,
                        ego **pFacEdg, ego *model)
icode = IG_intersection(I*8 src, I*8 tool, I*4  nEdge,
                        CPTR  pFacEdg, I*8  model)

Intersects the source BODY Object (that has the type SOLIDBODY, SHEETBODY or 
FACEBODY) with a surface or surfaces. The tool object contains the intersecting
geometry in the form of a FACEBODY, SHEETBODY, SOLIDBODY or a single FACE.

src	the source BODY object
tool   	the FACE/FACEBODY/SHEETBODY/SOLIDBODY tool object
nEdge	the number of EDGE objects created
pFacEdg	pointer to FACE/EDGE object pairs - 2*nEdge in len (freeable)
	can be NULL (if you dont need this data - the EDGEs are in model)
model  	the resultant MODEL object which contains the set of WIREBODY
	BODY objects (this is because there may be multiple LOOPS as 
	a result of the operation).

NOTE: 	The EDGE objects contained within the LOOPS have the attributes
	of the FACE in src responsible for that EDGE.

--------------------------------------------------------------------------------------------
--imprintBody

icode = EG_imprintBody(ego src, int nObjs, ego *facEdLo, ego *result)
icode = IG_imprintBody(I*8 src, I*4 nObjs, I*8  facEdLo, I*8  result)

Imprints EDGE/LOOPs on the source BODY Object (that has the type SOLIDBODY, 
SHEETBODY or FACEBODY). The EDGE/LOOPs are paired with the FACEs in the 
source that will be scribed with the EDGE/LOOP.

src   	the source BODY object
nEdge	the number of object pairs to imprint
facEdLo	list of FACE/EDGE and/or FACE/LOOP object pairs to scribe
	2*nEdge in len -- can be the output from intersect
result 	the resultant BODY object (with the same type as the input source
	object, though the splitting of FACEBODY objects results in a
	SHEETBODY)

--------------------------------------------------------------------------------------------
--filletBody

icode = EG_filletBody(ego src, int nEdge, ego *edges,
                      double radius, ego *result, int **maps)
icode = IG_filletBody(I*8 src, I*4 nEdge, I*8  edges,
                      R*8    radius, I*8  result, CPTR  maps)

Fillets the EDGEs on the source BODY Object (that has the type SOLIDBODY or SHEETBODY).

src     the source BODY object
nEdge	the number of EDGE objects to fillet
edges	list of EDGE object to fillet - nEdge in len
radius	the radius of the fillets created
result  the resultant BODY object (with the same type as the input source object)
maps	list of Face mappings (in the result) which includes operations and an
	index to src where the Face originated  2*nFaces in result in length
	(freeable)

--------------------------------------------------------------------------------------------
--chamferBody

icode = EG_chamferBody(ego src, int nEdge, ego *edges,
                       ego *faces,  double dis1,
                       double dis2, ego *result, int **maps)
icode = IG_chamferBody(I*8 src, I*4 nEdge, I*8  edges,
                       I*8  faces,  R*8    dis1, 
                       R*8  dis2,   I*8  result, CPTR  maps)

Chamfers the EDGEs on the source BODY Object (that has the type SOLIDBODY or SHEETBODY).

src     the source BODY object
nEdge   the number of EDGE objects to chamfer
edges   list of EDGE objects to chamfer - nEdge in len
faces   list of FACE objects to measure dis1 from - nEdge in len
dis1    the distance from the FACE object to chamfer
dis2    the distance from the other FACE to chamfer
result  the resultant BODY object (with the same type as the input source object)
maps	list of Face mappings (in the result) which includes operations and an
	index to src where the Face originated  2*nFaces in result in length
	(freeable)

--------------------------------------------------------------------------------------------
--hollowBody

icode = EG_hollowBody(ego src, int nFace, ego *faces,
                      double off, int join, ego *result, int **maps)
icode = IG_hollowBody(I*8 src, I*4 nFace, I*8  faces,
                      R*8    off, I*4 join, I*8  result, CPTR  maps)

A hollowed solid is built from an initial SOLIDBODY Object and a set of FACEs that initially bound the solid. These FACEs are removed and the remaining FACEs become the walls of the hollowed solid with the specified thickness. If there are no FACEs specified then the Body is offset by the specified distance (which can be negative).

src     the source BODY object
nFace   the number of FACE objects to remove (0 performs an Offset)
faces   list of FACE objects to fillet - nFace in len
off     the wall thickness (offset) of the hollowed result
join    0 - fillet-like corners, 1 - expanded corners
result  the resultant SOLIDBODY object
maps	list of Face mappings (in the result) which includes operations and an
	index to src where the Face originated  2*nFaces in result in length
	(freeable)

--------------------------------------------------------------------------------------------
--rotate

icode = EG_rotate(ego src, double angle, double *axis,
                  ego *result)
icode = IG_rotate(I*8 src, R*8    angle, R*8     axis,
                  I*8  result)

Rotates the source Object about the axis through the angle specified. If the Object is either a LOOP or WIREBODY the result is a SHEETBODY. If the source is either a FACE or FACEBODY then the returned Object is a SOLIDBODY.

src         	the source Object
angle	the angle to rotate the object through [0-360 Degrees]
axis	a point (on the axis) and a direction (6 in length)
result    	the resultant BODY object (type is one greater than the input source
		object)

--------------------------------------------------------------------------------------------
--extrude

icode = EG_extrude(ego src, double length, double *dir,
                   ego *result)
icode = IG_extrude(I*8 src, R*8    length, R*8     dir,
                   I*8  result)

Extrudes the source Object through the distance specified. If the Object is either a LOOP or WIREBODY the result is a SHEETBODY. If the source is either a FACE or FACEBODY then the returned Object is a SOLIDBODY.

src         	the source Object
length	the the distance to extrude
dir		the vector that is the extrude direction (3 in length)
result    	the resultant BODY object (type is one greater than the input source
		object)

--------------------------------------------------------------------------------------------
--sweep

icode = EG_sweep(ego src, ego edge, int mode, ego *result)
icode = IG_sweep(I*8 src, I*8 edge, I*4 mode, I*8  result)

Sweeps the source Object through the "spine" specified. The spine can be either an EDGE, LOOP or WIREBODY. If the source Object is either a LOOP or WIREBODY the result is a SHEETBODY. If the source is either a FACE or FACEBODY then the returned Object is a SOLIDBODY.

src	the source Object
spine	the Object used as guide curve segment(s) to sweep the source
	through
mode	sweep mode:
		0 - CorrectedFrenet	5 - GuideAC
		1 - Fixed		6 - GuidePlan
		2 - Frenet		7 - GuideACWithContact 
		3 - ConstantNormal	8 - GuidePlanWithContact 
		4 - Darboux		9 - DiscreteTrihedron  
result	the resultant BODY object (type is one greater than the input
	source Object)

--------------------------------------------------------------------------------------------
--loft

icode = EG_loft(int nSection, ego *sections,
                int options,  ego *result)
icode = IG_loft(I*4 nSection, I*8  sections,
                I*4 options,  I*8  result)

Lofts the input Objects to create a BODY Object (that has the type SOLIDBODY or SHEETBODY).

nSection	the number of Sections in the Loft Operation
sections	list of WIREBODY or LOOP objects to Loft - nSection in len
		the first and last can be NODEs
		options	bit flag that controls the loft:
			1 - SOLIDBODY result (default is SHEETBODY)
			2 - Ruled (linear) Loft (default is smooth)
result    	the resultant BODY object

--------------------------------------------------------------------------------------------
--blend
icode = EG_blend(int nSection, ego *sections, double *rc1,
                 double *rcN,  ego *result)
icode = IG_blend(I*4 nSection, I*8  sections, R*8     rc1,
                 R*8     rcN,  I*8  result)

Simply lofts the input Objects to create a BODY Object (that has the type 
SOLIDBODY or SHEETBODY).  Cubic BSplines are used. All sections must have 
the same number of Edges (except for NODEs) and the Edge order in each 
(defined in a CCW manner) is used to specify the loft connectivity.

nSection	the number of Sections in the Blend Operation
		interior sections can be repeated once for C1 or twice for C0
sections	list of WIREBODY or LOOP objects to Loft - nSection in len
		the first and last can be NODEs and/or FACEs (only one LOOP),
		if the first and last are NODEs and/or FACEs the result will be
		a SOLIDBODY otherwise a SHEETBODY will be constructed
rc1		specifies treatment* for 1st section (or NULL)
rcN		specifies treatment* for the last section (or NULL)
result    	the resultant BODY object

*	NODE -- elliptical treatment (8 in length): radius of curvature1, 
		unit direction, rc2, orthogonal direction
	other sections -- setting tangency (4 in length): magnitude,
		unit direction
	FACEs with 2 or 3 EDGEs -- make a rounded Wing Tip like cap: zero, 
		growthFactor (a length of 2)
--------------------------------------------------------------------------------------------
--ruled
icode = EG_ruled(int nSection, ego *sections, ego *result)
icode = IG_ruled(I*4 nSection, I*8  sections, I*8  result)

Produces a BODY Object (that has the type SOLIDBODY or SHEETBODY) that goes 
through the sections by ruled surfaces between each. All sections must have 
the same number of Edges (except for NODEs) and the Edge order in each is 
used to specify the connectivity.

nSection	the number of Sections in the Ruled Operation
Sections	A list of NODE, WIREBODY, LOOP and/or FACE objects to operate
			upon - nSection in len,
		Any FACE objects must contain only a single LOOP,
		Only the first and last sections can be NODEs, 
		If the first and last sections are NODEs and/or FACEs and all
 			WIREBODY and LOOP objects are closed, the result will be
			a SOLIDBODY otherwise a SHEETBODY will be constructed
result    	the resultant BODY object

Note: for both blend and ruled all Loops must have their Edges ordered in a 
counterclockwise manner.

--------------------------------------------------------------------------------------------

============================================================================================
Return Codes
============================================================================================
--------------------------------------------------------------------------------------------
--error codes

#define EGADS_ATTRERR  -29
#define EGADS_TOPOCNT  -28
#define EGADS_OCSEGFLT -27
#define EGADS_BADSCALE -26
#define EGADS_NOTORTHO -25
#define EGADS_DEGEN    -24
#define EGADS_CONSTERR -23
#define EGADS_TOPOERR  -22
#define EGADS_GEOMERR  -21
#define EGADS_NOTBODY  -20
#define EGADS_WRITERR  -19
#define EGADS_NOTMODEL -18
#define EGADS_NOLOAD   -17
#define EGADS_RANGERR  -16
#define EGADS_NOTGEOM  -15
#define EGADS_NOTTESS  -14
#define EGADS_EMPTY    -13
#define EGADS_NOTTOPO  -12
#define EGADS_REFERCE  -11
#define EGADS_NOTXFORM -10
#define EGADS_NOTCNTX   -9
#define EGADS_MIXCNTX   -8
#define EGADS_NODATA    -7
#define EGADS_NONAME    -6
#define EGADS_INDEXERR  -5
#define EGADS_MALLOC    -4
#define EGADS_NOTOBJ    -3
#define EGADS_NULLOBJ   -2
#define EGADS_NOTFOUND  -1
#define EGADS_SUCCESS    0
#define EGADS_OUTSIDE    1      /* also -- not the same */
--------------------------------------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
