/*
 ************************************************************************
 *                                                                      *
 * OpenCSM -- an open-source constructive solid modeler                 *
 *                                                                      *
 *            Written by John Dannenhoffer @ Syracuse University        *
 *                                                                      *
 ************************************************************************
 */

/*
 * Copyright (C) 2010/2020  John F. Dannenhoffer, III (Syracuse University)
 *
 * This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 *     MA  02110-1301  USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <float.h>
#include <math.h>
#include <assert.h>

//#define PRINT_BODYS         1           /* uncomment to print Bodys for each statement */
//#define FORCE_FINITE_DIFFS  1           /* uncomment to force finite differences */
//#define SHOW_SPLINES        1           /* uncomment to show splines with GRAFIC */
//#define USE_FUSESHEETS      1           /* uncomment to use EG_fuseSheets */
//#define PRINT_TIMES         1           /* uncomment to print boolean user/system times */
//#define PRINT_FAULTS        1           /* uncomment to print page faults per Branch */
//#define PRINT_PROGRESS      1           /* uncomment to print progress at end of each Branch */
#define USE_VELOCITYOFEDGE  1           /* uncomment to get Node velocities from Edges */
#define INTERP_VEL          2           /* =0 use eggMorph, =1 use MVC, =2 use VR-MVC, =3 use RBF */
#define MORPH_GRID          1           /* =0 use EG_mapTessBody, =1 use EGG_morph if possible */
//#define EDGE_HIST_TRANSFORM 1           /* uncomment to add _hist to edges for sensitvity transform */

#include "egads.h"
#include "egads_dot.h"
#include "egadsSplineVels.h"
#include "common.h"
#include "OpenCSM.h"
#include "udp.h"
#include "egg.h"

#ifdef  PRINT_TIMES
    #include <sys/time.h>
    #include <sys/resource.h>
    static double  bool_user_time=0, bool_sys_time=0, bool_wall_time=0;
#endif

#ifdef  PRINT_FAULTS
    #include <sys/resource.h>
    static long    old_minfaults, old_majfaults, new_minfaults, new_majfaults;
#endif

#ifdef  PRINT_PROGRESS
    #define PPRINT_INIT(MESG)  cpu_beg = clock(); SPRINT0(0, #MESG);
    #define PPRINT0(MESG)      cpu_end = clock(); SPRINT1(0, "...%10.3f sec: " #MESG, (double)(cpu_end-cpu_beg)/(double)(CLOCKS_PER_SEC)); cpu_beg=cpu_end;
    #define PPRINT1(MESG,A)    cpu_end = clock(); SPRINT2(0, "...%10.3f sec: " #MESG, (double)(cpu_end-cpu_beg)/(double)(CLOCKS_PER_SEC), A); cpu_beg=cpu_end;
    #define PPRINT2(MESG,A,B)  cpu_end = clock(); SPRINT3(0, "...%10.3f sec: " #MESG, (double)(cpu_end-cpu_beg)/(double)(CLOCKS_PER_SEC), A, B); cpu_beg=cpu_end;
#else
    #define PPRINT_INIT(MESG)
    #define PPRINT0(MESG)
    #define PPRINT1(MESG,A)
    #define PPRINT2(MESG,A,B)
#endif

#ifdef WIN32
    #include <windows.h>
    #include <direct.h>
    #define  snprintf    _snprintf
    #define  SLASH       '\\'
    #define  DLL         HINSTANCE
    #define  getcwd      _getcwd
#else
    #include <unistd.h>
    #include <dlfcn.h>
    #define  SLASH       '/'
    #define  DLL         void *
#endif

#define CINT    const int
#define CDOUBLE const double
#define CCHAR   const char
#define STRNCPY(TO, FROM, LEN) strncpy(TO, FROM, LEN); TO[LEN-1] = '\0';

#define   DTIME_NOM           0.00001     /* nominal finite difference step */

#ifdef SHOW_SPLINES
    #include "grafic.h"
#endif

#ifdef GRAFIC
    #include "grafic.h"
#endif

#ifndef WIN32
//    #define BACKTRACE
#endif
#ifdef BACKTRACE
    #include <execinfo.h>
#endif

#define OCSM_MAGIC        4433340       /* magic number */
#define TESS_PARAM_0      0.0250
#define TESS_PARAM_1      0.0075
#define TESS_PARAM_2      20.0

/*
 ************************************************************************
 *                                                                      *
 * Structures                                                           *
 *                                                                      *
 ************************************************************************
 */

/* "Rpn" contains information associated with Rpn (pseudo-code) */
typedef struct {
    int    type;                       /* type (see below) */
    char   text[MAX_STRVAL_LEN];       /* associated text */
} rpn_T;

/* "Stack" is used within the RPN evaluator */
typedef struct {
    double val;                        /* value */
    double dot;                        /* velocity */
    int    nan;                        /* =1 if NaN */
    char   str[MAX_STRVAL_LEN];        /* string value */
} stack_T;

/* "Patn" contains information associated with a patbeg/patend,
          ifthen/elseif/else/endif, catbeg/catend, or macbeg/macend pair */
typedef struct {
    int    itype;                      /* OCSM_PATBEG, OCSM_IFTHEN, OCSM_CATBEG, or OCSM_RECALL */
    int    ibeg;                       /* Branch number of patbeg, ifthen, catbeg, or recall */
    int    iend;                       /* Branch number of patend, endif,  catend */
    int    ncopy;                      /* total number of copies */
    int    icopy;                      /* current instance number (1->ncopy) */
    int    ipmtr;                      /* Parameter index of iterator */
} patn_T;

/* "Sket" is a Sketch */
typedef struct {
    int    type;                       /* 0 for old style, 1 for xy, 2 for yz, 3 for zx */
    int    irel;                       /* =1 if coordinates are relative to SKBEG */
    int    size;                       /* size of x[], y[], and z[] */
    int    solved;                     /* =1 if Sketch is solved */
    int    ix;                         /* Parameter index associated with ::x[] */
    int    iy;                         /* Parameter index associated with ::y[] */
    int    iz;                         /* Parameter index associated with ::z[] */
    int    id;                         /* Parameter index associated with ::d[] */

    double xbase;                      /* x-coordinate in skbeg statement */
    double ybase;                      /* y-coordinate in skbeg statement */
    double zbase;                      /* z-coordinate in skbeg statement */

    int    nseg;                       /* number of segments */
    int    itype[MAX_SKETCH_SIZE];     /* Branch type */
    int    ibrch[MAX_SKETCH_SIZE];     /* Branch index */
    double x[    MAX_SKETCH_SIZE];     /* X-coordinate at end of segment */
    double y[    MAX_SKETCH_SIZE];     /* Y-coordinate at end of segment */
    double z[    MAX_SKETCH_SIZE];     /* Z-coordinate at end of segment */

    int    nvar;                       /* number of variables (at least 2*nseg) */
    int    ipmtr[MAX_SKETCH_SIZE];     /* Parameter index */
    int    index[MAX_SKETCH_SIZE];     /* value index */

    int    ncon;                       /* number of constraints */
    char   ctype[MAX_SKETCH_SIZE];     /* constraint type (letter) */
    int    ipnt[ MAX_SKETCH_SIZE];     /* first  constraint index */
    int    ip1[  MAX_SKETCH_SIZE];     /* second constraint index */
    char   con[MAX_SKETCH_SIZE][MAX_EXPR_LEN];
} sket_T;

/* user data information for EG_*_vels spline sensitvity functions */
typedef struct {
    int           *isketch;            /* array  of Body numbers sketches */
    modl_T        *MODL;               /* pointer to MODL */
} egadsSpline_T;

/* red-black tree */
typedef struct {
    int    nnode;                      /* current number of Nodes */
    int    mnode;                      /* maximum number of Nodes */
    int    root;                       /* index of root Node */
    int    chunk;                      /* chunk size */
    int*   key1;                       /* array of primary    keys */
    int*   key2;                       /* array of secondary  keys */
    int*   key3;                       /* array of tertiary   keys */
    int*   key4;                       /* array of quaternary keys */
    int*   data;                       /* data associated with entry */
    int*   left;                       /* array of left children */
    int*   rite;                       /* array of rite children */
    int*   prnt;                       /* array of parents */
    int*   colr;                       /* array of colors */
} rbt_T;

/*
 ************************************************************************
 *                                                                      *
 * Definitions (for structures above)                                   *
 *                                                                      *
 ************************************************************************
 */

#define           PARSE_NOP         0   /* no operation */
#define           PARSE_OP1         1   /* either add "+" or subtract "-" */
#define           PARSE_OP2         2   /* either multiply "*" or divide "/" */
#define           PARSE_OP3         3   /* exponentiation "^" */
#define           PARSE_OPENP       4   /* open  parenthesis "(" */
#define           PARSE_CLOSEP      5   /* close parenthesis ")" */
#define           PARSE_OPENB       6   /* open  bracket "[" */
#define           PARSE_CLOSEB      7   /* close bracket "]" */
#define           PARSE_COMMA       8   /* comma "," */
#define           PARSE_NAME        9   /* variable name */
#define           PARSE_ARRAY      10   /* array name */
#define           PARSE_FUNC       11   /* function name */
#define           PARSE_NUMBER     12   /* number */
#define           PARSE_STRING     13   /* string */
#define           PARSE_END        14   /* end of Rpn-code */

#define           RBT_BLACK         0
#define           RBT_RED           1

/*
 ************************************************************************
 *                                                                      *
 * Macros (including those that go along with common.h)                 *
 *                                                                      *
 ************************************************************************
 */

static void *realloc_temp=NULL;              /* used by RALLOC macro */

/*
 ************************************************************************
 *                                                                      *
 * Declarations for support routines defined below                      *
 *                                                                      *
 ************************************************************************
 */

static int adjustFileSpec(FILE *csm_file, char filename[], int *linenum, char str[]);
static int buildApplied(  modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[]);
static int buildBoolean(  modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[]);
static int buildGrown(    modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[]);
static int buildPrimitive(modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[]);
static int buildSketch(   modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[], sket_T *sket);
static int buildSolver(   modl_T *modl, int ibrch, varg_T args[], int *nvar, int solvars[],
                          int *ncon, int solcons[]);
static int buildTransform(modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[]);
static int checkForFiniteDifferences(modl_T *modl, int ibody);
static int colorizeEdge(modl_T *modl, int ibody, int iedge);
static int colorizeFace(modl_T *modl, int ibody, int iface);
static int colorizeNode(modl_T *modl, int ibody, int inode);
static int createPerturbation(modl_T *modl);
       int createTessVels(modl_T *modl, int ibody);
static int delPmtrByName(modl_T *modl, char name[]);
static int dumpEgadsFile(modl_T *modl, int ibody);
static int evalRpn(rpn_T *rpn, modl_T *modl, double *val, double *dot, char str[]);
static int faceContains(ego eface, double xx, double yy, double zz);
static int finishBody(modl_T *modl, int ibody);
static int finishCopy(modl_T *modl, int src, /*@null@*/double matrix[], int ibody);
static int finiteDifference(modl_T *modl, int ibody, int seltype, int iselect, int npnt, /*@null@*/double uv[], double dxyz[]);
static int fixSketch(sket_T *sket, char vars_in[], char cons_mod[]);
static int fixSketchRank(sket_T *sket, int npnt, int segtyp[], int *jrank);
static int freeBody(modl_T *modl, int ibody);
static int getBodyTolerance(ego ebody, double *toler);
static int getToken(char *text, int nskip, char sep, int maxtok, char *token);
static int joinSheetBodys(modl_T *modl, ego ebodyl, ego ebodyr, double toler, ego *ebody);
static int joinWireBodys(modl_T *modl, ego ebodyl, ego ebodyr, double toler, ego *ebody);
static int makeEdge(modl_T *modl, ego ebeg, ego eend, ego *eedge);
static int makeFace(modl_T *modl, ego eedges[], int fillstyle, int dirn, ego *eface);
static int matches(char pattern[], const char string[]);
static int matsol(double A[], double b[], int n, double x[]);
static int mvcInterp(int nloop, CINT nper[], CDOUBLE uvframe[], CDOUBLE uv[], double weights[]);
static int newBody(modl_T *modl, int ibrch, int brtype, int ileft, int irite, varg_T args[], int hasdots, int botype, int *ibody);
static int parseName(modl_T *modl, char string[], char pname[], int *ipmtr, int *irow, int *icol);
static int printAttrs(ego ebody);
static int printPmtrs(modl_T *modl, FILE *fp);
static int rank(double mat[], int nrow, int ncol);
static int rbfWeights(int nbnd, double srad2, CDOUBLE uv[], double duv[], double weights[]);
static int rbtCompareKeys(int ikey1, int jkey1, int ikey2, int jkey2, int ikey3, int jkey3, int ikey4, int jkey4);
static int rbtCreate(int chunk, rbt_T **tree);
static int rbtDelete(rbt_T *tree);
static int rbtInsert(rbt_T *tree, int key1, int key2, int key3, int key4, int data);            /* (in)  associated data */
static int rbtLookup(rbt_T *tree, int inode);
//$$$static int rbtMaximum(rbt_T *tree, int istart);
//$$$static int rbtMinimum(rbt_T *tree, int istart);
//$$$static int rbtNext(rbt_T *tree, int istart);
//$$$static int rbtPrev(rbt_T *tree, int istart);
static void rbtRotateLeft(rbt_T *tree, int inode);
static void rbtRotateRite(rbt_T *tree, int inode);
static int rbtSearch(rbt_T *tree, int key1, int key2, int key3, int key4);
static int recycleBody(modl_T *modl, int ibrch, int brtype, varg_T args[], int hasdots);
static int removeFaceAttributes(ego ebody);
static int removePerturbation(modl_T *modl);
       int removeVels(modl_T *modl,  int ibody);
static int reorderLoops(modl_T *modl, int nloop, ego eloops[], int startFrom);
static int selectBody(ego emodel, char *order, int index);
static int setEgoAttribute(modl_T *modl, int ibrch, ego eobject);
static int setFaceAttribute(modl_T *modl, int ibody, int iface, int jbody, int jford, int npatn, patn_T *patn);
static int setupAtPmtrs(modl_T *modl, int havesel);
static void signalError(void *modl, int status, char format[], ...);
static int solidBoolean(modl_T *modl, ego ebodyl, ego ebodyr, int type, double maxtol, ego *emodel);
static int solveSketch(modl_T *modl, sket_T *sket);
static int solveSketchLM(modl_T *modl, sket_T *sket);
static int solveSketchOrig(modl_T *modl, sket_T *sket);
static int splineVelocityOfEdge(void* usrData, /*@unused@*/const ego secs[], int isec, ego eedge, CINT npnt, CDOUBLE ts[], CDOUBLE ts_dot[], double xyz[], double xyz_dot[], double dxdt_beg[], double dxdt_beg_dot[], double dxdt_end[], double dxdt_end_dot[]);
static int splineVelocityOfNode(void* usrData, /*@unused@*/const ego secs[], int isec, ego enode, ego eedge, double xyz[], double xyz_dot[]);
static int storeCsystem(modl_T *modl, int ibody);
static int str2rpn(char str[], rpn_T *rpn);
static int str2val(char expr[], modl_T *modl, double *val, double *dot, char str[]);
static int str2vals(char expr[], modl_T *modl, int *nrow, int *ncol, double *vals[], double *dots[], char str[]);
static int solsvd(double A[], double b[], int mrow, int ncol, double W[], double x[]);
static int tessellate(modl_T *modl, int ibody);
       int velocityOfEdge(modl_T *modl, int ibody, int iedge, int npnt, /*@null@*/double t[], double dxyz[]);
       int velocityOfFace(modl_T *modl, int ibody, int iface, int npnt, /*@null@*/double uv[], double dxyz[]);
       int velocityOfNode(modl_T *modl, int ibody, int inode, double dxyz[]);
static double wendland(CDOUBLE uv1[], CDOUBLE uv2[], double srad2);
static int writeAsciiStl(modl_T *modl, int nstack, int stack[], char filename[]);
static int writeAsciiUgrid(modl_T *modl, int ibody, char filename[]);
static int writeBinaryStl(modl_T *modl, int nstack, int stack[], char filename[]);
static int xformFaceToOriginal(modl_T *modl, int ibody, int iface, double mat[], double *scale);
static int xformFaceVelocity(modl_T *modl, int ibody, int iface, int nxyz, double xyz_pnt[], int ndxyz, double dxyz[]);
static int xformToOriginal(modl_T *modl, int ibody, int jbody, double mat[]);
static int xformVelocity(modl_T *modl, int jbody, int nxyz, double xyz_pnt[], int ndxyz, double dxyz[]);

#ifdef GRAFIC
static void plotFace(int*, void*, void*, void*, void*, void*,
                           void*, void*, void*, void*, void*, float*, char*, int);
#endif

#ifdef BACKTRACE
static void printBacktrace();
#endif

/* non-prototyped EGADS routines */
extern int EG_getEdgeUVeval(ego eface, ego eedge, int sense, double t, double *uv);
extern int EG_sensitTopo(int iface, double r[], double dxyz[]);
extern int EG_setUserPointer(ego context, void *ptr);
extern int EG_spline1dTan(int imaxx, const double *t1, const double *xyz, const double *tn, const double *kn, double tol, int *ivec, double **rdata);

/*
 ************************************************************************
 *                                                                      *
 * Global variables and defines                                         *
 *                                                                      *
 ************************************************************************
 */

static int outLevel  = 1;     /* global since it needs to be settable
                                 before a MODL is created */

/* method for interpolating (dU,dV) into interior of Faces:
   =0 use eggMorph (if egg is enabled)
   =1 to use MVC
   =2 to use VR-MVC */
//#define INTERP_VEL 2

/* method for mapping perturbed grid in interior of Faces:
   =0 use EG_mapTessBody
   =1 use EGG_morph if exists */
//#define MORPH_GRID 1

/*
 ************************************************************************
 *                                                                      *
 * Process for computing sensitivities                                  *
 *                                                                      *
 ************************************************************************

   ocsmLoad, ocsmCopy
      dtime   = 0
      perturb = NULL

   ocsmFree, ocsmNewBrch, ocsmSetBrch, ocsmDelBrch, ocsmSetArg, ocsmSetValu, ocsmSetValuD, ocsmSetVel, ocsmSetVelD
      removePerturbation
      removeVels

   ocsmSetDtime
      dtime = input
      removePerturbation
      removeVels
      if (dtime != 0)
         createPerturbation

   ocsmGetVel
      tessellate
      checkForFiniteDifferences
      if (dtime == -2)
         vel = 0
         return
      if (NODE)
         vel = velocityOfNode
      elseif (EDGE)
         temp = velocityOfEdge
         vel = normal component of temp
      elseif (FACE)
         vel = velocityOfFace

   ocsmGetTessVel
      checkForFiniteDifferences
      createTessVels
      if (NODE)
         vel = node.dxyz
      elseif (EDGE)
         vel = edge.dxyz
      elseif (FACE)
         vel = face.dxyz

   ===================================

   checkForFiniteDifferences
      if (FORCE_FINITE_DIFFS)
         dtime = DTIME_NOM
      if (perturb == NULL && dtime == 0 && ibody has a Branch that does not have analytic sensitivities)
         dtime = DTIME_NOM
      if (perturb == NULL && dtime > 0)
         createPerturbation

   createPerturbation
      if (dtime == -2)
         return
      if (perturb != NULL)
         mapTessBody(base -> perturb)
         return
      try increasingly smaller dtime
         copy(base -> perturb)
         ocsmBuild(perturb)
         if (base and perturb match topologically)
            return
         elseif (ran out of tries)
            dtime = -2
            return
         else
            dtime /= -2

   createTessVels
      tessellate
      initialize node.dxyz, edge.dt, edge.dxyz, face.duv. face.dxyz
      if (perturb != NULL)
         dxyz.node = (perturb - base) / dtime
         dyxz.edge = (perturb - base) / dtime
         dxyz.face = (perturb - base) / dtime
         return
      face.dxyz = velocityOfFace
      edge.dxyz = combination of face.dxyz
      node.dxyz = combination of edge.dxyz
      update boundary edge.dt because of trimming changes
      update boundary face.duv because of trimming changes
      if (EGG)
         update interior face.duv by morphing
      else
         update interior face.duv by MVC
         update face.dxyz from face.duv

   finiteDifferences
      if (dtime == -2)
         vel = 0
      elseif (FACE or EDGE or NODE)
         vel = (perturb - base) / dtime

   removePerturbation
      free(perturb)
      dtime   = 0
      perturb = NULL

   removeVels
      free(node.dxyz)
      free(edge.dt)
      free(edge.dxyz)
      free(face.duv)
      free(face.dxyz)

   velocityOfFace(ibody, iface)
      if (perturb != NULL)
         vel = finiteDifferences
         return
      find Body and Face in which Face first exists (jbody,jface)
      find transformation matrix from (ibody,iface) to (jbody,jface)
      if (jbody.hasdots == 0)
         vel = 0
      elseif (BOX, SPHERE, CONE, CYLINDER, or UDPRIM)
         ...
      elseif (EXTRUDE)
         if (side)
            vel = velocityOfEdge
         elseif (beg or end)
            find transformation between EXTRUDE and SKETCH
            vel = 0
            apply transformation back to EXTRUDE
      elseif (RULE)
         ...
      else
         vel = finiteDifferences
         return
      transform velocity back to ibody

   velocityOfEdge(ibody, iedge)
      if (DEGENERATE)
         vel = 0
         return
      if (perturb != NULL)
         vel = finiteDifferences
         return
      find Body and Edge in which Edge first exists (jbody,jedge)
      if (jedge was generated by BOOLEAN or GROWN)
         vleft = velocityOfFace(ileft)
         vrite = velocityOfFace(irite)
         vel = combination of vleft and vrite
         return
      find transformation matrix from (ibody,iedge) to (jbody,jedge)
      if (jbody.hasdots == 0)
         vel = 0
      elseif (BOX, SPHERE, CONE, CYLINDER, or UDPRIM)
         ...
      else
         vel = finiteDifferences
         return
      transform velocity back to ibody

   velocityOfNode(ibody, inode)
      if (perturb != NULL)
         vel = finiteDifferences
         return
      find Body and Node in which Node first exists (jbody, jnode)
      if (jnode was generate by BOOLEAN, GROWN, or UDPRIM)
         v1 = velocityOfEdge(edge1)
         ..
         vel = combination of v1, v2, ...
         return
      find transformation matrix from (ibody,inode) to (jbody,jnode)
      if (jbody.hasdits == 0)
         vel = 0
      elseif (BOX, SPHERE, CONE, or CYLINDER)
         ...
      else
         vel = finiteDifferences
         return
      transform velocity back to ibody
 */


/*
 ************************************************************************
 *                                                                      *
 *   ocsmVersion - return current version                               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmVersion(int    *imajor,             /* (out) major version number */
            int    *iminor)             /* (out) minor version number */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(ocsmVersion);

    /* --------------------------------------------------------------- */

    *imajor = OCSM_MAJOR_VERSION;
    *iminor = OCSM_MINOR_VERSION;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetOutLevel - set output level                                 *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetOutLevel(int    ilevel)      /* (in)  output level: */
                                    /*       =0 errors only */
                                    /*       =1 nominal (default) */
                                    /*       =2 debug */
{
    int       old_outLevel = 0;     /* (out) previous outLevel */

    ROUTINE(ocsmSetOutLevel);

    /* --------------------------------------------------------------- */

    /* note that this does not change EGADS' outLevel (since we do not
       have access to the EGADS context -- in fact it might not be
       created yet) */

    old_outLevel = outLevel;       /* global variable */
    outLevel     = ilevel;

//cleanup:
    return old_outLevel;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmLoad - create a MODL by reading a .csm file                    *
 *                                                                      *
 ************************************************************************
 */

int
ocsmLoad(char   filename[],             /* (in)  file to be read (with .csm) */
         void   **modl)                 /* (out) pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL=NULL;

    /* Sketch contains linsegs, cirarcs, splines, and beziers */
    int       nskpt;

    /* number of open patterns */
    int       npatn = 0;

    int       filelen, filetype, linenum[11], numudc;
    int       i, j, k, inquote, narg, irow, icol, indx, count, imatch, itoken;
    int       ibrch, ipmtr, jpmtr, icount, jcount, insolver, itmp;
    double    rows, cols, despmtr, value, dot, bound;
    char      *templine=NULL, *nextline=NULL, *command=NULL, *esp_root, *str=NULL;
    char      *str1=NULL, *str2=NULL, *str3=NULL;
    char      *str4=NULL, *str5=NULL, *str6=NULL;
    char      *str7=NULL, *str8=NULL, *str9=NULL;
    char      defn[MAX_EXPR_LEN], tmpfilename[MAX_EXPR_LEN], pathname[MAX_EXPR_LEN];
    char      pmtrName[MAX_EXPR_LEN], token[MAX_EXPR_LEN];
    char      filenames[11][MAX_FILENAME_LEN];
    void      *temp;

    FILE      *csm_file[11];

    ROUTINE(ocsmLoad);

    /* --------------------------------------------------------------- */

    SPRINT1(1, "--> enter ocsmLoad(filename=%s)", filename);

    csm_file[ 0] = NULL;

    #ifdef FORCE_FINITE_DIFFS
        SPRINT0(0, "WARNING:: ***************************************");
        SPRINT0(0, "WARNING:: all sensitivities by finite differences");
        SPRINT0(0, "WARNING:: ***************************************");
    #endif

    if (INTERP_VEL != 2) {
        SPRINT1(0, "INTERP_VEL = %d", INTERP_VEL);
    }
    if (MORPH_GRID != 1) {
        SPRINT1(0, "MORPH_GRID = %d", MORPH_GRID);
    }

    MALLOC(templine, char, MAX_LINE_LEN);
    MALLOC(nextline, char, MAX_LINE_LEN);
    MALLOC(command,  char, MAX_LINE_LEN);

    MALLOC(str,  char, MAX_STRVAL_LEN);

    MALLOC(str1, char, MAX_LINE_LEN);
    MALLOC(str2, char, MAX_LINE_LEN);
    MALLOC(str3, char, MAX_LINE_LEN);
    MALLOC(str4, char, MAX_LINE_LEN);
    MALLOC(str5, char, MAX_LINE_LEN);
    MALLOC(str6, char, MAX_LINE_LEN);
    MALLOC(str7, char, MAX_LINE_LEN);
    MALLOC(str8, char, MAX_LINE_LEN);
    MALLOC(str9, char, MAX_LINE_LEN);

    for (i = 0; i < 11; i++) {
        filenames[i][0] = '\0';
    }

    /* initializtions are only done if not a .vfy file */
    if (strstr(filename, ".vfy") == NULL) {

        /* make a new MODL and initialize it */
        MALLOC(MODL, modl_T, 1);

        MODL->magic      = OCSM_MAGIC;
        MODL->checked    = 0;
        MODL->ibrch      = 0;
        MODL->nextseq    = 1;
        MODL->ngroup     = 0;
        MODL->recycle    = 0;
        MODL->verify     = 0;
        MODL->cleanup    = 1;
        MODL->dumpEgads  = 0;
        MODL->loadEgads  = 0;
        MODL->printStack = 0;
        MODL->tessAtEnd  = 1;
        MODL->bodyLoaded = 0;
        MODL->hasC0blend = 0;

        MODL->seltype = -1;
        MODL->selbody = -1;
        MODL->selsize =  0;
        MODL->sellist = NULL;

        MODL->level = 0;

        for (i = 0; i < 11; i++) {
            MODL->scope[i] = 0;
        }

        STRNCPY(filenames[0], filename, MAX_FILENAME_LEN);
        for (i = 1; i < 11; i++) {
            filenames[i][0] = '\0';
        }

        MODL->filelist = NULL;
        MALLOC(MODL->filelist, char, STRLEN(filename)+2);
        strcpy(MODL->filelist, filename);
        strcat(MODL->filelist, "|");

        MODL->nattr = 0;
        MODL->attr  = NULL;

        MODL->nstor = 0;
        MODL->stor  = NULL;

        MODL->nbrch = 0;
        MODL->mbrch = 0;
        MODL->brch  = NULL;

        MODL->npmtr = 0;
        MODL->mpmtr = 0;
        MODL->pmtr  = NULL;

        MODL->nbody = 0;
        MODL->mbody = 0;
        MODL->body  = NULL;

        MODL->perturb  = NULL;
        MODL->basemodl = NULL;
        MODL->dtime    = 0;

        MODL->context     = NULL;
        MODL->eggname[0]  = '\0';
        MODL->eggGenerate = NULL;
        MODL->eggMorph    = NULL;
        MODL->eggInfo     = NULL;
        MODL->eggDump     = NULL;
        MODL->eggLoad     = NULL;
        MODL->eggFree     = NULL;

        MODL->nwarn   = 0;
        MODL->sigCode = 0;
        MODL->sigMesg = NULL;
        MALLOC(MODL->sigMesg, char, MAX_STR_LEN);
        MODL->sigMesg[0] = '\0';

        for (i = 0; i < 100; i++) {
            MODL->profile[i].ncall = 0;
            MODL->profile[i].time  = 0;
        }
    } else {
        MODL = *modl;

        /* ensure that we are not reading a .vfy file without
           having already read a .csm or .cpc file */
        assert (MODL           != NULL);
        assert (MODL->filelist != NULL);

        MODL->level = 0;
    }

    /* return value */
    *modl = MODL;

    if (STRLEN(filename) == 0) {
        goto cleanup;
    }

    if (STRLEN(filename) > MAX_FILENAME_LEN) {
        signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                    "filename has more than %d characters", MAX_FILENAME_LEN);
        goto cleanup;
    }

    /* check for valid extension */
    filelen = STRLEN(filename);
    if (filelen == 0) {
        SPRINT0(1, "WARNING:: loading empty MODL");
        (MODL->nwarn)++;
        filetype = -1;
    } else if (filelen < 5) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'c' &&
               filename[filelen-2] == 's' && filename[filelen-1] == 'm'   ) {
        SPRINT0(2, "    reading .csm file");
        filetype = 0;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'c' &&
               filename[filelen-2] == 'p' && filename[filelen-1] == 'c'   ) {
        SPRINT0(2, "    reading .cpc file");
        filetype = 1;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'v' &&
               filename[filelen-2] == 'f' && filename[filelen-1] == 'y'   ) {
        SPRINT0(2, "    reading .vfy file");
        filetype = 0;
    } else {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* clean up tmp files (but not for .vfy file) */
    if (strstr(filename, ".vfy") == NULL) {
        for (itmp = 0; itmp < 999; itmp++) {
            if (sprintf(tmpfilename, "tmp_OpenCSM_%03d", itmp) < 0) {
                break;
            }

            if (remove(tmpfilename) == 0) {
                SPRINT1(1, "--> tmp file \"%s\" removed", tmpfilename);
            }
        }
    }

    /* open the .csm file */
    if (STRLEN(filename) > 0) {
        csm_file[MODL->level] = fopen(filename, "r");
        if (csm_file[MODL->level] == NULL) {
            if (strstr(filename, ".vfy") != NULL) {
                SPRINT1(0, "WARNING:: cannot open \"%s\", so verification is being skipped", filename);
                (MODL->nwarn)++;
                status = SUCCESS;
            } else {
                signalError(MODL, OCSM_FILE_NOT_FOUND,
                            "file \"%s\" not found", filename);
                goto cleanup;
            }
            goto cleanup;
        }
        linenum[ MODL->level] = 0;
    }

    /* initialize the number of active Sketch points, patterns, and active UDCs */
    nskpt  = 0;
    npatn  = 0;
    numudc = 0;

    insolver = 0;

    /* read commands from .csm file until the end of file */
    /*   note that we should not use feof here since we will
         prematurely exit loop if last line does not end with CR/LF */
    while (1) {
        /* read the next line */
        temp = fgets(templine, MAX_LINE_LEN, csm_file[MODL->level]);
        linenum[MODL->level]++;

        MODL->ibrch = MODL->nbrch;

        /* we have found the end of the current file (without an end statement) */
        if (temp == NULL) {

            /* if at the top level, we are done */
            if (MODL->level == 0) {

                /* do NOT create a new Branch since having one here would
                   mean that any Branches added at the end would not get executed */
                break;

            /* otherwise, close file and revert to previous level */
            } else {
                fclose(csm_file[MODL->level]);

                /* create a new Branch and decrement the level */
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_END, filenames[MODL->level], linenum[MODL->level],
                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                CHECK_STATUS(ocsmNewBrch);

                (MODL->level)--;

                SPRINT1(1, "\n<<< Reverting to file \"%s\"\n", filenames[MODL->level]);
                continue;
            }
        }

        /* ignore spaces at the beginning of the line */
        for (j = 0; j < STRLEN(templine); j++) {
            if (templine[0] == ' ') {
                for (k = 0; k < STRLEN(templine); k++) {
                    templine[k] = templine[k+1];
                }
            }
        }

        /* process the next line:
           - ignore anything after a #
           - ignore anything after a \ and concatenate next line
           - remove any spaces between double quotes (") so that a user
             could include spaces within an expression as long as
             it is surrounded by double quotes */
        if (templine[0] != '#') {
            inquote = 0;
            j       = 0;
            for (i = 0; i < STRLEN(templine); i++) {
                if (templine[i] == '#') {
                    nextline[j++] = '\0';
                    break;
                } else if (templine[i] == '\\') {
                    linenum[MODL->level]++;
                    if (fgets(templine, MAX_LINE_LEN, csm_file[MODL->level]) == NULL) break;
                    i = -1;
                } else if (templine[i] == '"') {
                    inquote = 1 - inquote;
                } else if (templine[i] == ' '  || templine[i] == '\t' ||
                           templine[i] == '\r' || templine[i] == '\n'   ) {
                    if (inquote == 0 && j > 0) {
                        nextline[j++] = templine[i];
                    }
                } else {
                    nextline[j++] = templine[i];
                }

                if (j >= MAX_LINE_LEN-2) {
                    signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                                "input line is too long");
                    goto cleanup;
                }
            }
        } else {
            STRNCPY(nextline, templine, MAX_LINE_LEN);
            j = STRLEN(nextline);
        }
        nextline[j++] = '\0';

        /* strip white spaces from end of nextline */
        for (i = j-2; i >= 0; i--) {
            if (nextline[i] == ' '  || nextline[i] == '\t' ||
                nextline[i] == '\r' || nextline[i] == '\n'   ) {
                nextline[i] = '\0';
            } else {
                break;
            }
        }
        SPRINT4(1, "    nextline (%2d:%4d)[%4d]: %s", MODL->level, linenum[MODL->level], MODL->nbrch+1, nextline);
        if (STRLEN(nextline) <= 1) continue;

        /* get the command from the next input line */
        sscanf(nextline, "%2047s", command);

        /* input is: "# comment" */
        if (strncmp(command, "#", 1) == 0) {
            /* nothing to do */

        /* input is: "applycsys $csysName ibody=0" */
        } else if (strcmp(command, "applycsys") == 0 ||
                   strcmp(command, "APPLYCSYS") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "APPLYCSYS cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "APPLYCSYS cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "APPLYCSYS requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_APPLYCSYS, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "assert arg1 arg2 toler=0 verify=0" */
        } else if (strcmp(command, "assert") == 0 ||
                   strcmp(command, "ASSERT") == 0   ) {

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg < 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "ASSERT requires at least 2 arguments");
                goto cleanup;
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }
            if (narg < 4) {
                strcpy(str4, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_ASSERT, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "arc xend yend zend dist $plane=xy" */
        } else if (strcmp(command, "arc") == 0 ||
                   strcmp(command, "ARC") == 0   ) {
            if (nskpt == 0) {
                signalError(MODL, OCSM_SKETCH_IS_NOT_OPEN,
                            "ARC must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "ARC cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str5, "$");
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2046s\n",
                          str1, str2, str3, str4, &(str5[1]));
            if (narg == 4) {
                STRNCPY(str5, "$xy", MAX_EXPR_LEN);
            } else if (narg == 5) {
                if        (strcmp(str5, "$xy") == 0 || strcmp(str5, "$XY") == 0) {
                    STRNCPY(str5, "$xy", MAX_EXPR_LEN);
                } else if (strcmp(str5, "$yz") == 0 || strcmp(str5, "$YZ") == 0) {
                    STRNCPY(str5, "$yz", MAX_EXPR_LEN);
                } else if (strcmp(str5, "$zx") == 0 || strcmp(str5, "$ZX") == 0) {
                    STRNCPY(str5, "$zx", MAX_EXPR_LEN);
                } else {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "PLANE must be XY, YZ, or ZX");
                    goto cleanup;
                }
            } else {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "ARC requires at least 4 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_ARC, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++; nskpt++;

        /* input is: "attribute $attrName attrList */
        } else if (strcmp(command, "attribute") == 0 ||
                   strcmp(command, "ATTRIBUTE") == 0   ) {

            /* previous Branch will be attributed */
            ibrch = MODL->nbrch;

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "ATTRIBUTE requires 2 arguments");
                goto cleanup;
            }

            /* set the Branch's Attribute */
            if        (ibrch == 0) {
                status = ocsmSetAttr(MODL, ibrch, str1, str2);
                CHECK_STATUS(ocsmSetAttr);
            } else if (MODL->ngroup == 0                 &&
                       MODL->brch[ibrch].type == OCSM_SET  ) {
                status = ocsmSetAttr(MODL, ibrch, str1, str2);
                CHECK_STATUS(ocsmSetAttr);
            } else if (MODL->brch[ibrch].type == OCSM_ASSERT    ||
                       MODL->brch[ibrch].type == OCSM_CATBEG    ||
                       MODL->brch[ibrch].type == OCSM_CATEND    ||
//                     MODL->brch[ibrch].type == OCSM_CFGPMTR   ||
//                     MODL->brch[ibrch].type == OCSM_CONPMTR   ||
//                     MODL->brch[ibrch].type == OCSM_DESPMTR   ||
//                     MODL->brch[ibrch].type == OCSM_OUTPMTR   ||
                       MODL->brch[ibrch].type == OCSM_DIMENSION ||
                       MODL->brch[ibrch].type == OCSM_ELSE      ||
                       MODL->brch[ibrch].type == OCSM_ELSEIF    ||
                       MODL->brch[ibrch].type == OCSM_END       ||
                       MODL->brch[ibrch].type == OCSM_ENDIF     ||
                       MODL->brch[ibrch].type == OCSM_IFTHEN    ||
                       MODL->brch[ibrch].type == OCSM_INTERFACE ||
//                     MODL->brch[ibrch].type == OCSM_LBOUND    ||
                       MODL->brch[ibrch].type == OCSM_MACBEG    ||
                       MODL->brch[ibrch].type == OCSM_MACEND    ||
                       MODL->brch[ibrch].type == OCSM_MARK      ||
                       MODL->brch[ibrch].type == OCSM_PATBEG    ||
                       MODL->brch[ibrch].type == OCSM_PATBREAK  ||
                       MODL->brch[ibrch].type == OCSM_PATEND    ||
                       MODL->brch[ibrch].type == OCSM_PROJECT   ||
//                     MODL->brch[ibrch].type == OCSM_SELECT    ||
                       MODL->brch[ibrch].type == OCSM_SET       ||
                       MODL->brch[ibrch].type == OCSM_EVALUATE  ||
                       MODL->brch[ibrch].type == OCSM_GETATTR   ||
                       MODL->brch[ibrch].type == OCSM_SKBEG     ||
                       MODL->brch[ibrch].type == OCSM_SKCON     ||
                       MODL->brch[ibrch].type == OCSM_SKVAR     ||
                       MODL->brch[ibrch].type == OCSM_SOLBEG    ||
                       MODL->brch[ibrch].type == OCSM_SOLEND    ||
                       MODL->brch[ibrch].type == OCSM_STORE     ||
                       MODL->brch[ibrch].type == OCSM_SPECIAL   ||
                       MODL->brch[ibrch].type == OCSM_THROW     ||
//                     MODL->brch[ibrch].type == OCSM_UBOUND    ||
                       MODL->brch[ibrch].type == OCSM_UDPARG      ) {
                signalError(MODL, OCSM_ILLEGAL_ATTRIBUTE,
                            "a \"%s\" Branch cannot be attributed", ocsmGetText(MODL->brch[ibrch].type));
                goto cleanup;
            } else {
                status = ocsmSetAttr(MODL, ibrch, str1, str2);
                CHECK_STATUS(ocsmSetAttr);
            }

        /* input is: "bezier x y z" */
        } else if (strcmp(command, "bezier") == 0 ||
                   strcmp(command, "BEZIER") == 0   ) {
            if (nskpt == 0) {
                signalError(MODL, OCSM_SKETCH_IS_NOT_OPEN,
                            "BEZIER must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "BEZIER cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "BEZIRE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_BEZIER, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "blend begList=0 endList=0 reorder=0 oneFace=0" */
        } else if (strcmp(command, "blend") == 0 ||
                   strcmp(command, "BLEND") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "BLEND cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "BLEND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if   (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }
            if (narg < 4) {
                STRNCPY(str4, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_BLEND, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "box xbase ybase zbase dx dy dz" */
        } else if (strcmp(command, "box") == 0 ||
                   strcmp(command, "BOX") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "BOX cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "BOX cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6);
            if (narg != 6) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "BOX requires 6 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_BOX, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "catbeg sigCode" */
        } else if (strcmp(command, "catbeg") == 0 ||
                   strcmp(command, "CATBEG") == 0   ) {

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CATBEG requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_CATBEG, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "catend" */
        } else if (strcmp(command, "catend") == 0 ||
                   strcmp(command, "CATEND") == 0   ) {

            /* find the matching catbeg */
            i = 1;
            for (ibrch = MODL->nbrch; ibrch > 0; ibrch--) {
                if        (MODL->brch[ibrch].type == OCSM_CATEND) {
                    i++;
                } else if (MODL->brch[ibrch].type == OCSM_CATBEG) {
                    i--;
                    if (i == 0) {
                        break;
                    }
                }
            }
            if (ibrch <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "CATEND must follow a CATBEG");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_CATEND, filenames[MODL->level], linenum[MODL->level],
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            npatn--;

        /* input is: "cfgpmtr $pmtrName value" */
        } else if (strcmp(command, "cfgpmtr") == 0 ||
                   strcmp(command, "CFGPMTR") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "CFGPMTR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "CFGPMTR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "CFGPMTR not allowed in function-type .udc file");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CFGPMTR requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* do not allow pmtrName to contain a subscript */
            if (strstr(str1, "[") != NULL) {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot contain a subscript");
                goto cleanup;
            }

            /* make sure value is a valid number */
            if (sscanf(str2, "%lf", &value) == 0) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "values must be a number");
                goto cleanup;
            }

            /* if it does not exist, create it now */
            status = ocsmFindPmtr(MODL, str1, OCSM_CONFIG, 1, 1, &ipmtr);
            if (status == OCSM_NAME_ALREADY_DEFINED) {
                if (MODL->pmtr[ipmtr].type == OCSM_INTERNAL) {
                    signalError(MODL, OCSM_PMTR_IS_INTERNAL,
                                "%s is an internal parameter", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPUT) {
                    signalError(MODL, OCSM_PMTR_IS_OUTPUT,
                                "%s is an OUTPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_CONSTANT) {
                    signalError(MODL, OCSM_PMTR_IS_CONSTANT,
                                "%s is a CONPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL) {
                    signalError(MODL, OCSM_PMTR_IS_CONSTANT,
                                "%s is a DESPMTR", str1);
                    goto cleanup;
                }
            }
            CHECK_STATUS(ocsmFindPmtr);

            status = ocsmSetValuD(MODL, ipmtr, 1, 1, value);
            CHECK_STATUS(ocsmSetValu);

        /* input is: "chamfer radius edgeList=0 listStyle=0" */
        } else if (strcmp(command, "chamfer") == 0 ||
                   strcmp(command, "CHAMFER") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "CHAMFER cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "CHAMFER cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if        (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CHAMFER requires at least 1 argument");
                goto cleanup;
            } else if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_CHAMFER, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "cirarc xon yon zon xend yend zend" */
        } else if (strcmp(command, "cirarc") == 0 ||
                   strcmp(command, "CIRARC") == 0   ) {
            if (nskpt == 0) {
                signalError(MODL, OCSM_SKETCH_IS_NOT_OPEN,
                            "CIRARC msut be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "CIRARC cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6);

            if (narg != 6) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CIRARC requires 6 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_CIRARC, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++; nskpt++;

        /* input is: "combine toler=0" */
        } else if (strcmp(command, "combine") == 0 ||
                   strcmp(command, "COMBINE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "COMBINE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "COMBINE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_COMBINE, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "cone xvrtx yvrtx zvrtx xbase ybase zbase radius" */
        } else if (strcmp(command, "cone") == 0 ||
                   strcmp(command, "CONE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "CONE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "CONE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7);
            if (narg != 7) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CONE requires 7 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_CONE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "connect faceList1 faceList2 edgeList1=0 edgeList2=0" */
        } else if (strcmp(command, "connect") == 0 ||
                   strcmp(command, "CONNECT") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "CONNECT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "CONNECT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg < 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CONNECT requires 2 arguments");
                goto cleanup;
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }
            if (narg < 4) {
                strcpy(str4, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_CONNECT, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "conpmtr $pmtrName expression" */
        } else if (strcmp(command, "conpmtr") == 0 ||
                   strcmp(command, "CONPMTR") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "CONPMTR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "CONPMTR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->level > 0) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "CONPMTR not allowed in .udc file");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CONPMTR requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* check if pmtrName already exists, and if it does
               ensure that it is a CONSTANT parameter */
            ipmtr = -1;
            for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                if (strcmp(MODL->pmtr[jpmtr].name, &(str1[1])) == 0) {

                    if (MODL->pmtr[jpmtr].type == OCSM_CONSTANT) {
                        ipmtr = jpmtr;
                        break;
                    } else if (MODL->pmtr[jpmtr].type == OCSM_INTERNAL) {
                        signalError(MODL, OCSM_PMTR_IS_INTERNAL,
                                    "%s is an internal parameter", str1);
                        goto cleanup;
                    } else if (MODL->pmtr[jpmtr].type == OCSM_OUTPUT) {
                        signalError(MODL, OCSM_PMTR_IS_OUTPUT,
                                    "%s is a OUTPMTR", str1);
                        goto cleanup;
                    } else if (MODL->pmtr[jpmtr].type == OCSM_EXTERNAL ||
                               MODL->pmtr[jpmtr].type == OCSM_CONFIG     ) {
                        signalError(MODL, OCSM_PMTR_IS_EXTERNAL,
                                    "%s is a CFGPMTR or CFGPMTR", str1);
                        goto cleanup;
                    }
                }
            }

            /* create the Parameter (if it does not already exist) */
            if (ipmtr < 0) {
                status = ocsmNewPmtr(MODL, str1, OCSM_CONSTANT, 1, 1);
                CHECK_STATUS(ocsmNewPmtr);

                ipmtr = MODL->npmtr;
            }


            /* store the value */
            status = str2val(str2, NULL, &value, &dot, str);
            CHECK_STATUS(str2val);
            if (STRLEN(str) > 0) {
                signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                            "expression must evaluate to a number");
                goto cleanup;
            } else if (fabs(MODL->pmtr[ipmtr].value[0]+HUGEQ) < EPS06) {
                status = ocsmSetValu(MODL, ipmtr, 1, 1, str2);
                CHECK_STATUS(ocsmSetValu);
            } else if (fabs(MODL->pmtr[ipmtr].value[0]-value) < EPS06) {
                /* value already defined */
            } else {
                /* already defined with a different value */
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "%s is already defined with a different value", str1);
                goto cleanup;
            }

        /* input is: "csystem $csysName csysList */
        } else if (strcmp(command, "csystem") == 0 ||
                   strcmp(command, "CSYSTEM") == 0   ) {

            /* Csystem will aplied to previous Branch */
            ibrch = MODL->nbrch;

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CSYSTEM requires 2 arguments");
                goto cleanup;
            }

            /* set the Branch's csystem */
            if (MODL->brch[ibrch].type == OCSM_ASSERT    ||
                MODL->brch[ibrch].type == OCSM_CATBEG    ||
                MODL->brch[ibrch].type == OCSM_CATEND    ||
//              MODL->brch[ibrch].type == OCSM_CFGPMTR   ||
//              MODL->brch[ibrch].type == OCSM_CONPMTR   ||
//              MODL->brch[ibrch].type == OCSM_DESPMTR   ||
//              MODL->brch[ibrch].type == OCSM_OUTPMTR   ||
                MODL->brch[ibrch].type == OCSM_DIMENSION ||
                MODL->brch[ibrch].type == OCSM_ELSE      ||
                MODL->brch[ibrch].type == OCSM_ELSEIF    ||
                MODL->brch[ibrch].type == OCSM_END       ||
                MODL->brch[ibrch].type == OCSM_ENDIF     ||
                MODL->brch[ibrch].type == OCSM_IFTHEN    ||
                MODL->brch[ibrch].type == OCSM_INTERFACE ||
//              MODL->brch[ibrch].type == OCSM_LBOUND    ||
                MODL->brch[ibrch].type == OCSM_MACBEG    ||
                MODL->brch[ibrch].type == OCSM_MACEND    ||
                MODL->brch[ibrch].type == OCSM_MARK      ||
                MODL->brch[ibrch].type == OCSM_PATBEG    ||
                MODL->brch[ibrch].type == OCSM_PATBREAK  ||
                MODL->brch[ibrch].type == OCSM_PATEND    ||
                MODL->brch[ibrch].type == OCSM_PROJECT   ||
//              MODL->brch[ibrch].type == OCSM_SELECT    ||
                MODL->brch[ibrch].type == OCSM_SET       ||
                MODL->brch[ibrch].type == OCSM_EVALUATE  ||
                MODL->brch[ibrch].type == OCSM_GETATTR   ||
                MODL->brch[ibrch].type == OCSM_SKBEG     ||
                MODL->brch[ibrch].type == OCSM_SKCON     ||
                MODL->brch[ibrch].type == OCSM_SKVAR     ||
                MODL->brch[ibrch].type == OCSM_SOLBEG    ||
                MODL->brch[ibrch].type == OCSM_SOLEND    ||
                MODL->brch[ibrch].type == OCSM_STORE     ||
                MODL->brch[ibrch].type == OCSM_SPECIAL   ||
                MODL->brch[ibrch].type == OCSM_THROW     ||
//              MODL->brch[ibrdh].type == OCSM_UBOUND    ||
                MODL->brch[ibrch].type == OCSM_UDPARG      ) {
                signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                            "a \"%s\" Branch cannot get Csystem", ocsmGetText(MODL->brch[ibrch].type));
                goto cleanup;
            } else {
                status = ocsmSetCsys(MODL, ibrch, str1, str2);
                CHECK_STATUS(ocsmSetCsys);
            }

        /* input is: "cylinder xbeg ybeg zbeg xend yend zend radius" */
        } else if (strcmp(command, "cylinder") == 0 ||
                   strcmp(command, "CYLINDER") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "CYLINDER cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "CYLINDER cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7);
            if (narg != 7) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "CYLINDER requires 7 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_CYLINDER, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "despmtr $pmtrName values" */
        } else if (strcmp(command, "despmtr") == 0 ||
                   strcmp(command, "DESPMTR") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "DESPMTR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "DESPMTR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "DESPMTR not allowed in function-type .udc file");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "DESPMTR requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* make sure that values is a semicolon-separated list of numbers */
            icount = 0;
            while (icount < STRLEN(str2)) {
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] =str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                /* check for a valid number */
                if (sscanf(defn, "%lf", &value) == 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "values must only contain numbers");
                    goto cleanup;
                }
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS(parseName);

            /* if it does not exist, create it now */
            if (ipmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_EXTERNAL, 1, 1);
                CHECK_STATUS(ocsmNewPmtr);
                ipmtr = MODL->npmtr;

            /* make sure that Parameter is EXTERNAL */
            } else if (MODL->pmtr[ipmtr].type == OCSM_INTERNAL) {
                signalError(MODL, OCSM_PMTR_IS_INTERNAL,
                            "%s is an internal parameter", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPUT) {
                signalError(MODL, OCSM_PMTR_IS_OUTPUT,
                            "%s is an OUTPMTR", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_CONSTANT) {
                signalError(MODL, OCSM_PMTR_IS_CONSTANT,
                            "%s is a CONPMTR", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG) {
                signalError(MODL, OCSM_PMTR_IS_EXTERNAL,
                            "%s is a CFGPMTR", str1);
                goto cleanup;
            }

            /* store the values for the whole Parameter */
            if ((irow ==    0 && icol ==    0) ||
                (irow == -999 && icol == -999)   ) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        jcount = 0;

                        while (icount < STRLEN(str2)) {
                            if (str2[icount] == ';') {
                                icount++;
                                break;
                            } else {
                                defn[jcount  ] = str2[icount];
                                defn[jcount+1] = '\0';
                                icount++;
                                jcount++;
                            }
                        }

                        status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                        CHECK_STATUS(ocsmGetValu);

                        if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                            SPRINT0(1, "WARNING:: value not overwritten");
                            (MODL->nwarn)++;
                        } else {
                            if (strcmp(defn, "") != 0) {
                                status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                                CHECK_STATUS(ocsmSetValu);
                            }
                        }
                    }
                }

            /* store the values for all rows of the Parameter */
            } else if (irow == -999) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                    CHECK_STATUS(ocsmGetValu);

                    if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                        SPRINT0(1, "WARNING:: value not overwritten");
                        (MODL->nwarn)++;
                    } else {
                        if (strcmp(defn, "") != 0) {
                            status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                            CHECK_STATUS(ocsmSetValu);
                        }
                    }
                }

            /* store the values for all columns of the Parameter */
            } else if (icol == -999) {
                icount = 0;
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                    CHECK_STATUS(ocsmGetValu);

                    if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                        SPRINT0(1, "WARNING:: value not overwritten");
                        (MODL->nwarn)++;
                    } else {
                        if (strcmp(defn, "") != 0) {
                            status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                            CHECK_STATUS(ocsmSetValu);
                        }
                    }
                }

            /* store a single value into the Parameter */
            } else {
                if (irow <= 0) irow = 1;
                if (icol <= 0) icol = 1;

                icount = 0;
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] = str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                CHECK_STATUS(ocsmGetValu);

                if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                    SPRINT0(1, "WARNING:: value not overwritten");
                    (MODL->nwarn)++;
                } else {
                    if (strcmp(defn, "") != 0) {
                        status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                        CHECK_STATUS(ocsmSetValu);
                    }
                }
            }

        /* input is: "dimension $pmtrName nrow ncol despmtr=0" */
        } else if (strcmp(command, "dimension") == 0 ||
                   strcmp(command, "DIMENSION") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "DIMENSION cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "DIMENSION cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s %2047s\n",
                          &(str1[1]), str2, str3, str4);
            if (narg < 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "DIMENSION requires at least 3 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[1] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            if (narg == 4) {
                status = str2val(str4, MODL, &despmtr, &dot, str);
                CHECK_STATUS(str2val:despmtr);
                if (STRLEN(str) > 0) {
                    signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                "despmtr must evaluate to a number");
                    goto cleanup;
                }
            } else {
                despmtr = 0;
            }

            /* for an internal Parameter, create a Branch */
            if (NINT(despmtr) == 0) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_DIMENSION, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
                CHECK_STATUS(ocsmNewBrch);

            /* for an external Parameter, create the despmtr now (no Branch) */
            } else {
                if (MODL->level > 0) {
                    signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                                "DIMENSION not allowed in .udc file");
                    goto cleanup;
                }

                status = str2val(str2, MODL, &rows, &dot, str);
                CHECK_STATUS(str2val:rows);
                if (STRLEN(str) > 0) {
                    signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                "nrow must evaluate to a number");
                    goto cleanup;
                }

                status = str2val(str3, MODL, &cols, &dot, str);
                CHECK_STATUS(str2val:cols);
                if (STRLEN(str) > 0) {
                    signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                "ncol must evaluate to a number");
                    goto cleanup;
                }

                status = ocsmNewPmtr(MODL, &(str1[1]), OCSM_EXTERNAL, NINT(rows), NINT(cols));
                CHECK_STATUS(ocsmNewPmtr);
            }

        /* input is: "dump $filename remove=0 toMark=0" */
        } else if (strcmp(command, "dump") == 0 ||
                   strcmp(command, "DUMP") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "DUMP cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "DUMP cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "DUMP requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* convert filename if it starts with "$/" to relative pathname */
            if (strncmp(str1, "$$/", 3) == 0) {
                STRNCPY(pathname, filenames[MODL->level], MAX_EXPR_LEN);
                i = STRLEN(pathname) - 1;
                while (pathname[i] != SLASH) {
                    pathname[i] = '\0';
                    i--;
                    if (i < 0) break;
                }
                STRNCPY(tmpfilename, &(str1[3]), MAX_EXPR_LEN);
                snprintf(str1, MAX_EXPR_LEN, "$%s%s", pathname, tmpfilename);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_DUMP, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "else" */
        } else if (strcmp(command, "else") == 0 ||
                   strcmp(command, "ELSE") == 0   ) {

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_ELSE, filenames[MODL->level], linenum[MODL->level],
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "elseif val1 op1 val2 op2=and val3=0 op3=eq val4=0" */
        } else if (strcmp(command, "elseif") == 0 ||
                   strcmp(command, "ELSEIF") == 0   ) {

            /* extract arguments */
            strcpy(str2, "$");
            strcpy(str4, "$");
            strcpy(str6, "$");
            strcpy(str8, "$");
            narg = sscanf(nextline, "%*s %2047s %2046s %2047s %2046s %2047s %2046s %2047s\n",
                          str1, &(str2[1]), str3, &(str4[1]), str5, &(str6[1]), str7);
            if (narg < 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "ELSEIF requires at least 3 arguments");
                goto cleanup;
            }

            if (narg < 4) {
                strcpy(str4, "$and");
            }
            if (narg < 5) {
                strcpy(str5, "0");
            }
            if (narg < 6) {
                strcpy(str6, "$eq");
            }
            if (narg < 7) {
                strcpy(str7, "0");
            }

            if (strcmp(str2, "$lt") != 0 && strcmp(str2, "$LT") != 0 &&
                strcmp(str2, "$le") != 0 && strcmp(str2, "$LE") != 0 &&
                strcmp(str2, "$eq") != 0 && strcmp(str2, "$EQ") != 0 &&
                strcmp(str2, "$ge") != 0 && strcmp(str2, "$GE") != 0 &&
                strcmp(str2, "$gt") != 0 && strcmp(str2, "$GT") != 0 &&
                strcmp(str2, "$ne") != 0 && strcmp(str2, "$NE") != 0   ) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "op1 must be LT, LE, EQ, GE, GT, or NE");
                goto cleanup;
            }
            if (strcmp(str4, "$or" ) != 0 && strcmp(str4, "$OR" ) != 0 &&
                strcmp(str4, "$and") != 0 && strcmp(str4, "$AND") != 0 &&
                strcmp(str4, "$xor") != 0 && strcmp(str4, "$XOR") != 0   ) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "op2 must be OR, AND, or XOR");
                goto cleanup;
            }
            if (strcmp(str6, "$lt") != 0 && strcmp(str6, "$LT") != 0 &&
                strcmp(str6, "$le") != 0 && strcmp(str6, "$LE") != 0 &&
                strcmp(str6, "$eq") != 0 && strcmp(str6, "$EQ") != 0 &&
                strcmp(str6, "$ge") != 0 && strcmp(str6, "$GE") != 0 &&
                strcmp(str6, "$gt") != 0 && strcmp(str6, "$GT") != 0 &&
                strcmp(str6, "$ne") != 0 && strcmp(str6, "$NE") != 0   ) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "op3 must be LT, LE, EQ, GE, GT, or NE");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_ELSEIF, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "end" */
        } else if (strcmp(command, "end") == 0 ||
                   strcmp(command, "END") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "END cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "END cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* if at the top level, we are done */
            if ((filetype == 0 && MODL->level == 0)  ||
                (filetype == 1 && numudc      == 0)    ) {

                /* do NOT create a new Branch since having one here would
                   mean that any Branches added at the end would not get executed */
                break;

            /* if reading .cpc file, create a new Branch */
            } else if (filetype == 1) {

                /* create a new Branch and decrement the level */
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_END, filenames[MODL->level], linenum[MODL->level],
                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                CHECK_STATUS(ocsmNewBrch);

                numudc--;

            /* otherwise, close file and revert to previous level */
            } else {
                fclose(csm_file[MODL->level]);

                /* create a new Branch and decrement the level */
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_END, filenames[MODL->level], linenum[MODL->level],
                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                CHECK_STATUS(ocsmNewBrch);

                (MODL->level)--;

                SPRINT1(1, "\n<<< Reverting to file \"%s\"\n", filenames[MODL->level]);
                continue;
            }

        /* input is: "endif" */
        } else if (strcmp(command, "endif") == 0 ||
                   strcmp(command, "ENDIF") == 0   ) {

            /* find the matching ifthen */
            i = 1;
            for (ibrch = MODL->nbrch; ibrch > 0; ibrch--) {
                if        (MODL->brch[ibrch].type == OCSM_ENDIF ) {
                    i++;
                } else if (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                    i--;
                    if (i == 0) {
                        break;
                    }
                }
            }
            if (ibrch <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ENDIF must follow IFTHEN");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_ENDIF, filenames[MODL->level], linenum[MODL->level],
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            npatn--;

        /* input is: "evaluate $type ..." */
        } else if (strcmp(command, "evaluate") == 0 ||
                   strcmp(command, "EVALUATE") == 0   ) {

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s %2047s %2047s %2047s\n",
                          &(str1[1]), str2, str3, str4, str5, str6);

            /* $node ibody inode */
            if        (strcmp(str1, "$node") == 0 ||
                       strcmp(str1, "$NODE") == 0   ) {
                if (narg != 3) {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "EVALUATE NODE requires 3 arguments");
                    goto cleanup;
                }

            /* $edge ibody iedge t */
            } else if (strcmp(str1, "$edge") == 0 ||
                       strcmp(str1, "$EDGE") == 0   ) {
                if (narg != 4) {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "EVALUATE EDGE requires 4 arguments");
                    goto cleanup;
                }

            /* $edgerng ibody iedge */
            } else if (strcmp(str1, "$edgerng") == 0 ||
                       strcmp(str1, "$EDGERNG") == 0   ) {
                if (narg != 3) {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "EVALUATE EDGERNG requires 3 arguments");
                    goto cleanup;
                }

            /* $edgeinv ibody iedge x y z */
            } else if (strcmp(str1, "$edgeinv") == 0 ||
                       strcmp(str1, "$EDGEINV") == 0   ) {
                if (narg != 6) {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "EVALUATE EDGEINV requires 6 arguments");
                    goto cleanup;
                }

            /* $face ibody iface u v */
            } else if (strcmp(str1, "$face") == 0 ||
                       strcmp(str1, "$FACE") == 0   ) {
                if (narg != 5) {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "EVALUATE FACE requires 5 arguments");
                    goto cleanup;
                }

            /* $facerng ibody iface */
            } else if (strcmp(str1, "$facerng") == 0 ||
                       strcmp(str1, "$FACERNG") == 0   ) {
                if (narg != 3) {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "EVALUATE FACERNG requires 3 arguments");
                    goto cleanup;
                }

            /* $faceinv ibody iface x y z */
            } else if (strcmp(str1, "$faceinv") == 0 ||
                       strcmp(str1, "$FACEINV") == 0   ) {
                if (narg != 6) {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "EVALUATE FACEINV requires 6 arguments");
                    goto cleanup;
                }
            } else {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "type must be NODE, EDGE, EDGERNG, EDGEINV, FACE, FACERNG, or FACEINV");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_EVALUATE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "extract entList" */
        } else if (strcmp(command, "extract") == 0 ||
                   strcmp(command, "EXTRACT") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "EXTRACT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "EXTRACT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "EXTRACT requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_EXTRACT, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "extrude dx dy dz" */
        } else if (strcmp(command, "extrude") == 0 ||
                   strcmp(command, "EXTRUDE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "EXTRUDE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "EXTRUDE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "EXTRUDE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_EXTRUDE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "fillet radius edgeList=0 listStyle=0" */
        } else if (strcmp(command, "fillet") == 0 ||
                   strcmp(command, "FILLET") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "FILLET cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "FILLET cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if        (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "ASSERT requires at least 1 argument");
                goto cleanup;
            } else if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_FILLET, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "getattr $pmtrName attrID global=0" */
        } else if (strcmp(command, "getattr") == 0 ||
                   strcmp(command, "GETATTR") == 0   ) {

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "GETATTR requires at least 2 arguments");
                goto cleanup;
            }

            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[1] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_GETATTR, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "group nbody=0" */
        } else if (strcmp(command, "group") == 0 ||
                   strcmp(command, "GROUP") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "GROUP cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "GROUP cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_GROUP, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "hollow thick=0 entList=0 listStyle=0" */
        } else if (strcmp(command, "hollow") == 0 ||
                   strcmp(command, "HOLLOW") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "HOLLOW cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "HOLLOW cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if        (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
                STRNCPY(str2, "0", MAX_EXPR_LEN);
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_HOLLOW, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "ifthen val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0" */
        } else if (strcmp(command, "ifthen") == 0 ||
                   strcmp(command, "IFTHEN") == 0   ) {

            /* extract arguments */
            strcpy(str2, "$");
            strcpy(str4, "$");
            strcpy(str6, "$");
            strcpy(str8, "$");
            narg = sscanf(nextline, "%*s %2047s %2046s %2047s %2046s %2047s %2046s %2047s\n",
                          str1, &(str2[1]), str3, &(str4[1]), str5, &(str6[1]), str7);
            if (narg < 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "IFTHEN requires at least 3 arguments");
                goto cleanup;
            }

            if (narg < 4) {
                strcpy(str4, "$and");
            }
            if (narg < 5) {
                strcpy(str5, "0");
            }
            if (narg < 6) {
                strcpy(str6, "$eq");
            }
            if (narg < 7) {
                strcpy(str7, "0");
            }

            if (strcmp(str2, "$lt") != 0 && strcmp(str2, "$LT") != 0 &&
                strcmp(str2, "$le") != 0 && strcmp(str2, "$LE") != 0 &&
                strcmp(str2, "$eq") != 0 && strcmp(str2, "$EQ") != 0 &&
                strcmp(str2, "$ge") != 0 && strcmp(str2, "$GE") != 0 &&
                strcmp(str2, "$gt") != 0 && strcmp(str2, "$GT") != 0 &&
                strcmp(str2, "$ne") != 0 && strcmp(str2, "$NE") != 0   ) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "op1 must be LT, LE, EQ, GE, GT, or NE");
                goto cleanup;
            }
            if (strcmp(str4, "$or" ) != 0 && strcmp(str4, "$OR" ) != 0 &&
                strcmp(str4, "$and") != 0 && strcmp(str4, "$AND") != 0 &&
                strcmp(str4, "$xor") != 0 && strcmp(str4, "$XOR") != 0   ) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "op2 must be OR, AND, or XOR");
                goto cleanup;
            }
            if (strcmp(str6, "$lt") != 0 && strcmp(str6, "$LT") != 0 &&
                strcmp(str6, "$le") != 0 && strcmp(str6, "$LE") != 0 &&
                strcmp(str6, "$eq") != 0 && strcmp(str6, "$EQ") != 0 &&
                strcmp(str6, "$ge") != 0 && strcmp(str6, "$GE") != 0 &&
                strcmp(str6, "$gt") != 0 && strcmp(str6, "$GT") != 0 &&
                strcmp(str6, "$ne") != 0 && strcmp(str6, "$NE") != 0   ) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "op3 must be LT, LE, EQ, GE, GT, or NE");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_IFTHEN, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "import $filename bodynumber=1" */
        } else if (strcmp(command, "import") == 0 ||
                   strcmp(command, "IMPORT") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "IMPORT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "IMPORT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if        (narg == 1) {
                STRNCPY(str2, "1", MAX_EXPR_LEN);
            } else if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "IMPORT requires at least 1 argument");
                goto cleanup;
            }

            /* convert filename if it starts with "$/" or "$$/" to relative pathname */
            if (strncmp(str1, "$$/", 3) == 0) {
                STRNCPY(pathname, filenames[MODL->level], MAX_EXPR_LEN);
                i = STRLEN(pathname) - 1;
                while (pathname[i] != SLASH) {
                    pathname[i] = '\0';
                    i--;
                    if (i < 0) break;
                }
                STRNCPY(tmpfilename, &(str1[3]), MAX_EXPR_LEN);
                snprintf(str1, MAX_EXPR_LEN, "$%s%s", pathname, tmpfilename);
            } else if (strncmp(str1, "$$$/", 4) == 0) {
                STRNCPY(pathname, filenames[MODL->level], MAX_EXPR_LEN);
                i = STRLEN(pathname) - 1;
                while (pathname[i] != SLASH) {
                    pathname[i] = '\0';
                    i--;
                    if (i < 0) break;
                }
                STRNCPY(tmpfilename, &(str1[4]), MAX_EXPR_LEN);
                snprintf(str1, MAX_EXPR_LEN, "$%s%s", pathname, tmpfilename);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_IMPORT, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "interface $argName $argType default=0" */
        } else if (strcmp(command, "interface") == 0 ||
                   strcmp(command, "INTERFACE") == 0   ) {
            if (filetype == 0 && MODL->level <= 0) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "INTERFACE not allowed in .csm file");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");  strcpy(str2, "$");
            narg = sscanf(nextline, "%*s %2046s %2046s %2047s\n",
                          &(str1[1]), &(str2[1]), str3);
            if        (narg == 2) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "INTERFACE requires at least 2 arguments");
                goto cleanup;
            }

            /* ensure that valid argType is given */
            if ((strcmp(str2, "$in")  != 0) && (strcmp(str2, "$IN" ) != 0) &&
                (strcmp(str2, "$out") != 0) && (strcmp(str2, "$OUT") != 0) &&
                (strcmp(str2, "$dim") != 0) && (strcmp(str2, "$DIM") != 0) &&
                (strcmp(str2, "$all") != 0) && (strcmp(str2, "$ALL") != 0)   ) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "argType must be IN, OUT, DIM, or ALL");
                goto cleanup;
            }

            /* if an include-type UDC, reduce the scope back (note: it was
               increased by the UDPRIM statement) */
            if ((strcmp(str2, "$all") == 0) || (strcmp(str2, "$ALL") == 0)) {
                    MODL->scope[MODL->level] = MODL->scope[MODL->level-1];
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_INTERFACE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "intersect $order=none index=1 maxtol=0" */
        } else if (strcmp(command, "intersect") == 0 ||
                   strcmp(command, "INTERSECT") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "INTERSECT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "INTERSECT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 1) {
                STRNCPY(str1, "$none", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "1",     MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_INTERSECT, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "join toler=0 toMark=0" */
        } else if (strcmp(command, "join") == 0 ||
                   strcmp(command, "JOIN") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "JOIN cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "JOIN cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if        (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            } else if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_JOIN, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "lbound $pmtrName expression" */
        } else if (strcmp(command, "lbound") == 0 ||
                   strcmp(command, "LBOUND") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "LBOUND cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "LBOUND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "LBOUND not allowed in function-type .udc file");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "LBOUND requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* make sure that bounds is a semicolon-separated list of numbers */
            icount = 0;
            while (icount < STRLEN(str2)) {
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] =str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                /* check for a valid number */
                if (sscanf(defn, "%lf", &value) == 0) {
                    signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                "expression must evaluate to a number");
                    goto cleanup;
                }
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS(parseName);

            /* if it does not exist, create it now */
            if (ipmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_EXTERNAL, 1, 1);
                CHECK_STATUS(ocsmNewPmtr);
                ipmtr = MODL->npmtr;

            /* make sure that Parameter is EXTERNAL */
            } else if (MODL->pmtr[ipmtr].type == OCSM_INTERNAL) {
                signalError(MODL, OCSM_PMTR_IS_INTERNAL,
                            "%s is an internal parameter", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPUT) {
                signalError(MODL, OCSM_PMTR_IS_OUTPUT,
                            "%s is an OUTPMTR", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_CONSTANT) {
                signalError(MODL, OCSM_PMTR_IS_CONSTANT,
                            "%s is a CONPMTR", str1);
                goto cleanup;
//$$$            } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG) {
//$$$                signalError(MODL, OCSM_PMTR_IS_CONSTANT,
//$$$                            "%s is a CFGPMTR parameter", str1);
//$$$                goto cleanup;
            }

            /* store the bounds for the whole Parameter */
            if ((irow ==    0 && icol ==    0) ||
                (irow == -999 && icol == -999)   ) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        jcount = 0;

                        while (icount < STRLEN(str2)) {
                            if (str2[icount] == ';') {
                                icount++;
                                break;
                            } else {
                                defn[jcount  ] = str2[icount];
                                defn[jcount+1] = '\0';
                                icount++;
                                jcount++;
                            }
                        }

                        status = str2val(defn, NULL, &bound, &dot, str);
                        CHECK_STATUS(str2val);
                        if (STRLEN(str) > 0) {
                            signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                        "expression must be a number");
                            goto cleanup;
                        }

                        indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                        MODL->pmtr[ipmtr].lbnd[indx] = bound;
                    }
                }

            /* store the bounds for all rows of the Parameter */
            } else if (irow == -999) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = str2val(defn, NULL, &bound, &dot, str);
                    CHECK_STATUS(str2val);
                    if (STRLEN(str) > 0) {
                        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                    "expression must be a number");
                        goto cleanup;
                    }

                    indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                    MODL->pmtr[ipmtr].lbnd[indx] = bound;
                }

            /* store the bounds for all columns of the Parameter */
            } else if (icol == -999) {
                icount = 0;
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = str2val(defn, NULL, &bound, &dot, str);
                    CHECK_STATUS(str2val);
                    if (STRLEN(str) > 0) {
                        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                    "expression must be a number");
                        goto cleanup;
                    }

                    indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                    MODL->pmtr[ipmtr].lbnd[indx] = bound;
                }

            /* store a single bound into the Parameter */
            } else {
                if (irow <= 0) irow = 1;
                if (icol <= 0) icol = 1;

                icount = 0;
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] = str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                status = str2val(defn, NULL, &bound, &dot, str);
                CHECK_STATUS(str2val);
                if (STRLEN(str) > 0) {
                    signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                "expression must be a number");
                    goto cleanup;
                }

                indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                MODL->pmtr[ipmtr].lbnd[indx] = bound;
            }

        /* input is: "linseg x y z" */
        } else if (strcmp(command, "linseg") == 0 ||
                   strcmp(command, "LINSEG") == 0   ) {
            if (nskpt == 0) {
                signalError(MODL, OCSM_SKETCH_IS_NOT_OPEN,
                            "LINSEG must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "LINSEG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "LINSEG requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_LINSEG, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "loft smooth" */
        } else if (strcmp(command, "loft") == 0 ||
                   strcmp(command, "LOFT") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "LOFT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "LOFT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "LOFT requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_LOFT, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "macbeg imacro" */
        } else if (strcmp(command, "macbeg") == 0 ||
                   strcmp(command, "MACBEG") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "MACBEG cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "MACBEG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "MACBEG requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_MACBEG, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "macend" */
        } else if (strcmp(command, "macend") == 0 ||
                   strcmp(command, "MACEND") == 0   ) {
            if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "MACEND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_MACEND, filenames[MODL->level], linenum[MODL->level],
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "mark" */
        } else if (strcmp(command, "mark") == 0 ||
                   strcmp(command, "MARK") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "MARK cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "MARK cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_MARK, filenames[MODL->level], linenum[MODL->level],
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "mirror nx ny nz dist=0" */
        } else if (strcmp(command, "mirror") == 0 ||
                   strcmp(command, "MIRROR") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "MIRROR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "MIRROR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg == 3) {
                STRNCPY(str4, "0", MAX_EXPR_LEN);
            } else if (narg != 4) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "MIRROR requires 4 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_MIRROR, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "name $branchName" */
        } else if (strcmp(command, "name") == 0 ||
                   strcmp(command, "NAME") == 0   ) {

            /* previous Branch will be named */
            ibrch = MODL->nbrch;
            if (ibrch < 1) {
                signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                            "NAME must follow a Branch");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "NAME requires 1 argument");
                goto cleanup;
            }

            /* set the Branch's name */
            status = ocsmSetName(MODL, ibrch, str1);
            CHECK_STATUS(ocsmSetName);

        /* input is: "outpmtr $pmtrName" */
        } else if (strcmp(command, "outpmtr") == 0 ||
                   strcmp(command, "OUTPMTR") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "OUTPMTR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "OUTPMTR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->level > 0) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "OUTPMTR not allowed in .udc file");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "OUTPMTR requires 1 argument");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS(parseName);

            /* if it does not exist, create it now */
            if (ipmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_OUTPUT, 1, 1);
                CHECK_STATUS(ocsmNewPmtr);
                ipmtr = MODL->npmtr;

            /* make sure that Parameter is OUTPUT */
            } else if (MODL->pmtr[ipmtr].type == OCSM_INTERNAL) {
                signalError(MODL, OCSM_PMTR_IS_INTERNAL,
                            "%s is an internal parameter", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL ||
                       MODL->pmtr[ipmtr].type == OCSM_CONFIG     ) {
                signalError(MODL, OCSM_PMTR_IS_EXTERNAL,
                            "%s is a DESPMTR or CFGPMTR", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_CONSTANT) {
                signalError(MODL, OCSM_PMTR_IS_CONSTANT,
                            "%s is a CONPMTR", str1);
                goto cleanup;
            }

        /* input is: "patbeg $pmtrName ncopy" */
        } else if (strcmp(command, "patbeg") == 0 ||
                   strcmp(command, "PATBEG") == 0   ) {
            if (npatn >= MAX_NESTING) {
                signalError(MODL, OCSM_NESTED_TOO_DEEPLY,
                            "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "PATBEG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else {
                npatn++;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "PATBEG requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[1] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_PATBEG, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "patbreak expr" */
        } else if (strcmp(command, "patbreak") == 0 ||
                   strcmp(command, "PATBREAK") == 0   ) {

            if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "PATBREAK cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* find the matching patbeg */
            i = 1;
            for (ibrch = MODL->nbrch; ibrch > 0; ibrch--) {
                if        (MODL->brch[ibrch].type == OCSM_PATEND) {
                    i++;
                } else if (MODL->brch[ibrch].type == OCSM_PATBEG) {
                    i--;
                    if (i == 0) {
                        break;
                    }
                }
            }
            if (ibrch <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATBREAK must follow a PATBEG");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "PATBREAK requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_PATBREAK, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "patend" */
        } else if (strcmp(command, "patend") == 0 ||
                   strcmp(command, "PATEND") == 0   ) {
            if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "PATEND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* find the matching patbeg */
            i = 1;
            for (ibrch = MODL->nbrch; ibrch > 0; ibrch--) {
                if        (MODL->brch[ibrch].type == OCSM_PATEND) {
                    i++;
                } else if (MODL->brch[ibrch].type == OCSM_PATBEG) {
                    i--;
                    if (i == 0) {
                        break;
                    }
                }
            }
            if (ibrch <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATEND must follow a PATBEG");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_PATEND, filenames[MODL->level], linenum[MODL->level],
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            npatn--;

        /* input is: "point xloc yloc zloc" */
        } else if (strcmp(command, "point") == 0 ||
                   strcmp(command, "POINT") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "POINT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "POINT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "POINT requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_POINT, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "project x y z dx dy dz useEdges=0" */
        } else if (strcmp(command, "project") == 0 ||
                   strcmp(command, "PROJECT") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "PROJECT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "PROJECT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument and save*/
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7);
            if (narg < 6) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "PROJECT requires at least 6 arguments");
                goto cleanup;
            }
            if (narg < 7) {
                strcpy(str7, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_PROJECT, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "recall imacro" */
        } else if (strcmp(command, "recall") == 0 ||
                   strcmp(command, "RECALL") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "RECALL cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "RECALL cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument and save*/
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "RECALL requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_RECALL, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "reorder ishift iflip=0" */
        } else if (strcmp(command, "reorder") == 0 ||
                   strcmp(command, "REORDER") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "REORDER cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "REORDER cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg == 1) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            } else if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "REORDER requires at least 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_REORDER, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "restore $name index=0" */
        } else if (strcmp(command, "restore") == 0 ||
                   strcmp(command, "RESTORE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "RESTORE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "RESTORE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg == 1) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            } else if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "RESTORE requires at least 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_RESTORE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "revolve xorig yorig zorig dxaxis dyaxis dzaxis angDeg" */
        } else if (strcmp(command, "revolve") == 0 ||
                   strcmp(command, "REVOLVE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "REVOLVE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "REVOLVE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7);
            if (narg != 7) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "REVOLVE requires 7 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_REVOLVE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "rotatex angDeg yaxis zaxis" */
        } else if (strcmp(command, "rotatex") == 0 ||
                   strcmp(command, "ROTATEX") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "ROTATEX cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "ROTATEX cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "ROTATEX requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_ROTATEX, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "rotatey angDeg zaxis xaxis" */
        } else if (strcmp(command, "rotatey") == 0 ||
                   strcmp(command, "ROTATEY") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "ROTATEY cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "ROTATEY cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "ROTATEY requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_ROTATEY, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "rotatez angDeg xaxis yaxis" */
        } else if (strcmp(command, "rotatez") == 0 ||
                   strcmp(command, "ROTATEZ") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "ROTATEZ cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "ROTATEZ cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "ROTATEZ requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_ROTATEZ, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "rule reorder=0" */
        } else if (strcmp(command, "rule") == 0 ||
                   strcmp(command, "RULE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "RULE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "RULE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_RULE, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "scale fact xcent=0 ycent=0 zcent=0" */
        } else if (strcmp(command, "scale") == 0 ||
                   strcmp(command, "SCALE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "SCALE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SCALE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str3, "0");
            strcpy(str4, "0");
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SCALE requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                strcpy(str2, "0");
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }
            if (narg < 4) {
                strcpy(str4, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SCALE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "select $type arg1 ..." */
        } else if (strcmp(command, "select") == 0 ||
                   strcmp(command, "SELECT") == 0   ) {

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          &(str1[1]), str2, str3, str4, str5, str6, str7, str8);

            /* create the new Branch */
            if        (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SELECT requires at least 1 argument");
                goto cleanup;
            } else if (strcmp(str1, "$body") == 0 || strcmp(str1, "$BODY") == 0) {
                /* body */
                if        (narg == 1) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* body attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* body attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* body attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* body ibody */
                } else if (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                } else {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "SELECT BODY requires 1, 2, 3, 5, or 7 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$face") == 0 || strcmp(str1, "$FACE") == 0) {
                /* face */
                if (narg == 1) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* face attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* face attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* face attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* face iface  */
                } else if (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* face ibody1 iford1 */
                } else if (narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
                /* face ibody1 iford1 iseq=1 */
                } else if (narg == 3 || narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* face xmin xmax ymin ymax zmin zmax */
                } else if (narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7, NULL, NULL);

                } else {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "SELECT FACE requires 1, 2, 3, 4, 5, or 7 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$edge") == 0 || strcmp(str1, "$EDGE") == 0) {
                /* edge */
                if (narg == 1) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* edge attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* edge attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* edge attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* edge iedge */
                } else if (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* edge ibody1 iford1 ibody2 iford2 */
                } else if (narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);
                /* edge ibody1 iford1 ibody2 iford2 iseq=1 */
                } else if (narg == 5 || narg == 6) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
                /* edge x y z */
                } else if (narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* edge xmin xmax ymin ymax zmin zmax */
                } else if (narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7, NULL, NULL);

                } else {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "SELECT EDGE requires 1, 2, 3, 4, 5, 6, or 7 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$node") == 0 || strcmp(str1, "$NODE") == 0) {
                /* node */
                if (narg == 1) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* node attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* node attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* node attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* node inode */
                } else if (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* node x y z */
                } else if (narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* node xmin xmax ymin ymax zmin zmax */
                } else if (narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7, NULL, NULL);

                } else {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "SELECT NODE requires 1, 2, 3, 4, 5, or 7 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$add") == 0 || strcmp(str1, "$ADD") == 0) {
                /* add iface  -or-  add iedge  -or-  add inode */
                if        (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

                /* add attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* add attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* add attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
                /* add ibody1 iford1 */
                } else if (narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);

                /* add ibody1 iford1 iseq=1 */
                } else if (narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* add ibody1 iford1 ibody2 iford2 */
                } else if (narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);

                /* add ibody1 iford1 ibody2 iford2 iseq=1 */
                } else if (narg == 6) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);

                } else {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                                "SELECT ADD has wrong number of arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$sub") == 0 || strcmp(str1, "$SUB") == 0) {
                /* sub ient */
                if        (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

                /* sub attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* sub attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* sub attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* sub ibody1 iford1 */
                } else if (narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);

                /* sub ibody1 iford1 iseq=1 */
                } else if (narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* sub ibody1 iford1 ibody2 iford2 */
                } else if (narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);

                /* sub ibody1 iford1 ibody2 iford2 iseq=1 */
                } else if (narg == 6) {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);

                } else {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SELECT SUB has wrong number of arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$sort") == 0 || strcmp(str1, "$SORT") == 0) {
                /* sort $key */
                if (narg == 2 && str2[0] == '$') {
                    status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SELECT, filenames[MODL->level], linenum[MODL->level],
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                } else {
                    signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SELECT SORT has wrong number of arguments");
                    goto cleanup;
                }
            } else {
                signalError(MODL, OCSM_ILLEGAL_TYPE,
                            "type must be BODY, FACE, EDGE, NODE, ADD, SUB, or SORT");
                goto cleanup;
            }
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "set $pmtrName exprs" */
        } else if (strcmp(command, "set") == 0 ||
                   strcmp(command, "SET") == 0   ) {
            if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SET cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SET requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[1] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SET, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "skbeg x y z relative=0" */
        } else if (strcmp(command, "skbeg") == 0 ||
                   strcmp(command, "SKBEG") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "SKBEG cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SKBEG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg < 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SKBEG requires at least 3 arguments");
                goto cleanup;
            }
            if (narg < 4) {
                STRNCPY(str4, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SKBEG, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "skcon $type index1 index2=-1 $value=0" */
        } else if (strcmp(command, "skcon") == 0 ||
                   strcmp(command, "SKCON") == 0   ) {
            if (nskpt <= 0) {
                signalError(MODL, OCSM_SKETCH_IS_NOT_OPEN,
                            "SKCON must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SKCON cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* make sure that this follows a skvar or skcon statement */
            if (MODL->brch[MODL->nbrch].type != OCSM_SKVAR &&
                MODL->brch[MODL->nbrch].type != OCSM_SKCON   ) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "only SKVAR or SKCON can preceed SKCON statement");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            strcpy(str4, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s %2046s\n",
                          &(str1[1]), str2, str3, &(str4[1]));
            if (narg < 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SKCON requires 2 arguments");
                goto cleanup;
            }
            if (narg < 3) {
                STRNCPY(str3, "-1", MAX_EXPR_LEN);
            }
            if (narg < 4) {
                STRNCPY(str4, "$0", MAX_EXPR_LEN);
            }

            if        (strcmp(str1, "$X") == 0) {
            } else if (strcmp(str1, "$Y") == 0) {
            } else if (strcmp(str1, "$P") == 0) {
            } else if (strcmp(str1, "$T") == 0) {
            } else if (strcmp(str1, "$A") == 0) {
            } else if (strcmp(str1, "$W") == 0) {
            } else if (strcmp(str1, "$D") == 0) {
            } else if (strcmp(str1, "$H") == 0) {
            } else if (strcmp(str1, "$V") == 0) {
            } else if (strcmp(str1, "$I") == 0) {
            } else if (strcmp(str1, "$Z") == 0) {
            } else if (strcmp(str1, "$L") == 0) {
            } else if (strcmp(str1, "$R") == 0) {
            } else if (strcmp(str1, "$S") == 0) {
            } else {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "type must be X, Y, P, T, A, W, D, H, V, I, Z, L, R, or S");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SKCON, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "skend wireonly=0" */
        } else if (strcmp(command, "skend") == 0 ||
                   strcmp(command, "SKEND") == 0   ) {
            if (nskpt < 1) {
                signalError(MODL, OCSM_COLINEAR_SKETCH_POINTS,
                            "all Sketch points are colinear");
                goto cleanup;
            } else if (nskpt > MAX_SKETCH_SIZE) {
                signalError(MODL, OCSM_TOO_MANY_SKETCH_POINTS,
                            "more than %d sketch points", MAX_SKETCH_SIZE);
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SKEND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg <= 0) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SKEND, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            /* reset the number of Sketch points */
            nskpt = 0;

        /* input is: "skvar $type valList" */
        } else if (strcmp(command, "skvar") == 0 ||
                   strcmp(command, "SKVAR") == 0   ) {
            if (nskpt <= 0) {
                signalError(MODL, OCSM_SKETCH_IS_NOT_OPEN,
                            "SKBAR must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SKVAR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* make sure that this follows a skbeg statement */
            if (MODL->brch[MODL->nbrch].type != OCSM_SKBEG) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "only SKBEG can preceed SKVAR statement");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg < 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SKVAR requires 2 arguments");
                goto cleanup;
            }

            if        (strcmp(str1, "$xy") == 0 || strcmp(str1, "$XY") == 0) {
                STRNCPY(str1, "$xy", MAX_EXPR_LEN);
            } else if (strcmp(str1, "$yz") == 0 || strcmp(str1, "$YZ") == 0) {
                STRNCPY(str1, "$yz", MAX_EXPR_LEN);
            } else if (strcmp(str1, "$zx") == 0 || strcmp(str1, "$ZX") == 0) {
                STRNCPY(str1, "$zx", MAX_EXPR_LEN);
            } else {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "PLANE must be XY, YZ, or ZX");
                goto cleanup;
            }

            /* make sure that str2 contains the correct number of semicolons */
            count = 0;
            for (i = 0; i < STRLEN(str2); i++) {
                if (str2[i] == ';') {
                    count++;
                }
            }

            if (count == 0 || count%3 != 0) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "valList must contain triplets");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SKVAR, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "solbeg $varList" */
        } else if (strcmp(command, "solbeg") == 0 ||
                   strcmp(command, "SOLBEG") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "SOLBEG cannot be in SKBEG/SKEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s\n",
                          &(str1[1]));
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SOLBEG requires 1 argument");
                goto cleanup;
            }

            /* remember that we are in a solver block */
            insolver = 1;

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SOLBEG, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "solcon $expr" */
        } else if (strcmp(command, "solcon") == 0 ||
                   strcmp(command, "SOLCON") == 0   ) {
            if (insolver != 1) {
                signalError(MODL, OCSM_SOLVER_IS_NOT_OPEN,
                            "SOLCON must be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s\n",
                          &(str1[1]));
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SOLCON requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SOLCON, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "solend" */
        } else if (strcmp(command, "solend") == 0 ||
                   strcmp(command, "SOLEND") == 0   ) {
            if (insolver != 1) {
                signalError(MODL, OCSM_SOLVER_IS_NOT_OPEN,
                            "SOLEND must be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* no arguments */

            /* close the solver */
            insolver = 0;

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SOLEND, filenames[MODL->level], linenum[MODL->level],
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "special arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9" */
        } else if (strcmp(command, "special") == 0 ||
                   strcmp(command, "SPECIAL") == 0   ) {

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7, str8, str9);
            if (narg != 9) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SPECIAL requires at 9 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SPECIAL, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, str7, str8, str9);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "sphere xcent ycent zcent radius" */
        } else if (strcmp(command, "sphere") == 0 ||
                   strcmp(command, "SPHERE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "SPHERE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SPHERE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg != 4) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SPHERE requires at 4 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SPHERE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "spline x y z" */
        } else if (strcmp(command, "spline") == 0 ||
                   strcmp(command, "SPLINE") == 0   ) {
            if (nskpt == 0) {
                signalError(MODL, OCSM_SKETCH_IS_NOT_OPEN,
                            "SPLINE must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SPLINE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SPLINE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SPLINE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "sslope dx dy dz" */
        } else if (strcmp(command, "sslope") == 0 ||
                   strcmp(command, "SSLOPE") == 0   ) {
            if (nskpt == 0) {
                signalError(MODL, OCSM_SKETCH_IS_NOT_OPEN,
                            "SSLOPE must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SSLOPE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "SSLOPE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SSLOPE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "store $name index=0 keep=0" */
        } else if (strcmp(command, "store") == 0 ||
                   strcmp(command, "STORE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "STORE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "STORE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "STORE requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_STORE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "subtract $order=none index=1 maxtol=0" */
        } else if (strcmp(command, "subtract") == 0 ||
                   strcmp(command, "SUBTRACT") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "SUBTRACT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SUBTRACT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 1) {
                STRNCPY(str1, "$none", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "1",     MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0",     MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SUBTRACT, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "sweep" */
        } else if (strcmp(command, "sweep") == 0 ||
                   strcmp(command, "SWEEP") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "SWEEP cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "SWEEP cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_SWEEP, filenames[MODL->level], linenum[MODL->level],
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "throw sigCode" */
        } else if (strcmp(command, "throw") == 0 ||
                   strcmp(command, "THROW") == 0   ) {

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "THROW requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_THROW, filenames[MODL->level], linenum[MODL->level],
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "torus xcent ycent zcent dxaxis dyaxis dzaxis majorRad minorRad" */
        } else if (strcmp(command, "torus") == 0 ||
                   strcmp(command, "TORUS") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "TORUS cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "TORUS cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7, str8);
            if (narg != 8) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "TORUS requires 8 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_TORUS, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, str4, str5, str6, str7, str8, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "translate dx dy dz" */
        } else if (strcmp(command, "translate") == 0 ||
                   strcmp(command, "TRANSLATE") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "TRANSLATE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "TRANSLATE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "TRANSLATE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_TRANSLATE, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "ubound $pmtrName expression" */
        } else if (strcmp(command, "ubound") == 0 ||
                   strcmp(command, "UBOUND") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "UBOUND cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "UBOUND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                            "UBOUND not allowed in function-type .udc file");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "UBOUND requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* make sure that values is a semicolon-separated list of numbers */
            icount = 0;
            while (icount < STRLEN(str2)) {
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] =str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                /* check for a valid number */
                if (sscanf(defn, "%lf", &value) == 0) {
                    signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                "expression must evaluate to a number");
                    goto cleanup;
                }
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS(parseName);

            /* if it does not exist, create it now */
            if (ipmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_EXTERNAL, 1, 1);
                CHECK_STATUS(ocsmNewPmtr);
                ipmtr = MODL->npmtr;

            /* make sure that Parameter is EXTERNAL */
            } else if (MODL->pmtr[ipmtr].type == OCSM_INTERNAL) {
                signalError(MODL, OCSM_PMTR_IS_INTERNAL,
                            "%s is an internal parameter", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPUT) {
                signalError(MODL, OCSM_PMTR_IS_OUTPUT,
                            "%s is a OUTPMTR", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_CONSTANT) {
                signalError(MODL, OCSM_PMTR_IS_CONSTANT,
                            "%s is a CONPMTR", str1);
                goto cleanup;
//$$$            } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG) {
//$$$                signalError(MODL, OCSM_PMTR_IS_CONSTANT,
//$$$                            "%s is a CFGPMTR parameter", str1);
//$$$                goto cleanup;
            }

            /* store the bounds for the whole Parameter */
            if ((irow ==    0 && icol ==    0) ||
                (irow == -999 && icol == -999)   ) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        jcount = 0;

                        while (icount < STRLEN(str2)) {
                            if (str2[icount] == ';') {
                                icount++;
                                break;
                            } else {
                                defn[jcount  ] = str2[icount];
                                defn[jcount+1] = '\0';
                                icount++;
                                jcount++;
                            }
                        }

                        status = str2val(defn, NULL, &bound, &dot, str);
                        CHECK_STATUS(str2val);
                        if (STRLEN(str) > 0) {
                            signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                        "expression must evaluate to a number");
                            goto cleanup;
                        }

                        indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                        MODL->pmtr[ipmtr].ubnd[indx] = bound;
                    }
                }

            /* store the bounds for all rows of the Parameter */
            } else if (irow == -999) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = str2val(defn, NULL, &bound, &dot, str);
                    CHECK_STATUS(str2val);
                    if (STRLEN(str) > 0) {
                        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                    "expression must evaluate to a number");
                        goto cleanup;
                    }

                    indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                    MODL->pmtr[ipmtr].ubnd[indx] = bound;
                }

            /* store the bounds for all columns of the Parameter */
            } else if (icol == -999) {
                icount = 0;
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = str2val(defn, NULL, &bound, &dot, str);
                    CHECK_STATUS(str2val);
                    if (STRLEN(str) > 0) {
                        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                    "expression must evaluate to a number");
                        goto cleanup;
                    }

                    indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                    MODL->pmtr[ipmtr].ubnd[indx] = bound;
                }

            /* store a single bound into the Parameter */
            } else {
                if (irow <= 0) irow = 1;
                if (icol <= 0) icol = 1;

                icount = 0;
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] = str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                status = str2val(defn, NULL, &bound, &dot, str);
                CHECK_STATUS(str2val);
                if (STRLEN(str) > 0) {
                    signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                "expression must evaluate to a number");
                    goto cleanup;
                }

                indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                MODL->pmtr[ipmtr].ubnd[indx] = bound;
            }

        /* input is: "udparg $primtype $argName1 argValue1 $argName2 argValue2 $argName3 argValue3 $argName4 argValue4" */
        } else if (strcmp(command, "udparg") == 0 ||
                   strcmp(command, "UDPARG") == 0   ) {

            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "UDPARG cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "UDPARG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");  strcpy(str2, "$");  strcpy(str4, "$");  strcpy(str6, "$");  strcpy(str8, "$");
            narg = sscanf(nextline, "%*s %2046s %2046s %2047s %2046s %2047s %2046s %2047s %2046s %2047s\n",
                          &(str1[1]), &(str2[1]), str3, &(str4[1]), str5,
                                      &(str6[1]), str7, &(str8[1]), str9);
            if (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "UDPARG requires at least 1 argument");
                goto cleanup;
            } else if (narg%2 != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "UDPARG  requires 1, 3, 5, 7, or 9 arguments");
                goto cleanup;
            }

            if (narg < 3) str3[0] = '\0';
            if (narg < 5) str5[0] = '\0';
            if (narg < 7) str7[0] = '\0';
            if (narg < 9) str9[0] = '\0';

            /* adjust file spec or extract "inline" file */
            status = adjustFileSpec(csm_file[MODL->level], filenames[MODL->level], &(linenum[MODL->level]), str3);
            CHECK_STATUS(adjustFileSpec);

            status = adjustFileSpec(csm_file[MODL->level], filenames[MODL->level], &(linenum[MODL->level]), str5);
            CHECK_STATUS(adjustFileSpec);

            status = adjustFileSpec(csm_file[MODL->level], filenames[MODL->level], &(linenum[MODL->level]), str7);
            CHECK_STATUS(adjustFileSpec);

            status = adjustFileSpec(csm_file[MODL->level], filenames[MODL->level], &(linenum[MODL->level]), str9);
            CHECK_STATUS(adjustFileSpec);

            /* create the new Branch */
            if        (narg < 3) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPARG, filenames[MODL->level], linenum[MODL->level],
                                     str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            } else if (narg < 5) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPARG, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            } else if (narg < 7) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPARG, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);
            } else if (narg < 9) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPARG, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            } else {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPARG, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, str4, str5, str6, str7, str8, str9);
            }
            CHECK_STATUS(ocsmNewBrch);

        /* input is: "udprim $primtype $argName1 argValue1 $argName2 argValue2 $argName3 argValue3 $argName4 argValue4" */
        } else if (strcmp(command, "udprim") == 0 ||
                   strcmp(command, "UDPRIM") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "UDPRIM cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "UDPRIM cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");  strcpy(str2, "$");  strcpy(str4, "$");  strcpy(str6, "$");  strcpy(str8, "$");
            narg = sscanf(nextline, "%*s %2046s %2046s %2047s %2046s %2047s %2046s %2047s %2046s %2047s\n",
                          &(str1[1]), &(str2[1]), str3, &(str4[1]), str5,
                                      &(str6[1]), str7, &(str8[1]), str9);
            if (narg < 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "UDPRIM requires at least 1 argument");
                goto cleanup;
            } else if (narg%2 != 1) {
                signalError(MODL, OCSM_NOT_ENOUGH_ARGS,
                            "UDPRIM requires 1, 3, 5, 7, or 9 arguments");
                goto cleanup;
            }

            if (narg < 3) str3[0] = '\0';
            if (narg < 5) str5[0] = '\0';
            if (narg < 7) str7[0] = '\0';
            if (narg < 9) str9[0] = '\0';

            /* adjust file spec or extract "inline" file */
            status = adjustFileSpec(csm_file[MODL->level], filenames[MODL->level], &(linenum[MODL->level]), str3);
            CHECK_STATUS(adjustFileSpec);

            status = adjustFileSpec(csm_file[MODL->level], filenames[MODL->level], &(linenum[MODL->level]), str5);
            CHECK_STATUS(adjustFileSpec);

            status = adjustFileSpec(csm_file[MODL->level], filenames[MODL->level], &(linenum[MODL->level]), str7);
            CHECK_STATUS(adjustFileSpec);

            status = adjustFileSpec(csm_file[MODL->level], filenames[MODL->level], &(linenum[MODL->level]), str9);
            CHECK_STATUS(adjustFileSpec);

            /* create the new Branch */
            if        (narg < 3) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPRIM, filenames[MODL->level], linenum[MODL->level],
                                     str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            } else if (narg < 5) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPRIM, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            } else if (narg < 7) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPRIM, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);
            } else if (narg < 9) {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPRIM, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            } else {
                status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UDPRIM, filenames[MODL->level], linenum[MODL->level],
                                     str1, str2, str3, str4, str5, str6, str7, str8, str9);
            }
            CHECK_STATUS(ocsmNewBrch);

            /* if we are reading a .cpc file, increment numudc, and continue reading */
            if (filetype == 1) {

                if (strncmp(str1, "$$/",  3) == 0 ||
                    strncmp(str1, "$$$/", 4) == 0   ) {
                    numudc++;
                }

            /* if the primtype begins with a slash or dollar, then look for a .udc file
               in the current directory */
            } else if (strncmp(str1, "$/",   2) == 0 ||
                       strncmp(str1, "$$/",  3) == 0 ||
                       strncmp(str1, "$$$/", 4) == 0   ) {
                if (MODL->level < 10) {
                    (MODL->level)++;
                    MODL->scope[MODL->level] = MODL->scope[MODL->level-1] + 1;

                    /* if primtype starts with "/", look in current directory */
                    if (strncmp(str1, "$/", 2) == 0) {
                        snprintf(filenames[MODL->level], MAX_EXPR_LEN, "%s.udc", &(str1[2]));
                    /* if primtype starts with "$/", look in same directory as .csm file */
                    } else if (strncmp(str1, "$$/", 3) == 0) {
                        STRNCPY(pathname, filenames[MODL->level-1], MAX_EXPR_LEN);
                        i = STRLEN(pathname) - 1;
                        while (pathname[i] != SLASH) {
                            pathname[i] = '\0';
                            i--;
                            if (i < 0) break;
                        }
                        snprintf(filenames[MODL->level], MAX_EXPR_LEN, "%s%s.udc", pathname, &(str1[3]));
                    /* if primtype starts with "$$/", look in ESP_ROOT directory */
                    } else {
                        esp_root = getenv("ESP_ROOT");
                        snprintf(filenames[MODL->level], MAX_EXPR_LEN, "%s%cudc%c%s.udc", esp_root, SLASH, SLASH, &(str1[4]));
                    }

                    csm_file[MODL->level] = fopen(filenames[MODL->level], "r");
                    if (csm_file[MODL->level] != NULL) {
                        SPRINT1(1, "\n>>> Diverting to file \"%s\"\n", filenames[MODL->level]);
                        linenum[MODL->level] = 0;

                        assert (MODL->filelist != NULL);

                        imatch = 0;
                        for (itoken = 0; itoken < 0; itoken++) {   // arbitrary hard-coded limit
                            getToken(MODL->filelist, itoken, '|', MAX_EXPR_LEN, token);
                            if (STRLEN(token) == 0) {
                                break;
                            } else if (strcmp(filenames[MODL->level], token) == 0) {
                                imatch = 1;
                                break;
                            }
                        }
                        if (imatch == 0) {
                            RALLOC(MODL->filelist, char, STRLEN(MODL->filelist)+STRLEN(filenames[MODL->level])+2);
                            strcat(MODL->filelist, filenames[MODL->level]);
                            strcat(MODL->filelist, "|");
                        }
                    } else {
                        SPRINT1(0, "ERROR:: cannot open \"%s\"", filenames[MODL->level]);
                        (MODL->level)--;
                        status = OCSM_FILE_NOT_FOUND;
                        goto cleanup;
                    }
                } else {
                    signalError(MODL, OCSM_NESTED_TOO_DEEPLY,
                                "maximum file depth reached");
                }
            }

        /* input is: "union toMark=0 trimList=0 maxtol=0" */
        } else if (strcmp(command, "union") == 0 ||
                   strcmp(command, "UNION") == 0   ) {
            if (nskpt > 0) {
                signalError(MODL, OCSM_SKETCH_IS_OPEN,
                            "UNION cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                signalError(MODL, OCSM_SOLVER_IS_OPEN,
                            "UNION cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->nbrch, OCSM_UNION, filenames[MODL->level], linenum[MODL->level],
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);

        /* illegal command */
        } else {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "unrecognized command \"%s\"", command);
            goto cleanup;
        }
    }

cleanup:
    if (MODL != NULL) {
        if (status == 0) {
            status = MODL->sigCode;
        }

        /* close the .csm file */
        if (csm_file[MODL->level] != NULL) fclose(csm_file[MODL->level]);
    }

    FREE(str9);
    FREE(str8);
    FREE(str7);
    FREE(str6);
    FREE(str5);
    FREE(str4);
    FREE(str3);
    FREE(str2);
    FREE(str1);

    FREE(str );

    FREE(command );
    FREE(nextline);
    FREE(templine);

    return status;
}


/***********************************************************************/
/*                                                                     */
/*   ocsmLoadDict - load dictionary from dictname                      */
/*                                                                     */
/***********************************************************************/

int
ocsmLoadDict(void   *modl,              /* (in)  pointer to MODL */
             char   dictname[])         /* (in)  file that contains dictionary */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipmtr;
    double    oldvalue, olddot, pmtrValue;
    char      pmtrName[MAX_FILENAME_LEN];
    FILE      *dict_fp=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmLoadDict);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if there was a dictionary, load the definitions from it now */
    if (STRLEN(dictname) <= 0) goto cleanup;

    dict_fp = fopen(dictname, "r");
    if (dict_fp == NULL) {
        SPRINT1(0, "ERROR:: dictionary \"%s\" not found", dictname);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    SPRINT1(0, "--> Opening dictionary \"%s\"", dictname);

    while (1) {
        status = fscanf(dict_fp, "%s %lf\n", pmtrName, &pmtrValue);
        if (status < 2) break;

        SPRINT2(0, "    defining constant %-20s = %10.5f", pmtrName, pmtrValue);

        if (pmtrName[0] == '@') {
            SPRINT0(0, "ERROR:: constant name cannot start with @");
            status = OCSM_ILLEGAL_PMTR_NAME;
            goto cleanup;
        }

        status = ocsmNewPmtr(MODL, pmtrName, OCSM_CONSTANT, 1, 1);
        if (status == OCSM_NAME_ALREADY_DEFINED) {
            status = ocsmFindPmtr(MODL, pmtrName, OCSM_CONSTANT, 1, 1, &ipmtr);
            if (status != SUCCESS) {
                SPRINT1(0, "ERROR:: \"%s\" is already defined", pmtrName);
                status = OCSM_ILLEGAL_PMTR_NAME;
                goto cleanup;
            }

            status = ocsmGetValu(MODL, ipmtr, 1, 1, &oldvalue, &olddot);
            if (status != SUCCESS) {
                SPRINT1(0, "ERROR:: problem getting value for \"%s\"", pmtrName);
                status = OCSM_ILLEGAL_VALUE;
                goto cleanup;
            }

            if (pmtrValue == oldvalue) {
                SPRINT0(0, "    --> already exists with same value");
            } else {
                SPRINT1(0, "ERROR:: cannot overwrite \"%s\" that already exists", pmtrName);
                status = OCSM_ILLEGAL_VALUE;
                goto cleanup;
            }
        } else if (status < SUCCESS) {
            SPRINT1(0, "ERROR:: error defining constant \"%s\"\n", pmtrName);
            status = OCSM_ILLEGAL_PMTR_NAME;
            goto cleanup;
        } else {
            status = ocsmSetValuD(MODL, MODL->npmtr, 1, 1, pmtrValue);
            if (status < SUCCESS) {
                SPRINT1(0, "ERROR:: error setting value for constant \"%s\"\n", pmtrName);
                status = OCSM_ILLEGAL_VALUE;
                goto cleanup;
            }
        }
    }

    /* getting here means that we succeeded */
    status = SUCCESS;

cleanup:
    if (dict_fp != NULL) fclose(dict_fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *  ocsmUpdateDespmtrs - update DESPMTRs from filename                  *
 *                                                                      *
 ************************************************************************
 */

int
ocsmUpdateDespmtrs(void   *modl,        /* (in)  pointer to MODL */
                   char   filename[])   /* (in)  file that contains DESPMTRs */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipmtr, jpmtr, type, nrow, ncol;
    double    pmtrvalue;
    char      pmtrname[MAX_NAME_LEN], name[MAX_NAME_LEN];
    FILE      *fp=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmUpdateDespmtrs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if there was a file, update the DESPMTRs mentioned in it now */
    if (STRLEN(filename) <= 0) goto cleanup;

    fp = fopen(filename, "r");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: DESPMTR file \"%s\" not found", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    SPRINT1(0, "--> Opening DESPMTR file \"%s\"", filename);

    /* read lines in the form pmtrname pmtrvalue */
    while (1) {
        status = fscanf(fp, "%s %lf\n", pmtrname, &pmtrvalue);
        if (status < 2) break;

        /* find the DESPMTR index of pmtrname */
        ipmtr = 0;
        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            status = ocsmGetPmtr(MODL, jpmtr, &type, &nrow, &ncol, name);
            if (status < EGADS_SUCCESS) goto cleanup;

            if (strcmp(pmtrname, name) == 0 && type == OCSM_EXTERNAL) {
                ipmtr = jpmtr;
                break;
            }
        }

        if (ipmtr <= 0) {
            SPRINT1(0, "ERROR:: \"%s\" is not a valid DESPMTR", pmtrname);
            status = OCSM_ILLEGAL_PMTR_NAME;
            goto cleanup;
        }

        /* set the DESPMTR value */
        status = ocsmSetValuD(MODL, ipmtr, 1, 1, pmtrvalue);
        if (status < EGADS_SUCCESS) goto cleanup;

        SPRINT2(0, "    updating DESPMTR %32s = %12.6f", pmtrname, pmtrvalue);
    }

    /* getting here means that we succeeded */
    status = SUCCESS;

cleanup:
    if (fp != NULL) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetFilelist - get a list of all .csm, .cpc, and .udc file      *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetFilelist(void   *modl,           /* (in)  pointer to MODL */
                char   *filelist[])     /* (out) bar-sepatared list of files */
                                        /*       must be freed by user */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        ibrch, lenFilelist=0;
    char       tmpFilename[MAX_FILENAME_LEN+2], *myFilelist=NULL;

    ROUTINE(ocsmGetFilelist);

    /* --------------------------------------------------------------- */

    /* initialize filelist */
    lenFilelist = 1000;
    MALLOC(myFilelist, char, lenFilelist);

    myFilelist[0] = '\0';

    /* look through all Branches and its filename if not already in filelist */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        strcpy(tmpFilename, MODL->brch[ibrch].filename);
        strcat(tmpFilename, "|");

        if (strstr(myFilelist, tmpFilename) == NULL) {
            if (STRLEN(myFilelist)+STRLEN(MODL->brch[ibrch].filename)+2 > lenFilelist) {
                lenFilelist += 1000;
                RALLOC(myFilelist, char, lenFilelist);
            }

            strcat(myFilelist, tmpFilename);
        }
    }

    /* return the filelist (which must be freed by user) */
    *filelist = myFilelist;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSave - save a MODL to a file                                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSave(void   *modl,                  /* (in)  pointer to MODL */
         char   filename[])             /* (in)  file to be written (with extension) */
                                        /*       .csm -> write outer .csm file */
                                        /*       .cpc -> write checkpointed .csm file */
                                        /*       .udc -> write a .udc file */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       filelen, filetype, i, j;
    int       ipmtr, ibrch, jbrch, kbrch=-1, iattr, irow, icol, index, indent, nindent=0;
    char      udcname[MAX_EXPR_LEN], templine[MAX_LINE_LEN];
    FILE      *csm_file, *fp_inline;

    ROUTINE(ocsmSave);

    /* --------------------------------------------------------------- */

    SPRINT1(1, "--> enter ocsmSave(filename=%s)", filename);

    csm_file  = NULL;
    fp_inline = NULL;

    /* check for a valid extension */
    filelen = STRLEN(filename);
    if (filelen < 5) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'c' &&
               filename[filelen-2] == 's' && filename[filelen-1] == 'm'   ) {
        SPRINT0(2, "    writing .csm file");
        filetype = 0;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'c' &&
               filename[filelen-2] == 'p' && filename[filelen-1] == 'c'   ) {
        SPRINT0(2, "    writing .cpc file");
        filetype = 1;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'u' &&
               filename[filelen-2] == 'd' && filename[filelen-1] == 'c'   ) {
        SPRINT0(2, "    writing .udc file");
        filetype = 2;

        /* get udc name (part after last $ or / ) */
        j          = 0;
        udcname[j] = '\0';
        for (i = 0; i < STRLEN(filename)-4; i++) {
            if (filename[i] == '$' || filename[i] == '/') {
                j          = 0;
                udcname[j] = '\0';
            } else {
                udcname[j  ] = filename[i];
                udcname[j+1] = '\0';
                j++;
            }
        }

        /* find the UDPRIM statement that refers to udcname */
        kbrch = -1;
        for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
            if (       MODL->brch[ibrch].type           == OCSM_UDPRIM &&
                strstr(MODL->brch[ibrch].arg1, udcname) != NULL        &&
                (MODL->brch[ibrch].arg1[1] == '/' || MODL->brch[ibrch].arg1[1] == '$')) {
                kbrch = ibrch;
                break;
            }
        }

        if (kbrch < 0) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        }
    } else {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* open file */
    if (STRLEN(filename) == 0) {
        SPRINT0(0, "ERROR:: filename not specified");
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    csm_file = fopen(filename, "w");
    if (csm_file == NULL) {
        SPRINT1(0, "ERROR:: cannot open \"%s\"", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* write header */
    fprintf(csm_file, "# %s written by ocsmSave (v%d.%02d)\n",
            filename, OCSM_MAJOR_VERSION, OCSM_MINOR_VERSION);

    /* write the constant, output, and design (external) Parameters */
    if (filetype == 0 || filetype == 1) {
        fprintf(csm_file, "\n# Constant, Design, and Output Parameters:\n");
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (MODL->pmtr[ipmtr].type  == OCSM_CONSTANT) {

                fprintf(csm_file, "conpmtr   %s   %11.5f\n",
                        MODL->pmtr[ipmtr].name, MODL->pmtr[ipmtr].value[0]);
            } else if (MODL->pmtr[ipmtr].type  == OCSM_OUTPUT) {

                fprintf(csm_file, "outpmtr   %s\n",
                        MODL->pmtr[ipmtr].name);
            } else if (MODL->pmtr[ipmtr].type  == OCSM_EXTERNAL) {

                if (MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol > 1) {
                    fprintf(csm_file, "dimension %s   %d   %d   1\n",
                            MODL->pmtr[ipmtr].name,
                            MODL->pmtr[ipmtr].nrow,
                            MODL->pmtr[ipmtr].ncol);

                    index = 0;
                    for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                        fprintf(csm_file, "despmtr   %s[%d,:]   \"", MODL->pmtr[ipmtr].name, irow);
                        for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                            fprintf(csm_file, " %11.5f;", MODL->pmtr[ipmtr].value[index]);
                            index++;
                        }
                        fprintf(csm_file, "\"\n");
                    }
                } else {
                    fprintf(csm_file, "despmtr   %s   %11.5f\n",
                            MODL->pmtr[ipmtr].name, MODL->pmtr[ipmtr].value[0]);
                }

                index = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        if (MODL->pmtr[ipmtr].lbnd[index] > -HUGEQ) {
                            fprintf(csm_file, "lbound      %s[%d,%d]   %f\n",
                                    MODL->pmtr[ipmtr].name,
                                    irow, icol,
                                    MODL->pmtr[ipmtr].lbnd[index]);
                        }
                        if (MODL->pmtr[ipmtr].ubnd[index] < +HUGEQ) {
                            fprintf(csm_file, "ubound      %s[%d,%d]   %f\n",
                                    MODL->pmtr[ipmtr].name,
                                    irow, icol,
                                    MODL->pmtr[ipmtr].ubnd[index]);
                        }

                        index++;
                    }
                }
            } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG) {
                fprintf(csm_file, "cfgpmtr   %s   %11.5f\n",
                            MODL->pmtr[ipmtr].name, MODL->pmtr[ipmtr].value[0]);
            }
        }
    }

    /* write the global Attributes */
    if (filetype == 0 || filetype == 1) {
        fprintf(csm_file, "\n# Global Attributes:\n");
        for (iattr = 0; iattr < MODL->nattr; iattr++) {
            fprintf(csm_file, "attribute %s   %s\n",
                    MODL->attr[iattr].name,
                    MODL->attr[iattr].defn);
        }
    }

    /* make sure indentation is up to date */
    status = ocsmCheck(MODL);
    CHECK_STATUS(ocsmCheck);

    /* write the Branches */
    fprintf(csm_file, "\n# Branches:\n");
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {

        /* special treatment if writing a .udc file */
        if (filetype == 2) {

            /* advance to first Branch following UDPRIM statement */
            if (ibrch <= kbrch) {
                nindent = MODL->brch[ibrch].indent + 1;
                continue;

            /* we are done if an END statement */
            } else if (MODL->brch[ibrch].type == OCSM_END) {
                break;
            }
        }

        for (indent = nindent; indent < MODL->brch[ibrch].indent; indent++) {
            fprintf(csm_file, "   ");
        }

        if        (MODL->brch[ibrch].type == OCSM_APPLYCSYS) {
            fprintf(csm_file, "applycsys %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_ARC) {
            fprintf(csm_file, "arc       %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                  &(MODL->brch[ibrch].arg5[1]));
        } else if (MODL->brch[ibrch].type == OCSM_ASSERT) {
            fprintf(csm_file, "assert    %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_BEZIER) {
            fprintf(csm_file, "bezier    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_BLEND) {
            fprintf(csm_file, "blend     %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_BOX) {
            fprintf(csm_file, "box       %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6);
        } else if (MODL->brch[ibrch].type == OCSM_CATBEG) {
            fprintf(csm_file, "catbeg    %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_CATEND) {
            fprintf(csm_file, "catend\n");
        } else if (MODL->brch[ibrch].type == OCSM_CHAMFER) {
            fprintf(csm_file, "chamfer   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_CIRARC) {
            fprintf(csm_file, "cirarc    %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6);
        } else if (MODL->brch[ibrch].type == OCSM_COMBINE) {
            fprintf(csm_file, "combine   %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_CONE) {
            fprintf(csm_file, "cone      %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_CONNECT) {
            fprintf(csm_file, "connect   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_CYLINDER) {
            fprintf(csm_file, "cylinder  %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_DIMENSION) {
            fprintf(csm_file, "dimension %s   %s   %s   0\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_DUMP) {
            fprintf(csm_file, "dump      %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_ELSE) {
            fprintf(csm_file, "else\n");
        } else if (MODL->brch[ibrch].type == OCSM_ELSEIF) {
            fprintf(csm_file, "elseif    %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                  &(MODL->brch[ibrch].arg2[1]),
                    MODL->brch[ibrch].arg3,
                  &(MODL->brch[ibrch].arg4[1]),
                    MODL->brch[ibrch].arg5,
                  &(MODL->brch[ibrch].arg6[1]),
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_END) {
            fprintf(csm_file, "end\n");
        } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
            fprintf(csm_file, "endif\n");
        } else if (MODL->brch[ibrch].type == OCSM_EVALUATE) {
            if        (strcmp(MODL->brch[ibrch].arg1, "$node") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$NODE") == 0   ) {
                fprintf(csm_file, "evaluate  %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$edge") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$EDGE") == 0   ) {
                fprintf(csm_file, "evaluate  %s   %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3,
                        MODL->brch[ibrch].arg4);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$edgerng") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$EDGERNG") == 0   ) {
                fprintf(csm_file, "evaluate  %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$edgeinv") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$EDGEINV") == 0   ) {
                fprintf(csm_file, "evaluate  %s   %s   %s   %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3,
                        MODL->brch[ibrch].arg4,
                        MODL->brch[ibrch].arg5,
                        MODL->brch[ibrch].arg6);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$face") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$FACE") == 0   ) {
                fprintf(csm_file, "evaluate  %s   %s   %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3,
                        MODL->brch[ibrch].arg4,
                        MODL->brch[ibrch].arg5);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$facerng") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$FACERNG") == 0   ) {
                fprintf(csm_file, "evaluate  %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$faceinv") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$FACEINV") == 0   ) {
                fprintf(csm_file, "evaluate  %s   %s   %s   %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3,
                        MODL->brch[ibrch].arg4,
                        MODL->brch[ibrch].arg5,
                        MODL->brch[ibrch].arg6);
            }
        } else if (MODL->brch[ibrch].type == OCSM_EXTRACT) {
            fprintf(csm_file, "extract   %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_EXTRUDE) {
            fprintf(csm_file, "extrude   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_FILLET) {
            fprintf(csm_file, "fillet    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_GETATTR) {
            fprintf(csm_file, "getattr   %s %s %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_GROUP) {
            fprintf(csm_file, "group     %s\n",
                MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_HOLLOW) {
            fprintf(csm_file, "hollow    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_IFTHEN) {
            fprintf(csm_file, "ifthen    %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                  &(MODL->brch[ibrch].arg2[1]),
                    MODL->brch[ibrch].arg3,
                  &(MODL->brch[ibrch].arg4[1]),
                    MODL->brch[ibrch].arg5,
                  &(MODL->brch[ibrch].arg6[1]),
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_IMPORT) {
            fprintf(csm_file, "import    %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_INTERFACE) {
            fprintf(csm_file, "interface %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                  &(MODL->brch[ibrch].arg2[1]),
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_INTERSECT) {
            fprintf(csm_file, "intersect %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3    );
        } else if (MODL->brch[ibrch].type == OCSM_JOIN) {
            fprintf(csm_file, "join     %s    %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_LINSEG) {
            fprintf(csm_file, "linseg    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_LOFT) {
            fprintf(csm_file, "loft      %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_MACBEG) {
            fprintf(csm_file, "macbeg    %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_MACEND) {
            fprintf(csm_file, "macend\n");
        } else if (MODL->brch[ibrch].type == OCSM_MARK) {
            fprintf(csm_file, "mark\n");
        } else if (MODL->brch[ibrch].type == OCSM_MIRROR) {
            fprintf(csm_file, "mirror    %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_PATBEG) {
            fprintf(csm_file, "patbeg    %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2    );
        } else if (MODL->brch[ibrch].type == OCSM_PATBREAK) {
            fprintf(csm_file, "patbreak  %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_PATEND) {
            fprintf(csm_file, "patend\n");
        } else if (MODL->brch[ibrch].type == OCSM_POINT) {
            fprintf(csm_file, "point     %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_PROJECT) {
            fprintf(csm_file, "project   %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_RECALL) {
            fprintf(csm_file, "recall    %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_REORDER) {
            fprintf(csm_file, "reorder   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_RESTORE) {
            fprintf(csm_file, "restore   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2    );
        } else if (MODL->brch[ibrch].type == OCSM_REVOLVE) {
            fprintf(csm_file, "revolve   %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_ROTATEX) {
            fprintf(csm_file, "rotatex   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_ROTATEY) {
            fprintf(csm_file, "rotatey   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_ROTATEZ) {
            fprintf(csm_file, "rotatez   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_RULE) {
            fprintf(csm_file, "rule      %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_SCALE) {
            fprintf(csm_file, "scale     %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_SELECT) {
            fprintf(csm_file, "select    %s",
                  &(MODL->brch[ibrch].arg1[1]));
            if (MODL->brch[ibrch].narg >= 2) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg2);
            }
            if (MODL->brch[ibrch].narg >= 3) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg3);
            }
            if (MODL->brch[ibrch].narg >= 4) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg4);
            }
            if (MODL->brch[ibrch].narg >= 5) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg5);
            }
            if (MODL->brch[ibrch].narg >= 6) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg6);
            }
            if (MODL->brch[ibrch].narg >= 7) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg7);
            }
            if (MODL->brch[ibrch].narg >= 8) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg8);
            }
            fprintf(csm_file, "\n");
        } else if (MODL->brch[ibrch].type == OCSM_SET) {
            fprintf(csm_file, "set       %s %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_SKBEG) {
            fprintf(csm_file, "skbeg     %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_SKCON) {
            fprintf(csm_file, "skcon     %s   %s   %s  %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                  &(MODL->brch[ibrch].arg4[1]));
        } else if (MODL->brch[ibrch].type == OCSM_SKEND) {
            fprintf(csm_file, "skend     %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_SKVAR) {
            fprintf(csm_file, "skvar     %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_SOLBEG) {
            fprintf(csm_file, "solbeg    %s\n",
                  &(MODL->brch[ibrch].arg1[1]));
        } else if (MODL->brch[ibrch].type == OCSM_SOLCON) {
            fprintf(csm_file, "solcon    %s\n",
                  &(MODL->brch[ibrch].arg1[1]));
        } else if (MODL->brch[ibrch].type == OCSM_SOLEND) {
            fprintf(csm_file, "solend\n");
        } else if (MODL->brch[ibrch].type == OCSM_SPECIAL) {
            fprintf(csm_file, "special   %s   %s   %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7,
                    MODL->brch[ibrch].arg8,
                    MODL->brch[ibrch].arg9);
        } else if (MODL->brch[ibrch].type == OCSM_SPHERE) {
            fprintf(csm_file, "sphere    %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_SPLINE) {
            fprintf(csm_file, "spline    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_SSLOPE) {
            fprintf(csm_file, "sslope    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_STORE) {
            fprintf(csm_file, "store     %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3    );
        } else if (MODL->brch[ibrch].type == OCSM_SUBTRACT) {
            fprintf(csm_file, "subtract  %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3    );
        } else if (MODL->brch[ibrch].type == OCSM_SWEEP) {
            fprintf(csm_file, "sweep\n");
        } else if (MODL->brch[ibrch].type == OCSM_THROW) {
            fprintf(csm_file, "throw     %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_TORUS) {
            fprintf(csm_file, "torus     %s   %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7,
                    MODL->brch[ibrch].arg8);
        } else if (MODL->brch[ibrch].type == OCSM_TRANSLATE) {
            fprintf(csm_file, "translate %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_UDPARG) {
            fprintf(csm_file, "udparg    %s",
                  &(MODL->brch[ibrch].arg1[1]));
            if (MODL->brch[ibrch].narg >= 3) {
                fprintf(csm_file, "   %s   %s",
                        &(MODL->brch[ibrch].arg2[1]),
                          MODL->brch[ibrch].arg3);
            }
            if (MODL->brch[ibrch].narg >= 5) {
                fprintf(csm_file, "   %s   %s",
                        &(MODL->brch[ibrch].arg4[1]),
                          MODL->brch[ibrch].arg5);
            }
            if (MODL->brch[ibrch].narg >= 7) {
                fprintf(csm_file, "   %s   %s",
                        &(MODL->brch[ibrch].arg6[1]),
                          MODL->brch[ibrch].arg7);
            }
            if (MODL->brch[ibrch].narg >= 9) {
                fprintf(csm_file, "   %s   %s",
                        &(MODL->brch[ibrch].arg8[1]),
                          MODL->brch[ibrch].arg9);
            }
            fprintf(csm_file, "\n");
        } else if (MODL->brch[ibrch].type == OCSM_UDPRIM) {
            fp_inline = NULL;           // no inline file by default

            fprintf(csm_file, "udprim    %s",
                  &(MODL->brch[ibrch].arg1[1]));
            if (MODL->brch[ibrch].narg >= 3) {
                if (strncmp(MODL->brch[ibrch].arg3, "$tmp_OpenCSM_", 13) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg2[1]));
                    fp_inline = fopen(&MODL->brch[ibrch].arg3[1], "r");
                } else {
                    fprintf(csm_file, "   %s   %s",
                            &(MODL->brch[ibrch].arg2[1]),
                              MODL->brch[ibrch].arg3);
                }
            }
            if (MODL->brch[ibrch].narg >= 5) {
                if (strncmp(MODL->brch[ibrch].arg5, "$tmp_OpenCSM_", 13) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg4[1]));
                    fp_inline = fopen(&MODL->brch[ibrch].arg5[1], "r");
                } else {
                    fprintf(csm_file, "   %s   %s",
                            &(MODL->brch[ibrch].arg4[1]),
                              MODL->brch[ibrch].arg5);
                }
            }
            if (MODL->brch[ibrch].narg >= 7) {
                if (strncmp(MODL->brch[ibrch].arg7, "$tmp_OpenCSM_", 13) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg6[1]));
                    fp_inline = fopen(&MODL->brch[ibrch].arg7[1], "r");
                } else {
                    fprintf(csm_file, "   %s   %s",
                            &(MODL->brch[ibrch].arg6[1]),
                              MODL->brch[ibrch].arg7);
                }
            }
            if (MODL->brch[ibrch].narg >= 9) {
                if (strncmp(MODL->brch[ibrch].arg9, "$tmp_OpenCSM_", 13) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg8[1]));
                    fp_inline = fopen(&MODL->brch[ibrch].arg9[1], "r");
                } else {
                    fprintf(csm_file, "   %s   %s",
                            &(MODL->brch[ibrch].arg8[1]),
                              MODL->brch[ibrch].arg9);
                }
            }
            fprintf(csm_file, "\n");

            /* write an inline file (if there is one) */
            if (fp_inline != NULL) {
                while (1) {
                    if (fgets(templine, MAX_LINE_LEN, fp_inline) == NULL) break;

                    fprintf(csm_file, "%s", templine);
                }

                fclose(fp_inline);
                fp_inline = NULL;
                fprintf(csm_file, ">>\n");
            }

            /* skip Branches within this enclosed .udc (if not writing .cpc file) */
            if (filetype != 1) {
                if (strncmp(MODL->brch[ibrch].arg1, "$/",   2) == 0 ||
                    strncmp(MODL->brch[ibrch].arg1, "$$/",  3) == 0 ||
                    strncmp(MODL->brch[ibrch].arg1, "$$$/", 4) == 0   ) {
                    jbrch = ibrch;
                    while (MODL->brch[ibrch].type   != OCSM_END                ||
                           MODL->brch[ibrch].indent != MODL->brch[jbrch].indent  ) {
                        ibrch++;
                        if (ibrch > MODL->nbrch) {
                            signalError(MODL, OCSM_INTERNAL_ERROR,
                                        "could not find matching END statement");
                            status = OCSM_INTERNAL_ERROR;
                            goto cleanup;
                        }
                    }
                }
            }
        } else if (MODL->brch[ibrch].type == OCSM_UNION) {
            fprintf(csm_file, "union     %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        }

        /* write the name of the Branch (if not the default name) */
        if (strncmp(MODL->brch[ibrch].name, "Brch_", 5) != 0) {
            fprintf(csm_file, "name      %s\n",
                    MODL->brch[ibrch].name);
        }

        /* write the Attributes for the Branch */
        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            if        (MODL->brch[ibrch].attr[iattr].type != ATTRCSYS) {
                fprintf(csm_file, "attribute %s   %s\n",
                        MODL->brch[ibrch].attr[iattr].name,
                        MODL->brch[ibrch].attr[iattr].defn);
            } else {
                fprintf(csm_file, "csystem   %s   %s\n",
                        MODL->brch[ibrch].attr[iattr].name,
                        MODL->brch[ibrch].attr[iattr].defn);
            }
        }
    }

    /* close the file */
    fprintf(csm_file, "\nend\n");
    fclose(csm_file);
    csm_file = NULL;

cleanup:
    if (csm_file  != NULL) fclose(csm_file );
    if (fp_inline != NULL) fclose(fp_inline);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmCopy - copy a MODL                                             *
 *                                                                      *
 ************************************************************************
 */

int
ocsmCopy(void   *srcModl,               /* (in)  pointer to source MODL */
         void   **newModl)              /* (out) pointer to new    MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *SRC_MODL = (modl_T*)srcModl;
    modl_T    *NEW_MODL = NULL;

    int       ibrch, iattr, istor, ipmtr, irow, icol, index, i, j;

    ROUTINE(ocsmCopy);

    /* --------------------------------------------------------------- */

    /* default return value */
    *newModl = NULL;

    /* check magic number */
    if (SRC_MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (SRC_MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* make a new MODL and initialize it */
    MALLOC(NEW_MODL, modl_T, 1);

    NEW_MODL->magic      = OCSM_MAGIC;
    NEW_MODL->checked    = 0;
    NEW_MODL->ibrch      = 0;
    NEW_MODL->nextseq    = 1;
    NEW_MODL->ngroup     = SRC_MODL->ngroup;
    NEW_MODL->recycle    = 0;
    NEW_MODL->verify     = SRC_MODL->verify;
    NEW_MODL->cleanup    = SRC_MODL->cleanup;
    NEW_MODL->dumpEgads  = SRC_MODL->dumpEgads;
    NEW_MODL->loadEgads  = SRC_MODL->loadEgads;
    NEW_MODL->printStack = SRC_MODL->printStack;
    NEW_MODL->tessAtEnd  = SRC_MODL->tessAtEnd;
    NEW_MODL->bodyLoaded = SRC_MODL->bodyLoaded;
    NEW_MODL->hasC0blend = SRC_MODL->hasC0blend;

    NEW_MODL->seltype = -1;
    NEW_MODL->selbody = -1;
    NEW_MODL->selsize =  0;
    NEW_MODL->sellist = NULL;

    NEW_MODL->level = SRC_MODL->level;
    for (i = 0; i < 11; i++) {
        NEW_MODL->scope[i] = SRC_MODL->scope[i];
    }

    NEW_MODL->filelist = NULL;
    MALLOC(NEW_MODL->filelist, char, STRLEN(SRC_MODL->filelist)+1);
    strcpy(NEW_MODL->filelist, SRC_MODL->filelist);

    NEW_MODL->nattr = 0;
    NEW_MODL->attr  = NULL;

    NEW_MODL->nstor = 0;
    NEW_MODL->stor  = NULL;

    NEW_MODL->nbrch = 0;
    NEW_MODL->mbrch = 0;
    NEW_MODL->brch  = NULL;

    NEW_MODL->npmtr = 0;
    NEW_MODL->mpmtr = 0;
    NEW_MODL->pmtr  = NULL;

    NEW_MODL->nbody = 0;
    NEW_MODL->mbody = 0;
    NEW_MODL->body  = NULL;

    NEW_MODL->perturb  = NULL;
    NEW_MODL->basemodl = NULL;
    NEW_MODL->dtime    = 0;

    NEW_MODL->context     = SRC_MODL->context;
    strcpy(NEW_MODL->eggname, SRC_MODL->eggname);
    NEW_MODL->eggGenerate = SRC_MODL->eggGenerate;
    NEW_MODL->eggMorph    = SRC_MODL->eggMorph;
    NEW_MODL->eggDump     = SRC_MODL->eggDump;
    NEW_MODL->eggLoad     = SRC_MODL->eggLoad;
    NEW_MODL->eggFree     = SRC_MODL->eggFree;

    NEW_MODL->nwarn   = 0;
    NEW_MODL->sigCode = 0;
    NEW_MODL->sigMesg = NULL;
    MALLOC(NEW_MODL->sigMesg, char, MAX_STR_LEN);
    NEW_MODL->sigMesg[0] = '\0';

    for (i = 0; i < 100; i++) {
        NEW_MODL->profile[i].ncall = SRC_MODL->profile[i].ncall;
        NEW_MODL->profile[i].time  = SRC_MODL->profile[i].time;
    }

    /* return value */
    *newModl = NEW_MODL;

    /* copy the global Parameters */
    for (iattr = 0; iattr < SRC_MODL->nattr; iattr++) {
        status = ocsmSetAttr(NEW_MODL, 0,
                             SRC_MODL->attr[iattr].name,
                             SRC_MODL->attr[iattr].defn);
    }

    /* copy the Storge locations */
    NEW_MODL->nstor = SRC_MODL->nstor;

    MALLOC(NEW_MODL->stor, stor_T, NEW_MODL->nstor);

    for (istor = 0; istor < NEW_MODL->nstor; istor++) {
        STRNCPY(NEW_MODL->stor[istor].name, SRC_MODL->stor[istor].name, MAX_NAME_LEN);

        NEW_MODL->stor[istor].index = SRC_MODL->stor[istor].index;
        NEW_MODL->stor[istor].nbody = SRC_MODL->stor[istor].nbody;
        NEW_MODL->stor[istor].ibody = NULL;
        NEW_MODL->stor[istor].ebody = NULL;

        MALLOC(NEW_MODL->stor[istor].ibody, int, NEW_MODL->stor[istor].nbody);
        MALLOC(NEW_MODL->stor[istor].ebody, ego, NEW_MODL->stor[istor].nbody);

        for (i = 0; i < NEW_MODL->stor[istor].nbody; i++) {
            NEW_MODL->stor[istor].ibody[i] = SRC_MODL->stor[istor].ibody[i];
            NEW_MODL->stor[istor].ebody[i] = SRC_MODL->stor[istor].ebody[i];
        }
    }

    /* copy the Parameter table (done before Branch table so that
       new Parameters do not get created by a OCSM_SET, OCSM_GETATTR, or OCSM_PATBEG) */

    /* make sure new Parameter is created with the correct scope */
    for (ipmtr = 1; ipmtr <= SRC_MODL->npmtr; ipmtr++) {
        for (j = 0; j < 11; j++) {
            if (SRC_MODL->scope[j] == SRC_MODL->pmtr[ipmtr].scope) {
                NEW_MODL->level = j;
                break;
            }
        }
        if        (strcmp(SRC_MODL->pmtr[ipmtr].name, "@stack") == 0) {
            status = ocsmNewPmtr(NEW_MODL,
                                 SRC_MODL->pmtr[ipmtr].name,
                                 SRC_MODL->pmtr[ipmtr].type,
                                 1,
                                 MAX_STACK_SIZE);
        } else if (strcmp(SRC_MODL->pmtr[ipmtr].name, "@edata") == 0) {
            status = ocsmNewPmtr(NEW_MODL,
                                 SRC_MODL->pmtr[ipmtr].name,
                                 SRC_MODL->pmtr[ipmtr].type,
                                 1,
                                 20);
        } else {
            status = ocsmNewPmtr(NEW_MODL,
                                 SRC_MODL->pmtr[ipmtr].name,
                                 SRC_MODL->pmtr[ipmtr].type,
                                 SRC_MODL->pmtr[ipmtr].nrow,
                                 SRC_MODL->pmtr[ipmtr].ncol);
        }
        CHECK_STATUS(ocsmNewPmtr);
        NEW_MODL->level = SRC_MODL->level;

        if (SRC_MODL->pmtr[ipmtr].value != NULL) {
            index = 0;
            for (irow = 1; irow <= SRC_MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 1; icol <= SRC_MODL->pmtr[ipmtr].ncol; icol++) {
                    NEW_MODL->pmtr[ipmtr].value[index] = SRC_MODL->pmtr[ipmtr].value[index];
                    NEW_MODL->pmtr[ipmtr].dot[  index] = SRC_MODL->pmtr[ipmtr].dot[  index];

                    if (SRC_MODL->pmtr[ipmtr].type == OCSM_EXTERNAL) {
                        NEW_MODL->pmtr[ipmtr].lbnd[ index] = SRC_MODL->pmtr[ipmtr].lbnd[ index];
                        NEW_MODL->pmtr[ipmtr].ubnd[ index] = SRC_MODL->pmtr[ipmtr].ubnd[ index];
                    }

                    index++;
                }
            }
        }
        if (SRC_MODL->pmtr[ipmtr].str != NULL) {
            strcpy(NEW_MODL->pmtr[ipmtr].str, SRC_MODL->pmtr[ipmtr].str);
        }
    }

    /* copy the Branch table */
    for (ibrch = 1; ibrch <= SRC_MODL->nbrch; ibrch++) {
        status = ocsmNewBrch(NEW_MODL,
                             NEW_MODL->nbrch,
                             SRC_MODL->brch[ibrch].type,
                             SRC_MODL->brch[ibrch].filename,
                             SRC_MODL->brch[ibrch].linenum,
                             SRC_MODL->brch[ibrch].arg1,
                             SRC_MODL->brch[ibrch].arg2,
                             SRC_MODL->brch[ibrch].arg3,
                             SRC_MODL->brch[ibrch].arg4,
                             SRC_MODL->brch[ibrch].arg5,
                             SRC_MODL->brch[ibrch].arg6,
                             SRC_MODL->brch[ibrch].arg7,
                             SRC_MODL->brch[ibrch].arg8,
                             SRC_MODL->brch[ibrch].arg9);
        CHECK_STATUS(ocsmNewBrch);

        /* restore the old sequence number (over-writing the sequence
           number incremented in ocsmNewBrch) */
        NEW_MODL->nextseq = SRC_MODL->nextseq;

        /* copy the name and Attributes */
        FREE(  NEW_MODL->brch[ibrch].name);
        MALLOC(NEW_MODL->brch[ibrch].name, char, (int)(STRLEN(SRC_MODL->brch[ibrch].name)+1));
        strcpy(NEW_MODL->brch[ibrch].name,                    SRC_MODL->brch[ibrch].name    );

        for (iattr = 0; iattr < SRC_MODL->brch[ibrch].nattr; iattr++) {
            if (SRC_MODL->brch[ibrch].attr[iattr].type != ATTRCSYS) {
                status = ocsmSetAttr(NEW_MODL, ibrch,
                                     SRC_MODL->brch[ibrch].attr[iattr].name,
                                     SRC_MODL->brch[ibrch].attr[iattr].defn);
            } else {
                status = ocsmSetCsys(NEW_MODL, ibrch,
                                     SRC_MODL->brch[ibrch].attr[iattr].name,
                                     SRC_MODL->brch[ibrch].attr[iattr].defn);
            }
        }
    }

    /* set the Branch's activity and link to the other Branches */
    for (ibrch = 1; ibrch <= SRC_MODL->nbrch; ibrch++) {
        NEW_MODL->brch[ibrch].actv  = SRC_MODL->brch[ibrch].actv;
        NEW_MODL->brch[ibrch].ileft = SRC_MODL->brch[ibrch].ileft;
        NEW_MODL->brch[ibrch].irite = SRC_MODL->brch[ibrch].irite;
        NEW_MODL->brch[ibrch].ichld = SRC_MODL->brch[ibrch].ichld;
    }

    /* do NOT copy the Body table */

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmFree - free all storage associated with a MODL                 *
 *                                                                      *
 ************************************************************************
 */

int
ocsmFree(
/*@null@*/void   *modl)                 /* (in)  pointer to MODL (or NULL) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       itmp, ibrch, iattr, iface, istor, ipmtr, ibody;
    char      tmpfilename[MAX_EXPR_LEN];

    ROUTINE(ocsmFree);

    /* --------------------------------------------------------------- */

    /* if modl is NULL, then we are cleaning up tmp files and
       the udp cache */
    if (MODL == NULL) {

        /* clean up tmp files */
        for (itmp = 0; itmp < 999; itmp++) {
            if (sprintf(tmpfilename, "tmp_OpenCSM_%03d", itmp) < 0) {
                break;
            }

            if (remove(tmpfilename) == 0) {
                SPRINT1(1, "--> tmp file \"%s\" removed", tmpfilename);
            }
        }

        /* clean the udp cache */
        udp_cleanupAll();

        goto cleanup;
    }

    /* check magic number */
    if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* free up the Body table */
    for (ibody = 1; ibody <= MODL->mbody; ibody++) {
        if (MODL->body[ibody].etess != NULL) {
            status = EG_deleteObject(MODL->body[ibody].etess);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].etess = NULL;
        }

        ibrch = MODL->body[ibody].ibrch;
        if (ibrch > 0 && ibrch <= MODL->nbrch) {
            if (MODL->brch[ibrch].type == OCSM_UDPRIM) {
                status = udp_clean(MODL->body[ibody].arg[1].str, MODL->body[ibody].ebody);
                if (status == EGADS_NOTFOUND || status == EGADS_NOTMODEL) {
                    /* this means that some other Body probably cleaned up this udp
                       or that this is a user-defined component (udc) */
                } else {
                    CHECK_STATUS(udp_clean);
                }
            }
        }

        if (MODL->body[ibody].ebody != NULL) {
            /* ignore "dereference with active objects" message and/or any errors
               that may occur since this happens for Bodys that are restored */
            (void) EG_setOutLevel(MODL->context, 0);
            (void) EG_deleteObject(MODL->body[ibody].ebody);
            (void) EG_setOutLevel(MODL->context, outLevel);

            MODL->body[ibody].ebody = NULL;
        }

        status = removeVels(MODL, ibody);
        CHECK_STATUS(removeVels);

        if (MODL->body[ibody].face != NULL) {
            for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                if (MODL->body[ibody].face[iface].eggdata != NULL) {
                    status = MODL->eggFree(MODL->body[ibody].face[iface].eggdata);
                    CHECK_STATUS(eggFree);
                }
            }
        }

        status = freeBody(MODL, ibody);
        CHECK_STATUS(freeBody);
//$$$
//$$$        if (MODL->body[ibody].sens != 0) {
//$$$            SPRINT1(2, "resetting .sens for ibody=%d", ibody);
//$$$
//$$$            status = EG_setGeometry_dot(MODL->body[ibody].ebody, 0, 0,  NULL, NULL, NULL);
//$$$            CHECK_STATUS(EG_setGeometry_dot);
//$$$
//$$$            MODL->body[ibody].sens = 0;
//$$$        }
    }

    FREE(MODL->body);

    /* free up the Parameter table */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        FREE(MODL->pmtr[ipmtr].name );
        FREE(MODL->pmtr[ipmtr].value);
        FREE(MODL->pmtr[ipmtr].dot  );
        FREE(MODL->pmtr[ipmtr].lbnd );
        FREE(MODL->pmtr[ipmtr].ubnd );
        FREE(MODL->pmtr[ipmtr].str  );
    }

    FREE(MODL->pmtr);

    /* free up the Branch table */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            FREE(MODL->brch[ibrch].attr[iattr].name);
            FREE(MODL->brch[ibrch].attr[iattr].defn);
        }

        FREE(MODL->brch[ibrch].name    );
        FREE(MODL->brch[ibrch].filename);
        FREE(MODL->brch[ibrch].attr    );
        FREE(MODL->brch[ibrch].arg1    );
        FREE(MODL->brch[ibrch].arg2    );
        FREE(MODL->brch[ibrch].arg3    );
        FREE(MODL->brch[ibrch].arg4    );
        FREE(MODL->brch[ibrch].arg5    );
        FREE(MODL->brch[ibrch].arg6    );
        FREE(MODL->brch[ibrch].arg7    );
        FREE(MODL->brch[ibrch].arg8    );
        FREE(MODL->brch[ibrch].arg9    );
    }

    FREE(MODL->brch);

    /* free up the selection list */
    MODL->selsize = 0;
    FREE(MODL->sellist);

    /* free up the global Attributes */
    for (iattr = 0; iattr < MODL->nattr; iattr++) {
        FREE(MODL->attr[iattr].name);
        FREE(MODL->attr[iattr].defn);
    }
    FREE(MODL->attr);

    /* free up the Storage table */
    for (istor = 0; istor < MODL->nstor; istor++) {
        FREE(MODL->stor[istor].ibody);
        FREE(MODL->stor[istor].ebody);
    }
    FREE(MODL->stor);

    /* free up the message buffer */
    FREE(MODL->sigMesg);

    /* free up the file list */
    FREE(MODL->filelist);

    /* free up the MODL structure */
    FREE(MODL);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmInfo - get info about a MODL                                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmInfo(void   *modl,                  /* (in)  pointer to MODL */
         int    *nbrch,                 /* (out) number of Branches */
         int    *npmtr,                 /* (out) number of Parameters */
         int    *nbody)                 /* (out) number of Bodys */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmInfo);

    /* --------------------------------------------------------------- */

    /* default return values */
    *nbrch = -1;
    *npmtr = -1;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* return values */
    *nbrch = MODL->nbrch;
    *npmtr = MODL->npmtr;
    *nbody = MODL->nbody;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmCheck - check that Branches are properly ordered               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmCheck(void   *modl)                 /* (in)  pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ibrch, ipass, indent;
    int       inest[MAX_NESTING], jnest, nnest, ifound;

    ROUTINE(ocsmCheck);

    /* --------------------------------------------------------------- */

    SPRINT0(1, "--> enter ocsmCheck()");

    /* initially there are no errors */
    ipass = 0;

    /* clear the signals */
    MODL->nwarn      = 0;
    MODL->sigCode    = 0;
    MODL->sigMesg[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        signalError(MODL, OCSM_NOT_MODL_STRUCTURE,
                    "");
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        signalError(MODL, OCSM_NOT_MODL_STRUCTURE,
                    "");
        goto cleanup;
    }

    /* if we have already checked, just return */
    if (MODL->checked == 1) {
        goto cleanup;
    }

    /* make sure Blocks of Branches are properly nested */
    nnest = 0;

    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        MODL->ibrch = ibrch;

        if        (MODL->brch[ibrch].type == OCSM_PATBEG) {
            if (nnest >= MAX_NESTING) {
                signalError(MODL, OCSM_NESTED_TOO_DEEPLY,
                            "can only be nested %d levels deep", MAX_NESTING);
                goto cleanup;
            }

            inest[nnest++] = OCSM_PATBEG;
        } else if (MODL->brch[ibrch].type == OCSM_PATBREAK) {
            ifound = 0;
            for (jnest = nnest-1; jnest >= 0; jnest--) {
                if (inest[jnest] == OCSM_PATBEG) {
                    ifound++;
                    break;
                }
            }

            if (ifound == 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATBREAK is improperly nested");
                goto cleanup;
            }
        } else if (MODL->brch[ibrch].type == OCSM_PATEND) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATEND is improerly nested");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_PATBEG) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATEND is improperly nested");
                goto cleanup;
            }

            nnest--;
        } else if (MODL->brch[ibrch].type == OCSM_IFTHEN) {
            if (nnest >= MAX_NESTING) {
                signalError(MODL, OCSM_NESTED_TOO_DEEPLY,
                            "can only be nested %d levels deep", MAX_NESTING);
                goto cleanup;
            }

            inest[nnest++] = OCSM_IFTHEN;
        } else if (MODL->brch[ibrch].type == OCSM_ELSEIF) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ELSEIF is improperly nested");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_IFTHEN) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ELSEIF is improperly nested");
                goto cleanup;
            }
        } else if (MODL->brch[ibrch].type == OCSM_ELSE) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ELSE is improperly nested");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_IFTHEN) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ELSE is improperly nested");
                goto cleanup;
            }

            inest[nnest-1] = OCSM_ELSE;
        } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ENDIF is improperly nested");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_IFTHEN &&
                       inest[nnest-1] != OCSM_ELSE     ) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ENDIF is improperly nested");
                goto cleanup;
            }

            nnest--;
        } else if (MODL->brch[ibrch].type == OCSM_CATBEG) {
            if (nnest >= MAX_NESTING) {
                signalError(MODL, OCSM_NESTED_TOO_DEEPLY,
                            "can only be nested %d levels deep", MAX_NESTING);
                goto cleanup;
            }

            inest[nnest++] = OCSM_CATBEG;
        } else if (MODL->brch[ibrch].type == OCSM_CATEND) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "CATEND is improperly nested");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_CATBEG) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "CATEND is improperly nested");
                goto cleanup;
            }

            nnest--;
        }
    }

    if (nnest > 0) {
        signalError(MODL, OCSM_NESTING_NOT_CLOSED,
                    "%d block(s) are still open", nnest);
        goto cleanup;
    }

    /* initialize all indentation and parent/child relationships */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        MODL->brch[ibrch].indent = -1;
        MODL->brch[ibrch].ileft  = -2;
        MODL->brch[ibrch].irite  = -2;
        MODL->brch[ibrch].ichld  = -2;
    }

    /* set up the indentation */
    indent = 0;

    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {

        /* decrease indentation at the end of a block */
        if        (MODL->brch[ibrch].type == OCSM_MACEND   ||
                   MODL->brch[ibrch].type == OCSM_PATBREAK ||
                   MODL->brch[ibrch].type == OCSM_PATEND   ||
                   MODL->brch[ibrch].type == OCSM_ELSEIF   ||
                   MODL->brch[ibrch].type == OCSM_ELSE     ||
                   MODL->brch[ibrch].type == OCSM_ENDIF    ||
                   MODL->brch[ibrch].type == OCSM_CATEND   ||
                   MODL->brch[ibrch].type == OCSM_SKEND    ||
                   MODL->brch[ibrch].type == OCSM_SOLEND   ||
                   MODL->brch[ibrch].type == OCSM_END        ) {
            indent--;
        }

        if (indent < 0) {
            SPRINT0(1, "WARNING:: fixing indentation");
            (MODL->nwarn)++;
            indent = 0;
        }

        /* set the indentation */
        MODL->brch[ibrch].indent = indent;

        /* increase indentation at the beginning of a block */
        if        (MODL->brch[ibrch].type == OCSM_MACBEG   ||
                   MODL->brch[ibrch].type == OCSM_PATBEG   ||
                   MODL->brch[ibrch].type == OCSM_PATBREAK ||
                   MODL->brch[ibrch].type == OCSM_IFTHEN   ||
                   MODL->brch[ibrch].type == OCSM_ELSEIF   ||
                   MODL->brch[ibrch].type == OCSM_ELSE     ||
                   MODL->brch[ibrch].type == OCSM_CATBEG   ||
                   MODL->brch[ibrch].type == OCSM_SKBEG    ||
                   MODL->brch[ibrch].type == OCSM_SOLBEG     ) {
            indent++;
        } else if (MODL->brch[ibrch].type    == OCSM_UDPRIM &&
                   MODL->brch[ibrch].arg1[1] == '/'           ) {
            indent++;
        } else if (MODL->brch[ibrch].type    == OCSM_UDPRIM &&
                   MODL->brch[ibrch].arg1[1] == '$'         &&
                   MODL->brch[ibrch].arg1[2] == '/'           ) {
            indent++;
        } else if (MODL->brch[ibrch].type    == OCSM_UDPRIM &&
                   MODL->brch[ibrch].arg1[1] == '$'         &&
                   MODL->brch[ibrch].arg1[2] == '$'         &&
                   MODL->brch[ibrch].arg1[3] == '/'           ) {
            indent++;
        }
    }

    /* warn if improper nesting was found */
    if (indent == 1 && MODL->brch[MODL->nbrch].type != OCSM_END) {
        /* okay */
    } else if (indent != 0) {
        SPRINT1(1, "WARNING:: indent=%d, but should be 0", indent);
        (MODL->nwarn)++;
    }

    /* MODL has passed all checks */
    MODL->checked = 1;

cleanup:
    if (MODL->checked == 1) {
        SPRINT0(1, "--> checks passed");
    } else {
        SPRINT0(1, "--> checks failed");

        /* mark the Branch after the last one that passed as the Branch with the error */
        if (ipass < MODL->nbrch) {
            MODL->brch[ipass+1].ileft = -2;
        } else {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "");
        }
    }

    status = MODL->sigCode;

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmBuild - build Bodys by executing the MODL up to a given Branch *
 *                                                                      *
 ************************************************************************
 */

int
ocsmBuild(void   *modl,                 /* (in)  pointer to MODL */
          int    buildTo,               /* (in)  last Branch to execute (or 0 for all, or -1 for no recycling) */
          int    *builtTo,              /* (out) last Branch executed successfully */
          int    *nbody,                /* (in)  number of entries allocated in body[] */
                                        /* (out) number of Bodys on the stack if body!=NULL*/
/*@null@*/int    body[])                /* (out) array  of Bodys on the stack (LIFO)
                                                 (at least *nbody long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    /* stack contains Body indices, Sketch indices (if negative), or 0 for MARKs */
    int       nstack, nstackSave, *stack=NULL, nbodySave;

    /* Sketch contains linsegs, cirarcs, splines, and beziers */
    sket_T    *sket=NULL;

    /* storage loaction information */
    int        imacro, *macros=NULL;

    /* pattern information */
    int        npatn, npatn_sig, bool1, bool2, bool3;
    patn_T     *patn=NULL;
    double     newValue;

    /* solver information */
    int        nsolvar, nsolcon;
    int        *solvars=NULL, *solcons=NULL;

    /* select/sort information */
    int       nobjs, ient, ipass, nswap, iswap;
    double    rswap, *props=NULL, bbox[6];
    ego       *eobjs;

    int        ibrch, jbrch, type, ibrchl, i, j, iface, iedge, inode, nbodyMax;
    int        iattr, ipmtr, jpmtr, istor, jstor, icount, nmacro, ntemp, jstack, verify, icatch;
    int        ibody, jbody, jface, ibodyl, irow, nrow, icol, ncol, indx, itype, nlist, ilist, jlist,total_call;
    int        *iblist=NULL, nblist, count, iseq;
    varg_T     args[10];
    double     toler, value, dot, *values=NULL, *dots=NULL, *vels=NULL;
    char       pname[MAX_EXPR_LEN], pmtrName[MAX_EXPR_LEN], thisArg[MAX_LINE_LEN], str[MAX_STRVAL_LEN], temp[MAX_STRVAL_LEN];

    CINT       *tempIlist;
    CDOUBLE    *tempRlist, *Vels;
    CCHAR      *tempClist, *aname;

    int        imajor, iminor, iarg, ival, hasdots, istack, igroup, ngroup, nattr;
    int        ibest, npnt, ipnt, ntri, itri, AT_iedge, AT_iface, AT_xcg, AT_ycg, AT_zcg;
    int        match1, match2, match3, periodic, iter;
    CINT       *ptype, *pindx, *tris, *tric;
    double     tbest, xbest, ybest, zbest, dbest, dtest;
    double     u0, v0, x0, y0, z0, u1, v1, x1, y1, z1, u2, v2, x2, y2, z2, s0, s1, tt, mat[9], rhs[3], res[3], sval[3], s0s1tt[3];
    double     xyz_[3], uv_[3], data[18], uvrange[4], duvt[3], dmin;
    CDOUBLE    *xyz, *uv;
    char       dumpfile[MAX_EXPR_LEN], *extension;
    CCHAR      *OC_ver;
    FILE       *fp;
    ego        ebodyl, ebody, emodel, *etemp=NULL, enode, eedge, eface, eobj;
    clock_t    old_time, new_time, total_time;

    ROUTINE(ocsmBuild);

#define CATCH_STATUS(X)                                                 \
    if (status < SUCCESS) {                                             \
        MODL->sigCode = status;                                         \
        printf( "ERROR:: build terminated early due to BAD STATUS = %d (%s) from %s (called from %s:%d)\n", status, ocsmGetText(status), #X, routine, __LINE__); \
        goto finalize;                                                  \
    }

    /* --------------------------------------------------------------- */

    SPRINT1(1, "--> enter ocsmBuild(buildTo=%d)", buildTo);

    for (iarg = 1; iarg < 10; iarg++) {
        args[iarg].val = NULL;
        args[iarg].dot = NULL;
    }

    /* clear the signals */
    MODL->nwarn      = 0;
    MODL->sigCode    = 0;
    MODL->sigMesg[0] = '\0';

    MODL->ibrch      = 0;

    MALLOC(stack,   int,    MAX_STACK_SIZE);
    MALLOC(macros,  int,    MAX_NUM_MACROS+1);
    MALLOC(patn,    patn_T, MAX_NESTING);
    MALLOC(sket,    sket_T, 1);
    MALLOC(solvars, int,    MAX_SOLVER_SIZE);
    MALLOC(solcons, int,    MAX_SOLVER_SIZE);

    *builtTo = 0;
    nbodyMax = *nbody;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if MODL is not checked already, do it now (since checking a MODL
       has side-effects that are needed during build process) */
    if (MODL->checked != 1) {
        status = ocsmCheck(MODL);
        CHECK_STATUS(ocsmCheck);
    }

    /* defer all active Branches within macro definitions */
    nmacro = 0;
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        if (MODL->brch[ibrch].actv == OCSM_ACTIVE && nmacro > 0) {
            MODL->brch[ibrch].actv = OCSM_DEFERRED;
        }
        if        (MODL->brch[ibrch].type == OCSM_MACBEG) {
            nmacro++;
        } else if (MODL->brch[ibrch].type == OCSM_MACEND) {
            nmacro--;
        }
    }

    /* initialize all parent/child flags for Branches */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        MODL->brch[ibrch].ileft = -2;
        MODL->brch[ibrch].irite = -2;
        MODL->brch[ibrch].ichld = -2;
    }

    EG_revision(&imajor, &iminor, &OC_ver);
    if (strstr(OC_ver, "Interim") == NULL) {
        SPRINT3(1, "\n    EGADS version %2d.%02d (with %s)\n", imajor, iminor, &(OC_ver[5]));
    } else {
        SPRINT3(1, "\n    Interim EGADS version %2d.%02d (with %s)\n", imajor, iminor, &(OC_ver)[20]);
    }

    /* create a new EGADS context (if not already set) */
    if (MODL->context == NULL) {
        status = EG_open(&(MODL->context));
        CHECK_STATUS(EG_open);
    }

    status = EG_setOutLevel(MODL->context, outLevel);
    CHECK_STATUS(EG_setOutLevel);

    /* store the MODL pointer in the context */
    status = EG_setUserPointer(MODL->context, (void*)MODL);
    CHECK_STATUS(EG_setUserPointer);

    /* set the global level */
    MODL->level = 0;
    MODL->scope[MODL->level] = 0;

    /* reset the number of Groups */
    MODL->ngroup = 0;

    /* reset the last Body loaded from a Body_*.egads file */
    MODL->bodyLoaded = 0;

    /* reset the storage */
    for (istor = 0; istor < MODL->nstor; istor++) {
        FREE(MODL->stor[istor].ibody);
        FREE(MODL->stor[istor].ebody);
    }
    FREE(MODL->stor);
    MODL->nstor = 0;

    /* remove internal Parameters that may be left over from a failure
          in a Sketch that was being solved */
    status = delPmtrByName(MODL, "::d");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::z");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::y");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::x");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = SUCCESS;

    /* errors if any EXTERNAL Parameters are out of bounds.  this can
       only happen based upon values in the .csm file */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  != OCSM_EXTERNAL) continue;

        indx = 0;
        for (irow = 0; irow < MODL->pmtr[ipmtr].nrow; irow++) {
            for (icol = 0; icol < MODL->pmtr[ipmtr].ncol; icol++) {
                if (MODL->pmtr[ipmtr].value[indx] < MODL->pmtr[ipmtr].lbnd[indx]) {
                    status = OCSM_ILLEGAL_VALUE;
                    signalError(MODL, status,
                                "value of %s (%f) is lower  than lower bound (%f)",
                                MODL->pmtr[ipmtr].name,
                                MODL->pmtr[ipmtr].value[indx],
                                MODL->pmtr[ipmtr].lbnd[ indx]);
                    *builtTo = -99999;
                    SET_STATUS(status, despmtr);
                }

                if (MODL->pmtr[ipmtr].value[indx] > MODL->pmtr[ipmtr].ubnd[indx]) {
                    status = OCSM_ILLEGAL_VALUE;
                    signalError(MODL, status,
                                "value of %s (%f) is higher than upper bound (%f)",
                                MODL->pmtr[ipmtr].name,
                                MODL->pmtr[ipmtr].value[indx],
                                MODL->pmtr[ipmtr].ubnd[ indx]);
                    *builtTo = -99999;
                    SET_STATUS(status, despmtr);
                }

                indx++;
            }
        }
    }

    /* reinitailize values of all OUTPUT Parameters */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  != OCSM_OUTPUT) continue;

        if (MODL->pmtr[ipmtr].str != NULL) {
            MODL->pmtr[ipmtr].str[0] = '\0';
        } else {
            indx = 0;
            for (irow = 0; irow < MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 0; icol < MODL->pmtr[ipmtr].ncol; icol++) {
                    MODL->pmtr[ipmtr].value[indx] = -HUGEQ;
                    indx++;
                }
            }
        }
    }

    /* convert any internal Parameters (other than @edata and @stack) that are a matrix or
       has a string value into a scalar (so that rebuilding will start with
       exactly the same assumptions as the first build) */
    for (ipmtr = MODL->npmtr; ipmtr > 0; ipmtr--) {
        if (MODL->pmtr[ipmtr].type != OCSM_INTERNAL &&
            MODL->pmtr[ipmtr].type != OCSM_OUTPUT     ) continue;

        if (strcmp(MODL->pmtr[ipmtr].name, "@edata") == 0 ||
            strcmp(MODL->pmtr[ipmtr].name, "@stack") == 0   ) continue;

        if        (MODL->pmtr[ipmtr].nrow >  1 || MODL->pmtr[ipmtr].ncol >  1) {
            if (strcmp(MODL->pmtr[ipmtr].name, "@sellist") != 0) {
                SPRINT1(1, "INFO:: %s is a vector and is being converted to scalar", MODL->pmtr[ipmtr].name);
            }
            MODL->pmtr[ipmtr].nrow = 1;
            MODL->pmtr[ipmtr].ncol = 1;
        } else if (MODL->pmtr[ipmtr].nrow == 0 || MODL->pmtr[ipmtr].ncol == 0) {
            SPRINT1(1, "INFO:: %s is a string and is being converted to scalar", MODL->pmtr[ipmtr].name);
            FREE(MODL->pmtr[ipmtr].str);

            MALLOC(MODL->pmtr[ipmtr].value, double, 1);
            MALLOC(MODL->pmtr[ipmtr].dot,   double, 1);

            MODL->pmtr[ipmtr].value[0] = -HUGEQ;
            MODL->pmtr[ipmtr].dot[  0] = 0;

            if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL ||
                MODL->pmtr[ipmtr].type == OCSM_CONFIG     ) {
                MALLOC(MODL->pmtr[ipmtr].lbnd,  double, 1);
                MALLOC(MODL->pmtr[ipmtr].ubnd,  double, 1);

                MODL->pmtr[ipmtr].lbnd[ 0] = -HUGEQ;
                MODL->pmtr[ipmtr].ubnd[ 0] = +HUGEQ;
            }

            MODL->pmtr[ipmtr].nrow = 1;
            MODL->pmtr[ipmtr].ncol = 1;
        }
    }

    /* initialize the hasdots flag for all Bodys */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        MODL->body[ibody].hasdots = 0;
    }

    /* reset the loadEgads flag */
    MODL->loadEgads = abs(MODL->loadEgads);

    /* if buildTo was set to -1, mark all Branches as being dirty */
    if (buildTo == -1) {
        for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
            MODL->brch[ibrch].dirty = 1;
        }

        buildTo = 0;
    }

    /* find the first Body that has to be regenerated, because its
       Branch is dirty */
    MODL->recycle = 0;
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        ibrch = MODL->body[ibody].ibrch;
        if (MODL->nbrch == 0 || ibrch == 0 || ibrch > MODL->nbrch || MODL->brch[ibrch].dirty > 0) {

            /* free up all Bodys starting at ibody */
            for (jbody = ibody; jbody <= MODL->nbody; jbody++) {

                status = removeVels(MODL, jbody);
                CHECK_STATUS(removeVels);

                for (jface = 1; jface <= MODL->body[jbody].nface; jface++) {
                    if (MODL->body[jbody].face[jface].eggdata != NULL) {
                        status = MODL->eggFree(MODL->body[jbody].face[jface].eggdata);
                        CHECK_STATUS(eggFree);
                    }
                }

                status = freeBody(MODL, jbody);
                CHECK_STATUS(freeBody);

//$$$                if (MODL->body[jbody].sens != 0) {
//$$$                    SPRINT1(2, "resetting .sens for jbody=%d", jbody);
//$$$
//$$$                    status = EG_setGeometry_dot(MODL->body[jbody].ebody, 0, 0, NULL, NULL, NULL);
//$$$                    CHECK_STATUS(EG_setGeometry_dot);
//$$$
//$$$                    MODL->body[jbody].sens = 0;
//$$$                }
//$$$
                if (MODL->body[jbody].etess != NULL) {
                    status = EG_deleteObject(MODL->body[jbody].etess);
                    CHECK_STATUS(EG_deleteObject);

                    MODL->body[jbody].etess = NULL;
                }

                if (MODL->body[jbody].ebody != NULL) {
                    status = EG_deleteObject(MODL->body[jbody].ebody);
                    if (status == EGADS_EMPTY) status = SUCCESS;
                    CHECK_STATUS(EG_deleteObject);

                    MODL->body[jbody].ebody = NULL;
                }
            }

            /* remove any .ichld pointers to any Bodys at
               ibody or beyond */
            for (jbody = 1; jbody <= MODL->nbody; jbody++) {
                if (MODL->body[jbody].ichld >= ibody) {
                    MODL->body[jbody].ichld = 0;
                }
            }

            break;
        }
        MODL->recycle = ibody;
    }
    MODL->nbody = 0;

    /* any Body after ibody should be freed */
    for (jbody = MODL->recycle+1; jbody <= MODL->mbody; jbody++) {
        status = freeBody(MODL, jbody);
        CHECK_STATUS(freeBody);
    }

    /* initialize the stack */
    nstack = 0;

    /* initialize the number of active Sketch points (and constraints) */
    sket->type   = 0;
    sket->size   = 0;
    sket->solved = 1;
    sket->nseg   = 0;
    sket->nvar   = 0;
    sket->ncon   = 0;

    /* initiailze the number of nested patterns and the number of
       patterns when a signal was detected */
    npatn     = 0;
    npatn_sig = -1;

    /* initialize the number of solver constraints */
    nsolvar = 0;
    nsolcon = 0;

    /* initialize the storage locations */
    for (imacro = 1; imacro <= MAX_NUM_MACROS; imacro++) {
        macros[imacro] = -1;
    }

    /* initialize the arguments */
    for (iarg = 1; iarg < 10; iarg++) {
        args[iarg].nval = -1;
        args[iarg].nrow =  0;
        args[iarg].ncol =  0;
        args[iarg].val  = NULL;
        args[iarg].dot  = NULL;
    }

    /* if buildTo was set to zero, reset it (locally) to be greater
       then MODL->nbrch */
    if (buildTo == 0) {
        buildTo = MODL->nbrch + 1;
    }

    #ifdef PRINT_FAULTS
    {
        struct rusage myUsage;
        getrusage(RUSAGE_SELF, &myUsage);
        old_minfaults = myUsage.ru_minflt;
        old_majfaults = myUsage.ru_majflt;
    }
    #endif

    /* loop through and process all the Branches (up to buildTo) */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        nstackSave = nstack;
        nbodySave  = MODL->nbody;

        type = MODL->brch[ibrch].type;

        MODL->ibrch = ibrch;

        /* exit if we exceeded buildTo */
        if (ibrch > buildTo) {
            break;
        }

        /* if Branch is deferred, mark it as active but skip it for now */
        if (MODL->brch[ibrch].actv == OCSM_DEFERRED) {
            MODL->brch[ibrch].actv =  OCSM_ACTIVE;
            SPRINT1(1, "    deferring [%4d]:", ibrch);
            continue;
        }

        /* skip this Branch if it is not active */
        if (MODL->brch[ibrch].actv != OCSM_ACTIVE) {
            SPRINT1(1, "    skipping  [%4d]:", ibrch);
            continue;
        }

        /* if there is an uncaught signal, determine what to do with
           it.  note: checking if CATBEG matches the signal is done during
           the execution of the CATBEG */
        if (MODL->sigCode != 0) {

            /* if this is the first time we have seen the signal, remember the
               number of entries in the pattern table */
            if (npatn_sig == -1) {
                npatn_sig = npatn;
            }

            /* if this is the beginning of a block, add it to the pattern list */
            if        (type == OCSM_PATBEG ||
                       type == OCSM_IFTHEN ||
                       type == OCSM_RECALL   ) {
                if (npatn < MAX_NESTING) {
                    patn[npatn].itype = type;
                    patn[npatn].ibeg  = ibrch;
                    npatn++;
                    continue;
                } else {
                    status = OCSM_NESTED_TOO_DEEPLY;
                    signalError(MODL, status,
                                "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                    SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
                }

            /* if this is the beginning of a UDC, add it to the pattern list */
            } else if (type == OCSM_UDPRIM) {
                if ((MODL->brch[ibrch].arg1[1] >= 'a' && MODL->brch[ibrch].arg1[1] <= 'z') ||
                    (MODL->brch[ibrch].arg1[1] >= 'A' && MODL->brch[ibrch].arg1[1] <= 'Z')   ) {
                    continue;
                } else if (npatn < MAX_NESTING) {
                    patn[npatn].itype = type;
                    patn[npatn].ibeg  = ibrch;
                    npatn++;
                    continue;
                } else {
                    status = OCSM_NESTED_TOO_DEEPLY;
                    signalError(MODL, status,
                                "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                    SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
                }

            /* if this is the end of a block, remove it from the pattern list */
            } else if (type == OCSM_PATEND ||
                       type == OCSM_ENDIF  ||
                       type == OCSM_MACEND ||
                       type == OCSM_END      ) {
                npatn--;
                npatn_sig = MIN(npatn_sig, npatn);
                continue;

            /* if this is a CATBEG but we are in a block that was entered
               after the signal was created, skip the CATBEG */
            } else if (type == OCSM_CATBEG && npatn > npatn_sig) {
                continue;

            /* otherwise if this is not a CATBEG, go to the next Branch */
            } else if (type != OCSM_CATBEG) {
                continue;
            }
        }

        /* if this is an executable Sketch statement and we need
           to solve the Sketch, do it before interpreting the
           arguments and velocities */
        if (type == OCSM_LINSEG || type == OCSM_CIRARC ||
            type == OCSM_ARC    || type == OCSM_SPLINE ||
            type == OCSM_SSLOPE || type == OCSM_BEZIER   ) {
            status = solveSketch(MODL, sket);

            /* if the solver did not work, remove the Body associated with
               skbeg */
            if (status < SUCCESS) {
                (MODL->nbody)--;
            }

            CATCH_STATUS(solveSketch);
        }

        SPRINT1x(3, "----------%s", ocsmGetText(type));
        if (MODL->brch[ibrch].narg >= 1) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg1);}
        if (MODL->brch[ibrch].narg >= 2) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg2);}
        if (MODL->brch[ibrch].narg >= 3) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg3);}
        if (MODL->brch[ibrch].narg >= 4) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg4);}
        if (MODL->brch[ibrch].narg >= 5) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg5);}
        if (MODL->brch[ibrch].narg >= 6) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg6);}
        if (MODL->brch[ibrch].narg >= 7) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg7);}
        if (MODL->brch[ibrch].narg >= 8) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg8);}
        if (MODL->brch[ibrch].narg >= 9) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg9);}
        SPRINT0(3, "----------");

        /* get the values for the arguments and velocities */
        for (iarg = 1; iarg < 10; iarg++) {
            args[iarg].nval = -1;
            args[iarg].nrow =  0;
            args[iarg].ncol =  0;

            if (iarg > MODL->brch[ibrch].narg) continue;

                                  thisArg[0] = '\0';
            if (iarg == 1) strcpy(thisArg, MODL->brch[ibrch].arg1);
            if (iarg == 2) strcpy(thisArg, MODL->brch[ibrch].arg2);
            if (iarg == 3) strcpy(thisArg, MODL->brch[ibrch].arg3);
            if (iarg == 4) strcpy(thisArg, MODL->brch[ibrch].arg4);
            if (iarg == 5) strcpy(thisArg, MODL->brch[ibrch].arg5);
            if (iarg == 6) strcpy(thisArg, MODL->brch[ibrch].arg6);
            if (iarg == 7) strcpy(thisArg, MODL->brch[ibrch].arg7);
            if (iarg == 8) strcpy(thisArg, MODL->brch[ibrch].arg8);
            if (iarg == 9) strcpy(thisArg, MODL->brch[ibrch].arg9);

            if        (iarg == 1 && type == OCSM_SET) {      // allows comma in a[1,2]
                STRNCPY(str, &(thisArg[1]), MAX_STRVAL_LEN);
            } else if (iarg == 4 && type == OCSM_SKCON) {    // delays parse of constraint
                STRNCPY(str, &(thisArg[1]), MAX_STRVAL_LEN);
            } else if (iarg == 1 && type == OCSM_SOLCON) {   // delays parse of constraint
                STRNCPY(str, &(thisArg[1]), MAX_STRVAL_LEN);
            } else if (iarg >  4 && type == OCSM_IFTHEN) {   // allows for lazy evaluations
                break;
            } else if (iarg >  4 && type == OCSM_ELSEIF) {   // allows for lazy evaluations
                break;
            } else {
                status = str2vals(thisArg, MODL, &(args[iarg].nrow), &(args[iarg].ncol), &values, &dots, str);

                if (status < SUCCESS) {
                    SPRINT4(0, "ERROR:: problem evaluating argument %d (%s) for Branch %d (%s)",
                           iarg, thisArg, ibrch, ocsmGetText(MODL->brch[ibrch].type));
                    FREE(values);
                    FREE(dots  );
                    goto next_branch;
                }
            }

            if (STRLEN(str) > 0) {
                FREE(args[iarg].str);
                MALLOC(args[iarg].str, char, MAX_STRVAL_LEN);

                args[iarg].nval = 0;
                STRNCPY(args[iarg].str, str, MAX_STRVAL_LEN);
            } else {
                args[iarg].nval = (args[iarg].nrow) * (args[iarg].ncol);

                FREE(  args[iarg].val);   /* also free's .str since they are unioned */
                MALLOC(args[iarg].val, double, args[iarg].nval);

                FREE(  args[iarg].dot);
                MALLOC(args[iarg].dot, double, args[iarg].nval);

                for (i = 0; i < args[iarg].nval; i++) {
                    args[iarg].val[i] = values[i];
                    args[iarg].dot[i] = dots[  i];
                }
            }

            FREE(values);
            FREE(dots  );
        }

        /* make sure that there is enough room on the stack */
        if (nstack >= MAX_STACK_SIZE-1) {
            status = OCSM_TOO_MANY_BODYS_ON_STACK;
            goto cleanup;
        }

        MODL->brch[ibrch].ileft = -1;
        MODL->brch[ibrch].irite = -1;
        MODL->brch[ibrch].ichld = -1;

        /* execute Branch ibrch */
        old_time = clock();

        if        (MODL->brch[ibrch].bclass == OCSM_PRIMITIVE) {
            status = buildPrimitive(MODL, ibrch, args, &nstack, stack, npatn, patn);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildPrimitive);

            if ( MODL->brch[ibrch].type == OCSM_UDPRIM) {
                if (MODL->brch[ibrch].arg1[1] == '/' ||
                    MODL->brch[ibrch].arg1[1] == '$'   ) {
                    if (npatn < MAX_NESTING) {
                        patn[npatn].itype = OCSM_UDPRIM;
                        patn[npatn].ibeg  = ibrch;
                        npatn++;
                    } else {
                        status = OCSM_NESTED_TOO_DEEPLY;
                        signalError(MODL, status,
                                    "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                        SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
                    }
                }
            }
        } else if (MODL->brch[ibrch].bclass == OCSM_GROWN) {
            status = buildGrown(MODL, ibrch, args, &nstack, stack, npatn, patn);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildGrown);
        } else if (MODL->brch[ibrch].bclass == OCSM_APPLIED) {
            status = buildApplied(MODL, ibrch, args, &nstack, stack, npatn, patn);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildApplied);
        } else if (MODL->brch[ibrch].bclass == OCSM_BOOLEAN) {
            status = buildBoolean(MODL, ibrch, args, &nstack, stack, npatn, patn);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildBoolean);
        } else if (MODL->brch[ibrch].bclass == OCSM_TRANSFORM) {
            status = buildTransform(MODL, ibrch, args, &nstack, stack);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildTransform);
        } else if (MODL->brch[ibrch].bclass == OCSM_SKETCH) {
            status = buildSketch(MODL, ibrch, args, &nstack, stack, npatn, patn, sket);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildSketch);

            if (MODL->brch[ibrch].type != OCSM_SKBEG &&
                MODL->brch[ibrch].type != OCSM_SKVAR &&
                MODL->brch[ibrch].type != OCSM_SKCON   ) {
                MODL->brch[ibrch  ].ileft = ibrch - 1;
                MODL->brch[ibrch-1].ichld = ibrch;
            }
        } else if (MODL->brch[ibrch].bclass == OCSM_SOLVER) {
            status = buildSolver(MODL, ibrch, args, &nsolvar, solvars, &nsolcon, solcons);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildSolver);

        /* execute: "dimension $pmtrName nrow ncol 0" */
        } else if (type == OCSM_DIMENSION) {
            SPRINT4(1, "    executing [%4d] dimension:     %s  %11.5f  %11.5f  0",
                    ibrch, args[1].str, args[2].val[0], args[3].val[0]);

            status = ocsmNewPmtr(MODL, args[1].str, OCSM_UNKNOWN,
                                 NINT(args[2].val[0]), NINT(args[3].val[0]));
            CHECK_STATUS(ocsmNewPmtr);

        /* execute: "set $pmtrName exprs" */
        } else if (type == OCSM_SET) {
            SPRINT3(1, "    executing [%4d] set:            %s  %s",
                    ibrch, args[1].str, MODL->brch[ibrch].arg2);

            /* if $pmtrName is an implicit string, evaluate it */
            if (args[1].str[0] != '!') {
                STRNCPY(pname, args[1].str, MAX_EXPR_LEN);
            } else {
                status = str2val(args[1].str, MODL, &value, &dot, pname);
                if (MODL->sigCode != SUCCESS) goto next_branch;
                CHECK_STATUS(str2val);
            }

            /* break pname into pmtrName[irow,icol] */
            status = parseName(MODL, pname, pmtrName, &jpmtr, &irow, &icol);
            CATCH_STATUS(parseName);

            /* if it does not exist, create it now */
            if (jpmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_INTERNAL, 1, 1);
                CHECK_STATUS(ocsmNewPmtr);
                jpmtr = MODL->npmtr;

            /* make sure that Parameter is INTERNAL or OUTPUT */
            } else if (MODL->pmtr[jpmtr].type == OCSM_EXTERNAL ||
                       MODL->pmtr[jpmtr].type == OCSM_CONFIG     ) {
                SET_STATUS(OCSM_PMTR_IS_EXTERNAL, set);
            } else if (MODL->pmtr[jpmtr].type == OCSM_CONSTANT) {
                SET_STATUS(OCSM_PMTR_IS_CONSTANT, set);
            }

            /* string-value mode (expression evaluates to string) */
            if (args[2].nval == 0) {
                if (irow != 0 || icol != 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    CATCH_STATUS(set);
                }

                /* remove previous values and velocities and make
                   room for string */
                if (MODL->pmtr[jpmtr].str == NULL) {
                    FREE(MODL->pmtr[jpmtr].value);
                    FREE(MODL->pmtr[jpmtr].dot  );
                    FREE(MODL->pmtr[jpmtr].lbnd );
                    FREE(MODL->pmtr[jpmtr].ubnd );

                    MALLOC(MODL->pmtr[jpmtr].str, char, MAX_STRVAL_LEN);

                    MODL->pmtr[jpmtr].nrow = 0;
                    MODL->pmtr[jpmtr].ncol = 0;
                }

                /* store the string value */
                status = ocsmSetValu(MODL, jpmtr, 1, 1, MODL->brch[ibrch].arg2);
                CATCH_STATUS(ocsmSetValu);

                status = ocsmGetValuS(MODL, jpmtr, thisArg);
                CATCH_STATUS(ocsmGetValuS);

                SPRINT2(1, "                          %s = $%s",
                        pmtrName, thisArg);

            /* single-set mode (non-string) */
            } else if (args[2].nval == 1) {

                /* if currently a string value, remove it and make
                   room for single value */
                if (MODL->pmtr[jpmtr].str != NULL) {
                    FREE(MODL->pmtr[jpmtr].str);

                    MALLOC(MODL->pmtr[jpmtr].value, double, 1);
                    MALLOC(MODL->pmtr[jpmtr].dot,   double, 1);

                    MODL->pmtr[jpmtr].value[0] = -HUGEQ;
                    MODL->pmtr[jpmtr].dot[  0] = 0;

                    MODL->pmtr[jpmtr].nrow = 1;
                    MODL->pmtr[jpmtr].ncol = 1;
                }

                /* store the value(s) */
                if (irow == 0 && icol == 0) {
                    if (MODL->pmtr[jpmtr].nrow > 1 || MODL->pmtr[jpmtr].ncol > 1) {
                        for (irow = 1; irow <= MODL->pmtr[jpmtr].nrow; irow++) {
                            for (icol = 1; icol <= MODL->pmtr[jpmtr].ncol; icol++) {
                                status = ocsmSetValuD(MODL, jpmtr, irow, icol, args[2].val[0]);
                                CHECK_STATUS(ocsmSetValuD);

                                status = ocsmSetVelD( MODL, jpmtr, irow, icol, args[2].dot[0]);
                                CHECK_STATUS(ocsmSetVelD);

                                SPRINT5(1, "                          %s[%d,%d] = %11.5f %11.5f",
                                        pmtrName, irow, icol, args[2].val[0], args[2].dot[0]);
                            }
                        }
                    } else {
                        status = ocsmSetValuD(MODL, jpmtr, 1, 1, args[2].val[0]);
                        CHECK_STATUS(ocsmSetValuD);

                        status = ocsmSetVelD( MODL, jpmtr, 1, 1, args[2].dot[0]);
                        CHECK_STATUS(ocsmSetVelD);

                        SPRINT3(1, "                          %s = %11.5f %11.5f",
                                pmtrName, args[2].val[0], args[2].dot[0]);
                    }
                } else {
                    status = ocsmSetValuD(MODL, jpmtr, irow, icol, args[2].val[0]);
                    CATCH_STATUS(ocsmSetValuD);

                    status = ocsmSetVelD( MODL, jpmtr, irow, icol, args[2].dot[0]);
                    CATCH_STATUS(ocsmSetVelD);

                    SPRINT3(1, "                          %s = %11.5f %11.5f",
                            pmtrName, args[2].val[0], args[2].dot[0]);
                }

            /* multi-set mode */
            } else {

                /* we cannot be storing to a string value */
                if (MODL->pmtr[jpmtr].str != NULL) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    CATCH_STATUS(set);
                }

                /* store the values */
                icount = 0;
                value  = 0;
                dot    = 0;
                for (irow = 1; irow <= MODL->pmtr[jpmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[jpmtr].ncol; icol++) {

                        /* next value (if it exists; otherwise it is extended) */
                        if (icount < args[2].nval) {
                            value = args[2].val[icount];
                            dot   = args[2].dot[icount];
                        }

                        status = ocsmSetValuD(MODL, jpmtr, irow, icol, value);
                        CATCH_STATUS(ocsmSetValuD);

                        status = ocsmSetVelD(MODL, jpmtr, irow, icol, dot);
                        CATCH_STATUS(ocsmSetVelD);

                        if (icount < args[2].nval) {
                            SPRINT5(1, "                          %s[%d,%d] = %11.5f %11.5f",
                                    pmtrName, irow, icol, value, dot);
                        } else {
                            SPRINT5(1, "                          %s[%d,%d] = %11.5f %11.5f (extended)",
                                    pmtrName, irow, icol, value, dot);
                        }

                        icount++;
                    }
                }
            }

            /* if the SET statment has Attributes, create the global Attributes now */
            if (MODL->brch[ibrch].nattr > 0) {
                for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
                    status = ocsmSetAttr(MODL, 0, MODL->brch[ibrch].attr[iattr].name,
                                         MODL->brch[ibrch].attr[iattr].defn);
                    CHECK_STATUS(ocsmSetAttr);
                }
            }

        /* execute: "evaluate $type ..." */
        } else if (type == OCSM_EVALUATE) {

            jpmtr = 0;
            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                if (strcmp(MODL->pmtr[ipmtr].name, "@edata") == 0      &&
                    MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                    jpmtr = ipmtr;
                    break;
                }
            }

            if (jpmtr == 0) {
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            /* "evaluate $node ibody inode" */
            if (strcmp(args[1].str, "node") == 0 ||
                strcmp(args[1].str, "NODE") == 0   ) {
                SPRINT4(1, "    executing [%4d] evaluate:       %s  %s  %s",
                        ibrch, args[1].str, MODL->brch[ibrch].arg2,
                                            MODL->brch[ibrch].arg3);

                ibody = NINT(args[2].val[0]);
                inode = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (inode < 1 || inode > MODL->body[ibody].nnode) {
                    status = OCSM_NODE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Node");
                    goto next_branch;
                }

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = MODL->body[ibody].node[inode].x;
                MODL->pmtr[jpmtr].value[ 1] = MODL->body[ibody].node[inode].y;
                MODL->pmtr[jpmtr].value[ 2] = MODL->body[ibody].node[inode].z;
                MODL->pmtr[jpmtr].ncol      = 3;

            /* "evaluate $edge ibody iedge t" */
            } else if (strcmp(args[1].str, "edge") == 0 ||
                       strcmp(args[1].str, "EDGE") == 0   ) {
                SPRINT5(1, "    executing [%4d] evaluate:       %s  %s  %s  %s",
                        ibrch, args[1].str, MODL->brch[ibrch].arg2,
                                            MODL->brch[ibrch].arg3,
                                            MODL->brch[ibrch].arg4);

                ibody = NINT(args[2].val[0]);
                iedge = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
                    status = OCSM_EDGE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Edge");
                    goto next_branch;
                }

                status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                if        (strcmp(args[4].str, "beg") == 0) {
                    uv_[0] = uvrange[0];
                } else if (strcmp(args[4].str, "end") == 0) {
                    uv_[0] = uvrange[1];
                } else if (args[4].val[0] < uvrange[0]) {
                    uv_[0] = uvrange[0];
                } else if (args[4].val[0] > uvrange[1]) {
                    uv_[0] = uvrange[1];
                } else {
                    uv_[0] = args[4].val[0];
                }

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, uv_, data);
                CHECK_STATUS(EG_evaluate);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uv_[0];
                MODL->pmtr[jpmtr].value[ 1] = data[0];
                MODL->pmtr[jpmtr].value[ 2] = data[1];
                MODL->pmtr[jpmtr].value[ 3] = data[2];
                MODL->pmtr[jpmtr].value[ 4] = data[3];
                MODL->pmtr[jpmtr].value[ 5] = data[4];
                MODL->pmtr[jpmtr].value[ 6] = data[5];
                MODL->pmtr[jpmtr].value[ 7] = data[6];
                MODL->pmtr[jpmtr].value[ 8] = data[7];
                MODL->pmtr[jpmtr].value[ 9] = data[8];
                MODL->pmtr[jpmtr].ncol      = 10;

            /* "evaluate $edgerng ibody iedge" */
            } else if (strcmp(args[1].str, "edgerng") == 0 ||
                       strcmp(args[1].str, "EDGERNG") == 0   ) {
                SPRINT4(1, "    executing [%4d] evaluate:       %s  %s  %s",
                        ibrch, args[1].str, MODL->brch[ibrch].arg2,
                                            MODL->brch[ibrch].arg3);

                ibody = NINT(args[2].val[0]);
                iedge = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
                    status = OCSM_EDGE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Edge");
                    goto next_branch;
                }

                status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uvrange[0];
                MODL->pmtr[jpmtr].value[ 1] = uvrange[1];
                MODL->pmtr[jpmtr].ncol      = 2;

            /* "evaluate $edgeinv ibody iedge x y z" */
            } else if (strcmp(args[1].str, "edgeinv") == 0 ||
                       strcmp(args[1].str, "EDGEINV") == 0   ) {
                SPRINT7(1, "    executing [%4d] evaluate:       %s  %s  %s  %s  %s  %s",
                        ibrch, args[1].str, MODL->brch[ibrch].arg2,
                                            MODL->brch[ibrch].arg3,
                                            MODL->brch[ibrch].arg4,
                                            MODL->brch[ibrch].arg5,
                                            MODL->brch[ibrch].arg6);

                ibody = NINT(args[2].val[0]);
                iedge = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
                    status = OCSM_EDGE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Edge");
                    goto next_branch;
                }

                xyz_[0] = args[4].val[0];
                xyz_[1] = args[5].val[0];
                xyz_[2] = args[6].val[0];

                status = EG_invEvaluate(MODL->body[ibody].edge[iedge].eedge, xyz_, uv_, data);
                CHECK_STATUS(EG_invEvaluate);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uv_[ 0];
                MODL->pmtr[jpmtr].value[ 1] = data[0];
                MODL->pmtr[jpmtr].value[ 2] = data[1];
                MODL->pmtr[jpmtr].value[ 3] = data[2];
                MODL->pmtr[jpmtr].ncol      = 4;

            /* "evaluate $face ibody iface u v" */
            } else if (strcmp(args[1].str, "face") == 0 ||
                       strcmp(args[1].str, "FACE") == 0   ) {
                SPRINT6(1, "    executing [%4d] evaluate:       %s  %s  %s  %s  %s",
                        ibrch, args[1].str, MODL->brch[ibrch].arg2,
                                            MODL->brch[ibrch].arg3,
                                            MODL->brch[ibrch].arg4,
                                            MODL->brch[ibrch].arg5);

                ibody = NINT(args[2].val[0]);
                iface = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iface < 1 || iface > MODL->body[ibody].nface) {
                    status = OCSM_FACE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Face");
                    goto next_branch;
                }

                status = EG_getRange(MODL->body[ibody].face[iface].eface, uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                if        (args[4].val[0] < uvrange[0]) {
                    uv_[0] = uvrange[0];
                } else if (args[4].val[0] > uvrange[1]) {
                    uv_[0] = uvrange[1];
                } else {
                    uv_[0] = args[4].val[0];
                }

                if        (args[5].val[0] < uvrange[2]) {
                    uv_[1] = uvrange[2];
                } else if (args[5].val[0] > uvrange[3]) {
                    uv_[1] = uvrange[3];
                } else {
                    uv_[1] = args[5].val[0];
                }

                status = EG_evaluate(MODL->body[ibody].face[iface].eface, uv_, data);
                CHECK_STATUS(EG_evaluate);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uv_[  0];
                MODL->pmtr[jpmtr].value[ 1] = uv_[  1];
                MODL->pmtr[jpmtr].value[ 2] = data[ 0];
                MODL->pmtr[jpmtr].value[ 3] = data[ 1];
                MODL->pmtr[jpmtr].value[ 4] = data[ 2];
                MODL->pmtr[jpmtr].value[ 5] = data[ 3];
                MODL->pmtr[jpmtr].value[ 6] = data[ 4];
                MODL->pmtr[jpmtr].value[ 7] = data[ 5];
                MODL->pmtr[jpmtr].value[ 8] = data[ 6];
                MODL->pmtr[jpmtr].value[ 9] = data[ 7];
                MODL->pmtr[jpmtr].value[10] = data[ 8];
                MODL->pmtr[jpmtr].value[11] = data[ 9];
                MODL->pmtr[jpmtr].value[12] = data[10];
                MODL->pmtr[jpmtr].value[13] = data[11];
                MODL->pmtr[jpmtr].value[14] = data[12];
                MODL->pmtr[jpmtr].value[15] = data[13];
                MODL->pmtr[jpmtr].value[16] = data[14];
                MODL->pmtr[jpmtr].value[17] = data[15];
                MODL->pmtr[jpmtr].value[18] = data[16];
                MODL->pmtr[jpmtr].value[19] = data[17];
                MODL->pmtr[jpmtr].ncol      = 20;

            /* "evaluate $facerng ibody iface" */
            } else if (strcmp(args[1].str, "facerng") == 0 ||
                       strcmp(args[1].str, "FACERNG") == 0   ) {
                SPRINT4(1, "    executing [%4d] evaluate:       %s  %s  %s",
                        ibrch, args[1].str, MODL->brch[ibrch].arg2,
                                            MODL->brch[ibrch].arg3);

                ibody = NINT(args[2].val[0]);
                iface = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iface < 1 || iface > MODL->body[ibody].nface) {
                    status = OCSM_FACE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Face");
                    goto next_branch;
                }

                status = EG_getRange(MODL->body[ibody].face[iface].eface, uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uvrange[0];
                MODL->pmtr[jpmtr].value[ 1] = uvrange[1];
                MODL->pmtr[jpmtr].value[ 2] = uvrange[2];
                MODL->pmtr[jpmtr].value[ 3] = uvrange[3];
                MODL->pmtr[jpmtr].ncol      = 4;

            /* "evaluate $faceinv ibody iface x y z" */
            } else if (strcmp(args[1].str, "faceinv") == 0 ||
                       strcmp(args[1].str, "FACEINV") == 0   ) {
                SPRINT7(1, "    executing [%4d] evaluate:       %s  %s  %s  %s  %s  %s",
                        ibrch, args[1].str, MODL->brch[ibrch].arg2,
                                            MODL->brch[ibrch].arg3,
                                            MODL->brch[ibrch].arg4,
                                            MODL->brch[ibrch].arg5,
                                            MODL->brch[ibrch].arg6);

                ibody = NINT(args[2].val[0]);
                iface = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iface < 1 || iface > MODL->body[ibody].nface) {
                    status = OCSM_FACE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Face");
                    goto next_branch;
                }

                xyz_[0] = args[4].val[0];
                xyz_[1] = args[5].val[0];
                xyz_[2] = args[6].val[0];

                status = EG_invEvaluate(MODL->body[ibody].face[iface].eface, xyz_, uv_, data);
                CHECK_STATUS(EG_invEvaluate);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uv_[0];
                MODL->pmtr[jpmtr].value[ 1] = uv_[1];
                MODL->pmtr[jpmtr].value[ 2] = data[0];
                MODL->pmtr[jpmtr].value[ 3] = data[1];
                MODL->pmtr[jpmtr].value[ 4] = data[2];
                MODL->pmtr[jpmtr].ncol      = 5;
            }

        /* execute: "getattr $pmtrName attrID global=0" */
        } else if (type == OCSM_GETATTR) {
            SPRINT4(1, "    executing [%4d] getattr:        %s  %s  %s",
                    ibrch, args[1].str, MODL->brch[ibrch].arg2, MODL->brch[ibrch].arg3);

            /* make sure that there are no subscripts in pmtrName */
            if (strstr(args[1].str, "[") != NULL) {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError(MODL, status,
                            "pmtrName cannot contain [");
                goto next_branch;
            }

            /* find pmtrName in list of Parameters */
            jpmtr = -1;
            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                if (strcmp(MODL->pmtr[ipmtr].name, args[1].str) == 0          &&
                           MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                    jpmtr = ipmtr;

                    /* if the Parameter is CONSTANT, EXTERNAL, or CONFIG we have a problem */
                    if        (MODL->pmtr[jpmtr].type == OCSM_EXTERNAL ||
                               MODL->pmtr[jpmtr].type == OCSM_CONFIG     ) {
                        status = OCSM_PMTR_IS_EXTERNAL;
                        CATCH_STATUS(getattr);
                    } else if (MODL->pmtr[jpmtr].type == OCSM_CONSTANT) {
                        status = OCSM_PMTR_IS_CONSTANT;
                        CATCH_STATUS(getattr);
                    }

                    break;
                }
            }

            status = str2val(MODL->brch[ibrch].arg2, MODL, &value, &dot, str);
            CATCH_STATUS(str2val);

            /* get the ego associated with the selected entity */
            if        (NINT(args[3].val[0]) > 0) {
                eobj = NULL;
            } else if (MODL->seltype == 0) {
                eobj = MODL->body[MODL->selbody].node[MODL->sellist[0]].enode;
            } else if (MODL->seltype == 1) {
                eobj = MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge;
            } else if (MODL->seltype == 2) {
                eobj = MODL->body[MODL->selbody].face[MODL->sellist[0]].eface;
            } else if (MODL->selbody >= 1) {
                eobj = MODL->body[MODL->selbody].ebody;
            } else {
                status = OCSM_INTERNAL_ERROR;
                signalError(MODL, status,
                            "nothing is selected");
                goto next_branch;
            }

            /* get the number of Attributes for this selected object */
            if (eobj != NULL) {
                status = EG_attributeNum(eobj, &nattr);
                CATCH_STATUS(EG_attributeNum);
            } else {
                nattr = MODL->nattr;
            }

            /* if attrID is an integer, return the name of the attrID'th attribute */
            if (STRLEN(str) == 0) {
                iattr = NINT(value);

                /* ensure that iattr is in range */
                if (iattr < 1 || iattr > nattr) {
                    status = OCSM_ILLEGAL_ATTRIBUTE;
                    signalError(MODL, status,
                                "iattr is out of range");
                    goto next_branch;
                }

                /* if pmtrName does not exist, make it now */
                if (jpmtr < 0) {
                    status = ocsmNewPmtr(MODL, args[1].str, OCSM_INTERNAL, 0, 0);
                    CATCH_STATUS(ocsmNewPmtr);
                    jpmtr = MODL->npmtr;

                /* otherwise if it has rows and columns, convert to string */
                } else if (MODL->pmtr[jpmtr].nrow > 0 ||
                           MODL->pmtr[jpmtr].ncol > 0   ) {
                    FREE(MODL->pmtr[jpmtr].value);
                    FREE(MODL->pmtr[jpmtr].dot  );
                    FREE(MODL->pmtr[jpmtr].lbnd );
                    FREE(MODL->pmtr[jpmtr].ubnd );

                    MALLOC(MODL->pmtr[jpmtr].str, char, MAX_STRVAL_LEN);

                    MODL->pmtr[jpmtr].nrow = 0;
                    MODL->pmtr[jpmtr].ncol = 0;
                }

                /* store the name in jpmtr */
                if (eobj != NULL) {
                    status = EG_attributeGet(eobj, iattr, &aname, &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CATCH_STATUS(EG_attributeGet);

                    STRNCPY(MODL->pmtr[jpmtr].str, aname, MAX_STRVAL_LEN);
                } else {
                    STRNCPY(MODL->pmtr[jpmtr].str, MODL->attr[iattr-1].name, MAX_STRVAL_LEN);
                }

                SPRINT2(1, "                          %s = $%s",
                        args[1].str, MODL->pmtr[jpmtr].str);

            /* if attrID is $_nattr_, return the number of Attributes */
            } else if (strcmp(str, "_nattr_") == 0) {

                /* if pmtrName does not exist, make it now */
                if (jpmtr < 0) {
                    status = ocsmNewPmtr(MODL, args[1].str, OCSM_INTERNAL, 1, 1);
                    CATCH_STATUS(ocsmNewPmtr);
                    jpmtr = MODL->npmtr;

                /* otherwise if it is a string, convert to a number */
                } else if (MODL->pmtr[jpmtr].nrow == 0 &&
                           MODL->pmtr[jpmtr].ncol == 0   ) {
                    FREE(MODL->pmtr[jpmtr].str);

                    MALLOC(MODL->pmtr[jpmtr].value, double, 1);
                    MALLOC(MODL->pmtr[jpmtr].dot,   double, 1);

                    MODL->pmtr[jpmtr].value[0] = -HUGEQ;
                    MODL->pmtr[jpmtr].dot[  0] = 0;

                    MODL->pmtr[jpmtr].nrow = 1;
                    MODL->pmtr[jpmtr].ncol = 1;
                }

                /* store the result */
                status = ocsmSetValuD(MODL, jpmtr, 1, 1, (double)nattr);
                CATCH_STATUS(ocsmSetValuD);

                SPRINT2(1, "                          %s = %11.5f",
                        args[1].str, (double)nattr);

            /* otherwise, look up the value of the given Attribute */
            } else {
                if (eobj != NULL) {
                    status = EG_attributeRet(eobj, str, &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    if (status != SUCCESS) {
                        status = OCSM_ILLEGAL_ATTRIBUTE;
                        signalError(MODL, status,
                                    "Attribute \"%s\" not found", str);
                        goto next_branch;
                    }
                } else {
                    itype = -999;
                    for (iattr = 0; iattr < MODL->nattr; iattr++) {
                        if (strcmp(str, MODL->attr[iattr].name) == 0) {
                            itype     = ATTRSTRING;
                            nlist     = STRLEN(MODL->attr[iattr].defn);
                            tempClist = MODL->attr[iattr].defn;
                            break;
                        }
                    }
                    if (itype == -999) {
                        status = OCSM_ILLEGAL_ATTRIBUTE;
                        signalError(MODL, status,
                                    "Attribute \"%s\" not found", str);
                        goto next_branch;
                    }

                    if (MODL->attr[iattr].defn[0] == '$') {
                        itype     = ATTRSTRING;
                        nlist     = STRLEN(MODL->attr[iattr].defn) - 1;
                        tempClist = &(MODL->attr[iattr].defn[1]);
                    } else {
                        status = str2vals(MODL->attr[iattr].defn, MODL, &nrow, &ncol, &values, &dots, str);
                        CATCH_STATUS(str2val);

                        itype     = ATTRREAL;
                        nlist     = nrow * ncol;
                        tempRlist = values;
                    }
                }

                if (itype != ATTRINT  && itype != ATTRREAL  &&
                    itype != ATTRCSYS && itype != ATTRSTRING  ) {
                    status = OCSM_ILLEGAL_ATTRIBUTE;
                    signalError(MODL, status,
                                "Attribute \"%s\" is wrong type (%d)", str, itype);
                    goto next_branch;
                }

                /* if pmtrName does not exist, create it now */
                if (jpmtr < 0) {
                    if (itype == ATTRINT || itype == ATTRREAL || itype == ATTRCSYS) {
                        status = ocsmNewPmtr(MODL, args[1].str, OCSM_INTERNAL, 1, nlist);
                        CATCH_STATUS(ocsmNewPmtr);
                    } else {
                        status = ocsmNewPmtr(MODL, args[1].str, OCSM_INTERNAL, 0, 0);
                        CATCH_STATUS(ocsmNewPmtr);
                    }
                    jpmtr = MODL->npmtr;

                /* otherwise adjust type/size */
                } else if (itype == ATTRINT || itype == ATTRREAL || itype == ATTRCSYS) {
                    FREE(MODL->pmtr[jpmtr].value);
                    FREE(MODL->pmtr[jpmtr].dot  );
                    FREE(MODL->pmtr[jpmtr].lbnd );
                    FREE(MODL->pmtr[jpmtr].ubnd );
                    FREE(MODL->pmtr[jpmtr].str  );

                    MALLOC(MODL->pmtr[jpmtr].value, double, nlist);
                    MALLOC(MODL->pmtr[jpmtr].dot,   double, nlist);

                    for (i = 0; i < nlist; i++) {
                        MODL->pmtr[jpmtr].value[i] = -HUGEQ;
                        MODL->pmtr[jpmtr].dot[  i] = 0;
                    }

                    MODL->pmtr[jpmtr].nrow = 1;
                    MODL->pmtr[jpmtr].ncol = nlist;
                } else if (itype == ATTRSTRING) {
                    FREE(MODL->pmtr[jpmtr].value);
                    FREE(MODL->pmtr[jpmtr].dot  );
                    FREE(MODL->pmtr[jpmtr].lbnd );
                    FREE(MODL->pmtr[jpmtr].ubnd );
                    FREE(MODL->pmtr[jpmtr].str  );

                    MALLOC(MODL->pmtr[jpmtr].str, char, MAX_STRVAL_LEN);

                    MODL->pmtr[jpmtr].nrow = 0;
                    MODL->pmtr[jpmtr].ncol = 0;
                }

                /* store the values in jpmtr */
                if (itype == ATTRINT) {
                    for (ilist = 0; ilist < nlist; ilist++) {
                        status = ocsmSetValuD(MODL, jpmtr, 1, ilist+1, (double)tempIlist[ilist]);
                        CATCH_STATUS(ocsmSetValuD);

                        SPRINT3(1, "                          %s[1,%2d] = %11.5f",
                                args[1].str, ilist+1, (double)tempIlist[ilist]);
                    }
                } else if (itype == ATTRREAL || itype == ATTRCSYS) {
                    for (ilist = 0; ilist < nlist; ilist++) {
                        status = ocsmSetValuD(MODL, jpmtr, 1, ilist+1, tempRlist[ilist]);
                        CATCH_STATUS(ocsmSetValuD);

                        SPRINT3(1, "                          %s[1,%2d] = %11.5f",
                                args[1].str, ilist+1, tempRlist[ilist]);
                    }
                } else {
                    STRNCPY(MODL->pmtr[jpmtr].str, tempClist, MAX_STRVAL_LEN);

                    SPRINT2(1, "                          %s = $%s",
                            args[1].str, tempClist);

                }
            }

            FREE(values);
            FREE(dots  );

        /* execute: "udparg $primtype $argName1 argValue1 $argName2 argValue2 $argName3 argValue3 $argName4 argValue4" */
        } else if (type == OCSM_UDPARG) {
            SPRINT2x(1, "    executing [%4d] udparg:     %s",
                    ibrch, args[1].str);

            hasdots = 0;

            for (iarg = 3; iarg <= MODL->brch[ibrch].narg; iarg+=2) {
                if (args[iarg].nval == 0) {
                    SPRINT2x(1, " %s %s",
                             args[iarg-1].str, args[iarg].str);
                } else {
                    SPRINT2x(1, " %s %11.5f",
                             args[iarg-1].str, args[iarg].val[0]);

                    for (ival = 0; ival < args[iarg].nval; ival++) {
                        if (args[iarg].dot[ival] != 0) hasdots = 1;
                    }

                    /* set hasdots to 2 if any arguments changed (so that we know to
                       rebuild the udprim) */
                    ibody = MODL->nbody + 1;
                    if (ibody <= MODL->recycle) {
                        if (MODL->body[ibody].arg[iarg].nval == args[iarg].nval) {
                            for (ival = 0; ival < args[iarg].nval; ival++) {
                                if (MODL->body[ibody].arg[iarg].val[ival] != args[iarg].val[ival]) {
                                    hasdots = 2;
                                }
                            }
                        } else {
                            hasdots = 2;
                        }
                    }
                }
            }
            SPRINT0(1, " ");

            /* free a previuos Body if it exists */
            if (MODL->nbody+1 <= MODL->recycle) {
                if (MODL->body[MODL->nbody+1].arg[1].val != NULL) {
                    status = freeBody(MODL, MODL->nbody+1);
                    CATCH_STATUS(freeBody);
                }
            }

            /* create a Body */
            status = newBody(MODL, ibrch, OCSM_UDPARG, -1, -1,
                             args, hasdots, OCSM_NULL_BODY, &ibody);
            CATCH_STATUS(newBody);

            /* finish the Body (UDPARG) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(finishBody);

            /* do not push the Body onto the stack */
            SPRINT1(1, "                          Body   %4d created  (NULL Body)",
                    ibody);

        /* execute: "select $type arg1..." */
        } else if (type == OCSM_SELECT) {
            SPRINT1x(1, "    executing [%4d] select:   ", ibrch);
            for (iarg = 1; iarg <= MODL->brch[ibrch].narg; iarg++) {
                if        (args[iarg].nval + 0 && MODL->brch[ibrch].narg == 7) {
                    SPRINT1x(1, "  %11.5f",  args[iarg].val[0]);
                } else if (args[iarg].nval > 0) {
                    SPRINT1x(1, "  %d", NINT(args[iarg].val[0]));
                } else {
                    SPRINT1x(1, "  %s",      args[iarg].str);
                }
            }
            SPRINT0(1, " ");

            /* "select body ..." */
            if        (strcmp(args[1].str, "body") == 0 || strcmp(args[1].str, "BODY") == 0) {

                /* "body" */
                if        (MODL->brch[ibrch].narg == 1) {
                    MODL->seltype = -1;
                    for (MODL->selbody = MODL->nbody; MODL->selbody > 0; (MODL->selbody)--) {
                        if (MODL->body[MODL->selbody].botype != OCSM_NULL_BODY) break;
                    }

                /* "body attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    ibody = -1;
                    for (jbody = 1; jbody <= MODL->nbody; jbody++) {
                        if (MODL->body[jbody].botype == OCSM_NULL_BODY) continue;
                        if (MODL->body[jbody].ebody == NULL) continue;

                        status = EG_attributeNum(MODL->body[jbody].ebody, &nattr);
                        CHECK_STATUS(EG_attributeNum);

                        if (strcmp(args[2].str, "*") == 0) {
                            match1 = 1;
                        } else {
                            match1 = 0;
                        }
                        if (strcmp(args[4].str, "*") == 0) {
                            match2 = 1;
                        } else {
                            match2 = 0;
                        }
                        if (strcmp(args[6].str, "*") == 0) {
                            match3 = 1;
                        } else {
                            match3 = 0;
                        }

                        for (iattr = 1; iattr <= nattr; iattr++) {
                            status = EG_attributeGet(MODL->body[jbody].ebody,
                                                     iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeGet);

                            if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                if (strcmp(args[3].str, "*") == 0) {
                                    match1 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[3].str, tempClist) == 1) {
                                        match1 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[3].val[i]) == tempIlist[i]) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[3].val[i]-tempRlist[i]) < EPS06) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[3].str, "*") == 1) {
                                        match1 = 1;
                                    }
                                }
                            }

                            if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                if (strcmp(args[5].str, "*") == 0) {
                                    match2 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[5].str, tempClist) == 1) {
                                        match2 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[5].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[5].val[i]) == tempIlist[i]) match2++;
                                    }
                                    if (match2 == nlist) {
                                        match2 = 1;
                                    } else {
                                        match2 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[5].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[5].val[i]-tempRlist[i]) < EPS06) match2++;
                                    }
                                    if (match2 == nlist) {
                                        match2 = 1;
                                    } else {
                                        match2 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[5].str, "*") == 1) {
                                        match2 = 1;
                                    }
                                }
                            }

                            if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                if (strcmp(args[7].str, "*") == 0) {
                                    match3 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[7].str, tempClist) == 1) {
                                        match3 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[7].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[7].val[i]) == tempIlist[i]) match3++;
                                    }
                                    if (match3 == nlist) {
                                        match3 = 1;
                                    } else {
                                        match3 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[7].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[7].val[i]-tempRlist[i]) < EPS06) match3++;
                                    }
                                    if (match3 == nlist) {
                                        match3 = 1;
                                    } else {
                                        match3 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[7].str, "*") == 1) {
                                        match3 = 1;
                                    }
                                }
                            }
                        }

                        if (match1 == 1 && match2 == 1 && match3 == 1) {
                            if (ibody == -1) {
                                ibody = jbody;
                            } else {
                                status = OCSM_BODY_NOT_FOUND;
                                signalError(MODL, status,
                                            "more than one Body matches SELECT");
                                goto next_branch;
                            }
                        }
                    }

                    if (ibody > 0) {
                        MODL->seltype = -1;
                        MODL->selbody = ibody;
                        MODL->selsize = 0;

                        FREE(MODL->sellist);
                    } else {
                        status = OCSM_BODY_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specifies nonexistant Body");
                        goto next_branch;
                    }

                /* "body ibody" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    if (NINT(args[2].val[0]) >= 1 && NINT(args[2].val[0]) <= MODL->nbody) {
                        MODL->seltype = -1;
                        MODL->selbody = NINT(args[2].val[0]);
                        MODL->selsize = 0;

                        FREE(MODL->sellist);
                    } else if (NINT(args[2].val[0]) < 0 && nstack >= -NINT(args[2].val[0])) {
                        MODL->seltype = -1;
                        MODL->selbody = stack[nstack+NINT(args[2].val[0])];
                        MODL->selsize = 0;

                        FREE(MODL->sellist);

                        if (MODL->selbody == 0) {
                            status = setupAtPmtrs(MODL, -1);
                            goto next_branch;
                        }
                    } else {
                        status = OCSM_BODY_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specifies nonexistant Body");
                        goto next_branch;
                    }
                }

            /* "select face ..." */
            } else if (strcmp(args[1].str, "face") == 0 || strcmp(args[1].str, "FACE") == 0) {
                if (MODL->selbody < 0) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT specified nonexistant Body");
                    goto next_branch;

                /* "face" */
                } else if (MODL->brch[ibrch].narg == 1) {
                        MODL->seltype = 2;
                        MODL->selsize = MODL->body[MODL->selbody].nface;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                            MODL->sellist[iface-1] = iface;
                        }

                /* "face iface" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    if (NINT(args[2].val[0]) >= 1 && NINT(args[2].val[0]) <= MODL->body[MODL->selbody].nface) {
                        MODL->seltype = 2;
                        MODL->selsize = 1;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        MODL->sellist[0] = NINT(args[2].val[0]);
                    } else {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    }

                /* "face 0      iford1" */
                /* "face ibody1 0"      */
                } else if (MODL->brch[ibrch].narg == 3 && (NINT(args[2].val[0]) == 0 ||
                                                           NINT(args[3].val[0]) == 0   )) {
                    MODL->seltype = 2;
                    MODL->selsize = 0;

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                 "_faceID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                            (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1])   ) {
                            MODL->selsize++;
                        }
                    }

                    if (MODL->selsize > 0) {
                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);

                        i = 0;
                        for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                            status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                     "_faceID", &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CATCH_STATUS(EG_attributeRet);

                            if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                                (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1])   ) {
                                MODL->sellist[i] = iface;
                                i++;
                            }
                        }
                    } else {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    }

                /* "face ibody1 iford1 iseq=1" */
                } else if (MODL->brch[ibrch].narg == 3 || MODL->brch[ibrch].narg == 4) {
                    MODL->seltype = 2;
                    MODL->selsize = 1;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    MODL->sellist[0] = -1;

                    if (MODL->brch[ibrch].narg == 3) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[4].val[0]);
                    }

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                 "_faceID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if (NINT(args[2].val[0]) == tempIlist[0] &&
                            NINT(args[3].val[0]) == tempIlist[1] &&
                                            iseq == tempIlist[2]   ) {
                            MODL->sellist[0] = iface;
                            break;
                        }
                    }

                    if (MODL->sellist[0] < 0) {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    }

                /* "face xmin xmax ymin ymax zmin zmax" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 1 && args[3].nval == 1 &&
                                                          args[4].nval == 1 && args[5].nval == 1 &&
                                                          args[6].nval == 1 && args[7].nval == 1   ) {
                    MODL->seltype = 2;
                    MODL->selsize = 0;

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        status = EG_getBoundingBox(MODL->body[MODL->selbody].face[iface].eface, bbox);
                        CATCH_STATUS(EG_getBoundingBox);

                        if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                            bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                            bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                            MODL->selsize++;
                        }
                    }

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MAX(MODL->selsize, 1));
                    if (MODL->selsize == 0) {
                        MODL->sellist[0] = -1;

                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    } else {
                        MODL->selsize = 0;

                        for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                            status = EG_getBoundingBox(MODL->body[MODL->selbody].face[iface].eface, bbox);
                            CATCH_STATUS(EG_getBoundingBox);

                            if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                                bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                                bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                                MODL->sellist[MODL->selsize] = iface;
                                MODL->selsize++;
                            }
                        }
                    }

                /* "face attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    MODL->seltype = 2;
                    MODL->selsize = 0;

                    FREE(  MODL->sellist);

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        status = EG_attributeNum(MODL->body[MODL->selbody].face[iface].eface, &nattr);
                        CHECK_STATUS(EG_attributeNum);

                        if (strcmp(args[2].str, "*") == 0) {
                            match1 = 1;
                        } else {
                            match1 = 0;
                        }
                        if (strcmp(args[4].str, "*") == 0) {
                            match2 = 1;
                        } else {
                            match2 = 0;
                        }
                        if (strcmp(args[6].str, "*") == 0) {
                            match3 = 1;
                        } else {
                            match3 = 0;
                        }

                        for (iattr = 1; iattr <= nattr; iattr++) {
                            status = EG_attributeGet(MODL->body[MODL->selbody].face[iface].eface,
                                                     iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeGet);

                            if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                if (strcmp(args[3].str, "*") == 0) {
                                    match1 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[3].str, tempClist) == 1) {
                                        match1 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[3].val[i]) == tempIlist[i]) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[3].val[i]-tempRlist[i]) < EPS06) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[3].str, "*") == 1) {
                                        match1 = 1;
                                    }
                                }
                            }

                            if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                if (strcmp(args[5].str, "*") == 0) {
                                    match2 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[5].str, tempClist) == 1) {
                                        match2 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[5].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[5].val[i]) == tempIlist[i]) match2++;
                                    }
                                    if (match2 == nlist) {
                                        match2 = 1;
                                    } else {
                                        match2 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[5].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[5].val[i]-tempRlist[i]) < EPS06) match2++;
                                    }
                                    if (match2 == nlist) {
                                        match2 = 1;
                                    } else {
                                        match2 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[5].str, "*") == 1) {
                                        match2 = 1;;
                                    }
                                }
                            }

                            if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                if (strcmp(args[7].str, "*") == 0) {
                                    match3 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[7].str, tempClist) == 1) {
                                        match3 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[7].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[7].val[i]) == tempIlist[i]) match3++;
                                    }
                                    if (match3 == nlist) {
                                        match3 = 1;
                                    } else {
                                        match3 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[7].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[7].val[i]-tempRlist[i]) < EPS06) match3++;
                                    }
                                    if (match3 == nlist) {
                                        match3 = 1;
                                    } else {
                                        match3 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[7].str, "*") == 1) {
                                        match3 = 1;
                                    }
                                }
                            }
                        }

                        if (match1 == 1 && match2 == 1 && match3 == 1) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iface;
                        }
                    }

                    if (MODL->selsize == 0) {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    }
                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_face);
                }

            /* "select edge ..." */
            } else if (strcmp(args[1].str, "edge") == 0 || strcmp(args[1].str, "EDGE") == 0) {
                if (MODL->selbody < 0) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT specified nonexistant Body");
                    goto next_branch;

                /* "edge" */
                } else if (MODL->brch[ibrch].narg == 1) {
                        MODL->seltype = 1;
                        MODL->selsize = MODL->body[MODL->selbody].nedge;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                            MODL->sellist[iedge-1] = iedge;
                        }

                /* "edge iedge" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    if (NINT(args[2].val[0]) >= 1 && NINT(args[2].val[0]) <= MODL->body[MODL->selbody].nedge) {
                        MODL->seltype = 1;
                        MODL->selsize = 1;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        MODL->sellist[0] = NINT(args[2].val[0]);
                    } else {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    }


                /* "edge 0      iford1 ibody2 iford2" */
                /* "edge ibody1 0      ibody2 iford2" */
                /* "edge ibody1 iford1 0      iford2" */
                /* "edge ibody1 iford1 ibody2 0"      */
                } else if (MODL->brch[ibrch].narg == 5 && (NINT(args[2].val[0]) == 0 ||
                                                           NINT(args[3].val[0]) == 0 ||
                                                           NINT(args[4].val[0]) == 0 ||
                                                           NINT(args[5].val[0]) == 0   )) {
                    MODL->seltype = 1;
                    MODL->selsize = 0;

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                 "_edgeID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                            (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                            (NINT(args[4].val[0]) == 0 || NINT(args[4].val[0]) == tempIlist[2]) &&
                            (NINT(args[5].val[0]) == 0 || NINT(args[5].val[0]) == tempIlist[3])   ) {
                            MODL->selsize++;
                        }
                    }

                    if (MODL->selsize > 0) {
                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);

                        i = 0;
                        for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                            status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                     "_edgeID", &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CATCH_STATUS(EG_attributeRet);

                            if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                                (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                                (NINT(args[4].val[0]) == 0 || NINT(args[4].val[0]) == tempIlist[2]) &&
                                (NINT(args[5].val[0]) == 0 || NINT(args[5].val[0]) == tempIlist[3])   ) {
                                MODL->sellist[i] = iedge;
                                i++;
                            }
                        }
                    } else {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    }


                /* "edge ibody1 iford1 ibody2 iford2 iseq=1" */
                } else if (MODL->brch[ibrch].narg == 5 || MODL->brch[ibrch].narg == 6) {
                    MODL->seltype = 1;
                    MODL->selsize = 1;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    MODL->sellist[0] = -1;

                    if (MODL->brch[ibrch].narg == 5) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[6].val[0]);
                    }

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                 "_edgeID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if        (NINT(args[2].val[0]) == tempIlist[0] &&
                                   NINT(args[3].val[0]) == tempIlist[1] &&
                                   NINT(args[4].val[0]) == tempIlist[2] &&
                                   NINT(args[5].val[0]) == tempIlist[3] &&
                                                   iseq == tempIlist[4]   ) {
                            MODL->sellist[0] = iedge;
                            break;
                        } else if (NINT(args[2].val[0]) == tempIlist[2] &&
                                   NINT(args[3].val[0]) == tempIlist[3] &&
                                   NINT(args[4].val[0]) == tempIlist[0] &&
                                   NINT(args[5].val[0]) == tempIlist[1] &&
                                                   iseq == tempIlist[4]   ) {
                            MODL->sellist[0] = iedge;
                            break;
                        }
                    }

                    if (MODL->sellist[0] < 0) {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    }

                /* "edge xmin xmax ymin ymax zmin zmax" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 1 && args[3].nval == 1 &&
                                                          args[4].nval == 1 && args[5].nval == 1 &&
                                                          args[6].nval == 1 && args[7].nval == 1   ) {
                    MODL->seltype = 1;
                    MODL->selsize = 0;

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        status = EG_getBoundingBox(MODL->body[MODL->selbody].edge[iedge].eedge, bbox);
                        CATCH_STATUS(EG_getBoundingBox);

                        if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                            bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                            bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                            MODL->selsize++;
                        }
                    }

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MAX(MODL->selsize, 1));
                    if (MODL->selsize == 0) {
                        MODL->sellist[0] = -1;

                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    } else {
                        MODL->selsize = 0;

                        for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                            status = EG_getBoundingBox(MODL->body[MODL->selbody].edge[iedge].eedge, bbox);
                            CATCH_STATUS(EG_getBoundingBox);

                            if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                                bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                                bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                                MODL->sellist[MODL->selsize] = iedge;
                                MODL->selsize++;
                            }
                        }
                    }

                /* "edge attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    MODL->seltype = 1;
                    MODL->selsize = 0;

                    FREE(  MODL->sellist);

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        status = EG_attributeNum(MODL->body[MODL->selbody].edge[iedge].eedge, &nattr);
                        CHECK_STATUS(EG_attributeNum);

                        if (strcmp(args[2].str, "*") == 0) {
                            match1 = 1;
                        } else {
                            match1 = 0;
                        }
                        if (strcmp(args[4].str, "*") == 0) {
                            match2 = 1;
                        } else {
                            match2 = 0;
                        }
                        if (strcmp(args[6].str, "*") == 0) {
                            match3 = 1;
                        } else {
                            match3 = 0;
                        }

                        for (iattr = 1; iattr <= nattr; iattr++) {
                            status = EG_attributeGet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                     iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeGet);

                            if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                if (strcmp(args[3].str, "*") == 0) {
                                    match1 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[3].str, tempClist) == 1) {
                                        match1 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[3].val[i]) == tempIlist[i]) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[3].val[i]-tempRlist[i]) < EPS06) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype == ATTRINT && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[3].val[i]) == tempIlist[i]) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[3].val[i]-tempRlist[i]) < EPS06) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[3].str, "*") == 1) {
                                        match1 = 1;
                                    }
                                }
                            }

                            if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                if (strcmp(args[5].str, "*") == 0) {
                                    match2 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[5].str, tempClist) == 1) {
                                        match2 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[5].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[5].val[i]) == tempIlist[i]) match2++;
                                    }
                                    if (match2 == nlist) {
                                        match2 = 1;
                                    } else {
                                        match2 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[5].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[5].val[i]-tempRlist[i]) < EPS06) match2++;
                                    }
                                    if (match2 == nlist) {
                                        match2 = 1;
                                    } else {
                                        match2 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[5].str, "*") == 1) {
                                        match2 = 1;
                                    }
                                }
                            }

                            if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                if (strcmp(args[7].str, "*") == 0) {
                                    match3 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[7].str, tempClist) == 1) {
                                        match3 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[7].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[7].val[i]) == tempIlist[i]) match3++;
                                    }
                                    if (match3 == nlist) {
                                        match3 = 1;
                                    } else {
                                        match3 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[7].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[7].val[i]-tempRlist[i]) < EPS06) match3++;
                                    }
                                    if (match3 == nlist) {
                                        match3 = 1;
                                    } else {
                                        match3 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[7].str, "*") == 1) {
                                        match3 = 1;
                                    }
                                }
                            }
                        }

                        if (match1 == 1 && match2 == 1 && match3 == 1) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iedge;
                        }
                    }

                    if (MODL->selsize == 0) {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    }

                /* "edge x y z" */
                } else if (MODL->brch[ibrch].narg == 4 && args[2].nval == 1 &&
                                                          args[3].nval == 1 &&
                                                          args[4].nval == 1   ) {
                    MODL->seltype = 1;
                    MODL->selsize = 1;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    MODL->sellist[0] = -1;

                    dmin = HUGEQ;
                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        status = EG_getRange(MODL->body[MODL->selbody].edge[iedge].eedge, uvrange, &periodic);
                        CATCH_STATUS(EG_getRange);

                        uvrange[0] = (uvrange[0] + uvrange[1]) / 2;
                        status = EG_evaluate(MODL->body[MODL->selbody].edge[iedge].eedge, uvrange, data);
                        CATCH_STATUS(EG_evaluate);

                        dtest = sqrt((data[0]-args[2].val[0]) * (data[0]-args[2].val[0])
                                    +(data[1]-args[3].val[0]) * (data[1]-args[3].val[0])
                                    +(data[2]-args[4].val[0]) * (data[2]-args[4].val[0]));
                        if (dtest < dmin) {
                            dmin = dtest;
                            MODL->sellist[0] = iedge;
                        }
                    }

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_edge);
                }

            /* "select node ..." */
            } else if (strcmp(args[1].str, "node") == 0 || strcmp(args[1].str, "NODE") == 0) {
                if (MODL->selbody < 0) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT specified nonexistant Body");
                    goto next_branch;

                /* "node" */
                } else if (MODL->brch[ibrch].narg == 1) {
                        MODL->seltype = 0;
                        MODL->selsize = MODL->body[MODL->selbody].nnode;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                            MODL->sellist[inode-1] = inode;
                        }

                /* "node inode" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    if (NINT(args[2].val[0]) >= 1 && NINT(args[2].val[0]) <= MODL->body[MODL->selbody].nnode) {
                        MODL->seltype = 0;
                        MODL->selsize = 1;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        MODL->sellist[0] = NINT(args[2].val[0]);
                    } else {
                        status = OCSM_NODE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Node");
                        goto next_branch;
                    }

                /* "node x y z" */
                } else if (MODL->brch[ibrch].narg == 4) {
                    MODL->seltype = 0;
                    MODL->selsize = 1;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    MODL->sellist[0] = 1;
                    dbest = pow(MODL->body[MODL->selbody].node[1].x-args[2].val[0], 2)
                          + pow(MODL->body[MODL->selbody].node[1].y-args[3].val[0], 2)
                          + pow(MODL->body[MODL->selbody].node[1].z-args[4].val[0], 2);

                    for (inode = 2;  inode <= MODL->body[MODL->selbody].nnode; inode++) {
                         dtest = pow(MODL->body[MODL->selbody].node[inode].x-args[2].val[0], 2)
                               + pow(MODL->body[MODL->selbody].node[inode].y-args[3].val[0], 2)
                               + pow(MODL->body[MODL->selbody].node[inode].z-args[4].val[0], 2);
                         if (dtest < dbest) {
                             MODL->sellist[0] = inode;
                             dbest = dtest;
                         }
                    }

                /* "node xmin xmax ymin ymax zmin zmax" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 1 && args[3].nval == 1 &&
                                                          args[4].nval == 1 && args[5].nval == 1 &&
                                                          args[6].nval == 1 && args[7].nval == 1   ) {
                    MODL->seltype = 0;
                    MODL->selsize = 0;

                    for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                        status = EG_getBoundingBox(MODL->body[MODL->selbody].node[inode].enode, bbox);
                        CATCH_STATUS(EG_getBoundingBox);

                        if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                            bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                            bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                            MODL->selsize++;
                        }
                    }

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MAX(MODL->selsize, 1));
                    if (MODL->selsize == 0) {
                        MODL->sellist[0] = -1;

                        status = OCSM_NODE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Node");
                        goto next_branch;
                    } else {
                        MODL->selsize = 0;

                        for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                            status = EG_getBoundingBox(MODL->body[MODL->selbody].node[inode].enode, bbox);
                            CATCH_STATUS(EG_getBoundingBox);

                            if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                                bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                                bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                                MODL->sellist[MODL->selsize] = inode;
                                MODL->selsize++;
                            }
                        }
                    }

                /* "node attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    MODL->seltype = 0;
                    MODL->selsize = 0;

                    FREE(  MODL->sellist);

                    for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                        status = EG_attributeNum(MODL->body[MODL->selbody].node[inode].enode, &nattr);
                        CHECK_STATUS(EG_attributeNum);

                        if (strcmp(args[2].str, "*") == 0) {
                            match1 = 1;
                        } else {
                            match1 = 0;
                        }
                        if (strcmp(args[4].str, "*") == 0) {
                            match2 = 1;
                        } else {
                            match2 = 0;
                        }
                        if (strcmp(args[6].str, "*") == 0) {
                            match3 = 1;
                        } else {
                            match3 = 0;
                        }

                        for (iattr = 1; iattr <= nattr; iattr++) {
                            status = EG_attributeGet(MODL->body[MODL->selbody].node[inode].enode,
                                                     iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeGet);

                            if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                if (strcmp(args[3].str, "*") == 0) {
                                    match1 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[3].str, tempClist) == 1) {
                                        match1 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[3].val[i]) == tempIlist[i]) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[3].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[3].val[i]-tempRlist[i]) < EPS06) match1++;
                                    }
                                    if (match1 == nlist) {
                                        match1 = 1;
                                    } else {
                                        match1 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[3].str, "*") == 1) {
                                        match1 = 1;
                                    }
                                }
                            }

                            if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                if (strcmp(args[5].str, "*") == 0) {
                                    match2 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[5].str, tempClist) == 1) {
                                        match2 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[5].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[5].val[i]) == tempIlist[i]) match2++;
                                    }
                                    if (match2 == nlist) {
                                        match2 = 1;
                                    } else {
                                        match2 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[5].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[5].val[i]-tempRlist[i]) < EPS06) match2++;
                                    }
                                    if (match2 == nlist) {
                                        match2 = 1;
                                    } else {
                                        match2 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[5].str, "*") == 1) {
                                        match2 = 1;
                                    }
                                }
                            }

                            if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                if (strcmp(args[7].str, "*") == 0) {
                                    match3 = 1;
                                } else if (itype == ATTRSTRING) {
                                    if (matches((char*)args[7].str, tempClist) == 1) {
                                        match3 = 1;
                                    }
                                } else if (itype == ATTRINT && nlist == args[7].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (NINT(args[7].val[i]) == tempIlist[i]) match3++;
                                    }
                                    if (match3 == nlist) {
                                        match3 = 1;
                                    } else {
                                        match3 = 0;
                                    }
                                } else if (itype == ATTRREAL && nlist == args[7].nval) {
                                    for (i = 0; i < nlist; i++) {
                                        if (fabs(args[7].val[i]-tempRlist[i]) < EPS06) match3++;
                                    }
                                    if (match3 == nlist) {
                                        match3 = 1;
                                    } else {
                                        match3 = 0;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[7].str, "*") == 1) {
                                        match3 = 1;
                                    }
                                }
                            }
                        }

                        if (match1 == 1 && match2 == 1 && match3 == 1) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = inode;
                        }
                    }

                    if (MODL->selsize == 0) {
                        status = OCSM_NODE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Node");
                        goto next_branch;
                    }
                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_node);
                }

            /* "select add ..." */
            } else if (strcmp(args[1].str, "add") == 0 || strcmp(args[1].str, "ADD") == 0) {
                if (MODL->selbody < 0) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT specified nonexistant Body");
                    goto next_branch;

                } else if (MODL->seltype != 0 && MODL->seltype != 1 && MODL->seltype != 2) {
                    status = OCSM_ILLEGAL_ARGUMENT;
                    signalError(MODL, status,
                                "SELECT ADD must follow SELECT NODE, EDGE, or FACE");
                    goto next_branch;

                /* "add iface" and seltype==2*/
                } else if (MODL->brch[ibrch].narg == 2 && MODL->seltype == 2) {
                    iface = NINT(args[2].val[0]);

                    if (iface >= 1 && iface <= MODL->body[MODL->selbody].nface) {
                        (MODL->selsize)++;
                        RALLOC(MODL->sellist, int, MODL->selsize);

                        MODL->sellist[MODL->selsize-1] = iface;
                    } else {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "Face not found");
                        goto next_branch;
                    }

                /* "add iedge" and seltype==1*/
                } else if (MODL->brch[ibrch].narg == 2 && MODL->seltype == 1) {
                    iedge = NINT(args[2].val[0]);

                    if (iedge >= 1 && iedge <= MODL->body[MODL->selbody].nedge) {
                        (MODL->selsize)++;
                        RALLOC(MODL->sellist, int, MODL->selsize);

                        MODL->sellist[MODL->selsize-1] = iedge;
                    } else {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "Edge not found");
                        goto next_branch;
                    }

                /* "add inode" and seltype==0*/
                } else if (MODL->brch[ibrch].narg == 2 && MODL->seltype == 0) {
                    inode = NINT(args[2].val[0]);

                    if (inode >= 1 && inode <= MODL->body[MODL->selbody].nnode) {
                        (MODL->selsize)++;
                        RALLOC(MODL->sellist, int, MODL->selsize);

                        MODL->sellist[MODL->selsize-1] = inode;
                    } else {
                        status = OCSM_NODE_NOT_FOUND;
                        signalError(MODL, status,
                                    "Node not found");
                        goto next_branch;
                    }

                /* "add attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {

                    if (MODL->seltype == 2) {
                        for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                            match1 = 0;
                            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                                if (MODL->sellist[ilist] == iface) {
                                    match1 = 1;
                                    break;
                                }
                            }
                            if (match1 == 1) continue;

                            status = EG_attributeNum(MODL->body[MODL->selbody].face[iface].eface, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].face[iface].eface,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (itype == ATTRSTRING) {
                                    if (matches((char*)args[2].str, aname    ) == 1 &&
                                        matches((char*)args[3].str, tempClist) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname    ) == 1 &&
                                        matches((char*)args[5].str, tempClist) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname    ) == 1 &&
                                        matches((char*)args[7].str, tempClist) == 1   ) {
                                        match3 = 1;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[2].str, aname) == 1 &&
                                        matches((char*)args[3].str, "*"  ) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname) == 1 &&
                                        matches((char*)args[5].str, "*"  ) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname) == 1 &&
                                        matches((char*)args[7].str, "*"  ) == 1   ) {
                                        match3 = 1;
                                    }
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                (MODL->selsize)++;
                                RALLOC(MODL->sellist, int, MODL->selsize);

                                MODL->sellist[MODL->selsize-1] = iface;
                            }
                        }
                    } else if (MODL->seltype == 1) {
                        for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                            match1 = 0;
                            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                                if (MODL->sellist[ilist] == iedge) {
                                    match1 = 1;
                                    break;
                                }
                            }
                            if (match1 == 1) continue;

                            status = EG_attributeNum(MODL->body[MODL->selbody].edge[iedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (itype == ATTRSTRING) {
                                    if (matches((char*)args[2].str, aname    ) == 1 &&
                                        matches((char*)args[3].str, tempClist) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname    ) == 1 &&
                                        matches((char*)args[5].str, tempClist) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname    ) == 1 &&
                                        matches((char*)args[7].str, tempClist) == 1   ) {
                                        match3 = 1;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[2].str, aname) == 1 &&
                                        matches((char*)args[3].str, "*"  ) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname) == 1 &&
                                        matches((char*)args[5].str, "*"  ) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname) == 1 &&
                                        matches((char*)args[7].str, "*"  ) == 1   ) {
                                        match3 = 1;
                                    }
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                (MODL->selsize)++;
                                RALLOC(MODL->sellist, int, MODL->selsize);

                                MODL->sellist[MODL->selsize-1] = iedge;
                            }
                        }
                    } else if (MODL->seltype == 0) {
                        for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                            match1 = 0;
                            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                                if (MODL->sellist[ilist] == inode) {
                                    match1 = 1;
                                    break;
                                }
                            }
                            if (match1 == 1) continue;

                            status = EG_attributeNum(MODL->body[MODL->selbody].node[inode].enode, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].node[inode].enode,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (itype == ATTRSTRING) {
                                    if (matches((char*)args[2].str, aname    ) == 1 &&
                                        matches((char*)args[3].str, tempClist) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname    ) == 1 &&
                                        matches((char*)args[5].str, tempClist) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname    ) == 1 &&
                                        matches((char*)args[7].str, tempClist) == 1   ) {
                                        match3 = 1;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[2].str, aname) == 1 &&
                                        matches((char*)args[3].str, "*"  ) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname) == 1 &&
                                        matches((char*)args[5].str, "*"  ) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname) == 1 &&
                                        matches((char*)args[7].str, "*"  ) == 1   ) {
                                        match3 = 1;
                                    }
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                (MODL->selsize)++;
                                RALLOC(MODL->sellist, int, MODL->selsize);

                                MODL->sellist[MODL->selsize-1] = inode;
                            }
                        }
                    }

                /* "add ibody1 iford1 iseq=1" */
                } else if ((MODL->brch[ibrch].narg == 3 ||
                            MODL->brch[ibrch].narg == 4)   && MODL->seltype == 2) {

                    if (MODL->brch[ibrch].narg == 3) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[4].val[0]);
                    }

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        match1 = 0;
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            if (MODL->sellist[ilist] == iface) {
                                match1 = 1;
                                break;
                            }
                        }
                        if (match1 == 1) continue;

                        status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                 "_faceID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if (NINT(args[2].val[0]) == tempIlist[0] &&
                            NINT(args[3].val[0]) == tempIlist[1] &&
                                            iseq == tempIlist[2]   ) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iface;
                        }
                    }

                /* "add ibody1 iford1 ibody2 iford2 iseq=1" */
                } else if ((MODL->brch[ibrch].narg == 5 ||
                            MODL->brch[ibrch].narg == 6)   && MODL->seltype == 1) {

                    if (MODL->brch[ibrch].narg == 5) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[6].val[0]);
                    }

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        match1 = 0;
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            if (MODL->sellist[ilist] == iedge) {
                                match1 = 1;
                                break;
                            }
                        }
                        if (match1 == 1) continue;

                        status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                 "_edgeID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if        (NINT(args[2].val[0]) == tempIlist[0] &&
                                   NINT(args[3].val[0]) == tempIlist[1] &&
                                   NINT(args[4].val[0]) == tempIlist[2] &&
                                   NINT(args[5].val[0]) == tempIlist[3] &&
                                                   iseq == tempIlist[4]   ) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iedge;
                        } else if (NINT(args[2].val[0]) == tempIlist[2] &&
                                   NINT(args[3].val[0]) == tempIlist[3] &&
                                   NINT(args[4].val[0]) == tempIlist[0] &&
                                   NINT(args[5].val[0]) == tempIlist[1] &&
                                                   iseq == tempIlist[4]   ) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iedge;
                        }
                    }

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_node);
                }

            /* "select sub ..." */
            } else if (strcmp(args[1].str, "sub") == 0 || strcmp(args[1].str, "SUB") == 0) {

                if (MODL->selbody < 0) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT specified nonexistant Body");
                    goto next_branch;

                } else if (MODL->seltype != 0 && MODL->seltype != 1 && MODL->seltype != 2) {
                    status = OCSM_ILLEGAL_ARGUMENT;
                    signalError(MODL, status,
                                "SELECT SUB must follow SELECT node, edge, or face");
                    goto next_branch;

                /* "sub ient" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    ient   = NINT(args[2].val[0]);
                    match1 = 0;
                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        if (MODL->sellist[ilist] == ient) {
                            for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                MODL->sellist[jlist] = MODL->sellist[jlist+1];
                            }

                            (MODL->selsize)--;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            match1++;
                            break;
                        }
                    }

                    if (match1 == 0) {
                        status = OCSM_ILLEGAL_VALUE;
                        signalError(MODL, status,
                                    "SELECT SUB must specify a value in @sellist");
                        goto next_branch;
                    }

                /* "sub attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 && args[3].nval == 0 &&
                                                          args[4].nval == 0 && args[5].nval == 0 &&
                                                          args[6].nval == 0 && args[7].nval == 0   ) {

                    if (MODL->seltype == 2) {
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            iface = MODL->sellist[ilist];

                            status = EG_attributeNum(MODL->body[MODL->selbody].face[iface].eface, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].face[iface].eface,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (itype == ATTRSTRING) {
                                    if (matches((char*)args[2].str, aname    ) == 1 &&
                                        matches((char*)args[3].str, tempClist) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname    ) == 1 &&
                                        matches((char*)args[5].str, tempClist) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname    ) == 1 &&
                                        matches((char*)args[7].str, tempClist) == 1   ) {
                                        match3 = 1;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[2].str, aname) == 1 &&
                                        matches((char*)args[3].str, "*"  ) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname) == 1 &&
                                        matches((char*)args[5].str, "*"  ) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname) == 1 &&
                                        matches((char*)args[7].str, "*"  ) == 1   ) {
                                        match3 = 1;
                                    }
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                    MODL->sellist[jlist] = MODL->sellist[jlist+1];
                                }
                                ilist--;

                                (MODL->selsize)--;
                                RALLOC(MODL->sellist, int, MODL->selsize);
                            }
                        }
                    } else if (MODL->seltype == 1) {
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            iedge = MODL->sellist[ilist];

                            status = EG_attributeNum(MODL->body[MODL->selbody].edge[iedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (itype == ATTRSTRING) {
                                    if (matches((char*)args[2].str, aname    ) == 1 &&
                                        matches((char*)args[3].str, tempClist) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname    ) == 1 &&
                                        matches((char*)args[5].str, tempClist) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname    ) == 1 &&
                                        matches((char*)args[7].str, tempClist) == 1   ) {
                                        match3 = 1;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[2].str, aname) == 1 &&
                                        matches((char*)args[3].str, "*"  ) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname) == 1 &&
                                        matches((char*)args[5].str, "*"  ) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname) == 1 &&
                                        matches((char*)args[7].str, "*"  ) == 1   ) {
                                        match3 = 1;
                                    }
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                    MODL->sellist[jlist] = MODL->sellist[jlist+1];
                                }
                                ilist--;

                                (MODL->selsize)--;
                                RALLOC(MODL->sellist, int, MODL->selsize);
                            }
                        }
                    } else if (MODL->seltype == 0) {
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            inode = MODL->sellist[ilist];

                            status = EG_attributeNum(MODL->body[MODL->selbody].node[inode].enode, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].node[inode].enode,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (itype == ATTRSTRING) {
                                    if (matches((char*)args[2].str, aname    ) == 1 &&
                                        matches((char*)args[3].str, tempClist) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname    ) == 1 &&
                                        matches((char*)args[5].str, tempClist) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname    ) == 1 &&
                                        matches((char*)args[7].str, tempClist) == 1   ) {
                                        match3 = 1;
                                    }
                                } else if (itype != ATTRCSYS) {
                                    if (matches((char*)args[2].str, aname) == 1 &&
                                        matches((char*)args[3].str, "*"  ) == 1   ) {
                                        match1 = 1;
                                    }
                                    if (matches((char*)args[4].str, aname) == 1 &&
                                        matches((char*)args[5].str, "*"  ) == 1   ) {
                                        match2 = 1;
                                    }
                                    if (matches((char*)args[6].str, aname) == 1 &&
                                        matches((char*)args[7].str, "*"  ) == 1   ) {
                                        match3 = 1;
                                    }
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                    MODL->sellist[jlist] = MODL->sellist[jlist+1];
                                }
                                ilist--;

                                (MODL->selsize)--;
                                RALLOC(MODL->sellist, int, MODL->selsize);
                            }
                        }
                    }

                /* "sub ibody1 iford1 iseq=1" */
                } else if ((MODL->brch[ibrch].narg == 3 ||
                            MODL->brch[ibrch].narg == 4)  && MODL->seltype == 2) {

                    if (MODL->brch[ibrch].narg == 3) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[4].val[0]);
                    }

                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        iface = MODL->sellist[ilist];

                        status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                 "_faceID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        if (NINT(args[2].val[0]) == tempIlist[0] &&
                            NINT(args[3].val[0]) == tempIlist[1] &&
                                            iseq == tempIlist[2]   ) {
                            for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                MODL->sellist[jlist] = MODL->sellist[jlist+1];
                            }
                            ilist--;

                            (MODL->selsize)--;
                            RALLOC(MODL->sellist, int, MODL->selsize);
                        }
                    }

                /* sub ibody1 iford1 ibody2 iford2 iseq=1 */
                } else if ((MODL->brch[ibrch].narg == 5 ||
                            MODL->brch[ibrch].narg == 6)  && MODL->seltype == 1) {

                    if (MODL->brch[ibrch].narg == 5) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[6].val[0]);
                    }

                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        iedge = MODL->sellist[ilist];

                        status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                 "_edgeID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        if        (NINT(args[2].val[0]) == tempIlist[0] &&
                                   NINT(args[3].val[0]) == tempIlist[1] &&
                                   NINT(args[4].val[0]) == tempIlist[2] &&
                                   NINT(args[5].val[0]) == tempIlist[3] &&
                                                   iseq == tempIlist[4]   ) {
                            for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                MODL->sellist[jlist] = MODL->sellist[jlist+1];
                            }

                            (MODL->selsize)--;
                            RALLOC(MODL->sellist, int, MODL->selsize);
                        } else if (NINT(args[2].val[0]) == tempIlist[2] &&
                                   NINT(args[3].val[0]) == tempIlist[3] &&
                                   NINT(args[4].val[0]) == tempIlist[0] &&
                                   NINT(args[5].val[0]) == tempIlist[1] &&
                                                   iseq == tempIlist[4]   ) {
                            for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                MODL->sellist[jlist] = MODL->sellist[jlist+1];
                            }
                            ilist--;

                            (MODL->selsize)--;
                            RALLOC(MODL->sellist, int, MODL->selsize);
                        }
                    }

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_node);
                }

            /* "select sort $key" */
            } else if (strcmp(args[1].str, "sort") == 0 || strcmp(args[1].str, "SORT") == 0) {
                if (MODL->selsize <= 0 || MODL->seltype < 0 || MODL->seltype > 2) {
                    SPRINT0(0, "ERROR:: there is nothing selected");
                    status = OCSM_NO_SELECTION;
                    CATCH_STATUS(select);
                }

                /* make a list of the properties */
                MALLOC(props, double, MODL->selsize);

                if        (MODL->seltype == 0) {
                    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, NODE, &nobjs, &eobjs);
                } else if (MODL->seltype == 1) {
                    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, EDGE, &nobjs, &eobjs);
                } else if (MODL->seltype == 2) {
                    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, FACE, &nobjs, &eobjs);
                }
                CATCH_STATUS(select);

                for (ilist = 0; ilist < MODL->selsize; ilist++) {
                    ient = MODL->sellist[ilist] - 1;

                    if        (strcmp(args[2].str, "xmin") == 0 || strcmp(args[2].str, "XMIN") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[0];
                    } else if (strcmp(args[2].str, "ymin") == 0 || strcmp(args[2].str, "YMIN") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[1];
                    } else if (strcmp(args[2].str, "zmin") == 0 || strcmp(args[2].str, "ZMIN") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[2];
                    } else if (strcmp(args[2].str, "xmax") == 0 || strcmp(args[2].str, "XMAX") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[3];
                    } else if (strcmp(args[2].str, "ymax") == 0 || strcmp(args[2].str, "YMAX") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[4];
                    } else if (strcmp(args[2].str, "zmax") == 0 || strcmp(args[2].str, "ZMAX") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[5];
                    } else if (strcmp(args[2].str, "area") == 0 || strcmp(args[2].str, "AREA") == 0) {
                        if (MODL->seltype == 2) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[1];
                        } else {
                            status = OCSM_ILLEGAL_ARGUMENT;
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);
                        }
                    } else if (strcmp(args[2].str, "length") == 0 || strcmp(args[2].str, "LENGTH") == 0) {
                        if (MODL->seltype == 1) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[1];
                        } else {
                            status = OCSM_ILLEGAL_ARGUMENT;
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);
                        }
                    } else if (strcmp(args[2].str, "xcg") == 0 || strcmp(args[2].str, "XCG") == 0) {
                        if (MODL->seltype != 0) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[2];
                        } else {
                            props[ilist] = MODL->body[MODL->selbody].node[ient+1].x;
                        }
                    } else if (strcmp(args[2].str, "ycg") == 0 || strcmp(args[2].str, "YCG") == 0) {
                        if (MODL->seltype != 0) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[3];
                        } else {
                            props[ilist] = MODL->body[MODL->selbody].node[ient+1].y;
                        }
                    } else if (strcmp(args[2].str, "zcg") == 0 || strcmp(args[2].str, "ZCG") == 0) {
                        if (MODL->seltype != 0) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[4];
                        } else {
                            props[ilist] = MODL->body[MODL->selbody].node[ient+1].z;
                        }
                    } else {
                        status = OCSM_ILLEGAL_ARGUMENT;
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);
                    }
                }

                EG_free(eobjs);

                /* bubble sort */
                for (ipass = 0; ipass < MODL->selsize; ipass++) {
                    nswap = 0;
                    for (ilist = 0; ilist < MODL->selsize-1; ilist++) {
                        if (props[ilist+1] < props[ilist]-EPS06) {
                            iswap                  = MODL->sellist[ilist  ];
                            MODL->sellist[ilist  ] = MODL->sellist[ilist+1];
                            MODL->sellist[ilist+1] = iswap;

                            rswap          = props[ilist  ];
                            props[ilist  ] = props[ilist+1];
                            props[ilist+1] = rswap;

                            nswap++;
                        }
                    }
                    if (nswap == 0) break;
                }

                /* cleanup */
                FREE(props);

            } else {
                status = OCSM_ILLEGAL_ARGUMENT;
                CATCH_STATUS(select);
            }

            /* clear any signals that might have been thrown by str2val */
            MODL->sigCode    =   0;
            MODL->sigMesg[0] = '\0';

            /* update @-parameters (SELECT) */
            status = setupAtPmtrs(MODL, 1);
            CATCH_STATUS(setupAtPmtrs);

            /* put Attributes for OCSM_SELECT on the selected Body/Faces/Edges/Nodes */
            if (MODL->brch[ibrch].nattr > 0) {
                if        (MODL->seltype == 2) {
                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        iface = MODL->sellist[ilist];
                        eface = MODL->body[MODL->selbody].face[iface].eface;

                        SPRINT1(1, "                     putting Branch Attributes on Face %d", iface);

                        status = setEgoAttribute(MODL, ibrch, eface);
                        CATCH_STATUS(setEgoAttribute);

                        status = colorizeFace(MODL, MODL->selbody, iface);
                        CATCH_STATUS(colorizeFace);
                    }
                } else if (MODL->seltype == 1) {
                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        iedge = MODL->sellist[ilist];
                        eedge = MODL->body[MODL->selbody].edge[iedge].eedge;

                        SPRINT1(1, "                     putting Branch Attributes on Edge %d", iedge);

                        status = setEgoAttribute(MODL, ibrch, eedge);
                        CATCH_STATUS(setEgoAttribute);

                        status = colorizeEdge(MODL, MODL->selbody, iedge);
                        CATCH_STATUS(colorizeEdge);
                    }
                } else if (MODL->seltype == 0) {
                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        inode = MODL->sellist[ilist];
                        enode = MODL->body[MODL->selbody].node[inode].enode;

                        SPRINT1(1, "                     putting Branch Attributes on Node %d", inode);

                        status = setEgoAttribute(MODL, ibrch, enode);
                        CATCH_STATUS(setEgoAttribute);

                        status = colorizeNode(MODL, MODL->selbody, inode);
                        CATCH_STATUS(colorizeNode);
                    }
                } else {
                    SPRINT0(1, "                    putting Branch Attributes on Body");

                    status = setEgoAttribute(MODL, ibrch, MODL->body[MODL->selbody].ebody);
                    CATCH_STATUS(setEgoAttribute);
                }
            }

        /* execute: "interface $argName $argType default=0" */
        } else if (type == OCSM_INTERFACE) {
            if (args[3].nval == 0) {
                SPRINT4(1, "              [%4d] interface:  %s  %s  %s",
                        ibrch, args[1].str, args[2].str, args[3].str);
            } else {
                SPRINT4(1, "              [%4d] interface:  %s  %s  %11.5f",
                        ibrch, args[1].str, args[2].str, args[3].val[0]);
            }

            /* make sure that the local variable name is not the same
               as a constant or output Parameter */
            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                if        (strcmp(MODL->pmtr[ipmtr].name, args[1].str) == 0 &&
                           MODL->pmtr[ipmtr].type == OCSM_CONSTANT            ) {
                    status = OCSM_PMTR_IS_CONSTANT;
                    signalError(MODL, status,
                                "INTERFACE variable \"%s\" cannot match CONPMTR", args[1].str);
                    goto next_branch;
                } else if (strcmp(MODL->pmtr[ipmtr].name, args[1].str) == 0 &&
                           MODL->pmtr[ipmtr].type == OCSM_OUTPUT              ) {
                    status = OCSM_PMTR_IS_OUTPUT;
                    signalError(MODL, status,
                                "INTERFACE variable \"%s\" cannot match OUTPMTR", args[1].str);
                    goto next_branch;
                }
            }

            /* this is skipped because it was processed as part of the UDPRIM
               statement */

        /* execute: "project x y z dx dy dz useEdges=0" */
        } else if (type == OCSM_PROJECT) {
            SPRINT8(1, "    executing [%4d] project:    %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                    ibrch, args[1].val[0], args[2].val[0], args[3].val[0],
                           args[4].val[0], args[5].val[0], args[6].val[0], args[7].val[0]);

            /* get the Bodys on the top of the stack */
            if (nstack < 1) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "PROJECT expects a Body on stack");
                goto next_branch;
            } else {
                ibodyl = stack[nstack-1];
            }

            /* make sure that the current Body has a tessellation */
            status = tessellate(MODL, ibodyl);
            CHECK_STATUS(tessellate);

            /* loop through all Triangles in all Faces to find closest projection */
            if (NINT(args[7].val[0]) == 0) {
                ibest = 0;
                tbest = HUGEQ;
                xbest = HUGEQ;
                ybest = HUGEQ;
                zbest = HUGEQ;

                for (iface = 1; iface <= MODL->body[ibodyl].nface; iface++) {
                    status = EG_getTessFace(MODL->body[ibodyl].etess, iface,
                                            &npnt, &xyz, &uv, &ptype, &pindx,
                                            &ntri, &tris, &tric);
                    CATCH_STATUS(EG_getFaceTess);

                    for (itri = 0; itri < ntri; itri++) {
                        u0 = uv[ 2*tris[3*itri  ]-2];
                        v0 = uv[ 2*tris[3*itri  ]-1];
                        x0 = xyz[3*tris[3*itri  ]-3];
                        y0 = xyz[3*tris[3*itri  ]-2];
                        z0 = xyz[3*tris[3*itri  ]-1];
                        u1 = uv[ 2*tris[3*itri+1]-2];
                        v1 = uv[ 2*tris[3*itri+1]-1];
                        x1 = xyz[3*tris[3*itri+1]-3];
                        y1 = xyz[3*tris[3*itri+1]-2];
                        z1 = xyz[3*tris[3*itri+1]-1];
                        u2 = uv[ 2*tris[3*itri+2]-2];
                        v2 = uv[ 2*tris[3*itri+2]-1];
                        x2 = xyz[3*tris[3*itri+2]-3];
                        y2 = xyz[3*tris[3*itri+2]-2];
                        z2 = xyz[3*tris[3*itri+2]-1];

                        mat[0] = x0 - x2;  mat[1] = x1 - x2;  mat[2] = -args[4].val[0];  rhs[0] = args[1].val[0] - x2;
                        mat[3] = y0 - y2;  mat[4] = y1 - y2;  mat[5] = -args[5].val[0];  rhs[1] = args[2].val[0] - y2;
                        mat[6] = z0 - z2;  mat[7] = z1 - z2;  mat[8] = -args[6].val[0];  rhs[2] = args[3].val[0] - z2;

                        status = matsol(mat, rhs, 3, s0s1tt);
                        if (status != SUCCESS) continue;

                        s0 = s0s1tt[0];
                        s1 = s0s1tt[1];
                        tt = s0s1tt[2];

                        if (tt < -EPS06 || s0 < -EPS06 || s1 < -EPS06 || (1-s0-s1) < -EPS06) continue;

                        if (tt < tbest) {
                            ibest  = iface;
                            tbest  = tt;
                            uv_[0] = s0 * (u0 - u2) + s1 * (u1 - u2) + u2;
                            uv_[1] = s0 * (v0 - v2) + s1 * (v1 - v2) + v2;
                            uv_[2] = tt;

                            /* newton iteration to put it on the surface (should usually converge
                               in fewer than 5 iterations) */
                            for (iter = 0; iter < 30; iter++) {
                                status = EG_evaluate(MODL->body[ibodyl].face[iface].eface, uv_, data);
                                CHECK_STATUS(EG_evaluate);

                                /* actually -1.0*residual */
                                rhs[0] = data[0] - (args[1].val[0] + uv_[2] * args[4].val[0]);
                                rhs[1] = data[1] - (args[2].val[0] + uv_[2] * args[5].val[0]);
                                rhs[2] = data[2] - (args[3].val[0] + uv_[2] * args[6].val[0]);

                                if (fabs(rhs[0]) < EPS06 && fabs(rhs[1]) < EPS06 && fabs(rhs[2]) < EPS06) break;

                                mat[0] = -data[3];   mat[1] = -data[6];   mat[2] = args[4].val[0];
                                mat[3] = -data[4];   mat[4] = -data[7];   mat[5] = args[5].val[0];
                                mat[6] = -data[5];   mat[7] = -data[8];   mat[8] = args[6].val[0];

                                status = matsol(mat, rhs, 3, duvt);
                                CHECK_STATUS(matsol);

                                uv_[0] += duvt[0];
                                uv_[1] += duvt[1];
                                uv_[2] += duvt[2];
                            }

                            xbest = data[0];
                            ybest = data[1];
                            zbest = data[2];
                        }
                    }
                }

            /* loop through all segments in all Edges to find closest projection */
            } else {
                ibest = 0;
                tbest = HUGEQ;
                xbest = HUGEQ;
                ybest = HUGEQ;
                zbest = HUGEQ;

                for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {
                    status = EG_getTessEdge(MODL->body[ibodyl].etess, iedge,
                                            &npnt, &xyz, &uv);
                    CATCH_STATUS(EG_getTessEdge);

                    for (ipnt = 1; ipnt < npnt; ipnt++) {
                        u0 = uv[   ipnt-1];
                        x0 = xyz[3*ipnt-3];
                        y0 = xyz[3*ipnt-2];
                        z0 = xyz[3*ipnt-1];
                        u1 = uv[   ipnt  ];
                        x1 = xyz[3*ipnt  ];
                        y1 = xyz[3*ipnt+1];
                        z1 = xyz[3*ipnt+2];

                        mat[0] = x0 - x1;  mat[1] = -args[4].val[0];  rhs[0] = args[1].val[0] - x0;
                        mat[2] = y0 - y1;  mat[3] = -args[5].val[0];  rhs[1] = args[2].val[0] - y0;
                        mat[4] = z0 - z1;  mat[5] = -args[6].val[0];  rhs[2] = args[3].val[0] - z0;

                        status = solsvd(mat, rhs, 3, 2, sval, s0s1tt);
                        if (status != SUCCESS) continue;

                        s0 = s0s1tt[0];
                        tt = s0s1tt[1];

                        if (tt < 0 || s0 < 0 || s0 > 1) continue;

                        if (tt < tbest) {
                            ibest  = iedge;
                            tbest  = tt;
                            uv_[0] = (1 - tt) * u0 + tt * u1;
                            uv_[1] = tt;

                            /* newton iteration to put it on the curve (should usually converge
                               in fewer than 5 iterations) */
                            for (iter = 0; iter < 30; iter++) {
                                status = EG_evaluate(MODL->body[ibodyl].edge[iedge].eedge, uv_, data);
                                CHECK_STATUS(EG_evaluate);

                                res[0] = data[0] - (args[1].val[0] + uv_[1] * args[4].val[0]);
                                res[1] = data[1] - (args[2].val[0] + uv_[1] * args[5].val[0]);
                                res[2] = data[2] - (args[3].val[0] + uv_[1] * args[6].val[0]);

                                if (fabs(res[0]) < EPS06 && fabs(res[1]) < EPS06 && fabs(res[2]) < EPS06) break;

                                mat[0] =  data[3]        * data[3]        + data[4]        * data[4]        + data[5]        * data[5];
                                mat[1] = -data[3]        * args[4].val[0] - data[4]        * args[5].val[0] - data[5]        * args[6].val[0];
                                mat[2] =  mat[1];
                                mat[3] =  args[4].val[0] * args[4].val[0] + args[5].val[0] * args[5].val[0] + args[6].val[0] * args[6].val[0];

                                rhs[0] = -data[3]        * res[0]         - data[4]        * res[1]         - data[5]        * res[2];
                                rhs[1] =  args[4].val[0] * res[0]         + args[5].val[0] * res[1]         + args[6].val[0] * res[2];

                                status = matsol(mat, rhs, 2, duvt);
                                CHECK_STATUS(matsol);

                                uv_[0] += duvt[0];
                                uv_[1] += duvt[1];
                            }

                            xbest = data[0];
                            ybest = data[1];
                            zbest = data[2];
                        }
                    }
                }
            }

            /* if any hits, store the results of the best in the @-parameters */
            if (ibest > 0) {
                if (NINT(args[7].val[0]) == 0) {
                    status = ocsmFindPmtr(MODL, "@iface", OCSM_INTERNAL, 1, 1, &AT_iface);
                    CATCH_STATUS(ocsmFindPmtr);

                    status = ocsmSetValuD(MODL, AT_iface, 1, 1, (double)ibest);
                    CATCH_STATUS(ocsmSetValuD);
                } else {
                    status = ocsmFindPmtr(MODL, "@iedge", OCSM_INTERNAL, 1, 1, &AT_iedge);
                    CATCH_STATUS(ocsmFindPmtr);

                    status = ocsmSetValuD(MODL, AT_iedge, 1, 1, (double)ibest);
                    CATCH_STATUS(ocsmSetValuD);
                }

                status = ocsmFindPmtr(MODL, "@xcg", OCSM_INTERNAL, 1, 1, &AT_xcg);
                CATCH_STATUS(ocsmFindPmtr);

                status = ocsmSetValuD(MODL, AT_xcg, 1, 1, xbest);
                CATCH_STATUS(ocsmSetValuD);

                status = ocsmFindPmtr(MODL, "@ycg", OCSM_INTERNAL, 1, 1, &AT_ycg);
                CATCH_STATUS(ocsmFindPmtr);

                status = ocsmSetValuD(MODL, AT_ycg, 1, 1, ybest);
                CATCH_STATUS(ocsmSetValuD);

                status = ocsmFindPmtr(MODL, "@zcg", OCSM_INTERNAL, 1, 1, &AT_zcg);
                CATCH_STATUS(ocsmFindPmtr);

                status = ocsmSetValuD(MODL, AT_zcg, 1, 1, zbest);
                CATCH_STATUS(ocsmSetValuD);

            /* otherwise, return an error */
            } else {
                status = OCSM_FACE_NOT_FOUND;
                signalError(MODL, status,
                            "no Face was found");
                goto next_branch;
            }

        /* execute: "macbeg imacro" */
        } else if (type == OCSM_MACBEG) {
            SPRINT2(1, "    executing [%4d] macbeg:     %11.5f",
                    ibrch, args[1].val[0]);

            /* determine the storage location */
            imacro = NINT(args[1].val[0]);

            if (imacro < 1 || imacro > MAX_NUM_MACROS) {
                status = OCSM_ILLEGAL_MACRO_INDEX;
                CATCH_STATUS(macbeg);
            }

            /* an error if storage location is not empty */
            if (macros[imacro] > 0) {
                status = OCSM_STORAGE_ALREADY_USED;
                CATCH_STATUS(macbeg);
            }


            macros[imacro] = ibrch;

            SPRINT2(1, "                          Storing Branch %4d in storage %d", ibrch, imacro);

        /* execute: "macend" */
        } else if (type == OCSM_MACEND) {
            SPRINT1(1, "    executing [%4d] macend:",
                    ibrch);

            npatn--;
            ibrch = patn[npatn].iend;

        /* execute: "recall imacro" */
        } else if (type == OCSM_RECALL) {
            SPRINT2(1, "    executing [%4d] recall:     %11.5f",
                    ibrch, args[1].val[0]);

            /* determine the storage location */
            imacro = NINT(args[1].val[0]);

            if (imacro < 1 || imacro > MAX_NUM_MACROS) {
                status = OCSM_ILLEGAL_MACRO_INDEX;
                CATCH_STATUS(recall);
            } else if (macros[imacro] <= 0) {
                status = OCSM_NOTHING_PREVIOUSLY_STORED;
                CATCH_STATUS(recall);
            }

            if (npatn < MAX_NESTING) {
                patn[npatn].itype = OCSM_RECALL;
                patn[npatn].ibeg  = macros[imacro];
                patn[npatn].iend  = ibrch;
                patn[npatn].ncopy =  1;
                patn[npatn].icopy = +1;
                patn[npatn].ipmtr = -1;
                npatn++;
            } else {
                status = OCSM_NESTED_TOO_DEEPLY;
                signalError(MODL, status,
                            "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
            }

            /* start executing just after the macbeg */
            ibrch = macros[imacro];

            SPRINT1(1, "                          Entering storage %d", imacro);

        /* execute: "store $name index=0 keep=0" */
        } else if (type ==OCSM_STORE) {
            SPRINT4(1, "    executing [%4d] store:      %s  %11.5f  %11.5f",
                    ibrch, args[1].str, args[2].val[0], args[3].val[0]);

            /* if $name is . (dot), pop one Body off the stack */
            if (strcmp(args[1].str, ".") == 0) {
                if (args[2].val[0] != 0 || args[3].val[0] != 0) {
                    SPRINT0(1, "WARNING:: index and keep ignored since $name=.");
                    (MODL->nwarn)++;
                }

                nstack--;
                SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack]);

                if (stack[nstack] == 0) {
                    status = setupAtPmtrs(MODL, -1);

                    goto next_branch;
                }

            /* if $name is .. (dot-dot), pop all Bodys off stack back to the Mark
               (or until stack is empty) */
            } else  if (strcmp(args[1].str, "..") == 0) {
                if (args[2].val[0] != 0 || args[3].val[0] != 0) {
                    SPRINT0(1, "WARNING:: index and keep ignored since $name=..");
                    (MODL->nwarn)++;
                }

                while (nstack > 0) {
                    if (stack[nstack-1] == 0) {
                        nstack--;
                        break;
                    } else {
                        nstack--;
                        SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack]);
                    }
                }

            /* if $name is ... (ellipsis), pop all Bodys off stack */
            } else if (strcmp(args[1].str, "...") == 0) {
                if (args[2].val[0] != 0 || args[3].val[0] != 0) {
                    SPRINT0(1, "WARNING:: index and keep ignored since $name=...");
                    (MODL->nwarn)++;
                }

                while (nstack > 0) {
                    nstack--;
                    SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack]);
                }

            } else {
                /* find the Body on the top of the stack */
                if (nstack < 1) {
                    status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                    signalError(MODL, status,
                                "STORE expects a Body on the stack");
                    goto next_branch;
                } else {
                    ibodyl = stack[nstack-1];
                }

                /* if ibodyl is 0, it is a mark, so return an error */
                if (ibodyl == 0) {
                    status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                    signalError(MODL, status,
                                "STORE cannot be applied to a MARK");
                    goto next_branch;
                } else {
                    igroup = MODL->body[ibodyl].igroup;
                }

                /* see if name/index is already used */
                istor = -1;

                for (jstor = 0; jstor < MODL->nstor; jstor++) {
                    if (strcmp(args[1].str, MODL->stor[jstor].name) == 0 &&
                        NINT(args[2].val[0]) ==  MODL->stor[jstor].index   ) {
                        istor = jstor;
                        SPRINT2(1, "WARNING:: storage %s (%d) is being overwritten",
                                MODL->stor[jstor].name, MODL->stor[jstor].index);
                        (MODL->nwarn)++;
                        break;
                    }
                }

                /* make a list to keep track of the Bodys that should be stored */
                MALLOC(iblist, int, nstack);

                nblist = 0;
                while (nstack > 0) {
                    ibodyl = stack[--nstack];
                    if (ibodyl <= 0) {
                        if (nstack < MAX_STACK_SIZE) {
                            nstack++;
                        } else {
                            status = OCSM_TOO_MANY_BODYS_ON_STACK;
                            signalError(MODL, status,
                                        "Too many Bodys on Stack");
                            goto cleanup;
                        }
                        break;
                    }

                    if (MODL->body[ibodyl].igroup != igroup) {
                        if (nstack < MAX_STACK_SIZE) {
                            nstack++;
                        } else {
                            status = OCSM_TOO_MANY_BODYS_ON_STACK;
                            signalError(MODL, status,
                                        "Too many Bodys on Stack");
                            goto cleanup;
                        }
                        break;
                    }

                    iblist[nblist++] = ibodyl;
                }

                /* if storage does not exist, create it now */
                if (istor < 0) {
                    istor = MODL->nstor;

                    (MODL->nstor)++;
                    RALLOC(MODL->stor, stor_T, MODL->nstor);

                    STRNCPY(MODL->stor[istor].name, args[1].str, MAX_NAME_LEN);
                    MODL->stor[istor].index = NINT(args[2].val[0]);
                    MODL->stor[istor].nbody = nblist;
                    MODL->stor[istor].ibody = NULL;
                    MODL->stor[istor].ebody = NULL;

                    MALLOC(MODL->stor[istor].ibody, int, MODL->stor[istor].nbody);
                    MALLOC(MODL->stor[istor].ebody, ego, MODL->stor[istor].nbody);
                }

                /* if the keep flag is set, restore the stack */
                if (NINT(args[3].val[0]) == 1) {
                    if (nstack+nblist < MAX_STACK_SIZE) {
                        nstack += nblist;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }

                /* save the Body info */
                for (i = MODL->stor[istor].nbody-1; i >= 0; i--) {
                    ibodyl = iblist[i];

                    MODL->stor[istor].ibody[i] = ibodyl;
                    MODL->stor[istor].ebody[i] = MODL->body[ibodyl].ebody;

                    SPRINT1(1, "                          Body   %4d stored", ibodyl);
                }

                FREE(iblist);
            }

        /* execute: "patbeg $pmtrName ncopy" */
        } else if (type == OCSM_PATBEG) {
            SPRINT3(1, "    executing [%4d] patbeg:         %s  %11.5f",
                    ibrch, args[1].str, args[2].val[0]);

            if (npatn < MAX_NESTING) {
                patn[npatn].itype = OCSM_PATBEG;
                patn[npatn].ibeg  = ibrch;
                patn[npatn].iend  = -1;
                patn[npatn].ncopy = NINT(args[2].val[0]);
                patn[npatn].icopy =  1;
                patn[npatn].ipmtr = -1;
            } else {
                status = OCSM_NESTED_TOO_DEEPLY;
                signalError(MODL, status,
                            "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                CATCH_STATUS(patbeg);
            }

            /* store info about this pattern */
            /* find matching patend */
            icount = 1;
            for (ibrchl = ibrch+1; ibrchl <= MODL->nbrch; ibrchl++) {
                if        (MODL->brch[ibrchl].type == OCSM_PATBEG) {
                    icount++;
                } else if (MODL->brch[ibrchl].type == OCSM_PATEND) {
                    icount--;

                    if (icount == 0) {
                        patn[npatn].iend = ibrchl;
                        break;
                    }
                }
            }

            /* find the pmtrName */
            status = ocsmFindPmtr(MODL, args[1].str, OCSM_INTERNAL, 1, 1,
                                  &(patn[npatn].ipmtr));
            CATCH_STATUS(ocsmFindPmtr);

            /* if no copies are required, jump to Branch after patend */
            if (patn[npatn].ncopy < 1) {
                if (patn[npatn].iend > patn[npatn].ibeg) {
                    ibrch = patn[npatn].iend;
                } else {
                    break;    /* used if no matching patend */
                }

            /* otherwise increment the number of patterns and continue */
            } else {
                irow = icol = 1;

                status = ocsmSetValuD(MODL, patn[npatn].ipmtr, irow, icol, 1.0);
                CATCH_STATUS(ocsmSetValuD);

                SPRINT2(1, "                          pattern counter: %s = %3d",
                        MODL->pmtr[patn[npatn].ipmtr].name, 1);

                npatn++;
            }

        /* execute: "patbreak expr" */
        } else if (type == OCSM_PATBREAK) {
            SPRINT2(1, "    executing [%4d] patbreak:       %11.5f",
                    ibrch, args[1].val[0]);

            /* break out of this pattern if the argument is positive */
            if (args[1].val[0] > 0) {
                npatn--;

                while (ibrch < MODL->nbrch && MODL->brch[ibrch].type != OCSM_PATEND) {
                    ibrch++;
                }
            }

        /* execute: "patend" */
        } else if (type == OCSM_PATEND) {
            SPRINT1(1, "    executing [%4d] patend:",
                    ibrch);

            /* increment the iterator */
            (patn[npatn-1].icopy)++;

            /* go back for another copy */
            if (patn[npatn-1].icopy <= patn[npatn-1].ncopy) {
                newValue = patn[npatn-1].icopy;

                irow = icol = 1;

                status = ocsmSetValuD(MODL, patn[npatn-1].ipmtr, irow, icol, newValue);
                CATCH_STATUS(ocsmSetValuD);

                ibrch = patn[npatn-1].ibeg;

                SPRINT2(1, "                          pattern counter: %s = %3d",
                        MODL->pmtr[patn[npatn-1].ipmtr].name, patn[npatn-1].icopy);

            /* otherwise, we are finished with the pattern */
            } else {
                npatn--;
            }

        /* execute: "ifthen val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0" */
        } else if (type == OCSM_IFTHEN) {

            /* evaluate val1 $op1 val2 */
            bool1 = 0;
            if        (strcmp(args[2].str, "lt") == 0 ||
                       strcmp(args[2].str, "LT") == 0   ) {
                if (args[1].val[0] <  args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "le") == 0 ||
                       strcmp(args[2].str, "LE") == 0   ) {
                if (args[1].val[0] <= args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "eq") == 0 ||
                       strcmp(args[2].str, "EQ") == 0   ) {
                if (args[1].val[0] == args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "ge") == 0 ||
                       strcmp(args[2].str, "GE") == 0   ) {
                if (args[1].val[0] >= args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "gt") == 0 ||
                       strcmp(args[2].str, "GT") == 0   ) {
                if (args[1].val[0] >  args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "ne") == 0 ||
                       strcmp(args[2].str, "NE") == 0   ) {
                if (args[1].val[0] != args[3].val[0]) bool1 = 1;
            }

            /* set up for lazy evaluations */
            if        (strcmp(args[4].str, "and") == 0 ||
                       strcmp(args[4].str, "AND") == 0   ) {
                if (bool1 == 0) {
                    bool2  =  0;
                } else {
                    bool2  = -1;
                }
            } else if (strcmp(args[4].str, "or") == 0 ||
                       strcmp(args[4].str, "OR") == 0   ) {
                if (bool1 == 0) {
                    bool2  = -1;
                } else {
                    bool2  =  1;
                }
            } else if (strcmp(args[4].str, "xor") == 0 ||
                       strcmp(args[4].str, "XOR") == 0   ) {
                bool2  = -1;
            } else {
                bool2 = 0;
            }

            /* no need to evaluate last 3 arguments */
            if (bool2 >= 0) {
                SPRINT5(1, "    executing [%4d] ifthen:         %11.5f  %s  %11.5f  %s  ...",
                        ibrch, args[1].val[0], args[2].str, args[3].val[0], args[4].str);

            /* evaluate last 3 arguments */
            } else {
                for (iarg = 5; iarg <= 7; iarg++) {
                    if (iarg == 5) strcpy(thisArg, MODL->brch[ibrch].arg5);
                    if (iarg == 6) strcpy(thisArg, MODL->brch[ibrch].arg6);
                    if (iarg == 7) strcpy(thisArg, MODL->brch[ibrch].arg7);

                    status = str2vals(thisArg, MODL, &(args[iarg].nrow), &(args[iarg].ncol), &values, &dots, str);
                    if (status < SUCCESS) {
                        SPRINT4(0, "ERROR:: problem evaluating argument %d (%s) for Branch %d (%s)",
                                iarg, thisArg, ibrch, ocsmGetText(MODL->brch[ibrch].type));
                        CATCH_STATUS(str2vals);
                    }

                    if (STRLEN(str) > 0) {
                        FREE(  args[iarg].str);
                        MALLOC(args[iarg].str, char, MAX_STRVAL_LEN);

                        args[iarg].nval = 0;
                        STRNCPY(args[iarg].str, str, MAX_STRVAL_LEN);
                    } else {
                        args[iarg].nval = (args[iarg].nrow) * (args[iarg].ncol);

                        FREE(  args[iarg].val);   /* also free's .str since they are unioned */
                        MALLOC(args[iarg].val, double, args[iarg].nval);

                        FREE(  args[iarg].dot);
                        MALLOC(args[iarg].dot, double, args[iarg].nval);

                        for (i = 0; i < args[iarg].nval; i++) {
                            args[iarg].val[i] = values[i];
                            args[iarg].dot[i] = dots[  i];
                        }
                    }

                    FREE(values);
                    FREE(dots  );
                }

                SPRINT8(1, "    executing [%4d] ifthen:         %11.5f  %s  %11.5f  %s  %11.5f  %s  %11.5f",
                        ibrch, args[1].val[0], args[2].str, args[3].val[0], args[4].str,
                        args[5].val[0], args[6].str, args[7].val[0]);

                /* evaluate val3 $op3 val4 */
                bool2 = 0;
                if        ((strcmp(args[4].str, "or") == 0 ||
                            strcmp(args[4].str, "OR") == 0   ) && bool1 == 1) {
                    bool2 = 1;
                } else if ((strcmp(args[4].str, "and") == 0 ||
                            strcmp(args[4].str, "AND") == 0   ) && bool1 == 0) {
                    bool2 = 0;
                } else if (strcmp(args[6].str, "lt") == 0 ||
                           strcmp(args[6].str, "LT") == 0   ) {
                    if (args[5].val[0] <  args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "le") == 0 ||
                           strcmp(args[6].str, "LE") == 0   ) {
                    if (args[5].val[0] <= args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "eq") == 0 ||
                           strcmp(args[6].str, "EQ") == 0   ) {
                    if (args[5].val[0] == args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "ge") == 0 ||
                           strcmp(args[6].str, "GE") == 0   ) {
                    if (args[5].val[0] >= args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "gt") == 0 ||
                           strcmp(args[6].str, "GT") == 0   ) {
                    if (args[5].val[0] >  args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "ne") == 0 ||
                           strcmp(args[6].str, "NE") == 0   ) {
                    if (args[5].val[0] != args[7].val[0]) bool2 = 1;
                }
            }

            /* evaluate (val1 $op1 val2) $op2 (val3 $op3 val4) */
            bool3 = 0;
            if        (strcmp(args[4].str, "or") == 0 ||
                       strcmp(args[4].str, "OR") == 0   ) {
                bool3 = bool1 || bool2;
            } else if (strcmp(args[4].str, "and") == 0 ||
                       strcmp(args[4].str, "AND") == 0   ) {
                bool3 = bool1 && bool2;
            } else if (strcmp(args[4].str, "xor") == 0 ||
                       strcmp(args[4].str, "XOR") == 0   ) {
                bool3 = bool1 != bool2;
            }

            /* remember that we are in an IFTHEN structure */
            if (npatn < MAX_NESTING) {
                patn[npatn].itype = OCSM_IFTHEN;
                patn[npatn].ibeg  = ibrch;
                patn[npatn].iend  = -1;
                patn[npatn].ncopy = bool3;
                patn[npatn].icopy = -1;
                patn[npatn].ipmtr = -1;
                npatn++;
            } else {
                status = OCSM_NESTED_TOO_DEEPLY;
                signalError(MODL, status,
                            "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
            }

            /* if expression evaluated to false, skip to next matching
               ELSEIF, ELSE, or ENDIF */
            if (bool3 == 0) {
                ibrch++;
                icount = 0;   /* tells number of IFTHEN blocks that are within
                                 the one that evaluated to false */
                while (ibrch <= MODL->nbrch) {
                    if        (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                        icount++;
                    } else if (MODL->brch[ibrch].type == OCSM_ELSEIF ||
                               MODL->brch[ibrch].type == OCSM_ELSE     ) {
                        if (icount == 0) {
                            ibrch--;
                            break;
                        }
                    } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
                        if (icount == 0) {
                            ibrch--;
                            break;
                        } else {
                            icount--;
                        }
                    }
                    ibrch++;
                }
            }

        /* execute: "elseif val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0" */
        } else if (type == OCSM_ELSEIF) {

            /* if we got here by executing the previous IFTHEN block, skip to
               just before the next matching ENDIF Branch */
            if (patn[npatn-1].ncopy == 1) {
                icount = 0;   /* tells number of IFTHEN blocks that are within
                                 the one that evaluated to false */
                while (ibrch <= MODL->nbrch) {
                    if        (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                        icount++;
                    } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
                        if (icount == 0) {
                            ibrch--;
                            break;
                        } else {
                            icount--;
                        }
                    }
                    ibrch++;
                }
            } else {

                /* evaluate val1 $op1 val2 */
                bool1 = 0;
                if        (strcmp(args[2].str, "lt") == 0 ||
                           strcmp(args[2].str, "LT") == 0   ) {
                    if (args[1].val[0] <  args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "le") == 0 ||
                           strcmp(args[2].str, "LE") == 0   ) {
                    if (args[1].val[0] <= args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "eq") == 0 ||
                           strcmp(args[2].str, "EQ") == 0   ) {
                    if (args[1].val[0] == args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "ge") == 0 ||
                           strcmp(args[2].str, "GE") == 0   ) {
                    if (args[1].val[0] >= args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "gt") == 0 ||
                           strcmp(args[2].str, "GT") == 0   ) {
                    if (args[1].val[0] >  args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "ne") == 0 ||
                           strcmp(args[2].str, "NE") == 0   ) {
                    if (args[1].val[0] != args[3].val[0]) bool1 = 1;
                }

                /* set up for lazy evaluations */
                if        (strcmp(args[4].str, "and") == 0 ||
                           strcmp(args[4].str, "AND") == 0   ) {
                    if (bool1 == 0) {
                        bool2  =  0;
                    } else {
                        bool2  = -1;
                    }
                } else if (strcmp(args[4].str, "or") == 0 ||
                           strcmp(args[4].str, "OR") == 0   ) {
                    if (bool1 == 0) {
                        bool2  = -1;
                    } else {
                        bool2  =  1;
                    }
                } else if (strcmp(args[4].str, "xor") == 0 ||
                           strcmp(args[4].str, "XOR") == 0   ) {
                    bool2  = -1;
                } else {
                    bool2 = 0;
                }

                /* no need to evaluate last 3 arguments */
                if (bool2 >= 0) {
                    SPRINT4(1, "    executing [%4d] elseif:         %11.5f  %s  %11.5f  ...",
                            ibrch, args[1].val[0], args[2].str, args[3].val[0]);

                /* evaluate last 3 arguments */
                } else {
                    for (iarg = 5; iarg <= 7; iarg++) {
                        if (iarg == 5) strcpy(thisArg, MODL->brch[ibrch].arg5);
                        if (iarg == 6) strcpy(thisArg, MODL->brch[ibrch].arg6);
                        if (iarg == 7) strcpy(thisArg, MODL->brch[ibrch].arg7);

                        status = str2vals(thisArg, MODL, &(args[iarg].nrow), &(args[iarg].ncol), &values, &dots, str);
                        if (status < SUCCESS) {
                            SPRINT4(0, "ERROR:: problem evaluating argument %d (%s) for Branch %d (%s)",
                                    iarg, thisArg, ibrch, ocsmGetText(MODL->brch[ibrch].type));
                            CATCH_STATUS(str2vals);
                        }

                        if (STRLEN(str) > 0) {
                            FREE(  args[iarg].str);
                            MALLOC(args[iarg].str, char, MAX_STRVAL_LEN);

                            args[iarg].nval = 0;
                            STRNCPY(args[iarg].str, str, MAX_STRVAL_LEN);
                        } else {
                            args[iarg].nval = (args[iarg].nrow) * (args[iarg].ncol);

                            FREE(  args[iarg].val);   /* also free's .str since they are unioned */
                            MALLOC(args[iarg].val, double, args[iarg].nval);

                            FREE(  args[iarg].dot);
                            MALLOC(args[iarg].dot, double, args[iarg].nval);

                            for (i = 0; i < args[iarg].nval; i++) {
                                args[iarg].val[i] = values[i];
                                args[iarg].dot[i] = dots[  i];
                            }
                        }

                        FREE(values);
                        FREE(dots  );
                    }

                    SPRINT8(1, "    executing [%4d] elseif:         %11.5f  %s  %11.5f  %s  %11.5f  %s  %11.5f",
                            ibrch, args[1].val[0], args[2].str, args[3].val[0], args[4].str,
                            args[5].val[0], args[6].str, args[7].val[0]);

                    /* evaluate val3 $op3 val4 */
                    bool2 = 0;
                    if        ((strcmp(args[4].str, "or") == 0 ||
                                strcmp(args[4].str, "OR") == 0   ) && bool1 == 1) {
                        bool2 = 1;
                    } else if ((strcmp(args[4].str, "and") == 0 ||
                                strcmp(args[4].str, "AND") == 0   ) && bool1 == 0) {
                        bool2 = 0;
                    } else if (strcmp(args[6].str, "lt") == 0 ||
                               strcmp(args[6].str, "LT") == 0   ) {
                        if (args[5].val[0] <  args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "le") == 0 ||
                               strcmp(args[6].str, "LE") == 0   ) {
                        if (args[5].val[0] <= args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "eq") == 0 ||
                               strcmp(args[6].str, "EQ") == 0   ) {
                        if (args[5].val[0] == args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "ge") == 0 ||
                               strcmp(args[6].str, "GE") == 0   ) {
                        if (args[5].val[0] >= args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "gt") == 0 ||
                               strcmp(args[6].str, "GT") == 0   ) {
                        if (args[5].val[0] >  args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "ne") == 0 ||
                               strcmp(args[6].str, "NE") == 0   ) {
                        if (args[5].val[0] != args[7].val[0]) bool2 = 1;
                    }
                }

                /* evaluate (val1 $op1 val2) $op2 (val3 $op3 val4) */
                bool3 = 0;
                if        (strcmp(args[4].str, "or") == 0 ||
                           strcmp(args[4].str, "OR") == 0   ) {
                    bool3 = bool1 || bool2;
                } else if (strcmp(args[4].str, "and") == 0 ||
                           strcmp(args[4].str, "AND") == 0   ) {
                    bool3 = bool1 && bool2;
                } else if (strcmp(args[4].str, "xor") == 0 ||
                           strcmp(args[4].str, "XOR") == 0   ) {
                    bool3 = bool1 != bool2;
                }

                patn[npatn-1].ncopy = bool3;

                /* if expression evaluated to false, skip to next matching
                   elseif, else, or endif */
                if (bool3 == 0) {
                    ibrch++;
                    icount = 0;
                    while (ibrch <= MODL->nbrch) {
                        if        (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                            icount++;
                        } else if (MODL->brch[ibrch].type == OCSM_ELSEIF ||
                                   MODL->brch[ibrch].type == OCSM_ELSE     ) {
                            if (icount == 0) {
                                ibrch--;
                                break;
                            }
                        } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
                            if (icount == 0) {
                                ibrch--;
                                break;
                            } else {
                                icount--;
                            }
                        }
                        ibrch++;
                    }
                }
            }

        /* execute: "else" */
        } else if (type == OCSM_ELSE) {

            /* if we got here by executing the previous ifthen block, skip to
               just before the next matching endif Branch */
            if (patn[npatn-1].ncopy == 1) {
                icount = 0;   /* tells number of IFTHEN blocks that are within
                                 the one that evaluated to false */
                while (ibrch <= MODL->nbrch) {
                    if        (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                        icount++;
                    } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
                        if (icount == 0) {
                            ibrch--;
                            break;
                        } else {
                            icount--;
                        }
                    }
                    ibrch++;
                }
            } else {
                SPRINT1(1, "    executing [%4d] else:",
                        ibrch);
            }

        /* execute: "endif" */
        } else if (type == OCSM_ENDIF) {

            /* remove the patn associated with the ifthen statement */
            npatn--;

        /* execute: "throw sigCode" */
        } else if (type == OCSM_THROW) {
            SPRINT2(1, "    executing [%4d] throw:          %11.5f",
                    ibrch, args[1].val[0]);

            /* set the signal */
            signalError(MODL, NINT(args[1].val[0]),
                        "signal %d thrown by user", NINT(args[1].val[0]));
            goto next_branch;

        /* execute: "catbeg sigCode" */
        } else if (type == OCSM_CATBEG) {
            SPRINT2(1, "    executing [%4d] catbeg:         %s",
                    ibrch, MODL->brch[ibrch].arg1);

            icatch = 0;
            if (MODL->brch[ibrch].arg1[0] != '$') {
                icatch = NINT(args[1].val[0]);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$all"                        ) == 0) {
                icatch = 0;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$body_not_found"             ) == 0) {
                icatch = OCSM_BODY_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$colinear_sketch_points"     ) == 0) {
                icatch = OCSM_COLINEAR_SKETCH_POINTS;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$created_too_many_bodys"     ) == 0) {
                icatch = OCSM_CREATED_TOO_MANY_BODYS;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$did_not_create_body"        ) == 0) {
                icatch = OCSM_DID_NOT_CREATE_BODY;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$edge_not_found"             ) == 0) {
                icatch = OCSM_EDGE_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$error_in_bodys_on_stack"    ) == 0) {
                icatch = OCSM_ERROR_IN_BODYS_ON_STACK;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$face_not_found"             ) == 0) {
                icatch = OCSM_FACE_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$file_not_found"             ) == 0) {
                icatch = OCSM_FILE_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$func_arg_out_of_bounds"     ) == 0) {
                icatch = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_argument"           ) == 0) {
                icatch = OCSM_ILLEGAL_ARGUMENT;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_attribute"          ) == 0) {
                icatch = OCSM_ILLEGAL_ATTRIBUTE;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_csystem"            ) == 0) {
                icatch = OCSM_ILLEGAL_CSYSTEM;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_pmtr_name"          ) == 0) {
                icatch = OCSM_ILLEGAL_PMTR_NAME;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_value"              ) == 0) {
                icatch = OCSM_ILLEGAL_VALUE;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$insufficient_bodys_on_stack") == 0) {
                icatch = OCSM_INSUFFICIENT_BODYS_ON_STACK;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$name_not_found"             ) == 0) {
                icatch = OCSM_NAME_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$node_not_found"             ) == 0) {
                icatch = OCSM_NODE_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$non_coplanar_sketch_points" ) == 0) {
                icatch = OCSM_NON_COPLANAR_SKETCH_POINTS;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$no_selection"               ) == 0) {
                icatch = OCSM_NO_SELECTION;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$not_converged"              ) == 0) {
                icatch = OCSM_NOT_CONVERGED;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$self_intersecting"          ) == 0) {
                icatch = OCSM_SELF_INTERSECTING;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$wrong_types_on_stack"       ) == 0) {
                icatch = OCSM_WRONG_TYPES_ON_STACK;
            } else {
                status = OCSM_ILLEGAL_VALUE;
                signalError(MODL, status,
                            "unknown signal type (%s)", MODL->brch[ibrch].arg1);
                CATCH_STATUS(OCSM_NAME_NOT_FOUND);
            }

            /* if we are catching any signal and one is set, catch it and reset the signal */
            if (icatch == 0 && MODL->sigCode != 0) {
                SPRINT2(0, "    --> catching signal %d (%s)", MODL->sigCode, ocsmGetText(MODL->sigCode));

                status = ocsmFindPmtr(MODL, "@signal", OCSM_INTERNAL, 1, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                status = ocsmSetValuD(MODL, ipmtr, 1, 1, (double)(MODL->sigCode));
                CHECK_STATUS(ocsmSetValuD);

                MODL->sigCode    = 0;
                MODL->sigMesg[0] = '\0';
                npatn_sig        = -1;

            /* if there is no uncaught signal, or the uncaught signal
               does not match this catbeg, skip to the matching catend */
            } else if (icatch == 0 || MODL->sigCode == 0 || MODL->sigCode != icatch) {
                icount = 1;
                while (ibrch < MODL->nbrch) {
                    ibrch++;

                    if        (MODL->brch[ibrch].type == OCSM_CATBEG) {
                        icount++;
                    } else if (MODL->brch[ibrch].type == OCSM_CATEND) {
                        icount--;

                        if (icount == 0) {
                            break;
                        }
                    }
                }

            /* otherwise catch this signal by resetting the signal */
            } else {
                SPRINT2(0, "    --> catching signal %d (%s)", MODL->sigCode, ocsmGetText(MODL->sigCode));
                MODL->sigCode    = 0;
                MODL->sigMesg[0] = '\0';
                npatn_sig        = -1;
            }

        /* execute: "catend" */
        } else if (type == OCSM_CATEND) {

        /* execute: "mark" */
        } else if (type == OCSM_MARK) {
            SPRINT1(1, "    executing [%4d] mark:",
                    ibrch);

            /* push a Mark onto the stack */
            stack[nstack++] = 0;

            SPRINT0(1, "                          Mark        created");

        /* execute: "group nbody=0" */
        } else if (type == OCSM_GROUP) {
            SPRINT2(1, "    executing [%4d] group:         %11.5f",
                    ibrch, args[1].val[0]);

            /* make sure that there is a Body on the stack */
            if (nstack < 1) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "GROUP expects a Body on the stack");
                goto next_branch;
            } else if (stack[nstack-1] <= 0) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "GROUP expects a Body on the stack");
                goto next_branch;
            }

            /* the number of Bodys specified */
            ngroup = NINT(args[1].val[0]);

            /* if nbody is negative, break up the current group */
            if (ngroup < 0) {

                /* change the group number for all Bodys on stack which are in the same group
                   as teh Body on te top of the stack */
                for (istack = nstack-2; istack >= 0; istack--) {
                    if (stack[istack] > 0) {
                        if (MODL->body[stack[istack]].igroup == MODL->body[stack[nstack-1]].igroup) {
                            (MODL->ngroup)++;
                            MODL->body[stack[istack]].igroup = MODL->ngroup;
                        }
                    }
                }

            } else {
                istack = nstack - 1;
                igroup = MODL->body[stack[istack]].igroup;


                /* if ngroup is not given, potentially group all Bodys */
                if (ngroup == 0) {
                    ngroup = MODL->nbody;
                }

                /* loop back through the stack */
                while (istack > 0) {
                    istack--;

                    /* Sketch found -- error */
                    if (stack[istack] < 0) {
                        status = OCSM_WRONG_TYPES_ON_STACK;
                        signalError(MODL, status,
                                    "GROUP expects Bodys on the stack");
                        goto next_branch;

                        /* Body found, so change its Group */
                    } else if (stack[istack] > 0) {
                        MODL->body[stack[istack]].igroup = igroup;
                        SPRINT2(1, "                          Body   %4d added to Group %4d",
                                stack[istack], igroup);

                        /* if ngroup was given and we already have grouped
                           them, we are done */
                        ngroup--;
                        if (ngroup < 0) break;

                        /* Mark found, so remove it from the stack */
                    } else {
                        while (istack < nstack) {
                            stack[istack] = stack[istack+1];
                            istack++;
                        }

                        nstack--;
                        break;
                    }
                }
            }

            /* if the group statement has Attributes, apply to all Bodys in the Group */
            if (stack[nstack-1] > 0 && MODL->brch[ibrch].nattr > 0) {
                for (ibody = 1; ibody <= MODL->nbody; ibody++) {
                    if (MODL->body[ibody].igroup != MODL->body[stack[nstack-1]].igroup) continue;
                    ebody = MODL->body[ibody].ebody;

                    status = setEgoAttribute(MODL, ibrch, ebody);
                    CATCH_STATUS(setEgoAttribute);
                }
            }

        /* execute: "dump $filename remove=0 toMark=0" */
        } else if (type == OCSM_DUMP) {
            SPRINT4(1, "    executing [%4d] dump:       %s  %11.5f  %11.5f",
                    ibrch, args[1].str, args[2].val[0], args[3].val[0]);

            /* make sure that there is a Body on the stack */
            if (nstack < 1) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "DUMP expects a Body on the stack");
                goto next_branch;
            }

            /* check that an extension (filetype) was given */
            extension = NULL;
            for (i = STRLEN(args[1].str)-1; i > 1; i--) {
                if (args[1].str[i] == '.') {
                    extension = &(args[1].str[i]);
                    break;
                }
            }
            if (extension == NULL) {
                status = OCSM_FILE_NOT_FOUND;
                signalError(MODL, status,
                            "no filetype specified");
                goto next_branch;

            /* if the filetype is .stl or .STL, write a stereo-lithography file */
            } else if (strcmp(extension, ".stl") == 0 || strcmp(extension, ".STL") == 0) {

                if (NINT(args[3].val[0]) == 1) {
                    status = writeAsciiStl(MODL, nstack, stack, args[1].str);
                    CHECK_STATUS(writeAsciiStl);

                    SPRINT0(1, "WARNING:: multiple Bodys in STL file is non-standard");
                    (MODL->nwarn)++;

                    for (istack = 0; istack < nstack; istack++) {
                        if (stack[istack] > 0) {
                            SPRINT1(1, "                          Body   %4d dumped", stack[istack]);
                        }
                    }
                } else {
                    status = writeAsciiStl(MODL, 1, &(stack[nstack-1]), args[1].str);
                    CHECK_STATUS(writeAsciiStl);

                    SPRINT1(1, "                          Body   %4d dumped", stack[nstack-1]);

                    if (NINT(args[2].val[0]) == 1) {
                        SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack-1]);
                        nstack--;
                    }
                }

            /* if the filetype is .bstl or .BSTL, write a binary stereo-lithography file */
            } else if (strcmp(extension, ".bstl") == 0 || strcmp(extension, ".BSTL") == 0) {

                if (NINT(args[3].val[0]) == 1) {
                    status = writeBinaryStl(MODL, nstack, stack, args[1].str);
                    CHECK_STATUS(writeBinaryStl);

                    SPRINT0(1, "WARNING:: multiple Bodys in STL file is non-standard");
                    (MODL->nwarn)++;

                    for (istack = 0; istack < nstack; istack++) {
                        if (stack[istack] > 0) {
                            SPRINT1(1, "                          Body   %4d dumped", stack[istack]);
                        }
                    }
                } else {
                    status = writeBinaryStl(MODL, 1, &(stack[nstack-1]), args[1].str);
                    CHECK_STATUS(writeBinaryStl);

                    SPRINT1(1, "                          Body   %4d dumped", stack[nstack-1]);

                    if (NINT(args[2].val[0]) == 1) {
                        SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack-1]);
                        nstack--;
                    }
                }

            /* if the filetype is .ugrid or .UGRID, write a AFLR3 input file */
            } else if (strcmp(extension, ".ugrid") == 0 || strcmp(extension, ".UGRID") == 0) {

                if (NINT(args[3].val[0]) == 1) {
                    status = OCSM_FILE_NOT_FOUND;
                    signalError(MODL, status,
                                "only one Body can be written to .ugrid file");
                    goto next_branch;
                }

                SPRINT1(1, "                          Body   %4d dumped", stack[nstack-1]);
                if (NINT(args[2].val[0]) == 1) {
                    SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack-1]);
                    nstack--;
                }

                /* write the file */
                status = writeAsciiUgrid(MODL, stack[nstack-1], args[1].str);
                CHECK_STATUS(writeAsciiUgrid);

            /* if the filetype is .plot, write points into plotfile */
            } else if (strcmp(extension, ".plot") == 0 || strcmp(extension, ".PLOT") == 0) {
                ibody = stack[nstack-1];

                if (MODL->body[ibody].etess == NULL) {
                    status = tessellate(MODL, ibody);
                    CHECK_STATUS(tessellate);
                }

                /* count unique points */
                count = MODL->body[ibody].nnode;

                for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
                    status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                            &npnt, &xyz, &uv);
                    CHECK_STATUS(EG_getTessEdge);

                    count += (npnt - 2);
                }

                for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                    status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                            &npnt, &xyz, &uv, &pindx, &ptype,
                                            &ntri, &tris, &tric);
                    CHECK_STATUS(EG_getTessFace);

                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        if (ptype[ipnt] == -1) count++;
                    }
                }

                fp = fopen(args[1].str, "w");
                fprintf(fp, "%8d %8d %s\n", count, 0, args[1].str);

                for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
                    fprintf(fp, "%22.15e %22.15e %22.15e\n",
                            MODL->body[ibody].node[inode].x,
                            MODL->body[ibody].node[inode].y,
                            MODL->body[ibody].node[inode].z);
                }

                for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
                    status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                            &npnt, &xyz, &uv);
                    CHECK_STATUS(EG_getTessEdge);

                    for (ipnt = 1; ipnt < npnt-1; ipnt++) {
                        fprintf(fp, "%22.15e %22.15e %22.15e\n",
                                xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
                    }
                }

                for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                    status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                            &npnt, &xyz, &uv, &pindx, &ptype,
                                            &ntri, &tris, &tric);
                    CHECK_STATUS(EG_getTessFace);

                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        if (ptype[ipnt] == -1) {
                            fprintf(fp, "%22.15e %22.15e %22.15e\n",
                                    xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
                        }
                    }
                }

                fprintf(fp, "%8d %8d %s\n", 0, 0, "end");
                fclose(fp);

            /* if the filetype is .tess, write tessellation file */
            } else if (strcmp(extension, ".tess") == 0 || strcmp(extension, ".TESS") == 0) {
                ibody = stack[nstack-1];

                if (MODL->body[ibody].etess == NULL) {
                    status = tessellate(MODL, ibody);
                    CHECK_STATUS(tessellate);
                }

                fp = fopen(args[1].str, "w");

                fprintf(fp, "%8d %8d %8d\n",
                        MODL->body[ibody].nnode,
                        MODL->body[ibody].nedge,
                        MODL->body[ibody].nface);

                for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
                    fprintf(fp, "%22.15e %22.15e %22.15e\n",
                            MODL->body[ibody].node[inode].x,
                            MODL->body[ibody].node[inode].y,
                            MODL->body[ibody].node[inode].z);
                }

                for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
                    status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                            &npnt, &xyz, &uv);
                    CHECK_STATUS(EG_getTessEdge);

                    fprintf(fp, "%8d\n", npnt);
                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        fprintf(fp, "%22.15e %22.15e %22.15e %22.15e\n",
                                xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2], uv[ipnt]);
                    }
                }

                for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                    status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                            &npnt, &xyz, &uv, &pindx, &ptype,
                                            &ntri, &tris, &tric);
                    CHECK_STATUS(EG_getTessFace);

                    fprintf(fp, "%8d %8d\n", npnt, ntri);
                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        fprintf(fp, "%22.15e %22.15e %22.15e %22.15e %22.15e %8d %8d\n",
                                xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2],
                                uv[ 2*ipnt], uv[ 2*ipnt+1], ptype[ipnt], pindx[ipnt]);
                    }
                    for (itri = 0; itri < ntri; itri++) {
                        fprintf(fp, "%8d %8d %8d %8d %8d %8d\n",
                                tris[3*itri], tris[3*itri+1], tris[3*itri+2],
                                tric[3*itri], tric[3*itri+1], tric[3*itri+2]);
                    }
                }

                fclose(fp);

            /* if the filetype is .sens, write sensitivity file */
            } else if (strcmp(extension, ".sens") == 0 || strcmp(extension, ".SENS") == 0) {
                ibody = stack[nstack-1];

                /* only dump a .sens file if not in process of computing sensitivities
                   via finite differences, since trying to dump the .sens file will
                   result in an infinite loop of recursive calls */
                if (MODL->basemodl == NULL) {

                    if (NINT(args[3].val[0]) != 0) {
                        SPRINT0(1, "WARNING:: only last Body on stack dumped into .sens file");
                        (MODL->nwarn)++;
                    }

                    if (MODL->body[ibody].etess == NULL) {
                        status = tessellate(MODL, ibody);
                        CHECK_STATUS(tessellate);
                    }

                    fp = fopen(args[1].str, "w");

                    count = 0;
                    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                        if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL) {
                            count++;
                        }
                    }

                    fprintf(fp, "%8d\n", count);

                    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                        if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL) {
                            fprintf(fp, "%8d %s\n",
                                    MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                    MODL->pmtr[ipmtr].name);

                            for (i = 0; i < MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol; i++) {
                                fprintf(fp, "     %22.15e %22.15e\n",
                                        MODL->pmtr[ipmtr].value[i], MODL->pmtr[ipmtr].dot[i]);
                            }
                        }
                    }

                    fprintf(fp, "%8d %8d %8d\n",
                            MODL->body[ibody].nnode,
                            MODL->body[ibody].nedge,
                            MODL->body[ibody].nface);

                    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
                        MALLOC(vels, double, 3);

                        status = ocsmGetVel(MODL, ibody, OCSM_NODE, inode, 1, NULL, vels);
                        CHECK_STATUS(ocsmGetVel);

                        fprintf(fp, "%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e\n",
                                MODL->body[ibody].node[inode].x,
                                MODL->body[ibody].node[inode].y,
                                MODL->body[ibody].node[inode].z,
                                vels[0], vels[1], vels[2]);

                        FREE(vels);
                    }

                    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
                        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                                &npnt, &xyz, &uv);
                        CHECK_STATUS(EG_getTessEdge);

                        status = ocsmGetTessVel(MODL, ibody, OCSM_EDGE, iedge, &Vels);
                        CHECK_STATUS(ocsmGetTessVel);

                        fprintf(fp, "%8d\n", npnt);
                        for (ipnt = 0; ipnt < npnt; ipnt++) {
                            fprintf(fp, "%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e\n",
                                    xyz[ 3*ipnt], xyz[ 3*ipnt+1], xyz[ 3*ipnt+2],
                                    Vels[3*ipnt], Vels[3*ipnt+1], Vels[3*ipnt+2],
                                    uv[    ipnt]);
                        }
                    }

                    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                                &npnt, &xyz, &uv, &pindx, &ptype,
                                                &ntri, &tris, &tric);
                        CHECK_STATUS(EG_getTessFace);

                        status = ocsmGetTessVel(MODL, ibody, OCSM_FACE, iface, &Vels);
                        CHECK_STATUS(ocsmGetTessVel);

                        fprintf(fp, "%8d %8d\n", npnt, ntri);
                        for (ipnt = 0; ipnt < npnt; ipnt++) {
                            fprintf(fp, "%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %8d %8d\n",
                                    xyz[ 3*ipnt], xyz[ 3*ipnt+1], xyz[ 3*ipnt+2],
                                    Vels[3*ipnt], Vels[3*ipnt+1], Vels[3*ipnt+2],
                                    uv[  2*ipnt], uv[  2*ipnt+1],
                                    ptype[ ipnt], pindx[ ipnt  ]);
                        }
                        for (itri = 0; itri < ntri; itri++) {
                            fprintf(fp, "%8d %8d %8d %8d %8d %8d\n",
                                    tris[3*itri], tris[3*itri+1], tris[3*itri+2],
                                    tric[3*itri], tric[3*itri+1], tric[3*itri+2]);
                        }
                    }

                    fclose(fp);
                }

            /* if the filetype is .egg, write a EGG restart file */
            } else if (strcmp(extension, ".egg") == 0 || strcmp(extension, ".EGG") == 0) {
                ibody = stack[nstack-1];

                if (MODL->eggDump == NULL) {
                    SPRINT0(1, "WARNING:: eggDump does not exist.  File not dumped");
                    (MODL->nwarn)++;
                } else {
                    SPRINT1(1, "                          Body   %4d dumped", ibody);
                    if (NINT(args[2].val[0]) == 1) {
                        SPRINT1(1, "                          Body   %4d removed from stack", ibody);
                        nstack--;
                    }

                    /* write the file */
                    fp = fopen(args[1].str, "w");

                    fprintf(fp, "%8d %8d %8d\n",
                            MODL->body[ibody].nnode,
                            MODL->body[ibody].nedge,
                            MODL->body[ibody].nface);

                    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
                        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                                &npnt, &xyz, &uv);
                        CHECK_STATUS(EG_getTessEdge);

                        fprintf(fp, "%8d\n", npnt);
                    }

                    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                        status = MODL->eggDump(MODL->body[ibody].face[iface].eggdata, fp);
                        CHECK_STATUS(eggDump);
                    }

                    fclose(fp);
                }

            /* otherwise assume it is a type that EGADS knows how to handle */
            } else {

                /* make a model and dump the Body(s) */
                if (NINT(args[3].val[0]) != 1) {
                    ntemp = 1;
                    MALLOC(etemp, ego, ntemp);

                    status = EG_copyObject(MODL->body[stack[nstack-1]].ebody, NULL, &(etemp[0]));
                    CATCH_STATUS(EG_copyObject);

                    SPRINT1(1, "                          Body   %4d dumped", stack[nstack-1]);
                    if (NINT(args[2].val[0]) == 1) {
                        SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack-1]);
                        nstack--;
                    }
                } else {
                    ntemp = 0;
                    MALLOC(etemp, ego, nstack+1);

                    for (jstack = nstack-1; jstack >= 0; jstack--) {
                        if (stack[jstack] == 0) {
                            if (NINT(args[2].val[0]) == 1) {
                                SPRINT0(1, "                          Mark        removed from stack");
                                nstack--;
                            }
                            break;
                        } else if (stack[jstack] > 0) {
                            status = EG_copyObject(MODL->body[stack[jstack]].ebody, NULL, &(etemp[ntemp++]));
                            CATCH_STATUS(EG_copyObject);

                            SPRINT1(1, "                          Body   %4d dumped", stack[jstack]);
                            if (NINT(args[2].val[0]) == 1) {
                                SPRINT1(1, "                          Body   %4d removed from stack", stack[jstack]);
                                nstack--;
                            }
                        }
                    }
                }

                status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                         NULL, ntemp, etemp, NULL, &emodel);
                CATCH_STATUS(EG_makeTopology);

                FREE(etemp);

                /* add the global Attributes to the Model */
                for (iattr = 0; iattr < MODL->nattr; iattr++) {
                    status = EG_attributeAdd(emodel, MODL->attr[iattr].name, ATTRSTRING,
                                             STRLEN(MODL->attr[iattr].defn), NULL, NULL, MODL->attr[iattr].defn);
                    CATCH_STATUS(EG_attributeAdd);
                }

                /* add the DESPMTRs, CFGPMTRs, and OUTPMTRs as Attributes on the Model */
                for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                    if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL)  {
                        snprintf(pmtrName, MAX_EXPR_LEN, "_despmtr_%s", MODL->pmtr[ipmtr].name);

                        status = EG_attributeAdd(emodel, pmtrName, ATTRREAL,
                                                 MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                                 NULL, MODL->pmtr[ipmtr].value, NULL);
                        CATCH_STATUS(EG_attributeAdd);
                    } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG)  {
                        snprintf(pmtrName, MAX_EXPR_LEN, "_cfgpmtr_%s", MODL->pmtr[ipmtr].name);

                        status = EG_attributeAdd(emodel, pmtrName, ATTRREAL,
                                                 MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                                 NULL, MODL->pmtr[ipmtr].value, NULL);
                        CATCH_STATUS(EG_attributeAdd);
                    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPUT) {
                        snprintf(pmtrName, MAX_EXPR_LEN, "_outpmtr_%s", MODL->pmtr[ipmtr].name);

                        if (MODL->pmtr[ipmtr].value != NULL) {
                            status = EG_attributeAdd(emodel, pmtrName, ATTRREAL,
                                                     MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                                     NULL, MODL->pmtr[ipmtr].value, NULL);
                        } else {
                            status = EG_attributeAdd(emodel, pmtrName, ATTRSTRING,
                                                     MODL->pmtr[ipmtr].nrow,
                                                     NULL, NULL, MODL->pmtr[ipmtr].str);
                        }
                        CATCH_STATUS(EG_attributeAdd);
                    }
                }

                if (outLevel >= 3) {
                    SPRINT0(3, "emodel\n");
                    ocsmPrintEgo(emodel);
                }

                /* strip the dollarsign off the filename */
                STRNCPY(dumpfile, args[1].str, MAX_EXPR_LEN);

                /* if file exists, delete it now */
                status = remove(dumpfile);
                if (status == 0) {
                    SPRINT1(1, "WARNING:: file \"%s\" is being overwritten", dumpfile);
                    (MODL->nwarn)++;
                }

                status = EG_saveModel(emodel, dumpfile);
                CATCH_STATUS(EG_saveModel);

                status = EG_deleteObject(emodel);
                CATCH_STATUS(EG_deleteObject);
            }

        /* execute: "end" */
        } else if (type == OCSM_END) {
            SPRINT1(1, "    executing [%4d] end:", ibrch);

            /* do nothing if we are at the top level */
            if (MODL->level <= 0) break;

            /* remove from the pattern list */
            npatn--;

            /* find the UDPRIM Branch associated with this END */
            for (jbrch = ibrch-1; jbrch > 0; jbrch--) {
                if (MODL->brch[jbrch].indent == MODL->brch[ibrch].indent) {
                    if (MODL->brch[jbrch].type == OCSM_UDPRIM) {
                        break;
                    } else {
                        status = OCSM_INTERNAL_ERROR;
                        signalError(MODL, status,
                                    "expecting UDPRIM, but got %s", ocsmGetText(MODL->brch[jbrch].type));
                        CATCH_STATUS(end);
                    }
                }
            }

            /* jbrch is first Branch after the udprim statement that called this .udc */
            jbrch++;
            while (jbrch < ibrch) {
                if (MODL->brch[jbrch].type != OCSM_INTERFACE) break;

                if (strcmp(MODL->brch[jbrch].arg2, "$out") == 0 ||
                    strcmp(MODL->brch[jbrch].arg2, "$OUT") == 0   ) {

                    /* get the value of the local variable */
                    status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                    CATCH_STATUS(str2val);

                    /* find or create an @@-parameter up one level and store the value/dot */
                    (MODL->level)--;
                    snprintf(pmtrName, MAX_EXPR_LEN, "@@%s", &(MODL->brch[jbrch].arg1[1]));

                    if (STRLEN(str) == 0) {
                        status = ocsmFindPmtr(MODL, pmtrName, OCSM_INTERNAL, 1, 1, &ipmtr);
                        CATCH_STATUS(ocsmFindPmtr);

                        status = ocsmSetValuD(MODL, ipmtr, 1, 1, value);
                        CATCH_STATUS(ocsmSetValuD);

                        status = ocsmSetVelD(MODL, ipmtr, 1, 1, dot);
                        CATCH_STATUS(ocsmSetVelD);
                    } else {
                        status = ocsmFindPmtr(MODL, pmtrName, OCSM_INTERNAL, 0, 0, &ipmtr);
                        CATCH_STATUS(ocsmFindPmtr);

                        STRNCPY(temp, "$", MAX_STRVAL_LEN  );
                        strncat(temp, str, MAX_STRVAL_LEN-1);
                        status = ocsmSetValu(MODL, ipmtr, 1, 1, temp);
                        CATCH_STATUS(ocsmSetValu);
                    }

                    (MODL->level)++;
                }

                jbrch++;
            }

            /* remove all the Parameters at MODL->scope if a new scope */
            if (MODL->scope[MODL->level] > MODL->scope[MODL->level-1]) {
                for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                    if (MODL->pmtr[ipmtr].scope >= MODL->scope[MODL->level]) {
                        FREE(MODL->pmtr[ipmtr].name );
                        FREE(MODL->pmtr[ipmtr].value);
                        FREE(MODL->pmtr[ipmtr].dot  );
                        FREE(MODL->pmtr[ipmtr].lbnd );
                        FREE(MODL->pmtr[ipmtr].ubnd );
                        FREE(MODL->pmtr[ipmtr].str  );

                        for (jpmtr = ipmtr+1; jpmtr <= MODL->npmtr; jpmtr++) {

                            /* copy jpmtr over jpmtr-1 */
                            MODL->pmtr[jpmtr-1].name  = MODL->pmtr[jpmtr].name;
                            MODL->pmtr[jpmtr-1].type  = MODL->pmtr[jpmtr].type;
                            MODL->pmtr[jpmtr-1].scope = MODL->pmtr[jpmtr].scope;
                            MODL->pmtr[jpmtr-1].nrow  = MODL->pmtr[jpmtr].nrow;
                            MODL->pmtr[jpmtr-1].ncol  = MODL->pmtr[jpmtr].ncol;
                            MODL->pmtr[jpmtr-1].value = MODL->pmtr[jpmtr].value;
                            MODL->pmtr[jpmtr-1].dot   = MODL->pmtr[jpmtr].dot;
                            MODL->pmtr[jpmtr-1].lbnd  = MODL->pmtr[jpmtr].lbnd;
                            MODL->pmtr[jpmtr-1].ubnd  = MODL->pmtr[jpmtr].ubnd;
                            MODL->pmtr[jpmtr-1].str   = MODL->pmtr[jpmtr].str;
                        }

                        ipmtr--;            /* revisit imptr in next trip through loop */

                        MODL->pmtr[MODL->npmtr].name  = NULL;
                        MODL->pmtr[MODL->npmtr].value = NULL;
                        MODL->pmtr[MODL->npmtr].dot   = NULL;
                        MODL->pmtr[MODL->npmtr].lbnd  = NULL;
                        MODL->pmtr[MODL->npmtr].ubnd  = NULL;
                        MODL->pmtr[MODL->npmtr].str   = NULL;
                        (MODL->npmtr)--;
                    }
                }

                /* decrement the level */
                (MODL->level)--;
            }

        /* execute: "assert arg1 arg2 toler=0 verify=0" */
        } else if (type == OCSM_ASSERT) {
            /* determine if verification is required */
            verify = NINT(args[4].val[0]);

            if (verify <= MODL->verify) {
                SPRINT5(1, "    executing [%4d] assert:     %s  %s  %s  %s",
                        ibrch, MODL->brch[ibrch].arg1,
                               MODL->brch[ibrch].arg2,
                               MODL->brch[ibrch].arg3,
                               MODL->brch[ibrch].arg4);

                /* set up tolerance */
                if (args[3].val[0] == 0) {
                    toler = 1.0e-6;
                } else if (args[3].val[0] < 0) {
                    toler = fabs(args[1].val[0] * args[3].val[0]);
                } else {
                    toler = args[3].val[0];
                }

                /* return error if arg1 != arg2 */
                if (fabs(args[1].val[0]-args[2].val[0]) > toler) {
                    SPRINT1(0, "    arg1 = %20.8f", args[1].val[0]);
                    SPRINT1(0, "    arg2 = %20.8f", args[2].val[0]);
                    if (args[3].val[0] < 0) {
                        SPRINT1(0, " pct err = %20.8f", 100*(args[1].val[0]-args[2].val[0])/args[1].val[0]);
                    } else {
                        SPRINT1(0, " abs err = %20.8f",     (args[1].val[0]-args[2].val[0])               );
                    }
                    status = OCSM_ASSERT_FAILED;
                    CATCH_STATUS(assert);
                }
            } else {
                SPRINT5(1, "    ignoring  [%4d] assert:     %s  %s  %s  %s",
                        ibrch, MODL->brch[ibrch].arg1,
                               MODL->brch[ibrch].arg2,
                               MODL->brch[ibrch].arg3,
                               MODL->brch[ibrch].arg4);
            }

        /* execute: "special arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9" */
        } else if (type == OCSM_SPECIAL) {
            SPRINT10(1, "    executing [%4d] special:    %s  %s  %s  %s  %s  %s  %s  %s  %s",
                    ibrch, MODL->brch[ibrch].arg1,
                           MODL->brch[ibrch].arg2,
                           MODL->brch[ibrch].arg3,
                           MODL->brch[ibrch].arg4,
                           MODL->brch[ibrch].arg5,
                           MODL->brch[ibrch].arg6,
                           MODL->brch[ibrch].arg7,
                           MODL->brch[ibrch].arg8,
                           MODL->brch[ibrch].arg9);

            /* pop a Body from the stack */
            if (nstack < 1) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "SPECIAL expects a Body on the stack");
                goto next_branch;
            } else if (stack[nstack-1] <= 0) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "SPECIAL expects a Body on the stack");
                goto next_branch;
            } else {
                ibodyl = stack[--nstack];
            }

            hasdots = 0;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[nstack++] = MODL->nbody;
                status = SUCCESS;
                goto next_branch;
            }

            ebodyl = MODL->body[ibodyl].ebody;

            /* create a Body */
            status = newBody(MODL, ibrch, type, ibodyl, -1,
                             args, hasdots, MODL->body[ibodyl].botype, &ibody);
            CHECK_STATUS(newBody);

            /* default behavior is to ignore the arguments and simply copy the Body */
            status = EG_copyObject(ebodyl, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters and finish Body (SPECIAL) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[nstack++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                    ibody, toler);
        }

        /* keep track of profile info */
        new_time = clock();

        if (type >= 100 && type < 200) {
            MODL->profile[type-100].ncall += 1;
            MODL->profile[type-100].time  += (new_time - old_time);
        }

        /* record the required CPU time to create this Body */
        if (MODL->nbody > nbodySave) {
            MODL->body[MODL->nbody].CPU = (double)(new_time - old_time) / (double)(CLOCKS_PER_SEC);
        }

        /* record that we successfully executed this Branch */
        *builtTo = ibrch;

next_branch:
        /* restore the stack if there is an error */
        if (MODL->sigCode != 0) {
            nstack      = nstackSave;
            MODL->nbody = nbodySave;
        }

        /* clean up all unattached egos */
        if (MODL->cleanup == 1) {
            (void) EG_setOutLevel(MODL->context, 0);
            status = EG_deleteObject(MODL->context);
            (void) EG_setOutLevel(MODL->context, outLevel);
            CHECK_STATUS(EG_deleteObject);
        }

        /* set up @stack */
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, "@stack") == 0      &&
                MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                if (nstack < 1) {
                    MODL->pmtr[ipmtr].value[0] = -1;
                    MODL->pmtr[ipmtr].ncol     = 1;
                } else {
                    for (i = 0; i < nstack; i++) {
                        MODL->pmtr[ipmtr].value[i] = stack[i];
                    }
                    MODL->pmtr[ipmtr].ncol = nstack;
                }
            }
        }

        /* print the current stack */
        if (MODL->printStack != 0) {
            SPRINT1(1, "Stack at end of \"%s\" statement:", ocsmGetText(type));
            for (i = 0; i < nstack; i++) {
                ibodyl = stack[i];

                if (ibodyl == 0) {
                    SPRINT1(1, "    stack[%3d] = Mark", i);
                } else if (ibodyl < 0) {
                    SPRINT2(1, "    stack[%3d] = Sketch %d", i, ibodyl);
                } else {
                    SPRINT8(1, "    stack[%3d] = Body %5d %-20s %-20s ileft=%3d, irite = %3d, ichld=%3d, igroup=%3d",
                            i, ibodyl,
                            ocsmGetText(MODL->body[ibodyl].brtype),
                            ocsmGetText(MODL->body[ibodyl].botype),
                            MODL->body[ibodyl].ileft,
                            MODL->body[ibodyl].irite,
                            MODL->body[ibodyl].ichld,
                            MODL->body[ibodyl].igroup);
                }
            }
        }

        #ifdef PRINT_BODYS
        {
            int    nnode, nedge, nface, oclass, mtype, nchild, *senses, jstack;
            double data[4];
            char   onstack;
            ego    eref, *echilds;

            SPRINT1(1, "Bodys at end of \"%s\" statement:", ocsmGetText(type));
            SPRINT0(1, "   ibody                                     igroup ileft irite nnode nedge nface");
            for (ibodyl = 1; ibodyl <= MODL->nbody; ibodyl++) {
                if (MODL->body[ibodyl].ebody == NULL) {
                    nnode  = -1;
                    nedge  = -1;
                    nface  = -1;
                    oclass = -1;
                    mtype  = -1;
                } else {
                    EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, NODE, &nnode, NULL);
                    EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, EDGE, &nedge, NULL);
                    EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, FACE, &nface, NULL);
                    EG_getTopology( MODL->body[ibodyl].ebody, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
                }

                onstack = ' ';
                for (jstack = 0; jstack < nstack; jstack++) {
                    if (stack[jstack] == ibodyl) {
                        onstack = '*';
                        break;
                    }
                }

                SPRINT10(1, "   %5d%c %-20s %-14s %5d %5d %5d %5d %5d %5d",
                         ibodyl, onstack,
                         ocsmGetText(MODL->body[ibodyl].brtype),
                         ocsmGetText(MODL->body[ibodyl].botype),
                         MODL->body[ibodyl].igroup,
                         MODL->body[ibodyl].ileft,
                         MODL->body[ibodyl].irite,
                         nnode, nedge, nface);
            }
        }
        #endif

        #ifdef PRINT_FAULTS
        {
            struct rusage myUsage;
            getrusage(RUSAGE_SELF, &myUsage);
            new_minfaults = myUsage.ru_minflt;
            new_majfaults = myUsage.ru_majflt;
            SPRINT2(1, "    %ld minor and %ld major page faults for this Branch",
                    new_minfaults-old_minfaults, new_majfaults-old_majfaults);
            old_minfaults = new_minfaults;
            old_majfaults = new_majfaults;
        }
        #endif

    }

finalize:
    SPRINT0(1, "    finalizing:");

    /* mark all Branches up to builtTo as as not dirty and those after
       builtTo as dirty */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        if (ibrch <= *builtTo) {
            MODL->brch[ibrch].dirty = 0;
        } else {
            MODL->brch[ibrch].dirty = 1;
        }
    }

    /* special processing if there was an uncaught error signal */
    if (MODL->sigCode < 0) {

        /* close the Sketch */
        sket->type   = 0;
        sket->size   = 0;
        sket->solved = 1;
        sket->nseg   = 0;
        sket->nvar   = 0;
        sket->ncon   = 0;

        /* return negative of builtTo */
        (*builtTo) *= -1;

    /* special processing if there was an uncaught user-thrown signal */
    } else if (MODL->sigCode > 0) {
        SPRINT1(1, "WARNING:: there was an uncaught user-thrown signal %d",
                MODL->sigCode);
        (MODL->nwarn)++;

        /* close the Sketch */
        sket->type   = 0;
        sket->size   = 0;
        sket->solved = 1;
        sket->nseg   = 0;
        sket->nvar   = 0;
        sket->ncon   = 0;

        /* return negative of builtTo */
        (*builtTo) *= -1;
    }

    /* make sure the Sketch is not open */
    if (sket->nseg > 0) {
        SET_STATUS(OCSM_SKETCH_IS_OPEN, end);
    }

    /* free up the storage associated with the arguments */
    for (iarg = 1; iarg < 10; iarg++) {
        FREE(args[iarg].val);   /* also free's .str since they are unioned */
        FREE(args[iarg].dot);
    }

    /* make sure that user-supplied body[] is big enough */
    if (body != NULL && nstack > nbodyMax) {
        status = OCSM_TOO_MANY_BODYS_ON_STACK;
        goto cleanup;
    }

    /* pre-mark all the Bodys as not being on the stack (fixed below) */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        MODL->body[ibody].onstack = 0;
    }

    /* report a warning if there is a mark on the stack */
    for (i = 0; i < nstack; i++) {
        ibody = stack[i];
        if (ibody == 0) {
            SPRINT0(1, "WARNING:: mark being removed from the stack");
            (MODL->nwarn)++;

            for (j = i+1; j < nstack; j++) {
                stack[j-1] = stack[j];
            }
            nstack--;

            i--;  /* repeat in case first moved stack entry was also a mark */
        }
    }

    /* mark and (optionally) tessellate the stack's Bodys */
    for (i = 0; i < nstack; i++) {
        ibody = stack[i];
        MODL->body[ibody].onstack = 1;

        if (MODL->tessAtEnd == 1) {
            status = tessellate(MODL, ibody);
            CHECK_STATUS(tessellate);
        }
    }

    /* return Bodys on the stack (LIFO) */
    if (body != NULL) {
        *nbody = nstack;
    }

    nbodyMax = nstack;
    for (i = 0; i < nbodyMax; i++) {
        if (body != NULL) {
            body[i] = stack[--nstack];

            if (MODL->body[body[i]].botype != OCSM_NODE_BODY) {
                status = getBodyTolerance(MODL->body[body[i]].ebody, &toler);
                CHECK_STATUS(getBodyTolerance);

                SPRINT5(1, "    Body %5d   nnode=%-6d   nedge=%-6d   nface=%-6d   toler=%11.4e", body[i],
                        MODL->body[body[i]].nnode,
                        MODL->body[body[i]].nedge,
                        MODL->body[body[i]].nface, toler);

                if (outLevel >= 3) {
                    status = printAttrs(MODL->body[i].ebody);
                    CHECK_STATUS(printAttrs);
                }
            } else {
                SPRINT5(1, "    Body %5d   nnode=%-6d   nedge=%-6d   nface=%-6d   toler=%11.4e", body[i],
                        1, 0, 0, 0.0);
            }
        }
    }

    /* print the profile info */
    SPRINT0(1, "==> Profile information");
    total_time = 0;
    total_call = 0;
    for (i = 0; i < 100; i++) {
        total_call += MODL->profile[i].ncall;
        total_time += MODL->profile[i].time;
    }
    SPRINT0(1, "    Branch type           ncall  time (sec)    pct");
    for (i = 0; i < 100; i++) {
        if (MODL->profile[i].ncall > 0) {
            SPRINT4(1, "    %-20s  %5d  %10.3f  %5.1f", ocsmGetText(i+100), MODL->profile[i].ncall,
                   (double)(MODL->profile[i].time) / (double)(CLOCKS_PER_SEC),
                   (double)(MODL->profile[i].time) / (double)(total_time) * 100);
        }
    }
    SPRINT2(1, "    Total                 %5d  %10.3f", total_call, (double)(total_time)/(double)(CLOCKS_PER_SEC));

#ifdef PRINT_TIMES
    SPRINT1(1, "Total user time in Booleans = %10.3f", bool_user_time);
    SPRINT1(1, "Total sys  time in Booleans = %10.3f", bool_sys_time );
    SPRINT1(1, "Total      time in Booleans = %10.3f", bool_user_time+bool_sys_time);
    SPRINT1(1, "Total wall time in Booleans = %10.3f", bool_wall_time);
#endif

#ifdef PRINT_FAULTS
    SPRINT1(1, "Total minor page faults = %ld", new_minfaults);
    SPRINT1(1, "Total major page faults = %ld", new_majfaults);
#endif

cleanup:
    MODL->level = 0;

    for (iarg = 1; iarg < 10; iarg++) {
        FREE(args[iarg].val);   /* also free's .str since they are unioned */
        FREE(args[iarg].dot);
    }

    FREE(props  );
    FREE(sket   );
    FREE(solcons);
    FREE(solvars);
    FREE(patn   );
    FREE(macros );
    FREE(stack  );
    FREE(iblist );
    FREE(values );
    FREE(dots   );

#undef CATCH_STATUS
    /* if MODL->sigCode is not success, return it */
    if (MODL->sigCode != SUCCESS) {
        status = MODL->sigCode;
    }

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPerturb - create a perturbed MODL                              *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPerturb(void   *modl,               /* (in)  pointer to MODL */
            int    npmtrs,              /* (in)  number of perturbed Parameters (or 0 to remove)*/
  /*@null@*/int    ipmtrs[],            /* (in)  array of Parameter indices (1-npmtr) */
  /*@null@*/int    irows[],             /* (in)  array of row       indices (1-nrow) */
  /*@null@*/int    icols[],             /* (in)  array of column    indices (1-ncol) */
  /*@null@*/double values[])            /* (in)  array of perturbed values */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ii, ibody, builtTo, nbody_ptrb;
    modl_T    *MODL = (modl_T*)modl;
    modl_T    *PTRB = NULL;
    ego       newBody;

    void      *modl_ptrb=NULL;

    ROUTINE(ocsmPerturb);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if npmtrs is non-positive, remove the perturbation */
    if (npmtrs <= 0) {
        status = removePerturbation(MODL);
        CHECK_STATUS(removePerturbation);
        goto cleanup;
    }

    /* if there is no tessellation for any Body on the stack, return error */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        if (MODL->body[ibody].onstack == 0) continue;

        if (MODL->body[ibody].etess == NULL && MODL->body[ibody].botype != OCSM_NODE_BODY) {
            status = OCSM_NEED_TESSELLATION;
            goto cleanup;
        }
    }

    /* make a copy and set its driving parameters to "base + dtime * dot" */
    status = ocsmCopy(MODL, &modl_ptrb);
    CHECK_STATUS(ocsmCopy);

    PTRB = modl_ptrb;

    MODL->perturb  = PTRB;
    PTRB->basemodl = MODL;

    /* update the Parameters */
    for (ii = 0; ii < npmtrs; ii++) {
        status = ocsmSetValuD(PTRB, ipmtrs[ii], irows[ii], icols[ii], values[ii]);
        CHECK_STATUS(ocsmSetValuD);
    }

    /* recheck (this is needed to make sure that the indentation is updated) */
    status = ocsmCheck(PTRB);
    CHECK_STATUS(ocsmCheck);

    /* rebuild the perturbed copy */
    nbody_ptrb = 0;
    SPRINT0(1, ">>> building perturbation");
    status = ocsmBuild(PTRB, 0, &builtTo, &nbody_ptrb, NULL);
    CHECK_STATUS(ocsmBuild);

    /* check that base and ptrb have same number of Bodys */
    if (MODL->nbody != PTRB->nbody) {
        SPRINT0(1, "WARNING:: Base and perturbed models have different nbody");
        SPRINT1(1, "          MODL->nbody = %d", MODL->nbody);
        SPRINT1(1, "          PTRB->nbody = %d", PTRB->nbody);
        (MODL->nwarn)++;
        status = OCSM_DID_NOT_CREATE_BODY;
        goto cleanup;
    }

    /* check that base and ptrb Bodys match topologically */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        if (MODL->body[ibody].onstack != 1) continue;

//$$$        /* for now, assume that WireBodys map without checking */
        if (MODL->body[ibody].botype == OCSM_WIRE_BODY &&
            PTRB->body[ibody].botype == OCSM_WIRE_BODY   ) {
            status  = SUCCESS;
            newBody = NULL;

        /* do actual check for SolidBodys */
        } else {
            status = EG_mapBody(MODL->body[ibody].ebody, PTRB->body[ibody].ebody,
                                "_faceID", &newBody);
        }

        /* if topologies match, we can proceed */
        if (status == SUCCESS) {
            if (newBody != NULL) {
                EG_deleteObject(PTRB->body[ibody].ebody);
                PTRB->body[ibody].ebody = newBody;

                status = finishBody(PTRB, ibody);
                CHECK_STATUS(finishBody);
            }

        /* otherwise we have an error */
        } else {
            SPRINT2(2, "WARNING:: EG_mapBody(ibody=%d) -> status=%d\n", ibody, status);
            (MODL->nwarn)++;
            status = OCSM_DID_NOT_CREATE_BODY;
            goto cleanup;
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmNewBrch - create a new Branch                                  *
 *                                                                      *
 ************************************************************************
 */

int
ocsmNewBrch(void   *modl,               /* (in)  pointer to MODL */
            int    iafter,              /* (in)  Branch index (0-nbrch) after which to add */
            int    type,                /* (in)  Branch type (see below) */
            char   filename[],          /* (in)  filename where Branch is defined */
            int    linenum,             /* (in)  linenumber where Branch is defined (bias-1) */
  /*@null@*/char   arg1[],              /* (in)  Argument 1 (or NULL) */
  /*@null@*/char   arg2[],              /* (in)  Argument 2 (or NULL) */
  /*@null@*/char   arg3[],              /* (in)  Argument 3 (or NULL) */
  /*@null@*/char   arg4[],              /* (in)  Argument 4 (or NULL) */
  /*@null@*/char   arg5[],              /* (in)  Argument 5 (or NULL) */
  /*@null@*/char   arg6[],              /* (in)  Argument 6 (or NULL) */
  /*@null@*/char   arg7[],              /* (in)  Argument 7 (or NULL) */
  /*@null@*/char   arg8[],              /* (in)  Argument 8 (or NULL) */
  /*@null@*/char   arg9[])              /* (in)  Argument 9 (or NULL) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       bclass, narg, ibrch, jbrch, impstr;
    char      temparg[MAX_LINE_LEN];

    ROUTINE(ocsmNewBrch);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* make sure valid ibrch was given */
    if (iafter < 0 || iafter > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* check that valid type is given (and determine bclass) */
    if        (type == OCSM_APPLYCSYS) {     // $csysName ibody=0
        bclass = OCSM_TRANSFORM;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_ARC) {           // xend yend zend dist $plane=xy
        bclass = OCSM_SKETCH;
        narg   = 5;
        impstr = 0x010;
    } else if (type == OCSM_ASSERT) {        // arg1 arg2 toler=0 verify=0
        bclass = OCSM_UTILITY;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_BEZIER) {        // x y z
        bclass = OCSM_SKETCH;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_BLEND) {         // begList=0 endList=0 reorder=0 oneFace=0
        bclass = OCSM_GROWN;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_BOX) {           // xbase ybase zbase dx dy dz
        bclass = OCSM_PRIMITIVE;
        narg   = 6;
        impstr = 0x000;
    } else if (type == OCSM_CATBEG) {        // sigCode
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_CATEND) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_CHAMFER) {       // radius edgeList=0
        bclass = OCSM_APPLIED;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_CIRARC) {        // xon yon zon xend yend zend
        bclass = OCSM_SKETCH;
        narg   = 6;
        impstr = 0x000;
    } else if (type == OCSM_COMBINE) {       // toler=0
        bclass = OCSM_BOOLEAN;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_CONE) {          // xvrtx yvrtx zvrtx xbase ybase zbase radius
        bclass = OCSM_PRIMITIVE;
        narg   = 7;
        impstr = 0x000;
    } else if (type == OCSM_CONNECT) {       // faceList1 faceList2 edgelist1=0 edgelist2=0
        bclass = OCSM_BOOLEAN;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_CYLINDER) {      // xbeg ybeg zbeg xend yend zend radius
        bclass = OCSM_PRIMITIVE;
        narg   = 7;
        impstr = 0x000;
    } else if (type == OCSM_DIMENSION) {     // $pmtrName nrow ncol despmtr=0
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_DUMP) {          // $filename remove=0 toMark=0
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_ELSE) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_ELSEIF) {        // val1 $op1 val2 $op2 val3 $op3 val4
        bclass = OCSM_UTILITY;
        narg   = 7;
        impstr = 0x0aa;
    } else if (type == OCSM_END) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_ENDIF) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_EVALUATE) {      // $type arg1 ...
        bclass = OCSM_UTILITY;
        if        (strcmp(arg1, "$node") == 0 || strcmp(arg1, "$NODE") == 0) {
            narg = 3;
        } else if (strcmp(arg1, "$edge") == 0 || strcmp(arg1, "$EDGE") == 0) {
            narg = 4;
        } else if (strcmp(arg1, "$edgeinv") == 0 || strcmp(arg1, "$EDGEINV") == 0) {
            narg = 6;
        } else if (strcmp(arg1, "$face") == 0 || strcmp(arg1, "$FACE") == 0) {
            narg = 5;
        } else if (strcmp(arg1, "$faceinv") == 0 || strcmp(arg1, "$FACEINV") == 0) {
            narg = 6;
        } else {
            narg = 1;
        }
        impstr = 0x100;
    } else if (type == OCSM_EXTRACT) {       // index
        bclass = OCSM_BOOLEAN;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_EXTRUDE) {       // dx dy dz
        bclass = OCSM_GROWN;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_FILLET) {        // radius edgeList=0 listStyle=0
        bclass = OCSM_APPLIED;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_GETATTR) {       // $pmtrName attrID global=0
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_GROUP) {         // nbody=0
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_HOLLOW) {        // thick=0 entList=0 listStyle=0
        bclass = OCSM_APPLIED;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_IFTHEN) {        // val1 $op1 val2 $op2 val3 $op3 val4
        bclass = OCSM_UTILITY;
        narg   = 7;
        impstr = 0x0aa;
    } else if (type == OCSM_IMPORT) {        // $filename bodynumber=1
        bclass = OCSM_PRIMITIVE;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_INTERFACE) {     // $argName $argType default=0
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x180;
    } else if (type == OCSM_INTERSECT) {     // $order=none index=1 maxtol=0
        bclass = OCSM_BOOLEAN;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_JOIN) {          // toler=0 toMark=0
        bclass = OCSM_BOOLEAN;
        narg   = 2;
        impstr = 0x000;
    } else if (type == OCSM_LINSEG) {        // x y z
        bclass = OCSM_SKETCH;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_LOFT) {          // smooth
        bclass = OCSM_GROWN;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_MACBEG) {        // imacro
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_MACEND) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_MARK) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_MIRROR) {        // nx ny nz dist=0
        bclass = OCSM_TRANSFORM;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_PATBEG) {        // $pmtrName ncopy
        bclass = OCSM_UTILITY;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_PATBREAK) {      // expr
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_PATEND) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_POINT) {         // xloc yloc zloc
        bclass = OCSM_PRIMITIVE;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_PROJECT) {       // x y z dx dy dz useEdges=0
        bclass = OCSM_UTILITY;
        narg   = 7;
        impstr = 0x000;
    } else if (type == OCSM_RECALL) {        // imacro
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_REORDER) {       // ishift iflip=0
        bclass = OCSM_TRANSFORM;
        narg   = 2;
        impstr = 0x000;
    } else if (type == OCSM_RESTORE) {       // $name index=0
        bclass = OCSM_PRIMITIVE;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_REVOLVE) {       // xorig yorig zorig dxaxis dyaxis dzaxis angDeg
        bclass = OCSM_GROWN;
        narg   = 7;
        impstr = 0x000;
    } else if (type == OCSM_ROTATEX) {       // angDeg yaxis zaxis
        bclass = OCSM_TRANSFORM;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_ROTATEY) {       // angDeg zaxis xaxis
        bclass = OCSM_TRANSFORM;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_ROTATEZ) {       // angDeg xaxis yaxis
        bclass = OCSM_TRANSFORM;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_RULE) {          // reorder=0
        bclass = OCSM_GROWN;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_SCALE) {         // fact xcent=0 ycent=0 zcent=0
        bclass = OCSM_TRANSFORM;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_SELECT) {        // $type arg1 ...
        bclass = OCSM_UTILITY;
        narg   = 1;
        if (arg2 != NULL && arg2[0] != '\0') narg = 2;
        if (arg3 != NULL && arg3[0] != '\0') narg = 3;
        if (arg4 != NULL && arg4[0] != '\0') narg = 4;
        if (arg5 != NULL && arg5[0] != '\0') narg = 5;
        if (arg6 != NULL && arg6[0] != '\0') narg = 6;
        if (arg7 != NULL && arg7[0] != '\0') narg = 7;
        if (arg8 != NULL && arg8[0] != '\0') narg = 8;
        impstr = 0x100;
    } else if (type == OCSM_SET) {           // $pmtrName exprs
        bclass = OCSM_UTILITY;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_SKBEG) {         // x y z relative=0
        bclass = OCSM_SKETCH;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_SKCON) {         // $type index1 index2=1 $value=0
        bclass = OCSM_SKETCH;
        narg   = 4;
        impstr = 0x120;
    } else if (type == OCSM_SKEND) {         // wireonly=0
        bclass = OCSM_SKETCH;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_SKVAR) {         // $type valList
        bclass = OCSM_SKETCH;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_SOLBEG) {        // $varList
        bclass = OCSM_SOLVER;
        narg   = 1;
        impstr = 0x100;
    } else if (type == OCSM_SOLCON) {        // $expr
        bclass = OCSM_SOLVER;
        narg   = 1;
        impstr = 0x100;
    } else if (type == OCSM_SOLEND) {
        bclass = OCSM_SOLVER;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_SPECIAL) {
        bclass = OCSM_UTILITY;
        narg   = 9;
        impstr = 0x000;
    } else if (type == OCSM_SPHERE) {        // xcent ycent zcent radius
        bclass = OCSM_PRIMITIVE;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_SPLINE) {        // x y z
        bclass = OCSM_SKETCH;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_SSLOPE) {        // dx dy dz
        bclass = OCSM_SKETCH;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_STORE) {         // $name index=0 keep=0
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_SUBTRACT) {      // $order=none index=1 maxtol=0
        bclass = OCSM_BOOLEAN;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_SWEEP) {
        bclass = OCSM_GROWN;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_THROW) {         // sigCode
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_TORUS) {         // xcent ycent zcent dxaxis dyaxis dzaxis majorRad minorRad
        bclass = OCSM_PRIMITIVE;
        narg   = 8;
        impstr = 0x000;
    } else if (type == OCSM_TRANSLATE) {     // dx dy dz
        bclass = OCSM_TRANSFORM;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_UDPARG) {        // $primtype $argName1 argvalue1 $argName2 argvalue2 $argName3 argvalue3 $argName4 argvalue4
        bclass = OCSM_UTILITY;
        narg   = 1;
        if (arg2 != NULL && arg2[0] != '\0' &&
            arg3 != NULL && arg3[0] != '\0'   ) narg = 3;
        if (arg4 != NULL && arg4[0] != '\0' &&
            arg5 != NULL && arg5[0] != '\0'   ) narg = 5;
        if (arg6 != NULL && arg6[0] != '\0' &&
            arg7 != NULL && arg7[0] != '\0'   ) narg = 7;
        if (arg8 != NULL && arg8[0] != '\0' &&
            arg9 != NULL && arg9[0] != '\0'   ) narg = 9;
        impstr = 0x1aa;
    } else if (type == OCSM_UDPRIM) {        // $primtype $argName1 argvalue1 $argName2 argvalue2 $argName3 argvalue3 $argName4 argvalue4
        bclass = OCSM_PRIMITIVE;
        narg  = 1;
        if (arg2 != NULL && arg2[0] != '\0' &&
            arg3 != NULL && arg3[0] != '\0'   ) narg = 3;
        if (arg4 != NULL && arg4[0] != '\0' &&
            arg5 != NULL && arg5[0] != '\0'   ) narg = 5;
        if (arg6 != NULL && arg6[0] != '\0' &&
            arg7 != NULL && arg7[0] != '\0'   ) narg = 7;
        if (arg8 != NULL && arg8[0] != '\0' &&
            arg9 != NULL && arg9[0] != '\0'   ) narg = 9;
        impstr = 0x1aa;
    } else if (type == OCSM_UNION) {         // toMark=0 trimList=0 maxtol=0
        bclass = OCSM_BOOLEAN;
        narg   = 3;
        impstr = 0x000;
    } else {
        status = OCSM_ILLEGAL_TYPE;
        goto cleanup;
    }

    /* mark MODL as not being checked */
    MODL->checked = 0;

    /* increment the number of Branches */
    (MODL->nbrch)++;
    ibrch = iafter + 1;

    MODL->ibrch = MODL->nbrch;

    /* extend the Branch list (if needed) */
    if (MODL->nbrch > MODL->mbrch) {
        MODL->mbrch += 25;
        RALLOC(MODL->brch, brch_T, MODL->mbrch+1);
    }

    /* copy the Branches up to make room for the new Branch */
#ifndef __clang_analyzer__
    if (ibrch < MODL->nbrch) {
        for (jbrch = MODL->nbrch; jbrch > ibrch; jbrch--) {
            MODL->brch[jbrch].name     = MODL->brch[jbrch-1].name;
            MODL->brch[jbrch].type     = MODL->brch[jbrch-1].type;
            MODL->brch[jbrch].bclass   = MODL->brch[jbrch-1].bclass;
            MODL->brch[jbrch].level    = MODL->brch[jbrch-1].level;
            MODL->brch[jbrch].indent   = MODL->brch[jbrch-1].indent;
            MODL->brch[jbrch].filename = MODL->brch[jbrch-1].filename;
            MODL->brch[jbrch].linenum  = MODL->brch[jbrch-1].linenum;
            MODL->brch[jbrch].actv     = MODL->brch[jbrch-1].actv;
            MODL->brch[jbrch].dirty    = 1;
            MODL->brch[jbrch].nattr    = MODL->brch[jbrch-1].nattr;
            MODL->brch[jbrch].attr     = MODL->brch[jbrch-1].attr;
            MODL->brch[jbrch].ileft    = MODL->brch[jbrch-1].ileft;
            MODL->brch[jbrch].irite    = MODL->brch[jbrch-1].irite;
            MODL->brch[jbrch].ichld    = MODL->brch[jbrch-1].ichld;
            MODL->brch[jbrch].narg     = MODL->brch[jbrch-1].narg;
            MODL->brch[jbrch].arg1     = MODL->brch[jbrch-1].arg1;
            MODL->brch[jbrch].arg2     = MODL->brch[jbrch-1].arg2;
            MODL->brch[jbrch].arg3     = MODL->brch[jbrch-1].arg3;
            MODL->brch[jbrch].arg4     = MODL->brch[jbrch-1].arg4;
            MODL->brch[jbrch].arg5     = MODL->brch[jbrch-1].arg5;
            MODL->brch[jbrch].arg6     = MODL->brch[jbrch-1].arg6;
            MODL->brch[jbrch].arg7     = MODL->brch[jbrch-1].arg7;
            MODL->brch[jbrch].arg8     = MODL->brch[jbrch-1].arg8;
            MODL->brch[jbrch].arg9     = MODL->brch[jbrch-1].arg9;
        }
    }
#endif

    /* initialize the new Branch */
    MODL->brch[ibrch].name     = NULL;
    MODL->brch[ibrch].type     = type;
    MODL->brch[ibrch].bclass   = bclass;
    MODL->brch[ibrch].level    = MODL->level;
    MODL->brch[ibrch].indent   = 0;
    MODL->brch[ibrch].filename = NULL;
    MODL->brch[ibrch].linenum  = linenum;
    MODL->brch[ibrch].actv     =  OCSM_ACTIVE;
    MODL->brch[ibrch].dirty    = 1;
    MODL->brch[ibrch].nattr    = 0;
    MODL->brch[ibrch].attr     = NULL;
    MODL->brch[ibrch].ileft    = -2;
    MODL->brch[ibrch].irite    = -2;
    MODL->brch[ibrch].ichld    = -2;
    MODL->brch[ibrch].narg     =  narg;
    MODL->brch[ibrch].arg1     =  NULL;
    MODL->brch[ibrch].arg2     =  NULL;
    MODL->brch[ibrch].arg3     =  NULL;
    MODL->brch[ibrch].arg4     =  NULL;
    MODL->brch[ibrch].arg5     =  NULL;
    MODL->brch[ibrch].arg6     =  NULL;
    MODL->brch[ibrch].arg7     =  NULL;
    MODL->brch[ibrch].arg8     =  NULL;
    MODL->brch[ibrch].arg9     =  NULL;

    /* default name for the Branch */
    MALLOC(  MODL->brch[ibrch].name, char, 12);
    snprintf(MODL->brch[ibrch].name,       12, "Brch_%06d", MODL->nextseq);
    (MODL->nextseq)++;

    /* save the filename */
    MALLOC(MODL->brch[ibrch].filename, char, MAX_FILENAME_LEN);
    strcpy(MODL->brch[ibrch].filename, filename);

    /* save the Arguments */
    if (narg >= 1) {
        if (arg1 != NULL && STRLEN(arg1) > 0) {
            if ((impstr & 0x100) && arg1[0] != '$' && arg1[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg1 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg1);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg1);
            }

            MALLOC(MODL->brch[ibrch].arg1, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg1,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 2) {
        if (arg2 != NULL && STRLEN(arg2) > 0) {
            if ((impstr & 0x080) && arg2[0] != '$' && arg2[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg2 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg2);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg2);
            }

            MALLOC(MODL->brch[ibrch].arg2, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg2,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 3) {
        if (arg3 != NULL && STRLEN(arg3) > 0) {
            if ((impstr & 0x040) && arg3[0] != '$' && arg3[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg3 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg3);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg3);
            }

            MALLOC(MODL->brch[ibrch].arg3, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg3,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 4) {
        if (arg4 != NULL && STRLEN(arg4) > 0) {
            if ((impstr & 0x020) && arg4[0] != '$' && arg4[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg4 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg4);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg4);
            }

            MALLOC(MODL->brch[ibrch].arg4, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg4,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 5) {
        if (arg5 != NULL && STRLEN(arg5) > 0) {
            if ((impstr & 0x010) && arg5[0] != '$' && arg5[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg5 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg5);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg5);
            }

            MALLOC(MODL->brch[ibrch].arg5, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg5,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 6) {
        if (arg6 != NULL && STRLEN(arg6) > 0) {
            if ((impstr & 0x008) && arg6[0] != '$' && arg6[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg6 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg6);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg6);
            }

            MALLOC(MODL->brch[ibrch].arg6, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg6,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 7) {
        if (arg7 != NULL && STRLEN(arg7) > 0) {
            if ((impstr & 0x004) && arg7[0] != '$' && arg7[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg7 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg7);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg7);
            }

            MALLOC(MODL->brch[ibrch].arg7, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg7,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 8) {
        if (arg8 != NULL && STRLEN(arg8) > 0) {
            if ((impstr & 0x002) && arg8[0] != '$' && arg8[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg8 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg8);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg8);
            }

            MALLOC(MODL->brch[ibrch].arg8, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg8,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 9) {
        if (arg9 != NULL && STRLEN(arg9) > 0) {
            if ((impstr & 0x001) && arg9[0] != '$' && arg9[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg9 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg9);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg9);
            }

            MALLOC(MODL->brch[ibrch].arg9, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg9,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    /* increment number of groups if Branch will create a Body */
    if (bclass == OCSM_PRIMITIVE ||
        bclass == OCSM_GROWN     ||
        bclass == OCSM_APPLIED   ||
        bclass == OCSM_BOOLEAN   ||
        bclass == OCSM_TRANSFORM ||
        type   == OCSM_SKEND       ) {
        (MODL->ngroup)++;
    }

cleanup:
    if (status < SUCCESS) {
        MODL->nbrch--;
    }

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetBrch - get info about a Branch                              *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetBrch(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            int    *type,               /* (out) Branch type */
            int    *bclass,             /* (out) Branch class */
            int    *actv,               /* (out) Branch Activity */
            int    *ichld,              /* (out) ibrch of child (or 0 if root) */
            int    *ileft,              /* (out) ibrch of left parent (or 0) */
            int    *irite,              /* (out) ibrch of rite parent (or 0) */
            int    *narg,               /* (out) number of Arguments */
            int    *nattr)              /* (out) number of Attributes */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetBrch);

    /* --------------------------------------------------------------- */

    /* default return values */
    *type   = 0;
    *bclass = 0;
    *actv   = 0;
    *ichld  = 0;
    *ileft  = 0;
    *irite  = 0;
    *narg   = 0;
    *nattr  = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* return pertinent information */
    *type   = MODL->brch[ibrch].type;
    *bclass = MODL->brch[ibrch].bclass;
    *actv   = MODL->brch[ibrch].actv;
    *ichld  = MODL->brch[ibrch].ichld;
    *ileft  = MODL->brch[ibrch].ileft;
    *irite  = MODL->brch[ibrch].irite;
    *narg   = MODL->brch[ibrch].narg;
    *nattr  = MODL->brch[ibrch].nattr;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetBrch - set activity for a Branch                            *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetBrch(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            int    actv)                /* (in)  Branch activity */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetBrch);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that a valid activity was given */
    if (actv != OCSM_ACTIVE    &&
        actv != OCSM_SUPPRESSED  ) {
        status = OCSM_ILLEGAL_ACTIVITY;
        goto cleanup;
    }

    /* check that branch type can be suppressed */
    if (MODL->brch[ibrch].bclass != OCSM_PRIMITIVE &&
        MODL->brch[ibrch].bclass != OCSM_GROWN     &&
        MODL->brch[ibrch].bclass != OCSM_APPLIED   &&
        MODL->brch[ibrch].bclass != OCSM_TRANSFORM   ) {
        status = OCSM_CANNOT_BE_SUPPRESSED;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* save the activity */
    MODL->brch[ibrch].actv = actv;

    /* mark the Branch as dirty */
    MODL->brch[ibrch].dirty = 1;

    /* mark MODL as not being checked */
    MODL->checked = 0;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmDelBrch - delete a Branch (or whole Sketch if SKBEG)           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmDelBrch(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch)               /* (in)  Branch index (1-nbrch) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       itype, jbrch, iattr;

    ROUTINE(ocsmDelBrch);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check for valid Branch index */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* mark MODL as not being checked */
    MODL->checked = 0;

    /* remember the type if ibrch */
    itype = MODL->brch[ibrch].type;

    if (itype == OCSM_SKBEG) {
        SPRINT0(1, "WARNING:: deleting entire Sketch");
        (MODL->nwarn)++;
    }

    /* delete the Branch(es) */
    while (ibrch <= MODL->nbrch) {

        /* free up the storage associated with ibrch */
        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            FREE(MODL->brch[ibrch].attr[iattr].name);
            FREE(MODL->brch[ibrch].attr[iattr].defn);
        }

        FREE(MODL->brch[ibrch].name    );
        FREE(MODL->brch[ibrch].filename);
        FREE(MODL->brch[ibrch].attr    );
        FREE(MODL->brch[ibrch].arg1    );
        FREE(MODL->brch[ibrch].arg2    );
        FREE(MODL->brch[ibrch].arg3    );
        FREE(MODL->brch[ibrch].arg4    );
        FREE(MODL->brch[ibrch].arg5    );
        FREE(MODL->brch[ibrch].arg6    );
        FREE(MODL->brch[ibrch].arg7    );
        FREE(MODL->brch[ibrch].arg8    );
        FREE(MODL->brch[ibrch].arg9    );

        /* move all Branches up to write over deleted Branch */
        for (jbrch = ibrch; jbrch < MODL->nbrch; jbrch++) {
            MODL->brch[jbrch].name     = MODL->brch[jbrch+1].name;
            MODL->brch[jbrch].type     = MODL->brch[jbrch+1].type;
            MODL->brch[jbrch].bclass   = MODL->brch[jbrch+1].bclass;
            MODL->brch[jbrch].level    = MODL->brch[jbrch-1].level;
            MODL->brch[jbrch].indent   = MODL->brch[jbrch+1].indent;
            MODL->brch[jbrch].filename = MODL->brch[jbrch+1].filename;
            MODL->brch[jbrch].linenum  = MODL->brch[jbrch+1].linenum;
            MODL->brch[jbrch].actv     = MODL->brch[jbrch+1].actv;
            MODL->brch[jbrch].dirty    = 1;
            MODL->brch[jbrch].nattr    = MODL->brch[jbrch+1].nattr;
            MODL->brch[jbrch].attr     = MODL->brch[jbrch+1].attr;
            MODL->brch[jbrch].ileft    = MODL->brch[jbrch+1].ileft;
            MODL->brch[jbrch].irite    = MODL->brch[jbrch+1].irite;
            MODL->brch[jbrch].ichld    = MODL->brch[jbrch+1].ichld;
            MODL->brch[jbrch].narg     = MODL->brch[jbrch+1].narg;
            MODL->brch[jbrch].arg1     = MODL->brch[jbrch+1].arg1;
            MODL->brch[jbrch].arg2     = MODL->brch[jbrch+1].arg2;
            MODL->brch[jbrch].arg3     = MODL->brch[jbrch+1].arg3;
            MODL->brch[jbrch].arg4     = MODL->brch[jbrch+1].arg4;
            MODL->brch[jbrch].arg5     = MODL->brch[jbrch+1].arg5;
            MODL->brch[jbrch].arg6     = MODL->brch[jbrch+1].arg6;
            MODL->brch[jbrch].arg7     = MODL->brch[jbrch+1].arg7;
            MODL->brch[jbrch].arg8     = MODL->brch[jbrch+1].arg8;
            MODL->brch[jbrch].arg9     = MODL->brch[jbrch+1].arg9;
        }

        /* null pointers associated with the last Branch (since they were
           copied down) */
        MODL->brch[MODL->nbrch].name     = NULL;
        MODL->brch[MODL->nbrch].filename = NULL;
        MODL->brch[MODL->nbrch].attr     = NULL;
        MODL->brch[MODL->nbrch].arg1     = NULL;
        MODL->brch[MODL->nbrch].arg2     = NULL;
        MODL->brch[MODL->nbrch].arg3     = NULL;
        MODL->brch[MODL->nbrch].arg4     = NULL;
        MODL->brch[MODL->nbrch].arg5     = NULL;
        MODL->brch[MODL->nbrch].arg6     = NULL;
        MODL->brch[MODL->nbrch].arg7     = NULL;
        MODL->brch[MODL->nbrch].arg8     = NULL;
        MODL->brch[MODL->nbrch].arg9     = NULL;

        /* decrement the number of Branches */
        (MODL->nbrch)--;

        /* if the remembered type is not SKBEG, we are done */
        if (itype != OCSM_SKBEG) break;

        /* otherwise keep deleting Branches that were in the Sketch */
        if (MODL->brch[ibrch].type   != OCSM_SKEND &&
            MODL->brch[ibrch].bclass != OCSM_SKETCH  ) break;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintBrchs - print Branches to file                            *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintBrchs(void   *modl,            /* (in)  pointer to MODL */
               FILE   *fp)              /* (in)  pointer to FILE */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ibrch, i, nindent, iattr;

    ROUTINE(ocsmPrintBrchs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* run ocsmCheck to set up necessary linkages amongst Branches */
    status = ocsmCheck(MODL);
    CHECK_STATUS(ocsmCheck);

    /* print header */
    fprintf(fp, "    ibrch                    type             ileft irite ichld args...\n");

    /* print global Attributes */
    for (iattr = 0; iattr < MODL->nattr; iattr++) {
        if (MODL->attr[iattr].type != ATTRCSYS) {
            fprintf(fp, "                                              attr: %-20s %-20s\n",
                    MODL->attr[iattr].name,
                    MODL->attr[iattr].defn);
        } else {
            fprintf(fp, "                                              csys: %-20s %-20s\n",
                    MODL->attr[iattr].name,
                    MODL->attr[iattr].defn);
            }
    }

    /* print each Branch */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {

        fprintf(fp, "    %5d", ibrch);

        if (MODL->brch[ibrch].ileft == -2 &&
            MODL->brch[ibrch].irite == -2 &&
            MODL->brch[ibrch].ichld == -2   ) {
            fprintf(fp, " [-] ");
        } else if (MODL->brch[ibrch].dirty > 0) {
            if (MODL->brch[ibrch].actv == OCSM_ACTIVE    ) fprintf(fp, " [a] ");
            if (MODL->brch[ibrch].actv == OCSM_SUPPRESSED) fprintf(fp, " [s] ");
            if (MODL->brch[ibrch].actv == OCSM_INACTIVE  ) fprintf(fp, " [i] ");
            if (MODL->brch[ibrch].actv == OCSM_DEFERRED  ) fprintf(fp, " [d] ");
        } else {
            if (MODL->brch[ibrch].actv == OCSM_ACTIVE    ) fprintf(fp, " (a) ");
            if (MODL->brch[ibrch].actv == OCSM_SUPPRESSED) fprintf(fp, " (s) ");
            if (MODL->brch[ibrch].actv == OCSM_INACTIVE  ) fprintf(fp, " (i) ");
            if (MODL->brch[ibrch].actv == OCSM_DEFERRED  ) fprintf(fp, " (d) ");
        }

        fprintf(fp, " %-14s", MODL->brch[ibrch].name);

        nindent = MODL->brch[ibrch].indent;
        for (i = 0; i < nindent; i++) {
            fprintf(fp, ".");
        }

        fprintf(fp, "%-9s", ocsmGetText(MODL->brch[ibrch].type));

        for (i = nindent; i < 8; i++) {
            fprintf(fp, " ");
        }

        fprintf(fp, "%5d %5d %5d", MODL->brch[ibrch].ileft,
                                   MODL->brch[ibrch].irite,
                                   MODL->brch[ibrch].ichld);

        if (MODL->brch[ibrch].narg >= 1) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg1    );
        }
        if (MODL->brch[ibrch].narg >= 2) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg2    );
        }
        if (MODL->brch[ibrch].narg >= 3) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg3    );
        }
        if (MODL->brch[ibrch].narg >= 4) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg4    );
        }
        if (MODL->brch[ibrch].narg >= 5) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg5    );
        }
        if (MODL->brch[ibrch].narg >= 6) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg6    );
        }
        if (MODL->brch[ibrch].narg >= 7) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg7    );
        }
        if (MODL->brch[ibrch].narg >= 8) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg8    );
        }
        if (MODL->brch[ibrch].narg >= 9) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg9    );
        }

        fprintf(fp, "\n");

        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            if (MODL->brch[ibrch].attr[iattr].type != ATTRCSYS) {
                fprintf(fp, "                                              attr: %-20s %-20s\n",
                        MODL->brch[ibrch].attr[iattr].name,
                        MODL->brch[ibrch].attr[iattr].defn);
            } else {
                fprintf(fp, "                                              csys: %-20s %-20s\n",
                        MODL->brch[ibrch].attr[iattr].name,
                        MODL->brch[ibrch].attr[iattr].defn);
            }
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetArg - get an Argument for a Branch                          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetArg(void   *modl,                /* (in)  pointer to MODL */
           int    ibrch,                /* (in)  Branch index (1-nbrch) */
           int    iarg,                 /* (in)  Argument index (1-narg) */
           char   defn[],               /* (out) Argument definition (at least MAX_STRVAL_LEN long) */
           double *value,               /* (out) Argument value */
           double *dot)                 /* (out) Argument velocity */
{
    int       status = SUCCESS;         /* (out) return status */

    char      str[MAX_STRVAL_LEN];
    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetArg);

    /* --------------------------------------------------------------- */

    /* default return values */
    defn[0] = '\0';
    *value  = 0;
    str[0]  = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that valid iarg is given */
    if (iarg < 1 || iarg > MODL->brch[ibrch].narg) {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

    /* return the definition and current value */
    if (iarg == 1) {
        STRNCPY(defn, MODL->brch[ibrch].arg1, MAX_STRVAL_LEN);
    }
    if (iarg == 2) {
        STRNCPY(defn, MODL->brch[ibrch].arg2, MAX_STRVAL_LEN);
    }
    if (iarg == 3) {
        STRNCPY(defn, MODL->brch[ibrch].arg3, MAX_STRVAL_LEN);
    }
    if (iarg == 4) {
        STRNCPY(defn, MODL->brch[ibrch].arg4, MAX_STRVAL_LEN);
    }
    if (iarg == 5) {
        STRNCPY(defn, MODL->brch[ibrch].arg5, MAX_STRVAL_LEN);
    }
    if (iarg == 6) {
        STRNCPY(defn, MODL->brch[ibrch].arg6, MAX_STRVAL_LEN);
    }
    if (iarg == 7) {
        STRNCPY(defn, MODL->brch[ibrch].arg7, MAX_STRVAL_LEN);
    }
    if (iarg == 8) {
        STRNCPY(defn, MODL->brch[ibrch].arg8, MAX_STRVAL_LEN);
    }
    if (iarg == 9) {
        STRNCPY(defn, MODL->brch[ibrch].arg9, MAX_STRVAL_LEN);
    }

    status = str2val(defn, MODL, value, dot, str);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetArg - set an Argument for a Branch                          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetArg(void   *modl,                /* (in)  pointer to MODL */
           int    ibrch,                /* (in)  Branch index (1-nbrch) */
           int    iarg,                 /* (in)  Argument index (1-narg) */
           char   defn[])               /* (in)  Argument definition */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetArg);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that valid iarg is given */
    if (iarg < 1 || iarg > MODL->brch[ibrch].narg) {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* save the definition */
    if        (iarg == 1) {
        if (strcmp(defn, MODL->brch[ibrch].arg1) != 0) {
            FREE(  MODL->brch[ibrch].arg1);
            MALLOC(MODL->brch[ibrch].arg1, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg1,                    defn    );
        }
    } else if (iarg == 2) {
        if (strcmp(defn, MODL->brch[ibrch].arg2) != 0) {
            FREE(  MODL->brch[ibrch].arg2);
            MALLOC(MODL->brch[ibrch].arg2, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg2,                    defn    );
        }
    } else if (iarg == 3) {
        if (strcmp(defn, MODL->brch[ibrch].arg3) != 0) {
            FREE(  MODL->brch[ibrch].arg3);
            MALLOC(MODL->brch[ibrch].arg3, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg3,                    defn    );
        }
    } else if (iarg == 4) {
        if (strcmp(defn, MODL->brch[ibrch].arg4) != 0) {
            FREE(  MODL->brch[ibrch].arg4);
            MALLOC(MODL->brch[ibrch].arg4, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg4,                    defn    );
        }
    } else if (iarg == 5) {
        if (strcmp(defn, MODL->brch[ibrch].arg5) != 0) {
            FREE(  MODL->brch[ibrch].arg5);
            MALLOC(MODL->brch[ibrch].arg5, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg5,                    defn    );
        }
    } else if (iarg == 6) {
        if (strcmp(defn, MODL->brch[ibrch].arg6) != 0) {
            FREE(  MODL->brch[ibrch].arg6);
            MALLOC(MODL->brch[ibrch].arg6, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg6,                    defn    );
        }
    } else if (iarg == 7) {
        if (strcmp(defn, MODL->brch[ibrch].arg7) != 0) {
            FREE(  MODL->brch[ibrch].arg7);
            MALLOC(MODL->brch[ibrch].arg7, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg7,                    defn    );
        }
    } else if (iarg == 8) {
        if (strcmp(defn, MODL->brch[ibrch].arg8) != 0) {
            FREE(  MODL->brch[ibrch].arg8);
            MALLOC(MODL->brch[ibrch].arg8, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg8,                    defn    );
        }
    } else if (iarg == 9) {
        if (strcmp(defn, MODL->brch[ibrch].arg9) != 0) {
            FREE(  MODL->brch[ibrch].arg9);
            MALLOC(MODL->brch[ibrch].arg9, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg9,                    defn    );
        }
    }

    /* mark the Branch as dirty */
    MODL->brch[ibrch].dirty = 1;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmRetAttr - return an Attribute for a Branch by index            *
 *                                                                      *
 ************************************************************************
 */

int
ocsmRetAttr(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            int    iattr,               /* (in)  Attribute index (1-nattr) */
            char   aname[],             /* (out) Attribute name  (at least MAX_STRVAL_LEN long) */
            char   avalue[])            /* (out) Attribute value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmRetAttr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that value iattr is given */
    if (iattr < 1 || iattr > MODL->brch[ibrch].nattr) {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

    /* return the name and value */
    if (MODL->brch[ibrch].attr[iattr-1].type != ATTRCSYS) {
        STRNCPY(aname,  MODL->brch[ibrch].attr[iattr-1].name, MAX_STRVAL_LEN);
        STRNCPY(avalue, MODL->brch[ibrch].attr[iattr-1].defn, MAX_STRVAL_LEN);
    } else {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetAttr - get an Attribute for a Branch by name                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetAttr(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            char   aname[],             /* (in)  Attribute name */
            char   avalue[])            /* (out) Attribute value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iattr, jattr;

    ROUTINE(ocsmGetAttr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 0 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* global Attribute */
    if (ibrch == 0) {

        /* determine the Attribute index (if any) */
        iattr = -1;
        for (jattr = 0; jattr < MODL->nattr; jattr++) {
            if (strcmp(MODL->attr[jattr].name, aname) == 0) {
                iattr = jattr;
                break;
            }
        }

        /* error if Attribute name is not found */
        if (iattr < 0) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        }

        /* return the value */
        STRNCPY(avalue, MODL->attr[iattr].defn, MAX_STRVAL_LEN);

    /* Attribute for Branch */
    } else {

        /* determine the Attribute index (if any) */
        iattr = -1;
        for (jattr = 0; jattr < MODL->brch[ibrch].nattr; jattr++) {
            if (strcmp(MODL->brch[ibrch].attr[jattr].name, aname) == 0 &&
                       MODL->brch[ibrch].attr[jattr].type != ATTRCSYS    ) {
                iattr = jattr;
                break;
            }
        }

        /* error if Attribute name is not found */
        if (iattr < 0) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        }

        /* return the value */
        STRNCPY(avalue, MODL->brch[ibrch].attr[iattr].defn, MAX_STRVAL_LEN);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetAttr - set an Attribute for a Branch                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetAttr(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            char   aname[],             /* (in)  Attribute name */
            char   avalue[])            /* (in)  Attribute value (or blank to delete) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iattr, jattr, jbrch;

    ROUTINE(ocsmSetAttr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 0 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* if aname is a NULL, return now */
    if (STRLEN(aname) == 0) {
        SPRINT0(1, "WARNING:: NULL name given for Attribute");
        (MODL->nwarn)++;
        goto cleanup;

    /* if avalue is a NULL string, return now */
    } else if (strcmp(avalue, "$") == 0) {
        SPRINT1(1, "WARNING:: NULL value given for Attribute \"%s\"", aname);
        (MODL->nwarn)++;
        goto cleanup;
    }

    /* global Attribute */
    if (ibrch == 0) {

        /* determine the Attribute index (if any) */
        iattr = -1;
        for (jattr = 0; jattr < MODL->nattr; jattr++) {
            if (strcmp(MODL->attr[jattr].name, aname) == 0) {
                iattr = jattr;
                break;
            }
        }

        /* adding or modifying an Attribute */
        if (STRLEN(avalue) > 0) {
            /* if Attribute is not found already, create a new one */
            if (iattr < 0) {
                MODL->nattr++;

                RALLOC(MODL->attr, attr_T, MODL->nattr);

                iattr = MODL->nattr - 1;
                MODL->attr[iattr].name = NULL;
                MODL->attr[iattr].defn = NULL;
                MODL->attr[iattr].type = ATTRREAL;
            }

            /* set the Attribute's name and value */
            FREE(  MODL->attr[iattr].name);
            MALLOC(MODL->attr[iattr].name,  char, (int)(STRLEN(aname)+1));
            strcpy(MODL->attr[iattr].name,                     aname    );

            FREE(  MODL->attr[iattr].defn);
            MALLOC(MODL->attr[iattr].defn, char, (int)(STRLEN(avalue)+1));
            strcpy(MODL->attr[iattr].defn,                    avalue    );

        /* deleting an Attribute */
        } else {
            if (iattr < 0) {
                status = OCSM_NAME_NOT_FOUND;
                goto cleanup;
            }

            MODL->nattr--;

            for (jattr = iattr; jattr < MODL->nattr; jattr++) {
                MODL->attr[jattr].name = MODL->attr[jattr+1].name;
                MODL->attr[jattr].defn = MODL->attr[jattr+1].defn;
            }

            FREE(MODL->attr[MODL->nattr].name);
            FREE(MODL->attr[MODL->nattr].defn);
        }

        /* mark all the Branches as dirty */
        for (jbrch = 1; jbrch <= MODL->nbrch; jbrch++) {
            MODL->brch[jbrch].dirty = 1;
        }

    /* Attribute for Branch */
    } else {

        /* determine the Attribute index (if any) */
        iattr = -1;
        for (jattr = 0; jattr < MODL->brch[ibrch].nattr; jattr++) {
            if (strcmp(MODL->brch[ibrch].attr[jattr].name, aname) == 0) {
                iattr = jattr;
                break;
            }
        }

        /* adding or modifying an Attribute */
        if (STRLEN(avalue) > 0) {
            /* if Attribute is not found already, create a new one */
            if (iattr < 0) {
                MODL->brch[ibrch].nattr++;

                RALLOC(MODL->brch[ibrch].attr, attr_T, MODL->brch[ibrch].nattr);

                iattr = MODL->brch[ibrch].nattr - 1;
                MODL->brch[ibrch].attr[iattr].name = NULL;
                MODL->brch[ibrch].attr[iattr].defn = NULL;
                MODL->brch[ibrch].attr[iattr].type = ATTRREAL;
            } else if (MODL->brch[ibrch].attr[iattr].type == ATTRCSYS) {
                status = OCSM_NAME_NOT_UNIQUE;
                goto cleanup;
            }

            /* set the Attribute's name and value */
            FREE(  MODL->brch[ibrch].attr[iattr].name);
            MALLOC(MODL->brch[ibrch].attr[iattr].name,  char, (int)(STRLEN(aname)+1));
            strcpy(MODL->brch[ibrch].attr[iattr].name,                     aname    );

            FREE(  MODL->brch[ibrch].attr[iattr].defn);
            MALLOC(MODL->brch[ibrch].attr[iattr].defn, char, (int)(STRLEN(avalue)+1));
            strcpy(MODL->brch[ibrch].attr[iattr].defn,                    avalue    );

        /* deleting an Attribute */
        } else {
            if (iattr < 0) {
                status = OCSM_NAME_NOT_FOUND;
                goto cleanup;
            } else if (MODL->brch[ibrch].attr[iattr].type == ATTRCSYS) {
                status = OCSM_NAME_NOT_FOUND;
                goto cleanup;
            }

            MODL->brch[ibrch].nattr--;

            for (jattr = iattr; jattr < MODL->brch[ibrch].nattr; jattr++) {
                MODL->brch[ibrch].attr[jattr].name = MODL->brch[ibrch].attr[jattr+1].name;
                MODL->brch[ibrch].attr[jattr].defn = MODL->brch[ibrch].attr[jattr+1].defn;
                MODL->brch[ibrch].attr[jattr].type = MODL->brch[ibrch].attr[jattr+1].type;
            }
        }

        /* mark the Branch as dirty */
        MODL->brch[ibrch].dirty = 1;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmRetCsys - return a Csystem for a Branch by index               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmRetCsys(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            int    icsys,               /* (in)  Csystem index (1-nattr) */
            char   cname[],             /* (out) Csystem name  (at least MAX_STRVAL_LEN long) */
            char   cvalue[])            /* (out) Csystem value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmRetCsys);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that value icsys is given */
    if (icsys < 1 || icsys > MODL->brch[ibrch].nattr) {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

    /* return the name and value */
    if (MODL->brch[ibrch].attr[icsys-1].type == ATTRCSYS) {
        STRNCPY(cname,  MODL->brch[ibrch].attr[icsys-1].name, MAX_STRVAL_LEN);
        STRNCPY(cvalue, MODL->brch[ibrch].attr[icsys-1].defn, MAX_STRVAL_LEN);
    } else {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetCsys - get a Csystem for a Branch by name                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetCsys(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            char   cname[],             /* (in)  Csystem name */
            char   cvalue[])            /* (out) Csystem value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       icsys, jcsys;

    ROUTINE(ocsmGetCsys);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* determine the Csystem index (if any) */
    icsys = -1;
    for (jcsys = 0; jcsys < MODL->brch[ibrch].nattr; jcsys++) {
        if (strcmp(MODL->brch[ibrch].attr[jcsys].name, cname) == 0 &&
                   MODL->brch[ibrch].attr[jcsys].type == ATTRCSYS    ) {
            icsys = jcsys;
            break;
        }
    }

    /* error if Csystem name is not found */
    if (icsys < 0) {
        status = OCSM_NAME_NOT_FOUND;
        goto cleanup;
    }

    /* return the value */
    STRNCPY(cvalue, MODL->brch[ibrch].attr[icsys].defn, MAX_STRVAL_LEN);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetCsys - set a Csystem for a Branch                           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetCsys(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            char   cname[],             /* (in)  Csystem name */
            char   cvalue[])            /* (in)  Csystem value (or blank to delete) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       icsys, jcsys;

    ROUTINE(ocsmSetCsys);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* determine the Csystem index (if any) */
    icsys = -1;
    for (jcsys = 0; jcsys < MODL->brch[ibrch].nattr; jcsys++) {
        if (strcmp(MODL->brch[ibrch].attr[jcsys].name, cname) == 0) {
            icsys = jcsys;
            break;
        }
    }

    /* adding or modifying a Csystem */
    if (STRLEN(cvalue) > 0) {
        /* if Csystem is not found already, create a new one */
        if (icsys < 0) {
            MODL->brch[ibrch].nattr++;

            RALLOC(MODL->brch[ibrch].attr, attr_T, MODL->brch[ibrch].nattr);

            icsys = MODL->brch[ibrch].nattr - 1;
            MODL->brch[ibrch].attr[icsys].name = NULL;
            MODL->brch[ibrch].attr[icsys].defn = NULL;
            MODL->brch[ibrch].attr[icsys].type = ATTRCSYS;
        } else if (MODL->brch[ibrch].attr[icsys].type != ATTRCSYS) {
            status = OCSM_NAME_NOT_UNIQUE;
            goto cleanup;
        }

        /* set the Csystem's name and value */
        FREE(  MODL->brch[ibrch].attr[icsys].name);
        MALLOC(MODL->brch[ibrch].attr[icsys].name,  char, (int)(STRLEN(cname )+1));
        strcpy(MODL->brch[ibrch].attr[icsys].name,                     cname     );

        FREE(  MODL->brch[ibrch].attr[icsys].defn);
        MALLOC(MODL->brch[ibrch].attr[icsys].defn, char, (int)(STRLEN(cvalue)+1));
        strcpy(MODL->brch[ibrch].attr[icsys].defn,                    cvalue    );

    /* deleting a Csystem */
    } else {
        if (icsys < 0) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        } else if (MODL->brch[ibrch].attr[icsys].type != ATTRCSYS) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        }

        MODL->brch[ibrch].nattr--;

        for (jcsys = icsys; jcsys < MODL->brch[ibrch].nattr; jcsys++) {
            MODL->brch[ibrch].attr[jcsys].name = MODL->brch[ibrch].attr[jcsys+1].name;
            MODL->brch[ibrch].attr[jcsys].defn = MODL->brch[ibrch].attr[jcsys+1].defn;
            MODL->brch[ibrch].attr[jcsys].type = MODL->brch[ibrch].attr[jcsys+1].type;
        }
    }

    /* mark the Branch as dirty */
    MODL->brch[ibrch].dirty = 1;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintAttrs - print global Attributes to file                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintAttrs(void   *modl,            /* (in)  pointer to MODL */
               FILE   *fp)              /* (in)  pointer to FILE */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iattr;

    ROUTINE(ocsmPrintAttrs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    for (iattr = 0; iattr < MODL->nattr; iattr++) {
        fprintf(fp, "    %-24s -> %24s\n",
                MODL->attr[iattr].name,
                MODL->attr[iattr].defn);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetName - get the name of a Branch                             *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetName(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            char   name[])              /* (out) Branch name (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetName);

    /* --------------------------------------------------------------- */

    /* default return values */
    name[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* return the name */
    STRNCPY(name, MODL->brch[ibrch].name, MAX_STRVAL_LEN);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetName - set the name for a Branch                            *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetName(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            char   name[])              /* (in)  Branch name */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jbrch;

    ROUTINE(ocsmSetName);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* make sure that the new name is unique */
    for (jbrch = 1; jbrch <= MODL->nbrch; jbrch++) {
        if (strcmp(name, MODL->brch[jbrch].name) == 0) {
            status = OCSM_NAME_NOT_UNIQUE;
            goto cleanup;
        } else if (strncmp(name, "Brch_", 5) == 0) {
            status = OCSM_NAME_NOT_UNIQUE;
            goto cleanup;
        }
    }

    /* name cannot contain ">" */
    if (strstr(name, ">") != NULL) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* set the name */
    FREE(MODL->brch[ibrch].name);

    MALLOC(MODL->brch[ibrch].name, char, (int)(STRLEN(name)+1));
    strcpy(MODL->brch[ibrch].name,                    name    );

    /* mark the Branch as dirty */
    MODL->brch[ibrch].dirty = 1;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetSketch - get string data associated with a Sketch           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetSketch(void   *modl,             /* (in)  pointer to MODL */
              int    ibrch,             /* (in)  Branch index (1-nbrch) within Sketch */
              int    maxlen,            /* (in)  length of begs, vars, cons, and segs */
              char   begs[],            /* (out) string with SKBEG variables */
              char   vars[],            /* (out) string with Sketch variables */
              char   cons[],            /* (out) string with Sketch constraints */
              char   segs[])            /* (out) string with Sketch segments */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jbrch, iskbeg, iskend, index1, index2, ibeg, iend;
    double    value, xval, yval, zval, rel, dot;
    char      *token=NULL, str[MAX_STRVAL_LEN];

    ROUTINE(ocsmGetSketch);

    /* --------------------------------------------------------------- */

    MODL->sigCode    = 0;
    MODL->sigMesg[0] = '\0';

    /* default returns */
    begs[0] = '\0';
    vars[0] = '\0';
    cons[0] = '\0';
    segs[0] = '\0';

    if        (MODL->brch[ibrch].type == OCSM_SKBEG) {
        iskbeg = ibrch;
        iskend = ibrch + 1;
    } else if (MODL->brch[ibrch].type == OCSM_SKEND) {
        iskbeg = ibrch - 1;
        iskend = ibrch;
    } else {
        iskbeg = ibrch;
        iskend = ibrch;
    }

    /* find SKBEG at or before ibrch */
    while (iskbeg > 0 && MODL->brch[iskbeg].type != OCSM_SKBEG) {
        if (MODL->brch[iskbeg].type == OCSM_SKEND) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (SKEND found first)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
        iskbeg--;
        if (iskbeg <= 0) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (at beginning)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
    }

    /* find SKEND at or after ibrch */
    while (iskend <= MODL->nbrch && MODL->brch[iskend].type != OCSM_SKEND) {
        if (MODL->brch[iskend].type == OCSM_SKBEG) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (SKBEG found first)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
        iskend++;
        if (iskend <= 0) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (at end)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
    }

    MALLOC(token, char, maxlen+1);

    /* build the begs string */
    status = str2val(MODL->brch[iskbeg].arg1, MODL, &xval, &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "xval cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    status = str2val(MODL->brch[iskbeg].arg2, MODL, &yval, &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "yval cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    status = str2val(MODL->brch[iskbeg].arg3, MODL, &zval, &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "zval cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    status = str2val(MODL->brch[iskbeg].arg3, MODL, &rel,  &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "rel cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    snprintf(begs, maxlen, "%s;%f;%s;%f;%s;%f;%s;%f;",
             MODL->brch[iskbeg].arg1, xval,
             MODL->brch[iskbeg].arg2, yval,
             MODL->brch[iskbeg].arg3, zval,
             MODL->brch[iskbeg].arg4, rel );

    /* if there are no statements within the Sketch, return an empty Sketch */
    if (iskend == iskbeg+1) {
        goto cleanup;
    }

    /* make sure that there there are only valid statements in the Sketch */
    for (jbrch = iskbeg+1; jbrch < iskend; jbrch++) {
        if (MODL->brch[jbrch].type != OCSM_SKVAR  &&
            MODL->brch[jbrch].type != OCSM_SKCON  &&
            MODL->brch[jbrch].type != OCSM_LINSEG &&
            MODL->brch[jbrch].type != OCSM_ARC    &&
            MODL->brch[jbrch].type != OCSM_SPLINE &&
            MODL->brch[jbrch].type != OCSM_SSLOPE &&
            MODL->brch[jbrch].type != OCSM_BEZIER   ) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "wrong type (%s) in Sketch", ocsmGetText(MODL->brch[jbrch].type));
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
        }
    }

    /* make sure that a SKVAR follows the SKBEG */
    if (MODL->brch[iskbeg+1].type != OCSM_SKVAR) {
        signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                    "SKVAR does not follow SKBEG");
        SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
    }

    /* create the Sketch variables from the SKVAR statement */
    if (STRLEN(MODL->brch[iskbeg+1].arg2) < maxlen-1) {
        STRNCPY(vars, MODL->brch[iskbeg+1].arg2, maxlen);
    } else {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "buffer overflow writing Sketch variables");
        SET_STATUS(OCSM_INTERNAL_ERROR, ocsmGetSketch);
    }

    /* create the Sketch constraints from the SKCON statements */
    jbrch = iskbeg + 2;
    while (jbrch < iskend && MODL->brch[jbrch].type == OCSM_SKCON) {
        status = str2val(MODL->brch[jbrch].arg2, MODL, &value, &dot, str);
        CHECK_STATUS(str2val);
        if (STRLEN(str) > 0) {
            signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                        "stretch constraint value cannot be a string (%s)", ibrch, str);
            SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
        }
        index1 = NINT(value);

        status = str2val(MODL->brch[jbrch].arg3, MODL, &value, &dot, str);
        CHECK_STATUS(str2val);
        if (STRLEN(str) > 0) {
            signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                        "stretch constraint value cannot be a string (%s)", ibrch, str);
            SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
        }
        index2 = NINT(value);

        snprintf(token, maxlen, "%s;%d;%d;%s;",
                 &(MODL->brch[jbrch].arg1[1]), index1, index2, &(MODL->brch[jbrch].arg4[1]));

        if (STRLEN(cons)+STRLEN(token) < maxlen-1) {
            strncat(cons, token, maxlen);
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "buffer overflow writing Sketch constraints");
            SET_STATUS(OCSM_INTERNAL_ERROR, ocsmGetSketch);
        }

        jbrch++;
    }

    /* create the Sketch segments from the LINSEG, ARC, SPLINE, and BEZIER statements */
    ibeg = 1;
    while (jbrch < iskend) {
        if (strncmp(MODL->brch[jbrch].arg1, "::x[", 4) != 0) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "statement does not use ::x[] for x-argument");
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
        }
        if (strncmp(MODL->brch[jbrch].arg2, "::y[", 4) != 0) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "statement does not use ::y[] for y-argument");
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
        }
        if (strncmp(MODL->brch[jbrch].arg3, "::z[", 4) != 0 &&
            strcmp( MODL->brch[jbrch].arg3, "0"      ) != 0   ) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "statement does not use ::z[] or 0 for z-argument");
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
        }

        if (strcmp(MODL->brch[jbrch].arg1, "::x[1]") == 0) {
            iend = 1;
        } else {
            iend = ibeg + 1;
        }

        if        (MODL->brch[jbrch].type == OCSM_LINSEG) {
            snprintf(token, maxlen, "L;%d;%d;", ibeg, iend);
        } else if (MODL->brch[jbrch].type == OCSM_ARC) {
            snprintf(token, maxlen, "C;%d;%d;", ibeg, iend);
        } else if (MODL->brch[jbrch].type == OCSM_SPLINE) {
            snprintf(token, maxlen, "S;%d;%d;", ibeg, iend);
        } else if (MODL->brch[jbrch].type == OCSM_BEZIER) {
            snprintf(token, maxlen, "B;%d;%d;", ibeg, iend);
        }

        strncat(segs, token, maxlen);

        ibeg = iend;
        jbrch++;
    }

cleanup:
    FREE(token);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSolveSketch - solve for new Sketch variables                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSolveSketch(void   *modl,           /* (in)  pointer to MODL */
                char   vars_in[],       /* (in)  string with Sketch variables */
                char   cons[],          /* (in)  string with Sketch constraints */
                                        /* (out) string with Sketch constraint changes */
                char   vars_out[])      /* (out) string (1024 long) with new Sketch variables
                                                 or suggested modified constraints
                                                 (if starts with "*") */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;
    sket_T    *sket=NULL;

    int       i, im1, ip1, icount, lentok, index1, index2, ivar, nvar, jpmtr, jndex;
    int       ii, jj, ibeg, iend;
    double    val;
    char      token[MAX_EXPR_LEN], type[MAX_EXPR_LEN], value[MAX_EXPR_LEN];
    char      prefix[MAX_EXPR_LEN], suffix[MAX_EXPR_LEN];
    char      cons_mod[MAX_EXPR_LEN];

    ROUTINE(ocsmSolveSketch);

    /* --------------------------------------------------------------- */

    MALLOC(sket, sket_T, 1);

    /* default (empty) return */
    vars_out[0]      = '\0';
    MODL->sigMesg[0] = '\0';

    /* initialize the Sketch */
    sket->type   = 0;
    sket->size   = 0;
    sket->solved = 0;
    sket->nseg   = 0;
    sket->nvar   = 0;
    sket->ncon   = 0;

    /* count the semicolons in vars_in to detemine number of variables */
    nvar = 0;
    for (i = 0; i < STRLEN(vars_in); i++) {
        if (vars_in[i] == ';') nvar++;
    }

    if (nvar%3 == 0) {
        nvar /= 3;
        sket->size = nvar;
    } else {
        signalError(MODL, OCSM_ILLEGAL_VALUE,
                    "vars_in contains %d semicolons (which is not evenly divisible by 3)", nvar);
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* remove internal Parameters that may be left over from a failure
          in a Sketch that was being solved */
    status = delPmtrByName(MODL, "::d");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::z");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::y");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::x");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    /* make the new Sketch variables */
    status = ocsmNewPmtr(MODL, "::x", OCSM_INTERNAL, 1, sket->size);
    CHECK_STATUS(ocsmNewPmtr);
    sket->ix = MODL->npmtr;

    status = ocsmNewPmtr(MODL, "::y", OCSM_INTERNAL, 1, sket->size);
    CHECK_STATUS(ocsmNewPmtr);
    sket->iy = MODL->npmtr;

    status = ocsmNewPmtr(MODL, "::z", OCSM_INTERNAL, 1, sket->size);
    CHECK_STATUS(ocsmNewPmtr);
    sket->iz = MODL->npmtr;

    status = ocsmNewPmtr(MODL, "::d", OCSM_INTERNAL, 1, sket->size);
    CHECK_STATUS(ocsmNewPmtr);
    sket->id = MODL->npmtr;

    /* pull the variables out of vars_in */
    icount = 0;
    lentok = 0;
    for (i = 0; i < STRLEN(vars_in); i++) {
        if (vars_in[i] != ';') {
            token[lentok++] = vars_in[i];
            token[lentok  ] = '\0';
        } else {
            val = strtod(token, NULL);
            if        (icount%3 == 0) {
                MODL->pmtr[sket->ix].value[icount/3] = val;
                MODL->pmtr[sket->ix].dot[  icount/3] = 0;
            } else if (icount%3 == 1) {
                MODL->pmtr[sket->iy].value[icount/3] = val;
                MODL->pmtr[sket->iy].dot[  icount/3] = 0;
            } else {
                MODL->pmtr[sket->id].value[icount/3] = val;
                MODL->pmtr[sket->id].dot[  icount/3] = 0;
            }

            icount++;
            lentok = 0;
        }
    }

    /* make a list of the Sketch variables */
    sket->nvar = 0;
    for (i = 1; i <= sket->size; i++) {
        sket->ipmtr[sket->nvar] = sket->ix;
        sket->index[sket->nvar] = i-1;
        sket->nvar++;

        sket->ipmtr[sket->nvar] = sket->iy;
        sket->index[sket->nvar] = i-1;
        sket->nvar++;

        if (fabs(MODL->pmtr[sket->id].value[i-1]) > EPS06) {
            sket->ipmtr[sket->nvar] = sket->id;
            sket->index[sket->nvar] = i-1;
            sket->nvar++;
        }
    }

    for (ivar = 0; ivar < sket->nvar; ivar++) {
        jpmtr = sket->ipmtr[ivar];
        jndex = sket->index[ivar];

        SPRINT3(1, "    -> creating  %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                MODL->pmtr[jpmtr].value[jndex]);
    }

    /* make the constraints */
    icount = 0;
    lentok = 0;
    index1 = 0;
    index2 = 0;
    for (i = 0; i < STRLEN(cons); i++) {
        if (cons[i] != ';') {
            token[lentok++] = cons[i];
            token[lentok  ] = '\0';
        } else {
            if        (icount%4 == 0) {
                strcpy(type, token);
            } else if (icount%4 == 1) {
                index1 = strtol(token, NULL, 10);
            } else if (icount%4 == 2) {
                index2 = strtol(token, NULL, 10);
            } else {
                strcpy(value, token);

                /* (recursivly) modify value if it contains "::L[", "::I[", "::R[", or "::S[" */
                while (strstr(value, "::L[") != NULL || strstr(value, "::I[") != NULL ||
                       strstr(value, "::R[") != NULL || strstr(value, "::S[") != NULL   ){

                    /* pull out the prefix */
                    prefix[0] = '\0';
                    ibeg      =   0 ;
                    for (ii = 0; ii < STRLEN(value); ii++) {
                        if (value[ii] == ':' && value[ii+1] == ':' && value[ii+3] == '[') {
                            if (value[ii+2] == 'L' || value[ii+2] == 'I' ||
                                value[ii+2] == 'R' || value[ii+2] == 'S'   ) {
                                if (ii > 0) {
                                    STRNCPY(prefix, value, ii);
                                    prefix[ii] = '\0';
                                }
                                ibeg = strtol(&(value[ii+4]), NULL, 10);
                                break;
                            }
                        }
                    }

                    /* check that argument was okay */
                    if (ibeg < 1 || ibeg > sket->size) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "::%c[%d] is not defined", value[ii+2], ibeg);
                        status = OCSM_ILLEGAL_VALUE;
                        goto cleanup;
                    } else if (ibeg < sket->size) {
                        iend = ibeg + 1;
                    } else {
                        iend = 1;
                    }

                    /* pull out the suffix */
                    suffix[0] = '\0';
                    for (jj = ii+3; jj < STRLEN(value); jj++) {
                        if (value[jj] == ']') {
                            strcpy(suffix, &(value[jj+1]));
                            break;
                        }
                    }

                    /* create the replacement text */
                    if        (value[ii+2] == 'L') {
                        snprintf(value, MAX_EXPR_LEN, "%shypot(::y[%d]-::y[%d],::x[%d]-::x[%d])%s",
                                 prefix, iend, ibeg, iend, ibeg, suffix);
                    } else if (value[ii+2] == 'I') {
                        snprintf(value, MAX_EXPR_LEN, "%satan2d(::y[%d]-::y[%d],::x[%d]-::x[%d])%s",
                                 prefix, iend, ibeg, iend, ibeg, suffix);
                    } else if (value[ii+2] == 'R') {
                        snprintf(value, MAX_EXPR_LEN, "%sradius(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])%s",
                                 prefix, ibeg, ibeg, iend, iend, iend, suffix);
                    } else if (value[ii+2] == 'S') {
                        snprintf(value, MAX_EXPR_LEN, "%ssweep(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])%s",
                                 prefix, ibeg, ibeg, iend, iend, iend, suffix);
                    }
                }

                if        (strcmp(type, "X") == 0 && index2 <= 0) {
                    sket->ctype[sket->ncon] = 'X';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::x[%d]-(%s)",
                             index1, value);
                } else if (strcmp(type, "X") == 0) {
                    sket->ctype[sket->ncon] = 'X';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "Xcent(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                             index1, index1, index2, index2, index2, value);
                } else if (strcmp(type, "Y") == 0 && index2 <= 0) {
                    sket->ctype[sket->ncon] = 'Y';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::y[%d]-(%s)",
                             index1, value);
                } else if (strcmp(type, "Y") == 0) {
                    sket->ctype[sket->ncon] = 'Y';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "Ycent(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                             index1, index1, index2, index2, index2, value);
                } else if (strcmp(type, "P") == 0) {
                    sket->ctype[sket->ncon] = 'P';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                    ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "(abs(turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d]))-90)/57.3",
                             im1, im1, index1, index1, index1, ip1, ip1, ip1);
                } else if (strcmp(type, "T") == 0) {
                    sket->ctype[sket->ncon] = 'T';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                    ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])/57.3",
                             im1, im1, index1, index1, index1, ip1, ip1, ip1);
                } else if (strcmp(type, "A") == 0) {
                    sket->ctype[sket->ncon] = 'A';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                    ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "(turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s))/57.3",
                             im1, im1, index1, index1, index1, ip1, ip1, ip1, value);
                } else if (strcmp(type, "Z") == 0) {
                    sket->ctype[sket->ncon] = 'Z';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    if        (index2 == -2) {
                        snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                                 "::x[%d]-::x[%d]",
                                 index1, index1+1);
                    } else if (index2 == -3) {
                        snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                                 "::y[%d]-::y[%d]",
                                 index1-1, index1);
                    }
                } else if (strcmp(type, "W") == 0) {
                    sket->ctype[sket->ncon] = 'W';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::x[%d]-::x[%d]-(%s)",
                             index2, index1, value);
                } else if (strcmp(type, "D") == 0) {
                    sket->ctype[sket->ncon] = 'D';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::y[%d]-::y[%d]-(%s)",
                             index2, index1, value);
                } else if (strcmp(type, "H") == 0) {
                    sket->ctype[sket->ncon] = 'H';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::y[%d]-::y[%d]",
                             index1, index2);
                } else if (strcmp(type, "V") == 0) {
                    sket->ctype[sket->ncon] = 'V';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::x[%d]-::x[%d]",
                             index1, index2);
                } else if (strcmp(type, "I") == 0) {
                    sket->ctype[sket->ncon] = 'I';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "(atan2d(::y[%d]-::y[%d],::x[%d]-::x[%d])-(%s))/57.3",
                             index2, index1, index2, index1, value);
                } else if (strcmp(type, "L") == 0) {
                    sket->ctype[sket->ncon] = 'L';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "hypot(::y[%d]-::y[%d],::x[%d]-::x[%d])-(%s)",
                             index1, index2, index1, index2, value);
                } else if (strcmp(type, "R") == 0) {
                    sket->ctype[sket->ncon] = 'R';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "radius(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                             index1, index1, index2, index2, index2, value);
                } else if (strcmp(type, "S") == 0) {
                    sket->ctype[sket->ncon] = 'S';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "smallang(sweep(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s))/57.3",
                             index1, index1, index2, index2, index2, value);
                }
            }

            icount++;
            lentok = 0;
        }
    }

    /* check that number of constraints matches number of variables */
    if        (sket->nvar > sket->ncon) {
        status = fixSketch(sket, vars_in, cons_mod);
        CHECK_STATUS(fixSketch);

        if (STRLEN(cons_mod) > 0) {
            strcpy(vars_out, cons_mod);
        } else {
            signalError(MODL, OCSM_SINGULAR_MATRIX,
                        "under-constrained since nvar=%d but ncon=%d", sket->nvar, sket->ncon);
        }
        goto removeTemps;
    } else if (sket->nvar < sket->ncon) {
        status = fixSketch(sket, vars_in, cons_mod);
        CHECK_STATUS(fixSketch);

        if (STRLEN(cons_mod) > 0) {
            strcpy(vars_out, cons_mod);
        } else {
            signalError(MODL, OCSM_SINGULAR_MATRIX,
                        "over-constrained since nvar=%d but ncon=%d", sket->nvar, sket->ncon);
        }
        goto removeTemps;
    }

    /* try to solve the sketch */
    status = solveSketch(MODL, sket);

    /* if solver fails, simply return nvar=0 */
    if (status == OCSM_SINGULAR_MATRIX) {
        status = fixSketch(sket, vars_in, cons_mod);
        CHECK_STATUS(fixSketch);

        if (STRLEN(cons_mod) > 0) {
            strcpy(vars_out, cons_mod);
        } else {
            signalError(MODL, OCSM_SINGULAR_MATRIX,
                        "constraints are not independent");
        }
        goto removeTemps;
    } else if (status < SUCCESS) {
        goto removeTemps;
    }

    /* solver succeeded, so write the new variables */
    for (ivar = 0; ivar < nvar; ivar++) {
        snprintf(token, MAX_EXPR_LEN, "%.6lf;%.6lf;%.6lf;",
                 MODL->pmtr[sket->ix].value[ivar],
                 MODL->pmtr[sket->iy].value[ivar],
                 MODL->pmtr[sket->id].value[ivar]);
        strcat(vars_out, token);
    }

removeTemps:
    /* remove ::x[], ::y[], ::z[], and ::d[] if they were generated by a skvar statement */
    if (sket->nvar > 0) {
        status = delPmtrByName(MODL, "::d");
        if (status != OCSM_NAME_NOT_FOUND) {
            CHECK_STATUS(delPmtrByName);
        }

        status = delPmtrByName(MODL, "::z");
        if (status != OCSM_NAME_NOT_FOUND) {
            CHECK_STATUS(delPmtrByName);
        }

        status = delPmtrByName(MODL, "::y");
        if (status != OCSM_NAME_NOT_FOUND) {
            CHECK_STATUS(delPmtrByName);
        }

        status = delPmtrByName(MODL, "::x");
        if (status != OCSM_NAME_NOT_FOUND) {
            CHECK_STATUS(delPmtrByName);
        }
    }

cleanup:
    FREE(sket);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSaveSketch - overwrite Branches associated with a Sketch       *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSaveSketch(void   *modl,            /* (in)  pointer to MODL */
               int    ibrch,            /* (in)  Branch index (1-nbrch) within Sketch */
               char   vars[],           /* (in)  string with Sketch variables */
               char   cons[],           /* (in)  string with Sketch constraints */
               char   segs[])           /* (in)  string with Sketch segments */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iskbeg, iskend, jbrch, iafter, icon, ncon, iseg, nseg, i, irel;
    double    value, dot;
    char      *arg1=NULL, *arg2=NULL, *arg3=NULL, *arg4=NULL, *arg5=NULL, *arg6=NULL;
    char      str[MAX_STRVAL_LEN];

    ROUTINE(ocsmSaveSketch);

    /* --------------------------------------------------------------- */

    if (outLevel >= 2) {
        SPRINT0(2, "ocsmSaveSketch: at beginning");
        status = ocsmPrintBrchs(MODL, stdout);
        CHECK_STATUS(ocsmPrintBrchs);
    }

    MALLOC(arg1, char, MAX_EXPR_LEN);
    MALLOC(arg2, char, MAX_EXPR_LEN);
    MALLOC(arg3, char, MAX_EXPR_LEN);
    MALLOC(arg4, char, MAX_EXPR_LEN);
    MALLOC(arg5, char, MAX_EXPR_LEN);
    MALLOC(arg6, char, MAX_EXPR_LEN);

    if        (MODL->brch[ibrch].type == OCSM_SKBEG) {
        iskbeg = ibrch;
        iskend = ibrch + 1;
    } else if (MODL->brch[ibrch].type == OCSM_SKEND) {
        iskbeg = ibrch - 1;
        iskend = ibrch;
    } else {
        iskbeg = ibrch;
        iskend = ibrch;
    }

    /* find SKBEG at or before ibrch */
    while (iskbeg > 0 && MODL->brch[iskbeg].type != OCSM_SKBEG) {
        if (MODL->brch[iskbeg].type == OCSM_SKEND) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (SKEND found first)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
        iskbeg--;
        if (iskbeg <= 0) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (at beginning)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
    }

    /* find SKEND at or after ibrch */
    while (iskend <= MODL->nbrch && MODL->brch[iskend].type != OCSM_SKEND) {
        if (MODL->brch[iskend].type == OCSM_SKBEG) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (SKBEG found first)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
        iskend++;
        if (iskend <= 0) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (at end)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
    }

    iafter = iskbeg;

    /* determine the number of constraints */
    ncon = 0;
    for (i = 0; i < STRLEN(cons); i++) {
        if (cons[i] == ';') ncon++;
    }
    ncon /= 4;

    /* determine the number of segments */
    nseg = 0;
    for (i = 0; i < STRLEN(segs); i++) {
        if (segs[i] == ';') nseg++;
    }
    nseg /= 3;

    /* delete the Branches between the SKBEG and the SKEND */
    for (jbrch = iskend-1; jbrch > iskbeg; jbrch--) {
        status = ocsmDelBrch(MODL, jbrch);
        CHECK_STATUS(ocsmDelBrch);
    }

    /* determine if Sketch is absolute or relative */
    value = 0;
    dot   = 0;
    status = str2val(MODL->brch[iskbeg].arg4, MODL, &value, &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "sketch type cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    irel = NINT(value);

    /* add the SKVAR Branch */
    status = ocsmNewBrch(MODL, iafter++, OCSM_SKVAR, "", -1,
                         "$xy", vars, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    CHECK_STATUS(ocsmNewBrch);

    /* add the SKCON Branches */
    for (icon = 0; icon < ncon; icon++) {
        arg1[0] = '$';
        arg4[0] = '$';
        getToken(cons, 4*icon  , ';', MAX_EXPR_LEN, &(arg1[1]));
        getToken(cons, 4*icon+1, ';', MAX_EXPR_LEN,  arg2    );
        getToken(cons, 4*icon+2, ';', MAX_EXPR_LEN,  arg3    );
        getToken(cons, 4*icon+3, ';', MAX_EXPR_LEN, &(arg4[1]));

        status = ocsmNewBrch(MODL, iafter++, OCSM_SKCON, "", -1,
                             arg1, arg2, arg3, arg4, NULL, NULL, NULL, NULL, NULL);
        CHECK_STATUS(ocsmNewBrch);
    }

    /* add the LINSEG, ARC, SPLINE, and BEZIER Branches */
    for (iseg = 0; iseg < nseg; iseg++) {
        getToken(segs, 3*iseg,   ';', MAX_EXPR_LEN, arg1);
        getToken(segs, 3*iseg+2, ';', MAX_EXPR_LEN, arg6);

        if (irel == 0) {
            snprintf(arg2, MAX_EXPR_LEN, "::x[%s]", arg6);
            snprintf(arg3, MAX_EXPR_LEN, "::y[%s]", arg6);
            snprintf(arg4, MAX_EXPR_LEN, "::z[%s]", arg6);
            snprintf(arg5, MAX_EXPR_LEN, "::d[%s]", arg6);
        } else {
            snprintf(arg2, MAX_EXPR_LEN, "::x[%s]", arg6);
            snprintf(arg3, MAX_EXPR_LEN, "::y[%s]", arg6);
            snprintf(arg4, MAX_EXPR_LEN, "0"            );
            snprintf(arg5, MAX_EXPR_LEN, "::d[%s]", arg6);
        }

        if        (arg1[0] == 'L') {
            status = ocsmNewBrch(MODL, iafter++, OCSM_LINSEG, "", -1,
                                 arg2, arg3, arg4, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);
        } else if (arg1[0] == 'C') {
            strcpy(arg6, "$xy");
            status = ocsmNewBrch(MODL, iafter++, OCSM_ARC, "", -1,
                                 arg2, arg3, arg4, arg5, arg6, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);
        } else if (arg1[0] == 'S') {
            status = ocsmNewBrch(MODL, iafter++, OCSM_SPLINE, "", -1,
                                 arg2, arg3, arg4, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);
        } else if (arg1[0] == 'B') {
            status = ocsmNewBrch(MODL, iafter++, OCSM_BEZIER, "", -1,
                                 arg2, arg3, arg4, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);
        }
    }

    if (outLevel >= 2) {
        SPRINT0(2, "ocsmSaveSketch: after additions");
        status = ocsmPrintBrchs(MODL, stdout);
        CHECK_STATUS(ocsmPrintBrchs);
    }

cleanup:
    FREE(arg6);
    FREE(arg5);
    FREE(arg4);
    FREE(arg3);
    FREE(arg2);
    FREE(arg1);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmNewPmtr - create a new Parameter                               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmNewPmtr(void   *modl,               /* (in)  pointer to MODL */
            char   name[],              /* (in)  Parameter name */
            int    type,                /* (in)  Parameter type */
            int    nrow,                /* (in)  number of rows */
            int    ncol)                /* (in)  number of columns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ipmtr, i, irow, icol, indx;
    int       resize=0;

    ROUTINE(ocsmNewPmtr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if an UNKNOWN, default to INTERNAL unless it already exists as another type */
    if (type == OCSM_UNKNOWN) {
        type = OCSM_INTERNAL;
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, name) == 0) {
                type = MODL->pmtr[ipmtr].type;
                break;
            }
        }
    }

    /* if a CONSTANT then nrow and ncol must both be 1 */
    if (type == OCSM_CONSTANT) {
        if (nrow != 1 || ncol != 1) {
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        }
    }

    /* if a CONSTANT, EXTERNAL, or CONFIG remove any INTERNAL Parameters
       that might already exist (from a previous ocsmBuild) */
    if (type == OCSM_CONSTANT || type == OCSM_EXTERNAL || type == OCSM_CONFIG) {
        for (ipmtr = MODL->npmtr; ipmtr > 0; ipmtr--) {
            if (MODL->pmtr[ipmtr].type == OCSM_INTERNAL) {
                status = ocsmDelPmtr(MODL, ipmtr);
                CHECK_STATUS(ocsmDelPmtr);
            }
        }
    }

    /* check if an OUTPUT Parameter already exists */
    if (type == OCSM_OUTPUT) {
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, name) == 0 &&
                MODL->pmtr[ipmtr].type == OCSM_OUTPUT       ) {
                resize = ipmtr;
                break;
            }
        }

    /* check if pmtrName is already defined at this scope */
    } else {
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, name) == 0                 &&
                MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                if (type == OCSM_INTERNAL && MODL->pmtr[ipmtr].nrow == nrow
                                          && MODL->pmtr[ipmtr].ncol == ncol) {
                    status = SUCCESS;
                } else if (type == OCSM_INTERNAL) {
                    resize = ipmtr;
                    break;
                } else {
                    status = OCSM_NAME_ALREADY_DEFINED;
                }
                goto cleanup;
            }
        }
    }

    /* check that pmtrName is a valid name */
    if (STRLEN(name) == 0 || STRLEN(name) >= MAX_NAME_LEN) {
        status = OCSM_ILLEGAL_PMTR_NAME;
        goto cleanup;
    } else if (name[0] == '@') {
    } else if (isalpha(name[0]) == 0 && name[0] != ':') {
        status = OCSM_ILLEGAL_PMTR_NAME;
        goto cleanup;
    } else {
        for (i = 1; i < STRLEN(name); i++) {
            if        (isalpha(name[i]) != 0) {
            } else if (isdigit(name[i]) != 0) {
            } else if (name[i] == '_') {
            } else if (name[i] == '@') {
            } else if (name[i] == ':') {
            } else {
                status = OCSM_ILLEGAL_PMTR_NAME;
                goto cleanup;
            }
        }
    }

    /* check for a valid Parameter type */
    if (type != OCSM_EXTERNAL && type != OCSM_CONFIG  &&type != OCSM_OUTPUT  &&
        type != OCSM_INTERNAL && type != OCSM_CONSTANT                         ) {
        status = OCSM_ILLEGAL_TYPE;
        goto cleanup;
    }

    /* extend the Parameter list (if needed) */
#ifndef __clang_analyzer__
    if (MODL->npmtr >= MODL->mpmtr) {
        MODL->mpmtr += 25;
        RALLOC(MODL->pmtr, pmtr_T, MODL->mpmtr+1);

        for (ipmtr = MODL->npmtr+1; ipmtr <= MODL->mpmtr; ipmtr++) {
            MODL->pmtr[ipmtr].name  = NULL;
            MODL->pmtr[ipmtr].value = NULL;
            MODL->pmtr[ipmtr].dot   = NULL;
            MODL->pmtr[ipmtr].lbnd  = NULL;
            MODL->pmtr[ipmtr].ubnd  = NULL;
            MODL->pmtr[ipmtr].str   = NULL;
        }
    }
#endif

    /* create the new Parameter */
    if (resize == 0) {
        MODL->npmtr += 1;
        ipmtr = MODL->npmtr;

    /* or resize existing Parameter */
    } else {
        ipmtr = resize;
    }

    /* store its name and defn */
    FREE(   MODL->pmtr[ipmtr].name);
    MALLOC( MODL->pmtr[ipmtr].name, char, (int)(STRLEN(name)+1));
    STRNCPY(MODL->pmtr[ipmtr].name, name,       STRLEN(name)+1 );

    FREE(MODL->pmtr[ipmtr].value);
    FREE(MODL->pmtr[ipmtr].dot  );
    FREE(MODL->pmtr[ipmtr].lbnd );
    FREE(MODL->pmtr[ipmtr].ubnd );
    FREE(MODL->pmtr[ipmtr].str  );

    if (nrow > 0 && ncol > 0) {
        MALLOC(MODL->pmtr[ipmtr].value, double, nrow*ncol);
        MALLOC(MODL->pmtr[ipmtr].dot,   double, nrow*ncol);

        if (type == OCSM_EXTERNAL || type == OCSM_CONFIG) {
            MALLOC(MODL->pmtr[ipmtr].lbnd,  double, nrow*ncol);
            MALLOC(MODL->pmtr[ipmtr].ubnd,  double, nrow*ncol);
        }
    } else {
        MALLOC( MODL->pmtr[ipmtr].str,   char,   MAX_STRVAL_LEN);

        nrow = 0;
        ncol = 0;
    }

    MODL->pmtr[ipmtr].scope = MODL->scope[MODL->level];
    MODL->pmtr[ipmtr].type  = type;
    MODL->pmtr[ipmtr].nrow  = nrow;
    MODL->pmtr[ipmtr].ncol  = ncol;

    /* set default values, lower and upper Bounds */
    indx = 0;
    for (irow = 0; irow < nrow; irow++) {
        for (icol = 0; icol < ncol; icol++) {
            MODL->pmtr[ipmtr].value[indx] = -HUGEQ;
            MODL->pmtr[ipmtr].dot[  indx] = 0;

            if (type == OCSM_EXTERNAL || type == OCSM_CONFIG) {
                MODL->pmtr[ipmtr].lbnd[ indx] = -HUGEQ;
                MODL->pmtr[ipmtr].ubnd[ indx] = +HUGEQ;
            }
            indx++;
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmDelPmtr - delete a Parameter                                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmDelPmtr(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr)               /* (in)  Parameter index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jpmtr;

    ROUTINE(ocsmDelPmtr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr is given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    /* remove data associated with this Parameter */
    FREE(MODL->pmtr[ipmtr].name );
    FREE(MODL->pmtr[ipmtr].value);
    FREE(MODL->pmtr[ipmtr].dot  );
    FREE(MODL->pmtr[ipmtr].lbnd );
    FREE(MODL->pmtr[ipmtr].ubnd );
    FREE(MODL->pmtr[ipmtr].str  );

    /* move all Parameters up to write over deleted Parameter */
    for (jpmtr = ipmtr; jpmtr < MODL->npmtr; jpmtr++) {
        MODL->pmtr[jpmtr].name  = MODL->pmtr[jpmtr+1].name;
        MODL->pmtr[jpmtr].type  = MODL->pmtr[jpmtr+1].type;
        MODL->pmtr[jpmtr].scope = MODL->pmtr[jpmtr+1].scope;
        MODL->pmtr[jpmtr].nrow  = MODL->pmtr[jpmtr+1].nrow;
        MODL->pmtr[jpmtr].ncol  = MODL->pmtr[jpmtr+1].ncol;
        MODL->pmtr[jpmtr].value = MODL->pmtr[jpmtr+1].value;
        MODL->pmtr[jpmtr].dot   = MODL->pmtr[jpmtr+1].dot;
        MODL->pmtr[jpmtr].lbnd  = MODL->pmtr[jpmtr+1].lbnd;
        MODL->pmtr[jpmtr].ubnd  = MODL->pmtr[jpmtr+1].ubnd;
        MODL->pmtr[jpmtr].str   = MODL->pmtr[jpmtr+1].str;
    }

    /* null pointers associated with last Parameter (since they were
       copied down) */
    MODL->pmtr[MODL->npmtr].name  = NULL;
    MODL->pmtr[MODL->npmtr].value = NULL;
    MODL->pmtr[MODL->npmtr].dot   = NULL;
    MODL->pmtr[MODL->npmtr].lbnd  = NULL;
    MODL->pmtr[MODL->npmtr].ubnd  = NULL;
    MODL->pmtr[MODL->npmtr].str   = NULL;

    /* decrement the number of Parameters */
    (MODL->npmtr)--;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmFindPmtr - find (or create) a Parameter                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmFindPmtr(void   *modl,              /* (in)  pointer to MODL */
             char   name[],             /* (in)  Parameter name */
             int    type,               /* (in)  Parameter type */
             int    nrow,               /* (in)  number of rows */
             int    ncol,               /* (in)  number of columns */
             int    *ipmtr)             /* (out) Parameter index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jpmtr;

    ROUTINE(ocsmFindPmtr);

    /* --------------------------------------------------------------- */

    *ipmtr = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check if name is already defined at this level */
    for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
        if (strcmp(MODL->pmtr[jpmtr].name, name) == 0                 &&
                   MODL->pmtr[jpmtr].scope == MODL->scope[MODL->level]  ) {

            if (type == MODL->pmtr[jpmtr].type &&
                nrow <= MODL->pmtr[jpmtr].nrow &&
                ncol <= MODL->pmtr[jpmtr].ncol   ) {
                *ipmtr = jpmtr;
                goto cleanup;
            } else {
                status = OCSM_NAME_ALREADY_DEFINED;
                goto cleanup;
            }
        }
    }

    /* if we got here, create a new Parameter */
    status = ocsmNewPmtr(MODL, name, type, nrow, ncol);
    CHECK_STATUS(ocsmNewPmtr);

    *ipmtr = MODL->npmtr;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetPmtr - get info about a Parameter                           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetPmtr(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1-npmtr) */
            int    *type,               /* (out) Parameter type */
            int    *nrow,               /* (out) number of rows */
            int    *ncol,               /* (out) number of columns */
            char   name[])              /* (out) Parameter name (at least MAX_NAME_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetPmtr);

    /* --------------------------------------------------------------- */

    /* default return values */
    name[0] = '\0';
    *type   = 0;
    *nrow   = 0;
    *ncol   = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr is given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    /* return the name, type, and size */
    STRNCPY(name, MODL->pmtr[ipmtr].name, MAX_NAME_LEN);
    *type  =      MODL->pmtr[ipmtr].type;
    *nrow  =      MODL->pmtr[ipmtr].nrow;
    *ncol  =      MODL->pmtr[ipmtr].ncol;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintPmtrs - print external Parameters to file                 *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintPmtrs(void   *modl,            /* (in)  pointer to MODL */
               FILE   *fp)              /* (in)  pointer to FILE */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ipmtr, maxlen, irow, icol, index, count;

    ROUTINE(ocsmPrintPmtrs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* find maximum name length */
    maxlen = 0;
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (STRLEN(MODL->pmtr[ipmtr].name) > maxlen) {
            maxlen = STRLEN(MODL->pmtr[ipmtr].name);
        }
    }

    /* loop through all constant Parameters and print its name and value */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  == OCSM_CONSTANT) {
            fprintf(fp, "    %5d [c]  %-*s            %11.5f\n",
                    ipmtr, maxlen, MODL->pmtr[ipmtr].name, MODL->pmtr[ipmtr].value[0]);
        }
    }

    /* loop through all EXTERNAL nad CONFIG  Parameters and print its name, value, and defn */
    count = 0;
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL) {
            index = 0;
            for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    fprintf(fp, "    %5d [e]  %-*s  [%3d,%3d] %11.5f %11.5f    >>",
                            ipmtr, maxlen, MODL->pmtr[ipmtr].name,
                            irow, icol, MODL->pmtr[ipmtr].value[index],
                                        MODL->pmtr[ipmtr].dot[  index]);

                    if (MODL->pmtr[ipmtr].lbnd[index] <= -HUGEQ) {
                        fprintf(fp, " unbounded  << ");
                    } else {
                        fprintf(fp, "%11.5f << ", MODL->pmtr[ipmtr].lbnd[ index]);
                    }

                    if (MODL->pmtr[ipmtr].ubnd[index] >= +HUGEQ) {
                        fprintf(fp, " unbounded \n");
                    } else {
                        fprintf(fp, "%11.5f\n",   MODL->pmtr[ipmtr].ubnd[ index]);
                    }

                    index++;
                }
            }
            count++;
        } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG) {
            fprintf(fp, "    %5d [f]  %-*s  [%3d,%3d] %11.5f\n",
                    ipmtr, maxlen, MODL->pmtr[ipmtr].name,
                    1, 1, MODL->pmtr[ipmtr].value[0]);
            count++;
        }
    }

    /* return message if no Paramaters */
    if (count <= 0) {
        fprintf(fp, "    --none--\n");
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetValu - get the Value of a Parameter                         *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetValu(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1-npmtr) */
            int    irow,                /* (in)  row    index (1-nrow) */
            int    icol,                /* (in)  column index (1-ncol) */
            double *value,              /* (out) Parameter value */
            double *dot)                /* (out) Parameter velocity */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index;

    ROUTINE(ocsmGetValu);

    /* --------------------------------------------------------------- */

    /* default return values */
    *value = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].str != NULL) {
        status = OCSM_WRONG_PMTR_TYPE;
        goto cleanup;
    }

    if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* return pertinent information */
    *value = MODL->pmtr[ipmtr].value[index];
    *dot   = MODL->pmtr[ipmtr].dot[  index];

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetValuS - get the Value of a string Parameter                 *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetValuS(void   *modl,              /* (in)  pointer to MODL */
             int    ipmtr,              /* (in)  Parameter index (1-npmtr) */
             char   str[])              /* (out) Parameter value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetValuS);

    /* --------------------------------------------------------------- */

    /* default return values */
    str[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr is given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    /* return pertinent information */
    STRNCPY(str, MODL->pmtr[ipmtr].str, MAX_STRVAL_LEN);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetValu - set a Value for a Parameter                          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetValu(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1-npmtr) */
            int    irow,                /* (in)  row    index (1-nrow) */
            int    icol,                /* (in)  column index (1-nrow) or 0 for index */
            char   defn[])              /* (in)  definition of Value */
{
    int       status = SUCCESS;         /* (out) return status */

    int       index;
    double    value, dot;
    char      str[MAX_STRVAL_LEN];

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetValu);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPUT) {

    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    status = str2val(defn, MODL, &value, &dot, str);
    CHECK_STATUS(str2val);

    /* special treatment for string values */
    if (STRLEN(str) > 0) {

        /* make sure row and column are both zero */
        if (irow != 1 || icol != 1) {
            status = OCSM_WRONG_PMTR_TYPE;
            goto cleanup;
        }

        /* if not a string, make it so now */
        if (MODL->pmtr[ipmtr].str == NULL) {
            FREE(MODL->pmtr[ipmtr].value);
            FREE(MODL->pmtr[ipmtr].dot  );
            FREE(MODL->pmtr[ipmtr].lbnd );
            FREE(MODL->pmtr[ipmtr].ubnd );
        }

        FREE(   MODL->pmtr[ipmtr].str);
        MALLOC( MODL->pmtr[ipmtr].str, char, MAX_STRVAL_LEN);
        STRNCPY(MODL->pmtr[ipmtr].str, str,  MAX_STRVAL_LEN);

        MODL->pmtr[ipmtr].nrow = 0;
        MODL->pmtr[ipmtr].ncol = 0;

        goto cleanup;

    /* treatment for numbers */
    } else if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* evaluate the definition */
    if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL ||
        MODL->pmtr[ipmtr].type == OCSM_CONFIG   ||
        MODL->pmtr[ipmtr].type == OCSM_CONSTANT   ) {
        status = str2val(defn, NULL, &value, &dot, str);
        CHECK_STATUS(str2val);
    } else {
        status = str2val(defn, MODL, &value, &dot, str);
        CHECK_STATUS(str2val);
    }

    /* make sure new value is in bounds */
    if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL ||
        MODL->pmtr[ipmtr].type == OCSM_CONFIG     ) {
        if (value < MODL->pmtr[ipmtr].lbnd[index] ||
            value > MODL->pmtr[ipmtr].ubnd[index]   ) {
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        }
    }

    /* set pertinent information */
    MODL->pmtr[ipmtr].value[index] = value;
    MODL->pmtr[ipmtr].dot[  index] = 0;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetValuD - set a (double) Value for a Parameter                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetValuD(void   *modl,              /* (in)  pointer to MODL */
             int    ipmtr,              /* (in)  Parameter index (1-npmtr) */
             int    irow,               /* (in)  row    index (1-nrow) */
             int    icol,               /* (in)  column index (1-nrow) or 0 for index */
             double value)              /* (in)  vlaue to set */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index;

    ROUTINE(ocsmSetValuD);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type  == OCSM_OUTPUT) {

    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* make sure new value is in bounds */
    if (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL ||
        MODL->pmtr[ipmtr].type == OCSM_CONFIG     ) {
        if (value < MODL->pmtr[ipmtr].lbnd[index] ||
            value > MODL->pmtr[ipmtr].ubnd[index]   ) {
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        }
    }

    /* set pertinent information */
    MODL->pmtr[ipmtr].value[index] = value;
    MODL->pmtr[ipmtr].dot[  index] = 0;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetBnds - get the Bounds of a Parameter                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetBnds(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1-npmtr) */
            int    irow,                /* (in)  row    index (1-nrow) */
            int    icol,                /* (in)  column index (1-ncol) */
            double *lbound,             /* (out) lower Bound */
            double *ubound)             /* (out) upper Bound */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index;

    ROUTINE(ocsmGetBnds);

    /* --------------------------------------------------------------- */

    /* default return values */
    *lbound = -HUGEQ;
    *ubound = +HUGEQ;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* return pertinent information */
    *lbound = MODL->pmtr[ipmtr].lbnd[index];
    *ubound = MODL->pmtr[ipmtr].ubnd[index];

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetBnds - set the Bounds of a Parameter                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetBnds(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1-npmtr) */
            int    irow,                /* (in)  row    index (1-nrow) */
            int    icol,                /* (in)  column index (1-ncol) */
            double lbound,              /* (in)  lower Bound to set */
            double ubound)              /* (in)  upper Bound to set */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index;

    ROUTINE(ocsmGetBnds);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that lower bound is not greater than upper bound */
    if (lbound > ubound) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* check that ipmtr is an EXTERNAL parameter */
    if (MODL->pmtr[ipmtr].type != OCSM_EXTERNAL) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    /* check that current value will be in proposed bounds */
    if (MODL->pmtr[ipmtr].value[index] < lbound ||
        MODL->pmtr[ipmtr].value[index] > ubound   ) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* set the bounds */
    MODL->pmtr[ipmtr].lbnd[index] = lbound;
    MODL->pmtr[ipmtr].ubnd[index] = ubound;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetDtime - set sensitivity FD time step (or select analytic)   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetDtime(void   *modl,              /* (in)  pointer to MODL */
             double dtime)              /* (in)  time step (or 0 to choose analytic) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetDtime);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* store the initial dtime */
    MODL->dtime = dtime;

    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* if dtime!=0, then make a perturbation, starting at the givem dtime */
    if (dtime != 0) {
        status = createPerturbation(MODL);
        CHECK_STATUS(createPerturbation);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetVel - set a velocity for a Parameter                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetVel(void   *modl,                /* (in)  pointer to MODL */
           int    ipmtr,                /* (in)  Parameter index (1-npmtr) or 0 for all */
           int    irow,                 /* (in)  row    index (1-nrow)     or 0 for all */
           int    icol,                 /* (in)  column index (1-nrow)     or 0 for index */
           char   defn[])               /* (in)  definition of Velocity */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index, jpmtr;
    double    dot, dum;
    char      str[MAX_STRVAL_LEN];

    ROUTINE(ocsmSetVel);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr == 0) {
        if (irow != 0 || icol != 0) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }
    } else if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPUT) {

    } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    if (ipmtr > 0) {
        if (icol == 0) {
            if (irow < 0 || irow > MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol) {
                status = OCSM_ILLEGAL_PMTR_INDEX;
                goto cleanup;
            }
        } else if (irow < 0 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* reset dtime so we try analytical derivative next time
       (unless the user calls ocsmSetDtime) */
    MODL->dtime = 0;

    /* evaluate the definition */
    dot = 0;

    status = str2val(defn, NULL, &dot, &dum, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        status = OCSM_WRONG_PMTR_TYPE;
        goto cleanup;
    }

    /* set velocities on the Parameters */
    if (ipmtr == 0) {
        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            for (index = 0; index < MODL->pmtr[jpmtr].nrow*MODL->pmtr[jpmtr].ncol; index++) {
                MODL->pmtr[jpmtr].dot[index] = dot;
            }
        }
    } else if (irow == 0 && icol == 0) {
        for (index = 0; index < MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol; index++) {
            MODL->pmtr[ipmtr].dot[index] = dot;
        }
    } else if (icol == 0) {
        index = irow - 1;
        MODL->pmtr[ipmtr].dot[index] = dot;
    } else {
        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
        MODL->pmtr[ipmtr].dot[index] = dot;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetVelD - set a double velocity for a Parameter                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetVelD(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1-npmtr) or 0 for all */
            int    irow,                /* (in)  row    index (1-nrow)     or 0 for all */
            int    icol,                /* (in)  column index (1-nrow)     or 0 for all */
            double dot)                 /* (in)  velocity to set */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index, jpmtr;

    ROUTINE(ocsmSetVelD);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr == 0) {
        if (irow != 0 || icol != 0) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }
    } else if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPUT) {

    } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    if (ipmtr > 0) {
        if (icol == 0) {
            if (irow < 0 || irow > MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol) {
                status = OCSM_ILLEGAL_PMTR_INDEX;
                goto cleanup;
            }
        } else if (irow < 0 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* set velocities on the Parameters */
    if (ipmtr == 0) {
        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            for (index = 0; index < MODL->pmtr[jpmtr].nrow*MODL->pmtr[jpmtr].ncol; index++) {
                MODL->pmtr[jpmtr].dot[index] = dot;
            }
        }
    } else if (irow == 0 && icol == 0) {
        for (index = 0; index < MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol; index++) {
            MODL->pmtr[ipmtr].dot[index] = dot;
        }
    } else if (icol == 0) {
        index = irow - 1;
        MODL->pmtr[ipmtr].dot[index] = dot;
    } else {
        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
        MODL->pmtr[ipmtr].dot[index] = dot;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetUV - get the parametric coordinates on an Edge or Face      *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetUV(void   *modl,                 /* (in)  pointer to MODL */
          int    ibody,                 /* (in)  Body index (bias-1) */
          int    seltype,               /* (in)  OCSM_EDGE or OCSM_FACE (bias-1) */
          int    iselect,               /* (in)  Edge of Face index (bias-1) */
          int    npnt,                  /* (in)  number of points */
/*@null@*/double xyz[],                 /* (in)  coordinates (NULL or 3*npnt in length) */
          double uv[])                  /* (out) para coords (1*npnt or 2*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iedge, iface, ipnt, npnt_tess, ntri_tess;
    CINT      *ptype, *pindx, *tris, *tric;
    double    pos[3], data[2], result[3];
    CDOUBLE   *xyz_tess, *uv_tess;

    ROUTINE(ocsmGetUV);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* OCSM_EDGE was prescribed */
    if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 0 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        if (xyz == NULL) {
            status = EG_getTessEdge(MODL->body[ibody].edge[iedge].eedge, iedge,
                                    &npnt_tess, &xyz_tess, &uv_tess);
            CHECK_STATUS(EG_getTessEdge);

            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                uv[ipnt] = uv_tess[ipnt];
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                pos[0] = xyz[3*ipnt  ];
                pos[1] = xyz[3*ipnt+1];
                pos[2] = xyz[3*ipnt+2];

                status = EG_invEvaluate(MODL->body[ibody].edge[iedge].eedge,
                                        pos, data, result);
                CHECK_STATUS(EG_invEvaluate);

                uv[ipnt] = data[0];
            }
        }

    /* OCSM_FACE was prescribed */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 0 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        if (xyz == NULL) {
            status = EG_getTessFace(MODL->body[ibody].face[iface].eface, iface,
                                    &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                    &ntri_tess, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                uv[2*ipnt  ] = uv_tess[2*ipnt  ];
                uv[2*ipnt+1] = uv_tess[2*ipnt+1];
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                pos[0] = xyz[3*ipnt  ];
                pos[1] = xyz[3*ipnt+1];
                pos[2] = xyz[3*ipnt+2];

                status = EG_invEvaluate(MODL->body[ibody].face[iface].eface,
                                        pos, data, result);
                CHECK_STATUS(EG_invEvaluate);

                uv[2*ipnt  ] = data[0];
                uv[2*ipnt+1] = data[1];
            }
        }

    /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetXYZ - get the coordinates on a Node, Edge, or Face          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetXYZ(void   *modl,                /* (in)  pointer to MODL */
           int    ibody,                /* (in)  Body index (bias-1) */
           int    seltype,              /* (in)  OCSM_NODE, OCSM_EDGE, or OCSM_FACE */
           int    iselect,              /* (in)  Node, Edge, or Face index (bias-1) */
           int    npnt,                 /* (in)  number of points */
 /*@null@*/double uv[],                 /* (in)  para coords (NULL, 1*npnt, or 2*npnt in length) */
           double xyz[])                /* (out) coordinates (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       inode, iedge, iface, ipnt, npnt_tess, ntri_tess;
    CINT      *ptype, *pindx, *tris, *tric;
    double    params[2], data[18];
    CDOUBLE   *xyz_tess, *uv_tess;

    ROUTINE(ocsmGetXYZ);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* OCSM_NODE was prescribed */
    if (seltype == OCSM_NODE) {
        inode = iselect;

        if (inode < 1 || inode > MODL->body[ibody].nnode) {
            status = OCSM_NODE_NOT_FOUND;
            goto cleanup;
        }

        xyz[0] = MODL->body[ibody].node[inode].x;
        xyz[1] = MODL->body[ibody].node[inode].y;
        xyz[2] = MODL->body[ibody].node[inode].z;

    /* OCSM_EDGE was prescribed */
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        if (uv == NULL) {
            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt_tess, &xyz_tess, &uv_tess);
            CHECK_STATUS(EG_getTessEdge);

            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                params[0] = uv_tess[ipnt];

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                     params, data);
                CHECK_STATUS(EG_evaluate);

                xyz[3*ipnt  ] = data[0];
                xyz[3*ipnt+1] = data[1];
                xyz[3*ipnt+2] = data[2];
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                params[0] = uv[ipnt];

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                     params, data);
                CHECK_STATUS(EG_evaluate);

                xyz[3*ipnt  ] = data[0];
                xyz[3*ipnt+1] = data[1];
                xyz[3*ipnt+2] = data[2];
            }
        }

    /* OCSM_FACE was prescribed */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 1 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        if (uv == NULL) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                    &ntri_tess, &tris, &tric);
            CHECK_STATUS(EG_getFaceTess);

            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                params[0] = uv_tess[2*ipnt  ];
                params[1] = uv_tess[2*ipnt+1];

                status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                     params, data);
                CHECK_STATUS(EG_evaluate);

                xyz[3*ipnt  ] = data[0];
                xyz[3*ipnt+1] = data[1];
                xyz[3*ipnt+2] = data[2];
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                params[0] = uv[2*ipnt  ];
                params[1] = uv[2*ipnt+1];

                status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                     params, data);
                CHECK_STATUS(EG_evaluate);

                xyz[3*ipnt  ] = data[0];
                xyz[3*ipnt+1] = data[1];
                xyz[3*ipnt+2] = data[2];
            }
        }

    /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetNorm - get the unit normals for a Face                      *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetNorm(void   *modl,               /* (in)  pointer to MODL */
            int    ibody,               /* (in)  Body index (bias-1) */
            int    iface,               /* (in)  Face index (bias-1) */
            int    npnt,                /* (in)  number of points */
  /*@null@*/double uv[],                /* (in)  para coords (NULL or 2*npnt in length) */
            double norm[])              /* (out) normals (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ipnt, oclass, mtype, nchild, *senses, npnt_tess, ntri_tess;
    CINT      *ptype, *pindx, *tris, *tric;
    double    uvlims[4], data[18], anorm[4];
    CDOUBLE   *uv_tess, *xyz_tess;
    ego       eref, *echilds;

    ROUTINE(ocsmGetNorm);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* check for valid Face */
    if (iface < 1 || iface > MODL->body[ibody].nface) {
        status = OCSM_FACE_NOT_FOUND;
        goto cleanup;
    }

    /* get info about eface */
    status = EG_getTopology(MODL->body[ibody].face[iface].eface, &eref,
                            &oclass, &mtype, uvlims, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    /* return normals at tessellation points */
    if (uv == NULL) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                &ntri_tess, &tris, &tric);
        CHECK_STATUS(EG_getFaceTess);

        for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
            status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                 &(uv_tess[2*ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            anorm[0] = data[4] * data[8] - data[5] * data[7];
            anorm[1] = data[5] * data[6] - data[3] * data[8];
            anorm[2] = data[3] * data[7] - data[4] * data[6];
            anorm[3] = mtype * sqrt(anorm[0]*anorm[0] + anorm[1]*anorm[1] + anorm[2]*anorm[2]);

            norm[3*ipnt  ] = anorm[0] / anorm[3];
            norm[3*ipnt+1] = anorm[1] / anorm[3];
            norm[3*ipnt+2] = anorm[2] / anorm[3];
        }

    /* return normals at specified points */
    } else {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                 &(uv[2*ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            anorm[0] = data[4] * data[8] - data[5] * data[7];
            anorm[1] = data[5] * data[6] - data[3] * data[8];
            anorm[2] = data[3] * data[7] - data[4] * data[6];
            anorm[3] = mtype * sqrt(anorm[0]*anorm[0] + anorm[1]*anorm[1] + anorm[2]*anorm[2]);

            norm[3*ipnt  ] = anorm[0] / anorm[3];
            norm[3*ipnt+1] = anorm[1] / anorm[3];
            norm[3*ipnt+2] = anorm[2] / anorm[3];
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetVel - get the velocities of coordinates on a Node, Edge, or Face *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetVel(void   *modl,                /* (in)  pointer to MODL */
           int    ibody,                /* (in)  Body index (bias-1) */
           int    seltype,              /* (in)  OCSM_NODE, OCSM_EDGE, or OCSM_FACE */
           int    iselect,              /* (in)  Node, Edge, or Face index (bias-1) */
           int    npnt,                 /* (in)  number of points */
 /*@null@*/double uv[],                 /* (in)  para coords
                                                    NULL           for OCSM_NODE
                                                    NULL or 1*npnt for OCSM_EDGE
                                                    NULL or 2*npnt for OCSM_FACE */
           double vel[])                /* (out) velocities (in pre-allocated array)
                                                    3      for OCSM_NODE
                                                    3*npnt for OCSM_EDGE
                                                    3*npnt for OCSM_FACE */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface, ipnt, npnt_tess, ntri_tess;
    CINT      *ptype, *pindx, *tris, *tric;
    double    *dxyz=NULL;
    double    params[2], data[18], TdotT, VdotT, normx, normy, normz, norm, dotp;
    CDOUBLE   *xyz_tess, *uv_tess;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetVel);

    /* --------------------------------------------------------------- */

    SPRINT3(2, "ocsmGetVel(ibody=%d, seltype=%s, iselect=%d)", ibody, ocsmGetText(seltype), iselect);

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* default return */
    vel[0] = 0;
    vel[1] = 0;
    vel[2] = 0;

    /* a tessellation is needed if an Edge or Face and uv is not given */
    if ((seltype == OCSM_EDGE || seltype == OCSM_FACE) &&
        uv == NULL && MODL->body[ibody].etess == NULL    ) {
        status = tessellate(MODL, ibody);
        CHECK_STATUS(tessellate);
    }

    status = checkForFiniteDifferences(MODL, ibody);
    CHECK_STATUS(checkForFiniteDifferences);

    /* if there was a problem with the previous attempt to create
       a perturbation, then return vel=0 */
    if (MODL->dtime == -2) {
        SPRINT0(2, "    returning vel=0 because there was a problem creating the perturbation");

        if        (seltype == OCSM_NODE) {
            vel[0] = 0;
            vel[1] = 0;
            vel[2] = 0;
        } else if (seltype == OCSM_EDGE) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                vel[3*ipnt  ] = 0;
                vel[3*ipnt+1] = 0;
                vel[3*ipnt+2] = 0;
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                vel[ipnt] = 0;
            }
        }
        goto cleanup;
    }

    /* OCSM_NODE was prescribed */
    if (seltype == OCSM_NODE) {
        inode = iselect;

        if (inode < 1 || inode > MODL->body[ibody].nnode) {
            status = OCSM_NODE_NOT_FOUND;
            goto cleanup;
        }

        if (npnt != 1) {
            status = OCSM_ILLEGAL_ARGUMENT;
            goto cleanup;
        }

        status = velocityOfNode(MODL, ibody, inode, vel);
        CHECK_STATUS(velocityOfNode);

    /* OCSM_EDGE was prescribed */
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        /* check for degenerate Edge */
        if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                vel[3*ipnt  ] = 0;
                vel[3*ipnt+1] = 0;
                vel[3*ipnt+2] = 0;
            }

            goto cleanup;
        }

        MALLOC(dxyz, double, 3*npnt);

        status = velocityOfEdge(MODL, ibody, iedge, npnt, uv, dxyz);
        CHECK_STATUS(velocityOfEdge);

        /* return normal component */
        if (uv != NULL) {
            uv_tess = uv;
        } else {
            if (MODL->body[ibody].etess == NULL) {
                status = OCSM_NEED_TESSELLATION;
                goto cleanup;
            }

            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt_tess, &xyz_tess, &uv_tess);
            CHECK_STATUS(EG_getTessEdge);

            if (npnt_tess != npnt) {
                status = OCSM_ILLEGAL_ARGUMENT;
                goto cleanup;
            }
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            params[0] = uv_tess[ipnt];
            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                 params, data);
            CHECK_STATUS(EG_evaluate);

            TdotT = data[       3] * data[3] + data[       4] * data[4] + data[       5] * data[5];
            VdotT = dxyz[3*ipnt  ] * data[3] + dxyz[3*ipnt+1] * data[4] + dxyz[3*ipnt+2] * data[5];

            if (fabs(TdotT) > EPS12) {
                vel[3*ipnt  ] = dxyz[3*ipnt  ] - VdotT * data[3] / TdotT;
                vel[3*ipnt+1] = dxyz[3*ipnt+1] - VdotT * data[4] / TdotT;
                vel[3*ipnt+2] = dxyz[3*ipnt+2] - VdotT * data[5] / TdotT;
            } else {
                vel[3*ipnt  ] = dxyz[3*ipnt  ];
                vel[3*ipnt+1] = dxyz[3*ipnt+1];
                vel[3*ipnt+2] = dxyz[3*ipnt+2];
            }
        }

    /* OCSM_FACE was prescribed */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 1 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        MALLOC(dxyz, double, 3*npnt);

        status = velocityOfFace(MODL, ibody, iface, npnt, uv, vel);
        CHECK_STATUS(velocityOfFace);

        /* return normal component */
        if (uv != NULL) {
            uv_tess = uv;
        } else {
            if (MODL->body[ibody].etess == NULL) {
                status = OCSM_NEED_TESSELLATION;
                goto cleanup;
            }

            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                    &ntri_tess, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            if (npnt_tess != npnt) {
                status = OCSM_ILLEGAL_ARGUMENT;
                goto cleanup;
            }
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            params[0] = uv_tess[2*ipnt  ];
            params[1] = uv_tess[2*ipnt+1];
            status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                 params, data);
            CHECK_STATUS(EG_evaluate);

            normx = data[4] * data[8] - data[5] * data[7];
            normy = data[5] * data[6] - data[3] * data[8];
            normz = data[3] * data[7] - data[4] * data[6];
            norm  = normx * normx         + normy * normy         + normz * normz;
            dotp  = normx * vel[3*ipnt  ] + normy * vel[3*ipnt+1] + normz * vel[3*ipnt+2];

            if (fabs(norm) > EPS12) {
                vel[3*ipnt  ] = normx / norm * dotp;
                vel[3*ipnt+1] = normy / norm * dotp;
                vel[3*ipnt+2] = normz / norm * dotp;
            }
        }

    /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    FREE(dxyz);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetEgg - set up alternative tessellation by external generator *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetEgg(void   *modl,                /* (in)  pointer to MODL */
           char   *eggname)             /* (in)  name of dynamically-loadable file */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nlen;
    char      *fullname=NULL;
    DLL       dll;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetEgg);

    /* --------------------------------------------------------------- */

    /* return immediately if not egg was specified */
    if (STRLEN(eggname) == 0) {
        goto cleanup;
    }

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* store the external grid genertor name */
    STRNCPY(MODL->eggname, eggname, MAX_FILENAME_LEN);

    /* open the dynamically loaded library */
    nlen = STRLEN(eggname) + 5;
    MALLOC(fullname, char, nlen);

    strcpy(fullname, eggname);
#ifdef WIN32
    strcat(fullname, ".DLL");
    dll = LoadLibrary(fullname);
#else
    strcat(fullname, ".so");
    dll = dlopen(fullname, RTLD_NOW /* RTLD_LAZY */);
#endif

    if (!dll) {
        signalError(MODL, OCSM_FILE_NOT_FOUND,
                    "DLL \"%s\" not found", fullname);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* get the symbols from the library */
#ifdef WIN32
    MODL->eggGenerate = (eggGenerate_H) GetProcAddress(dll, "eggGenerate");
    MODL->eggMorph    = (eggMorph_H   ) GetProcAddress(dll, "eggMorph"   );
    MODL->eggInfo     = (eggInfo_H    ) GetProcAddress(dll, "eggInfo"    );
    MODL->eggDump     = (eggDump_H    ) GetProcAddress(dll, "eggDump"    );
    MODL->eggLoad     = (eggLoad_H    ) GetProcAddress(dll, "eggLoad"    );
    MODL->eggFree     = (eggFree_H    ) GetProcAddress(dll, "eggFree"    );
#else
    MODL->eggGenerate = dlsym(dll, "eggGenerate");
    MODL->eggMorph    = dlsym(dll, "eggMorph"   );
    MODL->eggInfo     = dlsym(dll, "eggInfo"    );
    MODL->eggDump     = dlsym(dll, "eggDump"    );
    MODL->eggLoad     = dlsym(dll, "eggLoad"    );
    MODL->eggFree     = dlsym(dll, "eggFree"    );
#endif

    if        (MODL->eggGenerate == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggGenerate not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggMorph    == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggMorph not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggInfo     == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggInfo not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggDump     == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggDump not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggLoad     == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggLoad not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggFree     == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggFree not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    }

cleanup:
    FREE(fullname);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetTessVel - get the tessellation velocities on Node, Edge, or Face *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetTessVel(void   *modl,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (bias-1) */
               int    seltype,          /* (in)  OCSM_NODE, OCSM_EDGE, or OCSM_FACE */
               int    iselect,          /* (in)  Node, Edges, or face index (bias-1) */
               CDOUBLE *dxyz[])         /* (out) pointer to storage containing velocities */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetTessVel);

    /* --------------------------------------------------------------- */

    SPRINT3(2, "enter ocsmGetTessVel(ibody=%d, seltype=%s, iselect=%d)",
            ibody, ocsmGetText(seltype), iselect);

    /* default return */
    *dxyz = NULL;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    status = checkForFiniteDifferences(MODL, ibody);
    CHECK_STATUS(checkForFiniteDifferences);

    /* get tessellation velocities if not already in memory */
    if (MODL->body[ibody].node[1].dxyz == NULL) {
        status = createTessVels(MODL, ibody);
        CHECK_STATUS(createTessVels);
    }

    /* OCSM_NODE */
    if (seltype == OCSM_NODE) {
        inode = iselect;

        if (inode < 1 || inode > MODL->body[ibody].nnode) {
            status = OCSM_NODE_NOT_FOUND;
            goto cleanup;
        }

        *dxyz = MODL->body[ibody].node[inode].dxyz;

    /* OCSM_EDGE */
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        *dxyz = MODL->body[ibody].edge[iedge].dxyz;

    /* OCSM_FACE */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 1 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        *dxyz = MODL->body[ibody].face[iface].dxyz;

    /* bad seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetBody - get info about a Body                                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetBody(void   *modl,               /* (in)  pointer to MODL */
            int    ibody,               /* (in)  Body index (1-nbody) */
            int    *type,               /* (out) Branch type */
            int    *ichld,              /* (out) ibody of child (or 0 if root) */
            int    *ileft,              /* (out) ibody of left parent (or 0) */
            int    *irite,              /* (out) ibody of rite parent (or 0) */
            double vals[],              /* (out) array  of Arguments (at least 10 long) */
            int    *nnode,              /* (out) number of Nodes */
            int    *nedge,              /* (out) number of Edges */
            int    *nface)              /* (out) number of Faces */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ibrch, iarg;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetBody);

    /* --------------------------------------------------------------- */

    /* default return values */
    *type  = 0;
    *ichld = 0;
    *ileft = 0;
    *irite = 0;
    *nnode = 0;
    *nedge = 0;
    *nface = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    ibrch = MODL->body[ibody].ibrch;

    /* return pertinent information */
    *type   = MODL->body[ibody].brtype;
    *ichld  = MODL->body[ibody].ichld;
    *ileft  = MODL->body[ibody].ileft;
    *irite  = MODL->body[ibody].irite;

    vals[0] = 0;
    for (iarg = 1; iarg < 10; iarg++) {
        if (iarg <= MODL->brch[ibrch].narg) {
            vals[iarg] = MODL->body[ibody].arg[iarg].val[0];
        } else {
            vals[iarg] = 0;
        }
    }

    *nnode  = MODL->body[ibody].nnode;
    *nedge  = MODL->body[ibody].nedge;
    *nface  = MODL->body[ibody].nface;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintBodys - print all Bodys to file                           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintBodys(void   *modl,            /* (in)  pointer to MODL */
               FILE   *fp)              /* (in)  pointer to FILE */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ibody, iarg;
    double    CPU=0;

    ROUTINE(ocsmPrintBodys);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* return message if no Bodys */
    if (MODL->nbody <= 0) {
        fprintf(fp, "    --none--\n");
        goto cleanup;
    }

    /* print Body table */
    fprintf(fp, "    ibody  ibrch brchType  ileft irite ichld group      CPU nnode nedge nface   bodyType     args ...\n");
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        if (MODL->body[ibody].onstack == 1) {
            fprintf(fp, "    %5d*", ibody);
        } else {
            fprintf(fp, "    %5d ", ibody);
        }

        fprintf(fp, " %5d %-9s %5d %5d %5d %5d %8.3f %5d %5d %5d %10s ",
                MODL->body[ibody].ibrch,
                ocsmGetText(MODL->body[ibody].brtype),
                MODL->body[ibody].ileft,
                MODL->body[ibody].irite,
                MODL->body[ibody].ichld,
                MODL->body[ibody].igroup,
                MODL->body[ibody].CPU,
                MODL->body[ibody].nnode,
                MODL->body[ibody].nedge,
                MODL->body[ibody].nface,
                ocsmGetText(MODL->body[ibody].botype));

        for (iarg = 1; iarg < 10; iarg++) {
            if        (MODL->body[ibody].arg[iarg].nval == 0) {
                fprintf(fp, "%8.8s ", MODL->body[ibody].arg[iarg].str);
            } else if (MODL->body[ibody].arg[iarg].nval == 1) {
                fprintf(fp, "%8.3f ", MODL->body[ibody].arg[iarg].val[0]);
            } else if (MODL->body[ibody].arg[iarg].nval >  1) {
                fprintf(fp, " [%3d*1] ", MODL->body[ibody].arg[iarg].nval);
            } else {
                break;
            }
        }

        fprintf(fp, "\n");

        CPU += MODL->body[ibody].CPU;
    }

    fprintf(fp, "                                             total %8.3f\n", CPU);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintBrep - print BRep associated with a Body to file          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintBrep(void   *modl,             /* (in)  pointer to MODL */
              int    ibody,             /* (in)  Body index (1-nbody) */
              FILE   *fp)               /* (in)  pointer to FILE */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface, nattr, iattr, itype, nlist, i;
    int       nnode, nedge, nface;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist, *attrName;
    ego       *enodes, *eedges, *efaces;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmPrintBrep);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* print Body info */
    fprintf(fp, "Body %4d\n", ibody);

    status = EG_attributeNum(MODL->body[ibody].ebody, &nattr);
    CHECK_STATUS(EG_attributeNum);

    for (iattr = 1; iattr <= nattr; iattr++) {
        status = EG_attributeGet(MODL->body[ibody].ebody, iattr,
                                 &attrName, &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeGet);

        fprintf(fp, "            %-20s =", attrName);
        if        (itype == ATTRINT) {
            for (i = 0; i < nlist; i++) {
                fprintf(fp, "%5d ", tempIlist[i]);
            }
        } else if (itype == ATTRREAL) {
            for (i = 0; i < nlist; i++) {
                fprintf(fp, "%11.5f ", tempRlist[i]);
            }
        } else if (itype == ATTRCSYS) {
            for (i = 0; i < nlist; i++) {
                fprintf(fp, "%11.5f ", tempRlist[i]);
            }
            fprintf(fp, "\n                                 =");
            for (i = nlist; i < nlist+12; i++) {
                fprintf(fp, "%11.5f ", tempRlist[i]);
            }
        } else if (itype == ATTRSTRING) {
            fprintf(fp, "%s", tempClist);
        }
        fprintf(fp, "\n");
    }

    /* loop through all Nodes */
    fprintf(fp, "    inode nedge ibody     x             y             z\n");
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        fprintf(fp, "    %5d %5d %5d %12.5f %12.5f %12.5f\n", inode,
                MODL->body[ibody].node[inode].nedge,
                MODL->body[ibody].node[inode].ibody,
                MODL->body[ibody].node[inode].x,
                MODL->body[ibody].node[inode].y,
                MODL->body[ibody].node[inode].z);

        fprintf(fp, "             Edges ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].node[inode].enode,
                                 EDGE, &nedge, &eedges);
        CHECK_STATUS(EG_getBodyTopos);
        for (iedge = 0; iedge < nedge; iedge++) {
            fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, eedges[iedge]));
        }
        fprintf(fp, "\n");
        EG_free(eedges);

        fprintf(fp, "             Faces ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].node[inode].enode,
                                 FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);
        for (iface = 0; iface < nface; iface++) {
            fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, efaces[iface]));
        }
        fprintf(fp, "\n");
        EG_free(efaces);

        status = EG_attributeNum(MODL->body[ibody].node[inode].enode, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(MODL->body[ibody].node[inode].enode, iattr,
                                     &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            fprintf(fp, "            %-20s =", attrName);
            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
                fprintf(fp, "\n                                 =");
                for (i = nlist; i < nlist+12; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                fprintf(fp, "%s", tempClist);
            }
            fprintf(fp, "\n");
        }
    }

    /* loop through all Edges */
    fprintf(fp, "    iedge  ibeg  iend ileft irite nface ibody iford imark\n");
    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        fprintf(fp, "    %5d %5d %5d %5d %5d %5d %5d %5d %5d\n", iedge,
                MODL->body[ibody].edge[iedge].ibeg,
                MODL->body[ibody].edge[iedge].iend,
                MODL->body[ibody].edge[iedge].ileft,
                MODL->body[ibody].edge[iedge].irite,
                MODL->body[ibody].edge[iedge].nface,
                MODL->body[ibody].edge[iedge].ibody,
                MODL->body[ibody].edge[iedge].iford,
                MODL->body[ibody].edge[iedge].imark);

        fprintf(fp, "             Nodes ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].edge[iedge].eedge,
                                 NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);
        for (inode = 0; inode < nnode; inode++) {
            fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, enodes[inode]));
        }
        fprintf(fp, "\n");
        EG_free(enodes);

        fprintf(fp, "             Faces ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].edge[iedge].eedge,
                                 FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);
        for (iface = 0; iface < nface; iface++) {
            fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, efaces[iface]));
        }
        fprintf(fp, "\n");
        EG_free(efaces);

        status = EG_attributeNum(MODL->body[ibody].edge[iedge].eedge, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(MODL->body[ibody].edge[iedge].eedge, iattr,
                                     &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            fprintf(fp, "            %-20s =", attrName);
            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
                fprintf(fp, "\n                                 =");
                for (i = nlist; i < nlist+12; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                fprintf(fp, "%s", tempClist);
            }
            fprintf(fp, "\n");
        }
    }

    /* loop through all Faces */
    fprintf(fp, "    iface ibody iford imark\n");
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        fprintf(fp, "    %5d %5d %5d %5d\n", iface,
                MODL->body[ibody].face[iface].ibody,
                MODL->body[ibody].face[iface].iford,
                MODL->body[ibody].face[iface].imark);

        fprintf(fp, "             Nodes ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].face[iface].eface,
                                 NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);
        for (inode = 0; inode < nnode; inode++) {
            fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, enodes[inode]));
        }
        fprintf(fp, "\n");
        EG_free(enodes);

        fprintf(fp, "             Edges ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].face[iface].eface,
                                 EDGE, &nedge, &eedges);
        CHECK_STATUS(EG_getBodyTopos);
        for (iedge = 0; iedge < nedge; iedge++) {
            fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, eedges[iedge]));
        }
        fprintf(fp, "\n");
        EG_free(eedges);

        status = EG_attributeNum(MODL->body[ibody].face[iface].eface, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(MODL->body[ibody].face[iface].eface, iattr,
                                     &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            fprintf(fp, "            %-20s =", attrName);
            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
                fprintf(fp, "                                 =");
                for (i = nlist; i < nlist+12; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                fprintf(fp, "%s", tempClist);
            }
            fprintf(fp, "\n");
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmEvalExpr - evaluate an expression                              *
 *                                                                      *
 ************************************************************************
 */

int
ocsmEvalExpr(void   *modl,              /* (in)  pointer to MODL */
             char   expr[],             /* (in)  expression */
             double *value,             /* (out) value */
             double *dot,               /* (out) velocity */
             char   str[])              /* (out) value if string-valued (w/o leading $) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmEvalExpr);

    /* --------------------------------------------------------------- */

    /* default return */
    *value = 0;
    *dot   = 0;
    str[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* evaluate the expression */
    status = str2val(expr, MODL, value, dot, str);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintEgo - print contents of an EGADS ego                      *
 *                                                                      *
 ************************************************************************
 */

void
ocsmPrintEgo(
   /*@null@*/ego    obj)                    /* (in)  ego to start */
{
    ego    eref0,    eref1,    eref2,    eref3,    eref4,   eref5,   eref6;
    int    oclass0,  oclass1,  oclass2,  oclass3,  oclass4, oclass5, oclass6;
    int    mtype0,   mtype1,   mtype2,   mtype3,   mtype4,  mtype5,  mtype6;
    int    nchild0,  nchild1,  nchild2,  nchild3,  nchild4, nchild5, nchild6;
    int    ichild0,  ichild1,  ichild2,  ichild3,  ichild4, ichild5, i;
    double data0[4], data1[4], data2[4], data3[4], data4[4], data5[4], data6[4];
    ego    *ebodys0, *ebodys1, *ebodys2, *ebodys3, *ebodys4, *ebodys5, *ebodys6;
    int    *senses0, *senses1, *senses2, *senses3, *senses4, *senses5, *senses6;

    int    status, count=0, oclass, mtype;
    ego    topref, prev, next, refobj, context, prev1, next1, ergeom;

    int     nattr, iattr, itype, nlist, ilist;
    CINT    *tempIlist;
    CDOUBLE *tempRlist;
    CCHAR   *tempClist, *aname;

    /* names take from egadsTypes.h */
    char *classname[27] = {"contxt",       "transform",  "tessellation",  "nil",
                           "empty",        "reference",  "ERROR 6",       "ERROR 7",
                           "ERROR 8",      "ERROR 9",    "pcurve",        "curve",
                           "surface",      "ERROR 13",   "ERROR 14",      "ERROR 15",
                           "ERROR 16",     "ERROR 17",   "ERROR 18",      "ERROR 19",
                           "node",         "edge",       "loop",          "face",
                           "shell",        "body",       "model"};

    /* pcurves and curves */
    char *mtypename1[10] = {"ERROR 0",     "line",       "circle",        "ellipse",
                            "parabola",    "hyperbola",  "trimmed",       "bezier",
                            "bspline",     "offset"};

    /* surfaces */
    char *mtypename2[12] = {"ERROR 0",     "plane",      "spherical",     "cylindrical",
                            "revolution",  "toroidal",   "trimmed",       "bezier",
                            "bspline",     "offest",     "conical",       "extrusion"};

    /* faces */
    char *mtypename3[ 3] = {"sreverse",    "nomtype",    "sforward"};

    /* other topology */
    char *mtypename4[10] = {"nomtype",     "onenode",    "twonode",       "open",
                            "closed",      "degenerate", "wirebody",      "facebody",
                            "sheetbody",   "solidbody"};

    char mtypename[32];


    /* --------------------------------------------------------------- */

    if (obj == NULL) {
        SPRINT0(0, "NULL");
        return;
    }

    status = EG_getContext(obj, &context);
    if (status < 0) {
        SPRINT1(0, "EG_getContext -> status=%d", status);
    }

    status = EG_getTopology(obj, &eref0, &oclass0, &mtype0,
                            data0, &nchild0, &ebodys0, &senses0);
    if (status != EGADS_SUCCESS) {
        EG_getInfo(obj, &oclass0, &mtype0, &topref, &prev, &next);
        nchild0 = -1;
        eref0   = topref;
    }

    if (oclass0 != NODE) {
        if (oclass0 == PCURVE || oclass0 == CURVE) {
            strcpy(mtypename, mtypename1[mtype0]);
        } else if (oclass0 == SURFACE) {
            strcpy(mtypename, mtypename2[mtype0]);
        } else if (oclass0 == FACE) {
            strcpy(mtypename, mtypename3[mtype0+1]);
        } else if (oclass0 == EDGE  || oclass0 == LOOP ||
                   oclass0 == SHELL || oclass0 == BODY ||
                   oclass0 == MODEL                      ) {
            strcpy(mtypename, mtypename4[mtype0]);
        } else {
            strcpy(mtypename, "");
        }

        status = EG_getGeometry(eref0, &oclass, &mtype, &ergeom, NULL, NULL);
        if (status != EGADS_SUCCESS) {
            oclass = 0;
            mtype  = 0;
        }
        SPRINT8(0, "oclass0=%3d (%s)  mtype0=%3d (%s)  obj=%llx,  eref0=%llx (%d:%d)",
                oclass0, classname[oclass0], mtype0, mtypename, (long long)obj, (long long)eref0, oclass, mtype);

        if (oclass0 == LOOP) {
            SPRINT0x(0, "< senses=");
            for (i = 0; i < nchild0; i++) {
                SPRINT1x(0, "%2d ", senses0[i]);
            }
            SPRINT0(0, " ");
        }
    } else {
        SPRINT7(0, "oclass0=%3d (%s)  mtype0=%3d,  obj=%llx,  data0=%20.10e %20.10e %20.10e",
                oclass0, classname[oclass0], mtype0, (long long)obj, data0[0], data0[1], data0[2]);
    }

    if (outLevel >= 2) {
        (void) EG_attributeNum(obj, &nattr);
        for (iattr = 1; iattr <= nattr; iattr++) {
            (void) EG_attributeGet(obj, iattr, &aname, &itype, &nlist,
                                   &tempIlist, &tempRlist, &tempClist);
            SPRINT1x(2, "          %-20s :", aname);
            if (itype == ATTRINT) {
                for (ilist = 0; ilist < nlist; ilist++) {
                SPRINT1x(2, " %5d", tempIlist[ilist]);
                }
                SPRINT0(2, " ");
            } else if (itype == ATTRREAL) {
                for (ilist = 0; ilist < nlist; ilist++) {
                    SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                }
                SPRINT0(2, " ");
            } else if (itype == ATTRSTRING) {
            SPRINT1(2, "%s", tempClist);
            } else {
                SPRINT0(2, " ");
            }
        }
    }

    next = obj->tref;
    prev = NULL;
    while (next != NULL) {
        refobj = next->attrs;
        if (refobj != context) {
            count++;
            EG_getInfo(refobj, &oclass1, &mtype1, &topref, &prev1, &next1);
            SPRINT5(0, "< refcount=%2d, refobj=%llx  (oclass=%2d (%s) mtype=%2d)",
                    count, (long long)refobj, oclass1, classname[oclass1], mtype1);
        }
        prev = next;
        next = prev->blind;
    }

    for (ichild0 = 0; ichild0 < nchild0; ichild0++) {
        status = EG_getTopology(ebodys0[ichild0], &eref1, &oclass1, &mtype1,
                                data1, &nchild1, &ebodys1, &senses1);
        if (status != EGADS_SUCCESS) {
            EG_getInfo(obj, &oclass1, &mtype1, &topref, &prev, &next);
            nchild1 = -1;
            eref1   = topref;
        }

        if (oclass1 != NODE) {
            if (oclass1 == PCURVE || oclass1 == CURVE) {
                strcpy(mtypename, mtypename1[mtype1]);
            } else if (oclass1 == SURFACE) {
                strcpy(mtypename, mtypename2[mtype1]);
            } else if (oclass1 == FACE) {
                strcpy(mtypename, mtypename3[mtype1+1]);
            } else if (oclass1 == EDGE  || oclass1 == LOOP ||
                       oclass1 == SHELL || oclass1 == BODY ||
                       oclass1 == MODEL                      ) {
                strcpy(mtypename, mtypename4[mtype1]);
            } else {
                strcpy(mtypename, "");
            }

            status = EG_getGeometry(eref1, &oclass, &mtype, &ergeom, NULL, NULL);
            if (status != EGADS_SUCCESS) {
                oclass = 0;
                mtype  = 0;
            }
            SPRINT8(0, ". oclass1=%3d (%s)  mtype1=%3d (%s)  obj=%llx,  eref1=%llx (%d:%d)",
                    oclass1, classname[oclass1], mtype1, mtypename, (long long)(ebodys0[ichild0]), (long long)eref1, oclass, mtype);

            if (oclass1 == LOOP) {
                SPRINT0x(0, ". < senses=");
                for (i = 0; i < nchild1; i++) {
                    SPRINT1x(0, "%2d ", senses1[i]);
                }
                SPRINT0(0, " ");
            }
        } else {
            SPRINT7(0, ". oclass1=%3d (%s)  mtype1=%3d,  obj=%llx,  data1=%20.10e %20.10e %20.10e",
                    oclass1, classname[oclass1], mtype1, (long long)(ebodys0[ichild0]), data1[0], data1[1], data1[2]);
        }

        if (outLevel >= 2) {
            (void) EG_attributeNum(ebodys0[ichild0], &nattr);
            for (iattr = 1; iattr <= nattr; iattr++) {
                (void) EG_attributeGet(ebodys0[ichild0], iattr, &aname, &itype, &nlist,
                                       &tempIlist, &tempRlist, &tempClist);
                SPRINT1x(2, "          %-20s :", aname);
                if (itype == ATTRINT) {
                    for (ilist = 0; ilist < nlist; ilist++) {
                        SPRINT1x(2, " %5d", tempIlist[ilist]);
                    }
                    SPRINT0(2, " ");
                } else if (itype == ATTRREAL) {
                    for (ilist = 0; ilist < nlist; ilist++) {
                        SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                    }
                    SPRINT0(2, " ");
                } else if (itype == ATTRSTRING) {
                    SPRINT1(2, "%s", tempClist);
                } else {
                    SPRINT0(2, " ");
                }
            }
        }

        for (ichild1 = 0; ichild1 < nchild1; ichild1++) {
            status = EG_getTopology(ebodys1[ichild1], &eref2, &oclass2, &mtype2,
                                    data2, &nchild2, &ebodys2, &senses2);
            if (status != EGADS_SUCCESS) {
                EG_getInfo(obj, &oclass2, &mtype2, &topref, &prev, &next);
                nchild2 = -1;
                eref2   = topref;
            }

            if (oclass2 != NODE) {
                if (oclass2 == PCURVE || oclass2 == CURVE) {
                    strcpy(mtypename, mtypename1[mtype2]);
                } else if (oclass2 == SURFACE) {
                    strcpy(mtypename, mtypename2[mtype2]);
                } else if (oclass2 == FACE) {
                    strcpy(mtypename, mtypename3[mtype2+1]);
                } else if (oclass2 == EDGE  || oclass2 == LOOP ||
                           oclass2 == SHELL || oclass2 == BODY ||
                           oclass2 == MODEL                      ) {
                    strcpy(mtypename, mtypename4[mtype2]);
                } else {
                    strcpy(mtypename, "");
                }

                status = EG_getGeometry(eref2, &oclass, &mtype, &ergeom, NULL, NULL);
                if (status != EGADS_SUCCESS) {
                    oclass = 0;
                    mtype  = 0;
                }
                SPRINT8(0, ". . oclass2=%3d (%s)  mtype2=%3d (%s)  obj=%llx,  eref2=%llx (%d:%d)",
                        oclass2, classname[oclass2], mtype2, mtypename, (long long)(ebodys1[ichild1]), (long long)eref2, oclass, mtype);

                if (oclass2 == LOOP) {
                    SPRINT0x(0, ". . < senses=");
                    for (i=0; i < nchild2; i++) {
                        SPRINT1x(0, "%2d ", senses2[i]);
                    }
                    SPRINT0(0, " ");
                }
            } else {
                SPRINT7(0, ". . oclass2=%3d (%s)  mtype2=%3d,  obj=%llx,  data2=%20.10e %20.10e %20.10e",
                        oclass2, classname[oclass2], mtype2, (long long)(ebodys1[ichild1]), data2[0], data2[1], data2[2]);
            }

            if (outLevel >= 2) {
                (void) EG_attributeNum(ebodys1[ichild1], &nattr);
                for (iattr = 1; iattr <= nattr; iattr++) {
                    (void) EG_attributeGet(ebodys1[ichild1], iattr, &aname, &itype, &nlist,
                                           &tempIlist, &tempRlist, &tempClist);
                    SPRINT1x(2, "          %-20s :", aname);
                    if (itype == ATTRINT) {
                        for (ilist = 0; ilist < nlist; ilist++) {
                            SPRINT1x(2, " %5d", tempIlist[ilist]);
                    }
                        SPRINT0(2, " ");
                    } else if (itype == ATTRREAL) {
                        for (ilist = 0; ilist < nlist; ilist++) {
                            SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                        }
                        SPRINT0(2, " ");
                    } else if (itype == ATTRSTRING) {
                        SPRINT1(2, "%s", tempClist);
                } else {
                        SPRINT0(2, " ");
                    }
                }
            }

            for (ichild2 = 0; ichild2 < nchild2; ichild2++) {
                status = EG_getTopology(ebodys2[ichild2], &eref3, &oclass3, &mtype3,
                               data3, &nchild3, &ebodys3, &senses3);
                if (status != EGADS_SUCCESS) {
                    EG_getInfo(obj, &oclass3, &mtype3, &topref, &prev, &next);
                    nchild3 = -1;
                    eref3   = topref;
                }

                if (oclass3 != NODE) {
                    if (oclass3 == PCURVE || oclass3 == CURVE) {
                        strcpy(mtypename, mtypename1[mtype3]);
                    } else if (oclass3 == SURFACE) {
                        strcpy(mtypename, mtypename2[mtype3]);
                    } else if (oclass3 == FACE) {
                        strcpy(mtypename, mtypename3[mtype3+1]);
                    } else if (oclass3 == EDGE  || oclass3 == LOOP ||
                               oclass3 == SHELL || oclass3 == BODY ||
                               oclass3 == MODEL                      ) {
                        strcpy(mtypename, mtypename4[mtype3]);
                    } else {
                        strcpy(mtypename, "");
                    }

                    status = EG_getGeometry(eref3, &oclass, &mtype, &ergeom, NULL, NULL);
                    if (status != EGADS_SUCCESS) {
                        oclass = 0;
                        mtype  = 0;
                    }
                    SPRINT8(0, ". . . oclass3=%3d (%s)  mtype3=%3d (%s)  obj=%llx,  eref3=%llx (%d:%d)",
                            oclass3, classname[oclass3], mtype3, mtypename, (long long)(ebodys2[ichild2]), (long long)eref3, oclass, mtype);

                    if (oclass3 == LOOP) {
                        SPRINT0x(0, ". . . < senses=");
                        for (i=0; i < nchild3; i++) {
                            SPRINT1x(0, "%2d ", senses3[i]);
                        }
                        SPRINT0(0, " ");
                    }
                } else {
                    SPRINT7(0, ". . . oclass3=%3d (%s)  mtype3=%3d,  obj=%llx,  data3=%20.10e %20.10e %20.10e",
                            oclass3, classname[oclass3], mtype3, (long long)(ebodys2[ichild2]), data3[0], data3[1], data3[2]);
                }

                if (outLevel >= 2) {
                    (void) EG_attributeNum(ebodys2[ichild2], &nattr);
                    for (iattr = 1; iattr <= nattr; iattr++) {
                        (void) EG_attributeGet(ebodys2[ichild2], iattr, &aname, &itype, &nlist,
                                               &tempIlist, &tempRlist, &tempClist);
                        SPRINT1x(2, "          %-20s :", aname);
                        if (itype == ATTRINT) {
                            for (ilist = 0; ilist < nlist; ilist++) {
                                SPRINT1x(2, " %5d", tempIlist[ilist]);
                            }
                            SPRINT0(2, " ");
                        } else if (itype == ATTRREAL) {
                            for (ilist = 0; ilist < nlist; ilist++) {
                                SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                            }
                            SPRINT0(2, " ");
                        } else if (itype == ATTRSTRING) {
                            SPRINT1(2, "%s", tempClist);
                    } else {
                            SPRINT0(2, " ");
                        }
                    }
                }

                for (ichild3 = 0; ichild3 < nchild3; ichild3++) {
                    status = EG_getTopology(ebodys3[ichild3], &eref4, &oclass4, &mtype4,
                                   data4, &nchild4, &ebodys4, &senses4);
                    if (status != EGADS_SUCCESS) {
                        EG_getInfo(obj, &oclass4, &mtype4, &topref, &prev, &next);
                        nchild4 = -1;
                        eref4   = topref;
                    }

                    if (oclass4 != NODE) {
                        if (oclass4 == PCURVE || oclass4 == CURVE) {
                            strcpy(mtypename, mtypename1[mtype4]);
                        } else if (oclass4 == SURFACE) {
                            strcpy(mtypename, mtypename2[mtype4]);
                        } else if (oclass4 == FACE) {
                            strcpy(mtypename, mtypename3[mtype4+1]);
                        } else if (oclass4 == EDGE  || oclass4 == LOOP ||
                                   oclass4 == SHELL || oclass4 == BODY ||
                                   oclass4 == MODEL                      ) {
                            strcpy(mtypename, mtypename4[mtype4]);
                        } else {
                            strcpy(mtypename, "");
                        }

                        status = EG_getGeometry(eref4, &oclass, &mtype, &ergeom, NULL, NULL);
                        if (status != EGADS_SUCCESS) {
                            oclass = 0;
                            mtype  = 0;
                        }
                        SPRINT8(0, ". . . . oclass4=%3d (%s)  mtype4=%3d (%s)  obj=%llx,  eref4=%llx (%d:%d)",
                                oclass4, classname[oclass4], mtype4, mtypename, (long long)(ebodys3[ichild3]), (long long)eref4, oclass, mtype);

                        if (oclass4 == LOOP) {
                            SPRINT0x(0, ". . . . < senses=");
                            for (i=0; i < nchild4; i++) {
                                SPRINT1x(0, "%2d ", senses4[i]);
                            }
                            SPRINT0(0, " ");
                        }
                    } else {
                        SPRINT7(0, ". . . . oclass4=%3d (%s)  mtype4=%3d,  obj=%llx,  data4=%20.10e %20.10e %20.10e",
                                oclass4, classname[oclass4], mtype4, (long long)(ebodys3[ichild3]), data4[0], data4[1], data4[2]);
                    }

                    if (outLevel >= 2) {
                        (void) EG_attributeNum(ebodys3[ichild3], &nattr);
                        for (iattr = 1; iattr <= nattr; iattr++) {
                            (void) EG_attributeGet(ebodys3[ichild3], iattr, &aname, &itype, &nlist,
                                                   &tempIlist, &tempRlist, &tempClist);
                            SPRINT1x(2, "          %-20s :", aname);
                            if (itype == ATTRINT) {
                                for (ilist = 0; ilist < nlist; ilist++) {
                                    SPRINT1x(2, " %5d", tempIlist[ilist]);
                                }
                                SPRINT0(2, " ");
                            } else if (itype == ATTRREAL) {
                                for (ilist = 0; ilist < nlist; ilist++) {
                                    SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                                }
                                SPRINT0(2, " ");
                            } else if (itype == ATTRSTRING) {
                                SPRINT1(2, "%s", tempClist);
                            } else {
                                SPRINT0(2, " ");
                            }
                        }
                    }

                    for (ichild4 = 0; ichild4 < nchild4; ichild4++) {
                        status = EG_getTopology(ebodys4[ichild4], &eref5, &oclass5, &mtype5,
                                                data5, &nchild5, &ebodys5, &senses5);
                        if (status != EGADS_SUCCESS) {
                            EG_getInfo(obj, &oclass5, &mtype5, &topref, &prev, &next);
                            nchild5 = -1;
                            eref5   = topref;
                        }

                        if (oclass5 != NODE) {
                            if (oclass5 == PCURVE || oclass5 == CURVE) {
                                strcpy(mtypename, mtypename1[mtype5]);
                            } else if (oclass5 == SURFACE) {
                                strcpy(mtypename, mtypename2[mtype5]);
                            } else if (oclass5 == FACE) {
                                strcpy(mtypename, mtypename3[mtype5+1]);
                            } else if (oclass5 == EDGE  || oclass5 == LOOP ||
                                       oclass5 == SHELL || oclass5 == BODY ||
                                       oclass5 == MODEL                      ) {
                                strcpy(mtypename, mtypename4[mtype5]);
                            } else {
                                strcpy(mtypename, "");
                            }

                            status = EG_getGeometry(eref5, &oclass, &mtype, &ergeom, NULL, NULL);
                            if (status != EGADS_SUCCESS) {
                                oclass = 0;
                                mtype  = 0;
                            }
                            SPRINT8(0, ". . . . . oclass5=%3d (%s)  mtype5=%3d (%s)  obj=%llx,  eref5=%llx (%d:%d)",
                                    oclass5, classname[oclass5], mtype5, mtypename, (long long)(ebodys4[ichild4]), (long long)eref5, oclass, mtype);

                            if (oclass5 == LOOP) {
                                SPRINT0x(0, ". . . . . < senses=");
                                for (i=0; i < nchild5; i++) {
                                    SPRINT1x(0, "%2d ", senses5[i]);
                                }
                                SPRINT0(0, " ");
                            }
                        } else {
                            SPRINT7(0, ". . . . . oclass5=%3d (%s)  mtype5=%3d,  obj=%llx,  data5=%20.10e %20.10e %20.10e",
                                    oclass5, classname[oclass5], mtype5, (long long)(ebodys4[ichild4]), data5[0], data5[1], data5[2]);
                        }

                        if (outLevel >= 2) {
                            (void) EG_attributeNum(ebodys4[ichild4], &nattr);
                            for (iattr = 1; iattr <= nattr; iattr++) {
                                (void) EG_attributeGet(ebodys4[ichild4], iattr, &aname, &itype, &nlist,
                                                       &tempIlist, &tempRlist, &tempClist);
                                SPRINT1x(2, "          %-20s :", aname);
                                if (itype == ATTRINT) {
                                    for (ilist = 0; ilist < nlist; ilist++) {
                                        SPRINT1x(2, " %5d", tempIlist[ilist]);
                                    }
                                    SPRINT0(2, " ");
                            } else if (itype == ATTRREAL) {
                                    for (ilist = 0; ilist < nlist; ilist++) {
                                        SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                                    }
                                    SPRINT0(2, " ");
                                } else if (itype == ATTRSTRING) {
                                    SPRINT1(2, "%s", tempClist);
                            } else {
                                    SPRINT0(2, " ");
                                }
                            }
                        }

                        for (ichild5 = 0; ichild5 < nchild5; ichild5++) {
                            status = EG_getTopology(ebodys5[ichild5], &eref6, &oclass6, &mtype6,
                                                    data6, &nchild6, &ebodys6, &senses6);
                            if (status != EGADS_SUCCESS) {
                                EG_getInfo(obj, &oclass6, &mtype6, &topref, &prev, &next);
                                nchild5 = -1;
                                eref6   = topref;
                            }

                            if (oclass6 != NODE) {
                                if (oclass6 == PCURVE || oclass6 == CURVE) {
                                    strcpy(mtypename, mtypename1[mtype6]);
                                } else if (oclass6 == SURFACE) {
                                    strcpy(mtypename, mtypename2[mtype6]);
                                } else if (oclass6 == FACE) {
                                    strcpy(mtypename, mtypename3[mtype6+1]);
                                } else if (oclass6 == EDGE  || oclass6 == LOOP ||
                                           oclass6 == SHELL || oclass6 == BODY ||
                                           oclass6 == MODEL                      ) {
                                    strcpy(mtypename, mtypename4[mtype6]);
                                } else {
                                    strcpy(mtypename, "");
                                }

                                status = EG_getGeometry(eref6, &oclass, &mtype, &ergeom, NULL, NULL);
                                if (status != EGADS_SUCCESS) {
                                    oclass = 0;
                                    mtype  = 0;
                                }
                                SPRINT8(0, ". . . . . . oclass6=%3d (%s)  mtype6=%3d (%s)  obj=%llx,  eref6=%llx (%d:%d)",
                                        oclass6, classname[oclass6], mtype6, mtypename, (long long)(ebodys5[ichild5]), (long long)eref6, oclass, mtype);

                                if (oclass6 == LOOP) {
                                    SPRINT0x(0, ". . . . . < senses=");
                                    for (i=0; i < nchild6; i++) {
                                        SPRINT1x(0, "%2d ", senses6[i]);
                                    }
                                    SPRINT0(0, " ");
                                }
                            } else {
                                SPRINT7(0, ". . . . . . oclass6=%3d (%s)  mtype6=%3d,  obj=%llx,  data6=%20.10e %20.10e %20.10e",
                                        oclass6, classname[oclass6], mtype6, (long long)(ebodys5[ichild5]), data6[0], data6[1], data6[2]);
                            }

                            if (outLevel >= 2) {
                                (void) EG_attributeNum(ebodys5[ichild5], &nattr);
                                for (iattr = 1; iattr <= nattr; iattr++) {
                                    (void) EG_attributeGet(ebodys5[ichild5], iattr, &aname, &itype, &nlist,
                                                           &tempIlist, &tempRlist, &tempClist);
                                    SPRINT1x(2, "          %-20s :", aname);
                                    if (itype == ATTRINT) {
                                        for (ilist = 0; ilist < nlist; ilist++) {
                                            SPRINT1x(2, " %5d", tempIlist[ilist]);
                                        }
                                        SPRINT0(2, " ");
                                    } else if (itype == ATTRREAL) {
                                        for (ilist = 0; ilist < nlist; ilist++) {
                                            SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                                        }
                                        SPRINT0(2, " ");
                                    } else if (itype == ATTRSTRING) {
                                    SPRINT1(2, "%s", tempClist);
                                    } else {
                                        SPRINT0(2, " ");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetText - convert an OCSM code to text                         *
 *                                                                      *
 ************************************************************************
 */

char *
ocsmGetText(int    icode)               /* (in)  code to look up */
{

    static char    unknown[]                          = "UNKNOWN";
    static char    success[]                          = "success";

    static char    ocsm_dimension[]                   = "dimension";
    static char    ocsm_cfgpmtr[]                     = "cfgpmtr";
    static char    ocsm_conpmtr[]                     = "conpmtr";
    static char    ocsm_despmtr[]                     = "despmtr";
    static char    ocsm_outpmtr[]                     = "outpmtr";
    static char    ocsm_lbound[]                      = "lbound";
    static char    ocsm_ubound[]                      = "ubound";
    static char    ocsm_name[]                        = "name";
    static char    ocsm_attribute[]                   = "attribute";
    static char    ocsm_csystem[]                     = "csystem";

    static char    ocsm_point[]                       = "point";
    static char    ocsm_box[]                         = "box";
    static char    ocsm_sphere[]                      = "sphere";
    static char    ocsm_cone[]                        = "cone";
    static char    ocsm_cylinder[]                    = "cylinder";
    static char    ocsm_torus[]                       = "torus";
    static char    ocsm_import[]                      = "import";
    static char    ocsm_udprim[]                      = "udprim";
    static char    ocsm_restore[]                     = "restore";

    static char    ocsm_extrude[]                     = "extrude";
    static char    ocsm_rule[]                        = "rule";
    static char    ocsm_loft[]                        = "loft";
    static char    ocsm_blend[]                       = "blend";
    static char    ocsm_revolve[]                     = "revolve";
    static char    ocsm_sweep[]                       = "sweep";

    static char    ocsm_fillet[]                      = "fillet";
    static char    ocsm_chamfer[]                     = "chamfer";
    static char    ocsm_hollow[]                      = "hollow";
    static char    ocsm_connect[]                     = "connect";

    static char    ocsm_intersect[]                   = "intersect";
    static char    ocsm_subtract[]                    = "subtract";
    static char    ocsm_union[]                       = "union";
    static char    ocsm_join[]                        = "join";
    static char    ocsm_extract[]                     = "extract";
    static char    ocsm_combine[]                     = "combine";

    static char    ocsm_translate[]                   = "translate";
    static char    ocsm_rotatex[]                     = "rotatex";
    static char    ocsm_rotatey[]                     = "rotatey";
    static char    ocsm_rotatez[]                     = "rotatez";
    static char    ocsm_scale[]                       = "scale";
    static char    ocsm_mirror[]                      = "mirror";
    static char    ocsm_applycsys[]                   = "applycsys";
    static char    ocsm_reorder[]                     = "reorder";

    static char    ocsm_skbeg[]                       = "skbeg";
    static char    ocsm_skcon[]                       = "skcon";
    static char    ocsm_skvar[]                       = "skvar";
    static char    ocsm_linseg[]                      = "linseg";
    static char    ocsm_cirarc[]                      = "cirarc";
    static char    ocsm_arc[]                         = "arc";
    static char    ocsm_spline[]                      = "spline";
    static char    ocsm_sslope[]                      = "sslope";
    static char    ocsm_bezier[]                      = "bezier";
    static char    ocsm_skend[]                       = "skend";

    static char    ocsm_solbeg[]                      = "solbeg";
    static char    ocsm_solcon[]                      = "solcon";
    static char    ocsm_solend[]                      = "solend";

    static char    ocsm_interface[]                   = "interface";
    static char    ocsm_end[]                         = "end";
    static char    ocsm_set[]                         = "set";
    static char    ocsm_evaluate[]                    = "evaluate";
    static char    ocsm_getattr[]                     = "getattr";
    static char    ocsm_udparg[]                      = "udparg";
    static char    ocsm_select[]                      = "select";
    static char    ocsm_project[]                     = "project";
    static char    ocsm_macbeg[]                      = "macbeg";
    static char    ocsm_macend[]                      = "macend";
    static char    ocsm_recall[]                      = "recall";
    static char    ocsm_store[]                       = "store";
    static char    ocsm_patbeg[]                      = "patbeg";
    static char    ocsm_patbreak[]                    = "patbreak";
    static char    ocsm_patend[]                      = "patend";
    static char    ocsm_ifthen[]                      = "ifthen";
    static char    ocsm_elseif[]                      = "elseif";
    static char    ocsm_else[]                        = "else";
    static char    ocsm_endif[]                       = "endif";
    static char    ocsm_throw[]                       = "throw";
    static char    ocsm_catbeg[]                      = "catbeg";
    static char    ocsm_catend[]                      = "catend";
    static char    ocsm_mark[]                        = "mark";
    static char    ocsm_group[]                       = "group";
    static char    ocsm_dump[]                        = "dump";
    static char    ocsm_assert[]                      = "assert";
    static char    ocsm_special[]                     = "special";

    static char    ocsm_primitive[]                   = "primitive";
    static char    ocsm_grown[]                       = "grown";
    static char    ocsm_applied[]                     = "applied";
    static char    ocsm_boolean[]                     = "boolean";
    static char    ocsm_transform[]                   = "transform";
    static char    ocsm_sketch[]                      = "sketch";
    static char    ocsm_solver[]                      = "solver";
    static char    ocsm_utility[]                     = "utility";

    static char    ocsm_active[]                      = "active";
    static char    ocsm_suppressed[]                  = "suppressed";
    static char    ocsm_inactive[]                    = "inactive";
    static char    ocsm_deferred[]                    = "deferred";

    static char    ocsm_solid_body[]                  = "solid_body";
    static char    ocsm_sheet_body[]                  = "sheet_body";
    static char    ocsm_wire_body[]                   = "wire_body";
    static char    ocsm_node_body[]                   = "node_body";
    static char    ocsm_null_body[]                   = "null_body";

    static char    ocsm_external[]                    = "external";
    static char    ocsm_config[]                      = "config";
    static char    ocsm_constant[]                    = "constant";
    static char    ocsm_internal[]                    = "internal";
    static char    ocsm_output[]                      = "output";
    static char    ocsm_unknown[]                     = "unknown";

    static char    ocsm_node[]                        = "node";
    static char    ocsm_edge[]                        = "edge";
    static char    ocsm_face[]                        = "face";
    static char    ocsm_body[]                        = "body";

    static char    ocsm_file_not_found[]              = "file_not_found";
    static char    ocsm_illegal_statement[]           = "illegal_statement";
    static char    ocsm_not_enough_args[]             = "not_enough_args";
    static char    ocsm_name_already_defined[]        = "name_already_defined";
    static char    ocsm_nested_too_deeply[]           = "nested_too_deeply";
    static char    ocsm_improper_nesting[]            = "improper_nesting";
    static char    ocsm_nesting_not_closed[]          = "nesting_not_closed";
    static char    ocsm_not_modl_structure[]          = "not_modl_structure";
    static char    ocsm_problem_creating_perturb[]    = "problem_creating_perturb";

    static char    ocsm_missing_mark[]                = "missing_mark";
    static char    ocsm_insufficient_bodys_on_stack[] = "insufficient_bodys_on_stack";
    static char    ocsm_wrong_types_on_stack[]        = "wrong_types_on_stack";
    static char    ocsm_did_not_create_body[]         = "did_not_create_body";
    static char    ocsm_created_too_many_bodys[]      = "created_too_many_bodys";
    static char    ocsm_too_many_bodys_on_stack[]     = "too_many_bodys_on_stack";
    static char    ocsm_error_in_bodys_on_stack[]     = "errors_in_bodys_on_stack";

    static char    ocsm_modl_not_checked[]            = "modl_not_checked";
    static char    ocsm_need_tessellation[]           = "need_tessellation";

    static char    ocsm_body_not_found[]              = "body_not_found";
    static char    ocsm_face_not_found[]              = "face_not_found";
    static char    ocsm_edge_not_found[]              = "edge_not_found";
    static char    ocsm_node_not_found[]              = "node_not_found";
    static char    ocsm_illegal_value[]               = "illegal_value";
    static char    ocsm_illegal_attribute[]           = "illegal_attribute";
    static char    ocsm_illegal_csystem[]             = "illegal_csystem";
    static char    ocsm_no_selection[]                = "no_selection";

    static char    ocsm_sketch_is_open[]              = "sketch_is_open";
    static char    ocsm_sketch_is_not_open[]          = "sketch_is_not_open";
    static char    ocsm_colinear_sketch_points[]      = "colinear_sketch_points";
    static char    ocsm_non_coplanar_sketch_points[]  = "non_coplanar_sketch_points";
    static char    ocsm_too_many_sketch_points[]      = "too_many_sketch_points";
    static char    ocsm_too_few_spline_points[]       = "too_few_spline_points";
    static char    ocsm_sketch_does_not_close[]       = "sketch_does_not_close";
    static char    ocsm_self_intersecting[]           = "self_intersecting";
    static char    ocsm_assert_failed[]               = "assert_failed";

    static char    ocsm_illegal_char_in_expr[]        = "illegal_char_in_expr";
    static char    ocsm_close_before_open[]           = "close_before_open";
    static char    ocsm_missing_close[]               = "missing_close";
    static char    ocsm_illegal_token_sequence[]      = "illegal_token_sequence";
    static char    ocsm_illegal_number[]              = "illegal_number";
    static char    ocsm_illegal_pmtr_name[]           = "illegal_pmtr_name";
    static char    ocsm_illegal_func_name[]           = "illegal_func_name";
    static char    ocsm_illegal_type[]                = "illegal_type";
    static char    ocsm_illegal_narg[]                = "illegal_narg";

    static char    ocsm_name_not_found[]              = "name_not_found";
    static char    ocsm_name_not_unique[]             = "name_not_unique";
    static char    ocsm_pmtr_is_external[]            = "pmtr_is_external";
    static char    ocsm_pmtr_is_internal[]            = "pmtr_is_internal";
    static char    ocsm_pmtr_is_output[]              = "pmtr_is_output";
    static char    ocsm_pmtr_is_constant[]            = "pmtr_is_constant";
    static char    ocsm_wrong_pmtr_type[]             = "wrong_pmtr_type";
    static char    ocsm_func_arg_out_of_bounds[]      = "func_arg_out_of_bounds";
    static char    ocsm_val_stack_underflow[]         = "val_stack_underflow";
    static char    ocsm_val_stack_overflow[]          = "val_stack_overflow";

    static char    ocsm_illegal_brch_index[]          = "illegal_brch_index";
    static char    ocsm_illegal_pmtr_index[]          = "illegal_pmtr_index";
    static char    ocsm_illegal_body_index[]          = "illegal_body_index";
    static char    ocsm_illegal_arg_index[]           = "illegal_arg_index";
    static char    ocsm_illegal_activity[]            = "illegal_activity";
    static char    ocsm_illegal_macro_index[]         = "illegal_macro_index";
    static char    ocsm_illegal_argument[]            = "illegal_argument";
    static char    ocsm_cannot_be_suppressed[]        = "cannot_be_suppressed";
    static char    ocsm_storage_already_used[]        = "storage_already_used";
    static char    ocsm_nothing_previously_stored[]   = "nothing_previously_stored";

    static char    ocsm_solver_is_open[]              = "solver_is_open";
    static char    ocsm_solver_is_not_open[]          = "solver_is_not_open";
    static char    ocsm_too_many_solver_vars[]        = "too_many_solver_vars";
    static char    ocsm_underconstrained[]            = "underconstrained";
    static char    ocsm_overconstrained[]             = "overconstrained";
    static char    ocsm_singular_matrix[]             = "singular_matrix";
    static char    ocsm_not_converged[]               = "not_converged";

    static char    ocsm_udp_error1[]                  = "udp_error1";
    static char    ocsm_udp_error2[]                  = "udp_error2";
    static char    ocsm_udp_error3[]                  = "udp_error3";
    static char    ocsm_udp_error4[]                  = "udp_error4";
    static char    ocsm_udp_error5[]                  = "udp_error5";
    static char    ocsm_udp_error6[]                  = "udp_error6";
    static char    ocsm_udp_error7[]                  = "udp_error7";
    static char    ocsm_udp_error8[]                  = "udp_error8";
    static char    ocsm_udp_error9[]                  = "udp_error9";

    static char    ocsm_op_stack_underflow[]          = "op_stack_underflow";
    static char    ocsm_op_stack_overflow[]           = "op_stack_overflow";
    static char    ocsm_rpn_stack_underflow[]         = "rpn_stack_underflow";
    static char    ocsm_rpn_stack_overflow[]          = "rpn_stack_overflow";
    static char    ocsm_token_stack_underflow[]       = "token_stack_underflow";
    static char    ocsm_token_stack_overflow[]        = "token_stack_overflow";
    static char    ocsm_unsupported[]                 = "unsupported";
    static char    ocsm_internal_error[]              = "internal_error";

    static char    egads_notfound[]                   = "egads_notfound";
    static char    egads_nullobj[]                    = "egads_nullobj";
    static char    egads_notobj[]                     = "egads_notobj";
    static char    egads_malloc[]                     = "egads_malloc";
    static char    egads_indexerr[]                   = "egads_indexerr";
    static char    egads_noname[]                     = "egads_noname";
    static char    egads_nodata[]                     = "egads_nodata";
    static char    egads_mixcntx[]                    = "egads_mixcntx";
    static char    egads_notcntx[]                    = "egads_notcntx";
    static char    egads_notxform[]                   = "egads_notxform";
    static char    egads_referce[]                    = "egads_referce";
    static char    egads_nottopo[]                    = "egads_nottopo";
    static char    egads_empty[]                      = "egads_empty";
    static char    egads_nottess[]                    = "egads_nottess";
    static char    egads_notgeom[]                    = "egads_notgeom";
    static char    egads_rangerr[]                    = "egads_rangerr";
    static char    egads_noload[]                     = "egads_noload";
    static char    egads_notmodel[]                   = "egads_notmodel";
    static char    egads_writerr[]                    = "egads_writerr";
    static char    egads_notbody[]                    = "egads_notbody";
    static char    egads_geomerr[]                    = "egads_geomerr";
    static char    egads_topoerr[]                    = "egads_topoerr";
    static char    egads_consterr[]                   = "egads_consterr";
    static char    egads_degen[]                      = "egads_degen";
    static char    egads_notortho[]                   = "egads_notortho";
    static char    egads_badscale[]                   = "egads_badscale";
    static char    egads_ocsegflt[]                   = "egads_ocsegflt";
    static char    egads_topocnt[]                    = "egads_topocnt";
    static char    egads_attrerr[]                    = "egads_attrerr";
    static char    egads_exists[]                     = "egads_exists";

    /* --------------------------------------------------------------- */

    /* OCSM_SUCCESS */
    if (icode == SUCCESS                         ) return success;

    /* not branches */
    if (icode == OCSM_DIMENSION                  ) return ocsm_dimension;
    if (icode == OCSM_CFGPMTR                    ) return ocsm_cfgpmtr;
    if (icode == OCSM_CONPMTR                    ) return ocsm_conpmtr;
    if (icode == OCSM_DESPMTR                    ) return ocsm_despmtr;
    if (icode == OCSM_OUTPMTR                    ) return ocsm_outpmtr;
    if (icode == OCSM_LBOUND                     ) return ocsm_lbound;
    if (icode == OCSM_UBOUND                     ) return ocsm_ubound;
    if (icode == OCSM_NAME                       ) return ocsm_name;
    if (icode == OCSM_ATTRIBUTE                  ) return ocsm_attribute;
    if (icode == OCSM_CSYSTEM                    ) return ocsm_csystem;

    /* OCSM_PRIMITIVE */
    if (icode == OCSM_POINT                      ) return ocsm_point;
    if (icode == OCSM_BOX                        ) return ocsm_box;
    if (icode == OCSM_SPHERE                     ) return ocsm_sphere;
    if (icode == OCSM_CONE                       ) return ocsm_cone;
    if (icode == OCSM_CYLINDER                   ) return ocsm_cylinder;
    if (icode == OCSM_TORUS                      ) return ocsm_torus;
    if (icode == OCSM_IMPORT                     ) return ocsm_import;
    if (icode == OCSM_UDPRIM                     ) return ocsm_udprim;
    if (icode == OCSM_RESTORE                    ) return ocsm_restore;

    /* OCSM_GROWN */
    if (icode == OCSM_EXTRUDE                    ) return ocsm_extrude;
    if (icode == OCSM_RULE                       ) return ocsm_rule;
    if (icode == OCSM_LOFT                       ) return ocsm_loft;
    if (icode == OCSM_BLEND                      ) return ocsm_blend;
    if (icode == OCSM_REVOLVE                    ) return ocsm_revolve;
    if (icode == OCSM_SWEEP                      ) return ocsm_sweep;

    /* OCSM_APPLIED */
    if (icode == OCSM_FILLET                     ) return ocsm_fillet;
    if (icode == OCSM_CHAMFER                    ) return ocsm_chamfer;
    if (icode == OCSM_HOLLOW                     ) return ocsm_hollow;
    if (icode == OCSM_CONNECT                    ) return ocsm_connect;

    /* OCSM_BOOLEAN */
    if (icode == OCSM_INTERSECT                  ) return ocsm_intersect;
    if (icode == OCSM_SUBTRACT                   ) return ocsm_subtract;
    if (icode == OCSM_UNION                      ) return ocsm_union;
    if (icode == OCSM_JOIN                       ) return ocsm_join;
    if (icode == OCSM_EXTRACT                    ) return ocsm_extract;
    if (icode == OCSM_COMBINE                    ) return ocsm_combine;

    /* OCSM_TRANSFORM */
    if (icode == OCSM_TRANSLATE                  ) return ocsm_translate;
    if (icode == OCSM_ROTATEX                    ) return ocsm_rotatex;
    if (icode == OCSM_ROTATEY                    ) return ocsm_rotatey;
    if (icode == OCSM_ROTATEZ                    ) return ocsm_rotatez;
    if (icode == OCSM_SCALE                      ) return ocsm_scale;
    if (icode == OCSM_MIRROR                     ) return ocsm_mirror;
    if (icode == OCSM_APPLYCSYS                  ) return ocsm_applycsys;
    if (icode == OCSM_REORDER                    ) return ocsm_reorder;

    /* OCSM_SKETCH */
    if (icode == OCSM_SKBEG                      ) return ocsm_skbeg;
    if (icode == OCSM_SKCON                      ) return ocsm_skcon;
    if (icode == OCSM_SKVAR                      ) return ocsm_skvar;
    if (icode == OCSM_LINSEG                     ) return ocsm_linseg;
    if (icode == OCSM_CIRARC                     ) return ocsm_cirarc;
    if (icode == OCSM_ARC                        ) return ocsm_arc;
    if (icode == OCSM_SPLINE                     ) return ocsm_spline;
    if (icode == OCSM_SSLOPE                     ) return ocsm_sslope;
    if (icode == OCSM_BEZIER                     ) return ocsm_bezier;
    if (icode == OCSM_SKEND                      ) return ocsm_skend;

    /* OCSM_SOLVER */
    if (icode == OCSM_SOLBEG                     ) return ocsm_solbeg;
    if (icode == OCSM_SOLCON                     ) return ocsm_solcon;
    if (icode == OCSM_SOLEND                     ) return ocsm_solend;

    /* OCSM_UTILITY */
    if (icode == OCSM_INTERFACE                  ) return ocsm_interface;
    if (icode == OCSM_END                        ) return ocsm_end;
    if (icode == OCSM_SET                        ) return ocsm_set;
    if (icode == OCSM_EVALUATE                   ) return ocsm_evaluate;
    if (icode == OCSM_GETATTR                    ) return ocsm_getattr;
    if (icode == OCSM_UDPARG                     ) return ocsm_udparg;
    if (icode == OCSM_SELECT                     ) return ocsm_select;
    if (icode == OCSM_PROJECT                    ) return ocsm_project;
    if (icode == OCSM_MACBEG                     ) return ocsm_macbeg;
    if (icode == OCSM_MACEND                     ) return ocsm_macend;
    if (icode == OCSM_RECALL                     ) return ocsm_recall;
    if (icode == OCSM_STORE                      ) return ocsm_store;
    if (icode == OCSM_PATBEG                     ) return ocsm_patbeg;
    if (icode == OCSM_PATBREAK                   ) return ocsm_patbreak;
    if (icode == OCSM_PATEND                     ) return ocsm_patend;
    if (icode == OCSM_IFTHEN                     ) return ocsm_ifthen;
    if (icode == OCSM_ELSEIF                     ) return ocsm_elseif;
    if (icode == OCSM_ELSE                       ) return ocsm_else;
    if (icode == OCSM_ENDIF                      ) return ocsm_endif;
    if (icode == OCSM_THROW                      ) return ocsm_throw;
    if (icode == OCSM_CATBEG                     ) return ocsm_catbeg;
    if (icode == OCSM_CATEND                     ) return ocsm_catend;
    if (icode == OCSM_MARK                       ) return ocsm_mark;
    if (icode == OCSM_GROUP                      ) return ocsm_group;
    if (icode == OCSM_DUMP                       ) return ocsm_dump;
    if (icode == OCSM_ASSERT                     ) return ocsm_assert;
    if (icode == OCSM_SPECIAL                    ) return ocsm_special;

    /* Branch classes */
    if (icode == OCSM_PRIMITIVE                  ) return ocsm_primitive;
    if (icode == OCSM_GROWN                      ) return ocsm_grown;
    if (icode == OCSM_APPLIED                    ) return ocsm_applied;
    if (icode == OCSM_BOOLEAN                    ) return ocsm_boolean;
    if (icode == OCSM_TRANSFORM                  ) return ocsm_transform;
    if (icode == OCSM_SKETCH                     ) return ocsm_sketch;
    if (icode == OCSM_SOLVER                     ) return ocsm_solver;
    if (icode == OCSM_UTILITY                    ) return ocsm_utility;

    /* Branch activities */
    if (icode == OCSM_ACTIVE                     ) return ocsm_active;
    if (icode == OCSM_SUPPRESSED                 ) return ocsm_suppressed;
    if (icode == OCSM_INACTIVE                   ) return ocsm_inactive;
    if (icode == OCSM_DEFERRED                   ) return ocsm_deferred;

    /* Body types */
    if (icode == OCSM_SOLID_BODY                 ) return ocsm_solid_body;
    if (icode == OCSM_SHEET_BODY                 ) return ocsm_sheet_body;
    if (icode == OCSM_WIRE_BODY                  ) return ocsm_wire_body;
    if (icode == OCSM_NODE_BODY                  ) return ocsm_node_body;
    if (icode == OCSM_NULL_BODY                  ) return ocsm_null_body;

    /* Parameter types */
    if (icode == OCSM_EXTERNAL                   ) return ocsm_external;
    if (icode == OCSM_CONFIG                     ) return ocsm_config;
    if (icode == OCSM_CONSTANT                   ) return ocsm_constant;
    if (icode == OCSM_INTERNAL                   ) return ocsm_internal;
    if (icode == OCSM_OUTPUT                     ) return ocsm_output;
    if (icode == OCSM_UNKNOWN                    ) return ocsm_unknown;

    /* Selector types */
    if (icode == OCSM_NODE                       ) return ocsm_node;
    if (icode == OCSM_EDGE                       ) return ocsm_edge;
    if (icode == OCSM_FACE                       ) return ocsm_face;
    if (icode == OCSM_BODY                       ) return ocsm_body;

     /* Error codes */
    if (icode == OCSM_FILE_NOT_FOUND             ) return ocsm_file_not_found;
    if (icode == OCSM_ILLEGAL_STATEMENT          ) return ocsm_illegal_statement;
    if (icode == OCSM_NOT_ENOUGH_ARGS            ) return ocsm_not_enough_args;
    if (icode == OCSM_NAME_ALREADY_DEFINED       ) return ocsm_name_already_defined;
    if (icode == OCSM_NESTED_TOO_DEEPLY          ) return ocsm_nested_too_deeply;
    if (icode == OCSM_IMPROPER_NESTING           ) return ocsm_improper_nesting;
    if (icode == OCSM_NESTING_NOT_CLOSED         ) return ocsm_nesting_not_closed;
    if (icode == OCSM_NOT_MODL_STRUCTURE         ) return ocsm_not_modl_structure;
    if (icode == OCSM_PROBLEM_CREATING_PERTURB   ) return ocsm_problem_creating_perturb;

    if (icode == OCSM_MISSING_MARK               ) return ocsm_missing_mark;
    if (icode == OCSM_INSUFFICIENT_BODYS_ON_STACK) return ocsm_insufficient_bodys_on_stack;
    if (icode == OCSM_WRONG_TYPES_ON_STACK       ) return ocsm_wrong_types_on_stack;
    if (icode == OCSM_DID_NOT_CREATE_BODY        ) return ocsm_did_not_create_body;
    if (icode == OCSM_CREATED_TOO_MANY_BODYS     ) return ocsm_created_too_many_bodys;
    if (icode == OCSM_TOO_MANY_BODYS_ON_STACK    ) return ocsm_too_many_bodys_on_stack;
    if (icode == OCSM_ERROR_IN_BODYS_ON_STACK    ) return ocsm_error_in_bodys_on_stack;
    if (icode == OCSM_MODL_NOT_CHECKED           ) return ocsm_modl_not_checked;
    if (icode == OCSM_NEED_TESSELLATION          ) return ocsm_need_tessellation;

    if (icode == OCSM_BODY_NOT_FOUND             ) return ocsm_body_not_found;
    if (icode == OCSM_FACE_NOT_FOUND             ) return ocsm_face_not_found;
    if (icode == OCSM_EDGE_NOT_FOUND             ) return ocsm_edge_not_found;
    if (icode == OCSM_NODE_NOT_FOUND             ) return ocsm_node_not_found;
    if (icode == OCSM_ILLEGAL_VALUE              ) return ocsm_illegal_value;
    if (icode == OCSM_ILLEGAL_ATTRIBUTE          ) return ocsm_illegal_attribute;
    if (icode == OCSM_ILLEGAL_CSYSTEM            ) return ocsm_illegal_csystem;
    if (icode == OCSM_NO_SELECTION               ) return ocsm_no_selection;

    if (icode == OCSM_SKETCH_IS_OPEN             ) return ocsm_sketch_is_open;
    if (icode == OCSM_SKETCH_IS_NOT_OPEN         ) return ocsm_sketch_is_not_open;
    if (icode == OCSM_COLINEAR_SKETCH_POINTS     ) return ocsm_colinear_sketch_points;
    if (icode == OCSM_NON_COPLANAR_SKETCH_POINTS ) return ocsm_non_coplanar_sketch_points;
    if (icode == OCSM_TOO_MANY_SKETCH_POINTS     ) return ocsm_too_many_sketch_points;
    if (icode == OCSM_TOO_FEW_SPLINE_POINTS      ) return ocsm_too_few_spline_points;
    if (icode == OCSM_SKETCH_DOES_NOT_CLOSE      ) return ocsm_sketch_does_not_close;
    if (icode == OCSM_SELF_INTERSECTING          ) return ocsm_self_intersecting;
    if (icode == OCSM_ASSERT_FAILED              ) return ocsm_assert_failed;

    if (icode == OCSM_ILLEGAL_CHAR_IN_EXPR       ) return ocsm_illegal_char_in_expr;
    if (icode == OCSM_CLOSE_BEFORE_OPEN          ) return ocsm_close_before_open;
    if (icode == OCSM_MISSING_CLOSE              ) return ocsm_missing_close;
    if (icode == OCSM_ILLEGAL_TOKEN_SEQUENCE     ) return ocsm_illegal_token_sequence;
    if (icode == OCSM_ILLEGAL_NUMBER             ) return ocsm_illegal_number;
    if (icode == OCSM_ILLEGAL_PMTR_NAME          ) return ocsm_illegal_pmtr_name;
    if (icode == OCSM_ILLEGAL_FUNC_NAME          ) return ocsm_illegal_func_name;
    if (icode == OCSM_ILLEGAL_TYPE               ) return ocsm_illegal_type;
    if (icode == OCSM_ILLEGAL_NARG               ) return ocsm_illegal_narg;

    if (icode == OCSM_NAME_NOT_FOUND             ) return ocsm_name_not_found;
    if (icode == OCSM_NAME_NOT_UNIQUE            ) return ocsm_name_not_unique;
    if (icode == OCSM_PMTR_IS_EXTERNAL           ) return ocsm_pmtr_is_external;
    if (icode == OCSM_PMTR_IS_INTERNAL           ) return ocsm_pmtr_is_internal;
    if (icode == OCSM_PMTR_IS_OUTPUT             ) return ocsm_pmtr_is_output;
    if (icode == OCSM_PMTR_IS_CONSTANT           ) return ocsm_pmtr_is_constant;
    if (icode == OCSM_WRONG_PMTR_TYPE            ) return ocsm_wrong_pmtr_type;
    if (icode == OCSM_FUNC_ARG_OUT_OF_BOUNDS     ) return ocsm_func_arg_out_of_bounds;
    if (icode == OCSM_VAL_STACK_UNDERFLOW        ) return ocsm_val_stack_underflow;
    if (icode == OCSM_VAL_STACK_OVERFLOW         ) return ocsm_val_stack_overflow;

    if (icode == OCSM_ILLEGAL_BRCH_INDEX         ) return ocsm_illegal_brch_index;
    if (icode == OCSM_ILLEGAL_PMTR_INDEX         ) return ocsm_illegal_pmtr_index;
    if (icode == OCSM_ILLEGAL_BODY_INDEX         ) return ocsm_illegal_body_index;
    if (icode == OCSM_ILLEGAL_ARG_INDEX          ) return ocsm_illegal_arg_index;
    if (icode == OCSM_ILLEGAL_ACTIVITY           ) return ocsm_illegal_activity;
    if (icode == OCSM_ILLEGAL_MACRO_INDEX        ) return ocsm_illegal_macro_index;
    if (icode == OCSM_ILLEGAL_ARGUMENT           ) return ocsm_illegal_argument;
    if (icode == OCSM_CANNOT_BE_SUPPRESSED       ) return ocsm_cannot_be_suppressed;
    if (icode == OCSM_STORAGE_ALREADY_USED       ) return ocsm_storage_already_used;
    if (icode == OCSM_NOTHING_PREVIOUSLY_STORED  ) return ocsm_nothing_previously_stored;

    if (icode == OCSM_SOLVER_IS_OPEN             ) return ocsm_solver_is_open;
    if (icode == OCSM_SOLVER_IS_NOT_OPEN         ) return ocsm_solver_is_not_open;
    if (icode == OCSM_TOO_MANY_SOLVER_VARS       ) return ocsm_too_many_solver_vars;
    if (icode == OCSM_UNDERCONSTRAINED           ) return ocsm_underconstrained;
    if (icode == OCSM_OVERCONSTRAINED            ) return ocsm_overconstrained;
    if (icode == OCSM_SINGULAR_MATRIX            ) return ocsm_singular_matrix;
    if (icode == OCSM_NOT_CONVERGED              ) return ocsm_not_converged;

    if (icode == OCSM_UDP_ERROR1                 ) return ocsm_udp_error1;
    if (icode == OCSM_UDP_ERROR2                 ) return ocsm_udp_error2;
    if (icode == OCSM_UDP_ERROR3                 ) return ocsm_udp_error3;
    if (icode == OCSM_UDP_ERROR4                 ) return ocsm_udp_error4;
    if (icode == OCSM_UDP_ERROR5                 ) return ocsm_udp_error5;
    if (icode == OCSM_UDP_ERROR6                 ) return ocsm_udp_error6;
    if (icode == OCSM_UDP_ERROR7                 ) return ocsm_udp_error7;
    if (icode == OCSM_UDP_ERROR8                 ) return ocsm_udp_error8;
    if (icode == OCSM_UDP_ERROR9                 ) return ocsm_udp_error9;

    if (icode == OCSM_OP_STACK_UNDERFLOW         ) return ocsm_op_stack_underflow;
    if (icode == OCSM_OP_STACK_OVERFLOW          ) return ocsm_op_stack_overflow;
    if (icode == OCSM_RPN_STACK_UNDERFLOW        ) return ocsm_rpn_stack_underflow;
    if (icode == OCSM_RPN_STACK_OVERFLOW         ) return ocsm_rpn_stack_overflow;
    if (icode == OCSM_TOKEN_STACK_UNDERFLOW      ) return ocsm_token_stack_underflow;
    if (icode == OCSM_TOKEN_STACK_OVERFLOW       ) return ocsm_token_stack_overflow;
    if (icode == OCSM_UNSUPPORTED                ) return ocsm_unsupported;
    if (icode == OCSM_INTERNAL_ERROR             ) return ocsm_internal_error;

    /* EGADS errors */
    if (icode == EGADS_NOTFOUND                  ) return egads_notfound;
    if (icode == EGADS_NULLOBJ                   ) return egads_nullobj;
    if (icode == EGADS_NOTOBJ                    ) return egads_notobj;
    if (icode == EGADS_MALLOC                    ) return egads_malloc;
    if (icode == EGADS_INDEXERR                  ) return egads_indexerr;
    if (icode == EGADS_NONAME                    ) return egads_noname;
    if (icode == EGADS_NODATA                    ) return egads_nodata;
    if (icode == EGADS_MIXCNTX                   ) return egads_mixcntx;
    if (icode == EGADS_NOTCNTX                   ) return egads_notcntx;
    if (icode == EGADS_NOTXFORM                  ) return egads_notxform;
    if (icode == EGADS_REFERCE                   ) return egads_referce;
    if (icode == EGADS_NOTTOPO                   ) return egads_nottopo;
    if (icode == EGADS_EMPTY                     ) return egads_empty;
    if (icode == EGADS_NOTTESS                   ) return egads_nottess;
    if (icode == EGADS_NOTGEOM                   ) return egads_notgeom;
    if (icode == EGADS_RANGERR                   ) return egads_rangerr;
    if (icode == EGADS_NOLOAD                    ) return egads_noload;
    if (icode == EGADS_NOTMODEL                  ) return egads_notmodel;
    if (icode == EGADS_WRITERR                   ) return egads_writerr;
    if (icode == EGADS_NOTBODY                   ) return egads_notbody;
    if (icode == EGADS_GEOMERR                   ) return egads_geomerr;
    if (icode == EGADS_TOPOERR                   ) return egads_topoerr;
    if (icode == EGADS_CONSTERR                  ) return egads_consterr;
    if (icode == EGADS_DEGEN                     ) return egads_degen;
    if (icode == EGADS_NOTORTHO                  ) return egads_notortho;
    if (icode == EGADS_BADSCALE                  ) return egads_badscale;
    if (icode == EGADS_OCSEGFLT                  ) return egads_ocsegflt;
    if (icode == EGADS_TOPOCNT                   ) return egads_topocnt;
    if (icode == EGADS_ATTRERR                   ) return egads_attrerr;
    if (icode == EGADS_EXISTS                    ) return egads_exists;

    /* default return */
    return unknown;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetCode - convert text to an OCSM code                         *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetCode(char   *text)               /* (in)  text to look up */
{

    /* --------------------------------------------------------------- */

    /* OCSM_SUCCESS */
    if (strcmp(text, "success"   ) == 0) return SUCCESS;

    /* not a branch */
    if (strcmp(text, "dimension" ) == 0) return OCSM_DIMENSION;
    if (strcmp(text, "cfgpmtr"   ) == 0) return OCSM_CFGPMTR;
    if (strcmp(text, "conpmtr"   ) == 0) return OCSM_CONPMTR;
    if (strcmp(text, "despmtr"   ) == 0) return OCSM_DESPMTR;
    if (strcmp(text, "outpmtr"   ) == 0) return OCSM_OUTPMTR;
    if (strcmp(text, "lbound"    ) == 0) return OCSM_LBOUND;
    if (strcmp(text, "ubound"    ) == 0) return OCSM_UBOUND;
    if (strcmp(text, "name"      ) == 0) return OCSM_NAME;
    if (strcmp(text, "attribute" ) == 0) return OCSM_ATTRIBUTE;
    if (strcmp(text, "csystem"   ) == 0) return OCSM_CSYSTEM;
    if (strcmp(text, "end"       ) == 0) return OCSM_END;

    /* OCSM_PRIMITIVE */
    if (strcmp(text, "point"     ) == 0) return OCSM_POINT;
    if (strcmp(text, "box"       ) == 0) return OCSM_BOX;
    if (strcmp(text, "sphere"    ) == 0) return OCSM_SPHERE;
    if (strcmp(text, "cone"      ) == 0) return OCSM_CONE;
    if (strcmp(text, "cylinder"  ) == 0) return OCSM_CYLINDER;
    if (strcmp(text, "torus"     ) == 0) return OCSM_TORUS;
    if (strcmp(text, "import"    ) == 0) return OCSM_IMPORT;
    if (strcmp(text, "udprim"    ) == 0) return OCSM_UDPRIM;
    if (strcmp(text, "restore"   ) == 0) return OCSM_RESTORE;

    /* OCSM_GROWN */
    if (strcmp(text, "extrude"   ) == 0) return OCSM_EXTRUDE;
    if (strcmp(text, "rule"      ) == 0) return OCSM_RULE;
    if (strcmp(text, "loft"      ) == 0) return OCSM_LOFT;
    if (strcmp(text, "blend"     ) == 0) return OCSM_BLEND;
    if (strcmp(text, "revolve"   ) == 0) return OCSM_REVOLVE;
    if (strcmp(text, "sweep"     ) == 0) return OCSM_SWEEP;

    /* OCSM_APPLIED */
    if (strcmp(text, "fillet"    ) == 0) return OCSM_FILLET;
    if (strcmp(text, "chamfer"   ) == 0) return OCSM_CHAMFER;
    if (strcmp(text, "hollow"    ) == 0) return OCSM_HOLLOW;
    if (strcmp(text, "connect"   ) == 0) return OCSM_CONNECT;

    /* OCSM_BOOLEAN */
    if (strcmp(text, "intersect" ) == 0) return OCSM_INTERSECT;
    if (strcmp(text, "subtract"  ) == 0) return OCSM_SUBTRACT;
    if (strcmp(text, "union"     ) == 0) return OCSM_UNION;
    if (strcmp(text, "join"      ) == 0) return OCSM_JOIN;
    if (strcmp(text, "extract"   ) == 0) return OCSM_EXTRACT;
    if (strcmp(text, "combine"   ) == 0) return OCSM_COMBINE;

    /* OCSM_TRANSFORM */
    if (strcmp(text, "translate" ) == 0) return OCSM_TRANSLATE;
    if (strcmp(text, "rotatex"   ) == 0) return OCSM_ROTATEX;
    if (strcmp(text, "rotatey"   ) == 0) return OCSM_ROTATEY;
    if (strcmp(text, "rotatez"   ) == 0) return OCSM_ROTATEZ;
    if (strcmp(text, "scale"     ) == 0) return OCSM_SCALE;
    if (strcmp(text, "mirror"    ) == 0) return OCSM_MIRROR;
    if (strcmp(text, "applycsys" ) == 0) return OCSM_APPLYCSYS;
    if (strcmp(text, "reorder"   ) == 0) return OCSM_REORDER;

    /* OCSM_SKETCH */
    if (strcmp(text, "skbeg"     ) == 0) return OCSM_SKBEG;
    if (strcmp(text, "skcon"     ) == 0) return OCSM_SKCON;
    if (strcmp(text, "skvar"     ) == 0) return OCSM_SKVAR;
    if (strcmp(text, "linseg"    ) == 0) return OCSM_LINSEG;
    if (strcmp(text, "cirarc"    ) == 0) return OCSM_CIRARC;
    if (strcmp(text, "arc"       ) == 0) return OCSM_ARC;
    if (strcmp(text, "spline"    ) == 0) return OCSM_SPLINE;
    if (strcmp(text, "sslope"    ) == 0) return OCSM_SSLOPE;
    if (strcmp(text, "bezier"    ) == 0) return OCSM_BEZIER;
    if (strcmp(text, "skend"     ) == 0) return OCSM_SKEND;

    /* OCSM_SOLVER */
    if (strcmp(text, "solbeg"    ) == 0) return OCSM_SOLBEG;
    if (strcmp(text, "solcon"    ) == 0) return OCSM_SOLCON;
    if (strcmp(text, "solend"    ) == 0) return OCSM_SOLEND;

    /* OCSM_UTILITY */
    if (strcmp(text, "interface" ) == 0) return OCSM_INTERFACE;
    if (strcmp(text, "end"       ) == 0) return OCSM_END;
    if (strcmp(text, "set"       ) == 0) return OCSM_SET;
    if (strcmp(text, "evaluate"  ) == 0) return OCSM_EVALUATE;
    if (strcmp(text, "getattr"   ) == 0) return OCSM_GETATTR;
    if (strcmp(text, "udparg"    ) == 0) return OCSM_UDPARG;
    if (strcmp(text, "select"    ) == 0) return OCSM_SELECT;
    if (strcmp(text, "project"   ) == 0) return OCSM_PROJECT;
    if (strcmp(text, "macbeg"    ) == 0) return OCSM_MACBEG;
    if (strcmp(text, "macend"    ) == 0) return OCSM_MACEND;
    if (strcmp(text, "recall"    ) == 0) return OCSM_RECALL;
    if (strcmp(text, "store"     ) == 0) return OCSM_STORE;
    if (strcmp(text, "patbeg"    ) == 0) return OCSM_PATBEG;
    if (strcmp(text, "patbreak"  ) == 0) return OCSM_PATBREAK;
    if (strcmp(text, "patend"    ) == 0) return OCSM_PATEND;
    if (strcmp(text, "ifthen"    ) == 0) return OCSM_IFTHEN;
    if (strcmp(text, "elseif"    ) == 0) return OCSM_ELSEIF;
    if (strcmp(text, "else"      ) == 0) return OCSM_ELSE;
    if (strcmp(text, "endif"     ) == 0) return OCSM_ENDIF;
    if (strcmp(text, "throw"     ) == 0) return OCSM_THROW;
    if (strcmp(text, "catbeg"    ) == 0) return OCSM_CATBEG;
    if (strcmp(text, "catend"    ) == 0) return OCSM_CATEND;
    if (strcmp(text, "mark"      ) == 0) return OCSM_MARK;
    if (strcmp(text, "group"     ) == 0) return OCSM_GROUP;
    if (strcmp(text, "dump"      ) == 0) return OCSM_DUMP;
    if (strcmp(text, "assert"    ) == 0) return OCSM_ASSERT;
    if (strcmp(text, "special"   ) == 0) return OCSM_SPECIAL;

    /* Branch classes */
    if (strcmp(text, "primitive" ) == 0) return OCSM_PRIMITIVE;
    if (strcmp(text, "grown"     ) == 0) return OCSM_GROWN;
    if (strcmp(text, "applied"   ) == 0) return OCSM_APPLIED;
    if (strcmp(text, "boolean"   ) == 0) return OCSM_BOOLEAN;
    if (strcmp(text, "transform" ) == 0) return OCSM_TRANSFORM;
    if (strcmp(text, "sketch"    ) == 0) return OCSM_SKETCH;
    if (strcmp(text, "solver"    ) == 0) return OCSM_SOLVER;
    if (strcmp(text, "utility"   ) == 0) return OCSM_UTILITY;

    /* Branch activities */
    if (strcmp(text, "active"    ) == 0) return OCSM_ACTIVE;
    if (strcmp(text, "suppressed") == 0) return OCSM_SUPPRESSED;
    if (strcmp(text, "inactive"  ) == 0) return OCSM_INACTIVE;
    if (strcmp(text, "deferred"  ) == 0) return OCSM_DEFERRED;

    /* Body types */
    if (strcmp(text, "solid_body") == 0) return OCSM_SOLID_BODY;
    if (strcmp(text, "sheet_body") == 0) return OCSM_SHEET_BODY;
    if (strcmp(text, "wire_body" ) == 0) return OCSM_WIRE_BODY;
    if (strcmp(text, "node_body" ) == 0) return OCSM_NODE_BODY;
    if (strcmp(text, "null_body" ) == 0) return OCSM_NULL_BODY;

    /* Parameter types */
    if (strcmp(text, "external"  ) == 0) return OCSM_EXTERNAL;
    if (strcmp(text, "config"    ) == 0) return OCSM_CONFIG;
    if (strcmp(text, "constant"  ) == 0) return OCSM_CONSTANT;
    if (strcmp(text, "internal"  ) == 0) return OCSM_INTERNAL;
    if (strcmp(text, "output"    ) == 0) return OCSM_OUTPUT;
    if (strcmp(text, "unknown"   ) == 0) return OCSM_UNKNOWN;

    /* Selector type */
    if (strcmp(text, "node"      ) == 0) return OCSM_NODE;
    if (strcmp(text, "edge"      ) == 0) return OCSM_EDGE;
    if (strcmp(text, "face"      ) == 0) return OCSM_FACE;
    if (strcmp(text, "body"      ) == 0) return OCSM_BODY;

    return 0;
}


/*
 ************************************************************************
 *                                                                      *
 *   adjustFileSpec - adjust filename spec for UDPARG and UDPRIM        *
 *                                                                      *
 ************************************************************************
 */

static int
adjustFileSpec(FILE   *csm_file,        /* (in)  pointer to current .csm file */
               char   filename[],       /* (in)  current filename */
               int    *linenum,         /* (both) current line number */
               char   str[])            /* (both) argument */
{
    int       status = SUCCESS;         /* (out) return status */

    int       itmp, i;
    char      tmpfilename[MAX_LINE_LEN], tmpfileline[MAX_LINE_LEN];
    char      pathname[MAX_EXPR_LEN];
    FILE      *tmp_file=NULL;

    ROUTINE(adjustFileSpec);

    /* --------------------------------------------------------------- */

    if (strncmp(str, "<<", MAX_EXPR_LEN) == 0) {

        /* look for a tmp file that does not exist */
        for (itmp = 0; itmp < 999; itmp++) {
            sprintf(tmpfilename, "tmp_OpenCSM_%03d", itmp);

            tmp_file = fopen(tmpfilename, "r");
            if (tmp_file != NULL) {
                fclose(tmp_file);
                continue;
            }

            /* we found an unused tmp file, so copy from filename to tmpfilename now */
            tmp_file = fopen(tmpfilename, "w");
            if (tmp_file != NULL) {
                while (1) {
                    (*linenum)++;
                    if (fgets(tmpfileline, MAX_LINE_LEN, csm_file) == NULL) break;

                    if (strncmp(tmpfileline, ">>", 2) == 0) {
                        break;
                    }

                    itmp = fputs(tmpfileline, tmp_file);
                    if (itmp < 0) break;
                }

                fclose(tmp_file);
                tmp_file = NULL;
                SPRINT1(1, "--> diverting inputs to tmp file \"%s\"", tmpfilename);

                sprintf(str, "$%s", tmpfilename);

                break;
            }
        }
    }

    /* convert arguments that start with "$/" to relative pathnames */
    if (strncmp(str, "$$/", 3) == 0) {
        STRNCPY(pathname, filename, MAX_EXPR_LEN);
        i = STRLEN(pathname) - 1;
        while (pathname[i] != SLASH) {
            pathname[i] = '\0';
            i--;
            if (i < 0) break;
        }
        STRNCPY(tmpfilename, &(str[3]), MAX_EXPR_LEN);
        snprintf(str, MAX_EXPR_LEN, "$%s%s", pathname, tmpfilename);
    }

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildApplied - implement OCSM_APPLIEDs for ocsmBuild               *
 *                                                                      *
 ************************************************************************
 */

static int
buildApplied(modl_T *modl,              /* (in)  pointer to MODL */
             int    ibrch,              /* (in)  Branch index (bias-1) */
             varg_T args[],             /* (in)  array of arguments */
             int    *nstack,            /* (both) number of Bodys on stack */
             int    stack[],            /* (both) array  of Bodys on stack */
             int    npatn,              /* (in)   number of patterns */
             patn_T patn[])             /* (both) array  of patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        nelist, *ielist=NULL, *iford1=NULL, *iford2=NULL;
    int        itype, nlist, type, hasdots, i, j, iedge, iface, nface, nedge, nloop;
    int        jford1, jford2, ibody, ibodyl, iprnt, jbrch, ipair, npair;
    CINT       *tempIlist;
    double     toler;
    CDOUBLE    *tempRlist;
    CCHAR      *tempClist;

    int        iford, nremove=0, nf, oclass, mtype, nchild, *senses, imatch, ilist;
    int        nfacemap, *facemap1=NULL, *facemap2=NULL, iswap;
    double     data[4];
    ego        ebody, ebodyl, *eedges, *efaces, emodel, eref, *echilds;
    ego        *eelist=NULL, *eflist=NULL, eshell, *eloops, eloop, eface;

    ROUTINE(buildApplied);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "fillet radius edgeList=0 listStyle=0" */
    if (type == OCSM_FILLET) {
        SPRINT4(1, "    executing [%4d] fillet:     %11.5f  %s  %11.5f",
                ibrch, args[1].val[0], MODL->brch[ibrch].arg2, args[3].val[0]);
        if (args[1].dot[0] != 0) {
            hasdots = 1;

            SPRINT1(1, "                                 %11.5f",
                       args[1].dot[0]);
        }

        /* check for a positive radius */
        if (args[1].val[0] <= 0) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius (%f) must be positive", args[1].val[0]);
            goto cleanup;
        }

        /* pop a Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "FILLET expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that ibodyl is not a Sketch */
        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "FILLET does not expect a Sketch on the stack");
            goto cleanup;
        }

        /* cycle back from ibodyl to find the closest left parent Body that
           was either a PRIMITIVE, GROWN, or BOOLEAN */
        iprnt = ibodyl;
        while (iprnt != 0) {
            jbrch = MODL->body[iprnt].ibrch;
            if (MODL->brch[jbrch].bclass == OCSM_PRIMITIVE ||
                MODL->brch[jbrch].bclass == OCSM_GROWN     ||
                MODL->brch[jbrch].bclass == OCSM_BOOLEAN     ) break;
            iprnt = MODL->body[iprnt].ileft;
        }

        /* initialize the list of Edges to which fillets should be applied */
        nelist = 0;
        MALLOC(ielist, int, MODL->body[ibodyl].nedge);

        /* apply fillet to all Edges if edgeList=0 AND parent is a RESTORE */
        if (args[2].nval == 1 && args[2].val[0] == 0  &&
            MODL->body[ibodyl].brtype == OCSM_RESTORE  ) {

            for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {
                ielist[nelist++] = iedge;
            }

        /* apply fillet to all Edges in edgeList if listStyle=1 */
        } else if (args[3].val[0] != 0) {
            nelist = args[2].nval;
            if (nelist < 1) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "edgeList must contain at least one Edge");
                goto cleanup;
            }

            for (i = 0; i < nelist; i++) {
                ielist[i] = NINT(args[2].val[i]);
            }

        /* apply fillet to all Edges if edgeList=0 OR iprnt is a Boolean */
        } else if ((args[2].nval == 1 && args[2].val[0] == 0) ||
                   MODL->body[iprnt].brtype == OCSM_INTERSECT ||
                   MODL->body[iprnt].brtype == OCSM_SUBTRACT  ||
                   MODL->body[iprnt].brtype == OCSM_UNION     ||
                   MODL->body[iprnt].brtype == OCSM_JOIN        ) {

            ebodyl = MODL->body[ibodyl].ebody;

            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            for (iedge = 1; iedge <= nedge; iedge++) {
                status = EG_attributeRet(eedges[iedge-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlist[0] == iprnt) {
                    ielist[nelist++] = iedge;
                }
            }

            EG_free(eedges);

        /* otherwise, process the edgeList (in order) */
        } else {

            if (args[2].nval%2 != 0) {
                signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                            "not an even number of entries in edgeList");
                goto cleanup;
            }

            npair = args[2].nval / 2;
            MALLOC(iford1, int, npair);
            MALLOC(iford2, int, npair);

            for (ipair = 0; ipair < npair; ipair++) {
                iford1[ipair] = NINT(args[2].val[2*ipair  ]);
                iford2[ipair] = NINT(args[2].val[2*ipair+1]);
            }

            /* make sure that we have at least one pair */
            if (npair <= 0) {
                SET_STATUS(OCSM_ILLEGAL_PMTR_NAME, fillet);
            }

            /* process the pairs */
            for (ipair = 0; ipair < npair; ipair++) {

                /* add all Edges to ielist */
                if (iford1[ipair] == 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        if (tempIlist[0] == iprnt) {
                            ielist[nelist++] = iedge;
                        }
                    }

                    EG_free(eedges);

                /* add Edges adjacent to +iford1[ipair] */
                } else if (iford1[ipair] > 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        jford1 = tempIlist[1] % 100;
                        jford2 = tempIlist[1] / 100;

                        if (tempIlist[0] == iprnt) {
                            if (jford1 == iford1[ipair] || jford2 == iford1[ipair]) {
                                ielist[nelist++] = iedge;
                            }
                        }
                    }

                    EG_free(eedges);

                /* remove all Edges adjacent to -iford1[ipair] */
                } else if (iford1[ipair] < 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        jford1 = tempIlist[1] % 100;
                        jford2 = tempIlist[1] / 100;

                        if (tempIlist[0] == iprnt) {
                            if (jford1 == -iford1[ipair] || jford2 == -iford1[ipair]) {
                                for (j = 0; j < nelist; j++) {
                                    if (ielist[j] == iedge) {
                                        ielist[j] = 0;
                                    }
                                }
                            }
                        }
                    }

                    EG_free(eedges);

                /* add Edges adjacent to +iford1[ipair] and +iford2[ipair] */
                } else if (iford1[ipair] > 0 && iford2[ipair] > 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        jford1 = tempIlist[1] % 100;
                        jford2 = tempIlist[1] / 100;

                        if (tempIlist[0] == iprnt) {
                            if        (jford1 == iford1[ipair] && jford2 == iford2[ipair]) {
                                ielist[nelist++] = iedge;
                            } else if (jford1 == iford2[ipair] && jford2 == iford1[ipair]) {
                                ielist[nelist++] = iedge;
                            }
                        }
                    }

                    EG_free(eedges);

                /* remove Edges adjacent to -iford1[ipair] and -iford2[ipair] */
                } else if (iford1[ipair] < 0 && iford2[ipair] < 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        jford1 = tempIlist[1] % 100;
                        jford2 = tempIlist[1] / 100;

                        if (tempIlist[0] == iprnt) {
                            if ((jford1 == -iford1[ipair] && jford2 == -iford2[ipair]) ||
                                (jford1 == -iford2[ipair] && jford2 == -iford1[ipair])   ) {
                                for (j = 0; j < nelist; j++) {
                                    if (ielist[j] == iedge) {
                                        ielist[j] = 0;
                                    }
                                }
                            }
                        }
                    }

                    EG_free(eedges);
                }
            }
        }

        /* remove deleted entries from the ielist */
        for (j = 0; j < nelist; j++) {
            if (ielist[j] == 0) {
                ielist[j] = ielist[nelist-1];
                nelist--;
                j--;
            }
        }

        /* create the fillets */
        if (nelist > 0) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_FILLET, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            MALLOC(eelist, ego, nelist);

            for (i = 0; i < nelist; i++) {
                if (ielist[i] < 1 || ielist[i] > nedge) {
                    signalError(MODL, OCSM_EDGE_NOT_FOUND,
                                "%d is not a valid Edge number", ielist[i]);
                    FREE(eelist);
                    EG_free(eedges);
                    goto cleanup;
                }

                SPRINT1(2, "        fillet with iedge=%d", ielist[i]);
                eelist[i] = eedges[ielist[i]-1];
            }

            EG_free(eedges);

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_filletBody: ebodyl");
                ocsmPrintEgo(ebodyl);
            }
            status = EG_filletBody(ebodyl, nelist, eelist, args[1].val[0], &ebody, NULL);
            if (status < SUCCESS) {
                signalError(MODL, status,
                            "FILLET failed");
                freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

            FREE(ielist);
            FREE(eelist);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (FILLET) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces with the current Body */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            for (iface = 1; iface <= nface; iface++) {
                status = EG_attributeRet(efaces[iface-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_NOTFOUND) {
                    status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                } else {
                    CHECK_STATUS(EG_attributeRet);
                }
            }

            EG_free(efaces);

            /* finish the Body (FILLET) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);
        } else {
            SPRINT0(1, "WARNING:: no edges for fillet");
            (MODL->nwarn)++;
            ibody = ibodyl;
        }

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "chamfer radius edgeList=0 listStyle=0" */
    } else if (type == OCSM_CHAMFER) {
        SPRINT4(1, "    executing [%4d] chamfer:    %11.5f  %s  %11.5f",
                ibrch, args[1].val[0], MODL->brch[ibrch].arg2, args[3].val[0]);
        if (args[1].dot[0] != 0) {
            hasdots = 1;

            SPRINT1(1, "                                 %11.5f",
                       args[1].dot[0]);
        }

        /* check for a positive radius */
        if (args[1].val[0] <= 0) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius (%f) must be positive", args[1].val[0]);
            goto cleanup;
        }

        /* pop a Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "CHAMFER expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that ibodyl is not a Sketch */
        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "CHAMFER does not expect a Sketch on the stack");
            goto cleanup;
        }

        /* cycle back from ibodyl to find the closest left parent Body that
           was either a PRIMITIVE, GROWN, or BOOLEAN */
        iprnt = ibodyl;
        while (iprnt != 0) {
            jbrch = MODL->body[iprnt].ibrch;
            if (MODL->brch[jbrch].bclass == OCSM_PRIMITIVE ||
                MODL->brch[jbrch].bclass == OCSM_GROWN     ||
                MODL->brch[jbrch].bclass == OCSM_BOOLEAN     ) break;
            iprnt = MODL->body[iprnt].ileft;
        }

        /* initialize the list of Edges to which chamfers should be applied */
        nelist = 0;
        MALLOC(ielist, int, MODL->body[ibodyl].nedge);

        /* apply chamfer to all Edges if edgeList=0 AND parent is a RESTORE */
        if (args[2].nval == 1 && args[2].val[0] == 0  &&
            MODL->body[ibodyl].brtype == OCSM_RESTORE  ) {

            for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {
                ielist[nelist++] = iedge;
            }

        /* apply chamfer to all Edges in edgeList if listStyle=1 */
        } else if (args[3].val[0] != 0) {
            nelist = args[2].nval;
            if (nelist < 1) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "edgeList must contain at least one Edge");
                goto cleanup;
            }

            for (i = 0; i < nelist; i++) {
                ielist[i] = NINT(args[2].val[i]);
            }

        /* apply chamfer to all Edges if edgeList=0 OR iprnt is a Boolean */
        } else if ((args[2].nval == 1 && args[2].val[0] == 0) ||
                   MODL->body[iprnt].brtype == OCSM_INTERSECT ||
                   MODL->body[iprnt].brtype == OCSM_SUBTRACT  ||
                   MODL->body[iprnt].brtype == OCSM_UNION     ||
                   MODL->body[iprnt].brtype == OCSM_JOIN        ) {

            ebodyl = MODL->body[ibodyl].ebody;

            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            for (iedge = 1; iedge <= nedge; iedge++) {
                status = EG_attributeRet(eedges[iedge-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlist[0] == iprnt) {
                    ielist[nelist++] = iedge;
                }
            }

            EG_free(eedges);

        /* otherwise, process the edgeList (in order) */
        } else {

            if (args[2].nval%2 != 0) {
                signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                            "not an even number of entries in edgeList");
                goto cleanup;
            }

            npair = args[2].nval / 2;
            MALLOC(iford1, int, npair);
            MALLOC(iford2, int, npair);

            for (ipair = 0; ipair < npair; ipair++) {
                iford1[ipair] = NINT(args[2].val[2*ipair  ]);
                iford2[ipair] = NINT(args[2].val[2*ipair+1]);
            }

            /* make sure that we have at least one pair */
            if (npair <= 0) {
                SET_STATUS(OCSM_ILLEGAL_PMTR_NAME, chamfer);
            }

            /* process the pairs */
            for (ipair = 0; ipair < npair; ipair++) {

                /* add all Edges to ielist */
                if (iford1[ipair] == 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        if (tempIlist[0] == iprnt) {
                            ielist[nelist++] = iedge;
                        }
                    }

                    EG_free(eedges);

                /* add Edges adjacent to +iford1[ipair] */
                } else if (iford1[ipair] > 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        jford1 = tempIlist[1] % 100;
                        jford2 = tempIlist[1] / 100;

                        if (tempIlist[0] == iprnt) {
                            if (jford1 == iford1[ipair] || jford2 == iford1[ipair]) {
                                ielist[nelist++] = iedge;
                            }
                        }
                    }

                    EG_free(eedges);

                /* remove all Edges adjacent to -iford1[ipair] */
                } else if (iford1[ipair] < 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        jford1 = tempIlist[1] % 100;
                        jford2 = tempIlist[1] / 100;

                        if (tempIlist[0] == iprnt) {
                            if (jford1 == -iford1[ipair] || jford2 == -iford1[ipair]) {
                                for (j = 0; j < nelist; j++) {
                                    if (ielist[j] == iedge) {
                                        ielist[j] = 0;
                                    }
                                }
                            }
                        }
                    }

                    EG_free(eedges);

                /* add Edges adjacent to +iford1[ipair] and +iford2[ipair] */
                } else if (iford1[ipair] > 0 && iford2[ipair] > 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        jford1 = tempIlist[1] % 100;
                        jford2 = tempIlist[1] / 100;

                        if (tempIlist[0] == iprnt) {
                            if        (jford1 == iford1[ipair] && jford2 == iford2[ipair]) {
                                ielist[nelist++] = iedge;
                            } else if (jford1 == iford2[ipair] && jford2 == iford1[ipair]) {
                                ielist[nelist++] = iedge;
                            }
                        }
                    }

                    EG_free(eedges);

                /* remove Edges adjacent to -iford1[ipair] and -iford2[ipair] */
                } else if (iford1[ipair] < 0 && iford2[ipair] < 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iedge = 1; iedge <= nedge; iedge++) {
                        status = EG_attributeRet(eedges[iedge-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        jford1 = tempIlist[1] % 100;
                        jford2 = tempIlist[1] / 100;

                        if (tempIlist[0] == iprnt) {
                            if ((jford1 == -iford1[ipair] && jford2 == -iford2[ipair]) ||
                                (jford1 == -iford2[ipair] && jford2 == -iford1[ipair])   ) {
                                for (j = 0; j < nelist; j++) {
                                    if (ielist[j] == iedge) {
                                        ielist[j] = 0;
                                    }
                                }
                            }
                        }
                    }

                    EG_free(eedges);
                }
            }
        }

        /* remove deleted entries from the ielist */
        for (j = 0; j < nelist; j++) {
            if (ielist[j] == 0) {
                ielist[j] = ielist[nelist-1];
                nelist--;
                j--;
            }
        }

        /* create the chamfers */
        if (nelist > 0) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_CHAMFER, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            MALLOC(eelist, ego, nelist);
            MALLOC(eflist, ego, nelist);

            for (i = 0; i < nelist; i++) {
                if (ielist[i] < 1 || ielist[i] > nedge) {
                    signalError(MODL, OCSM_EDGE_NOT_FOUND,
                                "%d is not a valid Edge number", ielist[i]);
                    FREE(eelist);
                    EG_free(eedges);
                    goto cleanup;
                }

                SPRINT1(2, "        chamfer with iedge=%d", ielist[i]);
                eelist[i] = eedges[ielist[i]-1];

                status = EG_getBodyTopos(ebodyl, eelist[i], FACE, &nf, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                eflist[i] = efaces[0];
                EG_free(efaces);
            }

            EG_free(eedges);

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_chamferBody: ebodyl");
                ocsmPrintEgo(ebodyl);
            }
            status = EG_chamferBody(ebodyl, nelist, eelist, eflist, args[1].val[0], args[1].val[0], &ebody, NULL);
            if (status < SUCCESS) {
                signalError(MODL, status,
                            "CHAMFER failed");
                goto cleanup;
            }

            FREE(ielist);
            FREE(eelist);
            FREE(eflist);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (CHAMFER) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces with the current Body */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            for (iface = 1; iface <= nface; iface++) {
                status = EG_attributeRet(efaces[iface-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_NOTFOUND) {
                    status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                } else {
                    CHECK_STATUS(EG_attributeRet);
                }
            }

            EG_free(efaces);

            /* finish the Body (CHAMFER) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);
        } else {
            SPRINT0(1, "WARNING:: no edges for chamfer");
            (MODL->nwarn)++;
            ibody = ibodyl;
        }

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "hollow thick=0 entList=0 listStyle=0" */
    } else if (type == OCSM_HOLLOW) {
        SPRINT4(1, "    executing [%4d] hollow:     %11.5f  %s  %s",
                ibrch, args[1].val[0], MODL->brch[ibrch].arg2, MODL->brch[ibrch].arg3);
        if (args[1].dot[0] != 0) {
            hasdots = 1;

            SPRINT1(1, "                                 %11.5f",
                    args[1].dot[0]);
        }

        /* pop an Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "HOLLOW expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* normal hollow command of a SolidBody (with possible Face(s) removed)*/
        if (args[1].val[0] != 0 && MODL->body[ibodyl].botype == OCSM_SOLID_BODY) {

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            /* generate offset Body */
            if (args[2].nval == 1 && args[2].val[0] == 0) {
                nremove = 0;

            /* make list of Faces that will be partially removed (iface given) */
            } else if (args[3].val[0] != 0) {
                MALLOC(eflist, ego, args[2].nval);

                nremove = 0;
                for (i = 0; i < args[2].nval; i++) {
                    iface = NINT(args[2].val[i]);

                    eflist[nremove++] = MODL->body[ibodyl].face[iface].eface;
                }

            /* make list of Faces that will be partially removed (ibody/iford given) */
            } else {
                if (args[2].nval%2 != 0) {
                    signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                                "not an even number of entries in faceList");
                    goto cleanup;
                }

                npair = args[2].nval / 2;
                MALLOC(iford1, int, npair);
                MALLOC(iford2, int, npair);

                for (i = 0; i < npair; i++) {
                    iford1[i] = NINT(args[2].val[2*i  ]);
                    iford2[i] = NINT(args[2].val[2*i+1]);
                }

                nremove = 0;
                MALLOC(eflist, ego, MODL->body[ibodyl].nface);

                status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                for (iface = 1; iface <= nface; iface++) {
                    status = EG_attributeRet(efaces[iface-1], "_body",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeRet);

                    for (ipair = 0; ipair < npair; ipair++) {
                        if (tempIlist[0] == iford1[ipair] &&
                            tempIlist[1] == iford2[ipair]   ) {
                            eflist[nremove++] = efaces[iface-1];
                        }
                    }
                }

                EG_free(efaces);
            }

            /* generate the hollow */
            if (outLevel >= 3) {
                SPRINT0(3, "before EG_hollowBody: ebodyl");
                ocsmPrintEgo(ebodyl);

                for (i = 0; i < nremove; i++) {
                    SPRINT1(3, "    Face %d to remove", i);
                    ocsmPrintEgo(eflist[i]);
                }

                SPRINT2(3, "off=%f, join=%d", args[1].val[0], 1);
            }

            /* note: facemap1 freed below */
            status = EG_hollowBody(ebodyl, nremove, eflist, args[1].val[0], 1, &ebody, &facemap1);
            CHECK_STATUS(EG_hollowBody);

            MODL->body[ibody].ebody = ebody;

        /* normal hollow command of a single-Face SheetBody (with possible Edge(s) removed) */
        } else if (args[1].val[0] != 0 && MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                                          MODL->body[ibodyl].nface  == 1                 ) {

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (nface != 1) {
                signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                            "Body must only have one Face");
                goto cleanup;
            }

            ebodyl = efaces[0];

            /* generate offset Body */
            if (args[2].nval == 1 && args[2].val[0] == 0) {
                nremove = 0;

            /* make a list of Edges that will be partially removed (iedge given) */
            } else {
                MALLOC(eelist, ego, args[2].nval);

                nremove = 0;
                for (i = 0; i < args[2].nval; i++) {
                    iedge = NINT(args[2].val[i]);

                    eelist[nremove++] = MODL->body[ibodyl].edge[iedge].eedge;
                }
            }

            /* generate the hollow */
            if (outLevel >= 3) {
                SPRINT0(3, "before EG_hollowBody: ebodyl");
                ocsmPrintEgo(ebodyl);

                for (i = 0; i < nremove; i++) {
                    SPRINT1(3, "    Edge %d to remove", i);
                    ocsmPrintEgo(eelist[i]);
                }

                SPRINT2(3, "off=%f, join=%d", args[1].val[0], 1);
            }

            status = EG_hollowBody(ebodyl, nremove, eelist, args[1].val[0], 1, &eface, NULL);
            CHECK_STATUS(EG_hollowBody);

            FREE(eelist);

            status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
                                     NULL, 1, &eface, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            EG_free(efaces);

        /* convert SolidBody to SheetBody (with possible Face(s) removed) */
        } else if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY) {

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_copyObject);

            status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            /* extract the Shell (if no Faces are to be removed) */
            if (args[2].nval == 1 && args[2].val[0] == 0) {
                status = EG_makeTopology(MODL->context, NULL, SHELL, CLOSED,
                                         NULL, nface, efaces, NULL, &eshell);
                CHECK_STATUS(EG_makeTopology);

            /* make a new Shell and remove Faces that were listed in entList (iface given) */
            } else if (args[3].val[0] != 0) {
                for (i = 0; i < args[2].nval; i++) {
                    iface = NINT(args[2].val[i]);
                    efaces[iface-1] = efaces[nface-1];
                    nface--;
                }

                if (outLevel >= 3) {
                    for (iface = 0; iface < nface; iface++) {
                        SPRINT1(3, "efaces[%d]:", iface);
                        ocsmPrintEgo(efaces[iface]);
                    }
                }

                status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                         NULL, nface, efaces, NULL, &eshell);
                CHECK_STATUS(EG_makeTopology);

            /* make a new Shell and remove Faces that were listed in faceList (ibody/iford given) */
            } else {
                if (args[2].nval%2 != 0) {
                    signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                                "not an even number of entries in faceList");
                    goto cleanup;
                }

                for (ipair = 0; ipair < args[2].nval/2; ipair++) {
                    for (iface = nface-1; iface >= 0; iface--) {
                        status = EG_attributeRet(efaces[iface], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        if (tempIlist[0] == NINT(args[2].val[2*ipair  ]) &&
                            tempIlist[1] == NINT(args[2].val[2*ipair+1])   ) {
                            efaces[iface] = efaces[nface-1];
                            nface--;
                        }
                    }
                }

                if (outLevel >= 3) {
                    for (iface = 0; iface < nface; iface++) {
                        SPRINT1(3, "efaces[%d]:", iface);
                        ocsmPrintEgo(efaces[iface]);
                    }
                }

                status=EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                       NULL, nface, efaces, NULL, &eshell);
                CHECK_STATUS(EG_makeTopology);
            }

            /* make the new SheetBody */
            status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            EG_free(efaces);

            MODL->body[ibody].ebody = ebody;

        /* convert single-Face SheetBody to WireBody (with possible Edge(s) removed) */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyl].nface  == 1                 ) {

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_copyObject);

            /* extract the Loop (if no Edges are to be removed) */
            if (args[2].nval == 1 && args[2].val[0] == 0) {
                status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloop, &eloops);
                CHECK_STATUS(EG_getBodyTopos);

                eloop = eloops[0];

                EG_free(eloops);

            /* make a new Loop and remove Edges that were listed in entList (iedge given) */
            } else {
                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                CHECK_STATUS(EG_getBodyTopos);

                for (i = 0; i < args[2].nval; i++) {
                    iedge = NINT(args[2].val[i]);
                    eedges[iedge-1] = eedges[nedge-1];
                    nedge--;
                }

                if (outLevel >= 3) {
                    for (iedge = 0; iedge < nedge; iedge++) {
                        SPRINT1(3, "eedges[%d]:", iedge);
                        ocsmPrintEgo(eedges[iedge]);
                    }
                }

                status = EG_makeLoop(nedge, eedges, NULL, 0, &eloop);
                CHECK_STATUS(EG_makeLoop);

                EG_free(eedges);
            }

            /* make the new WireBody */
            status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                     NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

        /* handle multi-Face SheetBody */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {

            /* remove Faces (if they are connected) */
            if (args[1].val[0] == 0 && args[2].val[0] != 0) {

                /* recycle old Body if not dirty */
                status = recycleBody(MODL, ibrch, type, args, hasdots);
                CHECK_STATUS(recycleBody);

                if (status == 1) {
                    stack[(*nstack)++] = MODL->nbody;
                    status = SUCCESS;
                    goto cleanup;
                }

                status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
                CHECK_STATUS(EG_copyObject);

                status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                /* if Face is not skipped, put it into efaces2 */
                for (iface = nface; iface >= 1; iface--) {
                    imatch = 0;

                    if (args[2].val[0] > 0) {
                        if (args[3].val[0] != 0) {
                            for (ilist = 0; ilist < args[2].nval; ilist++) {
                                if (iface == NINT(args[2].val[ilist])) {
                                    imatch = 1;
                                    break;
                                }
                            }
                        } else if (args[2].nval%2 == 0) {
                            status = EG_attributeRet(MODL->body[ibodyl].face[iface].eface, "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            for (ilist = 0; ilist < args[2].nval; ilist+=2) {
                                if (tempIlist[0] == NINT(args[2].val[ilist  ]) &&
                                    tempIlist[1] == NINT(args[2].val[ilist+1])   ) {
                                    imatch = 1;
                                    break;
                                }
                            }
                        } else {
                            signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                                        "not an even number of entries in entList");
                            goto cleanup;
                        }
                    }

                    /* skip this Face */
                    if (imatch == 1) {
                        efaces[iface-1] = efaces[nface-1];
                        nface--;
                    }
                }

                /* sew the Faces together into a SheetBody */
                status = EG_sewFaces(nface, efaces, 0, 1, &emodel);
                CHECK_STATUS(EG_sewFaces);

                status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebody = echilds[0];

                /* make the new SheetBody */
                status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);

                MODL->body[ibody].ebody = ebody;

                EG_free(efaces);

            /* hollow all Faces or those in entList */
            } else if (args[1].val[0] > 0) {

                /* recycle old Body if not dirty */
                status = recycleBody(MODL, ibrch, type, args, hasdots);
                CHECK_STATUS(recycleBody);

                if (status == 1) {
                    stack[(*nstack)++] = MODL->nbody;
                    status = SUCCESS;
                    goto cleanup;
                }

                status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
                CHECK_STATUS(EG_copyObject);

                status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                /* pull each Face out, hollow it, and put result bask into efaces */
                for (iface = 0; iface < nface; iface++) {
                    imatch = 0;

                    /* skip face if not in entList */
                    if (args[2].val[0] > 0) {
                        if (args[3].val[0] != 0) {
                            for (ilist = 0; ilist < args[2].nval; ilist++) {
                                if (iface+1 == NINT(args[2].val[ilist])) {
                                    imatch = 1;
                                    break;
                                }
                            }
                        } else if (args[2].nval%2 == 0) {
                            status = EG_attributeRet(MODL->body[ibodyl].face[iface+1].eface, "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            for (ilist = 0; ilist < args[2].nval; ilist+=2) {
                                if (tempIlist[0] == NINT(args[2].val[ilist  ]) &&
                                    tempIlist[1] == NINT(args[2].val[ilist+1])   ) {
                                    imatch = 1;
                                    break;
                                }
                            }
                        } else {
                            signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                                        "not an even number of entries in entList");
                            goto cleanup;
                        }
                    } else {
                        imatch = 1;
                    }

                    if (imatch == 1) {
                        status = EG_hollowBody(efaces[iface], 0, NULL, args[1].val[0], 1, &eface, NULL);
                        CHECK_STATUS(EG_hollowBody);

                        efaces[iface] = eface;
                    }
                }

                /* sew the Faces together into a SheetBody */
                status = EG_sewFaces(nface, efaces, 0, 1, &emodel);
                CHECK_STATUS(EG_sewFaces);

                status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebody = echilds[0];

                /* make the new SheetBody */
                status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);

                MODL->body[ibody].ebody = ebody;

                EG_free(efaces);

            /* illegal operation */
            } else {
                SET_STATUS(OCSM_ILLEGAL_VALUE, hollow);
            }

        /* otherwise an error */
        } else {
            SET_STATUS(OCSM_ILLEGAL_VALUE, hollow);
        }

        /* update @-parameters (HOLLOW) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (facemap1 == NULL) {
            iford = 0;
            for (iface = 1; iface <= nface; iface++) {
                status = EG_attributeRet(efaces[iface-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);

                if (status == EGADS_NOTFOUND) {
                    iford++;
                    status = setFaceAttribute(MODL, ibody, iface, 0, iford, npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                } else {
                    CHECK_STATUS(EG_attributeRet);
                }
            }
        } else {
            MALLOC(facemap2, int, 4*nface);

            /* make a list of the faceID of the Face from which new Faces are offset */
            nfacemap = 0;
            for (iface = 1; iface <= nface; iface++) {
                status = EG_attributeRet(efaces[iface-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);

                if (status == EGADS_NOTFOUND) {
                    if (facemap1[2*iface-2] != FACEOFF) {
                        signalError(MODL, OCSM_INTERNAL_ERROR,
                                    "facemap1[iface=%d]=%d %d", iface, facemap1[2*iface-2], facemap1[2*iface-1]);
                        EG_free(efaces);
                        SET_STATUS(OCSM_INTERNAL_ERROR, hollow);
                    } else {
                        i = facemap1[2*iface-1];

                        status = EG_attributeRet(MODL->body[ibodyl].face[i].eface, "_faceID",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        facemap2[4*nfacemap  ] = iface;
                        facemap2[4*nfacemap+1] = tempIlist[0];
                        facemap2[4*nfacemap+2] = tempIlist[1];
                        facemap2[4*nfacemap+3] = tempIlist[2];
                        nfacemap++;
                    }
                }
            }

            /* sort the facemap2 in faceID order */
            for (i = 0; i < nfacemap; i++) {
                for (j = i+1; j < nfacemap; j++) {
                    iswap = 0;

                    if (facemap2[4*j+1] < facemap2[4*i+1]) {
                        iswap = 1;
                    } else if (facemap2[4*j+1] == facemap2[4*i+1]) {
                        if (facemap2[4*j+2] < facemap2[4*i+2]) {
                            iswap = 1;
                        } else if (facemap2[4*j+2] == facemap2[4*i+2]) {
                            if (facemap2[4*j+3] < facemap2[4*i+3]) {
                                iswap = 1;
                            }
                        }
                    }

                    if (iswap > 0) {
                        iswap           = facemap2[4*i  ];
                        facemap2[4*i  ] = facemap2[4*j  ];
                        facemap2[4*j  ] = iswap;

                        iswap           = facemap2[4*i+1];
                        facemap2[4*i+1] = facemap2[4*j+1];
                        facemap2[4*j+1] = iswap;

                        iswap           = facemap2[4*i+2];
                        facemap2[4*i+2] = facemap2[4*j+2];
                        facemap2[4*j+2] = iswap;

                        iswap           = facemap2[4*i+3];
                        facemap2[4*i+3] = facemap2[4*j+3];
                        facemap2[4*j+3] = iswap;
                    }
                }
            }

            /* apply the faceID to the Faces in facemap2 */
            for (i = 0; i < nfacemap; i++) {
                iface = facemap2[4*i  ];

                status = setFaceAttribute(MODL, ibody, iface, 0, i+1, npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }
            FREE(   facemap2);
            EG_free(facemap1);
            facemap1 = NULL;
        }

        EG_free(efaces);

        /* finish the Body (HOLLOW) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);
    }

cleanup:
    FREE(eelist);
    FREE(eflist);
    FREE(facemap2);
    if (facemap1 != NULL) EG_free(facemap1);

    FREE(iford1);
    FREE(iford2);
    FREE(ielist);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildBoolean - implement OCSM_BOOLEANs for ocsmBuild               *
 *                                                                      *
 ************************************************************************
 */

static int
buildBoolean(modl_T *modl,              /* (in)  pointer to MODL */
             int    ibrch,              /* (in)  Branch index (bias-1) */
             varg_T args[],             /* (in)  array of arguments */
             int    *nstack,            /* (both) number of Bodys on stack */
             int    stack[],            /* (both) array  of Bodys on stack */
             int    npatn,              /* (in)   number of patterns */
             patn_T patn[])             /* (both) array  of patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        type, hasdots, toMark, saveOutLevel;
    int        ibody, ibodyl, ibodyr, index, nnewedges, atype, alen;
    int        i, j, k, nchild, nchange, numBodys, bodyList[999];
    int        numRemaining;
    double     toler, maxtol;
    char       order[MAX_EXPR_LEN];

    int         oclass, mtype, *senses, nface, nedge, nshell;
    int         iedge, iface, senses1[1], nedges, bodyType, inode, iedgel, iedger;
    int         nmatch, *matches=NULL, nfacel, nfacer, nfacedg;
    int         inbodyl, inbodyr, ichild, botype;
    int         fillstyle=0, itype, nlist, *indx=NULL, ii, swap;
    int         nnn, nEdgeList, nEdgeListl, nEdgeListr, iii, jjj, iadd;
    int         *sensesl, *sensesr, nFaceList;

//$$$//fhr
//$$$        int         parabool[10], para_inst;
//$$$//fhr
    int         isub, nloopl, nloopr, *sensesc=NULL, *idatal, *idatar, npnt, ntri, nn, periodic;
    CINT        *ptype, *pindx, *tris, *tric, *tempIlist;
    double      data[20], xyz[3], dirn[4], matrix[12], area, bbox1[6], bbox2[6], length, dot;
    double      xyz0[3], xyz1[3], xyz2[3], xyz3[3], dist02, dist03, dist12, dist13;
    double      *datal, *datar, norml[4], normr[4], uv[2], size, params[3], paramse[3], bbox[6], trange[4];
    CDOUBLE     *uv_tess, *xyz_tess, *tempRlist;
    CCHAR       *tempClist;
    ego         ebody, ebodyl, ebodyr, emodel, eref, *ebodys, *echilds=NULL;
    ego         *eshells=NULL, *efaces=NULL, *eedges=NULL, *elist=NULL;
    ego         eface, eloop, *efacedgs=NULL;
    ego         etemp1, etemp2, exform, eflip, etopref, eprev, enext;
    ego         *enewEdges=NULL, *enewFaces=NULL;
    ego         *nnnList, *edgeList=NULL, *edgeListl, *edgeListr, *faceList=NULL, eloops[2];
    ego         enodes[2], eedges2[8], eshell, *enewedges;
    ego         *eloopsl, *eloopsr, *eloopsc=NULL, esurfl, esurfr, enew, etess;

    ROUTINE(buildBoolean);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "intersect $order=none index=1 maxtol=0" */
    if (type == OCSM_INTERSECT) {
        SPRINT4(1, "    executing [%4d] intersect:  %s  %11.5f  %11.4e",
                ibrch, args[1].str, args[2].val[0], args[3].val[0]);

        /* pop 2 Bodys from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "INTERSECT expects 2 Bodys on the stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that at least one Body is a SolidBody */
        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY &&
            MODL->body[ibodyr].botype != OCSM_SOLID_BODY   ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "INTERSECT expects at least one SolidBody");
            goto cleanup;
        }

        /* extract the arguments */
        STRNCPY(order, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);
        index  = NINT(args[2].val[0]);
        maxtol =      args[3].val[0];

        /* create the new Body */
        if        (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {
            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            botype = OCSM_SOLID_BODY;
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            ebodyr = MODL->body[ibodyr].ebody;

            botype = OCSM_SHEET_BODY;
        } else if (MODL->body[ibodyr].botype == OCSM_SHEET_BODY) {
            status = EG_copyObject(MODL->body[ibodyr].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            ebodyr = MODL->body[ibodyl].ebody;

            botype = OCSM_SHEET_BODY;
        } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {
            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            ebodyr = MODL->body[ibodyr].ebody;

            botype = OCSM_WIRE_BODY;
        } else if (MODL->body[ibodyr].botype == OCSM_WIRE_BODY) {
            status = EG_copyObject(MODL->body[ibodyr].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            ebodyr = MODL->body[ibodyl].ebody;

            botype = OCSM_WIRE_BODY;
        } else {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "INTERSECT ran into an unexpected condition");
            goto cleanup;
        }

        status = newBody(MODL, ibrch, OCSM_INTERSECT, ibodyl, ibodyr,
                         args, hasdots, botype, &ibody);
        CHECK_STATUS(newBody);

        status = solidBoolean(MODL, ebodyl, ebodyr, INTERSECTION, maxtol, &emodel);
        if (status < 0) {
            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                        "INTERSECT did not create a Body");

            (void) freeBody(MODL, ibody);
            goto cleanup;
        }
        CHECK_STATUS(solidBoolean);

        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY ||
            MODL->body[ibodyr].botype != OCSM_SOLID_BODY   ) {
            status = EG_deleteObject(ebodyl);
            CHECK_STATUS(EG_deleteObject);
        }

        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                data, &nchild, &ebodys, &senses);
        CHECK_STATUS(EG_getTopology);

        if (nchild < 1) {
            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                        "INTERSECT did not create a Body");
            (void) freeBody(MODL, ibody);
            goto cleanup;
        } else if (index > nchild) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "INTERSECT only created %d Bodys but index=%d", nchild, index);

            (void) freeBody(MODL, ibody);
            goto cleanup;
        }

        if (index >= 0) {
            i = selectBody(emodel, order, index);
        } else {
            i = selectBody(emodel, order, 1);
        }

        status = EG_copyObject(ebodys[i], NULL, &ebody);
        CHECK_STATUS(EG_copyObject);

        MODL->body[ibody].ebody = ebody;

        if (nchild > 1) {
            if (index == -1) {

                for (j = 2; j <= nchild; j++) {

                    /* keep track of number of Bodys remaining from this command */
                    numRemaining = nchild + 1 - j;
                    status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                             1, &numRemaining, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    /* update @-parameters (SUBTRACT) and finish Body */
                    status = setupAtPmtrs(MODL, 0);
                    CHECK_STATUS(setupAtPmtrs);

                    status = finishBody(MODL, ibody);
                    if (MODL->sigCode != SUCCESS) goto cleanup;
                    CHECK_STATUS(finishBody);

                    /* push the Body onto the stack */
                    stack[(*nstack)++] = ibody;

                    status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                    CHECK_STATUS(getBodyTolerance);

                    SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                            ibody, toler);

                    /* create the new Body */
                    status = newBody(MODL, ibrch, OCSM_INTERSECT, ibodyl, ibodyr,
                                     args, hasdots, botype, &ibody);
                    CHECK_STATUS(newBody);

                    i = selectBody(emodel, order, j);

                    status = EG_copyObject(ebodys[i], NULL, &ebody);
                    CHECK_STATUS(EG_copyObject);

                    MODL->body[ibody].ebody = ebody;
                }
            } else {
                SPRINT1(1, "WARNING:: %d Bodys are being lost", nchild-1);
                (MODL->nwarn)++;
            }
        }

        status = EG_deleteObject(emodel);
        CHECK_STATUS(EG_deleteObject);

        /* update @-parameters (INTERSECT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "subtract $order=none index=1 maxtol=0" */
    } else if (type == OCSM_SUBTRACT) {
        SPRINT4(1, "    executing [%4d] subtract:   %s  %11.5f  %11.4e",
                ibrch, args[1].str, args[2].val[0], args[3].val[0]);

        /* pop 2 Bodys from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "SUBTRACT expects 2 Bodys on stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* extract the arguments */
        STRNCPY(order, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);
        index  = NINT(args[2].val[0]);
        maxtol =      args[3].val[0];

//$$$//fhr
//$$$        para_inst = 0;
//$$$        if (MODL->body[ibodyl].brtype == OCSM_SUBTRACT) {
//$$$            SPRINT0(1, "Parent is a Subtract");
//$$$            status = EG_getBoundingBox(MODL->body[ibodyr].ebody, bbox1);
//$$$            // Line below is temporary, need to get parabool working to use in for loop
//$$$            status = EG_getBoundingBox(MODL->body[MODL->body[ibodyl].irite].ebody, bbox2);
//$$$            /* This for loop is intended to go through the list of added booleans, to ensure
//$$$               each object to be added is not intersecting with all others.*/
//$$$            // Removed code that doesn't work without list of added bools
//$$$            for (j=0; j<=9; j++) {
//$$$                if (parabool[j] > 0) {
//$$$                    //Compute bbox2 here
//$$$                    if        (bbox2[0] > bbox1[3] || bbox2[3] < bbox1[0]) {
//$$$                        // No intersection
//$$$                        continue;
//$$$                    } else if (bbox2[1] > bbox1[4] || bbox2[4] < bbox1[1]) {
//$$$                        // No intersection
//$$$                        continue;
//$$$                    } else if (bbox2[2] > bbox1[5] || bbox2[5] < bbox1[2]) {
//$$$                        // No intersection
//$$$                        /* Must check whole list of parabool before
//$$$                           adding this brch to list*/
//$$$                        continue;
//$$$                    } else {
//$$$                        SPRINT0(1, "Intersected, complete chain and start new");
//$$$                        // If none of above conditions are true, intersecting
//$$$                        /* Test fails under non-axis-aligned condition */
//$$$                        // Complete then clear parabool
//$$$                        parabool[0] = ibrch; /* Doesn't work*/
//$$$                        para_inst   = 1;
//$$$                        break;
//$$$                    }
//$$$                }
//$$$            }
//$$$            if (para_inst == 0) {
//$$$                parabool[j+1] = ibrch;
//$$$            }
//$$$        } else {
//$$$            SPRINT0(1, "COMPLETE PREVIOUS CHAIN AND START NEW CHAIN")
//$$$                /* Need to tell code to complete previous chain here */
//$$$                /* Need to start a new chain of bools here           */
//$$$                parabool[0] = ibrch; /* Doesn't work */
//$$$        }
//$$$//fhr

        /* if both ibodyl and ibodyr are SolidBodys, perform Boolean
           opertion */
        if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
            MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = NULL;

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            status = solidBoolean(MODL, ebodyl, ebodyr, SUBTRACTION, maxtol, &emodel);
            if (status < 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                goto cleanup;
            }
            CHECK_STATUS(solidBoolean);

            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &ebodys, &senses);
            CHECK_STATUS(EG_getTopology);

            if (nchild < 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                goto cleanup;
            } else if (index > nchild) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "SUBTRACT only created %d Bodys but index=%d", nchild, index);

                (void) freeBody(MODL, ibody);
                goto cleanup;
            }

            if (index >= 0) {
                i = selectBody(emodel, order, index);
            } else {
                i = selectBody(emodel, order, 1);
            }

            status = EG_copyObject(ebodys[i], NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            if (nchild > 1) {
                if (index == -1) {

                    for (j = 2; j <= nchild; j++) {

                        /* keep track of number of Bodys remaining from this command */
                        numRemaining = nchild + 1 - j;
                        status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                                 1, &numRemaining, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* update @-parameters (SUBTRACT) and finish Body */
                        status = setupAtPmtrs(MODL, 0);
                        CHECK_STATUS(setupAtPmtrs);

                        status = finishBody(MODL, ibody);
                        if (MODL->sigCode != SUCCESS) goto cleanup;
                        CHECK_STATUS(finishBody);

                        /* push the Body onto the stack */
                        stack[(*nstack)++] = ibody;

                        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                        CHECK_STATUS(getBodyTolerance);

                        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                                ibody, toler);

                        /* create the new Body */
                        status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                                         args, hasdots, OCSM_SOLID_BODY, &ibody);
                        CHECK_STATUS(newBody);

                        i = selectBody(emodel, order, j);

                        status = EG_copyObject(ebodys[i], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        MODL->body[ibody].ebody = ebody;
                    }
                } else {
                    SPRINT1(1, "WARNING:: %d Bodys are being lost", nchild-1);
                    (MODL->nwarn)++;
                }
            }

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

        /* ibodyl is a SolidBody and ibodyr is a SheetBody, so scribe ibodyl */
        } else if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            if (outLevel >= 3) {
                SPRINT0(1, "before EG_intersection: ebodyl");
                ocsmPrintEgo(ebodyl);
                SPRINT0(1, "before EG_intersection: ebodyr");
                ocsmPrintEgo(ebodyr);
            }

            status = EG_intersection(ebodyl, ebodyr, &nfacedg, &efacedgs, &emodel);
            if (status < 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "INTERSECTION did not create a Body");
                goto cleanup;
            }
            CHECK_STATUS(EG_intersection);

            if (outLevel >= 3) {
                SPRINT0(1, "after EG_intersection\nemodel");
                ocsmPrintEgo(emodel);
                for (i = 0; i <  2*nfacedg; i++) {
                    SPRINT1(1, "efacedgs[%d]", i);
                    ocsmPrintEgo(efacedgs[i]);
                }
            }

            status = EG_imprintBody(ebodyl, nfacedg, efacedgs, &ebody);
            CHECK_STATUS(EG_imprintBody);

            /* try to transfer _faceID info from the Edges that got returned
               from EG_intersection onto the Edges that were created in
               EG_imprintBody (but with the name __scribeID__) */
            status = EG_getBodyTopos(ebody, NULL, EDGE,
                                     &nnewedges, &enewedges);
            CHECK_STATUS(EG_getBodyTopos);

            for (i = 1; i < 2*nfacedg; i+=2) {
                status = EG_attributeRet(efacedgs[i], "_faceID", &atype, &alen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_SUCCESS) {
                    status = EG_getBoundingBox(efacedgs[i], bbox1);
                    CHECK_STATUS(EG_getBoundingBox);

                    for (j = 0; j < nnewedges; j++) {
                        status = EG_getBoundingBox(enewedges[j], bbox2);
                        CHECK_STATUS(EG_getBoundingBox);

                        if (fabs(bbox1[0]-bbox2[0]) < EPS03 &&
                            fabs(bbox1[1]-bbox2[1]) < EPS03 &&
                            fabs(bbox1[2]-bbox2[2]) < EPS03 &&
                            fabs(bbox1[3]-bbox2[3]) < EPS03 &&
                            fabs(bbox1[4]-bbox2[4]) < EPS03 &&
                            fabs(bbox1[5]-bbox2[5]) < EPS03   ) {
                            status = EG_attributeAdd(enewedges[j], "__scribeID__", ATTRINT,
                                                     alen, tempIlist, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            break;
                        }
                    }
                }
            }

            EG_free(enewedges);

            if (emodel != NULL) {
                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);
            }

            EG_free(efacedgs);
            efacedgs = NULL;

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a SheetBody and ibodyr is a SheetBody */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            /* check to see if we should perform subtraction (rather than scribing) */
            isub = 1;

            /* for subtraction, both SheetBodys must have a single Face */
            if (MODL->body[ibodyl].nface != 1) isub = 0;
            if (MODL->body[ibodyr].nface != 1) isub = 0;

            /* for subtraction,  both surfaces must be PLANEs */
            status = EG_getTopology(MODL->body[ibodyl].face[1].eface, &esurfl,
                                    &oclass, &mtype, data, &nloopl, &eloopsl, &sensesl);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(esurfl, &oclass, &mtype, &eref, &idatal, &datal);
            CHECK_STATUS(EG_getGeometry);

            if (oclass != SURFACE || mtype != PLANE) {
                isub     = 0;
                norml[0] = 0;
                norml[1] = 0;
                norml[2] = 1;
            } else {
                norml[0]  = datal[4] * datal[8] - datal[5] * datal[7];
                norml[1]  = datal[5] * datal[6] - datal[3] * datal[8];
                norml[2]  = datal[3] * datal[7] - datal[4] * datal[6];
                norml[3]  = sqrt(norml[0]*norml[0] + norml[1]*norml[1] + norml[2]*norml[2]);
                norml[0] /= norml[3];
                norml[1] /= norml[3];
                norml[2] /= norml[3];
            }

            status = EG_getTopology(MODL->body[ibodyr].face[1].eface, &esurfr,
                                    &oclass, &mtype, data, &nloopr, &eloopsr, &sensesr);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(esurfr, &oclass, &mtype, &eref, &idatar, &datar);
            CHECK_STATUS(EG_getGeometry);

            if (oclass != SURFACE || mtype != PLANE) {
                isub     = 0;
                normr[0] = 0;
                normr[1] = 0;
                normr[2] = 1;
            } else {
                normr[0]  = datar[4] * datar[8] - datar[5] * datar[7];
                normr[1]  = datar[5] * datar[6] - datar[3] * datar[8];
                normr[2]  = datar[3] * datar[7] - datar[4] * datar[6];
                normr[3]  = sqrt(normr[0]*normr[0] + normr[1]*normr[1] + normr[2]*normr[2]);
                normr[0] /= normr[3];
                normr[1] /= normr[3];
                normr[2] /= normr[3];
            }

            /* for subtraction, ibodyr must contain only one Loop */
            if (nloopr != 1) isub = 0;

            /* for subtraction, the surfaces must be coplanar */
            if (isub == 1) {
                dot = norml[0] * normr[0] + norml[1] * normr[1] + norml[2] * normr[2];
                if (fabs(fabs(dot)-1) > EPS06) isub = 0;
            }

            if (isub == 1) {
                status = EG_invEvaluate(esurfr, datal, uv, xyz);
                CHECK_STATUS(EG_invEvaluate);

                if (fabs(datal[0] - xyz[0]) > EPS06 ||
                    fabs(datal[1] - xyz[1]) > EPS06 ||
                    fabs(datal[2] - xyz[2]) > EPS06   ) isub = 0;
            }

            if (idatal != NULL) EG_free(idatal);
            if (idatar != NULL) EG_free(idatar);

            EG_free(datal);
            EG_free(datar);

            /* subtract one SheetBody from the other by by combining their Loops */
            if (isub == 1) {

                /* make an array of the combined Loops */
                MALLOC(eloopsc, ego, nloopl+1);
                MALLOC(sensesc, int, nloopl+1);

                for (i = 0; i < nloopl; i++) {
                    eloopsc[i] = eloopsl[i];
                    sensesc[i] = sensesl[i];
                }
                eloopsc[nloopl] =  eloopsr[0];
                sensesc[nloopl] = -sensesr[0];

                eface  = NULL;
                eshell = NULL;

                /* make the Face, Shell, and then new SheetBody */
                status = EG_makeTopology(MODL->context, esurfl, FACE, SFORWARD, NULL,
                                         nloopl+1, eloopsc, sensesc, &eface);
                if (status != SUCCESS) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "in-plane SUBTRACTION of SheetBodys failed");
                    goto cleanup;
                }

                status = EG_attributeDup(MODL->body[ibodyl].face[1].eface, eface);
                CHECK_STATUS(EG_attributeDup);

                status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN, NULL,
                                         1, &eface, NULL, &eshell);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY, NULL,
                                         1, &eshell, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);

                /* in order to check that ibodyr intersects the outer Loop of ibodyl,
                   try to tessellate and make sure that there are triangles */
                status = EG_getBoundingBox(ebody, bbox);
                CHECK_STATUS(EG_getBoundingBox);

                size = MAX(MAX(bbox[3]-bbox[0], bbox[4]-bbox[1]), bbox[5]-bbox[2]);

                params[0] = TESS_PARAM_0 * size;
                params[1] = TESS_PARAM_1 * size;
                params[2] = TESS_PARAM_2;

                /* set .tParams on the Edges to make sure they each get at least 20 points */
                status = EG_copyObject(ebody, NULL, &enew);
                CHECK_STATUS(EG_copyObject);

                status = EG_getBodyTopos(enew, NULL, EDGE, &nn, &eedges);
                CHECK_STATUS(EG_getBodyTopos);

                for (ii = 0; ii < nn; ii++) {
                    status = EG_getRange(eedges[ii], trange, &periodic);
                    CHECK_STATUS(EG_getRange);

                    status = EG_arcLength(eedges[ii], trange[0], trange[1], &length);
                    CHECK_STATUS(EG_arcLength);

                    paramse[0] = MIN(length/20, params[0]);
                    paramse[1] = MIN(length/50, params[1]);
                    paramse[2] =                params[2];

                    status = EG_attributeAdd(eedges[ii], ".tParams", ATTRREAL, 3, NULL, paramse, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }

                EG_free(eedges);

                /* set .silent to keep EGADS from emitting error messages */
                status = EG_attributeAdd(enew, ".silent", ATTRSTRING, 2, NULL, NULL, "on");
                CHECK_STATUS(EG_attributeAdd);

                /* now tessellate and then remove it and the temporary Body */
                status = EG_makeTessBody(enew, params, &etess);
                CHECK_STATUS(EG_makeTessBody);

                status = EG_getTessFace(etess, 1,
                                        &npnt, &uv_tess, &xyz_tess, &ptype, &pindx,
                                        &ntri, &tris, &tric);
                CHECK_STATUS(EG_getFaceTess);

                status = EG_deleteObject(etess);
                CHECK_STATUS(EG_deleteObject);

                status = EG_deleteObject(enew);
                CHECK_STATUS(EG_deleteObject);

                /* if there are no triangles, the SUBTRACTion was not successful */
                if (ntri == 0) {
                    status = EG_deleteObject(eshell);
                    CHECK_STATUS(EG_deleteObject);

                    status = EG_deleteObject(eface );
                    CHECK_STATUS(EG_deleteObject);

                    status = EG_deleteObject(ebody );
                    CHECK_STATUS(EG_deleteObject);

                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "Loop for Bodyr intersects a Loop in Bodyl");
                    goto cleanup;
                }

                FREE(eloopsc);
                FREE(sensesc);

                /* make sure that the Attributes on the inner Body are not deleted */
                status = EG_attributeAdd(ebody, "__keepEdgeAttr__", ATTRSTRING,
                                         STRLEN("yes"), NULL, NULL, "yes");
                CHECK_STATUS(EG_attributeAdd);

            /* subtraction not possible, so scribe ibodyl with ibodyr */
            } else {
                if (outLevel >= 3) {
                    SPRINT0(3, "before EG_intersection: ebodyl");
                    ocsmPrintEgo(ebodyl);
                    SPRINT0(3, "before EG_intersection: ebodyr");
                    ocsmPrintEgo(ebodyr);
                }
                status = EG_intersection(ebodyl, ebodyr, &nfacedg, &efacedgs, &emodel);
                if (status < 0) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "INTERSECTION did not create a Body");
                    goto cleanup;
                }
                CHECK_STATUS(EG_intersection);

                if (outLevel >= 3) {
                    SPRINT0(3, "before EG_imprintBody: ebodyl");
                    ocsmPrintEgo(ebodyl);
                }
                status = EG_imprintBody(ebodyl, nfacedg, efacedgs, &ebody);
                CHECK_STATUS(EG_imprintBody);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                EG_free(efacedgs);
                efacedgs = NULL;
            }

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a SheetBody and ibodyr is a SolidBody, so perform
           Boolean operation */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            status = EG_copyObject(ebodyl, NULL, &etemp1);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &etemp1, NULL, &etemp2);
            CHECK_STATUS(EG_makeTopology);

            status = solidBoolean(MODL, etemp2, ebodyr, SUBTRACTION, maxtol, &emodel);
            if (status < 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                goto cleanup;
            }
            CHECK_STATUS(solidBoolean);

            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &ebodys, &senses);
            CHECK_STATUS(EG_getTopology);

            if (nchild < 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                goto cleanup;
            } else if (index > nchild) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "SUBTRACT only created %d Bodys but index=%d", nchild, index);

                (void) freeBody(MODL, ibody);
                goto cleanup;
            }

            if (index >= 0) {
                i = selectBody(emodel, order, index);
            } else {
                i = selectBody(emodel, order, 1);
            }

            status = EG_copyObject(ebodys[i], NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            if (nchild > 1) {
                if (index == -1) {

                    for (j = 2; j <= nchild; j++) {

                        /* keep track of number of Bodys remaining from this command */
                        numRemaining = nchild + 1 - j;
                        status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                                 1, &numRemaining, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* update @-parameters (SUBTRACT) and finish Body */
                        status = setupAtPmtrs(MODL, 0);
                        CHECK_STATUS(setupAtPmtrs);

                        status = finishBody(MODL, ibody);
                        if (MODL->sigCode != SUCCESS) goto cleanup;
                        CHECK_STATUS(finishBody);

                        /* push the Body onto the stack */
                        stack[(*nstack)++] = ibody;

                        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                        CHECK_STATUS(getBodyTolerance);

                        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                                ibody, toler);

                        /* create the new Body */
                        status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                                         args, hasdots, OCSM_SHEET_BODY, &ibody);
                        CHECK_STATUS(newBody);

                        i = selectBody(emodel, order, j);

                        status = EG_copyObject(ebodys[i], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        MODL->body[ibody].ebody = ebody;
                    }
                } else {
                    SPRINT1(1, "WARNING:: %d Bodys are being lost", nchild-1);
                    (MODL->nwarn)++;
                }
            }

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            status = EG_deleteObject(etemp2);
            CHECK_STATUS(EG_deleteObject);

        /* unsupported combination of Body types */
        } else {
            if (outLevel >= 3) {
                SPRINT0(0, "ebodyl");
                ocsmPrintEgo(MODL->body[ibodyl].ebody);
                SPRINT0(0, "ebodyr");
                ocsmPrintEgo(MODL->body[ibodyr].ebody);
            }

            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "unsupported combination of Body types to SUBTRACT");
            goto cleanup;
        }

        /* update @-parameters (SUBTRACT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "union toMark=0 trimList=0 maxtol=0" */
    } else if (type == OCSM_UNION) {
        SPRINT4(1, "    executing [%4d] union:      %11.5f  %s  %11.4e",
                ibrch, args[1].val[0], MODL->brch[ibrch].arg2, args[3].val[0]);

        /* extract the argument */
        toMark = NINT(args[1].val[0]);
        maxtol =      args[3].val[0];
        ibody  = 0;

        /* union top two Bodys on the stack */
        if (toMark == 0) {
            /* pop 2 Bodys from the stack */
            if ((*nstack) < 2) {
                signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                            "UNION expects 2 Bodys on stack");
                goto cleanup;
            } else {
                ibodyr = stack[--(*nstack)];
                ibodyl = stack[--(*nstack)];
            }

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            SPRINT0(2, "ebodyl");
            if (outLevel >= 2) ocsmPrintEgo(ebodyl);

            SPRINT0(2, "ebodyr");
            if (outLevel >= 2) ocsmPrintEgo(ebodyr);

            /* union of 2 SolidBodys */
            if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
                MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {

                /* create the new Body */
                status = newBody(MODL, ibrch, OCSM_UNION, ibodyl, ibodyr,
                                 args, hasdots, OCSM_SOLID_BODY, &ibody);
                CHECK_STATUS(newBody);

                MODL->body[ibody].ebody = NULL;

                /* normal (untrimmed) union of 2 SolidBodys */
                if (args[2].nval < 6) {
                    status = solidBoolean(MODL, ebodyl, ebodyr, FUSION, maxtol, &emodel);
                    if (status < 0) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION did not create a Body");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }
                    CHECK_STATUS(solidBoolean);

                    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                            data, &nchild, &ebodys, &senses);
                    CHECK_STATUS(EG_getTopology);

                    if (nchild == 1) {
                        status = EG_copyObject(ebodys[0], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        MODL->body[ibody].ebody = ebody;
                    } else {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION created %d Bodys", nchild);

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                /* trimmed union of 2 SolidBodys */
                } else {

                    /* determine if given point is in ebodyl or ebodyr */
                    xyz[0] = args[2].val[0];
                    xyz[1] = args[2].val[1];
                    xyz[2] = args[2].val[2];

                    inbodyl = EG_inTopology(ebodyl, xyz);
                    inbodyr = EG_inTopology(ebodyr, xyz);
                    SPRINT2(2, "inbodyl=%d, inbodyr=%d", inbodyl, inbodyr);

                    if        (inbodyl == EGADS_SUCCESS && inbodyr == EGADS_OUTSIDE) {
                    } else if (inbodyl == EGADS_OUTSIDE && inbodyr == EGADS_SUCCESS) {
                        etemp1 = ebodyl;
                        ebodyl = ebodyr;
                        ebodyr = etemp1;
                    } else if (inbodyl == EGADS_SUCCESS && inbodyl == EGADS_SUCCESS) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "trim point is inside both Bodys");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    } else {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "trim point is inside neither Body");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }

                    /* move ebodyl a little opposite the direction given */
                    dirn[0] = args[2].val[3];
                    dirn[1] = args[2].val[4];
                    dirn[2] = args[2].val[5];

                    matrix[ 0] = 1; matrix[ 1] = 0; matrix[ 2] = 0; matrix[ 3] = -dirn[0];
                    matrix[ 4] = 0; matrix[ 5] = 1; matrix[ 6] = 0; matrix[ 7] = -dirn[1];
                    matrix[ 8] = 0; matrix[ 9] = 0; matrix[10] = 1; matrix[11] = -dirn[2];

                    SPRINT4(2, "matrix: %10.5f %10.5f %10.5f %10.5f", matrix[ 0], matrix[ 1], matrix[ 2], matrix[ 3]);
                    SPRINT4(2, "        %10.5f %10.5f %10.5f %10.5f", matrix[ 4], matrix[ 5], matrix[ 6], matrix[ 7]);
                    SPRINT4(2, "        %10.5f %10.5f %10.5f %10.5f", matrix[ 8], matrix[ 9], matrix[10], matrix[11]);

                    status = EG_makeTransform(MODL->context, matrix, &exform);
                    CHECK_STATUS(EG_makeTransform);

                    status = EG_copyObject(ebodyl, exform, &etemp1);
                    CHECK_STATUS(EG_copyObject);

                    status = EG_deleteObject(exform);
                    CHECK_STATUS(EG_deleteObject);

                    /* subtract ebodyr from etemp1 (the moved copy of ebodyl) */
                    if (outLevel >= 2) {
                        SPRINT0(2, "etemp1");
                        ocsmPrintEgo(etemp1);
                        SPRINT0(2, "ebodyr");
                        ocsmPrintEgo(ebodyr);
                    }

                    status = solidBoolean(MODL, etemp1, ebodyr, SUBTRACTION, maxtol, &emodel);

                    if (status < 0) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "trimming SUBTRACTION failed");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }
                    CHECK_STATUS(solidBoolean);

                    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                            data, &nchild, &ebodys, &senses);
                    CHECK_STATUS(EG_getTopology);

                    SPRINT1(2, "nchild=%d", nchild);

                    /* if more than one Body was created, keep the body that contains the trim point */
                    if (nchild > 1) {
                        etemp2 = NULL;
                        for (ichild = 0; ichild < nchild; ichild++) {
                            inbodyl = EG_inTopology(ebodys[ichild], xyz);
                            if (inbodyl == EGADS_SUCCESS) {

                                /* move the kept Body back to its original position */
                                matrix[ 3] *= -1;
                                matrix[ 7] *= -1;
                                matrix[11] *= -1;

                                status = EG_makeTransform(MODL->context, matrix, &exform);
                                CHECK_STATUS(EG_makeTransform);

                                status = EG_copyObject(ebodys[ichild], exform, &etemp2);
                                CHECK_STATUS(EG_copyObject);

                                status = EG_deleteObject(exform);
                                CHECK_STATUS(EG_deleteObject);
                            }
                        }

                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        if (etemp2 == NULL) {
                            signalError(MODL, OCSM_INTERNAL_ERROR,
                                        "none of the Bodys from the subtraction contain the trim point");

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }

                        if (outLevel >= 2) {
                            SPRINT0(2, "etemp2");
                            ocsmPrintEgo(etemp2);
                            SPRINT0(2, "ebodyr");
                            ocsmPrintEgo(ebodyr);
                        }

                        /* union the kept Body and ibodyr */
                        status = solidBoolean(MODL, etemp2, ebodyr, FUSION, maxtol, &emodel);
                        if (status < 0) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION (with trimmed Body) did not create a Body");

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }
                        CHECK_STATUS(solidBoolean);

                        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                                data, &nchild, &ebodys, &senses);
                        CHECK_STATUS(EG_getTopology);

                        SPRINT1(2, "nchild=%d", nchild);

                        if (nchild != 1) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION (with trimmed Body) created %d Bodys", nchild);

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }

                        status = EG_copyObject(ebodys[0], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        MODL->body[ibody].ebody = ebody;

                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        status = EG_deleteObject(etemp1);
                        CHECK_STATUS(EG_deleteObject);

                        status = EG_deleteObject(etemp2);
                        CHECK_STATUS(EG_deleteObject);

                    /* since subtraction only created one Body, do a simple
                       union of the two original Bodys (after deleting the emodel) */
                    } else {
                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        status = solidBoolean(MODL, ebodyl, ebodyr, FUSION, maxtol, &emodel);
                        if (status < 0) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION did not create a Body");
                            goto cleanup;
                        }
                        CHECK_STATUS(solidBoolean);

                        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                                data, &nchild, &ebodys, &senses);
                        CHECK_STATUS(EG_getTopology);

                        if (nchild != 1) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION failed");

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }

                        status = EG_copyObject(ebodys[0], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        MODL->body[ibody].ebody = ebody;

                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);
                    }
                }

                /* update @-parameters (UNION) and finish Body */
                status = setupAtPmtrs(MODL, 0);
                CHECK_STATUS(setupAtPmtrs);

                status = finishBody(MODL, ibody);
                if (MODL->sigCode != SUCCESS) goto cleanup;
                CHECK_STATUS(finishBody);

            /* union of 2 SheetBodys */
            } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                       MODL->body[ibodyr].botype == OCSM_SHEET_BODY    ) {

#ifndef USE_FUSESHEETS
                int    nleft, nrite, status2, nerror;
                ego    *efleft, *efrite, etemp, *eflist=NULL;
#endif

                /* create the new Body */
                status = newBody(MODL, ibrch, OCSM_UNION, ibodyl, ibodyr,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);

#ifdef USE_FUSESHEETS
                status = EG_fuseSheets(ebodyl, ebodyr, &ebody);
                CHECK_STATUS(EG_fuseSheets);

                MODL->body[ibody].ebody = ebody;
#else

                /* count the number of Faces in ebodyl and ebodyr */
                status = EG_getBodyTopos(ebodyl, NULL, FACE, &nleft, &efleft);
                CHECK_STATUS(EG_getBodyTopos);

                status = EG_getBodyTopos(ebodyr, NULL, FACE, &nrite, &efrite);
                CHECK_STATUS(EG_getBodyTopos);

                /* nrite==1, then promote ebodyl to a emodel and use EG_solidBoolean */
                if (nrite == 1) {
                    ebodyr = efrite[0];

                    status = EG_copyObject(ebodyl, NULL, &etemp);
                    CHECK_STATUS(EG_copyObject);

                    status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                             NULL, 1, &etemp, NULL, &ebodyl);
                    CHECK_STATUS(EG_makeTopology);

                    EG_free(efleft);
                    EG_free(efrite);

                    if (outLevel >= 2) {
                        SPRINT0(2, "ebodyl (actually a Model)");
                        ocsmPrintEgo(ebodyl);
                        SPRINT0(2, "ebodyr (actually one Face)");
                        ocsmPrintEgo(ebodyr);
                    }
                    status2 = solidBoolean(MODL, ebodyl, ebodyr, FUSION, maxtol, &emodel);
                    if (outLevel >= 2) {
                        SPRINT0(2, "emodel (which should contain only one Body)");
                        ocsmPrintEgo(emodel);
                    }

                    status = EG_deleteObject(ebodyl);
                    CHECK_STATUS(EG_deleteObject);

                    status = status2;
                    if (status < 0) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION did not create a Body");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }
                    CHECK_STATUS(solidBoolean);

                    /* ensure that only one Body was created */
                    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                            data, &nchild, &ebodys, &senses);
                    CHECK_STATUS(EG_getTopology);

                    if (nchild != 1) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION created %d Bodys", nchild);

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }

                    status = EG_copyObject(ebodys[0], NULL, &ebody);
                    CHECK_STATUS(EG_copyObject);

                    MODL->body[ibody].ebody = ebody;

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                /* nleft==1, then promote ebodyr to a emodel and use EG_solidBoolean */
                } else if (nleft == 1) {
                    ebodyl = efleft[0];

                    status = EG_copyObject(ebodyr, NULL, &etemp);
                    CHECK_STATUS(EG_copyObject);

                    status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                             NULL, 1, &etemp, NULL, &ebodyr);
                    CHECK_STATUS(EG_makeTopology);

                    EG_free(efleft);
                    EG_free(efrite);

                    status2 = solidBoolean(MODL, ebodyr, ebodyl, FUSION, maxtol, &emodel);

                    status = EG_deleteObject(ebodyr);
                    CHECK_STATUS(EG_deleteObject);

                    status = status2;
                    if (status < 0) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION did not create a Body");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }
                    CHECK_STATUS(solidBoolean);

                    /* ensure that only one Body was created */
                    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                            data, &nchild, &ebodys, &senses);
                    CHECK_STATUS(EG_getTopology);

                    if (nchild != 1) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION created %d Bodys", nchild);

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }

                    status = EG_copyObject(ebodys[0], NULL, &ebody);
                    CHECK_STATUS(EG_copyObject);

                    MODL->body[ibody].ebody = ebody;

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                /* ebodyl and ebodyr both contain multiple Faces, so sew them together */
                } else {
                    /* make a list of the Faces in both Bodys */
                    MALLOC(eflist, ego, nleft+nrite);

                    nlist = 0;
                    for (i = 0; i < nleft; i++) {
                        eflist[nlist++] = efleft[i];
                    }
                    for (i = 0; i < nrite; i++) {
                        eflist[nlist++] = efrite[i];
                    }

                    EG_free(efrite);
                    EG_free(efleft);

                    /* sew the Faces into a new SheetBody */
                    status = EG_sewFaces(nlist, eflist, maxtol, 1, &emodel);
                    CHECK_STATUS(EG_sewFaces);

                    FREE(eflist);

                    /* check to ensure emodel contains one SheetBody */
                    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                            data, &nchild, &echilds, &senses);
                    CHECK_STATUS(EG_getTopology);

                    if (oclass != MODEL || nchild != 1) {
                        nerror = 1;
                    } else {
                        nerror = 0;
                    }

                    /* if we encountered an error, try sewing the original two SheetBodys */
                    if (nerror > 0) {
                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        MALLOC(eflist, ego, 2);

                        eflist[0] = ebodyl;
                        eflist[1] = ebodyr;

                        status = EG_sewFaces(2, eflist, maxtol, 1, &emodel);
                        CHECK_STATUS(EG_sewFaces);

                        FREE(eflist);

                        /* check to ensure emodel contains one SheetBody */
                        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                                data, &nchild, &echilds, &senses);
                        CHECK_STATUS(EG_getTopology);

                        if (oclass != MODEL || nchild != 1) {
                            nerror = 1;
                        } else {
                            nerror = 0;
                        }
                    }

                    /* if we still encountered an error, try sewing the original two
                       SheetBodys in the opposite order */
                    if (nerror > 0) {
                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        MALLOC(eflist, ego, 2);

                        eflist[0] = ebodyr;
                        eflist[1] = ebodyl;

                        status = EG_sewFaces(2, eflist, maxtol, 1, &emodel);
                        CHECK_STATUS(EG_sewFaces);

                        FREE(eflist);

                        /* check to ensure emodel contains one SheetBody */
                        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                                data, &nchild, &echilds, &senses);
                        CHECK_STATUS(EG_getTopology);

                        if (oclass != MODEL || nchild != 1) {
                            nerror = 1;

                            SPRINT0(0, "ERROR:: emodel returned from EG_sewFaces:");
                            ocsmPrintEgo(emodel);

                            for (i = 0; i < nchild; i++) {
                                status = EG_getBoundingBox(echilds[i], bbox);
                                CHECK_STATUS(EG_getBoundingBox);

                                SPRINT4(0, "ERROR:: Body %3d: min=%11.5f %11.5f %11.5f", i, bbox[0], bbox[1], bbox[2]);
                                SPRINT3(0, "                  max=%11.5f %11.5f %11.5f",    bbox[3], bbox[4], bbox[5]);
                            }

                            status = EG_deleteObject(emodel);
                            CHECK_STATUS(EG_deleteObject);
                        } else {
                            nerror = 0;
                        }
                    }

                    /* if none of above worked, signal an error */
                    if (nerror > 0) {
                        if (oclass != MODEL) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION used SEW, which did not yield a MODEL");

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        } else if (nchild != 1) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION used SEW, which produced more than one BODY (nchild=%d)", nchild);

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }
                    }

                    status = EG_copyObject(echilds[0], NULL, &ebody);
                    CHECK_STATUS(EG_copyObject);

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                    status = EG_getTopology(ebody, &eref, &oclass, &mtype,
                                            data, &nchild, &echilds, &senses);
                    CHECK_STATUS(EG_getTopology);

                    if (oclass != BODY || mtype != SHEETBODY) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION did not produce a SheetBody");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }

                    MODL->body[ibody].ebody = ebody;
                }
#endif

                /* update @-parameters (UNION) and finish Body */
                status = setupAtPmtrs(MODL, 0);
                CHECK_STATUS(setupAtPmtrs);

                status = finishBody(MODL, ibody);
                if (MODL->sigCode != SUCCESS) goto cleanup;
                CHECK_STATUS(finishBody);
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "UNION expects two SolidBodys or two SheetBodys on stack");
                goto cleanup;
            }

        /* union all SolidBodys back to the mark */
        } else if (toMark == 1) {

            /* make a list of the SolidBodys back to mark */
            numBodys = 0;
            while ((*nstack) > 0) {
                ibodyl = stack[--(*nstack)];

                if (ibodyl == 0) {           /* mark is found */
                    break;
                } else if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "UNION 1 expects SolidBody on stack");

                    (void) freeBody(MODL, ibody);
                    MODL->nbody--;
                    goto cleanup;
                } else {
                    bodyList[numBodys++] = ibodyl;
                }
            }

            numRemaining = numBodys - 1;

            if (numBodys < 2) {
                signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                            "UNION toMark=1 expects 2 or more Bodys since mark");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

            /* recycle old Body if not dirty (note: special treatment to skip
               to last Body that matches this Branch) */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* loop through all pairs of Bodys until finished */
            nchange = 1;
            while (nchange > 0) {
                nchange = 0;

                for (i = numBodys-1; i >= 0; i--) {
                    if (bodyList[i] <= 0) continue;

                    for (j = numBodys-1; j >= 0; j--) {
                        if (bodyList[j] <= 0) continue;
                        if (j           == i) continue;

                        ibodyl = bodyList[i];
                        ibodyr = bodyList[j];

                        ebodyl = MODL->body[ibodyl].ebody;
                        ebodyr = MODL->body[ibodyr].ebody;

                        status = solidBoolean(MODL, ebodyl, ebodyr, FUSION, maxtol, &emodel);
                        if (status == EGADS_SUCCESS) {
                            MODL->sigCode = 0;

                            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                                    data, &nchild, &ebodys, &senses);
                            CHECK_STATUS(EG_getTopology);

                            if (nchild != 1) {
                                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                            "UNION produced %d Bodys", nchild);
                                goto cleanup;
                            }

                            status = newBody(MODL, ibrch, OCSM_UNION, ibodyl, ibodyr,
                                             args, hasdots, OCSM_SOLID_BODY, &ibody);
                            CHECK_STATUS(newBody);

                            SPRINT3(1, "                          ... unioning Bodys %4d and %4d to create Body %4d",
                                    ibodyl, ibodyr, ibody);

                            status = EG_copyObject(ebodys[0], NULL, &ebody);
                            CHECK_STATUS(EG_copyObject);

                            MODL->body[ibody].ebody = ebody;

                            numRemaining--;
                            status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                                     1, &numRemaining, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            /* update @-parameters (UNION) and finish Body */
                            status = setupAtPmtrs(MODL, 0);
                            CHECK_STATUS(setupAtPmtrs);

                            status = finishBody(MODL, ibody);
                            CHECK_STATUS(finishBody);

                            bodyList[i] = ibody;
                            bodyList[j] = 0;
                            nchange++;

                            status = EG_deleteObject(emodel);
                            CHECK_STATUS(EG_deleteObject);
                        }
                    }
                }
            }

            nchange = 0;
            for (i = 0; i < numBodys; i++) {
                if (bodyList[i] > 0) {
                    nchange++;
                }
            }

            if (nchange > 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "no changes in last pass");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

        /* union all FaceBodys back to mark (into a SolidBody) */
        } else if (toMark == 2) {
            signalError(MODL, OCSM_UNSUPPORTED,
                        "UNION toMark=2 no longer supported. use COMBINE instead.");
            SET_STATUS(OCSM_UNSUPPORTED, union_2);

        /* bad value for toMark */
        } else {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "bad value for toMark (%d)", toMark);
            goto cleanup;
        }

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "join toler=0 toMark=0" */
    } else if (type == OCSM_JOIN) {
        SPRINT3(1, "    executing [%4d] join:       %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0]);

        /* extract the argument */
        toler  =      args[1].val[0];
        toMark = NINT(args[2].val[0]);

        /* toMark is set */
        if (toMark != 0) {
            if ((*nstack) < 2) {
                signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                            "JOIN expects 2 Bodys on stack");
                goto cleanup;
            }

            itype    = MODL->body[stack[*nstack-1]].botype;
            numBodys = 1;

            if (itype != OCSM_WIRE_BODY && itype != OCSM_SHEET_BODY) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "JOIN with toMark only works on WireBodys or SheetBodys (and have %s)",
                            ocsmGetText(itype));
                goto cleanup;
            }

            /* count the Bodys back to Mark and make sure they are
               all the same type */
            for (i = (*nstack-1)-2; i >= 0; i--) {
                if        (stack[i] == 0) {
                    break;    /* found Mark */
                } else if (MODL->body[stack[i]].botype == itype) {
                    numBodys++;
                } else {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "JOIN with toMark must have same types (expecting %s but have %s at nstack=%d)",
                                ocsmGetText(itype), ocsmGetText(MODL->body[stack[i]].botype), i);
                    goto cleanup;
                }
            }

            numRemaining = numBodys;

            /* recycle old Body if not dirty (note: special treatment to skip
               to last Body that matches this Branch) */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                while ((*nstack) > 0) {
                    ibodyl = stack[--(*nstack)];
                    if (ibodyl == 0) break;       /* mark is found */
                }

                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* join the Bodys in pairs */
            for (i = 0; i < numBodys; i++) {
                ibodyl = stack[*nstack-1-i];
                for (j = i+1; j <= numBodys; j++) {
                    ibodyr = stack[*nstack-1-j];

                    saveOutLevel = ocsmSetOutLevel(-1);
                    (void) EG_setOutLevel(MODL->context, 0);
                    if (itype == OCSM_WIRE_BODY) {
                        status = joinWireBodys(MODL, MODL->body[ibodyl].ebody,
                                                     MODL->body[ibodyr].ebody,
                                               toler, &ebody);
                    } else {
                        status = joinSheetBodys(MODL, MODL->body[ibodyl].ebody,
                                                      MODL->body[ibodyr].ebody,
                                                toler, &ebody);
                    }
                    (void) EG_setOutLevel(MODL->context, saveOutLevel);
                    (void) ocsmSetOutLevel(saveOutLevel);
                    if (status == SUCCESS) {
                        /* swap j and i-1 */
                        if (j != i-1) {
                            swap               = stack[*nstack-j-1];
                            stack[*nstack-j-1] = stack[*nstack-i-2];
                            stack[*nstack-i-2] = swap;
                        }

                        /* pop two entries from the stack */
                        (*nstack) -= 2;

                        /* create the new Body */
                        status = newBody(MODL, ibrch, OCSM_JOIN, ibodyl, ibodyr,
                                         args, hasdots, itype, &ibody);
                        CHECK_STATUS(newBody);

                        MODL->body[ibody].ebody = ebody;

                        numRemaining--;
                        status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                                 1, &numRemaining, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* update @-parameters (JOIN) and finish Body */
                        status = setupAtPmtrs(MODL, 0);
                        CHECK_STATUS(setupAtPmtrs);

                        status = finishBody(MODL, ibody);
                        if (MODL->sigCode != SUCCESS) goto cleanup;
                        CHECK_STATUS(finishBody);

                        /* push the Body onto the stack */
                        stack[(*nstack)++] = ibody;

                        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                        CHECK_STATUS(getBodyTolerance);

                        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                                ibody, toler);

                        /* there is now one fewer Bodys since Mark.  Also, reprocess
                           stack entry i */
                        numBodys--;
                        i--;
                        break;
                    }
                }
            }

            /* remove the mark (if it exists) */
            if (*nstack > 1) {
                if (stack[*nstack-2] == 0) {
                    stack[*nstack-2] = stack[*nstack-1];
                    (*nstack)--;
                }
            }

            goto cleanup;
        }

        /* pop 2 Bodys from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "JOIN expects 2 Bodys on stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* join two SolidBodys */
        if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
            MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {
            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            /* determine the pairs of matched Faces */
            status = EG_matchBodyFaces(ebodyl, ebodyr, toler, &nmatch, &matches);
            CHECK_STATUS(EG_matchBodyFaces);

            if (nmatch < 1) {
                signalError(MODL, OCSM_FACE_NOT_FOUND,
                            "expecting nmatch>=1 but got %d", nmatch);
                FREE(matches);
                goto cleanup;
            }

            /* make a list of the Faces to sew.  remove any from list that
               are in matches, which was generated above */
            nfacel = MODL->body[ibodyl].nface;
            nfacer = MODL->body[ibodyr].nface;

            MALLOC(efaces, ego, nfacel+nfacer);

            j = 0;
            for (i = 1; i <= nfacel; i++) {
                efaces[j++] = MODL->body[ibodyl].face[i].eface;
                SPRINT3(3, "adding   Face %d (%llx) to   efaces for Body %d", i, (long long)efaces[j-1], ibodyl);
                for (k = 0; k < nmatch; k++) {
                    if (i == matches[2*k]) {
                        SPRINT3(3, "removing Face %d (%llx) from efaces for Body %d", i, (long long)efaces[j-1], ibodyl);
                        j--;
                        break;
                    }
                }
            }
            for (i = 1; i <= nfacer; i++) {
                efaces[j++] = MODL->body[ibodyr].face[i].eface;
                SPRINT3(3, "adding   Face %d (%llx) to   efaces for Body %d", i, (long long)efaces[j-1], ibodyr);
                for (k = 0; k < nmatch; k++) {
                    if (i == matches[2*k+1]) {
                        SPRINT3(3, "removing Face %d (%llx) from efaces for Body %d", i, (long long)efaces[j-1], ibodyl);
                        j--;
                        break;
                    }
                }
            }
            SPRINT1(3, "there are %d faces in efaces", j);

            if (toler == 0) {
                EG_free(matches);
                matches = NULL;
            } else {
                FREE(matches);
            }

            status = EG_sewFaces(j, efaces, toler, 0, &emodel);
            CHECK_STATUS(EG_sewFaces);

            FREE(efaces);

            /* if the Model contains a single SolidBody, extract it */
            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &ebodys, &senses);
            CHECK_STATUS(EG_getTopology);

            if (nchild < 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "JOIN did not create a Body");
                goto cleanup;
            } else if (nchild > 1) {
                signalError(MODL, OCSM_CREATED_TOO_MANY_BODYS,
                            "JOIN created multiple Bodys");
                goto cleanup;
            } else {
                status = EG_getTopology(ebodys[0], &eref, &oclass, &mtype,
                                        data, &nface, &efaces, &senses);
                CHECK_STATUS(EG_getTopology);

                if (oclass != BODY || mtype != SOLIDBODY) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "JOIN expected a SolidBody to be produced");
                    goto cleanup;
                }

                /* create the new Body */
                status = newBody(MODL, ibrch, OCSM_JOIN, ibodyl, ibodyr,
                                 args, hasdots, OCSM_SOLID_BODY, &ibody);
                CHECK_STATUS(newBody);

                status = EG_copyObject(ebodys[0], NULL, &ebody);
                CHECK_STATUS(EG_copyObject);

                MODL->body[ibody].ebody = ebody;
            }

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

        /* join two SheetBodys */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {

            status = EG_fuseSheets(MODL->body[ibodyl].ebody,
                                   MODL->body[ibodyr].ebody, &ebody);

            if (status != SUCCESS) {
                status = joinSheetBodys(MODL, MODL->body[ibodyl].ebody,
                                              MODL->body[ibodyr].ebody,
                                        toler, &ebody);
                CHECK_STATUS(joinSheetBodys);
            }

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_JOIN, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        /* join two WireBodys */
        } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY &&
                   MODL->body[ibodyr].botype == OCSM_WIRE_BODY   ) {

            status = joinWireBodys(MODL, MODL->body[ibodyl].ebody,
                                         MODL->body[ibodyr].ebody,
                                   toler, &ebody);
            if (status == OCSM_DID_NOT_CREATE_BODY) {

                signalError(MODL, status,
                            "WireBodys to JOIN are not contiguous");
                goto cleanup;
            }
            CHECK_STATUS(joinWireBodys);

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_JOIN, ibodyl, ibodyr,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        } else {
            status = OCSM_WRONG_TYPES_ON_STACK;
            signalError(MODL, status,
                        "JOIN expects 2 SolidBodys, SheetBodys, or WireBodys on stack");
            goto cleanup;
        }

        /* update @-parameters (JOIN) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "extract entList" */
    } else if (type == OCSM_EXTRACT) {
        SPRINT2(1, "    executing [%4d] extract:    %s",
                ibrch, MODL->brch[ibrch].arg1);

        /* make sure that the signs of all entList entries are the same */
        if (args[1].nval > 1) {
            for (i = 1; i < args[1].nval; i++) {
                if (args[1].val[0]*args[1].val[i] <= 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "all entries in entList must have same sign");
                    goto cleanup;
                }
            }
        }

        /* pop a Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "EXTRACT expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* make sure the Body is a SolidBody or SheetBody */
        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY &&
            MODL->body[ibodyl].botype != OCSM_SHEET_BODY   ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "EXTRACT expects a SheetBody or a SolidBody");
            goto cleanup;
        }

        /* check for valid Face or Edge index */
        for (i = 0; i < args[1].nval; i++) {
            if        (+NINT(args[1].val[i]) > MODL->body[ibodyl].nface) {
                signalError(MODL, OCSM_FACE_NOT_FOUND,
                            "Face index (%d) is out of range", NINT(args[1].val[i]));
                goto cleanup;
            } else if (-NINT(args[1].val[i]) > MODL->body[ibodyl].nedge) {
                signalError(MODL, OCSM_EDGE_NOT_FOUND,
                            "Edge index (%d) is out of range", NINT(args[1].val[i]));
                goto cleanup;
            }
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        ebodyl = MODL->body[ibodyl].ebody;

        /* convert a SolidBody into a SheetBody (extract shell) */
        if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
            NINT(args[1].val[0])      == 0                 ) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRACT, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_getBodyTopos(ebodyl, NULL, SHELL, &nshell, &eshells);
            CHECK_STATUS(EG_getBodyTopos);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, eshells, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            EG_free(eshells);

            MODL->body[ibody].ebody = ebody;

        /* extract Edges surrounding a SheetBody into a WireBody */
        } else if (NINT(args[1].val[0]) == 0) {

            MALLOC(elist, ego, MODL->body[ibodyl].nedge);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRACT, ibodyl, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            i = 0;
            for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {
                if (MODL->body[ibodyl].edge[iedge].nface == 1) {
                    elist[i++] = MODL->body[ibodyl].edge[iedge].eedge;
                }
            }

            status = EG_makeLoop(i, elist, NULL, 0, &eloop);
            CHECK_STATUS(EG_makeLoop);

            FREE(elist);

            if (status > 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "exposed Edges do not make a single loop");
                goto cleanup;
            }

            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL,
                                     1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            status = EG_deleteObject(eloop);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].ebody = ebody;

        /* extract selected Faces from a SolidBody or SheetBody to create a SheetBody */
        } else if (NINT(args[1].val[0]) > 0) {
            status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRACT, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            if (args[1].nval == 1) {
                senses1[0] = SFORWARD;
                status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                         NULL, 1, &(efaces[NINT(args[1].val[0])-1]), senses1, &eshell);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                         NULL, 1, &eshell, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);

                status = EG_deleteObject(eshell);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[ibody].ebody = ebody;
            } else {
                MALLOC(elist, ego, args[1].nval);

                for (i = 0; i < args[1].nval; i++) {
                    elist[i] = efaces[NINT(args[1].val[i])-1];
                }

                status = EG_sewFaces(args[1].nval, elist, 0, 0, &emodel);
                CHECK_STATUS(EG_sewFaces);

                FREE(elist);

                /* if the Model contains a single SolidBody, extract it */
                status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                        data, &nchild, &ebodys, &senses);
                CHECK_STATUS(EG_getTopology);

                if (nchild > 1) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "Faces in EXTRACT are not contiguous");

                    (void) EG_deleteObject(emodel);
                    (void) freeBody(MODL, ibody);
                    EG_free(efaces);
                    goto cleanup;
                }

                status = EG_copyObject(ebodys[0], NULL, &ebody);
                CHECK_STATUS(EG_copyObject);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[ibody].ebody = ebody;
            }

            EG_free(efaces);

        /* extract selected Edges from a SolidBody or SheetBody to create a WireBody */
        } else {
            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRACT, ibodyl, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            if (args[1].nval == 1) {
                senses1[0] = SFORWARD;

                status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN, NULL,
                                         1, &(eedges[-NINT(args[1].val[0])-1]), senses1, &eloop);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                         NULL, 1, &eloop, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);

                status = EG_deleteObject(eloop);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[ibody].ebody = ebody;
            } else {
                MALLOC(elist, ego, args[1].nval);

                for (i = 0; i < args[1].nval; i++) {
                    elist[i] = eedges[-NINT(args[1].val[i])-1];
                }

                status = EG_makeLoop(args[1].nval, elist, NULL, 0, &eloop);
                CHECK_STATUS(EG_makeLoop);

                FREE(elist);

                if (status > 0) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "Edges in EXTRACT are not contiguous");

                    (void) freeBody(MODL, ibody);
                    EG_free(eedges);
                    goto cleanup;
                }

                status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL,
                                         1, &eloop, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);

                status = EG_deleteObject(eloop);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[ibody].ebody = ebody;
            }

            EG_free(eedges);
        }

        /* update @-parameters (EXTRACT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "combine toler=0" */
    } else if (type == OCSM_COMBINE) {
        SPRINT2(1, "    executing [%4d] combine:    %11.5f",
                ibrch, args[1].val[0]);

        /* extract the argument */
        toler = args[1].val[0];

        /* make a list to the Bodys back to mark */
        numBodys = 0;
        nedges   = 0;
        while ((*nstack) > 0) {
            ibodyl = stack[--(*nstack)];

            if (ibodyl == 0) {               /* mark is found */
                break;
            } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY ||
                       MODL->body[ibodyl].botype == OCSM_SHEET_BODY  ) {
                bodyList[numBodys++] = ibodyl;
                nedges += MODL->body[ibodyl].nedge;
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "COMBINE expects WireBody or SheetBody on stack");
                goto cleanup;
            }
        }

        if (numBodys < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "COMBINE expects one or more Bodys since mark");
            goto cleanup;
        }

        bodyType = MODL->body[bodyList[0]].botype;
        for (i = 1; i < numBodys; i++) {
            if (MODL->body[bodyList[i]].botype != bodyType) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "COMBINE found mixed Body types on stack");
                goto cleanup;
            }
        }

        ibodyl = bodyList[numBodys-1];
        ibodyr = bodyList[0         ];

        /* recycle old Body if not dirty (note: special treatment to skip
           to last Body that matches this Branch) */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* combine single WireBody into a SheetBody */
        if (bodyType == OCSM_WIRE_BODY && numBodys == 1) {
            status = EG_getBodyTopos(MODL->body[bodyList[0]].ebody, NULL, LOOP, &nchild, &echilds);
            CHECK_STATUS(EG_getBodyTopos);

            status = EG_getInfo(echilds[0], &oclass, &mtype, &etopref, &eprev, &enext);
            CHECK_STATUS(EG_getInfo);

            if (mtype != CLOSED) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "CONNECT with single WireBody must be closed");
                goto cleanup;
            }

            status = EG_makeFace(echilds[0], SFORWARD, NULL, &eface);
            CHECK_STATUS(EG_makeFace);

            EG_free(echilds);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN, NULL,
                                     1, &eface, NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY, NULL,
                                     1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, 0,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

            /* update @-parameters (COMBINE) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                    ibody, toler);

        /* combine WireBodys into a SheetBody */
        } else if (bodyType == OCSM_WIRE_BODY) {
            /* make list of Edges in the WireBodys */
            MALLOC(elist, ego, nedges);

            k = 0;
            for (i = numBodys-1; i >= 0; i--) {
                ebody = MODL->body[bodyList[i]].ebody;

                status = EG_getTopology(ebody, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                eloop = echilds[0];

                status = EG_getTopology(eloop, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                for (j = 0; j < nchild; j++) {
                    status = EG_copyObject(echilds[j], NULL, &(elist[k++]));
                    CHECK_STATUS(EG_copyObject);

                    if (outLevel >= 2) {
                        SPRINT1(2, "before makeLoop: elist[%d]", k-1);
                        ocsmPrintEgo(elist[k-1]);
                    }
                }
            }

            /* make the Loop, Face, and then the FaceBody */
            status = EG_makeLoop(nedges, elist, NULL, toler, &eloop);
            CHECK_STATUS(EG_makeLoop);

            if (outLevel >= 2) {
                SPRINT0(2, "eloop");
                ocsmPrintEgo(eloop);
            }

            if (status > 0) {
                EG_free(eloop);
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "Edges could not combined into a single Loop");
                goto cleanup;
            }

            /* make sure that Loop starts at first Edge */

            status = EG_getArea(eloop, NULL, &area);
            CHECK_STATUS(EG_getArea);

            /* if the area<0, then we need to flip the Loop now so that when
               we make the Face, we can use SREVERSE to flip the loop back.  if
               this is not done, the Loop will be flipped in the makeTopology(BODY),
               resulting in a FACEBODY that cannot be used in rule or blend */
            if (area < 0) {
                SPRINT1(1, "WARNING:: backwards Loop has area=%f that will be reversed", area);
                (MODL->nwarn)++;

                eflip = eloop;

                status = EG_flipObject(eflip, &eloop);
                CHECK_STATUS(EG_flipObject);
            }

            if (area > 0) {
                status = EG_makeFace(eloop, SFORWARD, NULL, &eface);
                CHECK_STATUS(EG_makeFace);
            } else {
                status = EG_makeFace(eloop, SREVERSE, NULL, &eface);
                CHECK_STATUS(EG_makeFace);
            }

            status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
                                     NULL, 1, &eface, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

            /* attach the Body to its children */
            for (i = 0; i < numBodys; i++) {
                MODL->body[bodyList[i]].ichld = ibody;
            }

            /* mark the new Faces with the current Branch */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            for (iface = 1; iface <= nface; iface++) {
                status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }

            EG_free(efaces);

            /* update @-parameters (COMBINE) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                    ibody, toler);

        /* convert single SheetBody into a SolidBody */
        } else if (bodyType == OCSM_SHEET_BODY && numBodys == 1) {
            status = EG_getBodyTopos(MODL->body[bodyList[0]].ebody, NULL, SHELL, &nchild, &echilds);
            CHECK_STATUS(EG_getBodyTopos);

            status = EG_getInfo(echilds[0], &oclass, &mtype, &etopref, &eprev, &enext);
            CHECK_STATUS(EG_getInfo);

            if (mtype != CLOSED) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "CONNECT with single SheetBody must be closed");
                goto cleanup;
            }

            status = EG_makeTopology(MODL->context, NULL, BODY, SOLIDBODY, NULL,
                                     1, echilds, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            EG_free(echilds);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, 0,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (COMBINE) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                    ibody, toler);

        /* combine SheetBodys into a SolidBody */
        } else if (bodyType == OCSM_SHEET_BODY) {

            /* make a list of the FaceBodys */
            MALLOC(elist, ego, numBodys);

            for (i = 0; i < numBodys; i++) {
                ebodyl = MODL->body[bodyList[i]].ebody;

                status = EG_getTopology(ebodyl, &eref, &oclass, &mtype,
                                        data, &nface, &efaces, &senses);
                CHECK_STATUS(EG_getTopology);

                if (nface != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "SheetBody has more than one FACE (nface=%d)", nface);
                    goto cleanup;
                }

                elist[i] = efaces[0];

                if (outLevel > 1) {
                    SPRINT1(2, "elist[%d]:", i);
                    (void) ocsmPrintEgo(elist[i]);
                }
            }

            /* sew them together into a Model using default tolerance */
            status = EG_sewFaces(numBodys, elist, toler, 0, &emodel);
            CHECK_STATUS(EG_sewfaces);

            /* if the Model contains a single SolidBody, extract it */
            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &ebodys, &senses);
            CHECK_STATUS(EG_getTopology);

            if (nchild < 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "COMBINE was expecting that a SolidBody would be produced");
                goto cleanup;
            } else {
                status = EG_getTopology(ebodys[0], &eref, &oclass, &mtype,
                                        data, &nface, &efaces, &senses);
                CHECK_STATUS(EG_getTopology);

                if (oclass != BODY) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "COMBINE was expecting that a SolidBody would be produced");
                    goto cleanup;
                } else if (mtype != SOLIDBODY) {
                    SPRINT0(1, "WARNING:: COMBINE produced an (open) SheetBody");
                    (MODL->nwarn)++;

                    itype = OCSM_SHEET_BODY;
                } else {
                    itype = OCSM_SOLID_BODY;
                }

                status = EG_copyObject(ebodys[0], NULL, &ebody);
                CHECK_STATUS(EG_copyObject);

                if (nchild > 1) {
                    SPRINT1(1, "WARNING:: %d Bodys are being lost", nchild-1);
                    (MODL->nwarn)++;
                }
            }

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, ibodyr,
                             args, hasdots, itype, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

            /* attach the Body to its children */
            for (i = 0; i < numBodys; i++) {
                MODL->body[bodyList[i]].ichld = ibody;
            }

            /* update @-parameters (COMBINE) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                    ibody, toler);
        }

    /* execute: "connect faceList1 faceList2 edgeList1=0 edgeList2=0" */
    } else if (type == OCSM_CONNECT) {
        SPRINT5(1, "    executing [%4d] connect:    %s  %s  %s  %s",
                ibrch, MODL->brch[ibrch].arg1, MODL->brch[ibrch].arg2,
                       MODL->brch[ibrch].arg3, MODL->brch[ibrch].arg4);

        /* pop two Bodys from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "CONNECT expects two Bodys on the stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;
        }

        for (i = 0; i < args[1].nval; i++) {
            SPRINT2(2, "   args[1].val[%2d]=%d", i, NINT(args[1].val[i]));
        }
        for (i = 0; i < args[2].nval; i++) {
            SPRINT2(2, "   args[2].val[%2d]=%d", i, NINT(args[2].val[i]));
        }
        for (i = 0; i < args[3].nval; i++) {
            SPRINT2(2, "   args[3].val[%2d]=%d", i, NINT(args[3].val[i]));
        }
        for (i = 0; i < args[4].nval; i++) {
            SPRINT2(2, "   args[4].val[%2d]=%d", i, NINT(args[4].val[i]));
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
                goto cleanup;
        }

        /* make sure that the number of values in args[1] and args[2] are the same */
        if (args[1].nval < 1 || args[2].nval < 1) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "faceList1 and faceList2 must contain 1 or more Faces");
            goto cleanup;
        } else if (args[1].nval != args[2].nval) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "faceList1 and faceList2 must contain same number of Faces");
            goto cleanup;
        }

        /* make sure that the number of values in args[3] and args[4] are the same */
        if (args[3].nval != args[4].nval) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "edgeList1 and edgeList2 must contain same number of Edges");
            goto cleanup;
        }

        /* only faceLists are given */
        if (NINT(args[3].val[0]) == 0 && NINT(args[4].val[0]) == 0) {

            /* make sure both Bodys are SolidBodys */
            if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY ||
                MODL->body[ibodyr].botype != OCSM_SOLID_BODY   ) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "CONNECT only works with SolidBodys");
                goto cleanup;
            }

            nEdgeList = MODL->body[ibodyl].nedge + MODL->body[ibodyr].nedge;
            nFaceList = MODL->body[ibodyl].nface + MODL->body[ibodyr].nface + 2 * nEdgeList;
            MALLOC(edgeList, ego, nEdgeList);
            MALLOC(faceList, ego, nFaceList);

            /* make a list of the Edges that surround the Faces in
               ebodyl and remove duplicates along the way */
            nEdgeList = 0;
            for (ii = 0; ii < args[1].nval; ii++) {
                iface = NINT(args[1].val[ii]);
                if (iface < 1 || iface > MODL->body[ibodyl].nface) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "faceList1 contains illegal Face number (%d) %d", iface, MODL->body[ibodyl].nface);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, MODL->body[ibodyl].face[iface].eface, EDGE,
                                         &nnn, &nnnList);
                CHECK_STATUS(EG_getBodyTopos);

                for (iii = 0; iii < nnn; iii++) {
                    status = EG_getInfo(nnnList[iii], &oclass, &mtype, &etopref, &eprev, &enext);
                    CHECK_STATUS(EG_getInfo);

                    if (mtype == DEGENERATE) continue;

                    /* if a duplicate, remove its partner from list */
                    iadd = 1;
                    for (jjj = 0; jjj < nEdgeList; jjj++) {
                        if (nnnList[iii] == edgeList[jjj]) {
                            edgeList[jjj] = edgeList[nEdgeList-1];
                            nEdgeList--;
                            iadd = 0;
                            break;
                        }
                    }

                    /* if not found, add to list */
                    if (iadd == 1) {
                        edgeList[nEdgeList] = nnnList[iii];
                        nEdgeList++;
                    }
                }

                EG_free(nnnList);
            }

            /* make a Loop out of edgeList so that we get the Edges in order and
               know the senses */
            status = EG_makeLoop(nEdgeList, edgeList, NULL, 0, &eloops[0]);
            CHECK_STATUS(EG_makeLoop);

            if (status > 0) {
                SPRINT0(0, "ERROR:: expected Loop to be closed (eloop[0])");
                ocsmPrintEgo(eloops[0]);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            status = EG_getTopology(eloops[0], &eref, &oclass, &mtype, data,
                                    &nEdgeListl, &edgeListl, &sensesl);
            CHECK_STATUS(EG_getTopology);

            /* make a list of the Edges that surround the Faces in ebodyr and
               remove duplicates along the way */
            nEdgeList = 0;
            for (ii = 0; ii < args[2].nval; ii++) {
                iface = NINT(args[2].val[ii]);
                if (iface < 1 || iface > MODL->body[ibodyr].nface) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "faceList2 contains illegal Face number (%d) %d", iface, MODL->body[ibodyr].nface);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyr, MODL->body[ibodyr].face[iface].eface, EDGE,
                                         &nnn, &nnnList);
                CHECK_STATUS(EG_getBodyTopos);

                for (iii = 0; iii < nnn; iii++) {
                    status = EG_getInfo(nnnList[iii], &oclass, &mtype, &etopref, &eprev, &enext);
                    CHECK_STATUS(EG_getInfo);

                    if (mtype == DEGENERATE) continue;

                    /* if a duplicate, remove its partner from list */
                    iadd = 1;
                    for (jjj = 0; jjj < nEdgeList; jjj++) {
                        if (nnnList[iii] == edgeList[jjj]) {
                            edgeList[jjj] = edgeList[nEdgeList-1];
                            nEdgeList--;
                            iadd = 0;
                            break;
                        }
                    }

                    /* if not found, add to list */
                    if (iadd == 1) {
                        edgeList[nEdgeList] = nnnList[iii];
                        nEdgeList++;
                    }
                }

                EG_free(nnnList);
            }

            /* make a Loop out of edgeList so that we get the Edges in order and
               know the senses */
            status = EG_makeLoop(nEdgeList, edgeList, NULL, 0, &eloops[1]);
            CHECK_STATUS(EG_makeLoop);

            if (status > 0) {
                SPRINT0(0, "ERROR:: expected Loop to be closed (eloop[1])");
                ocsmPrintEgo(eloops[1]);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            /* reorder eloops[1] so that it matches eloops[0] */
            status = reorderLoops(MODL, 2, eloops, 1);
            CHECK_STATUS(reorderLoops);

            status = EG_getTopology(eloops[1], &eref, &oclass, &mtype, data,
                                    &nEdgeListr, &edgeListr, &sensesr);
            CHECK_STATUS(EG_getTopology);

            /* make Edges between the Nodes in the two Loops */
            for (ii = 0; ii < nEdgeListl; ii++) {
                status = EG_getTopology(edgeListl[ii], &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (sensesl[ii] == SFORWARD) {
                    enodes[0] = echilds[0];
                } else {
                    enodes[0] = echilds[1];
                }

                status = EG_getTopology(edgeListr[ii], &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (sensesr[ii] == SFORWARD) {
                    enodes[1] = echilds[0];
                } else {
                    enodes[1] = echilds[1];
                }

                status = makeEdge(MODL, enodes[0], enodes[1], &(edgeList[ii]));
                CHECK_STATUS(makeEdge);
            }

            /* make Faces between the Edges in the two Loops */
            nFaceList = 0;
            for (ii = 0; ii < nEdgeListl; ii++) {
                eedges2[0] = edgeListl[ii];
                eedges2[1] = edgeList[ ii];
                eedges2[2] = edgeListr[ii];
                eedges2[3] = edgeList[(ii+1)%nEdgeListl];

                status = makeFace(MODL, eedges2, fillstyle, SFORWARD, &(faceList[nFaceList]));
                CHECK_STATUS(makeFace);

                nFaceList++;
            }

        /* edgeLists are given, so create bridging Faces between the two SheetBodys */
        } else {
            /* make sure both Bodys are SheetBodys or SolidBodys */
            if        (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                       MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {
            } else if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
                       MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "CONNECT only works with SheetBodys or SolidBodys");
                goto cleanup;
            }

            nEdgeList = MODL->body[ibodyl].nedge + MODL->body[ibodyr].nedge;
            nFaceList = MODL->body[ibodyl].nface + MODL->body[ibodyr].nface + 2 * nEdgeList;
            MALLOC(edgeList, ego, nEdgeList);
            MALLOC(faceList, ego, nFaceList);

            nFaceList = 0;

            for (ii = 0; ii < args[3].nval; ii++) {
                iedgel = NINT(args[3].val[ii]);
                iedger = NINT(args[4].val[ii]);

                if (iedgel == 0 && iedger == 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "CONNECT cannot have 0 at same position in edgeList1 and edgeList2");
                    goto cleanup;

                } else if (iedgel == 0) {
                    if (ii == 0 || ii == args[3].nval-1) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "CONNECT cannot have 0 entry at beg or end of edgeList1");
                        goto cleanup;
                    } else if (NINT(args[3].val[ii-1]) == 0 || NINT(args[3].val[ii+1]) == 0) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "CONNECT can not have consecutive 0s in edgeList1");
                        goto cleanup;
                    }
                    if        (MODL->body[ibodyl].edge[NINT(args[3].val[ii-1])].ibeg ==
                               MODL->body[ibodyl].edge[NINT(args[3].val[ii+1])].ibeg    ) {
                        iedgel    = NINT(args[3].val[ii-1]);
                        inode     = MODL->body[ibodyl].edge[iedgel].ibeg;
                        enodes[0] = MODL->body[ibodyl].node[inode ].enode;
                    } else if (MODL->body[ibodyl].edge[NINT(args[3].val[ii-1])].ibeg ==
                               MODL->body[ibodyl].edge[NINT(args[3].val[ii+1])].iend    ) {
                        iedgel    = NINT(args[3].val[ii-1]);
                        inode     = MODL->body[ibodyl].edge[iedgel].ibeg;
                        enodes[0] = MODL->body[ibodyl].node[inode ].enode;
                    } else if (MODL->body[ibodyl].edge[NINT(args[3].val[ii-1])].iend ==
                               MODL->body[ibodyl].edge[NINT(args[3].val[ii+1])].ibeg    ) {
                        iedgel    = NINT(args[3].val[ii-1]);
                        inode     = MODL->body[ibodyl].edge[iedgel].iend;
                        enodes[0] = MODL->body[ibodyl].node[inode ].enode;
                    } else if (MODL->body[ibodyl].edge[NINT(args[3].val[ii-1])].iend ==
                               MODL->body[ibodyl].edge[NINT(args[3].val[ii+1])].iend    ) {
                        iedgel    = NINT(args[3].val[ii-1]);
                        inode     = MODL->body[ibodyl].edge[iedgel].iend;
                        enodes[0] = MODL->body[ibodyl].node[inode ].enode;
                    } else {
                        signalError(MODL, OCSM_NODE_NOT_FOUND,
                                    "CONNECT could not find Node for degenerate Face");
                        goto cleanup;
                    }

                    status = makeEdge(MODL, enodes[0],
                                            MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].enode, &(edgeList[0]));
                    CHECK_STATUS(makeEdge);

                    edgeList[1] = MODL->body[ibodyr].edge[iedger].eedge;

                    status = makeEdge(MODL, enodes[0],
                                            MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].enode, &(edgeList[2]));
                    CHECK_STATUS(makeEdge);

                    edgeList[3] = NULL;

                    status = makeFace(MODL, edgeList, fillstyle, SFORWARD, &(faceList[nFaceList]));
                    CHECK_STATUS(makeFace);

                    nFaceList++;
                } else if (iedger == 0) {
                    if (ii == 0 || ii == args[4].nval-1) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "CONNECT cannot have 0 entry at beg or end of edgeList2");
                        goto cleanup;
                    } else if (NINT(args[4].val[ii-1]) == 0 || NINT(args[4].val[ii+1]) == 0) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "CONNECT can not have consecutive 0s in edgeList2");
                        goto cleanup;
                    }
                    if        (MODL->body[ibodyr].edge[NINT(args[4].val[ii-1])].ibeg ==
                               MODL->body[ibodyr].edge[NINT(args[4].val[ii+1])].ibeg    ) {
                        iedger    = NINT(args[4].val[ii-1]);
                        inode     = MODL->body[ibodyr].edge[iedger].ibeg;
                        enodes[1] = MODL->body[ibodyr].node[inode ].enode;
                    } else if (MODL->body[ibodyr].edge[NINT(args[4].val[ii-1])].ibeg ==
                               MODL->body[ibodyr].edge[NINT(args[4].val[ii+1])].iend    ) {
                        iedger    = NINT(args[4].val[ii-1]);
                        inode     = MODL->body[ibodyr].edge[iedger].ibeg;
                        enodes[1] = MODL->body[ibodyr].node[inode ].enode;
                    } else if (MODL->body[ibodyr].edge[NINT(args[4].val[ii-1])].iend ==
                               MODL->body[ibodyr].edge[NINT(args[4].val[ii+1])].ibeg    ) {
                        iedger    = NINT(args[4].val[ii-1]);
                        inode     = MODL->body[ibodyr].edge[iedger].iend;
                        enodes[1] = MODL->body[ibodyr].node[inode ].enode;
                    } else if (MODL->body[ibodyr].edge[NINT(args[4].val[ii-1])].iend ==
                               MODL->body[ibodyr].edge[NINT(args[4].val[ii+1])].iend    ) {
                        iedger    = NINT(args[4].val[ii-1]);
                        inode     = MODL->body[ibodyr].edge[iedger].iend;
                        enodes[1] = MODL->body[ibodyr].node[inode ].enode;
                    } else {
                        signalError(MODL, OCSM_NODE_NOT_FOUND,
                                    "CONNECT could not find Node for degenerate Face");
                        goto cleanup;
                    }

                    status = makeEdge(MODL, MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].enode,
                                            enodes[1], &(edgeList[0]));
                    CHECK_STATUS(makeEdge);

                    edgeList[1] = MODL->body[ibodyl].edge[iedgel].eedge;

                    status = makeEdge(MODL, MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].enode,
                                            enodes[1], &(edgeList[2]));
                    CHECK_STATUS(makeEdge);

                    edgeList[3] = NULL;

                    status = makeFace(MODL, edgeList, fillstyle, SREVERSE, &(faceList[nFaceList]));
                    CHECK_STATUS(makeFace);

                    nFaceList++;
                } else {
                    xyz0[0] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].x;
                    xyz0[1] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].y;
                    xyz0[2] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].z;

                    xyz1[0] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].x;
                    xyz1[1] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].y;
                    xyz1[2] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].z;

                    xyz2[0] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].x;
                    xyz2[1] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].y;
                    xyz2[2] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].z;

                    xyz3[0] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].x;
                    xyz3[1] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].y;
                    xyz3[2] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].z;

                    dist02 = (xyz0[0]-xyz2[0])*(xyz0[0]-xyz2[0]) + (xyz0[1]-xyz2[1])*(xyz0[1]-xyz2[1]) + (xyz0[2]-xyz2[2])*(xyz0[2]-xyz2[2]);
                    dist03 = (xyz0[0]-xyz3[0])*(xyz0[0]-xyz3[0]) + (xyz0[1]-xyz3[1])*(xyz0[1]-xyz3[1]) + (xyz0[2]-xyz3[2])*(xyz0[2]-xyz3[2]);
                    dist12 = (xyz1[0]-xyz2[0])*(xyz1[0]-xyz2[0]) + (xyz1[1]-xyz2[1])*(xyz1[1]-xyz2[1]) + (xyz1[2]-xyz2[2])*(xyz1[2]-xyz2[2]);
                    dist13 = (xyz1[0]-xyz3[0])*(xyz1[0]-xyz3[0]) + (xyz1[1]-xyz3[1])*(xyz1[1]-xyz3[1]) + (xyz1[2]-xyz3[2])*(xyz1[2]-xyz3[2]);

                    if (dist02+dist13 < dist03+dist12) {
                        edgeList[0] = MODL->body[ibodyl].edge[iedgel].eedge;
                        senses1[ 0] = SFORWARD;

                        status = makeEdge(MODL, MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].enode,
                                                MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].enode, &(edgeList[1]));
                        CHECK_STATUS(makeEdge);

                        edgeList[2] = MODL->body[ibodyr].edge[iedger].eedge;

                        status = makeEdge(MODL, MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].enode,
                                                MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].enode, &(edgeList[3]));
                        CHECK_STATUS(makeEdge);
                    } else {
                        edgeList[0] = MODL->body[ibodyl].edge[iedgel].eedge;

                        status = makeEdge(MODL, MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].enode,
                                                MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].enode, &(edgeList[1]));
                        CHECK_STATUS(makeEdge);

                        edgeList[2] = MODL->body[ibodyr].edge[iedger].eedge;

                        status = makeEdge(MODL, MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].enode,
                                                MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].enode, &(edgeList[3]));
                        CHECK_STATUS(makeEdge);
                    }

                    status = makeFace(MODL, edgeList, fillstyle, SFORWARD, &(faceList[nFaceList]));
                    CHECK_STATUS(makeFace);

                    nFaceList++;
                }
            }
        }

        /* add to faceList those Faces in faceListl and faceListr that are
           not one of the Faces that we are removing */
        status = EG_getBodyTopos(ebodyl, NULL, FACE, &nnn, &nnnList);
        CHECK_STATUS(EG_getBodyTopos);

        for (iii = 0; iii < nnn; iii++) {
            iadd = 1;

            for (jjj = 0; jjj < args[1].nval; jjj++) {
                if (NINT(args[1].val[jjj]) == iii+1) {
                    iadd = 0;
                    break;
                }
            }

            if (iadd == 1) {
                faceList[nFaceList] = nnnList[iii];
                nFaceList++;
            }
        }

        EG_free(nnnList);

        status = EG_getBodyTopos(ebodyr, NULL, FACE, &nnn, &nnnList);
        CHECK_STATUS(EG_getBodyTopos);

        for (iii = 0; iii < nnn; iii++) {
            iadd = 1;

            for (jjj = 0; jjj < args[2].nval; jjj++) {
                if (NINT(args[2].val[jjj]) == iii+1) {
                    iadd = 0;
                    break;
                }
            }

            if (iadd == 1) {
                faceList[nFaceList] = nnnList[iii];
                nFaceList++;
            }
        }

        EG_free(nnnList);

        /* make the (closed) Shell and the SolidBody */
        if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
            MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {
            status = EG_makeTopology(MODL->context, NULL, SHELL, CLOSED, NULL,
                                     nFaceList, faceList, NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SOLIDBODY, NULL,
                                     1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_CONNECT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);
        } else {
            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN, NULL,
                                     nFaceList, faceList, NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY, NULL,
                                     1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_CONNECT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);
        }

        MODL->body[ibody].ebody = ebody;

        /* mark the new Faces with the current Body */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        for (iface = 1; iface <= nface; iface++) {
            status = EG_attributeRet(efaces[iface-1], "_body",
                                     &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == EGADS_NOTFOUND) {
                status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            } else {
                CHECK_STATUS(EG_attributeRet);
            }
        }

        EG_free(efaces);

        /* update @-parameters (CONNECT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);
    }

cleanup:
    if (efacedgs != NULL) EG_free(efacedgs);

    FREE(edgeList );
    FREE(faceList );
    FREE(elist    );
    FREE(matches  );
    FREE(enewFaces);
    FREE(enewEdges);
    FREE(indx     );
    FREE(eloopsc  );
    FREE(sensesc  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildGrown - implement OCSM_GROWNs for ocsmBuild                   *
 *                                                                      *
 ************************************************************************
 */

static int
buildGrown(modl_T *modl,                /* (in)  pointer to MODL */
           int    ibrch,                /* (in)  Branch index (bias-1) */
           varg_T args[],               /* (in)  array of arguments */
           int    *nstack,              /* (both) number of Bodys on stack */
           int    stack[],              /* (both) array  of Bodys on stack */
           int    npatn,                /* (in)   number of patterns */
           patn_T patn[])               /* (both) array  of patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        type, hasdots, iface, nface, nloops, loftOpts, itypebeg, itypeend, i, ii, ival;
    int        inode, iedge, atype, ilen, newEbodyl=0;
    int        nsketch, nstrip, ibody, ibodyl, ibodyr, npart, attrtype, attrlen;
    int        *isketch=NULL, *jsketch=NULL, *kstrip=NULL;
    int        oclass, mtype, *senses, iford1, nedges, nfaces, nchild, oneFace, nnode;
    int        j, begPmtr, endPmtr, mode, nsew, *pinfo=NULL;
    CINT       *tempIlist;
    double     data[4], Rbeg[8], Rend[8], matrix[12];
    double     dx, dy, dz, cosx, sinx, cosy, siny, cosz, sinz;
    double     *prv=NULL, bbox[6], vals[7];
    double     toler, dirn[3], alen, bbox0[6], bbox1[6], *vmin=NULL, uvlimits[4];
    CDOUBLE    *tempRlist;
    CCHAR      *tempClist;
    ego        ebody, ebodyl, ebodyr, *enodes, *efaces=NULL, *echildren, *esketch=NULL;
    ego        eref, exform, etemp, *echilds, *esew=NULL, emodel;

    ROUTINE(buildGrown);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "extrude dx dy dz" */
    if (type == OCSM_EXTRUDE) {
        SPRINT4(1, "    executing [%4d] extrude:    %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* check to be sure that the extrude distance is not zero */
        if (fabs(args[1].val[0]) < EPS06 &&
            fabs(args[2].val[0]) < EPS06 &&
            fabs(args[3].val[0]) < EPS06   ) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "EXTRUDE distance must be non-zero");
            goto cleanup;
        }

        /* pop a Sketch from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "EXTRUDE expects a Body on the stack");
            goto cleanup;
        } else {
                ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        alen = sqrt(args[1].val[0]*args[1].val[0] + args[2].val[0]*args[2].val[0] + args[3].val[0]*args[3].val[0]);
        dirn[0] = args[1].val[0] / alen;
        dirn[1] = args[2].val[0] / alen;
        dirn[2] = args[3].val[0] / alen;

        /* ibodyl is a SheetBody, so create a SolidBody */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRUDE, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_getTopology(MODL->body[ibodyl].ebody, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if        (oclass == BODY && mtype == FACEBODY) {
                status = EG_getTopology(MODL->body[ibodyl].ebody, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebodyl = echilds[0];

            } else if (oclass == BODY && mtype == SHEETBODY) {
                if (nchild != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "found %d Shells in SheetBody but was expecting 1", nchild);
                    goto cleanup;
                }

                etemp = echilds[0];
                status = EG_getTopology(etemp, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (nchild != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "found %d Faces in SheetBody but was expecting 1", nchild);
                    goto cleanup;
                }

                ebodyl = echilds[0];
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "ebody is neither FaceBody nor SheetBody\n");
                goto cleanup;
            }

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_extrude: ebodyl");
                ocsmPrintEgo(ebodyl);
            }

            status = EG_extrude(ebodyl, alen, dirn, &ebody);
            CHECK_STATUS(EG_extrude);

            /* remove Attributes from Faces that start with period and underscore */
            status = removeFaceAttributes(ebody);
            CHECK_STATUS(removeFaceAttributes);

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a WireBody, so create a SheetBody */
        } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRUDE, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_extrude: ebodyl");
                ocsmPrintEgo(ebodyl);
            }

            status = EG_extrude(ebodyl, alen, dirn, &ebody);
            CHECK_STATUS(EG_extrude);

            /* remove Attributes from Faces that start with period and underscore */
            status = removeFaceAttributes(ebody);
            CHECK_STATUS(removeFaceAttributes)

            MODL->body[ibody].ebody = ebody;

        } else {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "EXTRUDE expects a SheetBody or WireBody");
            goto cleanup;
        }

        /* update @-parameters (EXTRUDE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        /* transfer Attributes from Sketch to beginning and ending Faces */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            status = EG_attributeDup(ebodyl, efaces[nface-2]);
            CHECK_STATUS(EG_attributeDup);

            status = EG_attributeDup(ebodyl, efaces[nface-1]);
            CHECK_STATUS(EG_attributeDup);
        }

        EG_free(efaces);

        /* mark the new Faces with the current Branch */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            nedges = nface - 2;
        } else {
            nedges = nface;
        }
        for (iface = 1; iface <= nedges; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nedges+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

            status = setFaceAttribute(MODL, ibody, nedges+2, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* finish the Body (EXTRUDE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "revolve xorig yorig zorig dxaxis dyaxis dzaxis angDeg" */
    } else if (type == OCSM_REVOLVE) {
        SPRINT8(1, "    executing [%4d] revolve:    %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0], args[7].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0 || args[7].dot[0] != 0                   ) {
            hasdots = 1;

            SPRINT7(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0], args[7].dot[0]);
        }

        /* check to be sure that the axis is not zero */
        if (fabs(args[4].val[0]) < EPS06 &&
            fabs(args[5].val[0]) < EPS06 &&
            fabs(args[6].val[0]) < EPS06   ) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "axis length must be non-zero");
            goto cleanup;
        }

        /* check to be sure that the angDeg is non-zero */
        if        (fabs(args[7].val[0]) < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "angDeg=%f cannot be zero", args[7].val[0]);
            goto cleanup;
        }

        /* pop a Sketch from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "REVOLVE expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that ibodyl is a SheetBody */
        if (MODL->body[ibodyl].botype != OCSM_SHEET_BODY &&
            MODL->body[ibodyl].botype != OCSM_WIRE_BODY    ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "REVOLVE is expecting a SheetBody or WireBody");
            goto cleanup;
        }

        /* check that a valid angle is given */
        if (args[7].val[0] < -360.0 || args[7].val[0] > 360) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "angle (%f) is not between -360 and +360", args[7].val[0]);
            goto cleanup;
        }

        /* ibodyl is a SheetBody, so create a SolidBody */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_REVOLVE, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_getTopology(MODL->body[ibodyl].ebody, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if        (oclass == BODY && mtype == FACEBODY) {
                status = EG_getTopology(MODL->body[ibodyl].ebody, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebodyl = echilds[0];

            } else if (oclass == BODY && mtype == SHEETBODY) {
                if (nchild != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "found %d Shells in SheetBody but was expecting 1", nchild);
                    goto cleanup;
                }

                etemp = echilds[0];
                status = EG_getTopology(etemp, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (nchild != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "found %d Faces in SheetBody but was expecting 1", nchild);
                    goto cleanup;
                }

                ebodyl = echilds[0];
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "ebody is neither FaceBody nor SheetBody\n");
                goto cleanup;
            }

            /* check if projection of axis of revolution does intersect the Face */
            status = EG_getTopology(ebodyl, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(eref, &oclass, &mtype, &etemp, &pinfo, &prv);
            CHECK_STATUS(EG_getGeometry);

            if (oclass != SURFACE || mtype != PLANE) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "expecting PLANE, but found oclass=%d, mtype=%d", oclass, mtype);
                goto cleanup;
            } else if (fabs(prv[3]) < EPS06 && fabs(prv[6]) < EPS06) {
                status = EG_getBoundingBox(ebodyl, bbox);
                CHECK_STATUS(EG_getBoundingBox);

                if        (args[2].val[0]-bbox[1] <= +EPS06 && args[5].val[0] <= 0) {
                } else if (args[2].val[0]-bbox[4] >= -EPS06 && args[5].val[0] >= 0) {
                } else if (args[3].val[0]-bbox[2] <= +EPS06 && args[6].val[0] <= 0) {
                } else if (args[3].val[0]-bbox[5] >= -EPS06 && args[6].val[0] >= 0) {
                } else {
                    SPRINT0(1, "WARNING:: axis may intersect Face and result may be invalid");
                    SPRINT2(1, "          bbox: ymin=%12.5f   ymax=%12.5f", bbox[1],        bbox[4]       );
                    SPRINT2(1, "          bbox: zmin=%12.5f   zmax=%12.5f", bbox[2],        bbox[5]       );
                    SPRINT2(1, "          base: ybeg=%12.5f   zbeg=%12.5f", args[2].val[0], args[3].val[0]);
                    SPRINT2(1, "          dirn: dy  =%12.5f   dz  =%12.5f", args[5].val[0], args[6].val[0]);
                    (MODL->nwarn)++;
                }
            } else if (fabs(prv[4]) < EPS06 && fabs(prv[7]) < EPS06) {
                status = EG_getBoundingBox(ebodyl, bbox);
                CHECK_STATUS(EG_getBoundingBox);

                if        (args[3].val[0]-bbox[2] <= +EPS06 && args[6].val[0] <= 0) {
                } else if (args[3].val[0]-bbox[5] >= -EPS06 && args[6].val[0] >= 0) {
                } else if (args[1].val[0]-bbox[0] <= +EPS06 && args[4].val[0] <= 0) {
                } else if (args[1].val[0]-bbox[3] >= -EPS06 && args[4].val[0] >= 0) {
                } else {
                    SPRINT0(1, "WARNING:: axis may intersect Face and result may be invalid");
                    SPRINT2(1, "          bbox: zmin=%12.5f   zmax=%12.5f", bbox[2],        bbox[5]       );
                    SPRINT2(1, "          bbox: xmin=%12.5f   xmax=%12.5f", bbox[0],        bbox[3]       );
                    SPRINT2(1, "          base: zbeg=%12.5f   ybeg=%12.5f", args[3].val[0], args[1].val[0]);
                    SPRINT2(1, "          dirn: dz  =%12.5f   dy  =%12.5f", args[6].val[0], args[4].val[0]);
                    (MODL->nwarn)++;
                }
            } else if (fabs(prv[5]) < EPS06 && fabs(prv[8]) < EPS06) {
                status = EG_getBoundingBox(ebodyl, bbox);
                CHECK_STATUS(EG_getBoundingBox);

                if        (args[1].val[0]-bbox[0] <= +EPS06 && args[4].val[0] <= 0) {
                } else if (args[1].val[0]-bbox[3] >= -EPS06 && args[4].val[0] >= 0) {
                } else if (args[2].val[0]-bbox[1] <= +EPS06 && args[5].val[0] <= 0) {
                } else if (args[2].val[0]-bbox[4] >= -EPS06 && args[5].val[0] >= 0) {
                } else {
                    SPRINT0(1, "WARNING:: axis may intersect Face and result may be invalid");
                    SPRINT2(1, "          bbox: xmin=%12.5f   xmax=%12.5f", bbox[0],        bbox[3]       );
                    SPRINT2(1, "          bbox: ymin=%12.5f   ymax=%12.5f", bbox[1],        bbox[4]       );
                    SPRINT2(1, "          base: xbeg=%12.5f   ybeg=%12.5f", args[1].val[0], args[2].val[0]);
                    SPRINT2(1, "          dirn: dx  =%12.5f   dy  =%12.5f", args[4].val[0], args[5].val[0]);
                    (MODL->nwarn)++;
                }
            } else {
                SPRINT0(1, "WARNING:: Face is not aligned with coordinate axes and thus cannot be checked");
                SPRINT3(1, "Point: %12.5f %12.5f %12.5f", prv[0], prv[1], prv[2]);
                SPRINT3(1, "Xaxis: %12.5f %12.5f %12.5f", prv[3], prv[4], prv[5]);
                SPRINT3(1, "Yaxis: %12.5f %12.5f %12.5f", prv[6], prv[7], prv[8]);
                (MODL->nwarn)++;
            }

            if (args[7].val[0] > 0) {
                if (outLevel >= 3) {
                    SPRINT0(3, "before EG_rotate: ebodyl");
                    ocsmPrintEgo(ebodyl);
                }

                vals[0] = args[1].val[0];
                vals[1] = args[2].val[0];
                vals[2] = args[3].val[0];
                vals[3] = args[4].val[0];
                vals[4] = args[5].val[0];
                vals[5] = args[6].val[0];

                status = EG_rotate(ebodyl, args[7].val[0], vals, &ebody);
                CHECK_STATUS(EG_rotate);

                /* remove Attributes from Faces that start with period and underscore */
                status = removeFaceAttributes(ebody);
                CHECK_STATUS(removeFaceAttributes)
            } else {
                if (outLevel >= 3) {
                    SPRINT0(3, "before EG_rotate: ebodyl");
                    ocsmPrintEgo(ebodyl);
                }

                vals[0] = args[1].val[0];
                vals[1] = args[2].val[0];
                vals[2] = args[3].val[0];
                vals[3] = args[4].val[0];
                vals[4] = args[5].val[0];
                vals[5] = args[6].val[0];

                status = EG_rotate(ebodyl, fabs(args[7].val[0]), vals, &etemp);
                CHECK_STATUS(EG_rotate);

                /* remove Attributes from Faces that start with period and underscore */
                status = removeFaceAttributes(etemp);
                CHECK_STATUS(removeFaceAttributes)

                if        (fabs(args[5].val[0]) < EPS06 && fabs(args[6].val[0]) < EPS06) {
                    cosx = cos(args[7].val[0] * PIo180);
                    sinx = sin(args[7].val[0] * PIo180);
                    dy   =     args[2].val[0];
                    dz   =     args[3].val[0];

                    matrix[ 0] = 1; matrix[ 1] = 0;    matrix[ 2] = 0;    matrix[ 3] = 0;
                    matrix[ 4] = 0; matrix[ 5] = cosx; matrix[ 6] =-sinx; matrix[ 7] = dy - dy * cosx + dz * sinx;
                    matrix[ 8] = 0; matrix[ 9] = sinx; matrix[10] = cosx; matrix[11] = dz - dy * sinx - dz * cosx;
                } else if (fabs(args[4].val[0]) < EPS06 && fabs(args[6].val[0]) < EPS06) {
                    cosy = cos(args[7].val[0] * PIo180);
                    siny = sin(args[7].val[0] * PIo180);
                    dz   =     args[3].val[0];
                    dx   =     args[1].val[0];

                    matrix[ 0] = cosy; matrix[ 1] = 0; matrix[ 2] = siny; matrix[ 3] = dx - dz * siny - dx * cosy;
                    matrix[ 4] = 0;    matrix[ 5] = 1; matrix[ 6] = 0;    matrix[ 7] = 0;
                    matrix[ 8] =-siny; matrix[ 9] = 0; matrix[10] = cosy; matrix[11] = dz - dz * cosy + dx * siny;
                } else if (fabs(args[4].val[0]) < EPS06 && fabs(args[5].val[0]) < EPS06) {
                    cosz = cos(args[7].val[0] * PIo180);
                    sinz = sin(args[7].val[0] * PIo180);
                    dx   =     args[1].val[0];
                    dy   =     args[2].val[0];

                    matrix[ 0] = cosz; matrix[ 1] =-sinz; matrix[ 2] = 0; matrix[ 3] = dx - dx * cosz + dy * sinz;
                    matrix[ 4] = sinz; matrix[ 5] = cosz; matrix[ 6] = 0; matrix[ 7] = dy - dx * sinz - dy * cosz;
                    matrix[ 8] = 0;    matrix[ 9] = 0;    matrix[10] = 1; matrix[11] = 0;
                } else {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "not aligned with axis (%f, %f, %f)", args[4].val[0], args[5].val[0], args[6].val[0]);
                    goto cleanup;
                }

                status = EG_makeTransform(MODL->context, matrix, &exform);
                CHECK_STATUS(EG_makeTransform);

                status = EG_copyObject(etemp, exform, &ebody);
                CHECK_STATUS(EG_copyObject);

                status = EG_deleteObject(exform);
                CHECK_STATUS(EG_deleteObject);
            }

            if (pinfo != NULL) EG_free(pinfo);
            if (prv   != NULL) EG_free(prv  );

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a WireBody, so create a SheetBody */
        } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_REVOLVE, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_rotate: ebodyl");
                ocsmPrintEgo(ebodyl);
            }

            vals[0] = args[1].val[0];
            vals[1] = args[2].val[0];
            vals[2] = args[3].val[0];
            vals[3] = args[4].val[0];
            vals[4] = args[5].val[0];
            vals[5] = args[6].val[0];

            status = EG_rotate(ebodyl, args[7].val[0], vals, &ebody);
            CHECK_STATUS(EG_rotate);

            /* remove Attributes from Faces that start with period and underscore */
            status = removeFaceAttributes(ebody);
            CHECK_STATUS(removeFaceAttributes)

            MODL->body[ibody].ebody = ebody;

        } else {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "REVOLVE expects a SheetBody or WireBody");
            goto cleanup;
        }

        /* update @-parameters (REVOLVE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        /* transfer Attributes from Sketch to beginning and ending Faces */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
            fabs(args[7].val[0]-360) > EPS06               ) {
            status = EG_attributeDup(ebodyl, efaces[nface-2]);
            CHECK_STATUS(EG_attributeDup);

            status = EG_attributeDup(ebodyl, efaces[nface-1]);
            CHECK_STATUS(EG_attributeDup);
        }

        EG_free(efaces);

        /* mark the new Faces with the current Branch */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
            fabs(fabs(args[7].val[0])-360) > EPS06         ) {
            nedges = nface - 2;
        } else {
            nedges = nface;
        }
        for (iface = 1; iface <= nedges; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
            fabs(fabs(args[7].val[0])-360) > EPS06         ) {
            status = setFaceAttribute(MODL, ibody, nedges+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

            status = setFaceAttribute(MODL, ibody, nedges+2, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* finish the Body (REVOLVE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "rule reorder=0" */
    } else if (type == OCSM_RULE) {
        SPRINT2(1, "    executing [%4d] rule:       %11.5f",
                ibrch, args[1].val[0]);

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            while ((*nstack) > 0) {
                ibodyl = stack[--(*nstack)];
                if (ibodyl == 0) break;      /* mark is found */
            }

            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* pop Sketches from the stack (until the Mark) and put them
           into isketch from first to last */
        MALLOC(isketch, int, (*nstack));
        MALLOC(esketch, ego, (*nstack));

        nsketch  =  0;
        nstrip   = -1;
        itypebeg = -1;
        itypeend = -1;
        ibodyl   = -1;
        while ((*nstack) > 0) {
            ibodyl = stack[--(*nstack)];

            if (ibodyl == 0) break;          /* mark is found */

            if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {
                if (nsketch == 0) {
                    itypeend = MODL->body[ibodyl].botype;
                }

                itypebeg = MODL->body[ibodyl].botype;

                for (j = nsketch; j > 0; j--) {
                    isketch[j] = isketch[j-1];
                    esketch[j] = esketch[j-1];
                }

                status = EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, NODE, &nnode, &enodes);
                CHECK_STATUS(EG_getBodyTopos);

                isketch[0] = ibodyl;
                esketch[0] = enodes[0];
                nsketch++;

                EG_free(enodes);

            } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY ||
                       MODL->body[ibodyl].botype == OCSM_SHEET_BODY  ) {
                ebodyl = MODL->body[ibodyl].ebody;

                status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloops, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nloops != 1) {
                    signalError(MODL, OCSM_ERROR_IN_BODYS_ON_STACK,
                                "expecting 1 Loop but found %d", nloops);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedges, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nsketch == 0) {
                    itypeend = MODL->body[ibodyl].botype;
                }

                itypebeg = MODL->body[ibodyl].botype;

                if (nstrip < 0) {
                    nstrip = nedges;
                } else if (nstrip != nedges) {
                    signalError(MODL, OCSM_ERROR_IN_BODYS_ON_STACK,
                                "expecting %d Edges but found %d", nstrip, nedges);
                    goto cleanup;
                }

                for (j = nsketch; j > 0; j--) {
                    isketch[j] = isketch[j-1];
                    esketch[j] = esketch[j-1];
                }
                isketch[0] = ibodyl;
                esketch[0] = ebodyl;
                nsketch++;
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "Body %d is neither NodeBody, WireBody, nor SheetBody", ibodyl);
                goto cleanup;
            }
        }

        if (nsketch < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "RULE expects 2 or more Bodys since mark");
            goto cleanup;
        } else {
            SPRINT2(1, "                          ruling  %d Sketches with %d Strips each...",
                    nsketch, nstrip);
        }

        /* check for multiplicity>1 */
        for (i = 1; i < nsketch; i++) {
            if (MODL->body[isketch[i-1]].botype != OCSM_SHEET_BODY ||
                MODL->body[isketch[i  ]].botype != OCSM_SHEET_BODY   ) continue;

            status = EG_getBoundingBox(MODL->body[isketch[i-1]].ebody, bbox0);
            CHECK_STATUS(EG_getBoundingBox);

            status = EG_getBoundingBox(MODL->body[isketch[i  ]].ebody, bbox1);
            CHECK_STATUS(EG_getBoundingBox);

            if (fabs(bbox0[0]-bbox1[0]) < EPS06 &&
                fabs(bbox0[1]-bbox1[1]) < EPS06 &&
                fabs(bbox0[2]-bbox1[2]) < EPS06 &&
                fabs(bbox0[3]-bbox1[3]) < EPS06 &&
                fabs(bbox0[4]-bbox1[4]) < EPS06 &&
                fabs(bbox0[5]-bbox1[5]) < EPS06   ) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "RULE cannot have repeated sections (%d and %d)",
                            isketch[i-1], isketch[i]);
                goto cleanup;
            }
        }

        /* create the Body (assume for now it is a SolidBody --- to be fixed below) */
        status = newBody(MODL, ibrch, OCSM_RULE, ibodyl, ibodyl,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        /* link this new Body with its children */
        for (i = 0; i < nsketch; i++) {
            if (isketch[i] != 0) {
                MODL->body[isketch[i]].ichld = ibody;
            }
        }

        MODL->body[ibody].ileft = isketch[0];
        MODL->body[ibody].irite = isketch[nsketch-1];

        /* first Sketch should be a NODE, WIREBODY, or FACE */
        if (itypebeg == OCSM_SHEET_BODY) {
            status = EG_getBodyTopos(esketch[0], NULL, FACE, &nfaces, &echildren);
            CHECK_STATUS(EG_getBodyTopos);

            esketch[0] = echildren[0];

            EG_free(echildren);
        }

        /* last Sketch should be a NODE, WIREBODY, or FACE */
        if (itypeend == OCSM_SHEET_BODY) {
            status = EG_getBodyTopos(esketch[nsketch-1], NULL, FACE, &nfaces, &echildren);
            CHECK_STATUS(EG_getBodyTopos);

            esketch[nsketch-1] = echildren[0];

            EG_free(echildren);
        }

        /* convert all the intermediate Sketches to LOOPs */
        for (i = 1; i < nsketch-1; i++) {
            status = EG_getBodyTopos(esketch[i], NULL, LOOP, &nloops, &echildren);
            CHECK_STATUS(EG_getBodyTopos);

            esketch[i] = echildren[0];

            EG_free(echildren);
        }

        /* reorder Loops to eliminate twisting */
        status = reorderLoops(MODL, nsketch, esketch, NINT(args[1].val[0]));
        CHECK_STATUS(reorderLoops);

        /* create the Body */
        if (outLevel >= 3) {
            for (ii = 0; ii < nsketch; ii++) {
                SPRINT1(3, "before EG_ruled: esketch[%d]", ii);
                ocsmPrintEgo(esketch[ii]);
            }
        }
        status = EG_ruled(nsketch, esketch, &ebody);
        if (status < SUCCESS) {
            signalError(MODL, status,
                        "EG_ruled returned an unexpected error");
            goto cleanup;
        }

        MODL->body[ibody].ebody = ebody;

        /* update the Body type if a SheetBody was produced */
        status = EG_getTopology(ebody, &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        if (oclass == BODY) {
            if (mtype == SHEETBODY || mtype == FACEBODY) {
                SPRINT0(1, "WARNING:: rule produced a SheetBody");
                (MODL->nwarn)++;
                MODL->body[ibody].botype = OCSM_SHEET_BODY;
            } else if (mtype != SOLIDBODY) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "Body produced is neither SheetBody or SolidBody");
                goto cleanup;
            }
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "EGO produced is not a Body");
            SET_STATUS(OCSM_INTERNAL_ERROR, rule);
        }

        /* update @-parameters (RULE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, NULL);
        CHECK_STATUS(EG_getBodyTopos);

        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) nface--;
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) nface--;

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
            nface++;
        }
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* finish the Body (RULE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "loft smooth" */
    } else if (type == OCSM_LOFT) {
        SPRINT2(1, "    executing [%4d] loft:       %11.5f",
                ibrch, args[1].val[0]);

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            while ((*nstack) > 0) {
                ibodyl = stack[--(*nstack)];
                if (ibodyl == 0) break;      /* mark is found */
            }

            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* pop Sketches from the stack (until the Mark) and put them
           into isketch from last to first */
        MALLOC(isketch, int, (*nstack));
        MALLOC(esketch, ego, (*nstack));

        nsketch  = 0;
        loftOpts = -1;
        ibodyl   = -1;
        ibodyr   = -1;
        while ((*nstack) > 0) {
            ibodyl = stack[--(*nstack)];

            if (ibodyl == 0) break;          /* mark is found */

            if (nsketch == 0) {
                if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {
                    loftOpts = 0;
                } else {
                    loftOpts = 1;
                }
            }

            ebodyl = MODL->body[ibodyl].ebody;

            if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {
                status = EG_getBodyTopos(ebodyl, NULL, NODE, &nnode, &enodes);
                CHECK_STATUS(EG_getBodyTopos);

                isketch[nsketch] = ibodyl;
                esketch[nsketch] = enodes[0];

                EG_free(enodes);
                nsketch++;
            } else {
                status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloops, &echildren);
                CHECK_STATUS(EG_getBodyTopos);

                isketch[nsketch] = ibodyl;
                esketch[nsketch] = echildren[0];
                nsketch++;

                EG_free(echildren);
            }

            ibodyr = ibodyl;
        }

        if (nsketch < 2 || ibodyl < 0) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "UNION expects 2 or more Bodys since mark");
            goto cleanup;
        } else {
            SPRINT1(1, "                          lofting %d Sketches...", nsketch);
        }
        ibodyl = isketch[0];

        /* determine if SheetBody or SolidBody should be created */
        if (MODL->body[ibodyr].botype == OCSM_WIRE_BODY) {
            loftOpts = 0;
        }

        /* create the new Body */
        if (loftOpts == 0) {
            status = newBody(MODL, ibrch, OCSM_LOFT, ibodyr, ibodyl,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);
        } else {
            status = newBody(MODL, ibrch, OCSM_LOFT, ibodyr, ibodyl,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);
        }

        /* all Bodys in Loft should point to new Body */
        for (i = 0; i < nsketch; i++) {
            if (isketch[i] != 0) {
                MODL->body[isketch[i]].ichld = ibody;
            }
        }

        if (NINT(args[1].val[0]) != 1) {
            loftOpts += 2;
        }

        if (outLevel >= 3) {
            for (ii = 0; ii < nsketch; ii++) {
                SPRINT1(3, "before EG_loft: esketch[%d]", ii);
                ocsmPrintEgo(esketch[ii]);
            }
        }
        status = EG_loft(nsketch, esketch, loftOpts, &ebody);
        CHECK_STATUS(EG_loft);

        /* if a SheetBody and ibodyl is SheetBody, sew them together */
        if (MODL->body[ibody ].botype == OCSM_SHEET_BODY &&
            MODL->body[ibodyl].botype == OCSM_SHEET_BODY   ) {

            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            nsew = nface + 1;
            MALLOC(esew, ego, nsew);
            for (i = 0; i < nsew-1; i++) {
                esew[i] = efaces[i];
            }

            EG_free(efaces);

            status = EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            esew[nsew-1] = efaces[0];

            EG_free(efaces);

            status = EG_sewFaces(nsew, esew, 0.0, 1, &emodel);
            CHECK_STATUS(EG_sewFaces);

            FREE(esew);

            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            ebody = echilds[0];

        /* if a SheetBody and ibodyr is SheetBody, sew them together */
        } else if (MODL->body[ibody ].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {

            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            nsew = nface + 1;
            MALLOC(esew, ego, nsew);
            for (i = 0; i < nsew-1; i++) {
                esew[i] = efaces[i];
            }

            EG_free(efaces);

            status = EG_getBodyTopos(MODL->body[ibodyr].ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            esew[nsew-1] = efaces[0];

            EG_free(efaces);

            status = EG_sewFaces(nsew, esew, 0.0, 1, &emodel);
            CHECK_STATUS(EG_sewFaces);

            FREE(esew);

            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            ebody = echilds[0];
        }

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (LOFT) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, NULL);
        CHECK_STATUS(EG_getBodyTopos);

        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) nface--;
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) nface--;

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
            nface++;
        }
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* finish the Body (LOFT) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "blend begList=0 endList=0 reorder=0 oneFace=0" */
    } else if (type == OCSM_BLEND) {
        SPRINT5(1, "    executing [%4d] blend:      %s  %s  %11.5f  %11.5f",
                ibrch, MODL->brch[ibrch].arg1, MODL->brch[ibrch].arg2, args[3].val[0], args[4].val[0]);

        for (ival = 0; ival < args[1].nval; ival++) {
            if (args[1].dot[ival] != 0) hasdots = 1;
        }

        for (ival = 0; ival < args[2].nval; ival++) {
            if (args[2].dot[ival] != 0) hasdots = 1;
        }

        oneFace = NINT(args[4].val[0]);

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            while ((*nstack) > 0) {
                ibodyl = stack[--(*nstack)];
                if (ibodyl == 0) break;      /* mark is found */
            }

            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* pop Sketches from the stack (until the Mark) and put them
           into isketch from first to last */
        MALLOC(isketch, int, (*nstack));
        MALLOC(jsketch, int, (*nstack));
        MALLOC(esketch, ego, (*nstack));

        nsketch  =  0;
        nstrip   = -1;
        itypebeg = -1;
        itypeend = -1;
        ibodyl   = -1;
        while ((*nstack) > 0) {
            ibodyl = stack[--(*nstack)];

            if (ibodyl == 0) break;          /* mark is found */
            if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {
                if (nsketch == 0) {
                    itypeend = MODL->body[ibodyl].botype;
                }

                itypebeg = MODL->body[ibodyl].botype;

                for (j = nsketch; j > 0; j--) {
                    isketch[j] = isketch[j-1];
                    jsketch[j] = jsketch[j-1];
                    esketch[j] = esketch[j-1];
                }

                status = EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, NODE, &nnode, &enodes);
                CHECK_STATUS(EG_getBodyTopos);

                isketch[0] = ibodyl;
                jsketch[0] = 0;
                esketch[0] = enodes[0];

                EG_free(enodes);
                nsketch++;

            } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY ||
                       MODL->body[ibodyl].botype == OCSM_SHEET_BODY  ) {
                ebodyl = MODL->body[ibodyl].ebody;

                status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloops, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nloops != 1) {
                    signalError(MODL, OCSM_ERROR_IN_BODYS_ON_STACK,
                                "expecting 1 Loop but found %d", nloops);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedges, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nsketch == 0) {
                    itypeend = MODL->body[ibodyl].botype;
                }

                itypebeg = MODL->body[ibodyl].botype;

                if (nstrip < 0) {
                    nstrip = nedges;
                } else if (nstrip != nedges) {
                    signalError(MODL, OCSM_ERROR_IN_BODYS_ON_STACK,
                                "expecting %d Edges but found %d", nstrip, nedges);
                    goto cleanup;
                }

                for (j = nsketch; j > 0; j--) {
                    isketch[j] = isketch[j-1];
                    jsketch[j] = jsketch[j-1];
                    esketch[j] = esketch[j-1];
                }
                isketch[0] = ibodyl;
                jsketch[0] = 1;
                esketch[0] = ebodyl;
                nsketch++;
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "Body %d is neither NODE, WireBody, nor SheetBody", ibodyl);
                goto cleanup;
            }
        }

        /* determine the type/multiplicity of the Sketches */
        for (i = 0; i < nsketch-3; i++) {
            if (jsketch[i] != 1 || jsketch[i+1] != 1 || jsketch[i+2] != 1) continue;

            status = EG_getBoundingBox(MODL->body[isketch[i  ]].ebody, bbox0);
            CHECK_STATUS(EG_getBoundingBox);

            status = EG_getBoundingBox(MODL->body[isketch[i+2]].ebody, bbox1);
            CHECK_STATUS(EG_getBoundingBox);

            if (fabs(bbox0[0]-bbox1[0]) < EPS06 &&
                fabs(bbox0[1]-bbox1[1]) < EPS06 &&
                fabs(bbox0[2]-bbox1[2]) < EPS06 &&
                fabs(bbox0[3]-bbox1[3]) < EPS06 &&
                fabs(bbox0[4]-bbox1[4]) < EPS06 &&
                fabs(bbox0[5]-bbox1[5]) < EPS06   ) {
                jsketch[i  ] = 3;
                jsketch[i+1] = 3;
                jsketch[i+2] = 3;
                i += 2;

                MODL->hasC0blend++;
            }
        }

        for (i = 0; i < nsketch-2; i++) {
            if (jsketch[i] != 1 || jsketch[i+1] != 1) continue;

            status = EG_getBoundingBox(MODL->body[isketch[i  ]].ebody, bbox0);
            CHECK_STATUS(EG_getBoundingBox);

            status = EG_getBoundingBox(MODL->body[isketch[i+1]].ebody, bbox1);
            CHECK_STATUS(EG_getBoundingBox);

            if (fabs(bbox0[0]-bbox1[0]) < EPS06 &&
                fabs(bbox0[1]-bbox1[1]) < EPS06 &&
                fabs(bbox0[2]-bbox1[2]) < EPS06 &&
                fabs(bbox0[3]-bbox1[3]) < EPS06 &&
                fabs(bbox0[4]-bbox1[4]) < EPS06 &&
                fabs(bbox0[5]-bbox1[5]) < EPS06   ) {
                jsketch[i  ] = 2;
                jsketch[i+1] = 2;
                i += 1;
            }
        }

        for (i = 0; i < nsketch; i++) {
            SPRINT4(3, "    isketch[%2d]=%3d   jsketch[%2d]=%d",
                    i, isketch[i], i, jsketch[i]);
        }

        /* we need at least two non-Node Sketches */
        if (nsketch < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "BLEND expects 2 or more Bodys since mark");
            goto cleanup;
        }

        /* there must be three or more Sketches between rounded begs and ends */
        if (itypebeg == OCSM_NODE_BODY && args[1].nval >= 8 &&
            itypeend == OCSM_NODE_BODY && args[2].nval >= 8 && nsketch < 5) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "BLEND expects 3 or more Sketches between rounded beg and end");
            goto cleanup;
        }

        /* there cannot be three or more consecutive C1 (multiplicity=2) Sketches */
        for (i = 1; i < nsketch-5; i++) {
            if (jsketch[i  ] == 2 && jsketch[i+1] == 2 &&
                jsketch[i+2] == 2 && jsketch[i+3] == 2 &&
                jsketch[i+4] == 2 && jsketch[i+5] == 2   ) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "BLEND cannot have three or more consecutive C1 sections");
                goto cleanup;
            }
        }

        SPRINT2(1, "                          blending  %d Sketches with %d Strips each...",
                nsketch, nstrip);

        /* create the Body (assume for now it is a SolidBody --- to be fixed below) */
        status = newBody(MODL, ibrch, OCSM_BLEND, ibodyl, ibodyl,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        /* link this new Body with its children */
        for (i = 0; i < nsketch; i++) {
            if (isketch[i] != 0) {
                MODL->body[isketch[i]].ichld = ibody;
            }
        }

        MODL->body[ibody].ileft = isketch[0];
        MODL->body[ibody].irite = isketch[nsketch-1];

        /* first Sketch should be a NODE, WIREBODY, or FACE */
        if (itypebeg == OCSM_SHEET_BODY) {
            status = EG_getBodyTopos(esketch[0], NULL, FACE, &nfaces, &echildren);
            CHECK_STATUS(EG_getBodyTopos);

            esketch[0] = echildren[0];

            EG_free(echildren);
        }

        /* last Sketch should be a NODE, WIREBODY, or FACE */
        if (itypeend == OCSM_SHEET_BODY) {
            status = EG_getBodyTopos(esketch[nsketch-1], NULL, FACE, &nfaces, &echildren);
            CHECK_STATUS(EG_getBodyTopos);

            esketch[nsketch-1] = echildren[0];

            EG_free(echildren);
        }

        /* convert all the intermediate Sketches to LOOPs */
        for (i = 1; i < nsketch-1; i++) {
            status = EG_getBodyTopos(esketch[i], NULL, LOOP, &nloops, &echildren);
            CHECK_STATUS(EG_getBodyTopos);

            esketch[i] = echildren[0];

            EG_free(echildren);
        }

        /* store info from begList into Rbeg */
        for (i = 0; i < args[1].nval; i++) {
            if (i >= 8) break;
            Rbeg[i] = args[1].val[i];
        }

        if (itypebeg == OCSM_NODE_BODY) {

            /* rounded beg */
            if (args[1].nval >= 8) {
                begPmtr = 1;

            /* sharp beg (because begList=0) */
            } else if (args[1].val[0] == 0) {
                begPmtr = 0;

            /* sharp beg (because begList did not contain enough values) */
            } else {
                begPmtr = 0;
                SPRINT1(1, "WARNING:: begList only has %d values", args[1].nval);
                SPRINT0(1, "          reverting to sharp beg");
                (MODL->nwarn)++;
            }
        } else {

            /* rounded tip at beg */
            if (args[1].val[0] < 0) {
                if (args[1].nval >= 2) {
                    begPmtr = 1;
                    Rbeg[0] = 0;
                } else {
                    begPmtr = 0;
                    SPRINT0(1, "WARNING:: begList does not contain eccentricity");
                    SPRINT0(1, "          reverting to sharp beg");
                    (MODL->nwarn)++;
                }

            /* blunt beg */
            } else {
                begPmtr = 0;
            }
        }

        /* store info from endList into Rend */
        for (i = 0; i < args[2].nval; i++) {
            if (i >= 8) break;
            Rend[i] = args[2].val[i];
        }

        if (itypeend == OCSM_NODE_BODY) {

            /* rounded end */
            if (args[2].nval >= 8) {
                endPmtr = 1;

            /* sharp end (because endList=0) */
            } else if (args[2].val[0] == 0) {
                endPmtr = 0;

            /* sharp end (because endList did not contain enough values) */
            } else {
                endPmtr = 0;
                SPRINT1(1, "WARNING:: endList only has %d values", args[2].nval);
                SPRINT0(1, "          reverting to sharp end");
                (MODL->nwarn)++;
            }
        } else {

            /* rounded tip at end */
            if (args[2].val[0] < 0) {
                if (args[2].nval >= 2) {
                    endPmtr = 1;
                    Rend[0] = 0;
                } else {
                    endPmtr = 0;
                    SPRINT0(1, "WARNING:: endList does not contain eccentricity");
                    SPRINT0(1, "          reverting to sharp end");
                    (MODL->nwarn)++;
                }

            /* blend end */
            } else {
                endPmtr = 0;
            }
        }

        /* reorder Loops to eliminate twisting */
        status = reorderLoops(MODL, nsketch, esketch, NINT(args[3].val[0]));
        CHECK_STATUS(reorderLoops);

        /* create the Body */
        if (begPmtr == 0 && endPmtr == 0) {
            SPRINT1(2, "call EG_blend(nsketch=%d, NULL, NULL)", nsketch);
            if (outLevel >= 3) {
                for (ii = 0; ii < nsketch; ii++) {
                    SPRINT1(3, "before EG_blend: esketch[%d]", ii);
                    ocsmPrintEgo(esketch[ii]);
                }
            }
            if (oneFace == 0) {
                status = EG_blend(+nsketch, esketch, NULL,  NULL,  &ebody);
            } else {
                status = EG_blend(-nsketch, esketch, NULL,  NULL,  &ebody);
            }
            if (status < SUCCESS) {
                signalError(MODL, status,
                            "EG_blend returned an error");
                goto cleanup;
            }
        } else if (begPmtr == 0) {
            SPRINT1(2, "call EG_blend(nsketch=%d, NULL, Rend)", nsketch);
            if (args[2].nval == 1) {
                SPRINT1(2, "Rend=%f", Rend[0]);
            }
            if (args[2].nval >= 4) {
                SPRINT4(2, "Rend=%f %f %f %f", Rend[0], Rend[1], Rend[2], Rend[3]);
            }
            if (args[2].nval >= 8) {
                SPRINT4(2, "     %f %f %f %f", Rend[4], Rend[5], Rend[6], Rend[7]);
            }

            if (outLevel >= 3) {
                for (ii = 0; ii < nsketch; ii++) {
                    SPRINT1(3, "before EG_blend: esketch[%d]", ii);
                    ocsmPrintEgo(esketch[ii]);
                }
            }
            if(oneFace == 0) {
                status = EG_blend(+nsketch, esketch, NULL,  Rend, &ebody);
            } else {
                status = EG_blend(-nsketch, esketch, NULL,  Rend, &ebody);
            }
            if (status == EGADS_DEGEN) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "sketch with multiplicity-2 adjacent to rounded beg");
                goto cleanup;
            } else if (status < SUCCESS) {
                signalError(MODL, status,
                            "EG_blend returned an error");
                goto cleanup;
            }
        } else if (endPmtr == 0) {
            SPRINT1(2, "call EG_blend(nsketch=%d, Rbeg, NULL)", nsketch);
            if (args[1].nval == 1) {
                SPRINT1(2, "Rbeg=%f", Rbeg[0]);
            }
            if (args[1].nval >= 4) {
                SPRINT4(2, "Rbeg=%f %f %f %f", Rbeg[0], Rbeg[1], Rbeg[2], Rbeg[3]);
            }
            if (args[1].nval >= 8) {
                SPRINT4(2, "     %f %f %f %f", Rbeg[4], Rbeg[5], Rbeg[6], Rbeg[7]);
            }

            if (outLevel >= 3) {
                for (ii = 0; ii < nsketch; ii++) {
                    SPRINT1(3, "before EG_blend: esketch[%d]", ii);
                    ocsmPrintEgo(esketch[ii]);
                }
            }
            if (oneFace == 0) {
                status = EG_blend(+nsketch, esketch, Rbeg, NULL,  &ebody);
            } else {
                status = EG_blend(-nsketch, esketch, Rbeg, NULL,  &ebody);
            }
            if (status == EGADS_DEGEN) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "sketch with multiplicity-2 adjacent to rounded end");
                goto cleanup;
            } else if (status < SUCCESS) {
                signalError(MODL, status,
                            "EG_blend returned an error");
                goto cleanup;
            }
        } else {
            SPRINT1(2, "call EG_blend(nsketch=%d, Rbeg, Rend)", nsketch);
            if (args[1].nval == 1) {
                SPRINT1(2, "Rbeg=%f", Rbeg[0]);
            }
            if (args[1].nval >= 4) {
                SPRINT4(2, "Rbeg=%f %f %f %f", Rbeg[0], Rbeg[1], Rbeg[2], Rbeg[3]);
            }
            if (args[1].nval >= 8) {
                SPRINT4(2, "     %f %f %f %f", Rbeg[4], Rbeg[5], Rbeg[6], Rbeg[7]);
            }

            if (args[2].nval == 1) {
                SPRINT1(2, "Rend=%f", Rend[0]);
            }
            if (args[2].nval >= 4) {
                SPRINT4(2, "Rend=%f %f %f %f", Rend[0], Rend[1], Rend[2], Rend[3]);
            }
            if (args[2].nval >= 8) {
                SPRINT4(2, "     %f %f %f %f", Rend[4], Rend[5], Rend[6], Rend[7]);
            }

            if (outLevel >= 3) {
                for (ii = 0; ii < nsketch; ii++) {
                    SPRINT1(3, "before EG_blend: esketch[%d]", ii);
                    ocsmPrintEgo(esketch[ii]);
                }
            }
            if (oneFace == 0) {
                status = EG_blend(+nsketch, esketch, Rbeg, Rend, &ebody);
            } else{
                status = EG_blend(-nsketch, esketch, Rbeg, Rend, &ebody);
            }
            if (status == EGADS_DEGEN) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "sketch with multiplicity-2 adjacent to rounded beg or end");
                goto cleanup;
            } else if (status < SUCCESS) {
                signalError(MODL, status,
                            "EG_blend returned an error");
                goto cleanup;
            }
        }

        MODL->body[ibody].ebody = ebody;

        /* update the Body type if a SheetBody was produced */
        status = EG_getTopology(ebody, &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        if (oclass == BODY) {
            if (mtype == SHEETBODY || mtype == FACEBODY) {
                SPRINT0(1, "WARNING:: blend produced a SheetBody");
                (MODL->nwarn)++;
                MODL->body[ibody].botype = OCSM_SHEET_BODY;
            } else if (mtype != SOLIDBODY) {
                signalError(MODL, OCSM_INTERNAL_ERROR,
                            "Body produced is neither SheetBody or SolidBody");
                SET_STATUS(OCSM_INTERNAL_ERROR, blend);
            }
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "EGO produced is not a Body");
            SET_STATUS(OCSM_INTERNAL_ERROR, blend);
        }

        /* update @-parameters (BLEND) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* loop through the Faces to keep track of strip number
           and minimum-v (which is used to determine the iford) */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        MALLOC(kstrip, int,    nface+1);
        MALLOC(vmin,   double, nface+1);

        npart = 0;
        for (iface = 1; iface <= nface; iface++) {
            status = EG_attributeRet(efaces[iface-1], ".blendStrip",
                                     &attrtype, &attrlen, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);
            kstrip[iface] = tempIlist[0];

            if (kstrip[iface] == 1) npart++;

            status = EG_getTopology(efaces[iface-1], &eref, &oclass, &mtype,
                                    uvlimits, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);
            vmin[iface] = uvlimits[2];
        }

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, NULL);
        CHECK_STATUS(EG_getBodyTopos);

        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) nface--;
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) nface--;

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
            nface++;
        }
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* make sure all Faces have an Attribute */
        for (iface = 1; iface <= nface; iface++) {
            status = EG_attributeRet(efaces[iface-1], "_body", &attrtype, &attrlen,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);
        }

        EG_free(efaces);

        /* finish the Body (BLEND) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* indicate all nodes and edges originate from the blend body */
        for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
            MODL->body[ibody].node[inode].ibody = ibody;
        }

        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            MODL->body[ibody].edge[iedge].ibody = ibody;
        }

#ifndef __clang_analyzer__
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            if (kstrip[iface] == -1 || kstrip[iface] == -2 || kstrip[iface] > 0) {
                MODL->body[ibody].face[iface].ibody = ibody;

                status = EG_attributeAdd(MODL->body[ibody].face[iface].eface, "_hist", ATTRINT,
                                         1, &ibody, NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);
            } else if (kstrip[iface] == -3) {
                /* copy the history from the sketch */
                status = EG_attributeRet(esketch[0], "_hist",
                                         &atype, &ilen, &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_SUCCESS) {
                    status = EG_attributeAdd(MODL->body[ibody].face[iface].eface, "_hist", ATTRINT,
                                             ilen, tempIlist, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }
            } else if (kstrip[iface] == -4) {
                /* copy the history from the sketch */
                status = EG_attributeRet(esketch[nsketch-1], "_hist",
                                         &atype, &ilen, &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_SUCCESS) {
                    status = EG_attributeAdd(MODL->body[ibody].face[iface].eface, "_hist", ATTRINT,
                                             ilen, tempIlist, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }
            } else {
                status = OCSM_FACE_NOT_FOUND;
                goto cleanup;
            }
        }
#endif

        FREE(vmin  );
        FREE(kstrip);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "sweep" */
    } else if (type == OCSM_SWEEP) {
        SPRINT1(1, "    executing [%4d] sweep:",
                ibrch);

        /* pop two Sketches from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "SWEEP expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that ibodyl is a Sketch */
        if (MODL->body[ibodyl].botype != OCSM_SHEET_BODY &&
            MODL->body[ibodyl].botype != OCSM_WIRE_BODY    ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "SWEEP expects a SheetBody or WireBody on the stack");
            goto cleanup;
        }

        /* check that ibodyr is a Sketch */
        if (MODL->body[ibodyr].botype != OCSM_WIRE_BODY) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "SWEEP expetcs a WireBody on the stack");
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_SWEEP, ibodyl, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        ebodyl = MODL->body[ibodyl].ebody;
        ebodyr = MODL->body[ibodyr].ebody;

        /* if ebodyl is actually an EGADS SheetBody (with one Face),
           convert it now to a FaceBody */
        status = EG_getTopology(ebodyl, &eref, &oclass, &mtype, data,
                                &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        if (mtype == SHEETBODY) {
            newEbodyl = 1;

            status = EG_getBodyTopos(ebodyl, NULL, FACE, &nchild, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
                                     NULL, 1, efaces, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);
        }

        /* arbitrarily set the mode to 0 */
        mode = 0;

        if (outLevel >= 3) {
            SPRINT0(3, "before EG_sweep: ebodyl");
            ocsmPrintEgo(ebodyl);
            SPRINT0(3, "before EG_sweep: ebodyr");
            ocsmPrintEgo(ebodyr);
        }
        status = EG_sweep(ebodyl, ebodyr, mode, &ebody);
        CHECK_STATUS(EG_sweep);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (SWEEP) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        /* transfer Attributes from Sketch to beginning Face */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            status = EG_attributeDup(ebodyl, efaces[0]);
            CHECK_STATUS(EG_attributeDup);
        }

        /* mark the new Faces with the current Branch */
        for (iface = 1; iface <= nface; iface++) {
            if        (iface == 1    ) {
                iford1 = 1;
            } else if (iface == nface) {
                iford1 = 2;
            } else {
                iford1 = iface + 2;
            }
            status = setFaceAttribute(MODL, ibody, iface, 0, iford1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        EG_free(efaces);

        /* finish the Body (SWEEP) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);
    }

cleanup:
    if (newEbodyl == 1) {
        status = EG_deleteObject(ebodyl);
        CHECK_STATUS(EG_deleteObject);
    }

    FREE(isketch);
    FREE(jsketch);
    FREE(esketch);

    FREE(vmin  );
    FREE(kstrip);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildPrimitive - implement OCSM_PRIMITIVEs for ocsmBuild           *
 *                                                                      *
 ************************************************************************
 */

static int
buildPrimitive(modl_T *modl,            /* (in)  pointer to MODL */
               int    ibrch,            /* (in)  Branch index (bias-1) */
               varg_T args[],           /* (in)  array of arguments */
               int    *nstack,          /* (both) number of Bodys on stack */
               int    stack[],          /* (both) array  of Bodys on stack */
               int    npatn,            /* (in)   number of patterns */
               patn_T patn[])           /* (both) array  of patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        type, hasdots, iface, nface, ibody, jbody, kbody, jbrch, irc, jstack;
    int        istor, jstor, ibodyl, ibodyr, nparent, i, atype, alength, markFaces, numRemaining;
    int        *newIlist=NULL, nattr, iattr;
    CINT       *tempIlist;
    double     toler, value, dot, data[18], tdata[4], xyz_out[3], bbox[6];
    CDOUBLE    *tempRlist;
    char       newname[MAX_EXPR_LEN];
    CCHAR      *tempClist, *aname;
    ego        esurface, eface, eshell;

    int         oclass, mtype, iford1, iarg, ival, nedge, iedge;
    int         udp_num, *udp_types, *udp_idef, udp_nmesh;
    int         valInt, ipmtr, jpmtr, ij, sense;
    int         oclass1, nchild, *senses, ifirst, icount, nbody_save;
    double      valDouble, vals[8], dx, dy, dz, alen;
    double      *udp_ddef;
    char        **udp_names, *udp_errStr, primtype[MAX_EXPR_LEN], temp[MAX_EXPR_LEN];
    char        dumpfile[MAX_EXPR_LEN];
    ego         ebody, *eedges, *efaces, topRef, prev, next, emodel, *ebodys=NULL, eref, *echilds;
    ego         *newTess=NULL, eoutput;
    ego         enode, eedge, eloop, ecurve, enodes[2];
    char        atPmtr[MAX_NAME_LEN], str[MAX_STRVAL_LEN];

    int         ifmap[4];
    double      sinx, cosx, siny, cosy, sinz, cosz, mat[12];
    ego         etemp=NULL, exform=NULL;

    ROUTINE(buildPrimitive);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "point xloc yloc zloc" */
    if (type == OCSM_POINT) {
        SPRINT4(1, "    executing [%4d] point:      %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;
            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_POINT, -1, -1,
                         args, hasdots, OCSM_NODE_BODY, &ibody);
        CHECK_STATUS(newBody);

        vals[0] = args[1].val[0];
        vals[1] = args[2].val[0];
        vals[2] = args[3].val[0];

        /* OCSM_NODE_BODY is actually a degenerate WireBody */
        status = EG_makeTopology(MODL->context, NULL, NODE, 0, vals, 0, NULL, NULL, &enode);
        CHECK_STATUS(EG_makeTopology);

        tdata[0] = 0;
        tdata[1] = 1;
        sense    = SFORWARD;
        status = EG_makeTopology(MODL->context, NULL, EDGE, DEGENERATE, tdata, 1, &enode, &sense, &eedge);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED, NULL, 1, &eedge, &sense, &eloop);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL, 1, &eloop, NULL, &ebody);
        CHECK_STATUS(EG_makeTopology);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (POINT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        SPRINT1(1, "                          Body   %4d created", ibody);

    /* execute: "box xbase ybase zbase dx dy dz" */
    } else if (type == OCSM_BOX) {
        SPRINT7(1, "    executing [%4d] box:        %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0                                                 ) {
            hasdots = 1;
            SPRINT6(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0]);
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* if dx, dy, and dz are all non-zero, make a SolidBody */
        if (fabs(args[4].val[0]) > EPS06 &&
            fabs(args[5].val[0]) > EPS06 &&
            fabs(args[6].val[0]) > EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            vals[0] = args[1].val[0];
            vals[1] = args[2].val[0];
            vals[2] = args[3].val[0];
            vals[3] = args[4].val[0];
            vals[4] = args[5].val[0];
            vals[5] = args[6].val[0];

            status = EG_makeSolidBody(MODL->context, BOX, vals, &ebody);
            CHECK_STATUS(EG_makeSolidBody);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces with the current Branch */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            iford1 = 0;
            for (iface = 1; iface <= nface; iface++) {
                if        (faceContains(efaces[iface-1], args[1].val[0],
                                                         args[2].val[0]+args[5].val[0]/2,
                                                         args[3].val[0]+args[6].val[0]/2)) {
                    iford1 = 1;
                } else if (faceContains(efaces[iface-1], args[1].val[0]+args[4].val[0],
                                                         args[2].val[0]+args[5].val[0]/2,
                                                         args[3].val[0]+args[6].val[0]/2)) {
                    iford1 = 2;
                } else if (faceContains(efaces[iface-1], args[1].val[0]+args[4].val[0]/2,
                                                         args[2].val[0],
                                                         args[3].val[0]+args[6].val[0]/2)) {
                    iford1 = 3;
                } else if (faceContains(efaces[iface-1], args[1].val[0]+args[4].val[0]/2,
                                                         args[2].val[0]+args[5].val[0],
                                                         args[3].val[0]+args[6].val[0]/2)) {
                    iford1 = 4;
                } else if (faceContains(efaces[iface-1], args[1].val[0]+args[4].val[0]/2,
                                                         args[2].val[0]+args[5].val[0]/2,
                                                         args[3].val[0])          ) {
                    iford1 = 5;
                } else if (faceContains(efaces[iface-1], args[1].val[0]+args[4].val[0]/2,
                                                         args[2].val[0]+args[5].val[0]/2,
                                                         args[3].val[0]+args[6].val[0])  ) {
                    iford1 = 6;
                }

                status = setFaceAttribute(MODL, ibody, iface, 0, iford1, npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }

            EG_free(efaces);

        /* SheetBody in y-z plane */
        } else if (fabs(args[4].val[0]) <  EPS06 &&
                   fabs(args[5].val[0]) >= EPS06 &&
                   fabs(args[6].val[0]) >= EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            data[0] = args[1].val[0];  data[1] = 0;   data[2] = 0;
            data[3] = 0;               data[4] = 1;   data[5] = 0;
            data[6] = 0;               data[7] = 0;   data[8] = 1;
            status = EG_makeGeometry(MODL->context, SURFACE, PLANE,
                                     NULL, NULL, data, &esurface);
            CHECK_STATUS(EG_makeGeometry);

            data[0] = args[2].val[0];   data[1] = args[2].val[0] + args[5].val[0];
            data[2] = args[3].val[0];   data[3] = args[3].val[0] + args[6].val[0];
            status = EG_makeFace(esurface, SFORWARD, data, &eface);
            CHECK_STATUS(EG_makeFace);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                     NULL, 1, &eface,  NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: y-z plane) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* SheetBody in x-z plane */
        } else if (fabs(args[4].val[0]) >= EPS06 &&
                   fabs(args[5].val[0]) <  EPS06 &&
                   fabs(args[6].val[0]) >= EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            data[0] = 0;  data[1] = args[2].val[0];  data[2] = 0;
            data[3] = 0;  data[4] = 0;               data[5] = 1;
            data[6] = 1;  data[7] = 0;               data[8] = 0;
            status = EG_makeGeometry(MODL->context, SURFACE, PLANE,
                                     NULL, NULL, data, &esurface);
            CHECK_STATUS(EG_makeGeometry);

            data[0] = args[3].val[0];   data[1] = args[3].val[0] + args[6].val[0];
            data[2] = args[1].val[0];   data[3] = args[1].val[0] + args[4].val[0];
            status = EG_makeFace(esurface, SFORWARD, data, &eface);
            CHECK_STATUS(EG_makeFace);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                     NULL, 1, &eface,  NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: x-z plane) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* SheetBody in x-y plane */
        } else if (fabs(args[4].val[0]) >= EPS06 &&
                   fabs(args[5].val[0]) >= EPS06 &&
                   fabs(args[6].val[0]) <  EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            data[0] = 0;  data[1] = 0;   data[2] = args[3].val[0];
            data[3] = 1;  data[4] = 0;   data[5] = 0;
            data[6] = 0;  data[7] = 1;   data[8] = 0;
            status = EG_makeGeometry(MODL->context, SURFACE, PLANE,
                                     NULL, NULL, data, &esurface);
            CHECK_STATUS(EG_makeGeometry);

            data[0] = args[1].val[0];   data[1] = args[1].val[0] + args[4].val[0];
            data[2] = args[2].val[0];   data[3] = args[2].val[0] + args[5].val[0];
            status = EG_makeFace(esurface, SFORWARD, data, &eface);
            CHECK_STATUS(EG_makeFace);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                     NULL, 1, &eface,  NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: x-y plane) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* WireBody in x direction */
        } else if (fabs(args[4].val[0]) >= EPS06 &&
                   fabs(args[5].val[0]) <  EPS06 &&
                   fabs(args[6].val[0]) <  EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* create the curve */
            data[0] = args[1].val[0];
            data[1] = args[2].val[0];
            data[2] = args[3].val[0];
            data[3] = args[4].val[0];
            data[4] = 0;
            data[5] = 0;

            status = EG_makeGeometry(MODL->context, CURVE, LINE,
                                     NULL, NULL, data, &ecurve);
            CHECK_STATUS(EG_makeGeometry);

            /* make the two Nodes */
            status = EG_invEvaluate(ecurve, data, &(data[4]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[0]);
            CHECK_STATUS(EG_makeTopology);

            data[0] = args[1].val[0] + args[4].val[0];
            status = EG_invEvaluate(ecurve, data, &(data[5]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[1]);
            CHECK_STATUS(EG_makeTopology);

            /* make the Edge, Loop, and WireBody */
            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                     &(data[4]), 2, enodes, NULL, &eedge);
            CHECK_STATUS(EG_makeTopology);

            sense = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                     NULL, 1, &eedge, &sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status =EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                    NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: x line) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* WireBody in y direction */
        } else if (fabs(args[4].val[0]) <  EPS06 &&
                   fabs(args[5].val[0]) >= EPS06 &&
                   fabs(args[6].val[0]) <  EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* create the curve */
            data[0] = args[1].val[0];
            data[1] = args[2].val[0];
            data[2] = args[3].val[0];
            data[3] = 0;
            data[4] = args[5].val[0];
            data[5] = 0;

            status = EG_makeGeometry(MODL->context, CURVE, LINE,
                                     NULL, NULL, data, &ecurve);
            CHECK_STATUS(EG_makeGeometry);

            /* make the two Nodes */
            status = EG_invEvaluate(ecurve, data, &(data[4]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[0]);
            CHECK_STATUS(EG_makeTopology);

            data[1] = args[2].val[0] + args[5].val[0];
            status = EG_invEvaluate(ecurve, data, &(data[5]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[1]);
            CHECK_STATUS(EG_makeTopology);

            /* make the Edge, Loop, and WireBody */
            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                     &(data[4]), 2, enodes, NULL, &eedge);
            CHECK_STATUS(EG_makeTopology);

            sense = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                     NULL, 1, &eedge, &sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status =EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                    NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: y line) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* WireBody in z direction */
        } else if (fabs(args[4].val[0]) <  EPS06 &&
                   fabs(args[5].val[0]) <  EPS06 &&
                   fabs(args[6].val[0]) >= EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* create the curve */
            data[0] = args[1].val[0];
            data[1] = args[2].val[0];
            data[2] = args[3].val[0];
            data[3] = 0;
            data[4] = 0;
            data[5] = args[6].val[0];

            status = EG_makeGeometry(MODL->context, CURVE, LINE,
                                     NULL, NULL, data, &ecurve);
            CHECK_STATUS(EG_makeGeometry);

            /* make the two Nodes */
            status = EG_invEvaluate(ecurve, data, &(data[4]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[0]);
            CHECK_STATUS(EG_makeTopology);

            data[2] = args[3].val[0] + args[6].val[0];
            status = EG_invEvaluate(ecurve, data, &(data[5]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[1]);
            CHECK_STATUS(EG_makeTopology);

            /* make the Edge, Loop, and WireBody */
            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                     &(data[4]), 2, enodes, NULL, &eedge);
            CHECK_STATUS(EG_makeTopology);

            sense = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                     NULL, 1, &eedge, &sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status =EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                    NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: z line) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        } else {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "more than one dx, dy, and dz can be zero");
            goto cleanup;
        }

        /* finish the Body (BOX) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "sphere xcent ycent zcent radius" */
    } else if (type == OCSM_SPHERE) {
        SPRINT5(1, "    executing [%4d] sphere:     %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0) {
            hasdots = 1;

            SPRINT4(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0]);
        }

        /* check to be sure that the radius is non-zero */
        if        (fabs(args[4].val[0]) < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius=%f cannot be zero", args[4].val[0]);
            goto cleanup;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_SPHERE, -1, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        vals[0] = args[1].val[0];
        vals[1] = args[2].val[0];
        vals[2] = args[3].val[0];
        vals[3] = args[4].val[0];

        status = EG_makeSolidBody(MODL->context, SPHERE, vals, &ebody);
        CHECK_STATUS(EG_makeSolidBody);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (SPHERE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        iford1 = 0;
        for (iface = 1; iface <= nface; iface++) {
            if        (faceContains(efaces[iface-1], args[1].val[0],
                                                     args[2].val[0]-args[4].val[0]/2,
                                                     args[3].val[0]          )) {
                iford1 = 1;
            } else if (faceContains(efaces[iface-1], args[1].val[0],
                                                     args[2].val[0]+args[4].val[0]/2,
                                                     args[3].val[0]          )) {
                iford1 = 2;
            }

            status = setFaceAttribute(MODL, ibody, iface, 0, iford1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        EG_free(efaces);

        /* finish the Body (SPHERE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "cone xvrtx yvrtx zvrtx xbase ybase zbase radius" */
    } else if (type == OCSM_CONE) {
        SPRINT8(1, "    executing [%4d] cone:       %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0], args[7].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0 || args[7].dot[0] != 0                   ) {
            hasdots = 1;

            SPRINT7(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0], args[7].dot[0]);
        }

        dx = args[4].val[0] - args[1].val[0];
        dy = args[5].val[0] - args[2].val[0];
        dz = args[6].val[0] - args[3].val[0];

        alen = sqrt(dx*dx + dy*dy + dz*dz);

        /* check to be sure that vertex and base are not the same */
        if (alen < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "vertex and base must be different");
            goto cleanup;
        }

        /* check to be sure that the radius is non-zero and positive */
        if (args[7].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius=%f cannot be zero or negative", args[7].val[0]);
            goto cleanup;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_CONE, -1, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        /* find coordinates for cone aligned with closest axis */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            if (dx > 0) {
                vals[0] = 0;     vals[1] = 0;  vals[2] = 0;
                vals[3] = alen;  vals[4] = 0;  vals[5] = 0;

                siny = -dz / alen;
                cosy = +sqrt(1 - siny*siny);

                sinz = +dy / alen / cosy;
                cosz = +sqrt(1 - sinz*sinz);

                mat[ 0] = cosz*cosy;  mat[ 1] = -sinz;  mat[ 2] = cosz*siny;  mat[ 3] = args[1].val[0];
                mat[ 4] = sinz*cosy;  mat[ 5] =  cosz;  mat[ 6] = sinz*siny;  mat[ 7] = args[2].val[0];
                mat[ 8] =     -siny;  mat[ 9] =     0;  mat[10] =      cosy;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            } else {
                vals[0] = alen;  vals[1] = 0;  vals[2] = 0;
                vals[3] =    0;  vals[4] = 0;  vals[5] = 0;

                siny = +dz / alen;
                cosy = +sqrt(1 - siny*siny);

                sinz = -dy / alen / cosy;
                cosz = +sqrt(1 - sinz*sinz);

                mat[ 0] = cosz*cosy;  mat[ 1] = -sinz;  mat[ 2] = cosz*siny;  mat[ 3] = args[4].val[0];
                mat[ 4] = sinz*cosy;  mat[ 5] =  cosz;  mat[ 6] = sinz*siny;  mat[ 7] = args[5].val[0];
                mat[ 8] =     -siny;  mat[ 9] =     0;  mat[10] =      cosy;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            }
        } else if (fabs(dy) >= fabs(dz)) {
            if (dy > 0) {
                vals[0] = 0;  vals[1] = 0;    vals[2] = 0;
                vals[3] = 0;  vals[4] = alen; vals[5] = 0;

                sinz = -dx / alen;
                cosz = +sqrt(1 - sinz*sinz);

                sinx = +dz / alen / cosz;
                cosx = +sqrt(1 - sinx*sinx);

                mat[ 0] =      cosz;  mat[ 1] =     -sinz;  mat[ 2] =     0;  mat[ 3] = args[1].val[0];
                mat[ 4] = cosx*sinz;  mat[ 5] = cosx*cosz;  mat[ 6] = -sinx;  mat[ 7] = args[2].val[0];
                mat[ 8] = sinx*sinz;  mat[ 9] = sinx*cosz;  mat[10] =  cosx;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            } else {
                vals[0] = 0;  vals[1] = alen; vals[2] = 0;
                vals[3] = 0;  vals[4] =    0; vals[5] = 0;

                sinz = +dx / alen;
                cosz = +sqrt(1 - sinz*sinz);

                sinx = -dz / alen / cosz;
                cosx = +sqrt(1 - sinx*sinx);

                mat[ 0] =      cosz;  mat[ 1] =     -sinz;  mat[ 2] =     0;  mat[ 3] = args[4].val[0];
                mat[ 4] = cosx*sinz;  mat[ 5] = cosx*cosz;  mat[ 6] = -sinx;  mat[ 7] = args[5].val[0];
                mat[ 8] = sinx*sinz;  mat[ 9] = sinx*cosz;  mat[10] =  cosx;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            }
        } else {
            if (dz > 0) {
                vals[0] = 0;  vals[1] = 0;  vals[2] = 0;
                vals[3] = 0;  vals[4] = 0;  vals[5] = alen;

                sinx = -dy / alen;
                cosx = +sqrt(1 - sinx*sinx);

                siny = +dx / alen / cosx;
                cosy = +sqrt(1 - siny*siny);

                mat[ 0] =  cosy;  mat[ 1] = siny*sinx;  mat[ 2] = siny*cosx;  mat[ 3] = args[1].val[0];
                mat[ 4] =     0;  mat[ 5] =      cosx;  mat[ 6] =     -sinx;  mat[ 7] = args[2].val[0];
                mat[ 8] = -siny;  mat[ 9] = cosy*sinx;  mat[10] = cosy*cosx;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            } else {
                vals[0] = 0;  vals[1] = 0;  vals[2] = alen;
                vals[3] = 0;  vals[4] = 0;  vals[5] =    0;

                sinx = +dy / alen;
                cosx = +sqrt(1 - sinx*sinx);

                siny = -dx / alen / cosx;
                cosy = +sqrt(1 - siny*siny);

                mat[ 0] =  cosy;  mat[ 1] = siny*sinx;  mat[ 2] = siny*cosx;  mat[ 3] = args[4].val[0];
                mat[ 4] =     0;  mat[ 5] =      cosx;  mat[ 6] =     -sinx;  mat[ 7] = args[5].val[0];
                mat[ 8] = -siny;  mat[ 9] = cosy*sinx;  mat[10] = cosy*cosx;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            }
        }
        vals[6] = args[7].val[0];

        /* create the cone along the axis */
        status = EG_makeSolidBody(MODL->context, CONE, vals, &etemp);
        CHECK_STATUS(EG_makeSolidBody);

        /* transform the cone into its final position */
        status = EG_makeTransform(MODL->context, mat, &exform);
        CHECK_STATUS(EG_makeTransform);

        status = EG_copyObject(etemp, exform, &ebody);
        CHECK_STATUS(EG_copyObject);

        status = EG_deleteObject(etemp);
        CHECK_STATUS(EG_deleteObject);

        status = EG_deleteObject(exform);
        CHECK_STATUS(EG_deleteObject);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (CONE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, ifmap[iface-1], npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        EG_free(efaces);

        /* finish the Body (CONE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "cylinder xbeg ybeg zbeg xend yend zend radius" */
    } else if (type == OCSM_CYLINDER) {
        SPRINT8(1, "    executing [%4d] cylinder:   %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0], args[7].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0 || args[7].dot[0] != 0                   ) {
            hasdots = 1;

            SPRINT7(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0], args[7].dot[0]);
        }

        dx = args[4].val[0] - args[1].val[0];
        dy = args[5].val[0] - args[2].val[0];
        dz = args[6].val[0] - args[3].val[0];

        alen = sqrt(dx*dx + dy*dy + dz*dz);

        /* check to be sure that vertex and base are not the same */
        if (alen < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "vertex and base must be different");
            goto cleanup;
        }

        /* check to be sure that the radius is non-zero and positive */
        if (args[7].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius=%f cannot be zero or negative", args[7].val[0]);
            goto cleanup;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_CYLINDER, -1, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        /* find coordinates for cylinder aligned with closest axis */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            if (dx > 0) {
                vals[0] = 0;     vals[1] = 0;  vals[2] = 0;
                vals[3] = alen;  vals[4] = 0;  vals[5] = 0;

                siny = -dz / alen;
                cosy = +sqrt(1 - siny*siny);

                sinz = +dy / alen / cosy;
                cosz = +sqrt(1 - sinz*sinz);

                mat[ 0] = cosz*cosy;  mat[ 1] = -sinz;  mat[ 2] = cosz*siny;  mat[ 3] = args[1].val[0];
                mat[ 4] = sinz*cosy;  mat[ 5] =  cosz;  mat[ 6] = sinz*siny;  mat[ 7] = args[2].val[0];
                mat[ 8] =     -siny;  mat[ 9] =     0;  mat[10] =      cosy;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;  ifmap[3] = 1;
            } else {
                vals[0] = 0;     vals[1] = 0;  vals[2] = 0;
                vals[3] = alen;  vals[4] = 0;  vals[5] = 0;

                siny = +dz / alen;
                cosy = +sqrt(1 - siny*siny);

                sinz = -dy / alen / cosy;
                cosz = +sqrt(1 - sinz*sinz);

                mat[ 0] = cosz*cosy;  mat[ 1] = -sinz;  mat[ 2] = cosz*siny;  mat[ 3] = args[4].val[0];
                mat[ 4] = sinz*cosy;  mat[ 5] =  cosz;  mat[ 6] = sinz*siny;  mat[ 7] = args[5].val[0];
                mat[ 8] =     -siny;  mat[ 9] =     0;  mat[10] =      cosy;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 1;  ifmap[3] = 2;
            }
        } else if (fabs(dy) >= fabs(dz)) {
            if (dy > 0) {
                vals[0] = 0;  vals[1] = 0;    vals[2] = 0;
                vals[3] = 0;  vals[4] = alen; vals[5] = 0;

                sinz = -dx / alen;
                cosz = +sqrt(1 - sinz*sinz);

                sinx = +dz / alen / cosz;
                cosx = +sqrt(1 - sinx*sinx);

                mat[ 0] =      cosz;  mat[ 1] =     -sinz;  mat[ 2] =     0;  mat[ 3] = args[1].val[0];
                mat[ 4] = cosx*sinz;  mat[ 5] = cosx*cosz;  mat[ 6] = -sinx;  mat[ 7] = args[2].val[0];
                mat[ 8] = sinx*sinz;  mat[ 9] = sinx*cosz;  mat[10] =  cosx;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;  ifmap[3] = 1;
            } else {
                vals[0] = 0;  vals[1] = 0;    vals[2] = 0;
                vals[3] = 0;  vals[4] = alen; vals[5] = 0;

                sinz = +dx / alen;
                cosz = +sqrt(1 - sinz*sinz);

                sinx = -dz / alen / cosz;
                cosx = +sqrt(1 - sinx*sinx);

                mat[ 0] =      cosz;  mat[ 1] =     -sinz;  mat[ 2] =     0;  mat[ 3] = args[4].val[0];
                mat[ 4] = cosx*sinz;  mat[ 5] = cosx*cosz;  mat[ 6] = -sinx;  mat[ 7] = args[5].val[0];
                mat[ 8] = sinx*sinz;  mat[ 9] = sinx*cosz;  mat[10] =  cosx;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 1;  ifmap[3] = 2;
            }
        } else {
            if (dz > 0) {
                vals[0] = 0;  vals[1] = 0;  vals[2] = 0;
                vals[3] = 0;  vals[4] = 0;  vals[5] = alen;

                sinx = -dy / alen;
                cosx = +sqrt(1 - sinx*sinx);

                siny = +dx / alen / cosx;
                cosy = +sqrt(1 - siny*siny);

                mat[ 0] =  cosy;  mat[ 1] = siny*sinx;  mat[ 2] = siny*cosx;  mat[ 3] = args[1].val[0];
                mat[ 4] =     0;  mat[ 5] =      cosx;  mat[ 6] =     -sinx;  mat[ 7] = args[2].val[0];
                mat[ 8] = -siny;  mat[ 9] = cosy*sinx;  mat[10] = cosy*cosx;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;  ifmap[3] = 1;
            } else {
                vals[0] = 0;  vals[1] = 0;  vals[2] = 0;
                vals[3] = 0;  vals[4] = 0;  vals[5] = alen;

                sinx = +dy / alen;
                cosx = +sqrt(1 - sinx*sinx);

                siny = -dx / alen / cosx;
                cosy = +sqrt(1 - siny*siny);

                mat[ 0] =  cosy;  mat[ 1] = siny*sinx;  mat[ 2] = siny*cosx;  mat[ 3] = args[4].val[0];
                mat[ 4] =     0;  mat[ 5] =      cosx;  mat[ 6] =     -sinx;  mat[ 7] = args[5].val[0];
                mat[ 8] = -siny;  mat[ 9] = cosy*sinx;  mat[10] = cosy*cosx;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 1;  ifmap[3] = 2;
            }
        }
        vals[6] = args[7].val[0];

        /* create the cylinder along the axis */
        status = EG_makeSolidBody(MODL->context, CYLINDER, vals, &etemp);
        CHECK_STATUS(EG_makeSolidBody);

        /* transform the cylinder into its final position */
        status = EG_makeTransform(MODL->context, mat, &exform);
        CHECK_STATUS(EG_makeTransform);

        status = EG_copyObject(etemp, exform, &ebody);
        CHECK_STATUS(EG_copyObject);

        status = EG_deleteObject(etemp);
        CHECK_STATUS(EG_deleteObject);

        status = EG_deleteObject(exform);
        CHECK_STATUS(EG_deleteObject);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (CYLINDER) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, ifmap[iface-1], npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        EG_free(efaces);

        /* finish the Body (CYLINDER) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "torus xcent ycent zcent dxaxis dyaxis dzaxis majorRad minorRad" */
    } else if (type == OCSM_TORUS) {
        SPRINT9(1, "    executing [%4d] torus:      %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0], args[7].val[0], args[8].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0 || args[7].dot[0] != 0 || args[8].dot[0] != 0   ) {
            hasdots = 1;

            SPRINT8(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0], args[7].dot[0], args[8].dot[0]);
        }

        /* check to be sure that the axis is not zero */
        if (fabs(args[4].val[0]) < EPS06 &&
            fabs(args[5].val[0]) < EPS06 &&
            fabs(args[6].val[0]) < EPS06   ) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "axis length must be non-zero");
            goto cleanup;
        }

        /* check to be sure that the radii are non-zero */
        if        (args[7].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "majorRad=%f cannot be zero or negative", args[7].val[0]);
            goto cleanup;
        } else if (args[8].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "minorRad=%f cannot be zero or negative", args[8].val[0]);
            goto cleanup;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_TORUS, -1, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        vals[0] = args[1].val[0];
        vals[1] = args[2].val[0];
        vals[2] = args[3].val[0];
        vals[3] = args[4].val[0];
        vals[4] = args[5].val[0];
        vals[5] = args[6].val[0];
        vals[6] = args[7].val[0];
        vals[7] = args[8].val[0];

        status = EG_makeSolidBody(MODL->context, TORUS, vals, &ebody);
        CHECK_STATUS(EG_makeSolidBody);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (TORUS) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        EG_free(efaces);

        /* finish the Body (TORUS) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);

    /* execute: "import $filename bodynumber=1" */
    } else if (type == OCSM_IMPORT) {
        SPRINT3(1, "    executing [%4d] import:     %s  %11.5f",
                ibrch, args[1].str, args[2].val[0]);

        /* recycle old Body if not dirty */
        nbody_save = MODL->nbody;
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                if (*nstack < MAX_STACK_SIZE) {
                    stack[(*nstack)++] = ibodyl;
                } else {
                    status = OCSM_TOO_MANY_BODYS_ON_STACK;
                    signalError(MODL, status,
                                "Too many Bodys on Stack");
                    goto cleanup;
                }
            }
            status = SUCCESS;
            goto cleanup;
        }

        /* load and execute the user-defined primitive */
        STRNCPY(primtype, "import", MAX_EXPR_LEN);

        status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
        if (status == EGADS_NOLOAD) {
            status = EGADS_SUCCESS;
        }
        CHECK_STATUS(udp_initialize);

        status = udp_clrArguments(primtype);
        CHECK_STATUS(udp_clrArguments);

        /* strip the dollarsign off the filename */
        STRNCPY(dumpfile, args[1].str, MAX_EXPR_LEN);

        status = udp_setArgument(primtype, "filename", dumpfile, (int)(STRLEN(dumpfile)+1));
        CHECK_STATUS(udp_setArgument);

        /* set the Body number (in the import) */
        status = udp_setArgument(primtype, "bodynumber", &(args[2].val[0]), 1);
        CHECK_STATUS(udp_setArgument);

        /* execute udpImport */
        status = udp_executePrim(primtype, MODL->context, &emodel, &udp_nmesh, &udp_errStr);
        if (status < 0) {
            if (udp_errStr != NULL) {
                signalError(MODL, status,
                            udp_errStr);
                EG_free(udp_errStr);
            }  else {
                signalError(MODL, status,
                            "unspecified error");
            }
            goto cleanup;
        }

        /* remember first Body created by this statement */
        ifirst = MODL->nbody + 1;

        /* check the type of return */
        status = EG_getTopology(emodel, &eref, &oclass1, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        /* if a MODEL was returned, set up @@ parameters for all MODEL attributes */
        if (oclass1 == MODEL) {
            status = EG_attributeNum(emodel, &nattr);
            CHECK_STATUS(EG_attributeNum);

            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(emodel, iattr, &aname, &atype, &alength, &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeGet);

                if (STRLEN(aname) >= MAX_NAME_LEN-2) {
                    SPRINT1(1, "WARNING:: \"@@%s\"s name (from Models attributes) will be truncated", aname);
                }

                snprintf(newname, MAX_NAME_LEN, "@@%s", aname);

                status = ocsmFindPmtr(MODL, newname, OCSM_INTERNAL, alength, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                if (atype == ATTRINT) {
                    for (i = 0; i < alength; i++) {
                        status = ocsmSetValuD(MODL, ipmtr, i+1, 1, (double)(tempIlist[i]));
                        CHECK_STATUS(ocsmSetValuD);
                    }
                } else if (atype == ATTRREAL) {
                    for (i = 0; i < alength; i++) {
                        status = ocsmSetValuD(MODL, ipmtr, i+1, 1, tempRlist[i]);
                        CHECK_STATUS(ocsmSetValuD);
                    }
                } else if (atype == ATTRSTRING) {
                    status = ocsmSetValu(MODL, ipmtr, 1, 1, (char *)tempClist);
                    CHECK_STATUS(ocsmSetValu);
                }
            }
        }

        /* either process BODY that was returned, or a copy of each of the Bodys in the MODEL */
        for (i = 0; i < nchild; i++) {
            if        (oclass1 == MODEL) {
                status = EG_copyObject(echilds[i], NULL, &ebody);
                CHECK_STATUS(EG_copyObject);
            } else if (oclass1 == BODY) {
                ebody  = emodel;
                nchild = 1;
            } else {
                signalError(MODL, OCSM_BODY_NOT_FOUND,
                            "expecting a Model or Body");
            }

            status = EG_getInfo(ebody, &oclass, &mtype, &topRef, &prev, &next);
            CHECK_STATUS(EG_getInfo);

            /* create the Body */
            if        (oclass == BODY && mtype == SOLIDBODY) {
                status = newBody(MODL, ibrch, OCSM_IMPORT, -1, -1,
                                 args, hasdots, OCSM_SOLID_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else if (oclass == BODY && mtype == FACEBODY) {
                status = newBody(MODL, ibrch, OCSM_IMPORT, -1, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else if (oclass == BODY && mtype == SHEETBODY) {
                status = newBody(MODL, ibrch, OCSM_IMPORT, -1, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else if (oclass == BODY && mtype == WIREBODY) {
                status = newBody(MODL, ibrch, OCSM_IMPORT, -1, -1,
                                 args, hasdots, OCSM_WIRE_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "IMPORT did not create a SolidBody, SheetBody, or WireBody");
                goto cleanup;
            }

            /* check the tolerance and issue warning if a problem */
            status = getBodyTolerance(ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            if (toler > 2.0e-7) {
                SPRINT1(1, "WARNING:: toler = %12.4e for import", toler);
                (MODL->nwarn)++;
            }

            /* set @@-parameters for any outputs from the udp */
            for (ij = 0; ij < udp_num; ij++) {
                if        (udp_types[ij] == -ATTRINT) {
                    status = udp_getOutput(primtype, emodel, udp_names[ij], (void*)&valInt);
                    CHECK_STATUS(udp_getOutput);

                    snprintf(atPmtr, MAX_NAME_LEN, "@@%s", udp_names[ij]);

                    status = ocsmFindPmtr(MODL, atPmtr, OCSM_INTERNAL, 1, 1, &ipmtr);
                    CHECK_STATUS(ocsmFindPmtr);

                    valDouble = valInt;
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, valDouble);
                    CHECK_STATUS(ocsmSetValuD);

                    snprintf(atPmtr, MAX_NAME_LEN, "__@@%s__", udp_names[ij]);

                    status = EG_attributeAdd(ebody, atPmtr, ATTRINT,
                                             1, &valInt, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                } else if (udp_types[ij] == -ATTRREAL) {
                    status = udp_getOutput(primtype, emodel, udp_names[ij], (void*)&valDouble);
                    CHECK_STATUS(udp_getOutput);

                    snprintf(atPmtr, MAX_NAME_LEN, "@@%s", udp_names[ij]);

                    status = ocsmFindPmtr(MODL, atPmtr, OCSM_INTERNAL, 1, 1, &ipmtr);
                    CHECK_STATUS(ocsmFindPmtr);

                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, valDouble);
                    CHECK_STATUS(ocsmSetValuD);

                    snprintf(atPmtr, MAX_NAME_LEN, "__@@%s__", udp_names[ij]);

                    status = EG_attributeAdd(ebody, atPmtr, ATTRREAL,
                                             1, NULL, &valDouble, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }
            }

            MODL->body[ibody].ebody = ebody;

            /* keep track of number of Bodys remaining from this command */
            numRemaining = nchild - 1 - i;
            if (numRemaining > 0) {
                status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                         1, &numRemaining, NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);
            }

            /* update @-parameters (IMPORT) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces with the current Branch */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (nface > 0) {
                for (iface = 1; iface <= nface; iface++) {
                    (void) EG_setOutLevel(MODL->context, 0);
                    status = EG_attributeDel(efaces[iface-1], "_body");

                    (void) EG_setOutLevel(MODL->context, outLevel);
                    if (status != EGADS_NOTFOUND) {
                        CHECK_STATUS(EG_attributeDel);
                    }

                    (void) EG_setOutLevel(MODL->context, 0);
                    status = EG_attributeDel(efaces[iface-1], "_brch");
                    (void) EG_setOutLevel(MODL->context, outLevel);
                    if (status != EGADS_NOTFOUND) {
                        CHECK_STATUS(EG_attributeDel);
                    }

                    status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                }
            } else {
                status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, &eedges);
                CHECK_STATUS(EG_getBodyTopos);

                for (iedge = 1; iedge <= nedge; iedge++) {
                    (void) EG_setOutLevel(MODL->context, 0);
                    status = EG_attributeDel(eedges[iedge-1], "_body");
                    (void) EG_setOutLevel(MODL->context, outLevel);
                    if (status != EGADS_NOTFOUND) {
                        CHECK_STATUS(EG_attributeDel);
                    }

                    (void) EG_setOutLevel(MODL->context, 0);
                    status = EG_attributeDel(eedges[iedge-1], "_brch");
                    (void) EG_setOutLevel(MODL->context, outLevel);
                    if (status != EGADS_NOTFOUND) {
                        CHECK_STATUS(EG_attributeDel);
                    }
                }

                EG_free(eedges);
            }

            EG_free(efaces);

            /* finish the Body (IMPORT) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body back onto the stack */
            if (*nstack < MAX_STACK_SIZE) {
                stack[(*nstack)++] = ibody;
            } else {
                status = OCSM_TOO_MANY_BODYS_ON_STACK;
                signalError(MODL, status,
                            "Too many Bodys on Stack");
                goto cleanup;
            }

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                    ibody, toler);
        }

        /* put all Bodys just created into same group */
        for (ibody = ifirst; ibody < MODL->nbody; ibody++) {
            MODL->body[ibody].igroup = MODL->body[MODL->nbody].igroup;
        }

    /* execute: "udprim $primtype $argName1 argValue1 $argName2 argValue2 $argName3 argValue3 $argName4 argValue4" */
    } else if (type == OCSM_UDPRIM) {

        /* primtype starts with a letter, so use a compiled udprim named 'primtype.so' */
        if ((args[1].str[0] >= 'a' && args[1].str[0] <= 'z') ||
            (args[1].str[0] >= 'A' && args[1].str[0] <= 'Z')   ) {
            SPRINT2x(1, "    executing [%4d] udprim:     %s",
                    ibrch, args[1].str);

            hasdots = 0;
            for (iarg = 3; iarg <= MODL->brch[ibrch].narg; iarg+=2) {
                if (args[iarg].nval == 0) {
                    SPRINT2x(1, " %s %s",
                             args[iarg-1].str, args[iarg].str);
                } else {
                    SPRINT2x(1, " %s %11.5f",
                             args[iarg-1].str, args[iarg].val[0]);
                    for (ival = 0; ival < args[iarg].nval; ival++) {
                        if (args[iarg].dot[ival] != 0) hasdots = 1;
                    }
                }
            }
            SPRINT0(1, " (compiled code)");

            /* go back to first associated udparg statement whose primtype matches the
               udprim's primtype */
            jbody = MODL->nbody;
            while (jbody > 0 && MODL->body[jbody].brtype == OCSM_UDPARG &&
                   strcmp(MODL->body[jbody].arg[1].str, args[1].str) == 0 ) {

                if (MODL->body[jbody].hasdots != 0) hasdots = MODL->body[jbody].hasdots;

                jbody--;
            }
            jbody++;

            /* initialize the user-defined primitive */
            STRNCPY(primtype, args[1].str, MAX_EXPR_LEN);

            status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
            if (status == EGADS_NOLOAD) {
                status = EGADS_SUCCESS;
            }
            CHECK_STATUS(udp_initialize);

            status = udp_clrArguments(primtype);
            CHECK_STATUS(udp_clrArguments);

            /* determine links for the new Body if the UDPRIM has any parents */
            nparent = udp_numBodys(primtype);

            if (nparent != 0) {
                MALLOC(newIlist, int, abs(nparent));
            }

            icount = 0;

            if (nparent == 1) {
                if ((*nstack) < 1) {
                    signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                                "UDPRIM(%s) expects a Body on the stack", primtype);
                    goto cleanup;
                } else {
                    newIlist[icount++] = stack[--(*nstack)];
                }
            } else if (nparent == 2) {
                if ((*nstack) < 2) {
                    signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                                "UDPRIM(%s) expects two Bodys on the stack", primtype);
                    goto cleanup;
                } else {
                    newIlist[icount++] = stack[--(*nstack)];
                    newIlist[icount++] = stack[--(*nstack)];
                }
            } else if (nparent < 0) {           // up to -nparent Bodys back to mark
                for (jstack = *nstack-1; jstack >= 0; jstack--) {
                    if (stack[jstack] == 0) break;
                    newIlist[icount++] = stack[--(*nstack)];
                }

                if (icount > -nparent) {
                    signalError(MODL, OCSM_TOO_MANY_BODYS_ON_STACK,
                                "UDPRIM(%s) requires 0 to %d Bodys before mark", primtype, -nparent);
                    goto cleanup;
                } else {
                    nparent = icount;
                }
            } else if (nparent != 0) {
                signalError(MODL, OCSM_INTERNAL_ERROR,
                            "nparent=%d\n", nparent);
                SET_STATUS(OCSM_INTERNAL_ERROR, udprim);
            }

            if (nparent == 0) {
                ibodyl = -1;
                ibodyr = -1;
            } else if (nparent == 1) {
                ibodyl = newIlist[0];
                ibodyr = -1;
            } else {
                ibodyl = newIlist[0];
                ibodyr = newIlist[icount-1];
            }

            /* recycle old Body if not dirty */
            nbody_save = MODL->nbody;
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                /* remove Mark from stack (if used because UDPRIM gets all Bodys back to Mark) */
                if (udp_numBodys(primtype) < 0 && *nstack > 0 && stack[*nstack-1] == 0) {
                    (*nstack)--;
                }

                for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                    if (*nstack < MAX_STACK_SIZE) {
                        stack[(*nstack)++] = ibodyl;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }

                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body (temporarily so that arguments can be processed) */
            status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* go back to first associated udparg statement whose primtype matches the
               udprim's primtype */
            jbody = MODL->nbody - 1;
            while (jbody > 0 && MODL->body[jbody].brtype == OCSM_UDPARG &&
                   strcmp(MODL->body[jbody].arg[1].str, args[1].str) == 0 ) {

                jbody--;
            }
            jbody++;

            while (jbody <= MODL->nbody) {
                for (iarg = 3; iarg < 10; iarg+=2) {
                    if (MODL->body[jbody].arg[iarg].nval < 0) break;

                    if (MODL->body[jbody].arg[iarg].nval == 0) {
                        status = udp_setArgument(MODL->body[jbody].arg[1].str,
                                                 MODL->body[jbody].arg[iarg-1].str,
                                                 MODL->body[jbody].arg[iarg  ].str,
                                          STRLEN(MODL->body[jbody].arg[iarg  ].str));
                        CHECK_STATUS(udp_setArgument);
                    } else {
                        status = udp_setArgument(MODL->body[jbody].arg[1].str,
                                                 MODL->body[jbody].arg[iarg-1].str,
                                                 MODL->body[jbody].arg[iarg  ].val,
                                                 MODL->body[jbody].arg[iarg  ].nval);
                        CHECK_STATUS(udp_setArgument);
                    }
                }

                jbody++;
            }

            /* remove temporary Body */
            status = freeBody(MODL, ibody);
            CHECK_STATUS(freeBody);

            (MODL->nbody)--;
            (MODL->ngroup)--;

            /* if the primitive needs inputs, make a Model of the Bodys and their
               Tessellation objects because a UDF may need the tessellation */
            MALLOC(ebodys,  ego, nparent);
            MALLOC(newTess, ego, nparent);

            for (i = 0; i < nparent; i++) {
                newTess[i] = NULL;
            }

            if  (nparent == 0) {
                emodel = MODL->context;
            } else {
                for (i = 0; i < nparent; i++) {
                    ibodyl = newIlist[nparent-1-i];
                    status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &(ebodys[i]));
                    CHECK_STATUS(EG_copyObject);

                    if (MODL->body[ibodyl].etess != NULL) {
                        status = EG_mapTessBody(MODL->body[ibodyl].etess, ebodys[i], &newTess[i]);
                        CHECK_STATUS(EG_mapTessBody);
                    }

                    MODL->body[ibodyl].ichld = MODL->nbody;
                }

                /* remove Mark from stack (if used because UDPRIM gets all Bodys back to Mark) */
                if (udp_numBodys(primtype) < 0 && *nstack > 0 && stack[*nstack-1] == 0) {
                    (*nstack)--;
                }

                status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                         NULL, nparent, ebodys, NULL, &emodel);
                CHECK_STATUS(EG_makeTopology);
            }

            FREE(newIlist);

            /* execute the primitive */
            status = udp_executePrim(primtype, emodel, &eoutput, &udp_nmesh, &udp_errStr);
            if (status < 0) {
                if (udp_errStr != NULL) {
                    signalError(MODL, status,
                                udp_errStr);
                    EG_free(udp_errStr);
                }  else {
                    signalError(MODL, status,
                                "unspecified error");
                }
                goto cleanup;
            }

            /* remember first Body created by this statement */
            ifirst = MODL->nbody + 1;

            /* check the type of return */
            status = EG_getTopology(eoutput, &eref, &oclass1, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            /* either process BODY that was returned, or a copy of each of the Bodys in the MODEL */
            for (i = 0; i < nchild; i++) {
                if        (oclass1 == MODEL) {
                    status = EG_copyObject(echilds[i], NULL, &ebody);
                    CHECK_STATUS(EG_copyObject);
                } else if (oclass1 == BODY) {
                    ebody  = eoutput;    /* cannot make copy since then
                                            the UDP could not match the ebody
                                            when computing sensitivities */
                    nchild = 1;
                } else {
                    signalError(MODL, OCSM_BODY_NOT_FOUND,
                                "expecting a Model or Body");
                }

                status = EG_getInfo(ebody, &oclass, &mtype, &topRef, &prev, &next);
                CHECK_STATUS(EG_getInfo);

                /* create the Body */
                if        (oclass == BODY && mtype == SOLIDBODY) {
                    status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                     args, hasdots, OCSM_SOLID_BODY, &ibody);
                    CHECK_STATUS(newBody);
                } else if (oclass == BODY && mtype == FACEBODY) {
                    status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                     args, hasdots, OCSM_SHEET_BODY, &ibody);
                    CHECK_STATUS(newBody);
                } else if (oclass == BODY && mtype == SHEETBODY) {
                    status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                     args, hasdots, OCSM_SHEET_BODY, &ibody);
                    CHECK_STATUS(newBody);
                } else if (oclass == BODY && mtype == WIREBODY) {
                    status = EG_getBoundingBox(ebody, bbox);
                    CHECK_STATUS(EG_getBoundingBox);
                    if (fabs(bbox[3]-bbox[0]) > EPS06 ||
                        fabs(bbox[4]-bbox[1]) > EPS06 ||
                        fabs(bbox[5]-bbox[2]) > EPS06   ) {
                        status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                         args, hasdots, OCSM_WIRE_BODY, &ibody);
                        CHECK_STATUS(newBody);
                    } else {
                        status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                         args, hasdots, OCSM_NODE_BODY, &ibody);
                        CHECK_STATUS(newBody);
                    }
                } else {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "UDPRIM did not create a SolidBody, SheetBody, or WireBody");
                    goto cleanup;
                }

                /* check the tolerance and issue warning if a problem */
                status = getBodyTolerance(ebody, &toler);
                CHECK_STATUS(getBodyTolerance);

                if (toler > 2.0e-7) {
                    SPRINT1(1, "WARNING:: toler = %12.4e for udprim", toler);
                    (MODL->nwarn)++;
                }

                /* set @@-parameters for any outputs from the udp */
                for (ij = 0; ij < udp_num; ij++) {
                    if        (udp_types[ij] == -ATTRINT) {
                        status = udp_getOutput(primtype, eoutput, udp_names[ij], (void*)&valInt);
                        CHECK_STATUS(udp_getOutput);

                        snprintf(atPmtr, MAX_NAME_LEN, "@@%s", udp_names[ij]);

                        status = ocsmFindPmtr(MODL, atPmtr, OCSM_INTERNAL, 1, 1, &ipmtr);
                        CHECK_STATUS(ocsmFindPmtr);

                        valDouble = valInt;
                        status = ocsmSetValuD(MODL, ipmtr, 1, 1, valDouble);
                        CHECK_STATUS(ocsmSetValuD);

                        snprintf(atPmtr, MAX_NAME_LEN, "__@@%s__", udp_names[ij]);

                        status = EG_attributeAdd(ebody, atPmtr, ATTRINT,
                                                 1, &valInt, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* store @@-parametr in body_T structure */
                    } else if (udp_types[ij] == -ATTRREAL) {
                        status = udp_getOutput(primtype, eoutput, udp_names[ij], (void*)&valDouble);
                        CHECK_STATUS(udp_getOutput);

                        snprintf(atPmtr, MAX_NAME_LEN, "@@%s", udp_names[ij]);

                        status = ocsmFindPmtr(MODL, atPmtr, OCSM_INTERNAL, 1, 1, &ipmtr);
                        CHECK_STATUS(ocsmFindPmtr);

                        status = ocsmSetValuD(MODL, ipmtr, 1, 1, valDouble);
                        CHECK_STATUS(ocsmSetValuD);

                        snprintf(atPmtr, MAX_NAME_LEN, "__@@%s__", udp_names[ij]);

                        status = EG_attributeAdd(ebody, atPmtr, ATTRREAL,
                                                 1, NULL, &valDouble, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* store @@-parametr in body_T structure */
                    }
                }

                MODL->body[ibody].ebody = ebody;

                /* keep track of number of Bodys remaining from this command */
                numRemaining = nchild - 1 - i;
                if (numRemaining > 0) {
                    status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                             1, &numRemaining, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }

                /* update @-parameters (UDPRIM udp/udf) */
                status = setupAtPmtrs(MODL, 0);
                CHECK_STATUS(setupAtPmtrs);

                /* mark the new Faces with the current Branch */
                status = EG_attributeRet(ebody, "__markFaces__", &atype, &alength,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_SUCCESS) {
                    markFaces = 1;
                    status = EG_attributeDel(ebody, "__markFaces__");
                    CHECK_STATUS(EG_attributeDel);
                } else {
                    markFaces = 0;
                }

                if (nparent == 0 || markFaces == 1) {
                    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iface = 1; iface <= nface; iface++) {
                        (void) EG_setOutLevel(MODL->context, 0);
                        status = EG_attributeDel(efaces[iface-1], "_body");
                        (void) EG_setOutLevel(MODL->context, outLevel);
                        if (status != EGADS_NOTFOUND) {
                            CHECK_STATUS(EG_attributeDel);
                        }

                        (void) EG_setOutLevel(MODL->context, 0);
                        status = EG_attributeDel(efaces[iface-1], "_brch");
                        (void) EG_setOutLevel(MODL->context, outLevel);
                        if (status != EGADS_NOTFOUND) {
                            CHECK_STATUS(EG_attributeDel);
                        }

                        status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                        CHECK_STATUS(setFaceAttribute);
                    }

                    EG_free(efaces);

                /* special case when a UDP/UDF returns a Body whose Faces are marked
                   with _ibrch[0] == -1 */
                } else if (markFaces == 0) {
                    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                    CHECK_STATUS(EG_getBodyTopos);

                    for (iface = 1; iface <= nface; iface++) {
                        status = EG_attributeRet(efaces[iface-1], "_brch", &atype, &alength,
                                                 &tempIlist, &tempRlist, &tempClist);
                        if (status == EGADS_SUCCESS && atype == ATTRINT && tempIlist[0] == -1) {
                            MALLOC(newIlist, int, alength);

                            newIlist[0] = ibrch;
                            for (i = 1; i < alength; i++) {
                                newIlist[i] = tempIlist[i];
                            }

                            status = EG_attributeAdd(efaces[iface-1], "_brch", atype, alength,
                                                     newIlist, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            FREE(newIlist);
                        }
                    }

                    EG_free(efaces);
                }

                /* finish the Body (UDPRIM udp/udf) */
                status = finishBody(MODL, ibody);
                if (MODL->sigCode != SUCCESS) goto cleanup;
                CHECK_STATUS(finishBody);

                /* push the Body back onto the stack */
                if (*nstack < MAX_STACK_SIZE) {
                    stack[(*nstack)++] = ibody;
                } else {
                    status = OCSM_TOO_MANY_BODYS_ON_STACK;
                    signalError(MODL, status,
                                "Too many Bodys on Stack");
                    goto cleanup;
                }

                status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                CHECK_STATUS(getBodyTolerance);

                SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                        ibody, toler);
            }

            /* put all Bodys just created into same group as the last Body */
            for (ibody = ifirst; ibody < MODL->nbody; ibody++) {
                MODL->body[ibody].igroup = MODL->body[MODL->nbody].igroup;
            }

            /* delete the emodel and any of its tessellations if made just for passing into UDP */
            for (i = 0; i < nparent; i++) {
                if (newTess[i] != NULL) {
                    status = EG_deleteObject(newTess[i]);
                    CHECK_STATUS(EG_deleteObject);
                }
            }

            if (nparent != 0) {
                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);
            }

        /* if primtype begins with /  $/ or $$/, then we have user-defined code */
        } else if (strncmp(args[1].str, "/",   1) == 0 ||
                   strncmp(args[1].str, "$/",  2) == 0 ||
                   strncmp(args[1].str, "$$/", 3) == 0   ) {
            SPRINT2x(1, "    executing [%4d] udprim:     %s",
                    ibrch, args[1].str);

            for (iarg = 3; iarg <= MODL->brch[ibrch].narg; iarg+=2) {
                if (args[iarg].nval == 0) {
                    SPRINT2x(1, " %s %s",
                             args[iarg-1].str, args[iarg].str);
                } else {
                    SPRINT2x(1, " %s %11.5f",
                             args[iarg-1].str, args[iarg].val[0]);
                }
            }
            SPRINT0(1, " (scripted code)");

            /* increment the level and create a new scope */
            (MODL->level)++;
            MODL->scope[MODL->level] = MODL->scope[MODL->level-1] + 1;

            SPRINT0(2, "Parameters before processing UDPARG/UDPRIM statements:");
            if (outLevel >= 2) {
                status = printPmtrs(MODL, stdout);
                CHECK_STATUS(printPmtrs);
            }

            /* note: we need to pre-process the INTERFACE statements in the
               UDC to set up storage and the default value before we actually
               pass in the values from the UDPARG and UDPRIM statements.  Later
               when we see the INTERFACE statements, nothing will actually
               get done */
            jbrch = ibrch + 1;
            while (MODL->brch[jbrch].type == OCSM_INTERFACE) {

                if (strcmp(MODL->brch[jbrch].arg2, "$all") == 0 ||
                    strcmp(MODL->brch[jbrch].arg2, "$ALL") == 0   ) {

                    /* use the same scope as the parent */
                    MODL->scope[MODL->level] = MODL->scope[MODL->level-1];
                    break;

                } else if (strcmp(MODL->brch[jbrch].arg2, "$in" ) == 0 ||
                           strcmp(MODL->brch[jbrch].arg2, "$IN" ) == 0 ||
                           strcmp(MODL->brch[jbrch].arg2, "$out") == 0 ||
                           strcmp(MODL->brch[jbrch].arg2, "$OUT") == 0   ) {

                    /* get default value */
                    status = str2val(MODL->brch[jbrch].arg3, MODL, &value, &dot, str);
                    CHECK_STATUS(str2val);

                    /* set default value (single value or string) */
                    if (STRLEN(str) == 0) {
                        status = ocsmNewPmtr(MODL, &(MODL->brch[jbrch].arg1[1]), OCSM_INTERNAL, 1, 1);
                        CHECK_STATUS(ocsmNewPmtr);

                        status = ocsmSetValuD(MODL, MODL->npmtr, 1, 1, value);
                        CHECK_STATUS(ocsmSetValu);

                        status = ocsmSetVelD(MODL, MODL->npmtr, 1, 1, dot);
                        CHECK_STATUS(ocsmSetVelD);
                    } else {
                        status = ocsmNewPmtr(MODL, &(MODL->brch[jbrch].arg1[1]), OCSM_INTERNAL, 1, 1);
                        CHECK_STATUS(ocsmNewPmtr);

                        status = ocsmSetValu(MODL, MODL->npmtr, 1, 1, MODL->brch[jbrch].arg3);
                        CHECK_STATUS(ocsmSetValu);
                    }
                } else if (strcmp(MODL->brch[jbrch].arg2, "$dim") == 0 ||
                           strcmp(MODL->brch[jbrch].arg2, "$DIM") == 0   ) {
                    status = str2val(MODL->brch[jbrch].arg3, MODL, &value, &dot, str);
                    CHECK_STATUS(str2val);
                    if (STRLEN(str) > 0) {
                        status = OCSM_WRONG_PMTR_TYPE;
                        goto cleanup;
                    }

                    status = ocsmFindPmtr(MODL, &(MODL->brch[jbrch].arg1[1]), OCSM_INTERNAL, 1, NINT(value), &ipmtr);
                    CHECK_STATUS(ocsmNewPmtr);

                    for (irc = 1; irc <= NINT(value); irc++) {
                        status = ocsmSetValuD(MODL, ipmtr, 1, irc, 0);
                        CHECK_STATUS(ocsmSetValuD);
                    }
                }

                jbrch++;
            }

            SPRINT0(2, "Parameters after pre-processing INTERFACE statements:");
            if (outLevel >= 2) {
                status = printPmtrs(MODL, stdout);
                CHECK_STATUS(printPmtrs);
            }

            /* find the first udparg statement associated with this udprim */
            jbody = MODL->nbody;
            while (jbody > 0 && MODL->body[jbody].brtype == OCSM_UDPARG &&
                   strcmp(MODL->body[jbody].arg[1].str, args[1].str) == 0 ) {
                jbody--;
            }
            kbody = jbody + 1;

            /* loop through all arguments in all udparg statements */
            for (jbody = kbody; jbody <= MODL->nbody; jbody++) {
                for (iarg = 3; iarg < 10; iarg+=2) {

                    if (MODL->body[jbody].arg[iarg].nval < 0) break;

                    ipmtr = -1;
                    for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                        if (strcmp(MODL->pmtr[jpmtr].name, MODL->body[jbody].arg[iarg-1].str) == 0 &&
                            MODL->pmtr[jpmtr].scope == MODL->scope[MODL->level]                      ) {
                            ipmtr = jpmtr;
                            break;
                        }
                    }

                    if (ipmtr < 0) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "argument \"%s\" in UDPARG/UDPRIM not in INTERFACE", MODL->body[jbody].arg[iarg-1].str);
                        SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                    }

                    if        (MODL->body[jbody].arg[iarg].nval == 0 && MODL->pmtr[ipmtr].str != NULL) {

                        STRNCPY(temp, "$",                             MAX_EXPR_LEN  );
                        strncat(temp, MODL->body[jbody].arg[iarg].str, MAX_EXPR_LEN-1);

                        status = ocsmSetValu(MODL, ipmtr, 1, 1, temp);
                        CHECK_STATUS(ocsmSetValu);

                    } else if (MODL->body[jbody].arg[iarg].nval >= 1 && MODL->pmtr[ipmtr].str == NULL) {

                        /* make Parameter bigger if multi-valued */
                            if (MODL->body[jbody].arg[iarg].nval > 1) {
                                FREE(  MODL->pmtr[ipmtr].value);
                                FREE(  MODL->pmtr[ipmtr].dot);
                                FREE(  MODL->pmtr[ipmtr].lbnd);
                                FREE(  MODL->pmtr[ipmtr].ubnd);

                                MALLOC(MODL->pmtr[ipmtr].value, double, MODL->body[jbody].arg[iarg].nval);
                                MALLOC(MODL->pmtr[ipmtr].dot,   double, MODL->body[jbody].arg[iarg].nval);

                                MODL->pmtr[ipmtr].nrow = MODL->body[jbody].arg[iarg].nrow;
                                MODL->pmtr[ipmtr].ncol = MODL->body[jbody].arg[iarg].ncol;
                            }

                            for (ival = 0; ival < MODL->body[jbody].arg[iarg].nval; ival++) {
                                MODL->pmtr[ipmtr].value[ival] = MODL->body[jbody].arg[iarg].val[ival];
                                MODL->pmtr[ipmtr].dot[  ival] = MODL->body[jbody].arg[iarg].dot[ival];
                            }
                    } else if (MODL->body[jbody].arg[iarg].nval > 0) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "expecting string for \"%s\"", MODL->pmtr[ipmtr].name);
                        SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                    } else {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "expecting non-string for \"%s\"", MODL->pmtr[ipmtr].name);
                        SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                    }
                }
            }

            /* loop through all arguments in udprim statement */
            for (iarg = 3; iarg <= 10; iarg+=2) {
                if (args[iarg].nval < 0) break;

                ipmtr = -1;
                for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                    if (strcmp(MODL->pmtr[jpmtr].name, args[iarg-1].str) == 0 &&
                        MODL->pmtr[jpmtr].scope == MODL->scope[MODL->level]     ) {
                        ipmtr = jpmtr;
                        break;
                    }
                }

                if (ipmtr < 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "bad argument \"%s\"", args[iarg-1].str);
                    SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                }

                if (args[iarg].nval == 0 && MODL->pmtr[ipmtr].str != NULL) {
                    STRNCPY(temp, "$",            MAX_EXPR_LEN  );
                    strncat(temp, args[iarg].str, MAX_EXPR_LEN-1);

                    status = ocsmSetValu(MODL,  ipmtr, 1, 1, temp);
                    CHECK_STATUS(ocsmSetValu);

                } else if (args[iarg].nval >= 1 && MODL->pmtr[ipmtr].str == NULL) {

                    /* make Parameter bigger if multi-valued */
                    if (args[iarg].nval > 1) {
                        FREE(MODL->pmtr[ipmtr].value);
                        FREE(MODL->pmtr[ipmtr].dot  );
                        FREE(MODL->pmtr[ipmtr].lbnd );
                        FREE(MODL->pmtr[ipmtr].ubnd );

                        MALLOC(MODL->pmtr[ipmtr].value, double, args[iarg].nval);
                        MALLOC(MODL->pmtr[ipmtr].dot,   double, args[iarg].nval);

                        MODL->pmtr[ipmtr].nrow = args[iarg].nrow;
                        MODL->pmtr[ipmtr].ncol = args[iarg].ncol;
                    }

                    for (ival = 0; ival < args[iarg].nval; ival++) {
                        MODL->pmtr[ipmtr].value[ival] = args[iarg].val[ival];
                        MODL->pmtr[ipmtr].dot[  ival] = args[iarg].dot[ival];
                    }
                } else if (args[iarg].nval > 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "expecting string for \"%s\"", MODL->pmtr[ipmtr].name);
                    SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                } else {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "expecting non-string for \"%s\"", MODL->pmtr[ipmtr].name);
                    SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                }
            }

            SPRINT0(2, "Parameters after processing INTERFACE statements:");
            if (outLevel >= 2) {
                status = printPmtrs(MODL, stdout);
                CHECK_STATUS(printPmtrs);
            }

            /* update @-parameters (UDPRIM: udc) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

        /* bad primtype */
        } else {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "bad primtype");
            SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
        }

    /* execute" "restore $name index" */
    } else if (type == OCSM_RESTORE) {
        SPRINT3(1, "    executing [%4d] restore:    %s  %11.5f",
                ibrch, args[1].str, args[2].val[0]);

        /* find name/index in storage */
        istor = -1;

        for (jstor = 0; jstor < MODL->nstor; jstor++) {
            if (strcmp(args[1].str, MODL->stor[jstor].name) == 0 &&
                NINT(args[2].val[0]) ==  MODL->stor[jstor].index   ) {
                istor = jstor;
                break;
            }
        }

        /* if storage does not exist, return an error */
        if (istor < 0) {
            signalError(MODL, OCSM_NAME_NOT_FOUND,
                        "storage \"%s\" %d not found", args[1].str, NINT(args[2].val[0]));
            SET_STATUS(OCSM_NAME_NOT_FOUND, restore);
        }

        for (i = MODL->stor[istor].nbody-1; i >= 0; i--) {
            ibodyl = MODL->stor[istor].ibody[i];

            /* recycle old Body if not dirty */
            nbody_save = MODL->nbody;
            status = recycleBody(MODL, ibrch, type, args, MODL->body[ibodyl].hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                    if (*nstack < MAX_STACK_SIZE) {
                        stack[(*nstack)++] = ibodyl;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }
                (MODL->ngroup)--;       /* this will get incremented below */
                break;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_RESTORE, ibodyl, -1,
                             args, MODL->body[ibodyl].hasdots, MODL->body[ibodyl].botype, &ibody);
            CHECK_STATUS(newBody);

            status = EG_copyObject(MODL->stor[istor].ebody[i], NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                     1, &i, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);

            /* update @-parameters (RESTORE) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the Faces with the current Branch */
            if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY ||
                MODL->body[ibodyl].botype == OCSM_SOLID_BODY   ) {
                status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                for (iface = 1; iface <= nface; iface++) {
                    status = setFaceAttribute(MODL, ibody, iface, ibrch, MODL->stor[istor].ibody[i], npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                }

                EG_free(efaces);
            }

            /* finish the Body (RESTORE) */
            status = finishCopy(MODL, ibodyl, NULL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            if (*nstack < MAX_STACK_SIZE) {
                stack[(*nstack)++] = ibody;
            } else {
                status = OCSM_TOO_MANY_BODYS_ON_STACK;
                signalError(MODL, status,
                            "Too many Bodys on Stack");
                goto cleanup;
            }

            if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY ||
                MODL->body[ibodyl].botype == OCSM_SOLID_BODY   ) {
                status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                CHECK_STATUS(getBodyTolerance);
            } else {
                toler = 0;
            }

            SPRINT2(1, "                          Body   %4d restored (toler=%11.4e)",
                    ibody, toler);

            /* decrement Group so that others that get made in the same restore
               will have the same Group number */
            (MODL->ngroup)--;
        }

        /* increment the Group since we are finished with it */
        (MODL->ngroup)++;
    }

cleanup:
    FREE(ebodys );
    FREE(newTess);
    FREE(newIlist);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildSketch - implement OCSM_SKETCHs for ocsmBuild                 *
 *                                                                      *
 ************************************************************************
 */

static int
buildSketch(modl_T *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (bias-1) */
            varg_T args[],              /* (in)  array of arguments */
            int    *nstack,             /* (both) number of Bodys on stack */
            int    stack[],             /* (both) array  of Bodys on stack */
            int    npatn,               /* (in)   number of patterns */
            patn_T patn[],              /* (both) array  of patterns */
            sket_T *sket)               /* (both) current Sketch info */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       type, hasdots, i, ii, jj, n, nspln=0, nbezr=0, ibody, iopen, iswap;
    int       ipmtr, index1, index2, im1, ip1, ibeg, iend, ivec[4];
    double    xlast, ylast, zlast, areax, areay, areaz, area;
    double    xmin, xmax, ymin, ymax, zmin, zmax, pts[3*MAX_SKETCH_SIZE];
    double    dx1, dy1, dz1, ds1, dx2, dy2, dz2, ds2, dotp, swap, *rvec;
    double    matrix[12], *begcond=NULL, begslope[3], *endcond=NULL, endslope[3];

    int        iseg, jseg, nseg, sense[MAX_SKETCH_SIZE], header[4];
    int        iface, nface, nedge, periodic, wireonly;
    double     data[20], tdata[4], result[3], dx, dy, dz;
    double     scent, xcent, ycent, zcent;

    int        jpmtr, jndex, ivar;

    char       value[MAX_EXPR_LEN], prefix[MAX_EXPR_LEN], suffix[MAX_EXPR_LEN];

    double     range[4], eval[18], norm[3];
    ego        ebody, *efaces, ecurve, eflip, eloop, enew, etemp, exform;
    ego        Enodes[MAX_SKETCH_SIZE+1], Eedges[MAX_SKETCH_SIZE], Efaces[1];
    ego        enode, eedge;

    ROUTINE(buildSketch);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "skbeg x y z relative=0" */
    if (type == OCSM_SKBEG) {
        SPRINT5(1, "    executing [%4d] skbeg:      %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* store the base variables for the Sketch */
        sket->xbase = args[1].val[0];
        sket->ybase = args[2].val[0];
        sket->zbase = args[3].val[0];

        /* determine if coordinates in LINSEG, CIRARC, ARC, SPLINE, and
           BEZIER are relative to those given in the SKBEG statement */
        if (NINT(args[4].val[0]) != 1) {
            sket->irel = 0;
        } else {
            sket->irel = 1;
        }

        /* add a segment to the Sketch */
        sket->itype[sket->nseg] = OCSM_SKBEG;
        sket->ibrch[sket->nseg] = ibrch;
        if (sket->irel == 0) {
            sket->x[sket->nseg] = args[1].val[0];
            sket->y[sket->nseg] = args[2].val[0];
            sket->z[sket->nseg] = args[3].val[0];
        } else {
            sket->x[sket->nseg] = 0;
            sket->y[sket->nseg] = 0;
            sket->z[sket->nseg] = 0;
        }
        sket->nseg++;

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_SKBEG, -1, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "skvar $type valList" */
    } else if (type == OCSM_SKVAR) {
        SPRINT5(1, "    executing [%4d] skvar:   %s  %11.5f  %11.5f  %11.5f ...",
                ibrch, args[1].str, args[2].val[0], args[2].val[1], args[2].val[2]);

        /* check that Sketch variables are not defined already */
        if (sket->nvar > 0) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "Sketch varibles already exist");
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, skvar);
        }

        /* check that sketech variables are not defined yet */
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if        (strcmp(MODL->pmtr[ipmtr].name, "::x") == 0) {
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "\"::x\" already exists");
                SET_STATUS(OCSM_NAME_ALREADY_DEFINED, skvar);
            } else if (strcmp(MODL->pmtr[ipmtr].name, "::y") == 0) {
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "\"::y\" already exists");
                SET_STATUS(OCSM_NAME_ALREADY_DEFINED, skvar);
            } else if (strcmp(MODL->pmtr[ipmtr].name, "::z") == 0) {
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "\"::z\" already exists");
                SET_STATUS(OCSM_NAME_ALREADY_DEFINED, skvar);
            } else if (strcmp(MODL->pmtr[ipmtr].name, "::d") == 0) {
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "\"::d\" already exists");
                SET_STATUS(OCSM_NAME_ALREADY_DEFINED, skvar);
            }
        }

        /* make the new Sketch variables */
        sket->size = args[2].nval / 3;

        status = ocsmNewPmtr(MODL, "::x", OCSM_INTERNAL, 1, sket->size);
        CHECK_STATUS(ocsmNewPmtr);
        sket->ix = MODL->npmtr;

        status = ocsmNewPmtr(MODL, "::y", OCSM_INTERNAL, 1, sket->size);
        CHECK_STATUS(ocsmNewPmtr);
        sket->iy = MODL->npmtr;

        status = ocsmNewPmtr(MODL, "::z", OCSM_INTERNAL, 1, sket->size);
        CHECK_STATUS(ocsmNewPmtr);
        sket->iz = MODL->npmtr;

        status = ocsmNewPmtr(MODL, "::d", OCSM_INTERNAL, 1, sket->size);
        CHECK_STATUS(ocsmNewPmtr);
        sket->id = MODL->npmtr;

        /* set the values for the Sketch variables */
        if        (strcmp(args[1].str, "xy") == 0) {
            sket->type = 1;

            for (i = 0; i < sket->size; i++) {
                MODL->pmtr[sket->ix].value[i] = args[2].val[3*i  ];
                MODL->pmtr[sket->iy].value[i] = args[2].val[3*i+1];
                MODL->pmtr[sket->iz].value[i] = sket->zbase;
                MODL->pmtr[sket->id].value[i] = args[2].val[3*i+2];

                MODL->pmtr[sket->ix].dot[i] = 0;
                MODL->pmtr[sket->iy].dot[i] = 0;
                MODL->pmtr[sket->iz].dot[i] = 0;
                MODL->pmtr[sket->id].dot[i] = 0;
            }
        } else if (strcmp(args[1].str, "yz") == 0) {
            sket->type = 2;

            for (i = 0; i < sket->size; i++) {
                MODL->pmtr[sket->ix].value[i] = sket->xbase;
                MODL->pmtr[sket->iy].value[i] = args[2].val[3*i  ];
                MODL->pmtr[sket->iz].value[i] = args[2].val[3*i+1];
                MODL->pmtr[sket->id].value[i] = args[2].val[3*i+2];

                MODL->pmtr[sket->ix].dot[i] = 0;
                MODL->pmtr[sket->iy].dot[i] = 0;
                MODL->pmtr[sket->iz].dot[i] = 0;
                MODL->pmtr[sket->id].dot[i] = 0;
            }
        } else if (strcmp(args[1].str, "zx") == 0) {
            sket->type = 3;

            for (i = 0; i < sket->size; i++) {
                MODL->pmtr[sket->ix].value[i] = args[2].val[3*i+1];
                MODL->pmtr[sket->iy].value[i] = sket->ybase;
                MODL->pmtr[sket->iz].value[i] = args[2].val[3*i  ];
                MODL->pmtr[sket->id].value[i] = args[2].val[3*i+2];

                MODL->pmtr[sket->ix].dot[i] = 0;
                MODL->pmtr[sket->iy].dot[i] = 0;
                MODL->pmtr[sket->iz].dot[i] = 0;
                MODL->pmtr[sket->id].dot[i] = 0;
            }
        }

        /* make a list of the Sketch variables */
        for (i = 1; i <= sket->size; i++) {
            if (sket->type == 1 || sket->type == 3) {
                sket->ipmtr[sket->nvar] = sket->ix;
                sket->index[sket->nvar] = i-1;
                sket->nvar++;
            }

            if (sket->type == 2 || sket->type == 1) {
                sket->ipmtr[sket->nvar] = sket->iy;
                sket->index[sket->nvar] = i-1;
                sket->nvar++;
            }

            if (sket->type == 3 || sket->type == 2) {
                sket->ipmtr[sket->nvar] = sket->iz;
                sket->index[sket->nvar] = i-1;
                sket->nvar++;
            }

            if (fabs(MODL->pmtr[sket->id].value[i-1]) > EPS06) {
                sket->ipmtr[sket->nvar] = sket->id;
                sket->index[sket->nvar] = i-1;
                sket->nvar++;
            }
        }

        for (ivar = 0; ivar < sket->nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            SPRINT3(1, "    -> creating  %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

        /* set the "constant" Sketch variables */
        for (i = 0; i < sket->size; i++) {
            if        (sket->type == 1) {
                MODL->pmtr[sket->iz].value[i] = sket->zbase;
                MODL->pmtr[sket->iz].dot[  i] = 0;
            } else if (sket->type == 2) {
                MODL->pmtr[sket->ix].value[i] = sket->xbase;
                MODL->pmtr[sket->ix].dot[  i] = 0;
            } else {
                MODL->pmtr[sket->iy].value[i] = sket->ybase;
                MODL->pmtr[sket->iy].dot[  i] = 0;
            }
        }

    /* execute: "skcon $type index1 index2=-1 $value=0" */
    } else if (type == OCSM_SKCON) {
        SPRINT5(1, "    executing [%4d] skcon:   %s  %3d  %3d  %s",
                ibrch, args[1].str, NINT(args[2].val[0]), NINT(args[3].val[0]), args[4].str);

        index1 = NINT(args[2].val[0]);
        index2 = NINT(args[3].val[0]);

        /* copy args[4].str to value so that it can be modified if needed below */
        strcpy(value, args[4].str);

        /* (recursivly) modify value if it contains "::L[", "::I[", "::R[", or "::S[" */
        while (strstr(value, "::L[") != NULL || strstr(value, "::I[") != NULL ||
               strstr(value, "::R[") != NULL || strstr(value, "::S[") != NULL   ) {

            /* pull out the prefix */
            prefix[0] = '\0';
            ibeg      =   0 ;
            for (ii = 0; ii < STRLEN(value); ii++) {
                if (value[ii] == ':' && value[ii+1] == ':' && value[ii+3] == '[') {
                    if (value[ii+2] == 'L' || value[ii+2] == 'I' ||
                        value[ii+2] == 'R' || value[ii+2] == 'S'   ) {
                        if (ii > 0) {
                            STRNCPY(prefix, value, ii+1);
                        }
                        ibeg = strtol(&(value[ii+4]), NULL, 10);
                        break;
                    }
                }
            }

            /* check that argument was okay */
            if (ibeg < 1 || ibeg > sket->size) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "::%c[%d] is not defined", value[ii+2], ibeg);
                status = OCSM_ILLEGAL_VALUE;
                goto cleanup;
            } else if (ibeg < sket->size) {
                iend = ibeg + 1;
            } else {
                iend = 1;
            }

            /* pull out the suffix */
            suffix[0] = '\0';
            for (jj = ii+3; jj < STRLEN(value); jj++) {
                if (value[jj] == ']') {
                    strcpy(suffix, &(value[jj+1]));
                    break;
                }
            }

            /* create the replacement text */
            if        (value[ii+2] == 'L') {
                snprintf(value, MAX_EXPR_LEN, "%shypot(::y[%d]-::y[%d],::x[%d]-::x[%d])%s",
                         prefix, iend, ibeg, iend, ibeg, suffix);
            } else if (value[ii+2] == 'I') {
                snprintf(value, MAX_EXPR_LEN, "%satan2d(::y[%d]-::y[%d],::x[%d]-::x[%d])%s",
                         prefix, iend, ibeg, iend, ibeg, suffix);
            } else if (value[ii+2] == 'R') {
                snprintf(value, MAX_EXPR_LEN, "%sradius(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])%s",
                         prefix, ibeg, ibeg, iend, iend, iend, suffix);
            } else if (value[ii+2] == 'S') {
                snprintf(value, MAX_EXPR_LEN, "%ssweep(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])%s",
                         prefix, ibeg, ibeg, iend, iend, iend, suffix);
            }
        }

        /* constraints on XY plane */
        if (sket->type == 1) {
            if        (strcmp(args[1].str, "X") == 0 && index2 <= 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::x[%d]-(%s)",
                         index1, value);
            } else if (strcmp(args[1].str, "X") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "Xcent(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                         index1, index1, index2, index2, index2, value);
            } else if (strcmp(args[1].str, "Y") == 0 && index2 <= 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::y[%d]-(%s)",
                         index1, value);
            } else if (strcmp(args[1].str, "Y") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "Ycent(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                         index1, index1, index2, index2, index2, value);
            } else if (strcmp(args[1].str, "P") == 0) {
                im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "(abs(turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d]))-90)/57.3",
                         im1, im1, index1, index1, index1, ip1, ip1, ip1);
            } else if (strcmp(args[1].str, "T") == 0) {
                im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])/57.3",
                         im1, im1, index1, index1, index1, ip1, ip1, ip1);
            } else if (strcmp(args[1].str, "A") == 0) {
                im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "(turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s))/57.3",
                         im1, im1, index1, index1, index1, ip1, ip1, ip1, value);
            } else if (strcmp(args[1].str, "Z") == 0) {
                if        (index2 == -2) {
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::x[%d]-::x[%d]",
                             index1, index1+1);
                } else if (index2 == -3) {
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::y[%d]-::y[%d]",
                             index1-1, index1);
                }
            } else if (strcmp(args[1].str, "W") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::x[%d]-::x[%d]-(%s)",
                         index2, index1, value);
            } else if (strcmp(args[1].str, "D") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::y[%d]-::y[%d]-(%s)",
                         index2, index1, value);
            } else if (strcmp(args[1].str, "H") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::y[%d]-::y[%d]",
                         index1, index2);
            } else if (strcmp(args[1].str, "V") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::x[%d]-::x[%d]",
                         index1, index2);
            } else if (strcmp(args[1].str, "I") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "(atan2d(::y[%d]-::y[%d],::x[%d]-::x[%d])-(%s))/57.3",
                         index2, index1, index2, index1, value);
            } else if (strcmp(args[1].str, "L") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "hypot(::y[%d]-::y[%d],::x[%d]-::x[%d])-(%s)",
                         index1, index2, index1, index2, value);
            } else if (strcmp(args[1].str, "R") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "radius(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                         index1, index1, index2, index2, index2, value);
            } else if (strcmp(args[1].str, "S") == 0) {
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "smallang(sweep(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s))/57.3",
                         index1, index1, index2, index2, index2, value);
            }
        }

        /* make a note that the Sketch needs to be solved */
        sket->solved = 0;

    /* execute: "linseg x y z" */
    } else if (type == OCSM_LINSEG) {
        SPRINT4(1, "    executing [%4d] linseg:     %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* add a segment to the Sketch */
        sket->itype[sket->nseg] = OCSM_LINSEG;
        sket->ibrch[sket->nseg] = ibrch;
        sket->x[    sket->nseg] = args[1].val[0];
        sket->y[    sket->nseg] = args[2].val[0];
        sket->z[    sket->nseg] = args[3].val[0];
        sket->nseg++;

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_LINSEG, MODL->nbody, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "cirarc xon yon zon xend yend zend" */
    } else if (type == OCSM_CIRARC) {
        SPRINT7(1, "    executing [%4d] cirarc:     %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0                                   ) {
            hasdots = 1;

            SPRINT6(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0]);
        }

        /* check for the colinearity of the 3 points */
        dx1 = args[1].val[0] - sket->x[sket->nseg-1];
        dy1 = args[2].val[0] - sket->y[sket->nseg-1];
        dz1 = args[3].val[0] - sket->z[sket->nseg-1];
        ds1 = sqrt(dx1*dx1 + dy1*dy1 + dz1*dz1);

        dx2 = args[4].val[0] - args[1].val[0];
        dy2 = args[5].val[0] - args[2].val[0];
        dz2 = args[6].val[0] - args[3].val[0];
        ds2 = sqrt(dx2*dx2 + dy2*dy2 + dz2*dz2);

        dotp = (dx1*dx2 + dy1*dy2 + dz1*dz2) / ds1 / ds2;

        /* if points are co-linear, convert to a linseg */
        if (fabs(dotp) > 0.9999) {
            SPRINT0(1, "WARNING:: converting to linseg since points are colinear");
            (MODL->nwarn)++;

            sket->itype[sket->nseg] = OCSM_LINSEG;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[4].val[0];
            sket->y[    sket->nseg] = args[5].val[0];
            sket->z[    sket->nseg] = args[6].val[0];
            sket->nseg++;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status != 1) {
                args[1].val[0] = args[4].val[0];
                args[2].val[0] = args[5].val[0];
                args[3].val[0] = args[6].val[0];

                args[1].dot[0] = args[4].dot[0];
                args[2].dot[0] = args[5].dot[0];
                args[3].dot[0] = args[6].dot[0];

                status = newBody(MODL, ibrch, OCSM_LINSEG, MODL->nbody, -1,
                                 args, hasdots, OCSM_SKETCH, &ibody);
                CHECK_STATUS(newBody);
            }

        /* add the cirarc to the Sketch (as two segments) */
        } else {
            sket->itype[sket->nseg] = OCSM_CIRARC;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[1].val[0];
            sket->y[    sket->nseg] = args[2].val[0];
            sket->z[    sket->nseg] = args[3].val[0];
            sket->nseg++;

            sket->itype[sket->nseg] = OCSM_CIRARC;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[4].val[0];
            sket->y[    sket->nseg] = args[5].val[0];
            sket->z[    sket->nseg] = args[6].val[0];
            sket->nseg++;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status != 1) {
                status = newBody(MODL, ibrch, OCSM_CIRARC, MODL->nbody, -1,
                                 args, hasdots, OCSM_SKETCH, &ibody);
                CHECK_STATUS(newBody);

                /* dump a copy of this Body */
                status = dumpEgadsFile(MODL, ibody);
                CHECK_STATUS(dumpEgadsFile);
            }
        }

    /* execute: "arc xend yend zend dist $plane=xy" */
    } else if (type == OCSM_ARC) {
        SPRINT6(1, "    executing [%4d] arc:        %11.5f  %11.5f  %11.5f  %11.5f  %s",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].str);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0) {
            hasdots = 1;

            SPRINT4(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0]);
        }

        /* if points are co-linear, convert to a linseg */
        if (fabs(args[4].val[0]) < 0.0001) {
            SPRINT0(1, "WARNING:: converting to linseg since points are colinear");
            (MODL->nwarn)++;

            sket->itype[sket->nseg] = OCSM_LINSEG;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[1].val[0];
            sket->y[    sket->nseg] = args[2].val[0];
            sket->z[    sket->nseg] = args[3].val[0];
            sket->nseg++;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status != 1) {
                status = newBody(MODL, ibrch, OCSM_LINSEG, MODL->nbody, -1,
                                 args, hasdots, OCSM_SKETCH, &ibody);
                CHECK_STATUS(newBody);
            }

        /* add the arc to the Sketch (as two segments) */
        } else {
            xcent = (args[1].val[0] + sket->x[sket->nseg-1]) / 2;
            ycent = (args[2].val[0] + sket->y[sket->nseg-1]) / 2;
            zcent = (args[3].val[0] + sket->z[sket->nseg-1]) / 2;

            dx    = (args[1].val[0] - sket->x[sket->nseg-1]);
            dy    = (args[2].val[0] - sket->y[sket->nseg-1]);
            dz    = (args[3].val[0] - sket->z[sket->nseg-1]);

            if        (strcmp(args[5].str, "xy") == 0 ) {
                sket->itype[sket->nseg] = OCSM_CIRARC;
                sket->ibrch[sket->nseg] = ibrch;
                sket->x[    sket->nseg] = xcent + args[4].val[0] * dy / sqrt(dx*dx + dy*dy);
                sket->y[    sket->nseg] = ycent - args[4].val[0] * dx / sqrt(dx*dx + dy*dy);
                sket->z[    sket->nseg] = zcent;
                sket->nseg++;
            } else if (strcmp(args[5].str, "yz") == 0) {
                sket->itype[sket->nseg] = OCSM_CIRARC;
                sket->ibrch[sket->nseg] = ibrch;
                sket->y[    sket->nseg] = ycent + args[4].val[0] * dz / sqrt(dy*dy + dz*dz);
                sket->z[    sket->nseg] = zcent - args[4].val[0] * dy / sqrt(dy*dy + dz*dz);
                sket->x[    sket->nseg] = xcent;
                sket->nseg++;
            } else {
                sket->itype[sket->nseg] = OCSM_CIRARC;
                sket->ibrch[sket->nseg] = ibrch;
                sket->z[    sket->nseg] = zcent + args[4].val[0] * dx / sqrt(dz*dz + dx*dx);
                sket->x[    sket->nseg] = xcent - args[4].val[0] * dz / sqrt(dz*dz + dx*dx);
                sket->y[    sket->nseg] = ycent;
                sket->nseg++;
            }

            sket->itype[sket->nseg] = OCSM_CIRARC;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[1].val[0];
            sket->y[    sket->nseg] = args[2].val[0];
            sket->z[    sket->nseg] = args[3].val[0];
            sket->nseg++;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status != 1) {
                status = newBody(MODL, ibrch, OCSM_ARC, MODL->nbody, -1,
                                 args, hasdots, OCSM_SKETCH, &ibody);
                CHECK_STATUS(newBody);

                /* dump a copy of this Body */
                status = dumpEgadsFile(MODL, ibody);
                CHECK_STATUS(dumpEgadsFile);
            }
        }

    /* execute: "spline x y z" */
    } else if (type == OCSM_SPLINE) {
        SPRINT4(1, "    executing [%4d] spline:     %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* add the spline to the Sketch */
        sket->itype[sket->nseg] = OCSM_SPLINE;
        sket->ibrch[sket->nseg] = ibrch;
        sket->x[    sket->nseg] = args[1].val[0];
        sket->y[    sket->nseg] = args[2].val[0];
        sket->z[    sket->nseg] = args[3].val[0];
        sket->nseg++;

        /* warning for repeated points */
        if (sket->nseg > 1) {
            if (fabs(sket->x[sket->nseg-1]-sket->x[sket->nseg-2]) < EPS06 &&
                fabs(sket->y[sket->nseg-1]-sket->y[sket->nseg-2]) < EPS06 &&
                fabs(sket->z[sket->nseg-1]-sket->z[sket->nseg-2]) < EPS06   ) {
                SPRINT0(1, "WARNING:: repeated point in spline being removed");
                (MODL->nwarn)++;
                sket->nseg--;
            }
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_SPLINE, MODL->nbody, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "sslope dx dy dz" */
    } else if (type == OCSM_SSLOPE) {
        SPRINT4(1, "    executing [%4d] sslope:     %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        if (fabs(args[1].val[0]) < EPS06 &&
            fabs(args[2].val[0]) < EPS06 &&
            fabs(args[2].val[0]) < EPS06   ) {
            status = OCSM_ILLEGAL_VALUE;
            signalError(MODL, status,
                        "SSLOPE requires non-zero direction");
            goto cleanup;
        }

        /* add the spline to the Sketch */
        sket->itype[sket->nseg] = OCSM_SSLOPE;
        sket->ibrch[sket->nseg] = ibrch;
        sket->x[    sket->nseg] = args[1].val[0];
        sket->y[    sket->nseg] = args[2].val[0];
        sket->z[    sket->nseg] = args[3].val[0];
        sket->nseg++;

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_SSLOPE, MODL->nbody, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "bezier x y z" */
    } else if (type == OCSM_BEZIER) {
        SPRINT4(1, "    executing [%4d] bezier:     %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* check for a zero-length segment */
        if (fabs(sket->x[sket->nseg-1]-args[1].val[0]) < EPS06 &&
            fabs(sket->y[sket->nseg-1]-args[2].val[0]) < EPS06 &&
            fabs(sket->z[sket->nseg-1]-args[3].val[0]) < EPS06   ) {
            SPRINT0(1, "WARNING:: zero-length segment skipped");
            (MODL->nwarn)++;
        } else {

            /* add the bezier to the Sketch */
            sket->itype[sket->nseg] = OCSM_BEZIER;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[1].val[0];
            sket->y[    sket->nseg] = args[2].val[0];
            sket->z[    sket->nseg] = args[3].val[0];
            sket->nseg++;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_BEZIER, MODL->nbody, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "skend wireonly=0" */
    } else if (type == OCSM_SKEND) {
        SPRINT2(1, "    executing [%4d] skend:      %11.5f",
                ibrch, args[1].val[0]);

        wireonly = NINT(args[1].val[0]);

        /* add the skend to the Sketch */
        sket->itype[sket->nseg] = OCSM_SKEND;
        sket->ibrch[sket->nseg] = ibrch;
        sket->x[    sket->nseg] = sket->x[sket->nseg-1];   /* not used */
        sket->y[    sket->nseg] = sket->y[sket->nseg-1];
        sket->z[    sket->nseg] = sket->z[sket->nseg-1];
        sket->nseg++;

        /* if we have only one Sketch segment, then we are creating a OCSM_NODE_BODY */
        if ((sket->nseg) == 2) {
            /* close the Sketch */
            sket->type   = 0;
            sket->size   = 0;
            sket->solved = 1;
            sket->nseg   = 0;
            sket->nvar   = 0;
            sket->ncon   = 0;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_SKEND, -1, -1,
                             args, hasdots, OCSM_NODE_BODY, &ibody);
            CHECK_STATUS(newBody);

            if (sket->irel == 0) {
                pts[0] = sket->x[0];
                pts[1] = sket->y[0];
                pts[2] = sket->z[0];
            } else {
                pts[0] = sket->xbase;
                pts[1] = sket->ybase;
                pts[2] = sket->zbase;
            }

            /* OCSM_NODE_BODY is actually a degenerate WireBody */
            status = EG_makeTopology(MODL->context, NULL, NODE, 0, pts, 0, NULL, NULL, &enode);
            CHECK_STATUS(EG_makeTopology);

            tdata[0] = 0;
            tdata[1] = 1;
            sense[0] = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, EDGE, DEGENERATE, tdata, 1, &enode, sense, &eedge);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED, NULL, 1, &eedge, sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (SKEND: point) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            SPRINT1(1, "                          Body   %4d created", ibody);

        /* we have more than one Sketch segment */
        } else {

            /* for now, $$$$$$$$$$$$$$ */

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;

                /* remove ::x[], ::y[], ::z[], and ::d[] if they were generated by a skvar statement */
                if (sket->nvar > 0) {
                    status = delPmtrByName(MODL, "::d");
                    if (status != OCSM_NAME_NOT_FOUND) {
                        CHECK_STATUS(delPmtrByName);
                    }

                    status = delPmtrByName(MODL, "::z");
                    if (status != OCSM_NAME_NOT_FOUND) {
                        CHECK_STATUS(delPmtrByName);
                    }

                    status = delPmtrByName(MODL, "::y");
                    if (status != OCSM_NAME_NOT_FOUND) {
                        CHECK_STATUS(delPmtrByName);
                    }

                    status = delPmtrByName(MODL, "::x");
                    if (status != OCSM_NAME_NOT_FOUND) {
                        CHECK_STATUS(delPmtrByName);
                    }
                }

                /* close the Sketch */
                sket->type   = 0;
                sket->size   = 0;
                sket->solved = 1;
                sket->nseg   = 0;
                sket->nvar   = 0;
                sket->ncon   = 0;

                goto cleanup;
            }

            /* make sure SSLOPE statements comes either before or after
               a SPLINE statement, but not both */
            for (iseg = 1; iseg < sket->nseg-1; iseg++) {
                if (sket->itype[iseg] == OCSM_SSLOPE) {
                    if        (sket->itype[iseg-1] == OCSM_SPLINE &&
                               sket->itype[iseg+1] == OCSM_SPLINE   ) {
                        status = OCSM_ILLEGAL_STATEMENT;
                        signalError(MODL, status,
                                    "SSLOPE cannot be between SPLINE statements");
                        goto cleanup;
                    } else if (sket->itype[iseg-1] != OCSM_SPLINE &&
                               sket->itype[iseg+1] != OCSM_SPLINE   ) {
                        status = OCSM_ILLEGAL_STATEMENT;
                        signalError(MODL, status,
                                    "SSLOPE must precede or follow a SPLINE statement");
                        goto cleanup;
                    }
                }
            }

            /* find the extrema of the Sketch points */
            xmin = sket->x[0];
            xmax = sket->x[0];
            ymin = sket->y[0];
            ymax = sket->y[0];
            zmin = sket->z[0];
            zmax = sket->z[0];
            SPRINT5(2, "skpnt[%3d] %3d %10.5f %10.5f %10.5f",
                    0, sket->itype[0], sket->x[0], sket->y[0], sket->z[0]);

            for (iseg = 1; iseg < sket->nseg; iseg++) {
                if (sket->x[iseg] < xmin) xmin = sket->x[iseg];
                if (sket->x[iseg] > xmax) xmax = sket->x[iseg];
                if (sket->y[iseg] < ymin) ymin = sket->y[iseg];
                if (sket->y[iseg] > ymax) ymax = sket->y[iseg];
                if (sket->z[iseg] < zmin) zmin = sket->z[iseg];
                if (sket->z[iseg] > zmax) zmax = sket->z[iseg];

                SPRINT5(2, "skpnt[%3d] %3d %10.5f %10.5f %10.5f",
                        iseg, sket->itype[iseg], sket->x[iseg], sket->y[iseg], sket->z[iseg]);
            }

            /* determine if the Sketch is open or closed */
            if (fabs(sket->x[sket->nseg-2]-sket->x[0]) < EPS06 &&
                fabs(sket->y[sket->nseg-2]-sket->y[0]) < EPS06 &&
                fabs(sket->z[sket->nseg-2]-sket->z[0]) < EPS06   ) {
                iopen = 0;
            } else {
                iopen = 1;
            }
            SPRINT1(2, "iopen=%d", iopen);

            /* find the approximate area of the Sketch to determine
               if it has been generated counter-clockwise or clockwise */
            areax = 0;
            areay = 0;
            areaz = 0;
            for (iseg = 2; iseg < sket->nseg; iseg++) {
                areax += ( (sket->y[iseg-1]-sket->y[0]) * (sket->z[iseg  ]-sket->z[0])
                         - (sket->y[iseg  ]-sket->y[0]) * (sket->z[iseg-1]-sket->z[0]));
                areay += ( (sket->z[iseg-1]-sket->z[0]) * (sket->x[iseg  ]-sket->x[0])
                         - (sket->z[iseg  ]-sket->z[0]) * (sket->x[iseg-1]-sket->x[0]));
                areaz += ( (sket->x[iseg-1]-sket->x[0]) * (sket->y[iseg  ]-sket->y[0])
                         - (sket->x[iseg  ]-sket->x[0]) * (sket->y[iseg-1]-sket->y[0]));
            }

            area = areax / MAX(xmax-xmin, EPS06)
                 + areay / MAX(ymax-ymin, EPS06)
                 + areaz / MAX(zmax-zmin, EPS06);

            if (iopen == 0 && area < 0) {
                SPRINT0(1,"WARNING:: Sketch is defined clockwise.  flipping direction");
                (MODL->nwarn)++;

                jseg = sket->nseg - 2;
                for (iseg = 1; iseg < sket->nseg; iseg++) {
                    if (iseg >= jseg) break;

                    iswap             = sket->itype[iseg];
                    sket->itype[iseg] = sket->itype[jseg];
                    sket->itype[jseg] = iswap;

                    iswap             = sket->ibrch[iseg];
                    sket->ibrch[iseg] = sket->ibrch[jseg];
                    sket->ibrch[jseg] = iswap;

                    jseg--;
                }

                jseg = sket->nseg - 3;
                for (iseg = 1; iseg < sket->nseg; iseg++) {
                    if (iseg >= jseg) break;

                    swap          = sket->x[iseg];
                    sket->x[iseg] = sket->x[jseg];
                    sket->x[jseg] = swap;

                    swap          = sket->y[iseg];
                    sket->y[iseg] = sket->y[jseg];
                    sket->y[jseg] = swap;

                    swap          = sket->z[iseg];
                    sket->z[iseg] = sket->z[jseg];
                    sket->z[jseg] = swap;

                    jseg--;
                }
            }

            /* create the beginning node */
            nseg = 0;
            pts[0] = sket->x[0];
            pts[1] = sket->y[0];
            pts[2] = sket->z[0];
            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                     pts, 0, NULL, NULL, &(Enodes[0]));
            CHECK_STATUS(EG_makeTopology);

            /* save "last" point */
            xlast = sket->x[0];
            ylast = sket->y[0];
            zlast = sket->z[0];

            /* no points in spline or bezier so far */
            nspln =  0;
            nbezr =  0;

            begcond = NULL;
            endcond = NULL;

            /* add the lines, circular-arcs, splines, and beziers to the Sketch plane */
            for (iseg = 1; iseg < sket->nseg; iseg++) {

                /* if we were defining a spline but the new segment is not
                   a spline, generate the spline now */
                if (nspln > 0 && sket->itype[iseg] != OCSM_SPLINE) {
                    if (sket->itype[iseg] == OCSM_SSLOPE) {
                        endslope[0] = sket->x[iseg];
                        endslope[1] = sket->y[iseg];
                        endslope[2] = sket->z[iseg];
                        endcond     = endslope;
                    }

                    SPRINT1(2, "spline (w/%d points):", nspln);
                    for (n = 0; n < nspln; n++) {
                        SPRINT4(2, "%5d %11.5f %11.5f %11.5f",   n, pts[3*n], pts[3*n+1], pts[3*n+2]);
                    }

                    if (iseg < sket->nseg-1 || iopen == 1) {
                        data[0] = pts[3*nspln-3];
                        data[1] = pts[3*nspln-2];
                        data[2] = pts[3*nspln-1];
                        status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                                 data, 0, NULL, NULL, &(Enodes[nseg+1]));
                        CHECK_STATUS(EG_makeTopology);
                    } else {
                        Enodes[nseg+1] = Enodes[0];
                    }

                    header[0] = nspln;
                    header[1] = 0;

                    if (nspln > 2 || begcond != NULL || endcond != NULL)  {
                        status = EG_spline1dTan(header[0], begcond, pts, endcond, NULL, EPS06, ivec, &rvec);
                        CHECK_STATUS(EG_spline1dTan);

                        status = EG_makeGeometry(MODL->context, CURVE, BSPLINE, NULL, ivec, rvec, &ecurve);
                        CHECK_STATUS(EG_makeGeometry);

                        EG_free(rvec);

                        tdata[0] = 0;
                        tdata[1] = 1;
                    } else {
                        pts[3] -= pts[0];
                        pts[4] -= pts[1];
                        pts[5] -= pts[2];

                        status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, pts, &ecurve);
                        CHECK_STATUS(EG_makeGeometry);

                        tdata[0] = 0;
                        tdata[1] = sqrt(pts[3]*pts[3] + pts[4]*pts[4] + pts[5]-pts[5]);
                    }

                    #ifdef SHOW_SPLINES
                    {
                        int    io_kbd=5, io_scr=6, indgr=1+4+16+64;
                        int    i, nline=9, ilin[9], isym[9], nper[9];
                        float  xplot[9000], yplot[9000];
                        double uu, xyz3[9];

                        for (i = 0; i < nline; i++) {
                            ilin[i] = +i;
                            isym[i] = -i;
                            nper[i] = 1000;
                        }

                        for (i = 0; i < 1000; i++) {
                            uu = tdata[0] + (double)i/999 * (tdata[1] - tdata[0]);

                            EG_evaluate(ecurve, &uu, xyz3);

                            xplot[      i] = uu;   yplot[      i] = xyz3[0];   //   x
                            xplot[ 1000+i] = uu;   yplot[ 1000+i] = xyz3[1];   //   y
                            xplot[ 2000+i] = uu;   yplot[ 2000+i] = xyz3[2];   //   z
                            xplot[ 3000+i] = uu;   yplot[ 3000+i] = xyz3[3];   //  dx/du
                            xplot[ 4000+i] = uu;   yplot[ 4000+i] = xyz3[4];   //  dy/du
                            xplot[ 5000+i] = uu;   yplot[ 5000+i] = xyz3[5];   //  dz/du
                            xplot[ 6000+i] = uu;   yplot[ 6000+i] = xyz3[6];   // d2x/du2
                            xplot[ 7000+i] = uu;   yplot[ 7000+i] = xyz3[7];   // d2y/du2
                            xplot[ 8000+i] = uu;   yplot[ 8000+i] = xyz3[8];   // d2z/du2
                        }

                        grinit_(&io_kbd, &io_scr, "generation of spline in ocsmBuild",
                                           STRLEN("generation of spline in ocsmBuild"));
                        grline_(ilin, isym, &nline,                "~x~y~spline data",
                                &indgr, xplot, yplot, nper, STRLEN("~x~y~spline data"));
                    }
                    #endif

                    status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                             tdata, 2, &(Enodes[nseg]), NULL, &(Eedges[nseg]));
                    CHECK_STATUS(EG_makeTopology);

                    nseg++;

                    nspln   = 0;
                    begcond = NULL;
                    endcond = NULL;

                    xlast = sket->x[iseg-1];
                    ylast = sket->y[iseg-1];
                    zlast = sket->z[iseg-1];
                }

                /* if we were defining a bezier but the new segment is not
                   a bezier, generate the bezier now */
                if (nbezr > 0 && sket->itype[iseg] != OCSM_BEZIER) {
                    if (nbezr < 2) {
                        signalError(MODL, OCSM_TOO_FEW_SPLINE_POINTS,
                                    "BEZIER requires at least 2 Sketch points");
                        SET_STATUS(OCSM_TOO_FEW_SPLINE_POINTS, skend);
                    }

                    SPRINT1(2, "bezier (w/%d points):", nbezr);
                    for (n = 0; n < nbezr; n++) {
                        SPRINT4(2, "%5d %11.5f %11.5f %11.5f",   n, pts[3*n], pts[3*n+1], pts[3*n+2]);
                    }

                    if (iseg < sket->nseg-1 || iopen == 1) {
                        data[0] = pts[3*nbezr-3];
                        data[1] = pts[3*nbezr-2];
                        data[2] = pts[3*nbezr-1];
                        status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                                 data, 0, NULL, NULL, &(Enodes[nseg+1]));
                        CHECK_STATUS(EG_makeTopology);
                    } else {
                        Enodes[nseg+1] = Enodes[0];
                    }

                    header[0] = 0;
                    header[1] = nbezr - 1;
                    header[2] = nbezr;

                    /* make the BEZIER */
                    status = EG_makeGeometry(MODL->context, CURVE, BEZIER, NULL, header, pts, &ecurve);
                    CHECK_STATUS(EG_makeGeometry);

                    status = EG_getRange(ecurve, tdata, &periodic);
                    CHECK_STATUS(EG_getRange);

                    status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                             tdata, 2, &(Enodes[nseg]), NULL, &(Eedges[nseg]));
                    CHECK_STATUS(EG_makeTopology);

                    nseg++;

                    nbezr = 0;

                    xlast = sket->x[iseg-1];
                    ylast = sket->y[iseg-1];
                    zlast = sket->z[iseg-1];
                }

                /* if the new segment is a skend, stop now */
                if (sket->itype[iseg] == OCSM_SKEND) {
                    break;

                /* add a linseg */
                } else if (sket->itype[iseg] == OCSM_LINSEG) {
                    if (fabs(xlast-sket->x[iseg]) < EPS06 &&
                        fabs(ylast-sket->y[iseg]) < EPS06 &&
                        fabs(zlast-sket->z[iseg]) < EPS06   ) {
                        SPRINT0(2, "skipped (zero length linseg)");
                    } else {
                        SPRINT0(2, "linseg:");
                        SPRINT4(2, "%5d %11.5f %11.5f %11.5f", 0,    xlast,         ylast,         zlast        );
                        SPRINT4(2, "%5d %11.5f %11.5f %11.5f", iseg, sket->x[iseg], sket->y[iseg], sket->z[iseg]);

                        if (iseg < sket->nseg-2 || iopen == 1) {
                            pts[0] = sket->x[iseg];
                            pts[1] = sket->y[iseg];
                            pts[2] = sket->z[iseg];
                            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                                     pts, 0, NULL, NULL, &(Enodes[nseg+1]));
                            CHECK_STATUS(EG_makeTopology);
                        } else {
                            Enodes[nseg+1] = Enodes[0];
                        }

                        pts[0] = xlast;
                        pts[1] = ylast;
                        pts[2] = zlast;
                        pts[3] = sket->x[iseg] - xlast;
                        pts[4] = sket->y[iseg] - ylast;
                        pts[5] = sket->z[iseg] - zlast;
                        status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, pts, &ecurve);
                        CHECK_STATUS(EG_makeGeometry);

                        status = EG_invEvaluate(ecurve, pts, &(tdata[0]), result);
                        CHECK_STATUS(EG_invEvaluate);

                        pts[0] = sket->x[iseg];
                        pts[1] = sket->y[iseg];
                        pts[2] = sket->z[iseg];
                        status = EG_invEvaluate(ecurve, pts, &(tdata[1]), result);
                        CHECK_STATUS(EG_invEvaluate);

                        status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                                 tdata, 2, &(Enodes[nseg]), NULL, &(Eedges[nseg]));
                        CHECK_STATUS(EG_makeTopology);

                        nseg++;
                    }

                    xlast = sket->x[iseg];
                    ylast = sket->y[iseg];
                    zlast = sket->z[iseg];

                /* add a cirarc */
                } else if (sket->itype[iseg] == OCSM_CIRARC) {
                    SPRINT0(2, "cirarc:");
                    SPRINT4(2, "%5d %11.5f %11.5f %11.5f", 0,      xlast,           ylast,           zlast          );
                    SPRINT4(2, "%5d %11.5f %11.5f %11.5f", iseg,   sket->x[iseg  ], sket->y[iseg  ], sket->z[iseg  ]);
                    SPRINT4(2, "%5d %11.5f %11.5f %11.5f", iseg+1, sket->x[iseg+1], sket->y[iseg+1], sket->z[iseg+1]);

                    if (iseg < sket->nseg-3 || iopen == 1) {
                        pts[0] = sket->x[iseg+1];
                        pts[1] = sket->y[iseg+1];
                        pts[2] = sket->z[iseg+1];
                        status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                                 pts, 0, NULL, NULL, &(Enodes[nseg+1]));
                        CHECK_STATUS(EG_makeTopology);
                    } else {
                        Enodes[nseg+1] = Enodes[0];
                    }

                    if        (fabs(xlast-sket->x[iseg]) < EPS06 && fabs(xlast-sket->x[iseg+1]) < EPS06) {
                        scent = ((sket->y[iseg+1] - ylast        ) * (sket->y[iseg  ] - sket->y[iseg+1])
                                -(sket->z[iseg+1] - zlast        ) * (sket->z[iseg+1] - sket->z[iseg  ]))
                               /((zlast           - sket->z[iseg]) * (sket->y[iseg  ] - sket->y[iseg+1])
                               - (sket->y[iseg]   - ylast        ) * (sket->z[iseg+1] - sket->z[iseg  ]));
                        ycent = (ylast + sket->y[iseg] + scent * (zlast         - sket->z[iseg])) / 2;
                        zcent = (zlast + sket->z[iseg] + scent * (sket->y[iseg] - ylast        )) / 2;

                        data[0] = xlast;
                        data[1] = ycent;
                        data[2] = zcent;
                        data[3] = 0;
                        data[4] = ylast - ycent;
                        data[5] = zlast - zcent;
                        data[6] = 0;
                        data[7] = -data[5];
                        data[8] = +data[4];
                        data[9] = sqrt(SQR(ylast-ycent) + SQR(zlast-zcent));

                    } else if (fabs(ylast-sket->y[iseg]) < EPS06 && fabs(ylast-sket->y[iseg+1]) < EPS06) {
                        scent = ((sket->z[iseg+1] - zlast        ) * (sket->z[iseg  ] - sket->z[iseg+1])
                                -(sket->x[iseg+1] - xlast        ) * (sket->x[iseg+1] - sket->x[iseg  ]))
                               /((xlast           - sket->x[iseg]) * (sket->z[iseg  ] - sket->z[iseg+1])
                               - (sket->z[iseg]   - zlast        ) * (sket->x[iseg+1] - sket->x[iseg  ]));
                        zcent = (zlast + sket->z[iseg] + scent * (xlast         - sket->x[iseg])) / 2;
                        xcent = (xlast + sket->x[iseg] + scent * (sket->z[iseg] - zlast        )) / 2;

                        data[0] = xcent;
                        data[1] = ylast;
                        data[2] = zcent;
                        data[3] = xlast - xcent;
                        data[4] = 0;
                        data[5] = zlast - zcent;
                        data[6] = +data[5];
                        data[7] = 0;
                        data[8] = -data[3];
                        data[9] = sqrt(SQR(zlast-zcent) + SQR(xlast-xcent));

                    } else if (fabs(zlast-sket->z[iseg]) < EPS06 && fabs(zlast-sket->z[iseg+1]) < EPS06) {
                        scent = ((sket->x[iseg+1] - xlast        ) * (sket->x[iseg  ] - sket->x[iseg+1])
                                -(sket->y[iseg+1] - ylast        ) * (sket->y[iseg+1] - sket->y[iseg  ]))
                               /((ylast           - sket->y[iseg]) * (sket->x[iseg  ] - sket->x[iseg+1])
                               - (sket->x[iseg]   - xlast        ) * (sket->y[iseg+1] - sket->y[iseg  ]));
                        xcent = (xlast + sket->x[iseg] + scent * (ylast         - sket->y[iseg])) / 2;
                        ycent = (ylast + sket->y[iseg] + scent * (sket->x[iseg] - xlast        )) / 2;

                        data[0] = xcent;
                        data[1] = ycent;
                        data[2] = zlast;
                        data[3] = xlast - xcent;
                        data[4] = ylast - ycent;
                        data[5] = 0;
                        data[6] = -data[4];
                        data[7] = +data[3];
                        data[8] = 0;
                        data[9] = sqrt(SQR(xlast-xcent) + SQR(ylast-ycent));

                    } else {
                        signalError(MODL, OCSM_NON_COPLANAR_SKETCH_POINTS,
                                    "Sketch points must be coplanar");
                        SET_STATUS(OCSM_NON_COPLANAR_SKETCH_POINTS, skend);
                    }

                    if (scent > 0) {
                        status = EG_makeGeometry(MODL->context, CURVE, CIRCLE, NULL, NULL, data, &ecurve);
                        CHECK_STATUS(EG_makeGeometry);
                    } else {
                        status = EG_makeGeometry(MODL->context, CURVE, CIRCLE, NULL, NULL, data, &eflip);
                        CHECK_STATUS(EG_makeGeometry);

                        status = EG_flipObject(eflip, &ecurve);
                        CHECK_STATUS(EG_flipObject);
                    }

                    data[0] = xlast;
                    data[1] = ylast;
                    data[2] = zlast;
                    status = EG_invEvaluate(ecurve, data, &(tdata[0]), result);
                    CHECK_STATUS(EG_invEvaluate);

                    data[0] = sket->x[iseg+1];
                    data[1] = sket->y[iseg+1];
                    data[2] = sket->z[iseg+1];
                    status = EG_invEvaluate(ecurve, data, &(tdata[1]), result);
                    CHECK_STATUS(EG_invEvaluate);

                    while (tdata[1] < tdata[0]) {
                        tdata[1] += TWOPI;
                    }

                    status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                             tdata, 2, &(Enodes[nseg]), NULL, &(Eedges[nseg]));
                    CHECK_STATUS(EG_makeTopology);

                    nseg++;

                    iseg++;   /* this is because cirarc show up in pairs in iskpnt */

                    xlast = sket->x[iseg];
                    ylast = sket->y[iseg];
                    zlast = sket->z[iseg];

                /* initialize or add points to a spline (to be processed above in future
                   trip through this for loop) */
                } else if (sket->itype[iseg] == OCSM_SPLINE) {
                    if (nspln == 0) {
                        pts[0] = xlast;
                        pts[1] = ylast;
                        pts[2] = zlast;

                        nspln = 1;
                    }

                    pts[3*nspln  ] = sket->x[iseg];
                    pts[3*nspln+1] = sket->y[iseg];
                    pts[3*nspln+2] = sket->z[iseg];

                    nspln++;

                /* initialize or add points to a bezier (to be processed above in future
                   trip through this for loop) */
                } else if (sket->itype[iseg] == OCSM_BEZIER) {
                    if (nbezr == 0) {
                        pts[0] = xlast;
                        pts[1] = ylast;
                        pts[2] = zlast;

                        nbezr = 1;
                    }

                    pts[3*nbezr  ] = sket->x[iseg];
                    pts[3*nbezr+1] = sket->y[iseg];
                    pts[3*nbezr+2] = sket->z[iseg];

                    nbezr++;

                /* record the beginning slope */
                } else if (sket->itype[iseg] == OCSM_SSLOPE) {
                    begslope[0] = sket->x[iseg];
                    begslope[1] = sket->y[iseg];
                    begslope[2] = sket->z[iseg];
                    begcond     = begslope;
                }
            }

            /* close the Sketch */
            for (iseg = 0; iseg < nseg; iseg++) {
                sense[iseg] = SFORWARD;
            }

            if (wireonly == 1 || iopen == 1) {
                if (iopen == 1) {
                    status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                             NULL, nseg, Eedges, sense, &eloop);
                    CHECK_STATUS(EG_makeTopology);
                } else {
                    status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED,
                                             NULL, nseg, Eedges, sense, &eloop);
                    CHECK_STATUS(EG_makeTopology);
                }

                status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                         NULL, 1, &eloop, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);
            } else {
                status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED,
                                         NULL, nseg, Eedges, sense, &eloop);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeFace(eloop, SFORWARD, NULL, Efaces);
                if (status == EGADS_GEOMERR) {
                    /* check that Sketch is planar */
                    if (fabs(xmax-xmin) > EPS06 &&
                        fabs(ymax-ymin) > EPS06 &&
                        fabs(zmax-zmin) > EPS06   ) {
                        signalError(MODL, OCSM_NON_COPLANAR_SKETCH_POINTS,
                                    "Sketch points must be coplanar");
                        SET_STATUS(OCSM_NON_COPLANAR_SKETCH_POINTS, skend);
                    } else {
                        signalError(MODL, OCSM_SELF_INTERSECTING,
                                    "Self-intersection detected in Sketch");
                        SET_STATUS(OCSM_SELF_INTERSECTING, skend);
                    }
                }
                CHECK_STATUS(EG_makeFace);

                status = EG_getRange(Efaces[0], range, &periodic);
                CHECK_STATUS(EG_getRange);

                range[0] = (range[0] + range[1]) / 2;
                range[1] = (range[2] + range[3]) / 2;

                status = EG_evaluate(Efaces[0], range, eval);
                CHECK_STATUS(EG_evaluate);

                norm[0] = eval[4] * eval[8] - eval[5] * eval[7];
                norm[1] = eval[5] * eval[6] - eval[3] * eval[8];
                norm[2] = eval[3] * eval[7] - eval[4] * eval[6];

                if        (fabs(norm[0]) >= fabs(norm[1]) &&
                           fabs(norm[0]) >= fabs(norm[2])   ) {
                    if (norm[0] < 0) {
                        status = EG_flipObject(Efaces[0], &enew);
                        CHECK_STATUS(EG_flipObject);
                        Efaces[0] = enew;
                    }
                } else if (fabs(norm[1]) >= fabs(norm[2]) &&
                           fabs(norm[1]) >= fabs(norm[0])   ) {
                    if (norm[1] < 0) {
                        status = EG_flipObject(Efaces[0], &enew);
                        CHECK_STATUS(EG_flipObject);
                        Efaces[0] = enew;
                    }
                } else {
                    if (norm[2] < 0) {
                        status = EG_flipObject(Efaces[0], &enew);
                        CHECK_STATUS(EG_flipObject);
                        Efaces[0] = enew;
                    }
                }

                status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
                                         NULL, 1, Efaces, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);
            }

            #if   defined(SHOW_SPLINES)
            {
                #define NPER          251
                #define MAX_PLOT_PTS 9999

                int    nplot, nline, ilin[MAX_SKETCH_SIZE+1], isym[MAX_SKETCH_SIZE+1], nper[MAX_SKETCH_SIZE+1];
                int    io_kbd=5, io_scr=6, indgr=1+2+4+16+64;
                float  xplot[MAX_PLOT_PTS], yplot[MAX_PLOT_PTS];
                char   pltitl[30], title[] = "Spline  (skbeg=^, linseg=+, cirarc=o, spline=x)";

                int    j, periodic, oclass, mtype, nchild, *senses;
                double trange[4], tt;
                ego    eref, *ebodys;

                if        (xmin == xmax) {
                    snprintf(pltitl, 30, "~y~z~Sketch at x=%10.5f", xmin);
                } else if (ymin == ymax) {
                    snprintf(pltitl, 30, "~z~x~Sketch at y=%10.5f", ymin);
                } else {
                    snprintf(pltitl, 30, "~x~y~Sketch at z=%10.5f", zmin);
                }

                /* put Sketch points onto plot */
                nline = 0;
                nplot = 0;
                for (i = 0; i < sket->nseg; i++) {
                    ilin[nline] = 0;
                    nper[nline] = 1;

                    if        (sket->itype[i] == OCSM_SKBEG) {
                        isym[nline] = GR_TRIANGLE;
                    } else if (sket->itype[i] == OCSM_LINSEG) {
                        isym[nline] = GR_PLUS;
                    } else if (sket->itype[i] == OCSM_CIRARC) {
                        isym[nline] = GR_CIRCLE;
                    } else if (sket->itype[i] == OCSM_SPLINE) {
                        isym[nline] = GR_X;
                    } else if (sket->itype[i] == OCSM_BEZIER) {
                        isym[nline] = GR_X;
                    }
                    nline++;

                    if        (xmin == xmax) {
                        xplot[nplot] = sket->y[i];
                        yplot[nplot] = sket->z[i];
                        nplot++;
                    } else if (ymin == ymax) {
                        xplot[nplot] = sket->z[i];
                        yplot[nplot] = sket->x[i];
                        nplot++;
                    } else {
                        xplot[nplot] = sket->x[i];
                        yplot[nplot] = sket->y[i];
                        nplot++;
                    }
                }

                /* put Sketch evaluations onto plot */
                status = EG_getTopology(eloop, &eref, &oclass, &mtype,
                                        data, &nchild, &ebodys, &senses);
                CHECK_STATUS(EG_getTopology);

                if (nplot+nchild*NPER > MAX_PLOT_PTS) {
                    signalError(MODL, OCSM_INTERNAL_ERROR,
                                "nplot=%d, nchild=%d, NPER=%d, MAX_PLOT_PTS=%d", nplot, nchild, NPER, MAX_PLOT_PTS);
                    SET_STATUS(OCSM_INTERNAL_ERROR, ShowSketch);
                }

                for (j = 0; j < nchild; j++) {
                    status = EG_getRange(ebodys[j], trange, &periodic);
                    CHECK_STATUS(EG_getRange);

                    for (i = 0; i < NPER; i++) {
                        tt = trange[0] + (double)(i) / (double)(NPER-1) * (trange[1] - trange[0]);

                        status = EG_evaluate(ebodys[j], &tt, data);
                        CHECK_STATUS(EG_evaluate);

                        if        (xmin == xmax) {
                            xplot[nplot] = data[1];
                            yplot[nplot] = data[2];
                            nplot++;
                        } else if (ymin == ymax) {
                            xplot[nplot] = data[2];
                            yplot[nplot] = data[0];
                            nplot++;
                        } else {
                            xplot[nplot] = data[0];
                            yplot[nplot] = data[1];
                            nplot++;
                        }
                    }

                    ilin[nline] =  +1;
                    isym[nline] =  -1;
                    nper[nline] = NPER;
                    nline++;
                }

                /* plot */
                grinit_(&io_kbd, &io_scr, title, STRLEN(title));
                grline_(ilin, isym, &nline, pltitl, &indgr, xplot, yplot, nper, STRLEN(pltitl));
            }
            #endif

            /* remove ::x[], ::y[], ::z[], and ::d[] if they were generated by a skvar statement */
            if (sket->nvar > 0) {
                status = delPmtrByName(MODL, "::d");
                if (status != OCSM_NAME_NOT_FOUND) {
                    CHECK_STATUS(delPmtrByName);
                }

                status = delPmtrByName(MODL, "::z");
                if (status != OCSM_NAME_NOT_FOUND) {
                    CHECK_STATUS(delPmtrByName);
                }

                status = delPmtrByName(MODL, "::y");
                if (status != OCSM_NAME_NOT_FOUND) {
                    CHECK_STATUS(delPmtrByName);
                }

                status = delPmtrByName(MODL, "::x");
                if (status != OCSM_NAME_NOT_FOUND) {
                    CHECK_STATUS(delPmtrByName);
                }
            }

            /* close the Sketch */
            sket->type   = 0;
            sket->size   = 0;
            sket->solved = 1;
            sket->nseg   = 0;
            sket->nvar   = 0;
            sket->ncon   = 0;

            /* make a new WireBody */
            if (iopen == 1 || wireonly == 1) {
                status = newBody(MODL, ibrch, OCSM_SKEND, MODL->nbody, -1,
                                 args, hasdots, OCSM_WIRE_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else {
                status = newBody(MODL, ibrch, OCSM_SKEND, MODL->nbody, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);
            }

            /* if relative, translate body now */
            if (sket->irel == 1) {
                etemp = ebody;

                matrix[ 0] = 1; matrix[ 1] = 0; matrix[ 2] = 0; matrix[ 3] = sket->xbase;
                matrix[ 4] = 0; matrix[ 5] = 1; matrix[ 6] = 0; matrix[ 7] = sket->ybase;
                matrix[ 8] = 0; matrix[ 9] = 0; matrix[10] = 1; matrix[11] = sket->zbase;

                status = EG_makeTransform(MODL->context, matrix, &exform);
                CHECK_STATUS(EG_makeTransform);

                status = EG_copyObject(etemp, exform, &ebody);
                CHECK_STATUS(EG_copyObject);

                status = EG_deleteObject(etemp);
                CHECK_STATUS(EG_deleteObject);

                status = EG_deleteObject(exform);
                CHECK_STATUS(EG_deleteObject);
            }

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (SKEND: wire or face) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces (if any) with the current Branch */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            for (iface = 1; iface <= nface; iface++) {
                status = setFaceAttribute(MODL, ibody, iface, 0, 0, npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }

            EG_free(efaces);

            status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, NULL);
            CHECK_STATUS(EG_getBodyTopos);

            /* finish the Body (SKEND) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Sketch onto the stack */
            stack[(*nstack)++] = ibody;

            SPRINT2(1, "                          Sketch %4d created with %d Edges",
                    ibody, nedge);
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildSolver - implement OCSM_SOLVERs for ocsmBuild                 *
 *                                                                      *
 ************************************************************************
 */

static int
buildSolver(modl_T *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (bias-1) */
/*@unused@*/varg_T args[],              /* (in)  array of arguments */
            int    *nvar,               /* (both) number of Solver variables */
            int    solvars[],           /* (both) array  of Slover variables */
            int    *ncon,               /* (both) number of constraints */
            int    solcons[])           /* (both) array  of constraints */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jbrch, type, iter, niter, ipmtr, jpmtr, i, j, k, ivar, icon;
    double    f0max, save_value, value, dot, lambda, rms, rmslast, omega, f0last;
    double    *val_init=NULL, *neg_f0=NULL, *neg_f0old=NULL, *delx=NULL, *dfdx=NULL, *JtJ=NULL, *JtQ=NULL;
    char      name[MAX_EXPR_LEN], str[MAX_STRVAL_LEN], str2[MAX_STRVAL_LEN];

    ROUTINE(buildSolver);

    /* --------------------------------------------------------------- */

    type = MODL->brch[ibrch].type;

    /* execute: "solbeg $varList" */
    if (type == OCSM_SOLBEG) {
        SPRINT2(1, "    executing [%4d] solbeg:         %s",
                ibrch, MODL->brch[ibrch].arg1);

        /* initialize the number of solver constraints and variables */
        *ncon = 0;
        *nvar = 0;

        /* make a list of the solver variables by parsing arg1 */
        name[j=0] = '\0';
        for (i = 1; i < STRLEN(MODL->brch[ibrch].arg1); i++) {
            if (MODL->brch[ibrch].arg1[i] != ';') {
                name[j  ] = MODL->brch[ibrch].arg1[i];
                name[j+1] = '\0';
                j++;
            } else {
                ipmtr = 0;
                for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                    if (strcmp(MODL->pmtr[jpmtr].name, name) == 0                         &&
                               MODL->pmtr[jpmtr].scope       == MODL->scope[MODL->level]  &&
                               MODL->pmtr[jpmtr].type        == OCSM_INTERNAL               ) {
                        ipmtr = jpmtr;
                        break;
                    }
                }

                if (ipmtr == 0) {
                    SPRINT1(1, "WARNING:: name \"%s\" not an INTERNAL parameter", name);
                    (MODL->nwarn)++;
                    status = OCSM_NAME_NOT_FOUND;
                    goto cleanup;
                }

                solvars[(*nvar)++] = ipmtr;

                if (*nvar > MAX_SOLVER_SIZE) {
                    signalError(MODL, OCSM_TOO_MANY_SOLVER_VARS,
                                "too many Solver variables");
                    SET_STATUS(OCSM_TOO_MANY_SOLVER_VARS, solbeg);
                }

                name[j=0] = '\0';
            }
        }

    /* execute: "solcon expr" */
    } else if (type == OCSM_SOLCON) {
        SPRINT2(1, "    executing [%4d] solcon:         %s",
                ibrch, MODL->brch[ibrch].arg1);

        solcons[(*ncon)++] = ibrch;

        if (*ncon > MAX_SOLVER_SIZE) {
            signalError(MODL, OCSM_TOO_MANY_SOLVER_VARS,
                        "too many Solver variables");
            SET_STATUS(OCSM_TOO_MANY_SOLVER_VARS, solcon);
        }

    /* execute: "solend" */
    } else if (type == OCSM_SOLEND) {
        SPRINT1(1, "    executing [%4d] solend:",
                ibrch);

        for (ivar = 0; ivar < *nvar; ivar++) {
            jpmtr = solvars[ivar];
            SPRINT3(2, "        var[%2d] = %3d [%s]",
                    ivar, jpmtr, MODL->pmtr[jpmtr].name);
        }
        for (icon = 0; icon < *ncon; icon++) {
            jbrch = solcons[icon];
            SPRINT3(2, "        con[%2d] = %3d [%s]",
                    icon, jbrch, &(MODL->brch[jbrch].arg1[1]));
        }

        /* if the number of constraints does not match the number of
           degrees of freedom, return an error */
        if        (*ncon < *nvar) {
            signalError(MODL, OCSM_UNDERCONSTRAINED,
                        "only %d constraints but %d degrees of freedom", *ncon, *nvar);
            SET_STATUS(OCSM_UNDERCONSTRAINED, solend);
        } else if (*ncon > *nvar) {
            signalError(MODL, OCSM_OVERCONSTRAINED,
                        "there are %d constraints, yet only %d degrees of freedom", *ncon, *nvar);
            SET_STATUS(OCSM_OVERCONSTRAINED, solend);
        }

        /* if there were no constraints, simply return */
        if (*ncon == 0) {
            goto cleanup;
        }

        /* get needed arrays */
        MALLOC(val_init,  double, MAX_SOLVER_SIZE);
        MALLOC(neg_f0,    double, MAX_SOLVER_SIZE);
        MALLOC(neg_f0old, double, MAX_SOLVER_SIZE);
        MALLOC(delx,      double, MAX_SOLVER_SIZE);
        MALLOC(JtQ,       double, MAX_SOLVER_SIZE);
        MALLOC(dfdx,      double, MAX_SOLVER_SIZE*MAX_SOLVER_SIZE);
        MALLOC(JtJ,       double, MAX_SOLVER_SIZE*MAX_SOLVER_SIZE);

        /* store the initial values in case we need to revert because solver failed */
        for (ivar = 0; ivar < *nvar; ivar++) {
            jpmtr = solvars[ivar];
            val_init[ivar] = MODL->pmtr[jpmtr].value[0];

            delx[ivar] = 0;
        }

        /* first try Newton's method to change the solver variables until
           the constraints are satisfied */
        niter  = 100;
        omega  = 0.50;
        f0last = 0;
        for (iter = 0; iter < niter; iter++) {

            /* evaluate the constraints */
            f0max = 0;
            for (icon = 0; icon < *ncon; icon++) {
                jbrch  = solcons[icon];

                status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                CHECK_STATUS(str2val);

                if (STRLEN(str) > 0) {
                    status = str2val(str, MODL, &value, &dot, str2);
                    CHECK_STATUS(str2val);

                    if (STRLEN(str2) > 0) {
                        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                    "constraint cannot have a string value (%s)", str2);
                        SET_STATUS(OCSM_WRONG_PMTR_TYPE, solend);
                    }
                }

                neg_f0[icon] = -value;
                SPRINT2(2,"        f0[%4d] = %11.4e", jbrch, value);

                if (fabs(value) > f0max) {
                    f0max = fabs(value);
                }
            }
            SPRINT2(1, "    -> solving Sketch: iter = %3d,   f0max = %12.4e", iter, f0max);

            /* if we have converged, stop the Newton iterations */
            if (f0max < EPS06) {
                break;
            }

            /* f0max < f0last, we are converging, so increase omega */
            if (f0max < f0last) {
                omega = MIN(1.2*omega, 1);
            }
            f0last = f0max;

            /* build up the Jacobian matrix by perturbing the solver variables
               one at a time */
            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];

                save_value = MODL->pmtr[jpmtr].value[0];
                MODL->pmtr[jpmtr].value[0] += EPS06;

                for (icon = 0; icon < *ncon; icon++) {
                    jbrch = solcons[icon];
                    status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                    CHECK_STATUS(str2val);

                    if (STRLEN(str) > 0) {
                        status = str2val(str, MODL, &value, &dot, str2);
                        CHECK_STATUS(str2val);

                        if (STRLEN(str2) > 0) {
                            status = OCSM_WRONG_PMTR_TYPE;
                            goto cleanup;
                        }
                    }

                    dfdx[icon*(*ncon)+ivar] = (value + neg_f0[icon]) / EPS06;
                }

                MODL->pmtr[jpmtr].value[0] = save_value;
            }

            /* take the Newton step */
            status = matsol(dfdx, neg_f0, *ncon, delx);
            if (status < SUCCESS) {
                SPRINT1(1, "singular matrix detected for iter=%d", iter);
                break;
            }

            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];
                MODL->pmtr[jpmtr].value[0] += omega * delx[ivar];
            }
        }

        /* now that we have run out of iterations, check for convergence */
        if (f0max < EPS06) {
            status = EGADS_SUCCESS;
            goto cleanup;
        } else {
            SPRINT0(1, "no convergence, so trying Levenberg-Marquardt");

            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];
                MODL->pmtr[jpmtr].value[0] = val_init[ivar];
            }
        }

        /* if not converged, use Levenberg-Marquardt iteration to change
           the solver variables until the constraints are satisfied */
        niter   = 100;
        lambda  = 1;
        rmslast = 1e300;

        for (iter = 0; iter < niter; iter++) {

            /* evaluate the constraints */
            f0max = 0;
            rms   = 0;
            for (icon = 0; icon < *ncon; icon++) {
                jbrch  = solcons[icon];

                status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                CHECK_STATUS(str2val);

                if (STRLEN(str) > 0) {
                    status = str2val(str, MODL, &value, &dot, str2);
                    CHECK_STATUS(str2val);

                    if (STRLEN(str2) > 0) {
                        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                    "constraint cannot have a string value (%s)", str2);
                        SET_STATUS(OCSM_WRONG_PMTR_TYPE, solend);
                    }
                }

                if (iter != 0) {
                    neg_f0old[icon] = neg_f0[icon];
                }

                neg_f0[icon] = -value;
                SPRINT2(2,"        f0[%4d] = %11.4e", jbrch, value);

                if (iter == 0) {
                    neg_f0old[icon] = neg_f0[icon];
                }

                rms += value * value;

                if (fabs(value) > f0max) {
                    f0max = fabs(value);
                }
            }
            SPRINT2(1, "    -> solving   iter = %3d,   f0max = %12.4e", iter, f0max);

            /* if we satisfied all the constraints, stop the Levenberg-Marquardt iterations */
            if (f0max < EPS06) {
                break;
            }

            /* rms <= rmslast, we are converging, so decrease lambda and accept step */
            if (rms <= rmslast) {
                lambda = MAX(0.5*lambda, 1.0e-10);
                rmslast = rms;
                SPRINT1(2,"        converging: lambda = %11.4e", lambda);

            /* rms > rmslast, not converging, so increase lambda and revert to old step */
            } else {
                lambda = MIN(2.0*lambda, 1.0e+10);
                for (ivar = 0; ivar < *nvar; ivar++) {
                    jpmtr = solvars[ivar];
                    MODL->pmtr[jpmtr].value[0] -= delx[ivar];

                    for (icon = 0; icon < *ncon; icon++){
                        neg_f0[icon] = neg_f0old[icon];
                    }
                }
                SPRINT1(2,"        not converging: lambda = %11.4e", lambda);
            }

            /* build up the Jacobian matrix by perturbing the solver variables
               one at a time */
            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];

                save_value = MODL->pmtr[jpmtr].value[0];
                MODL->pmtr[jpmtr].value[0] += EPS06;

                for (icon = 0; icon < *ncon; icon++) {
                    jbrch = solcons[icon];
                    status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                    CHECK_STATUS(str2val);

                    if (STRLEN(str) > 0) {
                        status = str2val(str, MODL, &value, &dot, str2);
                        CHECK_STATUS(str2val);

                        if (STRLEN(str2) > 0) {
                            status = OCSM_WRONG_PMTR_TYPE;
                            goto cleanup;
                        }
                    }

                    dfdx[icon*(*ncon)+ivar] = (value + neg_f0[icon]) / EPS06;
                }
                MODL->pmtr[jpmtr].value[0] = save_value;
            }

            /* find Jtranspose * J */
            for (ivar = 0; ivar < *nvar; ivar++) {
                for (icon = 0; icon < *ncon; icon++) {
                    JtJ[icon*(*ncon)+ivar] = 0;
                    for (k = 0; k < *nvar; k++) {
                        JtJ[icon*(*ncon)+ivar] += dfdx[k*(*ncon)+ivar] * dfdx[k*(*ncon)+icon];
                    }
                    if (ivar == icon) {
                        JtJ[icon*(*ncon)+ivar] *= (1.0 + lambda);
                    }
                }
            }

            /* find Jtranspose * Q */
            for (ivar = 0; ivar < *nvar; ivar ++) {
                JtQ[ivar] = 0;
                for (icon = 0; icon < *ncon; icon++) {
                    JtQ[ivar] += dfdx[icon*(*ncon)+ivar] * neg_f0[icon];
                }
            }

            /* take the Levenberg-Marquardt step*/
            status = matsol(JtJ, JtQ, *ncon, delx);
            CHECK_STATUS(matsol);

            /* update the design variables */
            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];
                MODL->pmtr[jpmtr].value[0] += delx[ivar];
            }
        }

        /* now that we have run out of iterations, check for convergence */
        if (f0max > EPS06) {

            SPRINT0(1, "WARNING:: reverting to initial solution");

            /* did not converge, so revert to initial values */
            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];
                MODL->pmtr[jpmtr].value[0] = val_init[ivar];
            }

            signalError(MODL, OCSM_NOT_CONVERGED,
                        "maximum iterations exceeded in SOLEND");
            goto cleanup;
        }

        /* initialize variables for next solver */
        *nvar = 0;
        *ncon = 0;
    }

cleanup:
    FREE(val_init );
    FREE(neg_f0   );
    FREE(neg_f0old);
    FREE(delx     );
    FREE(JtQ      );
    FREE(dfdx     );
    FREE(JtJ      );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildTransform - implemet OCSM_TRANSFORMs for ocsmBuild            *
 *                                                                      *
 ************************************************************************
 */

static int
buildTransform(modl_T *modl,            /* (in)  pointer to MODL */
               int    ibrch,            /* (in)  Branch index (bias-1) */
               varg_T args[],           /* (in)  array of arguments */
               int    *nstack,          /* (both) number of Bodys on stack */
               int    stack[])          /* (both) array  of Bodys on stack */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        type, hasdots, ibody, jbody, ibodyl, nloop, nface, nedge;
    int        oclass, mtype, *senses, ishift, iswap, i, j, nbody_save;
    int        *iblist=NULL, ilist, nblist, igroup, atype, alen;
    CINT       *tempIlist;
    double     toler, matrix[12], data[4];
    double     cosx, cosy, cosz, sinx, siny, sinz, xcent, ycent, zcent, fact;
    double     dx, dy, dz, nx, ny, nz, dist;
    CDOUBLE    *tempRlist;
    CCHAR      *tempClist;

    ego        ebody, ebodyl, exform, *eloops, eloop, eref, eswap;
    ego        *eedges, eface, esurf, *efaces, eshell;

    ROUTINE(buildTransform);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "translate dx dy dz" */
    if (type == OCSM_TRANSLATE) {
        SPRINT4(1, "    executing [%4d] translate:  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* make the transformation */
        dx = args[1].val[0];
        dy = args[2].val[0];
        dz = args[3].val[0];

        matrix[ 0] = 1; matrix[ 1] = 0; matrix[ 2] = 0; matrix[ 3] = dx;
        matrix[ 4] = 0; matrix[ 5] = 1; matrix[ 6] = 0; matrix[ 7] = dy;
        matrix[ 8] = 0; matrix[ 9] = 0; matrix[10] = 1; matrix[11] = dz;

    /* execute: "rotatex angDeg yaxis zaxis" */
    } else if (type == OCSM_ROTATEX) {
        SPRINT4(1, "    executing [%4d] rotatex:    %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* make the transformation */
        cosx = cos(args[1].val[0] * PIo180);
        sinx = sin(args[1].val[0] * PIo180);
        dy   =     args[2].val[0];
        dz   =     args[3].val[0];

        matrix[ 0] = 1; matrix[ 1] = 0;    matrix[ 2] = 0;    matrix[ 3] = 0;
        matrix[ 4] = 0; matrix[ 5] = cosx; matrix[ 6] =-sinx; matrix[ 7] = dy - dy * cosx + dz * sinx;
        matrix[ 8] = 0; matrix[ 9] = sinx; matrix[10] = cosx; matrix[11] = dz - dy * sinx - dz * cosx;

    /* execute: "rotatey angDeg yaxis zaxis" */
    } else if (type == OCSM_ROTATEY) {
        SPRINT4(1, "    executing [%4d] rotatey:    %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* make the transformation */
        cosy = cos(args[1].val[0] * PIo180);
        siny = sin(args[1].val[0] * PIo180);
        dz   =     args[2].val[0];
        dx   =     args[3].val[0];

        matrix[ 0] = cosy; matrix[ 1] = 0; matrix[ 2] = siny; matrix[ 3] = dx - dz * siny - dx * cosy;
        matrix[ 4] = 0;    matrix[ 5] = 1; matrix[ 6] = 0;    matrix[ 7] = 0;
        matrix[ 8] =-siny; matrix[ 9] = 0; matrix[10] = cosy; matrix[11] = dz - dz * cosy + dx * siny;

    /* execute: "rotatez angDeg yaxis zaxis" */
    } else if (type == OCSM_ROTATEZ) {
        SPRINT4(1, "    executing [%4d] rotatez:    %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* make the transformation */
        cosz = cos(args[1].val[0] * PIo180);
        sinz = sin(args[1].val[0] * PIo180);
        dx   =     args[2].val[0];
        dy   =     args[3].val[0];

        matrix[ 0] = cosz; matrix[ 1] =-sinz; matrix[ 2] = 0; matrix[ 3] = dx - dx * cosz + dy * sinz;
        matrix[ 4] = sinz; matrix[ 5] = cosz; matrix[ 6] = 0; matrix[ 7] = dy - dx * sinz - dy * cosz;
        matrix[ 8] = 0;    matrix[ 9] = 0;    matrix[10] = 1; matrix[11] = 0;

    /* execute: "scale fact xcent=0 ycent=0 zcent=0" */
    } else if (type == OCSM_SCALE) {
        SPRINT5(1, "    executing [%4d] scale:      %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0) {
            hasdots = 1;

            SPRINT4(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0]);
        }

        if (args[1].val[0] <= 0) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "Scale factor must be positive");
            goto cleanup;
        }

        /* make the transformation */
        fact  = args[1].val[0];
        xcent = args[2].val[0];
        ycent = args[3].val[0];
        zcent = args[4].val[0];

        matrix[ 0] = fact; matrix[ 1] = 0;    matrix[ 2] = 0;    matrix[ 3] = xcent * (1 - fact);
        matrix[ 4] = 0;    matrix[ 5] = fact; matrix[ 6] = 0;    matrix[ 7] = ycent * (1 - fact);
        matrix[ 8] = 0;    matrix[ 9] = 0;    matrix[10] = fact; matrix[11] = zcent * (1 - fact);

    /* execute: "mirror nx ny nz dist=0" */
    } else if (type == OCSM_MIRROR) {
        SPRINT5(1, "    executing [%4d] mirror:     %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0) {
            hasdots = 1;

            SPRINT4(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0]);
        }

        /* make the transformation */
        nx   = args[1].val[0];
        ny   = args[2].val[0];
        nz   = args[3].val[0];
        dist = args[4].val[0];

        fact  = sqrt(nx*nx + ny*ny + nz*nz);

        if (fabs(fact) < EPS12) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "nx, ny, and nz cannot all be 0");
            goto cleanup;
        }

        dx    = nx / fact;
        dy    = ny / fact;
        dz    = nz / fact;

        matrix[ 0] = 1-2*dx*dx;    matrix[ 1] =  -2*dy*dx;    matrix[ 2] =  -2*dz*dx;    matrix[ 3] = 2*dist*dx;
        matrix[ 4] =  -2*dx*dy;    matrix[ 5] = 1-2*dy*dy;    matrix[ 6] =  -2*dz*dy;    matrix[ 7] = 2*dist*dy;
        matrix[ 8] =  -2*dx*dz;    matrix[ 9] =  -2*dy*dz;    matrix[10] = 1-2*dz*dz;    matrix[11] = 2*dist*dz;

    /* execute: "applycsys $csysName ibody=0" */
    } else if (type == OCSM_APPLYCSYS) {
        SPRINT3(1, "    executing [%4d] applycsys:  %s  %11.5f",
                ibrch, args[1].str, args[2].val[0]);

        ibody = NINT(args[2].val[0]);

        /* if ibody>0, look for named Csystem on that Body */
        if (ibody > 0) {
            if (ibody > MODL->nbody) {
                signalError(MODL, OCSM_BODY_NOT_FOUND,
                            "Body %d not found", ibody);
                goto cleanup;
            } else if (MODL->body[ibody].igroup == MODL->body[MODL->nbody].igroup) {
                signalError(MODL, OCSM_BODY_NOT_FOUND,
                            "Body %d cannot be in Group on top of stack", ibody);
                goto cleanup;
            } else {
                if (MODL->body[ibody].ebody == NULL) {
                    signalError(MODL, OCSM_BODY_NOT_FOUND,
                                "Body %d is a NULL Body", ibody);
                    goto cleanup;
                }

                status = EG_attributeRet(MODL->body[ibody].ebody, args[1].str,
                                         &atype, &alen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status != SUCCESS) {
                    signalError(MODL, OCSM_NAME_NOT_FOUND,
                                "Csystem \"%s\" not found in Body %d", args[1].str, ibody);
                    goto cleanup;
                }

                /* make the transformation */
                matrix[ 0] = tempRlist[alen+3];    matrix[ 1] = tempRlist[alen+6];    matrix[ 2] = tempRlist[alen+ 9];    matrix[ 3] = tempRlist[alen  ];
                matrix[ 4] = tempRlist[alen+4];    matrix[ 5] = tempRlist[alen+7];    matrix[ 6] = tempRlist[alen+10];    matrix[ 7] = tempRlist[alen+1];
                matrix[ 8] = tempRlist[alen+5];    matrix[ 9] = tempRlist[alen+8];    matrix[10] = tempRlist[alen+11];    matrix[11] = tempRlist[alen+2];
            }

        /* if ibody==-1, look for named Csystem on current Body */
        } else if (ibody == -1) {
            status = EG_attributeRet(MODL->body[MODL->nbody].ebody, args[1].str,
                                     &atype, &alen,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status != SUCCESS) {
                signalError(MODL, OCSM_NAME_NOT_FOUND,
                            "Csystem \"%s\" not found in Body %d", args[1].str, MODL->nbody);
                goto cleanup;
            }

            fact = tempRlist[alen+ 3] * (tempRlist[alen+ 7] * tempRlist[alen+11] - tempRlist[alen+10] * tempRlist[alen+ 8])
                 + tempRlist[alen+ 6] * (tempRlist[alen+10] * tempRlist[alen+ 5] - tempRlist[alen+ 4] * tempRlist[alen+11])
                 + tempRlist[alen+ 9] * (tempRlist[alen+ 4] * tempRlist[alen+ 8] - tempRlist[alen+ 7] * tempRlist[alen+ 5]);

            matrix[ 0] = (tempRlist[alen+ 7] * tempRlist[alen+11] - tempRlist[alen+10] * tempRlist[alen+ 8]) / fact;
            matrix[ 1] = (tempRlist[alen+ 9] * tempRlist[alen+ 8] - tempRlist[alen+ 6] * tempRlist[alen+11]) / fact;
            matrix[ 2] = (tempRlist[alen+ 6] * tempRlist[alen+10] - tempRlist[alen+ 9] * tempRlist[alen+ 7]) / fact;

            matrix[ 4] = (tempRlist[alen+10] * tempRlist[alen+ 5] - tempRlist[alen+ 4] * tempRlist[alen+11]) / fact;
            matrix[ 5] = (tempRlist[alen+ 3] * tempRlist[alen+11] - tempRlist[alen+ 9] * tempRlist[alen+ 5]) / fact;
            matrix[ 6] = (tempRlist[alen+ 9] * tempRlist[alen+ 4] - tempRlist[alen+ 3] * tempRlist[alen+10]) / fact;

            matrix[ 8] = (tempRlist[alen+ 4] * tempRlist[alen+ 8] - tempRlist[alen+ 7] * tempRlist[alen+ 5]) / fact;
            matrix[ 9] = (tempRlist[alen+ 6] * tempRlist[alen+ 5] - tempRlist[alen+ 3] * tempRlist[alen+ 8]) / fact;
            matrix[10] = (tempRlist[alen+ 3] * tempRlist[alen+ 7] - tempRlist[alen+ 6] * tempRlist[alen+ 4]) / fact;

            matrix[ 3] = -(matrix[ 0] * tempRlist[alen] + matrix[ 1] * tempRlist[alen+1] + matrix[ 2] * tempRlist[alen+2]);
            matrix[ 7] = -(matrix[ 4] * tempRlist[alen] + matrix[ 5] * tempRlist[alen+1] + matrix[ 6] * tempRlist[alen+2]);
            matrix[11] = -(matrix[ 8] * tempRlist[alen] + matrix[ 9] * tempRlist[alen+1] + matrix[10] * tempRlist[alen+2]);

        /* otherwise search backward from last Body, looking for named Csystem */
        } else {
            for (jbody = MODL->nbody-1; jbody >= 1; jbody--) {
                if (MODL->body[jbody].ebody == NULL) continue;
                if (MODL->body[jbody].igroup == MODL->body[MODL->nbody].igroup) continue;

                status = EG_attributeRet(MODL->body[jbody].ebody, args[1].str,
                                         &atype, &alen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == SUCCESS) {
                    ibody  = jbody;
                    SPRINT1(2, "found Csystem in Body %d", ibody);

                    /* make the transformation */
                    matrix[ 0] = tempRlist[alen+3];    matrix[ 1] = tempRlist[alen+6];    matrix[ 2] = tempRlist[alen+ 9];    matrix[ 3] = tempRlist[alen  ];
                    matrix[ 4] = tempRlist[alen+4];    matrix[ 5] = tempRlist[alen+7];    matrix[ 6] = tempRlist[alen+10];    matrix[ 7] = tempRlist[alen+1];
                    matrix[ 8] = tempRlist[alen+5];    matrix[ 9] = tempRlist[alen+8];    matrix[10] = tempRlist[alen+11];    matrix[11] = tempRlist[alen+2];

                    break;
                }
            }

            if (ibody <= 0) {
                signalError(MODL, OCSM_NAME_NOT_FOUND,
                            "Csystem \"%s\" not found in any Body not in current Group", args[1].str);
                goto cleanup;
            }
        }
    } else {

        /* make a unit transformation */
        matrix[ 0] = 1;    matrix[ 1] = 0;    matrix[ 2] = 0;    matrix[ 3] = 0;
        matrix[ 4] = 0;    matrix[ 5] = 1;    matrix[ 6] = 0;    matrix[ 7] = 0;
        matrix[ 8] = 0;    matrix[ 9] = 0;    matrix[10] = 1;    matrix[11] = 0;
    }

    /* process translate, rotatex, rotatey, rotatez, scale, mirror, or applycsys */
    if (type == OCSM_TRANSLATE ||
        type == OCSM_ROTATEX   || type == OCSM_ROTATEY || type == OCSM_ROTATEZ  ||
        type == OCSM_SCALE     || type == OCSM_MIRROR  || type == OCSM_APPLYCSYS  ) {

        /* make sure that there is a Body on the top of the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "transformation expects a Body on the stack");
            goto cleanup;
        } else if (stack[(*nstack)-1] <= 0) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "transformation expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[(*nstack)-1];
            igroup = MODL->body[ibodyl].igroup;
        }

        /* make a list to potentially keep track of the Bodys
           that should be transformed */
        MALLOC(iblist, int, *nstack);

        nblist = 0;
        while (*nstack > 0) {
            ibodyl = stack[--(*nstack)];
            if (ibodyl <= 0) {
                (*nstack)++;
                break;
            }

            if (MODL->body[ibodyl].igroup != igroup) {
                (*nstack)++;
                break;
            }

            iblist[nblist++] = ibodyl;
        }

        /* make the transformation ego */
        status = EG_makeTransform(MODL->context, matrix, &exform);
        CHECK_STATUS(EG_makeTransform);

        /* process each Body in iblist[] */
        for (ilist = nblist-1; ilist >= 0; ilist--) {
            ibodyl = iblist[ilist];

            /* recycle old Body if not dirty */
            nbody_save = MODL->nbody;
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                    if (*nstack < MAX_STACK_SIZE) {
                        stack[(*nstack)++] = ibodyl;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }
                (MODL->ngroup)--;       /* this will get incremented below */
                break;
            }

            /* create a Body */
            status = newBody(MODL, ibrch, type, ibodyl, -1,
                             args, hasdots, MODL->body[ibodyl].botype, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            /* transform the Body */
            status = EG_copyObject(ebodyl, exform, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                     1, &ilist, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);

            /* update @-parameters (TRANSFORM) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                    ibody, toler);

            /* decrement Group so that others that get made in the same transform
               will have the same Group number */
            (MODL->ngroup)--;

            /* if this is a APPLYCSYS with ibody==-1, then it is the only Body
               that should be transformed */
            if (type == OCSM_APPLYCSYS && NINT(args[2].val[0]) == -1) break;
        }

        /* increment the Group since we are finished with it */
        (MODL->ngroup)++;

        /* clean up */
        status = EG_deleteObject(exform);
        CHECK_STATUS(EG_deleteObject);

        FREE(iblist);

    /* execute: "reorder ishift iflip=0" */
    } else if (type == OCSM_REORDER) {
        SPRINT3(1, "    executing [%4d] reorder:    %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0]);

        /* pop a Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "REORDER expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* make sure that ibodyl is either a WireBody or SheetBody */
        if (MODL->body[ibodyl].botype != OCSM_WIRE_BODY &&
            MODL->body[ibodyl].botype != OCSM_SHEET_BODY  ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "REORDER needs a WireBody or SheetBody");
            goto cleanup;
        }

        ebodyl = MODL->body[ibodyl].ebody;

        /* make sure that the Body has a single Loop */
        status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);

        eloop = eloops[0];
        EG_free(eloops);

        if (nloop != 1) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "REORDER requires one Loop");
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_REORDER, ibodyl, -1,
                         args, hasdots, MODL->body[ibodyl].botype, &ibody);
        CHECK_STATUS(newBody);

        /* get the Edges and senses in the Loop */
        status = EG_getTopology(eloop, &eref, &oclass, &mtype, data,
                                &nedge, &eedges, &senses);
        CHECK_STATUS(EG_getTopology);

        /* shift the Edges in the Loop */
        if (mtype != CLOSED && NINT(args[1].val[0]) != 0) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "only closed Loops can be shifted");
            MODL->nbody--;
            goto cleanup;
        }

        if (args[1].val[0] > 0) {
            SPRINT1(2, "before positive reordering: %d", NINT(args[1].val[0]));
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }

            for (ishift = 0; ishift < NINT(args[1].val[0]); ishift++) {
                eswap = eedges[0];
                iswap = senses[0];
                for (i = 0; i < nedge-1; i++) {
                    eedges[i] = eedges[i+1];
                    senses[i] = senses[i+1];
                }
                eedges[nedge-1] = eswap;
                senses[nedge-1] = iswap;
            }

            SPRINT0(2, "after   positive reordering");
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }
        } else if (args[1].val[0] < 0) {
            SPRINT1(2, "before negative reordering: %d", NINT(args[1].val[0]));
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }

            for (ishift = 0; ishift < -NINT(args[1].val[0]); ishift++) {
                eswap = eedges[nedge-1];
                iswap = senses[nedge-1];
                for (i = nedge-1; i > 0; i--) {
                    eedges[i] = eedges[i-1];
                    senses[i] = senses[i-1];
                }
                eedges[0] = eswap;
                senses[0] = iswap;
            }

            SPRINT0(2, "before negative reordering");
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }
        }

        /* flip the Loop */
        if (NINT(args[2].val[0]) != 0) {
            SPRINT0(2, "before flipping");
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }

            for (i = 0, j = nedge-1; i < j; i++, j--) {
                eswap     = eedges[i];
                iswap     = senses[i];
                eedges[i] = eedges[j];
                senses[i] = senses[j];
                eedges[j] = eswap;
                senses[j] = iswap;
            }

            for (i = 0; i < nedge; i++) {
                senses[i] = -senses[i];
            }

            SPRINT0(2, "after  flipping");
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }
        }

        status = EG_makeTopology(MODL->context, NULL, LOOP, mtype,
                                 NULL, nedge, eedges, senses, &eloop);
        CHECK_STATUS(EG_makeTopology);

        /* make either WireBody or SheetBody */
        if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {
            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                     NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);
        } else {
            status = EG_getTopology(ebodyl, &esurf, &oclass, &mtype, data,
                                    &nface, &efaces, &senses);
            CHECK_STATUS(EG_getTopology);

            if (mtype == SHEETBODY) {
                eshell = efaces[0];

                status = EG_getTopology(eshell, &esurf, &oclass, &mtype, data,
                                        &nface, &efaces, &senses);
                CHECK_STATUS(EG_getTopology);
            }

            status = EG_getTopology(efaces[0], &esurf, &oclass, &mtype, data,
                                    &nloop, &eloops, &senses);
            CHECK_STATUS(EG_getTopology);

            if (NINT(args[2].val[0]) != 0) {
                mtype = -mtype;
            }

            status = EG_makeTopology(MODL->context, esurf, FACE, mtype,
                                     NULL, 1, &eloop, senses, &eface);
            CHECK_STATUS(EG_makeTopology);

            status = EG_attributeDup(efaces[0], eface);
            CHECK_STATUS(EG_attributeDup);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                     NULL, 1, &eface, NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);
        }

        MODL->body[ibody].ebody = ebody;

        /* finish the Body (REORDER) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT2(1, "                          Body   %4d created  (toler=%11.4e)",
                ibody, toler);
    }

cleanup:
    FREE(iblist);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   checkForFiniteDifferences - check if fnite differences are needed  *
 *                                                                      *
 ************************************************************************
 */

static int
checkForFiniteDifferences(modl_T *MODL, /* (in)  pointer to MODL */
                          int    ibody) /* (in)  Body index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       jbody, kbody, iarg, needfd;

    ROUTINE(checkForFiniteDifferences);

    /* --------------------------------------------------------------- */

    SPRINT1(2, "checkForFiniteDifferences(ibody=%d)", ibody);

    /* force finite differences */
    #ifdef FORCE_FINITE_DIFFS
        if (MODL->dtime <= 0) {
            SPRINT0(2, "    creating perturbation since force_finite_diffs selected at compile time");

            MODL->dtime = DTIME_NOM;
        }
    #endif

    /* set the default time step if any parent is a Branch type
       for which we do NOT know how to analytically compute
       the sensitivities */
    if (MODL->perturb == NULL && MODL->dtime == 0) {
        needfd = 0;
        for (jbody = 1; jbody <= ibody; jbody++) {
            if (MODL->body[jbody].brtype == OCSM_TORUS   ||
                MODL->body[jbody].brtype == OCSM_IMPORT  ||
                MODL->body[jbody].brtype == OCSM_LOFT    ||
                MODL->body[jbody].brtype == OCSM_REVOLVE ||
                MODL->body[jbody].brtype == OCSM_SWEEP   ||
                MODL->body[jbody].brtype == OCSM_FILLET  ||
                MODL->body[jbody].brtype == OCSM_CHAMFER ||
                MODL->body[jbody].brtype == OCSM_HOLLOW  ||
                MODL->body[jbody].brtype == OCSM_CONNECT ||
                MODL->body[jbody].brtype == OCSM_SKEND     ) {

                needfd++;
                break;
            } else if (MODL->body[jbody].brtype == OCSM_UDPARG ||
                       MODL->body[jbody].brtype == OCSM_UDPRIM   ) {
                kbody = jbody;
                while (MODL->body[kbody].brtype == OCSM_UDPARG) {
                    if (kbody < MODL->nbody) {
                        kbody++;
                    } else {
                        break;
                    }
                }
                if (MODL->body[kbody].brtype == OCSM_UDPRIM) {
                    for (iarg = 3; iarg < 10; iarg+=2) {
                        if (MODL->body[jbody].arg[iarg-1].str == NULL) continue;

                        status = udp_setVelocity(MODL->body[jbody].arg[1].str,
                                                 MODL->body[kbody].ebody,
                                                 MODL->body[jbody].arg[iarg-1].str,
                                                 MODL->body[jbody].arg[iarg  ].dot,
                                                 MODL->body[jbody].arg[iarg  ].nval);
                        if (status == EGADS_INDEXERR) {
                            needfd++;
                        }
                        status = EGADS_SUCCESS;
                    }
                }
            }
            if (needfd > 0) break;
        }

        if (needfd > 0) {
            SPRINT3(2, "    creating perturbation for ibody=%d (called because jbody=%d is a %s)",
                    ibody, jbody, ocsmGetText(MODL->body[jbody].brtype));

            MODL->dtime = DTIME_NOM;
        }
    }

    /* create a perturbation if dtime was set positive (by external call to
       ocsmSetDtime or directly above) and a current perturbation does not exist */
    if (MODL->perturb == NULL && MODL->dtime > 0) {
        SPRINT2(2, "    creating perturbation for ibody=%d (because dtime=%15.10f)",
                ibody, MODL->dtime);

        status = createPerturbation(MODL);
        CHECK_STATUS(createPerturbation);
    }


cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   colorizeEdge - set Edge color if Attribute is present              *
 *                                                                      *
 ************************************************************************
 */

static int
colorizeEdge(modl_T   *MODL,            /* (in)  pointer to MODL */
             int      ibody,            /* (in)  Body index (bias-1) */
             int      iedge)            /* (in)  Edge index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       atype, alen, ired, igreen, iblue;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;

    ROUTINE(colorizeEdge);

    /* --------------------------------------------------------------- */

    /* use color Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_color",
                             &atype, &alen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (atype == ATTRREAL && alen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].edge[iedge].gratt.color = 65536 * ired + 256 * igreen + iblue;
        } else if (atype == ATTRSTRING) {
            if (strcmp(tempClist, "red"    ) == 0) MODL->body[ibody].edge[iedge].gratt.color = 0x00ff0000;
            if (strcmp(tempClist, "green"  ) == 0) MODL->body[ibody].edge[iedge].gratt.color = 0x0000ff00;
            if (strcmp(tempClist, "blue"   ) == 0) MODL->body[ibody].edge[iedge].gratt.color = 0x000000ff;
            if (strcmp(tempClist, "yellow" ) == 0) MODL->body[ibody].edge[iedge].gratt.color = 0x00ffff00;
            if (strcmp(tempClist, "magenta") == 0) MODL->body[ibody].edge[iedge].gratt.color = 0x00ff00ff;
            if (strcmp(tempClist, "cyan"   ) == 0) MODL->body[ibody].edge[iedge].gratt.color = 0x0000ffff;
            if (strcmp(tempClist, "white"  ) == 0) MODL->body[ibody].edge[iedge].gratt.color = 0x00ffffff;
            if (strcmp(tempClist, "black"  ) == 0) MODL->body[ibody].edge[iedge].gratt.color = 0x00000000;
            }
    }

    /* use gcolor Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_gcolor",
                             &atype, &alen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (atype == ATTRREAL && alen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].edge[iedge].gratt.mcolor = 65536 * ired + 256 * igreen + iblue;
        } else if (atype == ATTRSTRING) {
            if (strcmp(tempClist, "red"    ) == 0) MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00ff0000;
            if (strcmp(tempClist, "green"  ) == 0) MODL->body[ibody].edge[iedge].gratt.mcolor = 0x0000ff00;
            if (strcmp(tempClist, "blue"   ) == 0) MODL->body[ibody].edge[iedge].gratt.mcolor = 0x000000ff;
            if (strcmp(tempClist, "yellow" ) == 0) MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00ffff00;
            if (strcmp(tempClist, "magenta") == 0) MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00ff00ff;
            if (strcmp(tempClist, "cyan"   ) == 0) MODL->body[ibody].edge[iedge].gratt.mcolor = 0x0000ffff;
            if (strcmp(tempClist, "white"  ) == 0) MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00ffffff;
            if (strcmp(tempClist, "black"  ) == 0) MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00000000;
            }
    }

    status = SUCCESS;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   colorizeFace - set Face color if Attribute is present              *
 *                                                                      *
 ************************************************************************
 */

static int
colorizeFace(modl_T   *MODL,            /* (in)  pointer to MODL */
             int      ibody,            /* (in)  Body index (bias-1) */
             int      iface)            /* (in)  Face index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       atype, alen, ired, igreen, iblue;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;

    ROUTINE(colorizeFace);

    /* --------------------------------------------------------------- */

    /* use color Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_color",
                             &atype, &alen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (atype == ATTRREAL && alen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].face[iface].gratt.color = 65536 * ired + 256 * igreen + iblue;
        } else if (atype == ATTRSTRING) {
            if (strcmp(tempClist, "red"    ) == 0) MODL->body[ibody].face[iface].gratt.color = 0x00ff0000;
            if (strcmp(tempClist, "green"  ) == 0) MODL->body[ibody].face[iface].gratt.color = 0x0000ff00;
            if (strcmp(tempClist, "blue"   ) == 0) MODL->body[ibody].face[iface].gratt.color = 0x000000ff;
            if (strcmp(tempClist, "yellow" ) == 0) MODL->body[ibody].face[iface].gratt.color = 0x00ffff00;
            if (strcmp(tempClist, "magenta") == 0) MODL->body[ibody].face[iface].gratt.color = 0x00ff00ff;
            if (strcmp(tempClist, "cyan"   ) == 0) MODL->body[ibody].face[iface].gratt.color = 0x0000ffff;
            if (strcmp(tempClist, "white"  ) == 0) MODL->body[ibody].face[iface].gratt.color = 0x00ffffff;
            if (strcmp(tempClist, "black"  ) == 0) MODL->body[ibody].face[iface].gratt.color = 0x00000000;
            }
    }

    /* use bcolor Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_bcolor",
                             &atype, &alen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (atype == ATTRREAL && alen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].face[iface].gratt.bcolor = 65536 * ired + 256 * igreen + iblue;
        } else if (atype == ATTRSTRING) {
            if (strcmp(tempClist, "red"    ) == 0) MODL->body[ibody].face[iface].gratt.bcolor = 0x00ff0000;
            if (strcmp(tempClist, "green"  ) == 0) MODL->body[ibody].face[iface].gratt.bcolor = 0x0000ff00;
            if (strcmp(tempClist, "blue"   ) == 0) MODL->body[ibody].face[iface].gratt.bcolor = 0x000000ff;
            if (strcmp(tempClist, "yellow" ) == 0) MODL->body[ibody].face[iface].gratt.bcolor = 0x00ffff00;
            if (strcmp(tempClist, "magenta") == 0) MODL->body[ibody].face[iface].gratt.bcolor = 0x00ff00ff;
            if (strcmp(tempClist, "cyan"   ) == 0) MODL->body[ibody].face[iface].gratt.bcolor = 0x0000ffff;
            if (strcmp(tempClist, "white"  ) == 0) MODL->body[ibody].face[iface].gratt.bcolor = 0x00ffffff;
            if (strcmp(tempClist, "black"  ) == 0) MODL->body[ibody].face[iface].gratt.bcolor = 0x00000000;
            }
    }

    /* use gcolor Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_gcolor",
                             &atype, &alen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (atype == ATTRREAL && alen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].face[iface].gratt.mcolor = 65536 * ired + 256 * igreen + iblue;
        } else if (atype == ATTRSTRING) {
            if (strcmp(tempClist, "red"    ) == 0) MODL->body[ibody].face[iface].gratt.mcolor = 0x00ff0000;
            if (strcmp(tempClist, "green"  ) == 0) MODL->body[ibody].face[iface].gratt.mcolor = 0x0000ff00;
            if (strcmp(tempClist, "blue"   ) == 0) MODL->body[ibody].face[iface].gratt.mcolor = 0x000000ff;
            if (strcmp(tempClist, "yellow" ) == 0) MODL->body[ibody].face[iface].gratt.mcolor = 0x00ffff00;
            if (strcmp(tempClist, "magenta") == 0) MODL->body[ibody].face[iface].gratt.mcolor = 0x00ff00ff;
            if (strcmp(tempClist, "cyan"   ) == 0) MODL->body[ibody].face[iface].gratt.mcolor = 0x0000ffff;
            if (strcmp(tempClist, "white"  ) == 0) MODL->body[ibody].face[iface].gratt.mcolor = 0x00ffffff;
            if (strcmp(tempClist, "black"  ) == 0) MODL->body[ibody].face[iface].gratt.mcolor = 0x00000000;
            }
    }

    status = SUCCESS;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   colorizeNode - set Node color if Attribute is present              *
 *                                                                      *
 ************************************************************************
 */

static int
colorizeNode(modl_T   *MODL,            /* (in)  pointer to MODL */
             int      ibody,            /* (in)  Body index (bias-1) */
             int      inode)            /* (in)  Node index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       atype, alen, ired, igreen, iblue;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;

    ROUTINE(colorizeNode);

    /* --------------------------------------------------------------- */

    /* use color Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].node[inode].enode, "_color",
                             &atype, &alen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (atype == ATTRREAL && alen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].node[inode].gratt.color = 65536 * ired + 256 * igreen + iblue;
        } else if (atype == ATTRSTRING) {
            if (strcmp(tempClist, "red"    ) == 0) MODL->body[ibody].node[inode].gratt.color = 0x00ff0000;
            if (strcmp(tempClist, "green"  ) == 0) MODL->body[ibody].node[inode].gratt.color = 0x0000ff00;
            if (strcmp(tempClist, "blue"   ) == 0) MODL->body[ibody].node[inode].gratt.color = 0x000000ff;
            if (strcmp(tempClist, "yellow" ) == 0) MODL->body[ibody].node[inode].gratt.color = 0x00ffff00;
            if (strcmp(tempClist, "magenta") == 0) MODL->body[ibody].node[inode].gratt.color = 0x00ff00ff;
            if (strcmp(tempClist, "cyan"   ) == 0) MODL->body[ibody].node[inode].gratt.color = 0x0000ffff;
            if (strcmp(tempClist, "white"  ) == 0) MODL->body[ibody].node[inode].gratt.color = 0x00ffffff;
            if (strcmp(tempClist, "black"  ) == 0) MODL->body[ibody].node[inode].gratt.color = 0x00000000;
            }
    }

    status = SUCCESS;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   createPerturbation - create perturbed body for finite differencing *
 *                                                                      *
 ************************************************************************
 */

static int
createPerturbation(modl_T *MODL)        /* (in)  pointer to base MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ibody, nerror, itime, ntime=20;
    int       ipmtr, irow, icol, irc, builtTo, nbody_ptrb;
    double    *unew=NULL, *vnew=NULL, *uv_new=NULL, *xyz_new=NULL;
    modl_T    *PTRB = NULL;
    ego       newBody;

    void      *modl_ptrb=NULL;

    ROUTINE(createPerturbation);

    /* --------------------------------------------------------------- */

    /* if we found an error in a previous attempt to create a perturbation,
       return immediately (note: set MODL->dtime=0 before call) */
    if (MODL->dtime == -2) {
        goto cleanup;
    }

    /* if perturb exists, we may be able to return immediately.  this is because the
       mapping is generated just in time in createTessVels */
    if (MODL->perturb != NULL) {
        goto cleanup;
    }

    /* try up to ntime increasingly smaller time steps */
    for (itime = 0; itime < ntime; itime++) {
        SPRINT1(1, "    MODL->dtime=%15.10f\n", MODL->dtime);
        nerror = 0;

        /* make a copy and set its driving parameters to "base + dtime * dot" */
        status = ocsmCopy(MODL, &modl_ptrb);
        CHECK_STATUS(ocsmCopy);

        PTRB = modl_ptrb;

        MODL->perturb  = PTRB;
        PTRB->basemodl = MODL;

        for (ipmtr = 1; ipmtr <= PTRB->npmtr; ipmtr++) {
            if (PTRB->pmtr[ipmtr].type == OCSM_EXTERNAL) {
                irc = 0;
                for (irow = 0; irow < PTRB->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 0; icol < PTRB->pmtr[ipmtr].ncol; icol++) {
                        PTRB->pmtr[ipmtr].value[irc] += MODL->dtime * PTRB->pmtr[ipmtr].dot[irc];
                        PTRB->pmtr[ipmtr].dot[  irc]  = 0;
                        irc++;
                    }
                }
            }
        }

        /* recheck (this is needed to make sure that the indentation is updated) */
        status = ocsmCheck(PTRB);
        CHECK_STATUS(ocsmCheck);

        /* rebuild the perturbed copy */
        nbody_ptrb = 0;
        SPRINT0(2, ">>>\n>>> building perturbation\n>>>");
        status = ocsmBuild(PTRB, 0, &builtTo, &nbody_ptrb, NULL);

        if (status != SUCCESS) {
            SPRINT2(2, "WARNING:: ocsmBuild() -> status=%d, buildTo=%d\n", status, builtTo);
            (MODL->nwarn)++;
            nerror++;
        }

        /* check that base and ptrb have same number of Bodys */
        if (nerror == 0) {
            if (MODL->nbody != PTRB->nbody) {
                SPRINT0(1, "WARNING:: Base and perturbed models have different nbody");
                SPRINT1(1, "          MODL->nbody = %d", MODL->nbody);
                SPRINT1(1, "          PTRB->nbody = %d", PTRB->nbody);
                (MODL->nwarn)++;
                nerror++;
            }
        }

        /* check that base and ptrb Bodys match topologically */
        if (nerror == 0) {
            for (ibody = 1; ibody <= MODL->nbody; ibody++) {
                if (MODL->body[ibody].onstack != 1) continue;
                if (MODL->body[ibody].botype  == OCSM_NODE_BODY) continue;

//$$$           /* for now, assume that WireBodys map without checking */
                if        (MODL->body[ibody].botype == OCSM_WIRE_BODY &&
                           PTRB->body[ibody].botype == OCSM_WIRE_BODY   ) {
                    status  = SUCCESS;
                    newBody = NULL;

                /* do actual check for SolidBodys */
                } else {
                    status = EG_mapBody(MODL->body[ibody].ebody, PTRB->body[ibody].ebody,
                                        "_faceID", &newBody);
                }

                /* if topologes match, we can proceed */
                if (status == SUCCESS) {
                    if (newBody != NULL) {
                        EG_deleteObject(PTRB->body[ibody].ebody);
                        PTRB->body[ibody].ebody = newBody;

                        status = finishBody(PTRB, ibody);
                        CHECK_STATUS(finishBody);
                    }

                    /* tag that the body has been mapped */
                    status = EG_attributeAdd(PTRB->body[ibody].ebody, "__mapBody__", ATTRINT,
                                             1, &ibody, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                /* otherwise we have an error at this dtime */
                } else {
                    SPRINT2(2, "WARNING:: EG_mapBody(ibody=%d) -> status=%d\n", ibody, status);
                    (MODL->nwarn)++;
                    nerror++;
                    break;
                }
            }
        }

        /* if there are no errors above, then we do not need to look at any more times */
        if (nerror == 0) {
            break;

        /* if there are more times to try, flip and decrease time step and try again */
        } else if (itime < ntime-1) {
            status = ocsmFree(PTRB);
            CHECK_STATUS(ocsmFree);

            MODL->perturb = NULL;
            MODL->dtime /= -2;

        /* otherwise we could not find a sufficiently small time step, so return an error  */
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "dtime=%15.10f is not sufficiently small", MODL->dtime);

            MODL->dtime = -2;      /* signify a problem */
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }
    }

cleanup:
    FREE(xyz_new);
    FREE(uv_new);
    FREE(unew);
    FREE(vnew);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   createTessVels - create tessellation velocities                    *
 *                                                                      *
 ************************************************************************
 */

int
createTessVels(modl_T *MODL,            /* (in)  pointer to base MODL */
               int    ibody)            /* (in)  Body index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface, ipnt, jpnt, kpnt, ntri, periodic;
    int       ibeg, iend, ileft, irite, npnt_edge, npnt_face, npnt_left, npnt_rite, nbnd;
    int       *ipleft=NULL, *iprite=NULL;
    int       nloop, npnt_egg, nbnd_egg, ntri_egg;
    int       npnt_modl, npnt_ptrb, ntri_modl, ntri_ptrb;
    CINT      *ptype, *pindx, *tris, *tric, *nlast1, *p_egg, *tris_egg;
    double    dedge[18], dedge2[18], dleft[18], drite[18], mat[16], rhs[4], sval[4], duv[4];
    double    xdotB, ydotB, zdotB, tdotB, xdotE, ydotE, zdotE, tdotE;
    double    xdotL, ydotL, zdotL,        xdotR, ydotR, zdotR, tdot, frac, t, trange[2];
    double    phi, umin, umax, vmin, vmax, srad2;
    double    *weights=NULL, *duv_new=NULL;
    CDOUBLE   *xyz_edge, *t_edge, *xyz_face, *uv_face, *uv_egg;
    CDOUBLE   *xyz_left, *uv_left, *xyz_rite, *uv_rite;
    CDOUBLE   *xyz_modl, *xyz_ptrb, *uv_modl, *uv_ptrb;
    void      *eggdata, *eggdata_new;
    modl_T    *PTRB;

    ROUTINE(createTessVels);

    /* --------------------------------------------------------------- */

    SPRINT1(2, "enter createTessVels(ibody=%d)", ibody);

    PTRB = MODL->perturb;

    /* if there is a BLEND with a C0, force finite differences */
    if (MODL->hasC0blend > 0) {
        SPRINT0(0, "WARNING:: BLEND with C0 forces finite differences");
        (MODL->nwarn)++;

        MODL->dtime = DTIME_NOM;

        if (MODL->perturb == NULL) {
            status = createPerturbation(MODL);
            CHECK_STATUS(createPerturbation);
        }
    }

    /* we need a tessellation */
    if (MODL->body[ibody].etess == NULL) {
        status = tessellate(MODL, ibody);
        CHECK_STATUS(tessellate);

        /* make sure the perturbed tessellation is updated if it existed */
        if (PTRB != NULL && PTRB->body[ibody].etess != NULL) {
            EG_deleteObject(PTRB->body[ibody].etess);
            PTRB->body[ibody].etess = NULL;
        }
    }

    /* we need a mapped tessellation */
    if (PTRB != NULL && PTRB->body[ibody].etess == NULL) {
        status = tessellate(PTRB, ibody);
        CHECK_STATUS(tessellate);
    }

    /* allocate storage for and initialize all velocity storage */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        MALLOC(MODL->body[ibody].node[inode].dxyz, double, 3);

        MODL->body[ibody].node[inode].dxyz[0] = 0;
        MODL->body[ibody].node[inode].dxyz[1] = 0;
        MODL->body[ibody].node[inode].dxyz[2] = 0;
    }

    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt_edge, &xyz_edge, &t_edge);
        CHECK_STATUS(EG_getTessEdge);

        MALLOC(MODL->body[ibody].edge[iedge].dxyz, double, 3*npnt_edge);
        MALLOC(MODL->body[ibody].edge[iedge].dt,   double,   npnt_edge);

        for (ipnt = 0; ipnt < npnt_edge; ipnt++) {
            MODL->body[ibody].edge[iedge].dxyz[3*ipnt  ] = 0;
            MODL->body[ibody].edge[iedge].dxyz[3*ipnt+1] = 0;
            MODL->body[ibody].edge[iedge].dxyz[3*ipnt+2] = 0;

            MODL->body[ibody].edge[iedge].dt[    ipnt  ] = 0;
        }
    }

    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        MALLOC(MODL->body[ibody].face[iface].dxyz, double, 3*npnt_face);
        MALLOC(MODL->body[ibody].face[iface].duv,  double, 2*npnt_face);

        for (ipnt = 0; ipnt < npnt_face; ipnt++) {
            MODL->body[ibody].face[iface].dxyz[3*ipnt  ] = 0;
            MODL->body[ibody].face[iface].dxyz[3*ipnt+1] = 0;
            MODL->body[ibody].face[iface].dxyz[3*ipnt+2] = 0;

            MODL->body[ibody].face[iface].duv[ 2*ipnt  ] = 0;
            MODL->body[ibody].face[iface].duv[ 2*ipnt+1] = 0;
        }
    }

    /* if the MODL has a perturbation, compute the tessellation velocities
       by finite differences */
    if (PTRB != NULL) {
        if        (MODL->body[ibody].nnode != PTRB->body[ibody].nnode) {
            SPRINT3(0, "ERROR:: .nnode mismatch for ibody=%d, MODL=%d, PTRB=%d",
                    ibody, MODL->body[ibody].nnode, PTRB->body[ibody].nnode);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        } else if (MODL->body[ibody].nedge != PTRB->body[ibody].nedge) {
            SPRINT3(0, "ERROR:: .nedge mismatch for ibody=%d, MODL=%d, PTRB=%d",
                    ibody, MODL->body[ibody].nedge, PTRB->body[ibody].nedge);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        } else if (MODL->body[ibody].nface != PTRB->body[ibody].nface) {
            SPRINT3(0, "ERROR:: .nface mismatch for ibody=%d, MODL=%d, PTRB=%d",
                    ibody, MODL->body[ibody].nface, PTRB->body[ibody].nface);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

        for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
            MODL->body[ibody].node[inode].dxyz[0] = (PTRB->body[ibody].node[inode].x
                                                    -MODL->body[ibody].node[inode].x) / MODL->dtime;
            MODL->body[ibody].node[inode].dxyz[1] = (PTRB->body[ibody].node[inode].y
                                                    -MODL->body[ibody].node[inode].y) / MODL->dtime;
            MODL->body[ibody].node[inode].dxyz[2] = (PTRB->body[ibody].node[inode].z
                                                    -MODL->body[ibody].node[inode].z) / MODL->dtime;
        }

        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            /* do not process if a degenerate Edge */
            if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) continue;

            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt_modl, &xyz_modl, &uv_modl);
            CHECK_STATUS(EG_getTessEdge);

            status = EG_getTessEdge(PTRB->body[ibody].etess, -iedge,
                                    &npnt_ptrb, &xyz_ptrb, &uv_ptrb);
            CHECK_STATUS(EG_getTessEdge);

            if (npnt_modl != npnt_ptrb) {
                SPRINT4(0, "ERROR:: npnt mismatch for Edge %d:%d, MODL=%d, PTRB=%d",
                        ibody, iedge, npnt_modl, npnt_ptrb);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            for (ipnt = 0; ipnt < npnt_modl; ipnt++) {
                MODL->body[ibody].edge[iedge].dt[    ipnt  ] = (uv_ptrb[   ipnt  ]
                                                               -uv_modl[   ipnt  ]) / MODL->dtime;
                MODL->body[ibody].edge[iedge].dxyz[3*ipnt  ] = (xyz_ptrb[3*ipnt  ]
                                                               -xyz_modl[3*ipnt  ]) / MODL->dtime;
                MODL->body[ibody].edge[iedge].dxyz[3*ipnt+1] = (xyz_ptrb[3*ipnt+1]
                                                               -xyz_modl[3*ipnt+1]) / MODL->dtime;
                MODL->body[ibody].edge[iedge].dxyz[3*ipnt+2] = (xyz_ptrb[3*ipnt+2]
                                                               -xyz_modl[3*ipnt+2]) / MODL->dtime;
            }
        }

        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt_modl, &xyz_modl, &uv_modl, &ptype, &pindx,
                                    &ntri_modl, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            status = EG_getTessFace(PTRB->body[ibody].etess, -iface,
                                    &npnt_ptrb, &xyz_ptrb, &uv_ptrb, &ptype, &pindx,
                                    &ntri_ptrb, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            if (npnt_modl != npnt_ptrb) {
                SPRINT4(0, "ERROR:: npnt mismatch for Face %d:%d, MODL=%d, PTRB=%d",
                        ibody, iface, npnt_modl, npnt_ptrb);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            for (ipnt = 0; ipnt < npnt_modl; ipnt++) {
                MODL->body[ibody].face[iface].duv[ 2*ipnt  ] = (uv_ptrb[ 2*ipnt  ]
                                                               -uv_modl[ 2*ipnt  ]) / MODL->dtime;
                MODL->body[ibody].face[iface].duv[ 2*ipnt+1] = (uv_ptrb[ 2*ipnt+1]
                                                               -uv_modl[ 2*ipnt+1]) / MODL->dtime;
                MODL->body[ibody].face[iface].dxyz[3*ipnt  ] = (xyz_ptrb[3*ipnt  ]
                                                               -xyz_modl[3*ipnt  ]) / MODL->dtime;
                MODL->body[ibody].face[iface].dxyz[3*ipnt+1] = (xyz_ptrb[3*ipnt+1]
                                                               -xyz_modl[3*ipnt+1]) / MODL->dtime;
                MODL->body[ibody].face[iface].dxyz[3*ipnt+2] = (xyz_ptrb[3*ipnt+2]
                                                               -xyz_modl[3*ipnt+2]) / MODL->dtime;
            }
        }

        goto cleanup;
    }

    /* set Node .dxyz from velocityOfNode */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        status = velocityOfNode(MODL, ibody, inode,
                                MODL->body[ibody].node[inode].dxyz);
        CHECK_STATUS(velocityOfNode);
    }

    /* set Face .dxyz from velocityOfFace */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        status = velocityOfFace(MODL, ibody, iface, npnt_face, NULL,
                                MODL->body[ibody].face[iface].dxyz);
        CHECK_STATUS(velocityOfFace);
    }

    /* visit each Edge and determine if there any trimming cases that must be resolved */
    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {

        /* do not process if a degenerate Edge */
        if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) continue;

        /* get Edge info */
        ileft = MODL->body[ibody].edge[iedge].ileft;
        irite = MODL->body[ibody].edge[iedge].irite;
        ibeg  = MODL->body[ibody].edge[iedge].ibeg;
        iend  = MODL->body[ibody].edge[iedge].iend;

        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt_edge, &xyz_edge, &t_edge);
        CHECK_STATUS(EG_getTessEdge);

        /* normal, manifold Edges */
        if (MODL->body[ibody].edge[iedge].nface == 2) {

            /* find the points in ileft and irite that correspond with the
               points along iedge.  ipleft[i] is point in ileft that corresponds to
               point i (bias-0) in iedge */
            MALLOC(ipleft, int, npnt_edge);
            MALLOC(iprite, int, npnt_edge);

            for (ipnt = 0; ipnt < npnt_edge; ipnt++) {
                ipleft[ipnt] = -1;
                iprite[ipnt] = -1;
            }

            status = EG_getTessFace(MODL->body[ibody].etess, ileft,
                                    &npnt_left, &xyz_left, &uv_left, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (ipnt = 0; ipnt < npnt_left; ipnt++) {
                if (       ptype[ipnt] > 0  && pindx[ipnt] == iedge) {
                    ipleft[ptype[ipnt]-1] = ipnt;
                } else if (ptype[ipnt] == 0 && pindx[ipnt] == ibeg) {
                    ipleft[0            ] = ipnt;
                } else if (ptype[ipnt] == 0 && pindx[ipnt] == iend) {
                    ipleft[npnt_edge  -1] = ipnt;
                }
            }

            status = EG_getTessFace(MODL->body[ibody].etess, irite,
                                    &npnt_rite, &xyz_rite, &uv_rite, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (ipnt = 0; ipnt < npnt_rite; ipnt++) {
                if (       ptype[ipnt] > 0  && pindx[ipnt] == iedge) {
                    iprite[ptype[ipnt]-1] = ipnt;
                } else if (ptype[ipnt] == 0 && pindx[ipnt] == ibeg) {
                    iprite[0            ] = ipnt;
                } else if (ptype[ipnt] == 0 && pindx[ipnt] == iend) {
                    iprite[npnt_edge  -1] = ipnt;
                }
            }

            /* find the .dxyz associated with both ends of this Edge */
            xdotB = MODL->body[ibody].node[ibeg].dxyz[0] - MODL->body[ibody].face[ileft].dxyz[3*ipleft[0]  ];
            ydotB = MODL->body[ibody].node[ibeg].dxyz[1] - MODL->body[ibody].face[ileft].dxyz[3*ipleft[0]+1];
            zdotB = MODL->body[ibody].node[ibeg].dxyz[2] - MODL->body[ibody].face[ileft].dxyz[3*ipleft[0]+2];
            xdotE = MODL->body[ibody].node[iend].dxyz[0] - MODL->body[ibody].face[irite].dxyz[3*iprite[0]  ];
            ydotE = MODL->body[ibody].node[iend].dxyz[1] - MODL->body[ibody].face[irite].dxyz[3*iprite[0]+1];
            zdotE = MODL->body[ibody].node[iend].dxyz[2] - MODL->body[ibody].face[irite].dxyz[3*iprite[0]+2];

            if (xdotB*xdotB+ydotB*ydotB+zdotB*zdotB > xdotE*xdotE+ydotE*ydotE+zdotE*zdotE) {
                iface = irite;
                jpnt  = iprite[0];
                kpnt  = iprite[npnt_edge-1];
            } else {
                iface = ileft;
                jpnt  = ipleft[0];
                kpnt  = ipleft[npnt_edge-1];
            }

            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                 &(t_edge[0]), dedge);
            CHECK_STATUS(EG_evaluate);

            if (fabs(dedge[3]) < EPS12 && fabs(dedge[4]) < EPS12 && fabs(dedge[5]) < EPS12) {
                status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, trange, &periodic);
                CHECK_STATUS(EG_getRange);

                t = 0.999 * trange[0] + 0.001 * trange[1];

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, &t, dedge);
                CHECK_STATUS(EG_evaluate);
            }

            xdotB = MODL->body[ibody].node[ibeg].dxyz[0] - MODL->body[ibody].face[iface].dxyz[3*jpnt  ];
            ydotB = MODL->body[ibody].node[ibeg].dxyz[1] - MODL->body[ibody].face[iface].dxyz[3*jpnt+1];
            zdotB = MODL->body[ibody].node[ibeg].dxyz[2] - MODL->body[ibody].face[iface].dxyz[3*jpnt+2];
            tdotB = (xdotB    * dedge[3] + ydotB    * dedge[4] + zdotB    * dedge[5])
                  / (dedge[3] * dedge[3] + dedge[4] * dedge[4] + dedge[5] * dedge[5]);

            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                 &(t_edge[npnt_edge-1]), dedge);
            CHECK_STATUS(EG_evaluate);

            if (fabs(dedge[3]) < EPS12 && fabs(dedge[4]) < EPS12 && fabs(dedge[5]) < EPS12) {
                status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, trange, &periodic);
                CHECK_STATUS(EG_getRange);

                t = 0.001 * trange[0] + 0.999 * trange[1];

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, &t, dedge);
                CHECK_STATUS(EG_evaluate);
            }

            xdotE = MODL->body[ibody].node[iend].dxyz[0] - MODL->body[ibody].face[iface].dxyz[3*kpnt  ];
            ydotE = MODL->body[ibody].node[iend].dxyz[1] - MODL->body[ibody].face[iface].dxyz[3*kpnt+1];
            zdotE = MODL->body[ibody].node[iend].dxyz[2] - MODL->body[ibody].face[iface].dxyz[3*kpnt+2];
            tdotE = (xdotE    * dedge[3] + ydotE    * dedge[4] + zdotE    * dedge[5])
                  / (dedge[3] * dedge[3] + dedge[4] * dedge[4] + dedge[5] * dedge[5]);

            /* process each point on this Edge */
            for (ipnt = 0; ipnt < npnt_edge; ipnt++) {
                frac = (t_edge[ipnt] - t_edge[0]) / (t_edge[npnt_edge-1] - t_edge[0]);
                tdot = (1-frac) * tdotB + frac * tdotE;

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                     &(t_edge[ipnt]), dedge);
                CHECK_STATUS(EG_evaluate);

                status = EG_getEdgeUVeval(MODL->body[ibody].face[iface].eface,
                                          MODL->body[ibody].edge[iedge].eedge,
                                          0, t_edge[ipnt], dedge2);
                CHECK_STATUS(EG_getEdgeUVeval);

                status = EG_evaluate(MODL->body[ibody].face[ileft].eface,
                                     &(uv_left[2*ipleft[ipnt]]), dleft);
                CHECK_STATUS(EG_evaluate);

                status = EG_evaluate(MODL->body[ibody].face[irite].eface,
                                     &(uv_rite[2*iprite[ipnt]]), drite);
                CHECK_STATUS(EG_evaluate);

                xdotL = MODL->body[ibody].face[ileft].dxyz[3*ipleft[ipnt]  ];
                ydotL = MODL->body[ibody].face[ileft].dxyz[3*ipleft[ipnt]+1];
                zdotL = MODL->body[ibody].face[ileft].dxyz[3*ipleft[ipnt]+2];

                xdotR = MODL->body[ibody].face[irite].dxyz[3*iprite[ipnt]  ];
                ydotR = MODL->body[ibody].face[irite].dxyz[3*iprite[ipnt]+1];
                zdotR = MODL->body[ibody].face[irite].dxyz[3*iprite[ipnt]+2];

                mat[ 0] = +dleft[3];
                mat[ 1] = +dleft[6];
                mat[ 2] = -drite[3];
                mat[ 3] = -drite[6];
                rhs[ 0] = xdotR - xdotL;

                mat[ 4] = +dleft[4];
                mat[ 5] = +dleft[7];
                mat[ 6] = -drite[4];
                mat[ 7] = -drite[7];
                rhs[ 1] = ydotR - ydotL;

                mat[ 8] = +dleft[5];
                mat[ 9] = +dleft[8];
                mat[10] = -drite[5];
                mat[11] = -drite[8];
                rhs[ 2] = zdotR - zdotL;

                if (iface == ileft) {
                    mat[12] = dedge2[2];
                    mat[13] = dedge2[3];
                    mat[14] = 0;
                    mat[15] = 0;
                } else {
                    mat[12] = 0;
                    mat[13] = 0;
                    mat[14] = dedge2[2];
                    mat[15] = dedge2[3];
                }
                rhs[ 3] = tdot * (dedge2[2] * dedge2[2] + dedge2[3] * dedge2[3]);

                status = solsvd(mat, rhs, 4, 4, sval, duv);
                CHECK_STATUS(solsvd);

                MODL->body[ibody].edge[iedge].dxyz[3*ipnt  ] = xdotL + mat[0] * duv[0] + mat[1] * duv[1];
                MODL->body[ibody].edge[iedge].dxyz[3*ipnt+1] = ydotL + mat[4] * duv[0] + mat[5] * duv[1];
                MODL->body[ibody].edge[iedge].dxyz[3*ipnt+2] = zdotL + mat[8] * duv[0] + mat[9] * duv[1];

                MODL->body[ibody].face[ileft].duv[2*ipleft[ipnt]  ] = duv[0];
                MODL->body[ibody].face[ileft].duv[2*ipleft[ipnt]+1] = duv[1];
                MODL->body[ibody].face[irite].duv[2*iprite[ipnt]  ] = duv[2];
                MODL->body[ibody].face[irite].duv[2*iprite[ipnt]+1] = duv[3];
            }

            FREE(ipleft);
            FREE(iprite);

        /* non-manifold Edge */
        } else {
            SPRINT1(1, "WARNING:: velocities on non-manifold Edge %d being set to zero", iedge);
            (MODL->nwarn)++;

            for (ipnt = 0; ipnt < npnt_edge; ipnt++) {
                MODL->body[ibody].edge[iedge].dxyz[3*ipnt  ] = 0;
                MODL->body[ibody].edge[iedge].dxyz[3*ipnt+1] = 0;
                MODL->body[ibody].edge[iedge].dxyz[3*ipnt+2] = 0;
            }
        }
    }

    /* visit each Face and find iface.dxyz */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getFaceTess);

        /* update duv at the interior points of the Face based upon duv
           at its Edges and Nodes (as computed above) */
#ifndef __clang_analyzer__
        eggdata = MODL->body[ibody].face[iface].eggdata;
#endif

        /* if this is not a perturbed MODL and the grid on the Face
           was made with an external grid generator, have the external
           grid generator compute the sensitivity directly */
        if (INTERP_VEL == 0 && MODL->basemodl == NULL && eggdata != NULL) {
            SPRINT2(2, "Computing sensitivities by calling morph for Face %d:%d",
                    ibody, iface);

            status = MODL->eggInfo(eggdata, &npnt_egg, &nbnd_egg, &uv_egg, &p_egg,
                                   &ntri_egg, &tris_egg);
            CHECK_STATUS(eggInfo);

            MALLOC(duv_new, double, 2*npnt_egg);

            /* load in the uv velocities at the Boundary points */
            for (ipnt = 0; ipnt < nbnd_egg; ipnt++) {
                duv_new[2*ipnt  ] = MODL->body[ibody].face[iface].duv[2*ipnt  ];
                duv_new[2*ipnt+1] = MODL->body[ibody].face[iface].duv[2*ipnt+1];
            }

            /* call the external tessellator to propagate velocities
               into the interior */
            status = MODL->eggMorph(eggdata, duv_new, &eggdata_new);
            CHECK_STATUS(eggMorph);

            status = MODL->eggFree(eggdata_new);
            CHECK_STATUS(eggFree);

            /* save the uv velocities at the interior points */
            for (ipnt = nbnd_egg; ipnt < npnt_egg; ipnt++) {
                MODL->body[ibody].face[iface].duv[2*ipnt  ] = duv_new[2*ipnt  ];
                MODL->body[ibody].face[iface].duv[2*ipnt+1] = duv_new[2*ipnt+1];
            }

            FREE(duv_new);

        /* otherwise interpolate the duv on the boundary points on each Face into
           the Face's interior points (using mean-value coordinates or radial-basis
           functions) */
        } else {
            if (INTERP_VEL != 3) {
                SPRINT2(2, "Interpolating sensitivities via MVC for Face %d:%d",
                        ibody, iface);

                status = EG_getTessLoops(MODL->body[ibody].etess, iface, &nloop, &nlast1);
                CHECK_STATUS(EG_getTessLoops);

                MALLOC(weights, double, nlast1[nloop-1]);

                status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                        &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                        &ntri, &tris, &tric);
                CHECK_STATUS(EG_getFaceTess);

                for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                    if (ptype[ipnt] >= 0 || pindx[ipnt] >= 0) continue;

                    status = mvcInterp(nloop, nlast1, uv_face, &(uv_face[2*ipnt]), weights);
                    CHECK_STATUS(mvcInterp);

                    MODL->body[ibody].face[iface].duv[2*ipnt  ] = 0;
                    MODL->body[ibody].face[iface].duv[2*ipnt+1] = 0;

                    for (jpnt = 0; jpnt < nlast1[nloop-1]; jpnt++) {
                        MODL->body[ibody].face[iface].duv[2*ipnt  ] += weights[jpnt] * MODL->body[ibody].face[iface].duv[2*jpnt  ];
                        MODL->body[ibody].face[iface].duv[2*ipnt+1] += weights[jpnt] * MODL->body[ibody].face[iface].duv[2*jpnt+1];
                    }
                }

                FREE(weights);
            } else {
                SPRINT2(2, "Interpolating sensitivities via RBF for Face %d:%d",
                        ibody, iface);

                /* find the number of boundary points and its bounding box */
                nbnd = 0;
                umin = uv_face[0];
                umax = uv_face[0];
                vmin = uv_face[1];
                vmax = uv_face[1];

                for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                    if (uv_face[2*ipnt  ] < umin) umin = uv_face[2*ipnt  ];
                    if (uv_face[2*ipnt  ] > umax) umax = uv_face[2*ipnt  ];
                    if (uv_face[2*ipnt+1] < vmin) vmin = uv_face[2*ipnt+1];
                    if (uv_face[2*ipnt+1] > vmax) vmax = uv_face[2*ipnt+1];

                    if (ptype[ipnt] >= 0) {
                        nbnd = ipnt + 1;
                    } else {
                        break;
                    }
                }

                /* arbitrarily set the support radius so that each covers
                   about half of the domain */
                srad2 = 0.25 * MAX(umax-umin, vmax-vmin) * MAX(umax-umin, vmax-vmin);

                MALLOC(weights, double, 2*nbnd);

                /* find the weights associated with each boundary point */
                status = rbfWeights(nbnd, srad2, uv_face, MODL->body[ibody].face[iface].duv, weights);
                CHECK_STATUS(rbfWeights);

                /* evaluate the RBF at each of the interior points */
                for (ipnt = nbnd; ipnt < npnt_face; ipnt++) {
                    MODL->body[ibody].face[iface].duv[2*ipnt  ] = 0;
                    MODL->body[ibody].face[iface].duv[2*ipnt+1] = 0;

                    for (jpnt = 0; jpnt < nbnd; jpnt++) {
                        phi = wendland(&uv_face[2*ipnt], &uv_face[2*jpnt], srad2);

                        MODL->body[ibody].face[iface].duv[2*ipnt  ] += weights[2*jpnt  ] * phi;
                        MODL->body[ibody].face[iface].duv[2*ipnt+1] += weights[2*jpnt+1] * phi;
                    }
                }

                FREE(weights);
            }
        }

        /* update iface.dxyz */
        for (ipnt = 0; ipnt < npnt_face; ipnt++) {

            /* for points associated with Nodes, just copy .dxyz from the Node */
            if (ptype[ipnt] == 0) {
                inode = pindx[ipnt];

                MODL->body[ibody].face[iface].dxyz[3*ipnt  ] = MODL->body[ibody].node[inode].dxyz[0];
                MODL->body[ibody].face[iface].dxyz[3*ipnt+1] = MODL->body[ibody].node[inode].dxyz[1];
                MODL->body[ibody].face[iface].dxyz[3*ipnt+2] = MODL->body[ibody].node[inode].dxyz[2];

            /* for points in the interior of the Face ... */
            } else {
                status = EG_evaluate(MODL->body[ibody].face[iface].eface, &(uv_face[2*ipnt]), dleft);
                CHECK_STATUS(EG_evaluate);

                /* velocity is sum of its nominal velocity and the velocity associated
                   with the .duv */
                MODL->body[ibody].face[iface].dxyz[3*ipnt  ]
                    += dleft[3] * MODL->body[ibody].face[iface].duv[2*ipnt  ]
                     + dleft[6] * MODL->body[ibody].face[iface].duv[2*ipnt+1];
                MODL->body[ibody].face[iface].dxyz[3*ipnt+1]
                    += dleft[4] * MODL->body[ibody].face[iface].duv[2*ipnt  ]
                     + dleft[7] * MODL->body[ibody].face[iface].duv[2*ipnt+1];
                MODL->body[ibody].face[iface].dxyz[3*ipnt+2]
                    += dleft[5] * MODL->body[ibody].face[iface].duv[2*ipnt  ]
                     + dleft[8] * MODL->body[ibody].face[iface].duv[2*ipnt+1];
            }
        }
    }

cleanup:
    FREE(ipleft);
    FREE(iprite);
    FREE(weights);
    FREE(duv_new);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   delPmtrByName - delete last Parameter with given name              *
 *                                                                      *
 ************************************************************************
 */

static int
delPmtrByName(modl_T *MODL,             /* (in)  pointer to MODL */
              char   name[])            /* (in)  Parameter name */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipmtr;

    ROUTINE(delPmtrByName);

    /* --------------------------------------------------------------- */

    /* start looking from the end of the list for the named Parameter */
    for (ipmtr = MODL->npmtr; ipmtr >= 1; ipmtr--) {
        if (strcmp(MODL->pmtr[ipmtr].name, name) == 0) {
            status = ocsmDelPmtr(MODL, ipmtr);
            goto cleanup;
        }
    }

    /* name not found */
    status = OCSM_NAME_NOT_FOUND;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   dumpEgadsFile - dump file if dumpEgads flag is set                 *
 *                                                                      *
 ************************************************************************
 */

static int
dumpEgadsFile(modl_T *MODL,
              int    ibody)
{
    int       status = SUCCESS;         /* (out) return status */

    int        sense, iarg, ipmtr, ibrch;
    double     data[6];
    char       dumpfile[MAX_EXPR_LEN], argname[MAX_NAME_LEN], attrname[MAX_NAME_LEN];
    ego        ecurve, enodes[2], eedge, eloop, ebody, etemp, emodel;

    ROUTINE(dumpEgadsFile);

    /* --------------------------------------------------------------- */

    if (MODL->dumpEgads == 0) {
        goto cleanup;

    /* do not dump if Body was just loaded from a file */
    } else if (ibody == MODL->bodyLoaded) {
        goto cleanup;
    }

    /* find filename */
    sprintf(dumpfile, "Body_%06d.egads", ibody);

    (void) remove(dumpfile);

    /* if a SketchBody, create a dummy Body so that an .egads file
       can be created */
    if (MODL->body[ibody].botype == OCSM_SKETCH) {
        data[0] = 0;   data[1] = 0;   data[2] = 0;
        data[3] = 1;   data[4] = 0;   data[5] = 0;

        status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, data, &ecurve);
        CHECK_STATUS(EG_makeGeometry);

        status = EG_makeTopology(MODL->context, NULL, NODE, 0, &(data[0]),
                                 0, NULL, NULL, &(enodes[0]));
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, NODE, 0, &(data[3]),
                                 0, NULL, NULL, &(enodes[1]));
        CHECK_STATUS(EG_makeTopology);

        data[0] = 0;   data[1] = 1;
        status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE, data,
                                 2, enodes, NULL, &eedge);
        CHECK_STATUS(EG_makeTopology);

        sense = SFORWARD;
        status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN, NULL,
                                 1, &eedge, &sense, &eloop);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL,
                                 1, &eloop, NULL, &ebody);
        CHECK_STATUS(EG_makeTopology);

        status = EG_copyObject(ebody, NULL, &etemp);
        CHECK_STATUS(EG_copyObject);

        status = EG_deleteObject(ebody);
        CHECK_STATUS(EG_deleteBody);
    } else {
        status = EG_copyObject(MODL->body[ibody].ebody, NULL, &etemp);
        CHECK_STATUS(EG_copyObject);
    }

    /* make attributed Model */
    ibrch = MODL->body[ibody].ibrch;
    status = EG_attributeAdd(etemp, "__filename__", ATTRSTRING,
                             1, NULL, NULL, MODL->brch[ibrch].filename);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__brtype__", ATTRINT,
                             1, &(MODL->body[ibody].brtype), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    for (iarg = 1; iarg <= 9; iarg++) {
        snprintf(argname, MAX_NAME_LEN, "__arg%d__", iarg);
        if        (MODL->body[ibody].arg[iarg].nval > 0) {
            status = EG_attributeAdd(etemp, argname, ATTRREAL,
                                     MODL->body[ibody].arg[iarg].nval,
                                     NULL, MODL->body[ibody].arg[iarg].val, NULL);
            CHECK_STATUS(EG_attributeAdd);
        } else if (MODL->body[ibody].arg[iarg].nval == 0) {
            status = EG_attributeAdd(etemp, argname, ATTRSTRING,
                                     MODL->body[ibody].arg[iarg].nval,
                                     NULL, NULL, MODL->body[ibody].arg[iarg].str);
                CHECK_STATUS(EG_attributeAdd);
        }
    }

    status = EG_attributeAdd(etemp, "__ibrch__", ATTRINT,
                             1, &(MODL->body[ibody].ibrch), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__ileft__", ATTRINT,
                             1, &(MODL->body[ibody].ileft), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__irite__", ATTRINT,
                             1, &(MODL->body[ibody].irite), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__igroup__", ATTRINT,
                             1, &(MODL->body[ibody].igroup), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__botype__", ATTRINT,
                             1, &(MODL->body[ibody].botype), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].name[0] == '@' &&
            MODL->pmtr[ipmtr].name[1] == '@'   ) {
            strcpy(attrname, "__");
            strcat(attrname, MODL->pmtr[ipmtr].name);
            strcat(attrname, "__");

            status = EG_attributeAdd(etemp, attrname, ATTRREAL,
                                     MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                     NULL, MODL->pmtr[ipmtr].value, NULL);
            CHECK_STATUS(EG_attributeAdd);
        }
    }

    status = EG_makeTopology(MODL->context, NULL, MODEL, 0, NULL,
                             1, &etemp, NULL, &emodel);
    CHECK_STATUS(EG_makeTopology);

    status = EG_saveModel(emodel, dumpfile);
    CHECK_STATUS(EG_saveModel);

    status = EG_deleteObject(emodel);
    CHECK_STATUS(EG_deleteObject);

    SPRINT1(1, "--> dumped %s", dumpfile);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   evalRpn - evaluate Rpn-code                                        *
 *                                                                      *
 ************************************************************************
 */

static int
evalRpn(rpn_T     *rpn,                 /* (in)  pointer to Rpn-code */
        modl_T    *modl,                /* (in)  pointer to MODL */
        double    *val,                 /* (out) value      of expression */
        double    *dot,                 /* (out) derivative of expression */
        char      str[])                /* (out) value if string-valued or error */
{
    int       status = SUCCESS;         /* (out) return status */

    int       irpn, nvalstack, ival, ipmtr, jpmtr, irow, icol, irc, ietype, ii, jj;
    int       ibeg, iend;
    int       nan1, nan2, nan3, nan4, nan5, nan6, nan7, nan8;
    double    val1, dot1, val2, dot2, val3;
    #ifndef WIN32
    double __attribute__((unused)) dot3, val4, dot4;    /* needed to eliminate compiler warning */
    #else
    double                         dot3, val4, dot4;
    #endif
    double    xa,  xa_d,  ya,  ya_d,  xb, xb_d, yb, yb_d, xc, xc_d, yc, yc_d;
    double    dab, dab_d, dbc, dbc_d, R,  R_d,  L,  L_d;
    double    Xcent, Xcent_d, Ycent, Ycent_d, Xmidl, Xmidl_d, Ymidl, Ymidl_d;
    double    seglen, seglen_d, phi, phi_d, angle, angle_d, sweep, sweep_d;
    double    angab, angab_d, angbc, angbc_d;
    double    rad2deg = 1 / PIo180;
    char      prefix[MAX_NAME_LEN], suffix[MAX_NAME_LEN];
    char      str1[MAX_STRVAL_LEN], str2[MAX_STRVAL_LEN], str3[MAX_STRVAL_LEN];
    char      str4[MAX_STRVAL_LEN], str5[MAX_STRVAL_LEN], str6[MAX_STRVAL_LEN];
    char      str7[MAX_STRVAL_LEN], str8[MAX_STRVAL_LEN];
    char      errstr[MAX_STRVAL_LEN], tmp_text[MAX_STRVAL_LEN-17];
    char      *temp, *buffer;
    stack_T   *valstack=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(evalRpn);

#define PUSH_VAL(VAL,DOT,STR,NAN)               \
    if (nvalstack < MAX_EXPR_LEN-1) {           \
        valstack[nvalstack].val = VAL;          \
        valstack[nvalstack].dot = DOT;          \
        strcpy(valstack[nvalstack].str, STR);   \
        valstack[nvalstack].nan = NAN;          \
        nvalstack++;                            \
    } else {                                    \
        status = OCSM_VAL_STACK_OVERFLOW;       \
        goto cleanup;                           \
    }

#define POP_VAL(VAL,DOT,STR,NAN)                \
    if (nvalstack > 0) {                        \
        nvalstack--;                            \
        VAL = valstack[nvalstack].val;          \
        DOT = valstack[nvalstack].dot;          \
        strcpy(STR, valstack[nvalstack].str);   \
        NAN = valstack[nvalstack].nan;          \
    } else {                                    \
        status = OCSM_VAL_STACK_UNDERFLOW;      \
        goto cleanup;                           \
    }

    /* --------------------------------------------------------------- */

    MALLOC(valstack, stack_T, MAX_EXPR_LEN);

    /* default answer (in case there is an error) */
    *val   = 0;
    *dot   = 0;
    str[0] = '\0';

    /* flag to remember if this came from illegal_pmtr_name, illegal_value, or func_arg_out_of_bounds */
    ietype = 0;

    /* start with an empty value stack */
    nvalstack = 0;

    /* loop through whole Rpn-code */
    irpn = 0;
    while (rpn[irpn].type != PARSE_END) {

        SPRINT3(3, "executing %3d type=%2d, text=%s", irpn, rpn[irpn].type, rpn[irpn].text);

        /* PARSE_NUM */
        if (rpn[irpn].type == PARSE_NUMBER) {
            PUSH_VAL(strtod(rpn[irpn].text, (char**)NULL), 0.0, "", 0);

        /* PARSE_STRING */
        } else if (rpn[irpn].type == PARSE_STRING) {
            PUSH_VAL(0, 0, rpn[irpn].text, 0);

        /* PARSE_NAME */
        } else if (rpn[irpn].type == PARSE_NAME) {
            jpmtr = 0;
            if (modl != NULL) {
                prefix[0] = '\0';
                suffix[0] = '\0';
                for (irc = 0; irc < MAX_NAME_LEN-1; irc++) {
                    if (rpn[irpn].text[irc] == '\0') {
                        break;
                    } else if (rpn[irpn].text[irc] != '.') {
                        prefix[irc  ] = rpn[irpn].text[irc];
                        prefix[irc+1] = '\0';
                    } else {
                        STRNCPY(suffix, &(rpn[irpn].text[irc]), MAX_NAME_LEN);
                        break;
                    }
                }

                for (ipmtr = 1; ipmtr <= modl->npmtr; ipmtr++) {
                    if (strcmp(modl->pmtr[ipmtr].name, prefix) == 0                   &&
                              (modl->pmtr[ipmtr].scope == modl->scope[modl->level] ||
                               modl->pmtr[ipmtr].type  == OCSM_CONSTANT              )  ) {
                        jpmtr = ipmtr;

                        /* check for dot-suffix */
                        if (STRLEN(suffix) == 0) {
                            irow = icol = 1;

                            if (modl->pmtr[jpmtr].str != NULL) {
                                status = ocsmGetValuS(modl, jpmtr, str1);
                                CHECK_STATUS(ocsmGetValuS);

                                PUSH_VAL(0, 0, str1, 0);
                            } else {
                                status = ocsmGetValu(modl, jpmtr, irow, icol, &val1, &dot1);
                                CHECK_STATUS(ocsmGetValu);

                                if (val1 != -HUGEQ) {
                                    PUSH_VAL(val1, dot1, "", 0);
                                } else {
                                    STRNCPY(tmp_text, rpn[irpn].text, MAX_STRVAL_LEN-18);
                                    snprintf(errstr, MAX_STRVAL_LEN, "\"%s\" is not defined", tmp_text);
                                    PUSH_VAL(0,    0,    "", 1);
                                    ietype = OCSM_ILLEGAL_VALUE;
                                }
                            }
                            break;
                        } else if (strcmp(suffix, ".nrow") == 0) {
                            if (modl->pmtr[ipmtr].str != NULL) {
                                PUSH_VAL(0, 0, "", 0);
                            } else {
                                val1 = modl->pmtr[ipmtr].nrow;
                                PUSH_VAL(val1, 0, "", 0);
                            }
                            break;
                        } else if (strcmp(suffix, ".ncol") == 0) {
                            if (modl->pmtr[ipmtr].str != NULL) {
                                PUSH_VAL(0, 0, "", 0);
                            } else {
                                val1 = modl->pmtr[ipmtr].ncol;
                                PUSH_VAL(val1, 0, "", 0);
                            }
                            break;
                        } else if (strcmp(suffix, ".size") == 0) {
                            if (modl->pmtr[ipmtr].str != NULL) {
                                val1 = STRLEN(modl->pmtr[ipmtr].str);
                                PUSH_VAL(val1, 0, "", 0);
                            } else {
                                val1 = (modl->pmtr[ipmtr].nrow) * (modl->pmtr[ipmtr].ncol);
                                PUSH_VAL(val1, 0, "", 0);
                            }
                            break;
                        } else if (strcmp(suffix, ".sum")  == 0) {
                            val1 = 0;
                            dot1 = 0;
                            for (irc = 0; irc < (modl->pmtr[ipmtr].nrow)*(modl->pmtr[ipmtr].ncol); irc++) {
                                val1 += modl->pmtr[ipmtr].value[irc];
                                dot1 += modl->pmtr[ipmtr].dot[  irc];
                            }
                            PUSH_VAL(val1, dot1, "", 0);
                            break;
                        } else if (strcmp(suffix, ".norm")  == 0) {
                            val1 = 0;
                            dot1 = 0;
                            for (irc = 0; irc < (modl->pmtr[ipmtr].nrow)*(modl->pmtr[ipmtr].ncol); irc++) {
                                val1 += modl->pmtr[ipmtr].value[irc] * modl->pmtr[ipmtr].value[irc];
                                dot1 += modl->pmtr[ipmtr].value[irc] * modl->pmtr[ipmtr].dot[  irc];
                            }
                            if (val1 > 0) {
                                PUSH_VAL(sqrt(val1), dot1/sqrt(val1), "", 0);
                            } else {
                                PUSH_VAL(0, 0, "", 0);
                            }
                            break;
                        } else if (strcmp(suffix, ".min")  == 0) {
                            val1 = modl->pmtr[ipmtr].value[0];
                            dot1 = modl->pmtr[ipmtr].dot[  0];
                            for (irc = 0; irc < (modl->pmtr[ipmtr].nrow)*(modl->pmtr[ipmtr].ncol); irc++) {
                                if (modl->pmtr[ipmtr].value[irc] < val1) {
                                    val1 = modl->pmtr[ipmtr].value[irc];
                                    dot1 = modl->pmtr[ipmtr].dot[  irc];
                                }
                            }
                            PUSH_VAL(val1, dot1, "", 0);
                            break;
                        } else if (strcmp(suffix, ".max")  == 0) {
                            val1 = modl->pmtr[ipmtr].value[0];
                            dot1 = modl->pmtr[ipmtr].dot[  0];
                            for (irc = 0; irc < (modl->pmtr[ipmtr].nrow)*(modl->pmtr[ipmtr].ncol); irc++) {
                                if (modl->pmtr[ipmtr].value[irc] > val1) {
                                    val1 = modl->pmtr[ipmtr].value[irc];
                                    dot1 = modl->pmtr[ipmtr].dot[  irc];
                                }
                            }
                            PUSH_VAL(val1, dot1, "", 0);
                            break;
                        } else if (strcmp(suffix, ".dot")  == 0) {
                            val1 = modl->pmtr[ipmtr].value[0];
                            dot1 = modl->pmtr[ipmtr].dot[  0];
                            PUSH_VAL(dot1, 0, "", 0);
                            break;
                        } else {
                            signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                                        "illegal suffix (%s) in name", suffix);
                            status = OCSM_ILLEGAL_PMTR_NAME;
                            goto cleanup;
                        }
                    }
                }
            }
            if (jpmtr == 0) {
                STRNCPY(tmp_text, rpn[irpn].text, MAX_STRVAL_LEN-18);
                snprintf(errstr, MAX_STRVAL_LEN, "\"%s\" is not defined", tmp_text);
                PUSH_VAL(0, 0, "", 1);
                ietype = OCSM_ILLEGAL_PMTR_NAME;
            }

        /* PARSE_ARRAY */
        } else if (rpn[irpn].type == PARSE_ARRAY) {
            jpmtr = 0;
            if (modl != NULL) {
                for (ipmtr = 1; ipmtr <= modl->npmtr; ipmtr++) {
                    if (strcmp(modl->pmtr[ipmtr].name, rpn[irpn].text) == 0       &&
                               modl->pmtr[ipmtr].scope == modl->scope[modl->level]  ) {
                        jpmtr = ipmtr;

                        POP_VAL(val1, dot1, str1, nan1);
                        POP_VAL(val2, dot2, str2, nan2);

                        irow = NINT(val2);
                        icol = NINT(val1);

                        status = ocsmGetValu(modl, jpmtr, irow, icol, &val1, &dot1);
                        CHECK_STATUS(ocsmGetValu);

                        PUSH_VAL(val1, dot1, "", 0);
                        break;
                    }
                }
            }
            if (jpmtr == 0) {
                STRNCPY(tmp_text, rpn[irpn].text, MAX_STRVAL_LEN-18);
                snprintf(errstr, MAX_STRVAL_LEN, "\"%s\" is not defined", tmp_text);
                PUSH_VAL(0, 0, "", 1);
                ietype = OCSM_ILLEGAL_PMTR_NAME;
            }

        /* PARSE_OP1 or PARSE_OP2 or PARSE_OP3 */
        } else if (rpn[irpn].type == PARSE_OP1 ||
                   rpn[irpn].type == PARSE_OP2 ||
                   rpn[irpn].type == PARSE_OP3   ) {
            if        (strcmp(rpn[irpn].text, "+") == 0) {

                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);

                if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (STRLEN(str1) > 0 && STRLEN(str2) > 0) {
                    snprintf(str3, MAX_STRVAL_LEN, "%s%s", str2, str1);
                    PUSH_VAL(0, 0, str3, 0);
                } else if (STRLEN(str2) > 0) {
                    if (fabs(val1-NINT(val1))<EPS12) {
                        snprintf(str3, MAX_STRVAL_LEN, "%s%d", str2, NINT(val1));
                    } else {
                        snprintf(str3, MAX_STRVAL_LEN, "%s%f", str2,      val1 );
                    }
                    PUSH_VAL(0, 0, str3, 0);
                } else if (STRLEN(str1) > 0) {
                    if (fabs(val2-NINT(val2)) < EPS12) {
                        snprintf(str3, MAX_STRVAL_LEN, "%d%s", NINT(val2), str1);
                    } else {
                        snprintf(str3, MAX_STRVAL_LEN, "%f%s",      val2,  str1);
                    }
                    PUSH_VAL(0, 0, str3, 0);
                } else {
                    PUSH_VAL(val2+val1, dot2+dot1, "", 0);
                }
            } else if (strcmp(rpn[irpn].text, "-") == 0) {
                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(val2-val1, dot2-dot1, "", 0);
                }
            } else if (strcmp(rpn[irpn].text, "*") == 0) {
                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(val2*val1, dot1*val2+dot2*val1, "", 0);
                }
            } else if (strcmp(rpn[irpn].text, "/") == 0) {
                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0) {
                    STRNCPY(errstr, "divide by zero", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(val2/val1, (dot2*val1-dot1*val2)/val1/val1, "", 0);
                }
            } else if (strcmp(rpn[irpn].text, "^") == 0) {
                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);
                ival = (int)val1;

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == (double)ival && dot1 == 0){
                    PUSH_VAL(pow(val2,ival), dot2*ival*pow(val2,ival-1), "", 0);
                } else if (val2 < 0.0) {
                    STRNCPY(errstr, "a^b only for a>=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else if (val2 == 0) {
                    PUSH_VAL(0, 0, "", 0);
                } else {
                    PUSH_VAL(pow(val2,val1), (dot1*log(val2)+dot2*val1/val2)*pow(val2,val1), "", 0);
                }
            }

        /* PARSE_FUNC */
        } else if (rpn[irpn].type == PARSE_FUNC) {

            /* pi(x) */
            if        (strcmp(rpn[irpn].text, "pi") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(val1*PI, dot1*PI, "", 0);
                }

            /* min(x,y) */
            } else if (strcmp(rpn[irpn].text, "min") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // y
                POP_VAL(val2, dot2, str2, nan2);  // x

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < val2) {
                    PUSH_VAL(val1, dot1, "", 0);
                } else {
                    PUSH_VAL(val2, dot2, "", 0);
                }

            /* max(x,y) */
            } else if (strcmp(rpn[irpn].text, "max") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // y
                POP_VAL(val2, dot2, str2, nan2);  // x

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 > val2) {
                    PUSH_VAL(val1, dot1, "", 0);
                } else {
                    PUSH_VAL(val2, dot2, "", 0);
                }

            /* sqrt(x) */
            } else if (strcmp(rpn[irpn].text, "sqrt") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < 0.0) {
                    STRNCPY(errstr, "sqrt(x) only for x>=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(sqrt(val1), dot1/2/sqrt(val1), "", 0);
                }

            /* abs(x) */
            } else if (strcmp(rpn[irpn].text, "abs") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 >= 0) {
                    PUSH_VAL(+val1, +dot1, "", 0);
                } else {
                    PUSH_VAL(-val1, -dot1, "", 0);
                }

            /* int(x) */
            } else if (strcmp(rpn[irpn].text, "int") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    ival = (int) val1;
                    PUSH_VAL((double)ival, 0.0, "", 0);
                }

            /* nint(x) */
            } else if (strcmp(rpn[irpn].text, "nint") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    if (val1 > 0) {
                        ival = (int) (val1 + 0.50);
                    } else {
                        ival = (int) (val1 - 0.50);
                    }
                    PUSH_VAL((double)ival, 0.0, "", 0);
                }

            /* ceil(x) */
            } else if (strcmp(rpn[irpn].text, "ceil") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL((double)ceil(val1), 0.0, "", 0);
                }

            /* floor(x) */
            } else if (strcmp(rpn[irpn].text, "floor") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL((double)floor(val1), 0.0, "", 0);
                }

            /* mod(a,b) */
            } else if (strcmp(rpn[irpn].text, "mod") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // b
                POP_VAL(val2, dot2, str2, nan2);  // a

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 <= 0) {
                    STRNCPY(errstr, "mod(a,b) only for b>0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(val2-val1*(int)(val2/val1), (val1*dot2-val2*dot1)/val1/val1, "", 0);
                }

            /* sign(x) */
            } else if (strcmp(rpn[irpn].text, "sign") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(val1, dot1, "", nan1);
                } else if (val1 > 0) {
                    PUSH_VAL(+1, 0, "", 0);
                } else if (val1 < 0) {
                    PUSH_VAL(-1, 0, "", 0);
                } else {
                    PUSH_VAL( 0, 0, "", 0);
                }

            /* exp(x) */
            } else if (strcmp(rpn[irpn].text, "exp") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(exp(val1), dot1*exp(val1), "", 0);
                }

            /* log(x) */
            } else if (strcmp(rpn[irpn].text, "log") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < 0.0) {
                    STRNCPY(errstr, "log(x) only for x>=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(log(val1), dot1/val1, "", 0);
                }

            /* log10(x) */
            } else if (strcmp(rpn[irpn].text, "log10") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < 0.0) {
                    STRNCPY(errstr, "log10(x) only for x>=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(log10(val1), dot1*log10(exp(1.))/val1, "", 0);
                }

            /* sin(x) */
            } else if (strcmp(rpn[irpn].text, "sin") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(sin(val1), dot1*cos(val1), "", 0);
                }

            /* sind(x) */
            } else if (strcmp(rpn[irpn].text, "sind") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status =  OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    val1 /= rad2deg;
                    dot1 /= rad2deg;
                    PUSH_VAL(sin(val1), dot1*cos(val1), "", 0);
                }

            /* asin(x) */
            } else if (strcmp(rpn[irpn].text, "asin") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < -1.0 || val1 > 1.0) {
                    STRNCPY(errstr, "asin(x) only for abs(x)<=1", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(asin(val1), dot1/sqrt(1-val1*val1), "", 0);
                }

            /* asind(x) */
            } else if (strcmp(rpn[irpn].text, "asind") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < -1.0 || val1 > 1.0) {
                    STRNCPY(errstr, "asind(x) only for abs(x)<=1", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(asin(val1)*rad2deg, dot1*rad2deg/sqrt(1-val1*val1), "", 0);
                }

            /* cos(x) */
            } else if (strcmp(rpn[irpn].text, "cos") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(cos(val1), -dot1*sin(val1), "", 0);
                }

            /* cosd(x) */
            } else if (strcmp(rpn[irpn].text, "cosd") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    val1 /= rad2deg;
                    dot1 /= rad2deg;
                    PUSH_VAL(cos(val1), -dot1*sin(val1), "", 0);
                }

            /* acos(x) */
            } else if (strcmp(rpn[irpn].text, "acos") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < -1.0 || val1 > 1.0) {
                    STRNCPY(errstr, "acos(x) only for abs(x)<=1", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(acos(val1), -dot1/sqrt(1-val1*val1), "", 0);
                }

            /* acosd(x) */
            } else if (strcmp(rpn[irpn].text, "acosd") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < -1.0 || val1 > 1.0) {
                    STRNCPY(errstr, "acosd(x) only for abs(x)<=1", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(acos(val1)*rad2deg, -dot1*rad2deg/sqrt(1-val1*val1), "", 0);
                }

            /* tan(x) */
            } else if (strcmp(rpn[irpn].text, "tan") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(tan(val1), dot1/cos(val1)/cos(val1), "", 0);
                }

            /* tand(x) */
            } else if (strcmp(rpn[irpn].text, "tand") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    val1 /= rad2deg;
                    dot1 /= rad2deg;

                    PUSH_VAL(tan(val1), dot1/cos(val1)/cos(val1), "", 0);
                }

            /* atan(x) */
            } else if (strcmp(rpn[irpn].text, "atan") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(atan(val1), dot1/(1+val1*val1), "", 0);
                }

            /* atand(x) */
            } else if (strcmp(rpn[irpn].text, "atand") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(atan(val1)*rad2deg, dot1*rad2deg/(1+val1*val1), "", 0);
                }

            /* atan2(y,x) */
            } else if (strcmp(rpn[irpn].text, "atan2") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x
                POP_VAL(val2, dot2, str2, nan2);  // y

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0 && val2 == 0.0) {
                    STRNCPY(errstr, "atan2(x,y) only for x!=0 or y!=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(atan2(val2,val1), (dot2*val1-dot1*val2)/(val1*val1+val2*val2), "", 0);
                }

            /* atan2d(y,x) */
            } else if (strcmp(rpn[irpn].text, "atan2d") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x
                POP_VAL(val2, dot2, str2, nan2);  // y

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0 && val2 == 0.0) {
                    STRNCPY(errstr, "atan2d(x,y) only for x!=0 or y!=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(atan2(val2,val1)*rad2deg, (dot2*val1-dot1*val2)*rad2deg/(val1*val1+val2*val2), "", 0);
                }

            /* hypot(x,y) */
            } else if (strcmp(rpn[irpn].text, "hypot") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // y
                POP_VAL(val2, dot2, str2, nan2);  // x

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0 && val2 == 0.0) {
                    PUSH_VAL(0.0, 0.0, "", 0);
                } else {
                    PUSH_VAL(sqrt(val1*val1+val2*val2), (dot1*val1+dot2*val2)/sqrt(val1*val1+val2*val2), "", 0);
                }

            /* hypot3(x,y,z) */
            } else if (strcmp(rpn[irpn].text, "hypot3") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // z
                POP_VAL(val2, dot2, str2, nan2);  // y
                POP_VAL(val3, dot3, str3, nan3);  // x

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0 && val2 == 0.0 && val3 == 0.0) {
                    PUSH_VAL(0.0, 0.0, "", 0);
                } else {
                    PUSH_VAL(sqrt(val1*val1+val2*val2+val3*val3), (dot1*val1+dot2*val2+dot3*val3)/sqrt(val1*val1+val2*val2+val3*val3), "", 0);
                }

            /* incline(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "incline") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    angle   = atan2(yb-ya, xb-xa);
                    angle_d = ((xb-xa) * (yb_d-ya_d) - (yb-ya) * (xb_d-xa_d))
                            / ((xb-xa) * (xb  -xa  ) + (yb-ya) * (yb  -ya  ));

                    PUSH_VAL(angle*rad2deg, angle_d*rad2deg, "", 0);
                }

            /* Xcent(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "Xcent") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xa
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    Xcent   = (xa   + xb  ) / 2;
                    Xcent_d = (xa_d + xb_d) / 2;

                    PUSH_VAL(Xcent, Xcent_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (4 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    Xcent   = (xa   + xb  ) / 2
                            - (R-dab) * (yb-ya) / (2*L);
                    Xcent_d = (xa_d + xb_d) / 2
                            - (R_d-dab_d) * (yb  -ya  ) / (2*L)
                            - (R  -dab  ) * (yb_d-ya_d) / (2*L)
                            + L_d * (R-dab) * (yb-ya) / (2*L*L);

                    PUSH_VAL(Xcent, Xcent_d, "", 0);
                }

            /* Ycent(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "Ycent") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    Ycent   = (ya   + yb  ) / 2;
                    Ycent_d = (ya_d + yb_d) / 2;

                    PUSH_VAL(Ycent, Ycent_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (4 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    Ycent   = (ya + yb) / 2
                            + (R-dab) * (xb-xa) / (2*L);
                    Ycent_d = (ya_d + yb_d) / 2
                            + (R_d-dab_d) * (xb  -xa  ) / (2*L)
                            + (R  -dab  ) * (xb_d-xa_d) / (2*L)
                            + L_d * (R-dab) * (xb-xa) / (2*L*L);

                    PUSH_VAL(Ycent, Ycent_d, "", 0);
                }

            /* Xmidl(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "Xmidl") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    Xmidl   = (xa   + xb  ) / 2;
                    Xmidl_d = (xa_d + xb_d) / 2;

                    PUSH_VAL(Xmidl, Xmidl_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    Xmidl   = (xa + xb) / 2
                            + dab * (yb-ya) / (2*L);
                    Xmidl_d = (xa_d + xb_d) / 2
                            + dab_d * (yb  -ya  ) / (2*L)
                            + dab   * (yb_d-ya_d) / (2*L)
                            - L_d * dab * (yb-ya) / (2*L*L);

                    PUSH_VAL(Xmidl, Xmidl_d, "", 0);
                }

            /* Ymidl(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "Ymidl") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    Ymidl   = (ya   + yb  ) / 2;
                    Ymidl_d = (ya_d + yb_d) / 2;

                    PUSH_VAL(Ymidl, Ymidl_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    Ymidl   = (ya   + yb  ) / 2
                            - dab * (xb-xa) / (2*L);
                    Ymidl_d = (ya_d + yb_d) / 2
                            - dab_d * (xb  -xa  ) / (2*L)
                            - dab   * (xb_d-xa_d) / (2*L)
                            + L_d * dab * (xb-xa) / (2*L*L);

                    PUSH_VAL(Ymidl, Ymidl_d, "", 0);
                }

            /* seglen(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "seglen") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    seglen   = sqrt((xb  -xa  )*(xb-xa) + (yb  -ya  )*(yb-ya));
                    seglen_d =     ((xb_d-xa_d)*(xb-xa) + (yb_d-ya_d)*(yb-ya)) / seglen;

                    PUSH_VAL(seglen, seglen_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    phi   = atan(L / (R-dab));
                    phi_d = ((R-dab) * L_d - L * (R_d-dab_d)) / (L*L + (R-dab)*(R-dab));

                    seglen   = 2 * R  * phi;
                    seglen_d = 2 * (R_d * phi + R * phi_d);

                    PUSH_VAL(seglen, seglen_d, "", 0);
                }

            /* radius(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "radius") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    PUSH_VAL(0.0, 0.0, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    PUSH_VAL(R, R_d, "", 0);
                }

            /* sweep(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "sweep") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    PUSH_VAL(0.0, 0.0, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    phi   = atan(L / (R-dab));
                    phi_d = ((R-dab) * L_d - L * (R_d-dab_d)) / (L*L + (R-dab)*(R-dab));

                    sweep   = 2 * phi;
                    sweep_d = 2 * phi_d;

                    PUSH_VAL(sweep*rad2deg, sweep_d*rad2deg, "", 0);
                }

            /* turnang(xa,ya,dab,xb,yb,dbc,xc,yc) */
            } else if (strcmp(rpn[irpn].text, "turnang") == 0) {
                POP_VAL(yc,  yc_d,  str1, nan1);  // yc
                POP_VAL(xc,  xc_d,  str2, nan2);  // xc
                POP_VAL(dbc, dbc_d, str3, nan3);  // dbc
                POP_VAL(yb,  yb_d,  str4, nan4);  // yb
                POP_VAL(xb,  xb_d,  str5, nan5);  // xb
                POP_VAL(dab, dab_d, str6, nan6);  // dab
                POP_VAL(ya,  ya_d,  str7, nan7);  // ya
                POP_VAL(xa,  xa_d,  str8, nan8);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0 || STRLEN(str6) > 0 ||
                    STRLEN(str7) > 0 || STRLEN(str8) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0 || nan6 != 0 ||
                           nan7 != 0 || nan8 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    angab   = atan2(yb-ya, xb-xa);
                    angab_d = ((xb-xa)*(yb_d-ya_d) - (yb-ya)*(xb_d-xa_d))
                            / ((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  ));

                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    if        (fabs(dab-L) < EPS12) { //                  +L == dab
                        angab   -= 3 * PI / 2;
                        angab_d += 0;
                    } else if (fabs(dab+L) < EPS12) { // dab == -L
                        angab   += 3 * PI / 2;
                        angab_d += 0;
                    } else if (fabs(dab) > EPS06) {
                        R   = (L*L + dab*dab) / (2 * dab);
                        R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                        phi   = atan(L / (R-dab));
                        phi_d = ((R-dab) * L_d - L * (R_d-dab_d)) / (L*L + (R-dab)*(R-dab));

                        if        (dab >  +L) {       //                  +L < dab
                            angab   += phi + PI;
                            angab_d += phi_d;
                        } else if (dab >  -L) {       //       -L < dab < +L
                            angab   += phi;
                            angab_d += phi_d;
                        } else {                      // dab < -L
                            angab   += phi - PI;
                            angab_d += phi_d;
                        }
                    }

                    angbc = atan2(yc-yb, xc-xb);
                    angbc_d = ((xc-xb)*(yc_d-yb_d) - (yc-yb)*(xc_d-xb_d))
                            / ((xc-xb)*(xc  -xb  ) + (yc-yb)*(yc  -yb  ));

                    L   = sqrt((xc-xb)*(xc  -xb  ) + (yc-yb)*(yc  -yb  )) /  2;
                    L_d =     ((xc-xb)*(xc_d-xb_d) + (yc-yb)*(yc_d-yb_d)) / (2 * L);

                    if        (fabs(dbc-L) < EPS12) { //                  +L == dbc
                        angbc   += 3 * PI / 2;
                        angbc_d += 0;
                    } else if (fabs(dbc+L) < EPS12) { // dbc == -L
                        angbc   -= 3 * PI / 2;
                        angbc_d += 0;
                    } else if (fabs(dbc) > EPS06) {
                        R   = (L*L + dbc*dbc) / (2 * dbc);
                        R_d = (dbc * L * L_d - L * L * dbc_d) / (2 * dbc * dbc);

                        phi   = atan(L / (R-dbc));
                        phi_d = ((R-dbc) * L_d - L * (R_d-dbc_d)) / (L*L + (R-dbc)*(R-dbc));

                        if        (dbc >  +L) {       //                  +L < dbc
                            angbc   -= phi + PI;
                            angbc_d -= phi_d;
                        } else if (dbc >  -L) {       //       -L < dbc < +L
                            angbc   -= phi;
                            angbc_d -= phi_d;
                        } else {                      // dbc < -L
                            angbc   -= phi - PI;
                            angbc_d -= phi_d;
                        }
                    }

                    angle   = angbc   - angab;
                    angle_d = angbc_d - angab_d;
                    while (angle < -PI) {
                        angle += TWOPI;
                    }
                    while (angle > +PI) {
                        angle -= TWOPI;
                    }

                    PUSH_VAL(angle*rad2deg, angle_d*rad2deg, "", 0);
                }

            /* dip(xa,ya,xb,yb,rad) */
            } else if (strcmp(rpn[irpn].text, "dip") == 0) {
                POP_VAL(R,  R_d,  str1, nan1);  // rad
                POP_VAL(yb, yb_d, str2, nan2);  // yb
                POP_VAL(xb, xb_d, str3, nan3);  // xb
                POP_VAL(ya, ya_d, str4, nan4);  // ya
                POP_VAL(xa, xa_d, str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    if (L > R) {
                        STRNCPY(errstr, "dip only for L<=R", MAX_STRVAL_LEN);
                        PUSH_VAL(0, 0, "", 1);
                        ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                    } else {
                        dab   = R   -                        sqrt(R*R - L*L);
                        dab_d = R_d - (R*R_d - L*L_d) / (2 * sqrt(R*R - L*L));
                        PUSH_VAL(dab, dab_d, "", 0);
                    }
                }

            /* smallang(x) */
            } else if (strcmp(rpn[irpn].text, "smallang") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    while (val1 > +180) {
                        val1 -= 360;
                    }
                    while (val1 < -180) {
                        val1 += 360;
                    }
                    PUSH_VAL(val1, dot1, "", 0);
                }

            /* val2str(num,digits) */
            } else if (strcmp(rpn[irpn].text, "val2str") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // digits
                POP_VAL(val2, dot2, str2, nan2);  // num

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (NINT(val1) <= 0) {
                    sprintf(str3, "%d", NINT(val2));
                    PUSH_VAL(0, 0, str3, 0);
                } else {
                    sprintf(str3, "%.*f", NINT(val1), val2);
                    PUSH_VAL(0, 0, str3, 0);
                }

            /* str2val(string) */
            } else if (strcmp(rpn[irpn].text, "str2val") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // string

                if (STRLEN(str1) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    status = str2val(str1, MODL, &val2, &dot2, str2);
                    if (status != EGADS_SUCCESS) goto cleanup;
                    PUSH_VAL(val2, dot2, str2, 0);
                }

            /* findstr(str1,str2) */
            } else if (strcmp(rpn[irpn].text, "findstr") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // str2
                POP_VAL(val2, dot2, str2, nan2);  // str1

                if (STRLEN(str1) == 0 || STRLEN(str2) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    temp = (char*) strstr(&(str2[1]), &(str1[1]));

                    if (temp == NULL) {
                        PUSH_VAL(0, 0, "", 0);
                    } else {
                        val3 = (int)(temp - str2);
                        PUSH_VAL(val3, 0, "", 0);
                    }
                }

            /* slice(str,ibeg,iend) */
            } else if (strcmp(rpn[irpn].text, "slice") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // iend
                POP_VAL(val2, dot2, str2, nan2);  // ibeg
                POP_VAL(val3, dot3, str3, nan3);  // str

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    ibeg = NINT(val2) - 1;
                    iend = NINT(val1) - 1;
                    if (iend > STRLEN(str3)) iend = strlen(str3);
                    if (ibeg < 0 || ibeg > STRLEN(str3)-1) {
                        STRNCPY(errstr, "ibeg must be be between 1 and strlen(str)", MAX_STRVAL_LEN);
                        PUSH_VAL(0, 0, "", 1);
                        ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                    } else if (iend < ibeg) {
                        STRNCPY(errstr, "iend must not be less than ibeg", MAX_STRVAL_LEN);
                        PUSH_VAL(0, 0, "", 1);
                        ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                    } else {
                        STRNCPY(str4, &(str3[ibeg]), iend-ibeg+2);
                        PUSH_VAL(0, 0, str4, 0);
                    }
                }

            /* path($pwd) or path($csm) or path($root) or path($file) */
            } else if (strcmp(rpn[irpn].text, "path") == 0) {
                POP_VAL(val1, dot1, str1, nan1);

                if        (strcmp(str1, "pwd" ) == 0) {
                    if ((buffer = getcwd(NULL,0)) == NULL) {
                        STRNCPY(str2, ".", MAX_STRVAL_LEN);        // error
                    } else {
                        snprintf(str2, MAX_STRVAL_LEN, "%s%c", buffer, SLASH);
                        free(buffer);
                    }
                    PUSH_VAL(0, 0, str2, 0);
                } else if (strcmp(str1, "csm" ) == 0) {
                    if (strchr(MODL->brch[MODL->ibrch].filename, SLASH) == NULL) {
                        snprintf(str2, MAX_STRVAL_LEN, ".%c", SLASH);
                    } else {
                        snprintf(str2, MAX_STRVAL_LEN, "%s", MODL->brch[MODL->ibrch].filename);
                        for (ii = STRLEN(str2)-1; ii >= 0; ii--) {
                            if (str2[ii  ] == SLASH) {
                                str2[ii+1] = '\0';
                                break;
                            }
                        }
                    }
                    PUSH_VAL(0, 0, str2, 0);
                } else if (strcmp(str1, "root") == 0) {
                    snprintf(str2, MAX_STRVAL_LEN, "%s%c", getenv("ESP_ROOT"), SLASH);
                    PUSH_VAL(0, 0, str2, 0);
                } else if (strcmp(str1, "file") == 0) {
                    snprintf(str2, MAX_STRVAL_LEN, "%s", MODL->brch[MODL->ibrch].filename);
                    jj = 0;
                    for (ii = 0; ii < STRLEN(str2); ii++) {
                        if (str2[ii] == SLASH) {
                            jj = ii + 1;
                        }
                    }
                    PUSH_VAL(0, 0, &(str2[jj]), 0);
                } else {
                    STRNCPY(errstr, "valid arg for path() is only $pwd, $csm, $root, or $name", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                }

            /* ifzero(test,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifzero") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // test

                if (STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val3 == 0) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }

            /* ifpos(test,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifpos") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // test

                if (STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val3 > 0) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }

            /* ifneg(test,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifneg") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // test

                if (STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val3 < 0) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }

            /* ifmatch(st1,pat,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifmatch") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // pat
                POP_VAL(val4, dot4, str4, nan4);  // str

                if (STRLEN(str3) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (STRLEN(str4) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (matches(str3, str4)) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }

            /* ifnan(test,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifnan") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // test

                if (STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan3 != 0) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }
            }
        } else {
            SPRINT2(3, "skipping type %d (%s)", rpn[irpn].type, rpn[irpn].text);
        }

        if (outLevel >= 3) {
            for (ii = 0; ii < nvalstack; ii++) {
                SPRINT4(3, "    %10.5f %10.5f %20s %5d",
                        valstack[ii].val, valstack[ii].dot,
                        valstack[ii].str, valstack[ii].nan);
            }
        }

        irpn++;
    }

    POP_VAL(*val, *dot, str, nan1);

    /* if error flag was set, return error */
    if (nan1 != 0) {
        strcpy(str, errstr);
        status = ietype;

    } else if (nvalstack > 0) {
        status = OCSM_VAL_STACK_OVERFLOW;
    }

#undef PUSH_VAL
#undef POP_VAL

cleanup:
    FREE(valstack);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   faceContains - determine if point is in Face's bounding box        *
 *                                                                      *
 ************************************************************************
 */

static int
faceContains(ego    eface,              /* (in)  pointer to Face */
             double xx,                 /* (in)  x-coordinate */
             double yy,                 /* (in)  y-coordinate */
             double zz)                 /* (in)  z-coordinate */
{
    int       status = 0;               /* (out) =0  not in bounding box */
                                        /*       =1      in bounding box */

    double    box[6];

    ROUTINE(faceContains);

    /* --------------------------------------------------------------- */

    status = EG_getBoundingBox(eface, box);
    CHECK_STATUS(EG_getBoundingBox);

    if (xx < box[0] || yy < box[1] || zz < box[2] ||
        xx > box[3] || yy > box[4] || zz > box[5]   ) {
        status = 0;
    } else {
        status = 1;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   finishBody - finish the definition of the body                     *
 *                                                                      *
 ************************************************************************
 */

static int
finishBody(modl_T *modl,                /* (in)  pointer to MODL */
           int    ibody)                /* (in)  Body index (1-nbody) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       nnode, nedge, nface, inode, iedge, iface, jbody;
    int       jedge, jface, nodes[2], ibeg, iend, periodic, found, jnode;
#ifdef EDGE_HIST_TRANSFORM
    int       kedge;
#endif
    int       ileft, irite, nlist, nlist2, nlist3, itype, itype2, itype3;
    int       iattr, nattr, iattrib[7], jattrib[7], iswap, nswap, atype, alen, i, icount;
    int       noTopoChange, keepEdgeAttr,*newIlist=NULL, *needSeq=NULL;
    CINT      *tempIlist, *tempIlist2, *tempIlist3;
    double    data[18], params[3], bbox[6], size, trange[4], trange2[4];
    double    xparent, yparent, zparent, xold, yold, zold, dx, dy, dz;
    double    cosx, cosy, cosz, sinx, siny, sinz, nx, ny, nz, dist, fact, xcent, ycent, zcent;
    CDOUBLE   *tempRlist, *tempRlist2, *tempRlist3;
    CCHAR     *tempClist, *tempClist2, *tempClist3, *aname3;
    body_T    *body=NULL;
    rbt_T     *rbt;

    int       nchild, ichild, oclass, mtype, ibrch, *senses;
    int       nloop, iloop, ntemp;
    double    *area=NULL, *xcg=NULL, *ycg=NULL, *zcg=NULL;
    ego       ebody, *enodes, eedge, *eedges, eface, *efaces, *echildren;
    ego       eref, *echilds, *eloops, topRef, prev, next, ecurve1, ecurve2;
#ifdef PRINT_PROGRESS
    time_t    cpu_beg, cpu_end;
#endif

    ROUTINE(finishBody);

    /* --------------------------------------------------------------- */

    PPRINT_INIT(enter finish);

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* get Body info */
    body = &(MODL->body[ibody]);

    /* print ego information */
    if (outLevel >= 3) {
        SPRINT1(3, "finishing Body %d:", ibody);
        ocsmPrintEgo(body->ebody);
    }

    /* create parent/child links in the Branches */
    ibrch = body->ibrch;
    ileft = body->ileft;
    irite = body->irite;

    if (ileft > 0) {
        ileft = MODL->body[ileft].ibrch;

        MODL->brch[ibrch].ileft = ileft;
        MODL->brch[ileft].ichld = ibrch;
    } else {
        MODL->brch[ibrch].ileft = -1;
    }

    if (irite > 0) {
        irite = MODL->body[irite].ibrch;

        MODL->brch[ibrch].irite = irite;
        MODL->brch[irite].ichld = ibrch;
    } else {
        MODL->brch[ibrch].irite = -1;
    }

    MODL->brch[ibrch].ichld = -1;

    PPRINT0(done with parent/child);

    /* if a NULL Body o SketchBody, set up quantities */
    if (body->botype == OCSM_NULL_BODY ||
        body->botype == OCSM_SKETCH      ) {
        body->nnode = 0;
        body->nedge = 0;
        body->nface = 0;

        goto cleanup;
    }

    /* make sure that all SolidBodys have a positive volume */
    if (body->botype == OCSM_SOLID_BODY) {
        status = EG_getMassProperties(body->ebody, data);
        CHECK_STATUS(EG_getMassProperties);

        if (data[0] <= 0) {
            SPRINT1(1, "WARNING:: Body might be inside-out (volume=%10.3e)", data[0]);
            (MODL->nwarn)++;
        }
    }

    /* get the number of Nodes, Edges, and Faces associated with this Body */
    ebody  = body->ebody;

    status = EG_getInfo(ebody, &oclass, &mtype, &topRef, &prev, &next);
    CHECK_STATUS(EG_getInfo);

    if (oclass == BODY) {
        status = EG_getBodyTopos(ebody, NULL, NODE, &nnode, NULL);
        CHECK_STATUS(EG_getBodyTopos:NODE);

        status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, NULL);
        CHECK_STATUS(EG_getBodyTopos:EDGE);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, NULL);
        CHECK_STATUS(EG_getBodyTopos:FACE);
    } else {
        goto cleanup;
    }

    /* override number of Edges in NODE_BODY */
    if (body->botype == OCSM_NODE_BODY) {
        nedge = 0;
    }

    body->nnode = nnode;
    body->nedge = nedge;
    body->nface = nface;

    /* delete old Node, Edge, and Face storage */
    FREE(body->node);
    FREE(body->edge);
    FREE(body->face);

    /* if we are creating a perturbation (that is, is basemodl != NULL),
       make sure that the number of Nodes, Edges, and Faces matches
       the base model */
    if (MODL->basemodl != NULL) {
        if (ibody > MODL->basemodl->nbody) {
            SPRINT2(1, "WARNING:: trying to finish ibody=%d but base model only had %d Bodys",
                    ibody, MODL->basemodl->nbody);
            (MODL->nwarn)++;
            status = OCSM_PROBLEM_CREATING_PERTURB;
            goto cleanup;
        }

        if (nnode != MODL->basemodl->body[ibody].nnode) {
            SPRINT3(1, "WARNING:: nnode disagree for ibody %d, PRTB=%d, BASE=%d",
                    ibody, nnode, MODL->basemodl->body[ibody].nnode);
            (MODL->nwarn)++;
            status = OCSM_PROBLEM_CREATING_PERTURB;
            goto cleanup;
        }

        if (nedge != MODL->basemodl->body[ibody].nedge) {
            SPRINT3(1, "WARNING:: nedge disagree for ibody %d, PRTB=%d, BASE=%d",
                    ibody, nedge, MODL->basemodl->body[ibody].nedge);
            (MODL->nwarn)++;
            status = OCSM_PROBLEM_CREATING_PERTURB;
            goto cleanup;
        }

        if (nface != MODL->basemodl->body[ibody].nface) {
            SPRINT3(1, "WARNING:: nface disagree for ibody %d, PRTB=%d, BASE=%d",
                    ibody, nface, MODL->basemodl->body[ibody].nface);
            (MODL->nwarn)++;
            status = OCSM_PROBLEM_CREATING_PERTURB;
            goto cleanup;
        }
    }

    /* add any global Attributes to this Body */
    status = setEgoAttribute(MODL, 0, ebody);
    CHECK_STATUS(setEgoAttribute);

    /* add any Attributes associated with this Branch to this Body */
    ibrch = body->ibrch;

    status = setEgoAttribute(MODL, ibrch, ebody);
    CHECK_STATUS(setEgoAttribute);

    /* add the current Branch as an Attribute for this Body */
    status = EG_attributeAdd(ebody, "_body", ATTRINT,
                             1, &ibody, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(ebody, "_brch", ATTRINT,
                             1, &ibrch, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    /* store the tessellation parameters.  if there are .tParams
       on this Body, use them */
    status = EG_attributeRet(ebody, ".tParams", &itype, &nlist,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS && nlist == 3) {
        params[0] = tempRlist[0];
        params[1] = tempRlist[1];
        params[2] = tempRlist[2];

    /* otherwise, use the defaults based upon the size of the bounding box */
    } else {
        status = EG_getBoundingBox(ebody, bbox);
        CHECK_STATUS(EG_getBoundingBox);

        size = sqrt(SQR(bbox[3]-bbox[0]) + SQR(bbox[4]-bbox[1]) + SQR(bbox[5]-bbox[2]));

        params[0] = TESS_PARAM_0 * size;
        params[1] = TESS_PARAM_1 * size;
        params[2] = TESS_PARAM_2;
    }

    status = EG_attributeAdd(ebody, "_tParams", ATTRREAL,
                             3, NULL, params, NULL);
    CHECK_STATUS(EG_attributeAdd);

    body->gratt.object = NULL;
    body->gratt.active = 1;                              /* active */
    body->gratt.color  = 0x00000000;                     /* black */
    body->gratt.ptsize = 5;
    body->gratt.render = 64;                             /* FORWARD */
    body->gratt.dirty  = 1;

    PPRINT0(done with Body attributes);

    /* initialize the Nodes for this Body */
    if (nnode < 1) {
        SPRINT2(1, "WARNING:: nnode=%d for ibody=%d", nnode, ibody);
        (MODL->nwarn)++;
        status = OCSM_INTERNAL_ERROR;
        goto cleanup;
    }

    MALLOC(body->node, node_T, nnode+1);

    status = EG_getBodyTopos(ebody, NULL, NODE, &ntemp, &enodes);
    CHECK_STATUS(EG_getBodyTopos);

    if (ntemp != nnode) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "ntemp=%d does not match nnode=%d", ntemp, nnode);
        SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
    }

    for (inode = 1; inode <= nnode; inode++) {
        status = EG_getTopology(enodes[inode-1],
                                &eref, &oclass, &mtype, data,
                                &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        body->node[inode].nedge = 0;
        body->node[inode].x     = data[0];
        body->node[inode].y     = data[1];
        body->node[inode].z     = data[2];
        body->node[inode].ibody = 0;
        body->node[inode].dxyz  = NULL;

        body->node[inode].gratt.object = NULL;
        body->node[inode].gratt.active = 1;              /* actrive */
        body->node[inode].gratt.color  = 0x00000000;     /* black */
        body->node[inode].gratt.ptsize = 5;
        body->node[inode].gratt.render = 64;             /* FORWARD */
        body->node[inode].gratt.dirty  = 1;

        body->node[inode].enode = enodes[inode-1];
    }

    EG_free(enodes);

    PPRINT1(done initializing %d Nodes, nnode);

    /* initialize the Edges for this Body */
    if (body->botype != OCSM_NODE_BODY) {
        if (nedge < 1) {
            SPRINT2(1, "WARNING:: nedge=%d for ibody=%d", nedge, ibody);
            (MODL->nwarn)++;
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

        MALLOC(body->edge, edge_T, nedge+1);

        status = EG_getBodyTopos(ebody, NULL, EDGE, &ntemp, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        if (ntemp != nedge) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "ntemp=%d does not match nedge=%d", ntemp, nedge);
            SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
        }

        for (iedge = 1; iedge <= nedge; iedge++) {
            status = EG_getTopology(eedges[iedge-1], &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            nodes[0] = status = EG_indexBodyTopo(ebody, echilds[0]);
            CHECK_STATUS(EG_indexBodyTopo);

            nodes[1] = status = EG_indexBodyTopo(ebody, echilds[1]);
            CHECK_STATUS(EG_indexBodyTopo);

            body->edge[iedge].itype        = mtype;
            body->edge[iedge].ibeg         = nodes[0];
            body->edge[iedge].iend         = nodes[1];
            body->edge[iedge].ileft        = -1;
            body->edge[iedge].irite        = -1;
            body->edge[iedge].nface        = 0;
            body->edge[iedge].ibody        = -1;
            body->edge[iedge].iford        = -1;
            body->edge[iedge].imark        = -1;
            body->edge[iedge].gratt.object = NULL;
            body->edge[iedge].gratt.active = 1;              /* active */
            body->edge[iedge].gratt.color  = 0x00ff0000;     /* red */
            body->edge[iedge].gratt.bcolor = 0x00ffffff;     /* white */
            body->edge[iedge].gratt.mcolor = 0x00000000;     /* black */
            body->edge[iedge].gratt.lwidth = 2;
            body->edge[iedge].gratt.ptsize = 3;
            body->edge[iedge].gratt.render = 2 + 64;         /* FOREGROUND | FORWARD */
            body->edge[iedge].gratt.dirty  = 1;
            body->edge[iedge].dxyz         = NULL;
            body->edge[iedge].dt           = NULL;
            body->edge[iedge].eedge        = eedges[iedge-1];

            /* update the Node valence info */
            for (ichild = 0; ichild < nchild; ichild++) {
                inode = status = EG_indexBodyTopo(ebody, echilds[ichild]);
                CHECK_STATUS(EG_indexBodyTopos);

                body->node[inode].nedge++;
            }
        }

        EG_free(eedges);
    }

    PPRINT1(done initializing %d Edges, nedge);

    /* initialize the Faces for this Body */
    MALLOC(body->face, face_T, nface+1);

    status = EG_getBodyTopos(ebody, NULL, FACE, &ntemp, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (ntemp != nface) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "ntemp=%d does not match nface=%d", ntemp, nface);
        SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
    }

    for (iface = 1; iface <= nface; iface++) {
        body->face[iface].ibody        = -1;
        body->face[iface].iford        = -1;
        body->face[iface].imark        = -1;
        body->face[iface].gratt.object = NULL;
        body->face[iface].gratt.active = 1;              /* active */
        body->face[iface].gratt.color  = 0x00ffffa3;     /* yellow */
        body->face[iface].gratt.bcolor = 0x007f7f7f;     /* grey */
        body->face[iface].gratt.mcolor = 0x00000000;     /* black */
        body->face[iface].gratt.lwidth = 1;
        body->face[iface].gratt.ptsize = 1;
        body->face[iface].gratt.render = 2 + 4 + 64;     /* FOREGROUND | ORIENTATION | FORWARD */
        body->face[iface].gratt.dirty  = 1;
        body->face[iface].eggdata      = NULL;
        body->face[iface].dxyz         = NULL;
        body->face[iface].duv          = NULL;
        body->face[iface].eface = efaces[iface-1];

        status = colorizeFace(MODL, ibody, iface);
        CHECK_STATUS(colorizeFace);

        /* update the Edge valence info */
        status = EG_getBodyTopos(ebody, efaces[iface-1], EDGE, &nchild, &echilds);
        CHECK_STATUS(EG_getBodyTopos);

        for (ichild = 0; ichild < nchild; ichild++) {
            if (echilds[ichild] == NULL) continue;

            iedge = status = EG_indexBodyTopo(ebody, echilds[ichild]);
            CHECK_STATUS(EG_indexBodyTopos);

            body->edge[iedge].nface++;
        }

        EG_free(echilds);
    }

    EG_free(efaces);

    nedge = body->nedge;
    nface = body->nface;

    /* special treatment for an isolated WireBody (.nface==0) */
    if (nface == 0) {
        for (iedge = 1; iedge <= nedge; iedge++) {

            /* WireBody that is a transform of a previous WireBody */
            if (body->ileft > 0 && body->brtype != OCSM_SKEND && body->brtype != OCSM_JOIN) {
                body->edge[iedge].ibody = MODL->body[body->ileft].edge[iedge].ibody;
                body->edge[iedge].iford = MODL->body[body->ileft].edge[iedge].iford;

            /* newly created WireBody */
            } else {
                body->edge[iedge].ibody = ibody;
                body->edge[iedge].iford = iedge;
            }
        }
    }

    /* store Csystem on this Body */
    (void) storeCsystem(MODL, ibody);
    if (MODL->sigCode != SUCCESS) {
        status = freeBody(MODL, ibody);
        MODL->nbody--;
        goto cleanup;
    }

    /* set up ileft and irite on the adjacent Edges */
    for (iface = 1; iface <= nface; iface++) {
        status = EG_getTopology(body->face[iface].eface, &eref,
                                &oclass, &mtype, data, &nloop, &eloops, &senses);
        CHECK_STATUS(EG_getTopology);

        for (iloop = 0; iloop < nloop; iloop++) {
            status = EG_getTopology(eloops[iloop], &eref,
                                    &oclass, &mtype, data, &nchild, &echildren, &senses);
            CHECK_STATUS(EG_getTopology);

            for (ichild = 0; ichild < nchild; ichild++) {
                iedge = status = EG_indexBodyTopo(ebody, echildren[ichild]);
                CHECK_STATUS(EG_indexBodyTopo);

                if (iedge < 1 || iedge > body->nedge) {
                    signalError(MODL, OCSM_INTERNAL_ERROR,
                                "echildren[%d] not found in body", ichild);
                    status = OCSM_INTERNAL_ERROR;
                    goto cleanup;
                }

                if (senses[ichild] == SFORWARD) {
                    body->edge[iedge].ileft = iface;
                } else {
                    body->edge[iedge].irite = iface;
                }
            }
        }
    }

    PPRINT1(done initializing %d Faces, nface);

    /* retrieve the Marks from the Edge and Face Attributes */
    for (iedge = 1; iedge <= nedge; iedge++) {
        eedge = body->edge[iedge].eedge;
        status = EG_attributeRet(eedge, "mark", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);

        if (status == SUCCESS && nlist > 0) {
            body->edge[iedge].imark = tempIlist[0];
        }
    }

    for (iface = 1; iface <= nface; iface++) {
        eface = body->face[iface].eface;
        status = EG_attributeRet(eface, "mark", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);

        if (status == SUCCESS && nlist > 0) {
            body->face[iface].imark = tempIlist[0];
        }
    }

    /* retrieve the Branch and Face order from the Faces Attributes */
    for (iface = 1; iface <= nface; iface++) {
        eface = body->face[iface].eface;
        status = EG_attributeRet(eface, "_body", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);

        if        (status == SUCCESS && nlist == 2) {
            body->face[iface].ibody = tempIlist[0];
            body->face[iface].iford = tempIlist[1];
        } else if (status == SUCCESS && nlist == 1) {
            body->face[iface].ibody = tempIlist[0];
            body->face[iface].iford = -1;
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "\"body\" attribute error for iface=%d (nlist=%d)", iface, nlist);
            SET_STATUS(OCSM_INTERNAL_ERROR, no_attribute);
        }

        status = EG_attributeRet(eface, "mark", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);

        if (status == SUCCESS && nlist > 0) {
            body->face[iface].imark = tempIlist[0];
        }
    }

    /* add an Attribute to each Face to say that is was included
       in this Body */
    for (iface = 1; iface <= nface; iface++) {
        status = EG_attributeRet(body->face[iface].eface, "_hist",
                                 &atype, &alen, &tempIlist, &tempRlist, &tempClist);

        if (status != SUCCESS) {
            status = EG_attributeAdd(body->face[iface].eface, "_hist", ATTRINT,
                                     1, &ibody, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);
        } else if (atype != ATTRINT) {
            status = OCSM_INTERNAL_ERROR;
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "_hist is not an integer Attribute");
            goto cleanup;
        } else {
            MALLOC(newIlist, int, alen+1);
            for (i = 0; i < alen; i++) {
                newIlist[i] = tempIlist[i];
            }
            newIlist[alen] = ibody;

            status = EG_attributeAdd(body->face[iface].eface, "_hist", ATTRINT,
                                     alen+1, newIlist, NULL, NULL);
            FREE(newIlist);
            CHECK_STATUS(EG_attributeAdd);
        }
    }

    /* delete old Edge Attributes (that may be copied onto entities
       by EGADS) */
    noTopoChange = EG_attributeRet(ebody, "__noTopoChange__",
                                   &itype, &nlist,
                                   &tempIlist, &tempRlist, &tempClist);
    keepEdgeAttr = EG_attributeRet(ebody, "__keepEdgeAttr__",
                                   &itype, &nlist,
                                   &tempIlist, &tempRlist, &tempClist);
    if (noTopoChange != SUCCESS                    &&
        keepEdgeAttr != SUCCESS                    &&
        MODL->brch[ibrch].bclass != OCSM_TRANSFORM &&
        MODL->brch[ibrch].type   != OCSM_UDPRIM    &&
        MODL->brch[ibrch].type   != OCSM_IMPORT      ) {
        for (iedge = 1; iedge <= nedge; iedge++) {
            status = EG_attributeNum(body->edge[iedge].eedge, &nattr);
            CHECK_STATUS(EG_attributeNum);

            /* this special treatment is needed since scribe Edges get the
               _faceID of the scribing Face */
            for (iattr = nattr-1; iattr >= 0; iattr--) {
                status = EG_attributeGet(body->edge[iedge].eedge, iattr+1, &aname3, &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeGet);

                if (strcmp(aname3, "__scribeID__") != 0) {
                    status = EG_attributeDel(body->edge[iedge].eedge, aname3);
                    CHECK_STATUS(EG_attributeDel);
                }
            }
        }

        if (keepEdgeAttr == SUCCESS) {
            status = EG_attributeDel(ebody, "__keepEdgeAttr__");
            CHECK_STATUS(EG_attributeDel);
        }
    }

    /* set up the Branch and iford for each Edge */
    for (iedge = 1; iedge <= nedge; iedge++) {
        ileft = body->edge[iedge].ileft;
        irite = body->edge[iedge].irite;

        /* non-manifold with rite neighbor */
        if (ileft < 1 && irite > 0) {
            body->edge[iedge].ibody = body->face[irite].ibody;
            body->edge[iedge].iford = -3;

        /* non-manifold with left neighbor */
        } else if (ileft > 0 && irite < 1) {
            body->edge[iedge].ibody = body->face[ileft].ibody;
            body->edge[iedge].iford = -3;

        /* non-manifold without any neighbors */
        } else if (ileft < 1 || irite < 1) {
            /* do nothing */

        /* if ileft and irite have same Body, then Edge has that Body too */
        } else if (body->face[ileft].ibody == body->face[irite].ibody) {
            body->edge[iedge].ibody = body->face[ileft].ibody;
            body->edge[iedge].iford = 100 * body->face[ileft].iford
                                          + body->face[irite].iford;

        /* if either ileft or irite is a FILLET, CHAMFER, CONNECT, or HOLLOW,
           then Edge is associated with it */
        } else if (MODL->body[body->face[ileft].ibody].brtype == OCSM_FILLET  ||
                   MODL->body[body->face[ileft].ibody].brtype == OCSM_CHAMFER ||
                   MODL->body[body->face[ileft].ibody].brtype == OCSM_CONNECT ||
                   MODL->body[body->face[ileft].ibody].brtype == OCSM_HOLLOW    ) {
            body->edge[iedge].ibody = body->face[ileft].ibody;
            body->edge[iedge].iford = 0;

        } else if (MODL->body[body->face[irite].ibody].brtype == OCSM_FILLET  ||
                   MODL->body[body->face[irite].ibody].brtype == OCSM_CHAMFER ||
                   MODL->body[body->face[irite].ibody].brtype == OCSM_CONNECT ||
                   MODL->body[body->face[irite].ibody].brtype == OCSM_HOLLOW    ) {
            body->edge[iedge].ibody = body->face[irite].ibody;
            body->edge[iedge].iford = 0;

        /* search up the tree to find the first common Body */
        } else {
            body->edge[iedge].ibody = -4;
            body->edge[iedge].iford = -4;

            /* get the _hist for the left and rite Faces */
            status = EG_attributeRet(body->face[ileft].eface, "_hist",
                                     &itype, &nlist2,
                                     &tempIlist2, &tempRlist2, &tempClist2);
            CHECK_STATUS(EG_attributeRet);

            status = EG_attributeRet(body->face[irite].eface, "_hist",
                                     &itype, &nlist3,
                                     &tempIlist3, &tempRlist3, &tempClist3);
            CHECK_STATUS(EG_attributeRet);

            /* look for the first Body that both ileft and irite have in the _hist */
            for (jbody = 1; jbody <= ibody; jbody++) {
                found = 0;
                for (i = 0; i < nlist2; i++) {
                    if (tempIlist2[i] == jbody) {
                        found++;
                        break;
                    }
                }
                for (i = 0; i < nlist3; i++) {
                    if (tempIlist3[i] == jbody) {
                        found++;
                        break;
                    }
                }
                if (found == 2) {
                    body->edge[iedge].ibody = jbody;
                    body->edge[iedge].iford = 0;
                    break;
                }
            }
        }
    }

    /* color Edges as:
       non-manifold (brown)  if .nface <  2
       non-manifold (orange) if .nface >  2
       interior     (green)  if .iford != 0
       exterior     (blue)   otherwise */
    for (iedge = 1; iedge <= nedge; iedge++) {
        if        (body->edge[iedge].nface < 2) {
            body->edge[iedge].gratt.color = 0x008b4513;          /* brown */
        } else if (body->edge[iedge].nface > 2) {
            body->edge[iedge].gratt.color = 0x00ffa500;          /* orange */
        } else if (body->edge[iedge].iford != 0) {
            body->edge[iedge].gratt.color = 0x0000ff00;          /* green */
        } else {
            body->edge[iedge].gratt.color = 0x000000ff;          /* blue  */
        }

        status = colorizeEdge(MODL, ibody, iedge);
        CHECK_STATUS(colorizeEdge);
    }

    /* set up the Body for each Node */
    for (iedge = 1; iedge <= nedge; iedge++) {
        ibeg = body->edge[iedge].ibeg;
        iend = body->edge[iedge].iend;

        assert(ibeg > 0);                         /* needed to avoid clang warning */
        assert(ibeg <= body->nnode);              /* needed to avoid clang warning */
        assert(iend > 0);                         /* needed to avoid clang warning */
        assert(iend <= body->nnode);              /* needed to avoid clang warning */

        if (body->edge[iedge].ibody > body->node[ibeg ].ibody) {
            body->node[ibeg ].ibody = body->edge[iedge].ibody;
        }

        if (body->edge[iedge].ibody > body->node[iend ].ibody) {
            body->node[iend ].ibody = body->edge[iedge].ibody;
        }
    }

    /* if a NodeBody, set the Body for the Node either as itself or its left parent */
    if (body->botype == OCSM_NODE_BODY) {
        if (body->ileft < 0) {
            body->node[1].ibody = ibody;
        } else {
            body->node[1].ibody = MODL->body[body->ileft].node[1].ibody;
        }
    }

    /* store the Body and Face order as Attributes for each Edge */
    for (iedge = 1; iedge <= nedge; iedge++) {
        eedge = body->edge[iedge].eedge;
        iattrib[0] = body->edge[iedge].ibody;
        iattrib[1] = body->edge[iedge].iford;

        status = EG_attributeAdd(eedge, "_body", ATTRINT,
                                 2, iattrib, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* report un-attributed Edges and Faces (but not if non-manifold)*/
    for (iedge = 1; iedge <= nedge; iedge++) {
        if        (body->edge[iedge].nface >   2) {

        } else if (body->edge[iedge].iford == -3) {

        } else if (body->edge[iedge].ibody <=  0 ||
                   body->edge[iedge].iford <   0   ) {
            SPRINT4(1, "WARNING:: Edge %d:%3d has .ibody=%d  .iford=%d",
                    ibody, iedge, body->edge[iedge].ibody,
                    body->edge[iedge].iford);
            (MODL->nwarn)++;
        }
    }

    for (iface = 1; iface <= nface; iface++) {
        if (body->face[iface].ibody <= 0 ||
            body->face[iface].iford <  0   ) {
            SPRINT4(1, "WARNING:: Face %d:%3d has .ibody=%d  .iford=%d",
                    ibody, iface, body->face[iface].ibody,
                    body->face[iface].iford);
            (MODL->nwarn)++;
        }
    }

    /* if there are no topological changes, do not adjust any of
       the faceIDs, edgeIDs, or Attributes */
    status = EG_attributeRet(ebody, "__noTopoChange__",
                             &itype, &nlist,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        status = dumpEgadsFile(MODL, ibody);
        CHECK_STATUS(dumpEgadsFile);

        status = EG_attributeDel(ebody, "__noTopoChange__");
        CHECK_STATUS(EG_attributeDel);

        goto cleanup;
    }

    /* remove the faceID from all Faces, edgeID from all Edges,
       and nodeID from all Nodes */
    for (iface = 1; iface <= nface; iface++) {
        status = EG_attributeRet(body->face[iface].eface, "_faceID",
                                 &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS) {
            status = EG_attributeDel(body->face[iface].eface, "_faceID");
            CHECK_STATUS(EG_attributeDel);
        }
    }

    for (iedge = 1; iedge <= nedge; iedge++) {
        status = EG_attributeRet(body->edge[iedge].eedge, "_edgeID",
                                 &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS) {
            status = EG_attributeDel(body->edge[iedge].eedge, "_edgeID");
            CHECK_STATUS(EG_attributeDel);
        }
    }

    for (inode = 1; inode <= nnode; inode++) {
        status = EG_attributeRet(body->node[inode].enode, "_nodeID",
                                 &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS) {
            status = EG_attributeDel(body->node[inode].enode, "_nodeID");
            CHECK_STATUS(EG_attributeDel);
        }
    }

    PPRINT0(done adding Face attributes);

    /* create a red/black tree to hold all _faceIDs */
    status = rbtCreate(nface, &rbt);
    CHECK_STATUS(rbtCreate);

    MALLOC(needSeq, int, nface+1);

    /* transfer the _body Attribute to the _faceID */
    icount = 0;

    for (iface = 1; iface <= nface; iface++) {
        needSeq[iface] = 0;
        status = EG_attributeRet(body->face[iface].eface, "_body",
                                 &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        iattrib[0] = tempIlist[0];
        iattrib[1] = tempIlist[1];
        iattrib[2] = 1;

        /* check to see if we have another _faceID with the same two initial entries */
        inode = rbtSearch(rbt, iattrib[0], iattrib[1], 0, 0);

        /* if not, add it now */
        if (inode < 0) {
            status = rbtInsert(rbt, iattrib[0], iattrib[1], 0, 0, iface);
            CHECK_STATUS(rbtInsert);

        /* otherwise increment the sequence number until it is unique */
        } else {
            icount++;
            needSeq[iface] = 1;
            needSeq[rbtLookup(rbt, inode)] = 1;

            for (jface = 1; jface < iface; jface++) {
                status = EG_attributeRet(body->face[jface].eface, "_faceID",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlist[0] == iattrib[0] &&
                    tempIlist[1] == iattrib[1]   ) {
                    iattrib[2] ++;
                }
            }
        }

        /* now add the initial _faceID */
        status = EG_attributeAdd(body->face[iface].eface, "_faceID", ATTRINT,
                                 3, iattrib, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* delete the RBT */
    status = rbtDelete(rbt);
    CHECK_STATUS(rbtDelete);

    rbt = NULL;

    PPRINT0(done with initial _faceID);

    /* reorder the faceIDs based upon cg location when sequence > 1 */
    if (icount > 0) {
        MALLOC(area, double, nface+1);
        MALLOC(xcg,  double, nface+1);
        MALLOC(ycg,  double, nface+1);
        MALLOC(zcg,  double, nface+1);

        /* store flag such that mass properties are computed when needed */
        for (iface = 1; iface <= nface; iface++) {
            area[iface] = -1;
        }

        icount = 0;
        nswap  = 1;
        while (nswap > 0) {
            icount++;
            nswap = 0;

            /* look for Faces that might have seq num > 1 */
            for (iface = 1; iface <= nface; iface++) {
                if (needSeq[iface] == 0) continue;

                status = EG_attributeRet(body->face[iface].eface, "_faceID",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                iattrib[0] = tempIlist[0];
                iattrib[1] = tempIlist[1];
                iattrib[2] = tempIlist[2];

                for (jface = 1; jface <= nface; jface++) {
                    if (needSeq[jface] == 0) continue;

                    status = EG_attributeRet(body->face[jface].eface, "_faceID",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeRet);

                    jattrib[0] = tempIlist[0];
                    jattrib[1] = tempIlist[1];
                    jattrib[2] = tempIlist[2];

                    if (iattrib[0] == jattrib[0] &&
                        iattrib[1] == jattrib[1] &&
                        iattrib[2] >  jattrib[2]   ) {

                        /* get the mass properties if we do not have them yet */
                        if (area[iface] < 0) {
                            status = EG_getMassProperties(body->face[iface].eface, data);
                            CHECK_STATUS(EG_getMassProperties);

                            area[iface] = data[1];
                            xcg[ iface] = data[2];
                            ycg[ iface] = data[3];
                            zcg[ iface] = data[4];
                        }

                        if (area[jface] < 0) {
                            status = EG_getMassProperties(body->face[jface].eface, data);
                            CHECK_STATUS(EG_getMassProperties);

                            area[jface] = data[1];
                            xcg[ jface] = data[2];
                            ycg[ jface] = data[3];
                            zcg[ jface] = data[4];
                        }

                        /* determine if we need a swap */
                        iswap = 0;
                        if        (fabs(xcg[iface]-xcg[jface]) > EPS06) {
                            if (xcg[iface] < xcg[jface]) {
                                iswap = 1;
                            }
                        } else if (fabs(ycg[iface]-ycg[jface]) > EPS06) {
                            if (ycg[iface] < ycg[jface]) {
                                iswap = 1;
                            }
                        } else if (fabs(zcg[iface]-zcg[jface]) > EPS06) {
                            if (zcg[iface] < zcg[jface]) {
                                iswap = 1;
                            }
                        } else if (area[iface] < area[jface]) {
                            iswap = 1;
                        }

                        /* perform the swap */
                        if (iswap > 0) {
                            status = EG_attributeAdd(body->face[iface].eface, "_faceID", ATTRINT,
                                                     3, jattrib, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            status = EG_attributeAdd(body->face[jface].eface, "_faceID", ATTRINT,
                                                     3, iattrib, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            iattrib[0] = jattrib[0];
                            iattrib[1] = jattrib[1];
                            iattrib[2] = jattrib[2];

                            nswap++;
                        }
                    }
                }
            }

            /* if a possible infinite loop because different criteria are
               used in different passes, post a warning and continue */
            if (nswap > 0 && icount > 2*nedge) {
                SPRINT0(1, "WARNING:: _faceID:iseq may be unusable");
                (MODL->nwarn)++;
                break;
            }
        }

        FREE(zcg );
        FREE(ycg );
        FREE(xcg );
        FREE(area);

        PPRINT0(done resolving _faceID sequence numbers);
    }

    FREE(needSeq);

    /* create a red/lack tree to hold all _edgeIDs */
    status = rbtCreate(nedge, &rbt);
    CHECK_STATUS(rbtCreate);

    MALLOC(needSeq, int, nedge+1);

    /* add the _edgeID Attribute to all Edges */
    icount = 0;

    for (iedge = 1; iedge <= nedge; iedge++) {
        needSeq[iedge] = 0;

        ileft = body->edge[iedge].ileft;
        if (ileft >= 0) {
            status = EG_attributeRet(body->face[ileft].eface, "_body",
                                     &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);

            iattrib[0] = tempIlist[0];
            iattrib[1] = tempIlist[1];
        } else {
            iattrib[0] = 0;
            iattrib[1] = 0;
        }

        irite = body->edge[iedge].irite;
        if (irite >= 0) {
            status = EG_attributeRet(body->face[irite].eface, "_body",
                                     &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);

            iattrib[2] = tempIlist[0];
            iattrib[3] = tempIlist[1];
        } else {
            iattrib[2] = 0;
            iattrib[3] = 0;
        }

        /* special handling for case that comes from a scribe operation
           (this case can be identified by having the same _faceID on
           both adjoining Faces and an Edge with a __scribeID__ attribute) */
        if (iattrib[0] == iattrib[2] && iattrib[1] == iattrib[3]) {
            status = EG_attributeRet(body->edge[iedge].eedge, "__scribeID__",
                                     &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == EGADS_SUCCESS) {
                iattrib[2] = tempIlist[0];
                iattrib[3] = tempIlist[1];
            }
        }

        /* reorder small to large */
        if (100*iattrib[0]+iattrib[1] > 100*iattrib[2]+iattrib[3]) {
            iswap      = iattrib[0];
            iattrib[0] = iattrib[2];
            iattrib[2] = iswap;

            iswap      = iattrib[1];
            iattrib[1] = iattrib[3];
            iattrib[3] = iswap;
        }

        iattrib[4] = 1;

        /* check to see if we have another _edgeID with the same four initial entries */
        inode = rbtSearch(rbt, iattrib[0], iattrib[1], iattrib[2], iattrib[3]);

        /* if not, add it now */
        if (inode < 0) {
            status = rbtInsert(rbt, iattrib[0], iattrib[1], iattrib[2], iattrib[3], iedge);
            CHECK_STATUS(rbtInsert);

        /* otherwise, increment the sequence number until it is unique */
        } else {
            icount++;
            needSeq[iedge] = 1;
            needSeq[rbtLookup(rbt, inode)] = 1;

            for (jedge = 1; jedge < iedge; jedge++) {
                status = EG_attributeRet(body->edge[jedge].eedge, "_edgeID",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlist[0] == iattrib[0] &&
                    tempIlist[1] == iattrib[1] &&
                    tempIlist[2] == iattrib[2] &&
                    tempIlist[3] == iattrib[3]   ) {
                    iattrib[4] ++;
                }
            }
        }

        /* now add the initial _edgeID */
        status = EG_attributeAdd(body->edge[iedge].eedge, "_edgeID", ATTRINT,
                                 5, iattrib, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* delete the RBT */
    status = rbtDelete(rbt);
    CHECK_STATUS(rbtDelete);

    rbt = NULL;

    PPRINT0(done with initial _edgeID);

    /* reorder the edgeIDs based upon cg location when sequence > 1 */
    if (icount > 0) {
        MALLOC(area, double, nedge+1);
        MALLOC(xcg,  double, nedge+1);
        MALLOC(ycg,  double, nedge+1);
        MALLOC(zcg,  double, nedge+1);

        /* store flag that mass properties are compouted when needed */
        for (iedge = 1; iedge <= nedge; iedge++) {
            area[iedge] = -1;
        }

        icount = 0;
        nswap  = 1;
        while (nswap > 0) {
            icount++;
            nswap = 0;

            /* look for Edges that might have seq num > 1 */
            for (iedge = 1; iedge <= nedge; iedge++) {
                if (needSeq[iedge] == 0) continue;

                status = EG_attributeRet(body->edge[iedge].eedge, "_edgeID",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                iattrib[0] = tempIlist[0];
                iattrib[1] = tempIlist[1];
                iattrib[2] = tempIlist[2];
                iattrib[3] = tempIlist[3];
                iattrib[4] = tempIlist[4];

                for (jedge = 1; jedge <= nedge; jedge++) {
                    if (needSeq[jedge] == 0) continue;

                    status = EG_attributeRet(body->edge[jedge].eedge, "_edgeID",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeRet);

                    jattrib[0] = tempIlist[0];
                    jattrib[1] = tempIlist[1];
                    jattrib[2] = tempIlist[2];
                    jattrib[3] = tempIlist[3];
                    jattrib[4] = tempIlist[4];

                    if (iattrib[0] == jattrib[0] &&
                        iattrib[1] == jattrib[1] &&
                        iattrib[2] == jattrib[2] &&
                        iattrib[3] == jattrib[3] &&
                        iattrib[4] >  jattrib[4]   ) {

                        /* get the mass propeties if we do not have them yet */
                        if (area[iedge] < 0) {
                            status = EG_getMassProperties(body->edge[iedge].eedge, data);
                            CHECK_STATUS(EG_getMassProperties);

                            area[iedge] = data[1];
                            xcg[ iedge] = data[2];
                            ycg[ iedge] = data[3];
                            zcg[ iedge] = data[4];
                        }

                        if (area[jedge] < 0) {
                            status = EG_getMassProperties(body->edge[jedge].eedge, data);
                            CHECK_STATUS(EG_getMassProperties);

                            area[jedge] = data[1];
                            xcg[ jedge] = data[2];
                            ycg[ jedge] = data[3];
                            zcg[ jedge] = data[4];
                        }

                        /* determine if we need a swap */
                        iswap = 0;
                        if        (fabs(xcg[iedge]-xcg[jedge]) > EPS06) {
                            if (xcg[iedge] < xcg[jedge]) {
                                iswap = 1;
                            }
                        } else if (fabs(ycg[iedge]-ycg[jedge]) > EPS06) {
                            if (ycg[iedge] < ycg[jedge]) {
                                iswap = 1;
                            }
                        } else if (fabs(zcg[iedge]-zcg[jedge]) > EPS06) {
                            if (zcg[iedge] < zcg[jedge]) {
                                iswap = 1;
                            }
                        } else if (area[iedge] < area[jedge]) {
                            iswap = 1;
                        }

                        /* perform the swap */
                        if (iswap > 0) {
                            status = EG_attributeAdd(body->edge[iedge].eedge, "_edgeID", ATTRINT,
                                                     5, jattrib, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            status = EG_attributeAdd(body->edge[jedge].eedge, "_edgeID", ATTRINT,
                                                     5, iattrib, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            iattrib[0] = jattrib[0];
                            iattrib[1] = jattrib[1];
                            iattrib[2] = jattrib[2];
                            iattrib[3] = jattrib[3];
                            iattrib[4] = jattrib[4];

                            nswap++;
                        }
                    }
                }
            }

            /* if a possible infinite loop because different criteria are
               used in different passes, post a warning and continue */
            if (nswap > 0 && icount > 2*nedge) {
                SPRINT0(1, "WARNING:: _edgeID:iseq may be unusable");
                (MODL->nwarn)++;
                break;
            }
        }

        FREE(zcg );
        FREE(ycg );
        FREE(xcg );
        FREE(area);

        PPRINT0(done resolving _edgeID sequence numbers);
    }

    FREE(needSeq);

    /* persist Edge attributes for any Edge in left or rite parents with a matching _edgeID
       and which has equivalent underlying geometries */
    if (MODL->brch[ibrch].bclass != OCSM_TRANSFORM) {
        ileft = body->ileft;
        irite = body->irite;

        for (iedge = 1; iedge <= nedge; iedge++) {
            status = EG_attributeRet(body->edge[iedge].eedge, "_edgeID",
                                     &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);

            status = EG_getRange(body->edge[iedge].eedge, trange, &periodic);
            CHECK_STATUS(EG_getRange);

            if (ileft > 0 && MODL->body[ileft].ebody != NULL) {
                for (jedge = 1; jedge <= MODL->body[ileft].nedge; jedge++) {

                    status = EG_attributeRet(MODL->body[ileft].edge[jedge].eedge, "_edgeID",
                                             &itype2, &nlist2, &tempIlist2, &tempRlist2, &tempClist2);
                    CHECK_STATUS(EG_attributeRet);

                    status = EG_getRange(MODL->body[ileft].edge[jedge].eedge, trange2, &periodic);
                    CHECK_STATUS(EG_getRange);

                    if (tempIlist[0] == tempIlist2[0]    &&
                        tempIlist[1] == tempIlist2[1]    &&
                        tempIlist[2] == tempIlist2[2]    &&
                        tempIlist[3] == tempIlist2[3]    &&
                        trange[0]    >= trange2[0]-EPS03 &&
                        trange[1]    <= trange2[1]+EPS03   ) {

                        status = EG_getTopology(MODL->body[ileft].edge[jedge].eedge,
                                                &ecurve1, &oclass, &mtype, data, &nchild, &echilds, &senses);
                        CHECK_STATUS(EG_getTopology);

                        status = EG_getTopology(body->edge[iedge].eedge,
                                                &ecurve2, &oclass, &mtype, data, &nchild, &echilds, &senses);
                        CHECK_STATUS(EG_getTopology);

                        status = EG_isSame(ecurve1, ecurve2);
                        if (status == EGADS_SUCCESS) {
                            SPRINT4(2, "Edge %d:%d getting Attributes from left parent %d:%d", ibody, iedge, ileft, jedge);

                            status = EG_attributeNum(MODL->body[ileft].edge[jedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[ileft].edge[jedge].eedge, iattr,
                                                         &aname3, &itype3, &nlist3, &tempIlist3, &tempRlist3, &tempClist3);
                                CHECK_STATUS(EG_attributeGet);

                                if (strcmp(aname3, "_body"  ) != 0 &&
                                    strcmp(aname3, "_edgeID") != 0 &&
                                    strcmp(aname3, "_nface" ) != 0   ) {
                                    SPRINT1(2, "   copying \"%s\"", aname3);

                                    status = EG_attributeAdd(body->edge[iedge].eedge, aname3, itype3,
                                                             nlist3, tempIlist3, tempRlist3, tempClist3);
                                    CHECK_STATUS(EG_attributeAdd);
                                }
                            }

                            status = colorizeEdge(MODL, ibody, iedge);
                            CHECK_STATUS(colorizeEdge);
                        }
                    }
                }
            }

            if (irite > 0 && MODL->body[irite].ebody != NULL) {
                for (jedge = 1; jedge <= MODL->body[irite].nedge; jedge++) {

                    status = EG_attributeRet(MODL->body[irite].edge[jedge].eedge, "_edgeID",
                                             &itype2, &nlist2, &tempIlist2, &tempRlist2, &tempClist2);
                    CHECK_STATUS(EG_attributeRet);

                    status = EG_getRange(MODL->body[irite].edge[jedge].eedge, trange2, &periodic);
                    CHECK_STATUS(EG_getRange);

                    if (tempIlist[0] == tempIlist2[0]    &&
                        tempIlist[1] == tempIlist2[1]    &&
                        tempIlist[2] == tempIlist2[2]    &&
                        tempIlist[3] == tempIlist2[3]    &&
                        trange[0]    >= trange2[0]-EPS03 &&
                        trange[1]    <= trange2[1]+EPS03   ) {

                        status = EG_getTopology(MODL->body[irite].edge[jedge].eedge,
                                                &ecurve1, &oclass, &mtype, data, &nchild, &echilds, &senses);
                        CHECK_STATUS(EG_getTopology);

                        status = EG_getTopology(body->edge[iedge].eedge,
                                                &ecurve2, &oclass, &mtype, data, &nchild, &echilds, &senses);
                        CHECK_STATUS(EG_getTopology);

                        status = EG_isSame(ecurve1, ecurve2);
                        if (status == EGADS_SUCCESS) {
                            SPRINT4(2, "Edge %d:%d getting Attributes from rite parent %d:%d", ibody, iedge, irite, jedge);

                            status = EG_attributeNum(MODL->body[irite].edge[jedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[irite].edge[jedge].eedge, iattr,
                                                         &aname3, &itype3, &nlist3, &tempIlist3, &tempRlist3, &tempClist3);
                                CHECK_STATUS(EG_attributeGet);

                                if (strcmp(aname3, "_body"  ) != 0 &&
                                    strcmp(aname3, "_edgeID") != 0 &&
                                    strcmp(aname3, "_nface" ) != 0   ) {
                                    SPRINT1(2, "   copying \"%s\"", aname3);

                                    status = EG_attributeAdd(body->edge[iedge].eedge, aname3, itype3,
                                                             nlist3, tempIlist3, tempRlist3, tempClist3);
                                    CHECK_STATUS(EG_attributeAdd);
                                }
                            }

                            status = colorizeEdge(MODL, ibody, iedge);
                            CHECK_STATUS(colorizeEdge);
                        }
                    }
                }
            }
        }

        PPRINT0(done persisting _edgeID from parent);

        /* persist Node attributes for any Node that matches the transformed Node
           location in the parent */
        for (inode = 1; inode <= nnode; inode++) {
            if (MODL->brch[ibrch].type == OCSM_UDPRIM) continue;
            if (MODL->brch[ibrch].type == OCSM_IMPORT) continue;

            /* start by removing any old attributes */
            status = EG_attributeDel(body->node[inode].enode, NULL);
            CHECK_STATUS(EG_attributeDel);

            /* find transformation in left parent */
            ileft = body->ileft;
            found = 0;
            if (ileft > 0) {
                for (jnode = 1; jnode <= MODL->body[ileft].nnode; jnode++) {
                    xparent = MODL->body[ileft].node[jnode].x;
                    yparent = MODL->body[ileft].node[jnode].y;
                    zparent = MODL->body[ileft].node[jnode].z;

                    if        (body->brtype == OCSM_TRANSLATE) {
                        xparent += body->arg[1].val[0];
                        yparent += body->arg[2].val[0];
                        zparent += body->arg[3].val[0];
                    } else if (body->brtype == OCSM_ROTATEX) {
                        cosx = cos(body->arg[1].val[0] * PIo180);
                        sinx = sin(body->arg[1].val[0] * PIo180);
                        dy   =     body->arg[2].val[0];
                        dz   =     body->arg[3].val[0];

                        yold = yparent;
                        zold = zparent;

                        yparent = dy + cosx * (yold - dy) - sinx * (zold - dz);
                        zparent = dz + sinx * (yold - dy) + cosx * (zold - dz);
                    } else if (body->brtype == OCSM_ROTATEY) {
                        cosy = cos(body->arg[1].val[0] * PIo180);
                        siny = sin(body->arg[1].val[0] * PIo180);
                        dz   =     body->arg[2].val[0];
                        dx   =     body->arg[3].val[0];

                        xold = xparent;
                        zold = zparent;

                        xparent = dx + cosy * (xold - dx) + siny * (zold - dz);
                        zparent = dz - siny * (xold - dx) + cosy * (zold - dz);
                    } else if (body->brtype == OCSM_ROTATEZ) {
                        cosz = cos(body->arg[1].val[0] * PIo180);
                        sinz = sin(body->arg[1].val[0] * PIo180);
                        dx   =     body->arg[2].val[0];
                        dy   =     body->arg[3].val[0];

                        xold = xparent;
                        yold = yparent;

                        xparent = dx + cosz * (xold - dx) - sinz * (yold - dy);
                        yparent = dy + sinz * (xold - dx) + sinz * (yold - dy);
                    } else if (body->brtype == OCSM_SCALE) {
                        fact  = body->arg[1].val[0];
                        xcent = body->arg[2].val[0];
                        ycent = body->arg[3].val[0];
                        zcent = body->arg[4].val[0];

                        xparent = xparent * fact + xcent * (1 - fact);
                        yparent = yparent * fact + ycent * (1 - fact);
                        zparent = zparent * fact + zcent * (1 - fact);
                    } else if (body->brtype == OCSM_MIRROR) {
                        nx   = body->arg[1].val[0];
                        ny   = body->arg[2].val[0];
                        nz   = body->arg[3].val[0];
                        dist = body->arg[4].val[0];

                        fact  = sqrt(nx*nx + ny*ny + nz*nz);
                        dx    = nx / fact;
                        dy    = ny / fact;
                        dz    = nz / fact;

                        xold = xparent;
                        yold = yparent;
                        zold = zparent;

                        xparent = (1-2*dx*dx) * xold + ( -2*dy*dx) * yold + ( -2*dz*dx) * zold + 2*dist*dx;
                        yparent = ( -2*dx*dy) * xold + (1-2*dy*dy) * yold + ( -2*dz*dy) * zold + 2*dist*dy;
                        zparent = ( -2*dx*dz) * xold + ( -2*dy*dz) * yold + (1-2*dz*dz) * zold + 2*dist*dz;
                    }

                    if (fabs(body->node[inode].x-xparent) < EPS06 &&
                        fabs(body->node[inode].y-yparent) < EPS06 &&
                        fabs(body->node[inode].z-zparent) < EPS06   ) {
                        SPRINT4(2, "Node %d:%d getting Attributes from left parent %d:%d", ibody, inode, ileft, jnode);
                        found = jnode;
                        break;
                    }
                }

                if (found > 0) {
                    status = EG_attributeNum(MODL->body[ileft].node[found].enode, &nattr);
                    CHECK_STATUS(EG_attributeNum);

                    for (iattr = 1; iattr <= nattr; iattr++) {
                        status = EG_attributeGet(MODL->body[ileft].node[found].enode, iattr,
                                                 &aname3, &atype, &alen, &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeGet);

                        if (strcmp(aname3, "_nodeID") != 0 && strcmp(aname3, "_nedge") != 0) {
                            status = EG_attributeAdd(body->node[inode].enode, aname3, atype, alen,
                                                     tempIlist, tempRlist, tempClist);
                            CHECK_STATUS(EG_attributeAdd);
                        }
                    }
                }
            }

            irite = body->irite;
            found = 0;
            if (irite > 0) {
                for (jnode = 1; jnode <= MODL->body[irite].nnode; jnode++) {
                    xparent = MODL->body[irite].node[jnode].x;
                    yparent = MODL->body[irite].node[jnode].y;
                    zparent = MODL->body[irite].node[jnode].z;

                    if        (body->brtype == OCSM_TRANSLATE) {
                        xparent += body->arg[1].val[0];
                        yparent += body->arg[2].val[0];
                        zparent += body->arg[3].val[0];
                    } else if (body->brtype == OCSM_ROTATEX) {
                        cosx = cos(body->arg[1].val[0] * PIo180);
                        sinx = sin(body->arg[1].val[0] * PIo180);
                        dy   =     body->arg[2].val[0];
                        dz   =     body->arg[3].val[0];

                        yold = yparent;
                        zold = zparent;

                        yparent = dy + cosx * (yold - dy) - sinx * (zold - dz);
                        zparent = dz + sinx * (yold - dy) + cosx * (zold - dz);
                    } else if (body->brtype == OCSM_ROTATEY) {
                        cosy = cos(body->arg[1].val[0] * PIo180);
                        siny = sin(body->arg[1].val[0] * PIo180);
                        dz   =     body->arg[2].val[0];
                        dx   =     body->arg[3].val[0];

                        xold = xparent;
                        zold = zparent;

                        xparent = dx + cosy * (xold - dx) + siny * (zold - dz);
                        zparent = dz - siny * (xold - dx) + cosy * (zold - dz);
                    } else if (body->brtype == OCSM_ROTATEZ) {
                        cosz = cos(body->arg[1].val[0] * PIo180);
                        sinz = sin(body->arg[1].val[0] * PIo180);
                        dx   =     body->arg[2].val[0];
                        dy   =     body->arg[3].val[0];

                        xold = xparent;
                        yold = yparent;

                        xparent = dx + cosz * (xold - dx) - sinz * (yold - dy);
                        yparent = dy + sinz * (xold - dx) + sinz * (yold - dy);
                    } else if (body->brtype == OCSM_SCALE) {
                        fact  = body->arg[1].val[0];
                        xcent = body->arg[2].val[0];
                        ycent = body->arg[3].val[0];
                        zcent = body->arg[4].val[0];

                        xparent = xparent * fact + xcent * (1 - fact);
                        yparent = yparent * fact + ycent * (1 - fact);
                        zparent = zparent * fact + zcent * (1 - fact);
                    } else if (body->brtype == OCSM_MIRROR) {
                        nx   = body->arg[1].val[0];
                        ny   = body->arg[2].val[0];
                        nz   = body->arg[3].val[0];
                        dist = body->arg[4].val[0];

                        fact  = sqrt(nx*nx + ny*ny + nz*nz);
                        dx    = nx / fact;
                        dy    = ny / fact;
                        dz    = nz / fact;

                        xold = xparent;
                        yold = yparent;
                        zold = zparent;

                        xparent = (1-2*dx*dx) * xold + ( -2*dy*dx) * yold + ( -2*dz*dx) * zold + 2*dist*dx;
                        yparent = ( -2*dx*dy) * xold + (1-2*dy*dy) * yold + ( -2*dz*dy) * zold + 2*dist*dy;
                        zparent = ( -2*dx*dz) * xold + ( -2*dy*dz) * yold + (1-2*dz*dz) * zold + 2*dist*dz;
                    }

                    if (fabs(body->node[inode].x-xparent) < EPS06 &&
                        fabs(body->node[inode].y-yparent) < EPS06 &&
                        fabs(body->node[inode].z-zparent) < EPS06   ) {
                        SPRINT4(2, "Node %d:%d getting Attributes from rite parent %d:%d", ibody, inode, ileft, jnode);
                        found = jnode;
                        break;
                    }
                }

                if (found > 0) {
                    status = EG_attributeNum(MODL->body[irite].node[found].enode, &nattr);
                    CHECK_STATUS(EG_attributeNum);

                    for (iattr = 1; iattr <= nattr; iattr++) {
                        status = EG_attributeGet(MODL->body[irite].node[found].enode, iattr,
                                                 &aname3, &atype, &alen, &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeGet);

                        if (strcmp(aname3, "_nodeID") != 0 && strcmp(aname3, "_nedge") != 0) {
                            status = EG_attributeAdd(body->node[inode].enode, aname3, atype, alen,
                                                     tempIlist, tempRlist, tempClist);
                            CHECK_STATUS(EG_attributeAdd);
                        }
                    }
                }
            }
        }

        PPRINT0(done persisting _nodeID from parent);
    }

    /* add the _nodeID Attribute to all Nodes */
    for (inode = 1; inode <= nnode; inode++) {
        status = EG_attributeAdd(body->node[inode].enode, "_nodeID", ATTRINT,
                                 1, &inode, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    PPRINT0(done adding _nodeID);

    /* add an Attribute to each Edge telling how many incident Faces it has */
    for (iedge = 1; iedge <= nedge; iedge++) {
        status = EG_attributeAdd(body->edge[iedge].eedge, "_nface", ATTRINT,
                                 1, &(body->edge[iedge].nface), NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);

#ifdef EDGE_HIST_TRANSFORM
        /* check if _hist was transferred */
        status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_hist",
                                 &atype, &alen, &tempIlist, &tempRlist, &tempClist);

        if (status == SUCCESS) {

            if (atype != ATTRINT) {
                status = OCSM_INTERNAL_ERROR;
                signalError(MODL, OCSM_INTERNAL_ERROR,
                            "_hist is not an integer Attribute");
                goto cleanup;
            }

            MALLOC(newIlist, int, alen+1);
            for (i = 0; i < alen; i++) {
                newIlist[i] = tempIlist[i];
            }
            newIlist[alen] = ibody;

            status = EG_attributeAdd(MODL->body[ibody].edge[iedge].eedge, "_hist", ATTRINT,
                                     alen+1, newIlist, NULL, NULL);
            FREE(newIlist);
            CHECK_STATUS(EG_attributeAdd);
            continue;
        }


        /* jbody is the Body in which this Edge first appeared */
        jbody = MODL->body[ibody].edge[iedge].ibody;

        /* find the Edge in jbody that maps to Edge iedge in ibody */
        if (jbody == ibody) {
            jedge = iedge;
        } else {

            if (jbody <= 0) {
                status = OCSM_INTERNAL_ERROR;
                signalError(MODL, OCSM_INTERNAL_ERROR,
                            "_hist invalid jbody");
                goto cleanup;
            }

            status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_edgeID",
                                     &atype, &alen, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);

            jedge = -1;

            /* try matching _edgeID, including iseq */
            for (kedge = 1; kedge <= MODL->body[jbody].nedge; kedge++) {
                status = EG_attributeRet(MODL->body[jbody].edge[kedge].eedge, "_edgeID",
                                         &atype, &alen, &tempIlist2, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlist[0] == tempIlist2[0] &&
                    tempIlist[1] == tempIlist2[1] &&
                    tempIlist[2] == tempIlist2[2] &&
                    tempIlist[3] == tempIlist2[3] &&
                    tempIlist[4] == tempIlist2[4]   ) {
                    jedge = kedge;
                    break;
                }
            }

            /* if that diddn't work, try matching _edgeID, ignoring iseq */
            if (jedge == -1) {
                for (kedge = 1; kedge <= MODL->body[jbody].nedge; kedge++) {
                    status = EG_attributeRet(MODL->body[jbody].edge[kedge].eedge, "_edgeID",
                                             &atype, &alen, &tempIlist2, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeRet);

                    if (tempIlist[0] == tempIlist2[0] &&
                        tempIlist[1] == tempIlist2[1] &&
                        tempIlist[2] == tempIlist2[2] &&
                        tempIlist[3] == tempIlist2[3]   ) {
                        jedge = kedge;
                        break;
                    }
                }
            }
        }

        if (jedge == -1) {
            /* if the edge is not found assume it is new */
            status = EG_attributeAdd(MODL->body[ibody].edge[iedge].eedge, "_hist", ATTRINT,
                                     1, &ibody, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);
            continue;
        }

        /* check if _hist is in the original edge (which might be the current body) */
        status = EG_attributeRet(MODL->body[jbody].edge[jedge].eedge, "_hist",
                                 &atype, &alen, &tempIlist, &tempRlist, &tempClist);

        if (status != SUCCESS) {
            status = EG_attributeAdd(MODL->body[ibody].edge[iedge].eedge, "_hist", ATTRINT,
                                     1, &ibody, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);
        } else if (atype != ATTRINT) {
            status = OCSM_INTERNAL_ERROR;
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "_hist is not an integer Attribute");
            goto cleanup;
        } else {
            MALLOC(newIlist, int, alen+1);
            for (i = 0; i < alen; i++) {
                newIlist[i] = tempIlist[i];
            }
            newIlist[alen] = ibody;

            status = EG_attributeAdd(MODL->body[ibody].edge[iedge].eedge, "_hist", ATTRINT,
                                     alen+1, newIlist, NULL, NULL);
            FREE(newIlist);
            CHECK_STATUS(EG_attributeAdd);
        }
#endif
    }

    /* add an Attribute to each Node telling how many incident Edges it has */
    for (inode = 1; inode <= nnode; inode++) {
        status = EG_attributeAdd(body->node[inode].enode, "_nedge", ATTRINT,
                                 1, &(body->node[inode].nedge), NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* dump a copy of this Body */
    status = dumpEgadsFile(MODL, ibody);
    CHECK_STATUS(dumpEgadsFile);

    /* restore status in cases where an interim error occurred above */
    status = EGADS_SUCCESS;

cleanup:
    PPRINT0(exit finish);

    FREE(zcg );
    FREE(ycg );
    FREE(xcg );
    FREE(area);
    FREE(needSeq);

    if (MODL != NULL) {
        if (MODL->body != NULL) {
            if (MODL->body[ibody].node == NULL) MODL->body[ibody].nnode = 0;
            if (MODL->body[ibody].edge == NULL) MODL->body[ibody].nedge = 0;
            if (MODL->body[ibody].face == NULL) MODL->body[ibody].nface = 0;
        }
    }

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   finishCopy - finish the definition of a restored body              *
 *                                                                      *
 ************************************************************************
 */

static int
finishCopy(modl_T *modl,                /* (in)  pointer to MODL */
           int    isrc,                 /* (in)  Body index of source */
 /*@null@*/double matrix[],             /* (in)  transformation matrix (or NULL) */
           int    ibody)                /* (in)  Body index (1-nbody) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ibrch, ileft, irite;
    int       nnode, nedge, nface, ntemp, inode, iedge, iface;
    ego       ebody, *enodes, *eedges, *efaces;
    body_T    *body=NULL, *src=NULL;
#ifdef PRINT_PROGRESS
    time_t    cpu_beg, cpu_end;
#endif

    ROUTINE(finishCopy);

    /* --------------------------------------------------------------- */

    PPRINT_INIT(enter finishCopy);

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* get Body info */
    src  = &(MODL->body[isrc ]);
    body = &(MODL->body[ibody]);

    /* print ego information */
    if (outLevel >= 3) {
        SPRINT1(3, "finishing Body %d:", ibody);
        ocsmPrintEgo(body->ebody);
    }

    /* create parent/child links in the Branches */
    ibrch = body->ibrch;
    ileft = body->ileft;
    irite = body->irite;

    if (ileft > 0) {
        ileft = MODL->body[ileft].ibrch;

        MODL->brch[ibrch].ileft = ileft;
        MODL->brch[ileft].ichld = ibrch;
    } else {
        MODL->brch[ibrch].ileft = -1;
    }

    if (irite > 0) {
        irite = MODL->body[irite].ibrch;

        MODL->brch[ibrch].irite = irite;
        MODL->brch[irite].ichld = ibrch;
    } else {
        MODL->brch[ibrch].irite = -1;
    }

    MODL->brch[ibrch].ichld = -1;

    PPRINT0(done with parent/child);

    /* if a NULL Body o SketchBody, set up quantities */
    if (body->botype == OCSM_NULL_BODY ||
        body->botype == OCSM_SKETCH      ) {
        body->nnode = 0;
        body->nedge = 0;
        body->nface = 0;

        goto cleanup;
    }

    /* get the number of Nodes, Edges, and Faces associated with this Body */
    ebody = body->ebody;
    nnode = src->nnode;
    nedge = src->nedge;
    nface = src->nface;

    body->nnode = nnode;
    body->nedge = nedge;
    body->nface = nface;

    /* delete old Node, Edge, and Face storage */
    FREE(body->node);
    FREE(body->edge);
    FREE(body->face);

    /* add any Attributes associated with this Branch to this Body */
    ibrch = body->ibrch;

    status = setEgoAttribute(MODL, ibrch, ebody);
    CHECK_STATUS(setEgoAttribute);

    /* add the current Branch as an Attribute for this Body */
    status = EG_attributeAdd(ebody, "_body", ATTRINT,
                             1, &ibody, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(ebody, "_brch", ATTRINT,
                             1, &ibrch, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    body->gratt.object = src->gratt.object;
    body->gratt.active = src->gratt.active;
    body->gratt.color  = src->gratt.color;
    body->gratt.ptsize = src->gratt.ptsize;
    body->gratt.render = src->gratt.render;
    body->gratt.dirty  = src->gratt.dirty;

    PPRINT0(done initializing Body);

    /* initialize the Nodes for this Body */
    MALLOC(body->node, node_T, nnode+1);

    status = EG_getBodyTopos(ebody, NULL, NODE, &ntemp, &enodes);
    CHECK_STATUS(EG_getBodyTopos);

    if (ntemp != nnode) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "ntemp=%d does not match nnode=%d", ntemp, nnode);
        SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
    }

    for (inode = 1; inode <= nnode; inode++) {
        body->node[inode].nedge        = src->node[inode].nedge;
        body->node[inode].ibody        = src->node[inode].ibody;
        body->node[inode].dxyz         = NULL;
        body->node[inode].gratt.object = src->node[inode].gratt.object;
        body->node[inode].gratt.active = src->node[inode].gratt.active;
        body->node[inode].gratt.color  = src->node[inode].gratt.color;
        body->node[inode].gratt.ptsize = src->node[inode].gratt.ptsize;
        body->node[inode].gratt.render = src->node[inode].gratt.render;
        body->node[inode].gratt.dirty  = src->node[inode].gratt.dirty;
        body->node[inode].enode        = enodes[inode-1];

        if (matrix == NULL) {
            body->node[inode].x = src->node[inode].x;
            body->node[inode].y = src->node[inode].y;
            body->node[inode].z = src->node[inode].z;
        } else {
            body->node[inode].x = matrix[ 0] * src->node[inode].x
                                + matrix[ 1] * src->node[inode].y
                                + matrix[ 2] * src->node[inode].z + matrix[ 3];
            body->node[inode].y = matrix[ 4] * src->node[inode].x
                                + matrix[ 5] * src->node[inode].y
                                + matrix[ 6] * src->node[inode].z + matrix[ 7];
            body->node[inode].z = matrix[ 8] * src->node[inode].x
                                + matrix[ 9] * src->node[inode].y
                                + matrix[10] * src->node[inode].z + matrix[1];
        }
    }

    EG_free(enodes);

    PPRINT1(done initializing %d Nodes, nnode);

    /* initialize the Edges for this Body */
    if (body->botype != OCSM_NODE_BODY) {
        if (nedge < 1) {
            SPRINT2(1, "WARNING:: nedge=%d for ibody=%d", nedge, ibody);
            (MODL->nwarn)++;
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

        MALLOC(body->edge, edge_T, nedge+1);

        status = EG_getBodyTopos(ebody, NULL, EDGE, &ntemp, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        if (ntemp != nedge) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "ntemp=%d does not match nedge=%d", ntemp, nedge);
            SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
        }

        for (iedge = 1; iedge <= nedge; iedge++) {
            body->edge[iedge].itype        = src->edge[iedge].itype;
            body->edge[iedge].ibeg         = src->edge[iedge].ibeg;
            body->edge[iedge].iend         = src->edge[iedge].iend;
            body->edge[iedge].ileft        = src->edge[iedge].ileft;
            body->edge[iedge].irite        = src->edge[iedge].irite;
            body->edge[iedge].nface        = src->edge[iedge].nface;
            body->edge[iedge].ibody        = src->edge[iedge].ibody;
            body->edge[iedge].iford        = src->edge[iedge].iford;
            body->edge[iedge].imark        = src->edge[iedge].imark;
            body->edge[iedge].gratt.object = src->edge[iedge].gratt.object;
            body->edge[iedge].gratt.active = src->edge[iedge].gratt.active;
            body->edge[iedge].gratt.color  = src->edge[iedge].gratt.color;
            body->edge[iedge].gratt.bcolor = src->edge[iedge].gratt.bcolor;
            body->edge[iedge].gratt.mcolor = src->edge[iedge].gratt.mcolor;
            body->edge[iedge].gratt.lwidth = src->edge[iedge].gratt.lwidth;
            body->edge[iedge].gratt.ptsize = src->edge[iedge].gratt.ptsize;
            body->edge[iedge].gratt.render = src->edge[iedge].gratt.render;
            body->edge[iedge].gratt.dirty  = src->edge[iedge].gratt.dirty;
            body->edge[iedge].dxyz         = NULL;
            body->edge[iedge].dt           = NULL;
            body->edge[iedge].eedge        = eedges[iedge-1];
        }

        EG_free(eedges);
    }

    PPRINT1(done initializing %d Edges, nedge);

    /* initialize the Faces for this Body */
    MALLOC(body->face, face_T, nface+1);

    status = EG_getBodyTopos(ebody, NULL, FACE, &ntemp, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (ntemp != nface) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "ntemp=%d does not match nface=%d", ntemp, nface);
        SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
    }

    for (iface = 1; iface <= nface; iface++) {
        body->face[iface].ibody        = src->face[iface].ibody;
        body->face[iface].iford        = src->face[iface].iford;
        body->face[iface].imark        = src->face[iface].imark;
        body->face[iface].gratt.object = src->face[iface].gratt.object;
        body->face[iface].gratt.active = src->face[iface].gratt.active;
        body->face[iface].gratt.color  = src->face[iface].gratt.color;
        body->face[iface].gratt.bcolor = src->face[iface].gratt.bcolor;
        body->face[iface].gratt.mcolor = src->face[iface].gratt.mcolor;
        body->face[iface].gratt.lwidth = src->face[iface].gratt.lwidth;
        body->face[iface].gratt.ptsize = src->face[iface].gratt.ptsize;
        body->face[iface].gratt.render = src->face[iface].gratt.render;
        body->face[iface].gratt.dirty  = src->face[iface].gratt.dirty;
        body->face[iface].eggdata      = NULL;
        body->face[iface].dxyz         = NULL;
        body->face[iface].duv          = NULL;
        body->face[iface].eface        = efaces[iface-1];
    }

    EG_free(efaces);

    PPRINT1(done initializing %d Faces, nface);

    /* store Csystem on this Body */
    (void) storeCsystem(MODL, ibody);
    if (MODL->sigCode != SUCCESS) {
        status = freeBody(MODL, ibody);
        MODL->nbody--;
        goto cleanup;
    }

    /* dump a copy of this Body */
    status = dumpEgadsFile(MODL, ibody);
    CHECK_STATUS(dumpEgadsFile);

    /* restore status in cases where an interim error occurred above */
    status = EGADS_SUCCESS;

cleanup:
    PPRINT0(exit finishCopy);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   finiteDifference - get derivatives by finite differences           *
 *                                                                      *
 ************************************************************************
 */

static int
finiteDifference(modl_T *modl,          /* (in)  pointer to MODL */
                 int    ibody,          /* (in)  Body index (bias-1) */
                 int    seltype,        /* (in)  select type: OCSM_FACE, OCSM_EDGE, or OCSM_NODE */
                 int    iselect,        /* (in)  Face, Ege, or Node index (bias-1) */
                 int    npnt,           /* (in)  number of points */
       /*@null@*/double uv[],           /* (in)  array of t or uv at points (or NULL) */
                 double dxyz[])         /* (out) array of xyz at points */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface;

    modl_T    *MODL = (modl_T*)modl;

    int       npnt_base, npnt_ptrb, ntri_base, ntri_ptrb, ip0, ip1, ip2, itri, ipnt;
    int       oclass, mtype, nchild, *senses, itype, nlist, jnode;
    CINT      *tris_base, *tris_ptrb, *tric_base, *tric_ptrb;
    CINT      *ptype_base, *ptype_ptrb, *pindx_base, *pindx_ptrb;
    CINT      *tempIlist;
    double    uv_face[2], weights[3], data_base[18], data_ptrb[18];
    CDOUBLE   *xyz_base, *xyz_ptrb, *uv_base, *uv_ptrb;
    ego       eref, *echilds;

    ROUTINE(finiteDifference);

    /* --------------------------------------------------------------- */

    if (MODL->dtime == -2) {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] = 0;
            dxyz[3*ipnt+1] = 0;
            dxyz[3*ipnt+2] = 0;
        }
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        /* get the base and perturbed tessellations. note that we do not need to
           explicitly use the .fMap Attribute since it is taken care of in
           EG_getTessFace() */
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_base, &xyz_base, &uv_base, &ptype_base, &pindx_base,
                                &ntri_base, &tris_base, &tric_base);
        CHECK_STATUS(EG_getTessFace);

        status = EG_getTessFace(MODL->perturb->body[ibody].etess, -iface,
                                &npnt_ptrb, &xyz_ptrb, &uv_ptrb, &ptype_ptrb, &pindx_ptrb,
                                &ntri_ptrb, &tris_ptrb, &tric_ptrb);
        CHECK_STATUS(EG_getTessFace);

        /* if using tessellation points, just take finite difference of locations */
        if (uv == NULL) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                dxyz[3*ipnt  ] = (xyz_ptrb[3*ipnt  ] - xyz_base[3*ipnt  ]) / MODL->dtime;
                dxyz[3*ipnt+1] = (xyz_ptrb[3*ipnt+1] - xyz_base[3*ipnt+1]) / MODL->dtime;
                dxyz[3*ipnt+2] = (xyz_ptrb[3*ipnt+2] - xyz_base[3*ipnt+2]) / MODL->dtime;
            }

        /* otherwise, interpolate into the tessellation and then take finite differences */
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                uv_face[0] = uv[2*ipnt  ];
                uv_face[1] = uv[2*ipnt+1];

                status = EG_locateTessBody(MODL->body[ibody].etess, 1,
                                           &iface, uv_face, &itri, weights);
                CHECK_STATUS(EG_locateTessBody);

                ip0 = tris_base[3*(itri-1)  ] - 1;
                ip1 = tris_base[3*(itri-1)+1] - 1;
                ip2 = tris_base[3*(itri-1)+2] - 1;

                dxyz[3*ipnt  ] = ((xyz_ptrb[3*ip0  ] * weights[0]
                                  +xyz_ptrb[3*ip1  ] * weights[1]
                                  +xyz_ptrb[3*ip2  ] * weights[2])
                                 -(xyz_base[3*ip0  ] * weights[0]
                                  +xyz_base[3*ip1  ] * weights[1]
                                  +xyz_base[3*ip2  ] * weights[2])) / MODL->dtime;
                dxyz[3*ipnt+1] = ((xyz_ptrb[3*ip0+1] * weights[0]
                                  +xyz_ptrb[3*ip1+1] * weights[1]
                                  +xyz_ptrb[3*ip2+1] * weights[2])
                                 -(xyz_base[3*ip0+1] * weights[0]
                                  +xyz_base[3*ip1+1] * weights[1]
                                  +xyz_base[3*ip2+1] * weights[2])) / MODL->dtime;
                dxyz[3*ipnt+2] = ((xyz_ptrb[3*ip0+2] * weights[0]
                                  +xyz_ptrb[3*ip1+2] * weights[1]
                                  +xyz_ptrb[3*ip2+2] * weights[2])
                                 -(xyz_base[3*ip0+2] * weights[0]
                                  +xyz_base[3*ip1+2] * weights[1]
                                  +xyz_base[3*ip2+2] * weights[2])) / MODL->dtime;
            }
        }
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        /* get the base and perturbed tessellations.  note that we do not need to
           explicitly use the .eMap Attribute since it is taken care of in
           EG_getTessEdge() */
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt_base, &xyz_base, &uv_base);
        CHECK_STATUS(EG_getTessEdge);

        status = EG_getTessEdge(MODL->perturb->body[ibody].etess, -iedge,
                                &npnt_ptrb, &xyz_ptrb, &uv_ptrb);
        CHECK_STATUS(EG_getTessEdge);

        /* if using tessellation points, just take finite difference of locations */
        if (uv == NULL) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                dxyz[3*ipnt  ] = (xyz_ptrb[3*ipnt  ] - xyz_base[3*ipnt  ]) / MODL->dtime;
                dxyz[3*ipnt+1] = (xyz_ptrb[3*ipnt+1] - xyz_base[3*ipnt+1]) / MODL->dtime;
                dxyz[3*ipnt+2] = (xyz_ptrb[3*ipnt+2] - xyz_base[3*ipnt+2]) / MODL->dtime;
            }

        /* otherwise, interpolate into the tessellation and then take finite differences */
        } else {
//$$$   this might be a problem because it does not account for possible changes in t
//$$$       between the perturbed and baseline curves
//$$$
//$$$       perhaps we should use the same "normalized" t instead of the t itself (Bill Jones)
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                     &(uv[ipnt]), data_base);
                CHECK_STATUS(EG_evaluate);

                status = EG_evaluate(MODL->perturb->body[ibody].edge[iedge].eedge,
                                     &(uv[ipnt]), data_ptrb);
                CHECK_STATUS(EG_evaluate);

                dxyz[3*ipnt  ] = (data_ptrb[0] - data_base[0]) / MODL->dtime;
                dxyz[3*ipnt+1] = (data_ptrb[1] - data_base[1]) / MODL->dtime;
                dxyz[3*ipnt+2] = (data_ptrb[2] - data_base[2]) / MODL->dtime;
            }
        }

    } else if (seltype == OCSM_NODE) {
        inode = iselect;

        /* if .nMap exists, use mapped Node location in the perturbed Body */
        status = EG_attributeRet(MODL->perturb->body[ibody].ebody, ".nMap",
                                 &itype, &nlist, &tempIlist, NULL, NULL);
        if (status == SUCCESS) {
            jnode = tempIlist[inode-1];
        } else {
            jnode = inode;
        }

        /* get the two locations */
        status = EG_getTopology(MODL->body[ibody].node[inode].enode, &eref,
                                &oclass, &mtype, data_base, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        status = EG_getTopology(MODL->perturb->body[ibody].node[jnode].enode, &eref,
                                &oclass, &mtype, data_ptrb, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        dxyz[0] = (data_ptrb[0] - data_base[0]) / MODL->dtime;
        dxyz[1] = (data_ptrb[1] - data_base[1]) / MODL->dtime;
        dxyz[2] = (data_ptrb[2] - data_base[2]) / MODL->dtime;

        /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   fixSketch - find constraints that will improve Sketch              *
 *                                                                      *
 ************************************************************************
 */

static int
fixSketch(sket_T *sket,                 /* (in)  Sketch structure */
          char   vars[],                /* (in)  variable string */
          char   cons_mod[])            /* (out) deleted and added constraints */
{
    int       status = SUCCESS;         /* (out) return status */

    int       i, j, count, ipnt, im1, ip1, npnt, icon, jcon;
    int       old_rank, new_rank, okay, nadd, ndel, *segtyp=NULL;
    double    *xyd=NULL, *xyd_out=NULL, *xy=NULL, *res=NULL, *jac=NULL, *dxy=NULL, *sval=NULL;
    double    dx, dy, dip;
    double    tan20=0.364, tan25=0.466, tan65=2.145;
    char      temp[MAX_EXPR_LEN], savetype;

    ROUTINE(fixSketch);

    /* --------------------------------------------------------------- */

    SPRINT2(2, "enter fixSketch(nvar=%d, ncon=%d)", sket->nvar, sket->ncon);

    /* default output (no suggestted deletions or additions) */
    cons_mod[0] = '\0';

    /* read the xyd from vars */
    count = 0;
    for (i = 0; i < STRLEN(vars); i++) {
        if (vars[i] == ';') {
            count++;
        }
    }

    assert(count > 0);
    MALLOC(xyd,     double, count);
    MALLOC(xyd_out, double, count);

    npnt    = 0;
    j       = 0;
    temp[0] = '\0';
    for (i = 0; i < STRLEN(vars); i++) {
        if (vars[i] == ';') {
            sscanf(temp, "%lf", &(xyd[npnt]));
            npnt++;
            j       = 0;
            temp[0] = '\0';
        } else {
            temp[j++] = vars[i];
            temp[j  ] = '\0';
        }
    }
    npnt /= 3;
    SPRINT1(2, "npnt=%d", npnt);

    assert (npnt > 1);
    MALLOC(segtyp, int, npnt);

    /* determine the Segment types */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        segtyp[ipnt] = 0;               // unclassified

        ip1 = ipnt + 1;   if (ip1 >= npnt) ip1 -= npnt;

        dx  = xyd[3*ip1  ] - xyd[3*ipnt  ];
        dy  = xyd[3*ip1+1] - xyd[3*ipnt+1];
        dip =                xyd[3*ip1 +2];

        /* linear Segments */
        if (fabs(dip) < EPS06) {
            if        (fabs(dy) < tan20*fabs(dx)) {
                segtyp[ipnt] = 1;       // horizontal
            } else if (fabs(dx) < tan20*fabs(dy)) {
                segtyp[ipnt] = 2;       // vertical
            } else {
                segtyp[ipnt] = 3;      // unknown linear Segment
            }

        /* circular arc Segments */
        } else {
            if (fabs(dy) > tan25*fabs(dx) && fabs(dy) < tan65*fabs(dx)) {
                if (dx*dy*dip > 0) {
                    segtyp[ipnt] = 4;   // 90hv bend: horizontal to vertical
                } else {
                    segtyp[ipnt] = 5;   // 90vh bend: vertical   to horizontal
                }
            } else if (fabs(dx) < tan20*fabs(dy)) {
                segtyp[ipnt] = 6;       // 180hh bend: horizontal to horizontal
            } else if (fabs(dy) < tan20*fabs(dx)) {
                segtyp[ipnt] = 7;       // 180vv bend: vertical   to vertical
            } else {
                segtyp[ipnt] = 8;       // unknown cirarc Segment
            }
        }

        SPRINT5(2, "%3d   %10.5f %10.5f %10.5f  %d",
                ipnt, xyd[3*ipnt], xyd[3*ipnt+1], xyd[3*ipnt+2], segtyp[ipnt]);
    }

    /* getting here means that we did not converge or that we are
       over-constrainted, so see if there are any redundant constraints
       (which will be detected by comparing the matrix ranks) */
    status = fixSketchRank(sket, npnt, segtyp, &old_rank);
    SPRINT1(2, "old_rank=%d", old_rank);
    CHECK_STATUS(fixSketchRank);

    /* check to see if any of the constraints could be deleted without
       reducing the rank */
    ndel = 0;
    for (icon = 0; icon < sket->ncon; icon++) {
        SPRINT4x(2, "trying to delete constraint %d (%c %2d %2d): ",
                 icon, sket->ctype[icon], sket->ipnt[icon], sket->ip1[icon]);

        ipnt = sket->ipnt[icon] - 1;    /* switch to bias-0 */

        /* do not try to delete a constraint that will not be
           processed by fixSketchRank, because otherwise we will
           not see a reduction in the rank and will therefore
           (perhaps) erroneously suggest that the constraint
           can be removed */
        if        (sket->ctype[icon] == 'X') {
            if (ipnt == 0) {
                SPRINT0(2, "cannot delete X on point 1");
                continue;
            }
        } else if (sket->ctype[icon] == 'Y') {
            if (ipnt == 0) {
                SPRINT0(2, "cannot delete Y on point 1");
                continue;
            }
        } else if (sket->ctype[icon] == 'V') {
        } else if (sket->ctype[icon] == 'W') {
        } else if (sket->ctype[icon] == 'H') {
        } else if (sket->ctype[icon] == 'D') {
        } else if (sket->ctype[icon] == 'L') {
            if        (segtyp[ipnt] == 1) {
                /* nearly horizontal */
            } else if (segtyp[ipnt] == 2) {
                /* nearly vertical */
            } else {
                SPRINT0(2, "not nearly horizontal or vertical");
                continue;     /* skip this one */
            }

        } else if (sket->ctype[icon] == 'T') {
            im1 = ipnt - 1;   if (im1 < 0) im1 += npnt;

            if        (segtyp[im1] == 1 && segtyp[ipnt] == 1) {
                /* both segs nearly horizontal */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 2) {
                /* both segs nearly vertical */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 4) {
                /* horizontal to 90hv */
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 1) {
                /* 90vh to hoirizontal */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 5) {
                /* vertical to 90vh */
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 2) {
                /* 90hv to vertical */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 6) {
                /* horizontal to 180hh */
            } else if (segtyp[im1] == 6 && segtyp[ipnt] == 1) {
                /* 180hh to horizontal */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 7) {
                /* vertical to 180vv */
            } else if (segtyp[im1] == 7 && segtyp[ipnt] == 2) {
                /* 180vv to vertical */
            } else {
                SPRINT0(2, "invalid horizontal or vertical connection");
                continue;     /* skip this one */
            }

        } else if (sket->ctype[icon] == 'P') {
            im1 = ipnt - 1;   if (im1 < 0) im1 += npnt;

            if        (segtyp[im1] == 1 && segtyp[ipnt] == 2) {
                /* horizontal and vertical */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 1) {
                /* vertical and horizontal */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 5) {
                /* horizontal and 90vh */
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 2) {
                /* 90vh and vertical */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 4) {
                /* vertical amd 90hv */
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 1) {
                /* 90hv and horizontal */
            } else {
                SPRINT0(2, "invalid horizontal and vertical connection");
                continue;     /* skip this one */
            }

        } else if (sket->ctype[icon] == 'R')  {

            if        (segtyp[ipnt] == 4 || segtyp[ipnt] == 5) {
                /* 90hv or 90vh */
            } else if (segtyp[ipnt] == 6 || segtyp[ipnt] == 7) {
                /* 180hh or 180vv */
            } else {
                SPRINT0(2, "not recognized bend");
                continue;     /* skip this one */
            }

        } else {
            SPRINT0(2, "unknown type");
            continue;         /* skip this one, since unknown type */
        }

        /* temporarily overwrite constraint type */
        savetype          = sket->ctype[icon];
        sket->ctype[icon] = ' ';

        status = fixSketchRank(sket, npnt, segtyp, &new_rank);
        SPRINT1x(2, "new_rank=%d  ", new_rank);
        CHECK_STATUS(fixSketchRank);

        sket->ctype[icon] = savetype;

        /* if removing the constraint does not reduce the rank, suggest that
           the constraint can be removed */
        if (new_rank == old_rank) {
            SPRINT0(2, "accept");
            ndel++;
            if (ndel == 1) {
                snprintf(cons_mod, MAX_EXPR_LEN, "*del;%c;%d;%d",
                         sket->ctype[icon], sket->ipnt[icon], sket->ip1[icon]);
            } else {
                snprintf(temp,     MAX_EXPR_LEN,     ";%c;%d;%d",
                         sket->ctype[icon], sket->ipnt[icon], sket->ip1[icon]);
                strncat(cons_mod, temp, MAX_EXPR_LEN);
            }
        } else {
            SPRINT0(2, "reject (rank was reduced)");
        }
    }

    SPRINT1(2, "suggesting %d constraints to delete", ndel);
    if (ndel > 0) goto cleanup;

    /* getting here means that no constraints could be removed without
       lowering the rank, so try adding various constraint types */
    nadd = 0;

    /* loop through all points to see if point-based constraints will improve the rank */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        im1 = ipnt - 1;   if (im1 < 0) im1 += npnt;

        /* check if adding 'X' constraint will improve rank */
        SPRINT1x(2, "trying to add X constraint %2d -1: ", ipnt+1);

        /* only consider if we do not already have an 'X' at this point */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (sket->ctype[jcon] == 'X' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have X");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'X';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = -1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;X;%d;-1", ipnt+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";X;%d;-1", ipnt+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'Y' constraint will improve rank */
        SPRINT1x(2, "trying to add Y constraint %2d -1: ", ipnt+1);

        /* only consider if we do not already have a 'Y' at this point */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (sket->ctype[jcon] == 'Y' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have Y");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'Y';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = -1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;Y;%d;-1", ipnt+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";Y;%d;-1", ipnt+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'T' constraint will improve rank */
        SPRINT1x(2, "trying to add T constraint %2d -1: ", ipnt+1);

        /* only consider if we do not already have a 'T' or 'P' at this point
           and we have the right horizontal or vertical connection */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if        (sket->ctype[jcon] == 'T' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have T");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'P' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have P");
                okay = 0;
                break;
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 4) {
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 1) {
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 5) {
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 2) {
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 6) {
            } else if (segtyp[im1] == 6 && segtyp[ipnt] == 1) {
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 7) {
            } else if (segtyp[im1] == 7 && segtyp[ipnt] == 2) {
            } else {
                SPRINT0(2, "wrong segtyp connections");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'T';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = -1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;T;%d;-1", ipnt+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";T;%d;-1", ipnt+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'P' constraint will improve rank */
        SPRINT1x(2, "trying to add P constraint %2d -1: ", ipnt+1);

        /* only consider if we do not already have a 'T' or 'P' at this point
           and we have the right horizontal or vertical connection */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if        (sket->ctype[jcon] == 'T' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have T");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'P' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have P");
                okay = 0;
                break;
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 5) {
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 2) {
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 4) {
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 1) {
            } else {
                SPRINT0(2, "wrong segtyp connections");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'P';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = -1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;P;%d;-1", ipnt+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";P;%d;-1", ipnt+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }
    }

    /* loop through all segments to see if segment-based constraints will improve rank */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        ip1 = ipnt + 1;   if (ip1 >= npnt) ip1 -= npnt;
        SPRINT3(2, "ipnt=%d, ip1=%d, npnt=%d", ipnt, ip1, npnt);

        /* check if adding 'H' constraint will improve rank */
        SPRINT2x(2, "trying to add H constraint %2d %2d: ", ipnt+1, ip1+1);

        /* only consider if nearly horizontal and we do not
           have a 'H', 'V', or 'I' already on this segment */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (segtyp[ipnt] != 1) {
                SPRINT0(2, "not nearly horizontal");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'H' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have H");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'V' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have V");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'I' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have I");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'H';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = ip1  + 1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;H;%d;%d", ipnt+1, ip1+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";H;%d;%d", ipnt+1, ip1+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'V' constraint will improve rank */
        SPRINT2x(2, "trying to add V constraint %2d %2d: ", ipnt+1, ip1+1);

        /* only consider if nearly vertical and we do not
           have a 'H', 'V', or 'I' already on this segment */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (segtyp[ipnt] != 2) {
                SPRINT0(2, "not nearly vertical");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'H' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have H");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'V' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have V");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'I' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have I");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'V';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = ip1  + 1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;V;%d;%d", ipnt+1, ip1+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";V;%d;%d", ipnt+1, ip1+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'L' constraint will improve rank */
        SPRINT2x(2, "trying to add L constraint %2d %2d: ", ipnt+1, ip1+1);

        /* only consider if we do not already have an 'L'
           on this segment and not nearly horizontal or vertical */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (segtyp[ipnt] != 1 && segtyp[ipnt] != 2) {
                SPRINT0(2, "not nearly horizontal or vertical");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'L' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have L");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'L';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = ip1  + 1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;L;%d;%d", ipnt+1, ip1+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";L;%d;%d", ipnt+1, ip1+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'R' constraint will improve rank */
        SPRINT2x(2, "trying to add R constraint %2d %2d: ", ipnt+1, ip1+1);

        /* only consider if we do not already have a 'R'
           on this Segment and not 180 bend */
        okay = 1;

        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (segtyp[ipnt] != 4 && segtyp[ipnt] != 5 &&
                segtyp[ipnt] != 6 && segtyp[ipnt] != 7   ) {
                SPRINT0(2, "not 90 or 180 bend");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'R' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have R");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'R';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = ip1  + 1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;R;%d;%d", ipnt+1, ip1+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";R;%d;%d", ipnt+1, ip1+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

    }

    SPRINT1(2, "suggesting %d constraints to add", nadd);
    if (nadd > 0) goto cleanup;

cleanup:
    FREE(xyd_out);
    FREE(xyd );

    FREE(segtyp);

    FREE(sval);
    FREE(dxy );
    FREE(jac );
    FREE(res );
    FREE(xy  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   fixSketchRank - compute rank of simplified Jacobian matrix         *
 *                                                                      *
 ************************************************************************
 */

static int
fixSketchRank(sket_T *sket,             /* (in)  sketch info */
              int    npnt,              /* (in)  number of points */
              int    segtyp[],          /* (in)  array  os Segment types */
              int    *jrank)            /* (out) rank of Jacobian */
{
    int       status = SUCCESS;         /* (out) return status */

    int       icon, irow, nrow, icol, ncol, ipnt, im1, ip1;
    double    *jac=NULL;

    ROUTINE(fixSketchRank);

    /* --------------------------------------------------------------- */

    /* each point has an x, y, and dip */
    ncol = 3 * npnt;
    nrow = MAX(sket->ncon, ncol);

    /* allocate and initialize jacobian */
    MALLOC(jac, double, nrow*ncol);

    for (icon = 0; icon < nrow; icon++) {
        for (icol = 0; icol < ncol; icol++) {
            jac[icon*ncol+icol] = 0;
        }
    }

    /* add each of the constraints to the matricies */
    for (icon = 0; icon < sket->ncon; icon++) {
        ipnt = sket->ipnt[icon] - 1;     /* switch to bias-0 */
        ip1  = sket->ip1[ icon] - 1;

        /* 'X' constraint */
        if        (sket->ctype[icon] == 'X') {
            jac[icon*ncol+3*ipnt  ] = +1;

        /* 'Y' constraint */
        } else if (sket->ctype[icon] == 'Y') {
            jac[icon*ncol+3*ipnt+1] = +1;

        /* 'V' constraint */
        } else if (sket->ctype[icon] == 'V') {
            jac[icon*ncol+3*ipnt  ] = -1;
            jac[icon*ncol+3*ip1   ] = +1;

        /* 'W' constraint */
        } else if (sket->ctype[icon] == 'W') {
            jac[icon*ncol+3*ipnt  ] = -1;
            jac[icon*ncol+3*ip1   ] = +1;

        /* 'H' constraint */
        } else if (sket->ctype[icon] == 'H') {
            jac[icon*ncol+3*ipnt+1] = -1;
            jac[icon*ncol+3*ip1 +1] = +1;

        /* 'D' constraint */
        } else if (sket->ctype[icon] == 'D') {
            jac[icon*ncol+3*ipnt+1] = -1;
            jac[icon*ncol+3*ip1 +1] = +1;

        /* 'L' constraint */
        } else if (sket->ctype[icon] == 'L') {
            /* horizontal segment */
            if        (segtyp[ipnt] == 1) {
                jac[icon*ncol+3*ipnt  ] = -1;
                jac[icon*ncol+3*ip1   ] = +1;
            /* vertical segment */
            } else if (segtyp[ipnt] == 2) {
                jac[icon*ncol+3*ipnt+1] = -1;
                jac[icon*ncol+3*ip1 +1] = +1;
            }

        /* 'T' constraint */
        } else if (sket->ctype[icon] == 'T') {
            im1 = ipnt - 1;   if (im1 <  0   ) im1 += npnt;
            ip1 = ipnt + 1;   if (ip1 >= npnt) ip1 -= npnt;

            /* both horizontal segments */
            if        (segtyp[im1] == 1 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1 +1] = -1;
                jac[icon*ncol+3*ipnt+1] = +2;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* both vertical segments */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1   ] = -1;
                jac[icon*ncol+3*ipnt  ] = +2;
                jac[icon*ncol+3*ip1   ] = -1;
            /* horizontal to 90hv */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 4) {
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            /* 90vh to hoirizontal */
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
            /* vertical to 90vh */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 5) {
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* 90hv to vertical */
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
            /* horizontal to 180hh */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 6) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            /* 180hh to horizontal */
            } else if (segtyp[im1] == 6 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* vertical to 180vv */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 7) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* 180vv to vertical */
            } else if (segtyp[im1] == 7 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            }

        /* 'P' constraint */
        } else if (sket->ctype[icon] == 'P') {
            im1 = ipnt - 1;   if (im1 <  0   ) im1 += npnt;
            ip1 = ipnt + 1;   if (ip1 >= npnt) ip1 -= npnt;

            /* horizontal and vertical segments */
            if        (segtyp[im1] == 1 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            /* vertical and horizontal segments */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* horizontal and 90vh segments */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 5) {
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            /* 90vh and vertical segments */
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
            /* vertical and 90hv segments */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 4) {
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* 90hv and horizontal segments */
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
            }

        /* 'R' constraint */
        } else if (sket->ctype[icon] == 'R') {

            /* 90 bend */
            if        (segtyp[ipnt] == 4 || segtyp[ipnt] == 5) {
                jac[icon*ncol+3*ipnt+2] = +1;

            /* 180 bend */
            } else if (segtyp[ipnt] == 6 || segtyp[ipnt] == 7) {
                jac[icon*ncol+3*ipnt+2] = +1;
            }

        }
    }

    /* add implicit constraints for all non-CIRARC Segments */
    nrow = sket->ncon;

    for (ipnt = 0; ipnt < npnt; ipnt++) {
        if (segtyp[ipnt] <= 3) {
            jac[nrow*ncol+3*ipnt+2] = +1;
            nrow++;
        }
    }

    SPRINT0x(2, "\n              ");
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        SPRINT3x(2, "x%-2d y%-2d d%-2d ", ipnt+1, ipnt+1, ipnt+1);
    }
#ifndef __clang_analyzer__
    SPRINT0(2, " ");
    for (irow = 0; irow < nrow; irow++) {
        if (irow < sket->ncon) {
            SPRINT4x(2, "%3d %c %2d %2d: ", irow, sket->ctype[irow], sket->ipnt[irow], sket->ip1[irow]);
        } else {
            SPRINT1x(2, "%3d cirarc : ", irow);
        }
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            SPRINT3x(2, "%3d %3d %3d ", NINT(jac[irow*ncol+3*ipnt  ]),
                                        NINT(jac[irow*ncol+3*ipnt+1]),
                                        NINT(jac[irow*ncol+3*ipnt+2]));
        }
        SPRINT0(2, " ");
    }
#endif

    /* compute the rank */
    *jrank = rank(jac, nrow, ncol);
    SPRINT1(2, "*jrank=%d", *jrank);

cleanup:
    FREE(jac);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   freeBody - free memory associated with a Body (undo newBody)       *
 *                                                                      *
 ************************************************************************
 */

static int
freeBody(modl_T *MODL,                  /* (in)  pointer to MODL */
         int    ibody)                  /* (in)  Body index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iarg;

    ROUTINE(freeBody);

    /* --------------------------------------------------------------- */

    /* free up arguments */
    for (iarg = 1; iarg < 10; iarg++) {
        FREE(MODL->body[ibody].arg[iarg].val);   /* also free's .str since they are unioned */
        FREE(MODL->body[ibody].arg[iarg].dot);
    }

    /* free up Node, Edge, and Face tables */
    FREE(MODL->body[ibody].node);
    FREE(MODL->body[ibody].edge);
    FREE(MODL->body[ibody].face);

    /* cleanup sensitivity cache (if it exists) */
    if (MODL->body[ibody].sens != 0) {
        SPRINT1(2, "resetting .sens for ibody=%d", ibody);

        status = EG_setGeometry_dot(MODL->body[ibody].ebody, 0, 0,  NULL, NULL, NULL);
        CHECK_STATUS(EG_setGeometry_dot);

        MODL->body[ibody].sens = 0;
    }

    /* mark that the Body was freed */
    MODL->body[ibody].ibrch = 0;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   getBodyTolerance - get the largest tolerance associated with       *
 *                      ebody and its Edges/Faces                       *
 *                                                                      *
 ************************************************************************
 */

static int
getBodyTolerance(ego    ebody,          /* (in)  pointer to Body */
                 double *toler)         /* (out) largest tolerance */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nface, nedge, iface, iedge, oclass, mtype;
    double    tol;

    ego       *efaces, *eedges, eref, eprev, enext;

    ROUTINE(getBodyTolerance);

    /* --------------------------------------------------------------- */

    *toler = 0;

    /* if ebody is really a MODEL, return a tolerance of -1 */
    status = EG_getInfo(ebody, &oclass, &mtype, &eref, &eprev, &enext);
    CHECK_STATUS(EG_getInfo);

    if (oclass == MODEL) {
        *toler = -1;
        goto cleanup;
    }

    /* get tolerance associated with the Body */
    status = EG_getTolerance(ebody, &tol);
    CHECK_STATUS(EG_getTolerance);

    SPRINT1(3, "    body         toler=%11.4e", tol);

    *toler = MAX(*toler, tol);

    /* for each Face associated with ebody, get its tolerance */
    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    for (iface = 0; iface < nface; iface++) {
        status = EG_getTolerance(efaces[iface], &tol);
        CHECK_STATUS(EG_getTolerance);

        SPRINT2(3, "    iface=%-5d  toler=%11.4e", iface+1, tol);

        *toler = MAX(*toler, tol);
    }

    EG_free(efaces);

    /* for each Edge associated with ebody, get its tolerance */
    status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, &eedges);
    CHECK_STATUS(EG_getBodyTopos);

    for (iedge = 0; iedge < nedge; iedge++) {
        status = EG_getTolerance(eedges[iedge], &tol);
        CHECK_STATUS(EG_getTolerance);

        SPRINT2(3, "    iedge=%-5d  toler=%11.4e", iedge+1, tol);

        *toler = MAX(*toler, tol);
    }

    EG_free(eedges);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   getToken - get a token from a string                               *
 *                                                                      *
 ************************************************************************
 */

static int
getToken(char   *text,                  /* (in)  full text */
         int    nskip,                  /* (in)  tokens to skip */
         char   sep,                    /* (in)  seperator character */
         int    maxtok,                 /* (in)  size of token */
         char   *token)                 /* (out) token */
{
    int    lentok, i, count, iskip;

    token[0] = '\0';
    lentok   = 0;

    /* convert tabs to spaces */
    for (i = 0; i < STRLEN(text); i++) {
        if (text[i] == '\t') {
            text[i] = ' ';
        }
    }

    /* count the number of separators */
    count = 0;
    for (i = 0; i < STRLEN(text); i++) {
        if (text[i] == sep) {
            count++;
        }
    }

    if (count < nskip+1) return 0;

    /* skip over nskip tokens */
    i = 0;
    for (iskip = 0; iskip < nskip; iskip++) {
        while (text[i] != sep) {
            i++;
        }
        i++;
    }

    /* extract the token we are looking for */
    while (text[i] != sep) {
        token[lentok++] = text[i++];
        token[lentok  ] = '\0';

        if (lentok >= maxtok-1) {
            signalError(NULL, OCSM_INTERNAL_ERROR,
                        "token exceeds maxtok=%d", maxtok);
            break;
        }
    }

    return STRLEN(token);
}


/*
 ************************************************************************
 *                                                                      *
 *   joinSheetBodys - join 2 SheetsBodys into a new SheetBody           *
 *                                                                      *
 ************************************************************************
 */

static int
joinSheetBodys(modl_T *modl,            /* (in)  pointer to MODL */
               ego    ebodyl,           /* (in)  left SheetBody */
               ego    ebodyr,           /* (in)  rite SheetBody */
               double toler,            /* (in)  tolerance */
               ego    *ebody)           /* (out) resulting SheetBody */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       nnodel, nedgel, nfacel, nnoder, nedger, nfacer, nloop;
    int       inode, iedge, iface, jnode, jedge, jface;
    int       oclassf, mtypef, oclassl, mtypel, *sensesr, *sensesl;
    int       oclasss, mtypes, *nodbod=NULL;
    int       oclass, mtype, *senses, nchild, ibeg, iend;
    int       iloop, nedglup, iedglup, nskip, skipthis;
    double    toll, tolr, datal[4], datar[4];
    double    bboxl[6], bboxr[6], dataf[4];
    ego       *enodesl=NULL, *eedgesl=NULL, *efacesl=NULL;
    ego       *enodesr=NULL, *eedgesr=NULL, *efacesr=NULL, *eloopsr;
    ego       *enodes=NULL, *eedges=NULL, *efaces=NULL, eshell;
    ego       eref, *echilds, ecurve, esurface, etemp[2];
    ego       *eloops=NULL, *eedglupr, *eedglup=NULL;

    ROUTINE(joinSheetBodys);

    /* --------------------------------------------------------------- */

    /* increase toler to the larger of given value and tolerances of
       the input Bodys */
    status = EG_getTolerance(ebodyl, &toll);
    CHECK_STATUS(EG_getTolerance);

    status = EG_getTolerance(ebodyr, &tolr);
    CHECK_STATUS(EG_getTolerance);

    if (toll > toler) toler = toll;
    if (tolr > toler) toler = tolr;

    /* extract the Nodes, Edges, and Faces from ebodyl */
    status = EG_getBodyTopos(ebodyl, NULL, NODE, &nnodel, &enodesl);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedgel, &eedgesl);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(ebodyl, NULL, FACE, &nfacel, &efacesl);
    CHECK_STATUS(EG_getBodyTopos);

    /* extract the Nodes, Edges, and Faces from ebodyr */
    status = EG_getBodyTopos(ebodyr, NULL, NODE, &nnoder, &enodesr);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(ebodyr, NULL, EDGE, &nedger, &eedgesr);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(ebodyr, NULL, FACE, &nfacer, &efacesr);
    CHECK_STATUS(EG_getBodyTopos);

    /* make arrays to hold the Nodes, Edges, and Faces in the joined Body */
    MALLOC(enodes, ego, nnodel+nnoder);
    MALLOC(eedges, ego, nedgel+nedger);
    MALLOC(efaces, ego, nfacel+nfacer);
    MALLOC(nodbod, int, nnodel+nnoder);

    /* link the Nodes, Edges, and Faces in ebody to ebodyl */
    for (inode = 0; inode < nnodel; inode++) {
        enodes[inode] = enodesl[inode];
    }
    for (iedge = 0; iedge < nedgel; iedge++) {
        eedges[iedge] = eedgesl[iedge];
    }
    for (iface = 0; iface < nfacel; iface++) {
        efaces[iface] = efacesl[iface];
    }

    /* for Nodes in ebodyr, either use the Node in ebodyl
       (if on the joint) or ebodyr */
    for (inode = 0; inode < nnoder; inode++) {
        status = EG_getTopology(enodesr[inode], &eref, &oclass, &mtype,
                                datar, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        enodes[nnodel+inode] = NULL;
        for (jnode = 0; jnode < nnodel; jnode++) {
            status = EG_getTopology(enodesl[jnode], &eref, &oclass, &mtype,
                                    datal, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (fabs(datal[0]-datar[0]) < toler &&
                fabs(datal[1]-datar[1]) < toler &&
                fabs(datal[2]-datar[2]) < toler   ) {

                enodes[nnodel+inode] = enodesl[jnode];
                nodbod[nnodel+inode] = jnode;   /* in ebodyl */
                break;
            }
        }

        if (enodes[nnodel+inode] == NULL) {
            enodes[nnodel+inode] = enodesr[inode];
            nodbod[nnodel+inode] = -1;       /* in ebodyr */
        }
    }

    /* for Edges in ebodyr, either use the Edge in ebodyl
       (if on the joint) or ebodyr */
    for (iedge = 0; iedge < nedger; iedge++) {
        status = EG_getTopology(eedgesr[iedge], &ecurve, &oclass, &mtype,
                                datar, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        ibeg = EG_indexBodyTopo(ebodyr, echilds[0]) - 1;
        iend = EG_indexBodyTopo(ebodyr, echilds[1]) - 1;

        /* if both Nodes are in ebodyl, get the reference to the
           corresponding Edge in ebodyl */
        if (nodbod[nnodel+ibeg] >= 0 && nodbod[nnodel+iend] >= 0) {
            eedges[nedgel+iedge] = NULL;

            status = EG_getBoundingBox(eedgesr[iedge], bboxr);
            CHECK_STATUS(EG_getBoundingBox);

            for (jedge = 0; jedge < nedgel; jedge++) {
                status = EG_getBoundingBox(eedgesl[jedge], bboxl);
                CHECK_STATUS(EG_getBoundingBox);

                if (fabs(bboxl[0]-bboxr[0]) < toler &&
                    fabs(bboxl[1]-bboxr[1]) < toler &&
                    fabs(bboxl[2]-bboxr[2]) < toler &&
                    fabs(bboxl[3]-bboxr[3]) < toler &&
                    fabs(bboxl[4]-bboxr[4]) < toler &&
                    fabs(bboxl[5]-bboxr[5]) < toler   ) {
                    eedges[nedgel+iedge] = eedgesl[jedge];
                    break;
                }
            }

            if (eedges[nedgel+iedge] == NULL) {
                SPRINT0(0, "ERROR:: expecting to find corresponding Edge in ebodyl");
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

        /* if both Nodes are in ebodyr, just reference the Edge */
        } else if (nodbod[nnodel+ibeg] == -1 && nodbod[nnodel+iend] == -1) {
            eedges[nedgel+iedge] = eedgesr[iedge];

        /* otherwise make a new Edge */
        } else {
            etemp[0] = enodes[nnodel+ibeg];
            etemp[1] = enodes[nnodel+iend];

            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                     datar, 2, etemp, NULL, &(eedges[nedgel+iedge]));
            CHECK_STATUS(EG_makeTopology);
        }
    }

    /* for Faces in ebodyr, either use the Face in ebodyr
       (if away from the joint) or a new Faces (which is adjusted for a new Edge) */
    nskip = 0;
    for (iface = 0; iface < nfacer; iface++) {
        status = EG_getBoundingBox(efacesr[iface], bboxr);
        CHECK_STATUS(EG_getBoundingBox);

        skipthis = 0;
        for (jface = 0; jface < nfacel; jface++) {
            status = EG_getBoundingBox(efacesl[jface], bboxl);
            CHECK_STATUS(EG_getBoundingBox);

            if (fabs(bboxl[0]-bboxr[0]) < toler &&
                fabs(bboxl[1]-bboxr[1]) < toler &&
                fabs(bboxl[2]-bboxr[2]) < toler &&
                fabs(bboxl[3]-bboxr[3]) < toler &&
                fabs(bboxl[4]-bboxr[4]) < toler &&
                fabs(bboxl[5]-bboxr[5]) < toler   ) {
                skipthis = 1;
                nskip++;
                break;
            }
        }

        if (skipthis > 0) continue;

        status = EG_getTopology(efacesr[iface], &esurface, &oclassf, &mtypef,
                                dataf, &nloop, &eloopsr, &sensesr);
        CHECK_STATUS(EG_getTopology);

        status = EG_getGeometry(esurface, &oclasss, &mtypes, &eref, NULL, NULL);
        CHECK_STATUS(EG_getGeometry);

        MALLOC(eloops, ego, nloop);

        for (iloop = 0; iloop < nloop; iloop++) {
            status = EG_getTopology(eloopsr[iloop], &eref, &oclassl, &mtypel,
                                    datal, &nedglup, &eedglupr, &sensesl);
            CHECK_STATUS(EG_getTopology);

            MALLOC(eedglup, ego, 2*nedglup);

            for (iedglup = 0; iedglup < nedglup; iedglup++) {
                jedge = EG_indexBodyTopo(ebodyr, eedglupr[iedglup]) - 1;
                eedglup[iedglup] = eedges[nedgel+jedge];
            }

            if (mtypes != PLANE) {
                for (iedglup = 0; iedglup < nedglup; iedglup++) {
                    eedglup[nedglup+iedglup] = eedglupr[nedglup+iedglup];
                }
            }

            status = EG_makeTopology(MODL->context, eref, LOOP, CLOSED,
                                     NULL, nedglup, eedglup, sensesl, &eloops[iloop]);
            CHECK_STATUS(EG_makeTopology);

            FREE(eedglup);
        }

        status = EG_makeTopology(MODL->context, esurface, FACE, mtypef,
                                 dataf, nloop, eloops, sensesr, &(efaces[nfacel+iface-nskip]));
        CHECK_STATUS(EG_makeTopology);

        status = EG_attributeDup(efacesr[iface], efaces[nfacel+iface-nskip]);
        CHECK_STATUS(EG_attributeDup);

        FREE(eloops);
    }

    /* create a Shell from all the Faces */
    status = EG_makeTopology(MODL->context, NULL, SHELL, CLOSED, NULL,
                             nfacel+nfacer-nskip, efaces, NULL, &eshell);
    if (status < SUCCESS && outLevel < 0) goto cleanup;      /* does not print message */
    CHECK_STATUS(EG_makeTopology);

    /* create the SheetBody */
    status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY, NULL,
                             1, &eshell, NULL, ebody);
    CHECK_STATUS(EG_makeTopology);

    /* cleanup now that SheetBody was made */
    status = EG_deleteObject(eshell);
    CHECK_STATUS(EG_deleteObject);

    for (iface = 0; iface < nfacer-nskip; iface++) {
        status = EG_deleteObject(efaces[nfacel+iface]);
        CHECK_STATUS(EG_deleteObject);
    }

cleanup:
    EG_free(enodesl);
    EG_free(eedgesl);
    EG_free(efacesl);
    EG_free(enodesr);
    EG_free(eedgesr);
    EG_free(efacesr);

    FREE(enodes);
    FREE(eedges);
    FREE(efaces);
    FREE(eloops);
    FREE(nodbod);
    FREE(eedglup);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   joinWireBodys - join 2 WireBodys into a new WireBody               *
 *                                                                      *
 ************************************************************************
 */

static int
joinWireBodys(modl_T *modl,             /* (in)  pointer to MODL */
              ego    ebodyl,            /* (in)  left WireBody */
              ego    ebodyr,            /* (in)  rite WireBody */
              double toler,             /* (in)  tolerance */
              ego    *ebody)            /* (out) resulting WireBody */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       oclass, mtype, nchild, *sensesl, *sensesr, *senses=NULL;
    int       i, nedgel, nedger, nedges;
    double    toll, tolr, data[4];
    double    xyzbegl[4], xyzendl[4], xyzbegr[4], xyzendr[4];
    ego       eref, *echilds, *eedgesl, *eedgesr, *enodes, *eedges=NULL, eloop=NULL;

    ROUTINE(joinWireBodys);

    /* --------------------------------------------------------------- */

    if (outLevel > 1) {
        SPRINT0(2, "ebodyl");
        ocsmPrintEgo(ebodyl);
        SPRINT0(2, "ebodyr");
        ocsmPrintEgo(ebodyr);
    }

    /* increase toler to the larger of given value and tolerances of
       the input Bodys */
    status = EG_getTolerance(ebodyl, &toll);
    CHECK_STATUS(EG_getTolerance);

    status = EG_getTolerance(ebodyr, &tolr);
    CHECK_STATUS(EG_getTolerance);

    if (toll > toler) toler = toll;
    if (tolr > toler) toler = tolr;

    /* extract the Edges from ebodyl */
    status = EG_getTopology(ebodyl, &eref, &oclass, &mtype,
                            data, &nchild, &echilds, &sensesl);
    CHECK_STATUS(EG_getTopology);

    status = EG_getTopology(echilds[0], &eref, &oclass, &mtype,
                            data, &nedgel, &eedgesl, &sensesl);
    CHECK_STATUS(EG_getTopology);

    /* extract the first and last Node from ebodyl */
    status = EG_getTopology(eedgesl[0], &eref, &oclass, &mtype,
                            data, &nchild, &enodes, &senses);
    CHECK_STATUS(EG_getTopology);

    if (sensesl[0] == SFORWARD) {
        status = EG_getTopology(enodes[0], &eref, &oclass, &mtype,
                                xyzbegl, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);
    } else {
        status = EG_getTopology(enodes[1], &eref, &oclass, &mtype,
                                xyzbegl, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);
    }

    status = EG_getTopology(eedgesl[nedgel-1], &eref, &oclass, &mtype,
                            data, &nchild, &enodes, &senses);
    CHECK_STATUS(EG_getTopology);

    if (sensesl[nedgel-1] == SFORWARD) {
        status = EG_getTopology(enodes[1], &eref, &oclass, &mtype,
                                xyzendl, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);
    } else {
        status = EG_getTopology(enodes[0], &eref, &oclass, &mtype,
                                xyzendl, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);
    }

    /* extract the Edges from ebodyr */
    status = EG_getTopology(ebodyr, &eref, &oclass, &mtype,
                            data, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    status = EG_getTopology(echilds[0], &eref, &oclass, &mtype,
                            data, &nedger, &eedgesr, &sensesr);
    CHECK_STATUS(EG_getTopology);

    /* extract the first and last Node from ebodyr */
    status = EG_getTopology(eedgesr[0], &eref, &oclass, &mtype,
                            data, &nchild, &enodes, &senses);
    CHECK_STATUS(EG_getTopology);

    if (sensesr[0] == SFORWARD) {
        status = EG_getTopology(enodes[0], &eref, &oclass, &mtype,
                                xyzbegr, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);
    } else {
        status = EG_getTopology(enodes[1], &eref, &oclass, &mtype,
                                xyzbegr, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);
    }

    status = EG_getTopology(eedgesr[nedger-1], &eref, &oclass, &mtype,
                            data, &nchild, &enodes, &senses);
    CHECK_STATUS(EG_getTopology);

    if (sensesr[nedger-1] == SFORWARD) {
        status = EG_getTopology(enodes[1], &eref, &oclass, &mtype,
                                xyzendr, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);
    } else {
        status = EG_getTopology(enodes[0], &eref, &oclass, &mtype,
                                xyzendr, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);
    }

    /* make new WireBody if end(l) = beg(r) */
    if        (fabs(xyzendl[0] - xyzbegr[0]) < toler &&
               fabs(xyzendl[1] - xyzbegr[1]) < toler &&
               fabs(xyzendl[2] - xyzbegr[2]) < toler   ) {

        nedges = nedgel + nedger;
        MALLOC(eedges, ego, nedges);
        MALLOC(senses, int, nedges);

        for (i = 0; i < nedgel; i++) {
            eedges[i] = eedgesl[i];
            senses[i] = sensesl[i];
        }
        for (i = 0; i < nedger; i++) {
            eedges[i+nedgel] = eedgesr[i];
            senses[i+nedgel] = sensesr[i];
        }

        status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                 NULL, nedges, eedges, senses, &eloop);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                 NULL, 1, &eloop, NULL, ebody);
        CHECK_STATUS(EG_makeTopology);

    /* make new WireBody if end(l) = end(r) */
    } else if (fabs(xyzendl[0] - xyzendr[0]) < toler &&
               fabs(xyzendl[1] - xyzendr[1]) < toler &&
               fabs(xyzendl[2] - xyzendr[2]) < toler   ) {

        nedges = nedgel + nedger;
        MALLOC(eedges, ego, nedges);
        MALLOC(senses, int, nedges);

        for (i = 0; i < nedgel; i++) {
            eedges[i] =  eedgesl[i];
            senses[i] = -sensesl[i];
        }
        for (i = 0; i < nedger; i++) {
            eedges[i+nedgel] = eedgesr[nedger-1-i];
            senses[i+nedgel] = sensesr[nedger-1-i];
        }

        status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                 NULL, nedges, eedges, senses, &eloop);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                 NULL, 1, &eloop, NULL, ebody);
        CHECK_STATUS(EG_makeTopology);

    /* make new WireBody if beg(l) = beg(r) */
    } else if (fabs(xyzbegl[0] - xyzbegr[0]) < toler &&
               fabs(xyzbegl[1] - xyzbegr[1]) < toler &&
               fabs(xyzbegl[2] - xyzbegr[2]) < toler   ) {

        nedges = nedgel + nedger;
        MALLOC(eedges, ego, nedges);
        MALLOC(senses, int, nedges);

        for (i = 0; i < nedgel; i++) {
            eedges[i] =  eedgesl[nedgel-1-i];
            senses[i] = -sensesl[nedgel-1-i];
        }
        for (i = 0; i < nedger; i++) {
            eedges[i+nedgel] = eedgesr[i];
            senses[i+nedgel] = sensesr[i];
        }

        status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                 NULL, nedges, eedges, senses, &eloop);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                 NULL, 1, &eloop, NULL, ebody);
        CHECK_STATUS(EG_makeTopology);

    /* make new WireBody if end(r) = beg(l) */
    } else if (fabs(xyzendr[0] - xyzbegl[0]) < toler &&
               fabs(xyzendr[1] - xyzbegl[1]) < toler &&
               fabs(xyzendr[2] - xyzbegl[2]) < toler   ) {

        nedges = nedgel + nedger;
        MALLOC(eedges, ego, nedges);
        MALLOC(senses, int, nedges);

        for (i = 0; i < nedger; i++) {
            eedges[i] = eedgesr[i];
            senses[i] = sensesr[i];
        }
        for (i = 0; i < nedgel; i++) {
            eedges[i+nedger] = eedgesl[i];
            senses[i+nedger] = sensesl[i];
        }

        status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                 NULL, nedges, eedges, senses, &eloop);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                 NULL, 1, &eloop, NULL, ebody);
        CHECK_STATUS(EG_makeTopology);

    /* WireBodys ends do not match */
    } else {
        status = OCSM_DID_NOT_CREATE_BODY;
        *ebody = NULL;
        goto cleanup;
    }

    /* cleanup now that WireBody was made */
    status = EG_deleteObject(eloop);
    CHECK_STATUS(EG_deleteObject);

    if (outLevel > 1 && *ebody != NULL) {
        SPRINT0(2, "ebody");
        ocsmPrintEgo(*ebody);
    }

cleanup:
    FREE(eedges);
    FREE(senses);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   makeEdge - make an Edge between eNodes                             *
 *                                                                      *
 ************************************************************************
 */

static int
makeEdge(modl_T *modl,                  /* (in)  pointer to MODL */
         ego    ebeg,                   /* (in)  enode at beginning */
         ego    eend,                   /* (in)  enode at end */
         ego    *eedge)                 /* (out) created Edge */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       oclass, mtype, nchild, *senses;
    double    data[4], xyz_beg[4], xyz_end[4], xyz_line[6], tdata[2], result[3];
    ego       eobj, etopref, eprev, enext, eref, ecurve, *echilds, enodes[2];

    ROUTINE(makeEdge);

    /* --------------------------------------------------------------- */

    /* check to see if there is an Edge already connecting ebeg and eend */
    eobj = MODL->context;
    while (eobj != NULL) {
        status = EG_getInfo(eobj, &oclass, &mtype, &etopref, &eprev, &enext);
        CHECK_STATUS(EG_getInfo);

        if (etopref == MODL->context && oclass == EDGE && mtype == TWONODE) {
            status = EG_getTopology(eobj, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (echilds[0] == ebeg && echilds[1] == eend) {
                *eedge = eobj;
                goto cleanup;
            }
        }

        eobj = enext;
    }

    /* if the two Nodes are the same, we will make a degenerate Edge */
    if (ebeg == eend) {
        tdata[0] = 0;
        tdata[1] = 1;

        status = EG_makeTopology(MODL->context, NULL, EDGE, DEGENERATE, tdata, 1, &ebeg, NULL, eedge);
        CHECK_STATUS(EG_makeTopology);

        goto cleanup;
    }

    /* get the coordinates of the two Nodes */
    status = EG_getTopology(ebeg, &eref, &oclass, &mtype,
                            xyz_beg, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    status = EG_getTopology(eend, &eref, &oclass, &mtype,
                            xyz_end, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    /* create a line between the Nodes */
    xyz_line[0] = xyz_beg[0];
    xyz_line[1] = xyz_beg[1];
    xyz_line[2] = xyz_beg[2];
    xyz_line[3] = xyz_end[0] - xyz_beg[0];
    xyz_line[4] = xyz_end[1] - xyz_beg[1];
    xyz_line[5] = xyz_end[2] - xyz_beg[2];

    status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, xyz_line, &ecurve);
    CHECK_STATUS(EG_makeGeometry);

    /* find the parametric coordinates of the endpoints */
    status = EG_invEvaluate(ecurve, xyz_beg, &(tdata[0]), result);
    CHECK_STATUS(EG_invEvaluate);

    status = EG_invEvaluate(ecurve, xyz_end, &(tdata[1]), result);
    CHECK_STATUS(EG_invEvaluate);

    /* make the Edge */
    enodes[0] = ebeg;
    enodes[1] = eend;
    status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                             tdata, 2, enodes, NULL, eedge);
    CHECK_STATUS(EG_makeTopology);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   makeFace - make a Face from an array of Edges                      *
 *                                                                      *
 ************************************************************************
 */

static int
makeFace(modl_T *modl,                  /* (in)  pointer to MODL */
         ego    eedges_in[],            /* (in)  array of 4 Edges */
         int    fillstyle,              /* (in)  fillstyle argument to EG_isoCline */
         int    dirn,                   /* (in)  direction for first Edge */
         ego    *eface)                 /* (out) created Face */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iedge, jedge, nedge, senses[8], *senses2, oclass, mtype, nchild;
    double    data[4];
    ego       eedges[8], eloop, eref, *echilds, esurface, ebeg, eend;

    ROUTINE(makeFace);

    /* --------------------------------------------------------------- */

    if (eedges_in[3] == NULL) {
        nedge = 3;
    } else {
        nedge = 4;
    }

    /* create a Loop from the Edges */
    status = EG_getTopology(eedges_in[0], &eref, &oclass, &mtype, data,
                            &nchild, &echilds, &senses2);
    CHECK_STATUS(EG_getTopology);

    eedges[0] = eedges_in[0];

    if (dirn >= 0) {
        senses[0] = SFORWARD;
        ebeg      = echilds[0];
        eend      = echilds[1];
    } else {
        senses[0] = SREVERSE;
        ebeg      = echilds[1];
        eend      = echilds[0];
    }

    for (iedge = 1; iedge < nedge; iedge++) {
        for (jedge = 1; jedge < 4; jedge++) {
            if (eedges_in[jedge] == NULL) continue;

            status = EG_getTopology(eedges_in[jedge], &eref, &oclass, &mtype, data,
                                &nchild, &echilds, &senses2);
            CHECK_STATUS(EG_getTopology);

            if        (echilds[0] == eend) {
                eedges[iedge]    = eedges_in[jedge];
                senses[iedge]    = SFORWARD;
                eend             = echilds[1];
                eedges_in[jedge] = NULL;
                break;
            } else if (echilds[1] == eend) {
                eedges[iedge]    = eedges_in[jedge];
                senses[iedge]    = SREVERSE;
                eend             = echilds[0];
                eedges_in[jedge] = NULL;
                break;
            }
        }
    }

    if (eend != ebeg) {
        SPRINT0(0, "ERROR:: Loop is expected to be CLOSED but is OPEN");
        status = OCSM_INTERNAL_ERROR;
        goto cleanup;
    }

    status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED,
                             NULL, nedge, eedges, senses, &eloop);
    CHECK_STATUS(EG_makeTopology);

    /* create a Surface from the Loop (using the overloaded EG_isoCline) */
    status = EG_isoCline(eloop, fillstyle, 0.0, &esurface);
    CHECK_STATUS(EG_isoCline);

    status = EG_deleteObject(eloop);
    CHECK_STATUS(EG_deleteObject);

    /* find the PCurves associated with the Edges */
    for (iedge = 0; iedge < nedge; iedge++) {
        status = EG_otherCurve(esurface, eedges[iedge], 0.0, &(eedges[iedge+nedge]));
        CHECK_STATUS(EG_otherCurve);

        senses[iedge+nedge] = senses[iedge];
    }

    /* make a new Loop and a Face using this Surface */
    status = EG_makeTopology(MODL->context, esurface, LOOP, CLOSED,
                             NULL, nedge, eedges, senses, &eloop);
    CHECK_STATUS(EG_makeTopology);

    status = EG_makeTopology(MODL->context, esurface, FACE, SFORWARD,
                             NULL, 1, &eloop, senses, eface);
    CHECK_STATUS(EG_makeTopology);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   matches - check if two strings match (with * + ? wildcards)        *
 *                                                                      *
 ************************************************************************
 */

static int
matches(char pattern[],                /* (in)  pattern */
  const char string[])                 /* (in)  string to check */
{

    /* --------------------------------------------------------------- */

    /* matching rules:
       ? matches any one character
       + matches one or more characters
       * matches zero or more characters

       use an adaptation of the recursive code found at:
       http://codegolf.stackexchange.com/questions/467/implement-glob-matcher
    */

    if        (*pattern == '*') {
        return matches(pattern+1, string) || (*string && matches(pattern, string+1));

    } else if (*pattern == '+') {
        return *string && (matches(pattern+1, ++string) || matches(pattern, string));

    } else if (*pattern == '?') {
        return *string && matches(pattern+1, string+1);

    } else {
        return *string == *pattern++ && (!*string++ || matches(pattern, string));

    }
}


/*
 ************************************************************************
 *                                                                      *
 *   matsol - Gaussian elimination with partial pivoting                *
 *                                                                      *
 ************************************************************************
 */

static int
matsol(double    A[],                   /* (in)  matrix to be solved (stored rowwise) */
                                        /* (out) upper-triangular form of matrix */
       double    b[],                   /* (in)  right hand side */
                                        /* (out) right-hand side after swapping */
       int       n,                     /* (in)  size of matrix */
       double    x[])                   /* (out) solution of A*x=b */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ir, jc, kc, imax;
    double    amax, swap, fact;

    ROUTINE(matsol);

    /* --------------------------------------------------------------- */

    /* reduce each column of A */
    for (kc = 0; kc < n; kc++) {

        /* find pivot element */
        imax = kc;
        amax = fabs(A[kc*n+kc]);

        for (ir = kc+1; ir < n; ir++) {
            if (fabs(A[ir*n+kc]) > amax) {
                imax = ir;
                amax = fabs(A[ir*n+kc]);
            }
        }

        /* check for possibly-singular matrix (ie, near-zero pivot) */
        if (amax < EPS12) {
            status = OCSM_SINGULAR_MATRIX;
            goto cleanup;
        }

        /* if diagonal is not pivot, swap rows in A and b */
        if (imax != kc) {
            for (jc = 0; jc < n; jc++) {
                swap         = A[kc  *n+jc];
                A[kc  *n+jc] = A[imax*n+jc];
                A[imax*n+jc] = swap;
            }

            swap    = b[kc  ];
            b[kc  ] = b[imax];
            b[imax] = swap;
        }

        /* row-reduce part of matrix to the bottom of and right of [kc,kc] */
        for (ir = kc+1; ir < n; ir++) {
            fact = A[ir*n+kc] / A[kc*n+kc];

            for (jc = kc+1; jc < n; jc++) {
                A[ir*n+jc] -= fact * A[kc*n+jc];
            }

            b[ir] -= fact * b[kc];

            A[ir*n+kc] = 0;
        }
    }

    /* back-substitution pass */
    x[n-1] = b[n-1] / A[(n-1)*n+(n-1)];

    for (jc = n-2; jc >= 0; jc--) {
        x[jc] = b[jc];
        for (kc = jc+1; kc < n; kc++) {
            x[jc] -= A[jc*n+kc] * x[kc];
        }
        x[jc] /= A[jc*n+jc];
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   mvcInterp - interpolate using mean-value coordinates               *
 *                                                                      *
 ************************************************************************
 */

static int
mvcInterp(int        nloop,             /* (in)  number of loops */
          CINT       nlast1[],          /* (in)  last point (plus 1) in each loop */
          CDOUBLE    uvframe[],         /* (in)  coordinates of points in loop(s) */
          CDOUBLE    uv[],              /* (in)  point at which weights should be computed */
          double     weights[])         /* (out) weights associated with each frame point */
{
    int       status = SUCCESS;         /* (out) return status */

    int       i, j, im1, ip1, ibeg, ntotal, k, numneg;
    double    umin, umax, vmin, vmax, du, dv, dl, mu, eps, wi, wsum=0;
    double    du1, dv1, du2, dv2, du3, dv3, den, s, t;
    double    *duv=NULL, *A=NULL, *D=NULL, *R=NULL;

    ROUTINE(mvcInterp);

    /* --------------------------------------------------------------- */

    /* default return */
    ntotal = nlast1[nloop-1];

    for (i = 0; i < ntotal; i++) {
        weights[i] = 0;
    }

    /* get temporary storage */
    MALLOC(duv, double, 2*ntotal);
    MALLOC(A,   double,   ntotal);
    MALLOC(D,   double,   ntotal);
    MALLOC(R,   double,   ntotal);

    /* find the extrema of u and v and an overall tolerance */
    umin = uvframe[0];
    umax = uvframe[0];
    vmin = uvframe[1];
    vmax = uvframe[1];

    for (i = 0; i < ntotal; i++) {
        if (uvframe[2*i  ] < umin) umin = uvframe[2*i  ];
        if (uvframe[2*i  ] > umax) umax = uvframe[2*i  ];
        if (uvframe[2*i+1] < vmin) vmin = uvframe[2*i+1];
        if (uvframe[2*i+1] > vmax) vmax = uvframe[2*i+1];
    }

    eps = EPS12 * sqrt((umax-umin) * (umax-umin) + (vmax-vmin) * (vmax-vmin));

    /* compute A, D, and R for each segment of the frame */
    ibeg = 0;
    for (j = 0; j < nloop; j++) {
        for (i = ibeg; i < nlast1[j]; i++) {
            ip1 = i + 1;
            if (ip1 == nlast1[j]) ip1 = ibeg;

            duv[2*i    ] = uvframe[2*i    ] - uv[0];
            duv[2*i  +1] = uvframe[2*i  +1] - uv[1];
            duv[2*ip1  ] = uvframe[2*ip1  ] - uv[0];
            duv[2*ip1+1] = uvframe[2*ip1+1] - uv[1];

            A[i] =     (duv[2*i    ]*duv[2*ip1+1] - duv[2*ip1  ]*duv[2*i+1]) / 2.0;
            D[i] =      duv[2*ip1  ]*duv[2*i    ] + duv[2*ip1+1]*duv[2*i+1];
            R[i] = sqrt(duv[2*i    ]*duv[2*i    ] + duv[2*i  +1]*duv[2*i+1]);

            /* if any frame point is very close to uv, return weights=1
               for that point */
            if (R[i] <= eps) {
                weights[i] = 1.0;
                goto cleanup;
            }
        }
        ibeg = nlast1[j];
    }

    /* handle the special case when uv lies on one of the segments of
       the frame */
    ibeg = 0;
    for (j = 0; j < nloop; j++) {
        for (i = ibeg; i < nlast1[j]; i++) {
            ip1 = i + 1;
            if (ip1 == nlast1[j]) ip1 = ibeg;

            if ((fabs(A[i]) <= eps) && (D[i] < 0.0)) {
                du = uvframe[2*ip1  ] - uvframe[2*i  ];
                dv = uvframe[2*ip1+1] - uvframe[2*i+1];
                dl = sqrt(du*du + dv*dv);
                if (dl <= eps) {
                    SPRINT0(0, "ERROR:: dl is less than eps");
                    status = OCSM_INTERNAL_ERROR;
                    goto cleanup;
                }

                du = uv[0] - uvframe[2*i  ];
                dv = uv[1] - uvframe[2*i+1];
                mu = sqrt(du*du + dv*dv) / dl;
                if ((mu < 0.0) || (mu > 1.0)) {
                    SPRINT1(0, "ERROR:: mu(=%lf) -- out of range", mu);
                    status = OCSM_INTERNAL_ERROR;
                    goto cleanup;
                }

                weights[i  ] = 1.0 - mu;
                weights[ip1] =       mu;
                goto cleanup;
            }
        }
        ibeg = nlast1[j];
    }

    /* compute the weights for any point in the interior */
    ibeg = 0;
    for (j = 0; j < nloop; j++) {
        for (i = ibeg; i < nlast1[j]; i++) {
            im1 = i - 1;
            if (i   == ibeg)       im1  = nlast1[j]-1;

            ip1 = i + 1;
            if (ip1 == nlast1[j])  ip1  = ibeg;

            wi = 0.0;
            if (fabs(A[im1]) > eps) wi  = (R[im1] - D[im1] / R[i]) / A[im1];
            if (fabs(A[i  ]) > eps) wi += (R[ip1] - D[i  ] / R[i]) / A[i  ];

            wsum       += wi;
            weights[i]  = wi;
        }
        ibeg = nlast1[j];
    }

    /* special code for visibiity-reduced mean value coordinates */
    if (INTERP_VEL == 2) {

        /* set all negtive weights to zero */
        numneg = 0;
        for (i = 0; i < ntotal; i++) {
            if (weights[i] < 0) {
                wsum -= weights[i];
                weights[i] = 0;
                numneg++;
            }
        }

        /* set weights to zero if ray from uv to frame point is
           hidden by another boundary segment */
        if (numneg > 0) {
            for (k = 0; k < ntotal; k++) {
                if (fabs(weights[k]) < EPS12) continue;

                ibeg = 0;
                for (j = 0; j < nloop; j++) {
                    for (i = ibeg; i < nlast1[j]; i++) {
                        if (fabs(weights[k]) < EPS12) break;

                        im1 = i - 1;
                        if (i == ibeg) im1  = nlast1[j]-1;

                        if (im1 == k || i == k) continue;

                        du1 = uvframe[2*k  ] - uv[0];
                        dv1 = uvframe[2*k+1] - uv[1];

                        du2 = uvframe[2*im1  ] - uvframe[2*i  ];
                        dv2 = uvframe[2*im1+1] - uvframe[2*i+1];

                        du3 = uvframe[2*im1  ] - uv[0];
                        dv3 = uvframe[2*im1+1] - uv[1];

                        den = du1 * dv2 - du2 * dv1;

                        if (fabs(den) < EPS12) continue;

                        s = (du3 * dv2 - du2 * dv3) / den;
                        t = (du1 * dv3 - du3 * dv1) / den;

                        if (s > 0 && s < 1 && t >= 0 && t <= 1) {
                            wsum -= weights[k];
                            weights[k] = 0;
                        }
                    }
                    ibeg = nlast1[j];
                }
            }
        }
    }

    /* normalize the weights */
    if (fabs(wsum) > 0.0) {
        for (i = 0; i < ntotal; i++) {
            weights[i] /= wsum;
        }
    }

cleanup:
    FREE(R);
    FREE(D);
    FREE(A);
    FREE(duv);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   newBody - create and initialize a new Body                         *
 *                                                                      *
 ************************************************************************
 */

static int
newBody(modl_T *modl,                   /* (in)  pointer to MODL */
        int    ibrch,                   /* (in)  Branch index (1-mbrch) */
        int    brtype,                  /* (in)  Branch type */
        int    ileft,                   /* (in)  left parent Body (or 0) */
        int    irite,                   /* (in)  rite parent Body (or 0) */
        varg_T args[],                  /* (in)  array of arguments */
        int    hasdots,                 /* (in)  =1 if any arguments have non-zero dots */
        int    botype,                  /* (in)  Body type */
        int    *ibody)                  /* (out) new Body index */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iarg, ival, jbody;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(newBody);

    /* --------------------------------------------------------------- */

    /* extend the Body list (if needed) */
    if (MODL->nbody >= MODL->mbody) {
        MODL->mbody += 25;
        RALLOC(MODL->body, body_T, MODL->mbody+1);

        for (jbody = MODL->nbody+1; jbody <= MODL->mbody; jbody++) {
            MODL->body[jbody].ibrch  =  0;
            MODL->body[jbody].botype =  0;
            MODL->body[jbody].ileft  = -1;
            MODL->body[jbody].irite  = -1;
            MODL->body[jbody].ichld  = -1;
            MODL->body[jbody].igroup = -1;

            for (iarg = 1; iarg < 10; iarg++) {
                MODL->body[jbody].arg[iarg].val = NULL;
                MODL->body[jbody].arg[iarg].dot = NULL;
            }

            MODL->body[jbody].ebody   = NULL;
            MODL->body[jbody].etess   = NULL;
            MODL->body[jbody].npnts   = 0;
            MODL->body[jbody].ntris   = 0;

            MODL->body[jbody].onstack = 0;
            MODL->body[jbody].hasdots = 0;
            MODL->body[jbody].botype  = 0;
            MODL->body[jbody].CPU     = 0;
            MODL->body[jbody].nnode   = 0;
            MODL->body[jbody].node    = NULL;
            MODL->body[jbody].nedge   = 0;
            MODL->body[jbody].edge    = NULL;
            MODL->body[jbody].nface   = 0;
            MODL->body[jbody].face    = NULL;
            MODL->body[jbody].sens    = 0;
        }
    }

    /* create the new Body and initialize it */
    MODL->nbody++;

    MODL->ngroup++;

    *ibody = MODL->nbody;
    MODL->body[*ibody].ibrch  = ibrch;
    MODL->body[*ibody].brtype = brtype;
    MODL->body[*ibody].ileft  = ileft;
    MODL->body[*ibody].irite  = irite;
    MODL->body[*ibody].ichld  = 0;
    MODL->body[*ibody].igroup = MODL->ngroup;

    for (iarg = 1; iarg < 10; iarg++) {
        MODL->body[*ibody].arg[iarg].nval = args[iarg].nval;
        MODL->body[*ibody].arg[iarg].nrow = args[iarg].nrow;
        MODL->body[*ibody].arg[iarg].ncol = args[iarg].ncol;

        if (args[iarg].nval == 0) {
            MALLOC(MODL->body[*ibody].arg[iarg].str, char, (int)(STRLEN(args[iarg].str)+1));

            strcpy(MODL->body[*ibody].arg[iarg].str, args[iarg].str);

            if (MODL->body[*ibody].arg[iarg].dot != NULL) {
                SPRINT2(0, "ERROR:: MODL->body[%d].arg[%d].dot is not NULL", *ibody, iarg);
                status = BAD_MALLOC;
                goto cleanup;
            }
        } else if (args[iarg].nval > 0) {
            MALLOC(MODL->body[*ibody].arg[iarg].val, double, args[iarg].nval);
            MALLOC(MODL->body[*ibody].arg[iarg].dot, double, args[iarg].nval);

            for (ival = 0; ival < args[iarg].nval; ival++) {
                MODL->body[*ibody].arg[iarg].val[ival] = args[iarg].val[ival];
                MODL->body[*ibody].arg[iarg].dot[ival] = args[iarg].dot[ival];
            }
        }
    }

    MODL->body[*ibody].ebody = NULL;
    MODL->body[*ibody].etess = NULL;
    MODL->body[*ibody].npnts = 0;
    MODL->body[*ibody].ntris = 0;

    MODL->body[*ibody].onstack = 0;
    MODL->body[*ibody].hasdots = hasdots;
    MODL->body[*ibody].botype  = botype;
    MODL->body[*ibody].CPU     = 0;
    MODL->body[*ibody].nnode   = 0;
    MODL->body[*ibody].node    = NULL;
    MODL->body[*ibody].nedge   = 0;
    MODL->body[*ibody].edge    = NULL;
    MODL->body[*ibody].nface   = 0;
    MODL->body[*ibody].face    = NULL;
    MODL->body[*ibody].sens    = 0;

    /* link children */
    if (ileft > 0) {
        MODL->body[ileft].ichld = *ibody;
    }
    if (irite > 0) {
        MODL->body[irite].ichld = *ibody;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   parseName - parse namestr into Parameter name, row, and column     *
 *                                                                      *
 ************************************************************************
 */

static int
parseName(modl_T *modl,                 /* (in)  pointer to MODL */
          char   string[],              /* (in)  name string to parse */
          char   pname[],               /* (out) Parameter name (at least MAX_NAME_LEN long) */
          int    *ipmtr,                /* (out) Parameter index (1-npmtr) or 0 if none */
          int    *irow,                 /* (out) row index (bias-1) */
                                        /*       =0 if not given, =-999 if given as : */
          int    *icol)                 /* (out) column index (bias-1) */
                                        /*       =0 if not given, =-999 if given as : */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       i, icount, jcount, jpmtr;
    double    rownum, colnum, dot;
    char      row[MAX_EXPR_LEN], col[MAX_EXPR_LEN];
    char      str[MAX_STRVAL_LEN];

    ROUTINE(parseName);

    /* --------------------------------------------------------------- */

    /* break str1 into pname[irow,icol]
          name      -> irow=   0, icol=   0
          name[1,2] -> irow=   1, icol=   2
          name[:,2] -> irow=-999, icol=   2
          name[1,:] -> irow=   1, icol=-999
          name[:,:] -> irow=-999, icol=-999
          name[1]   -> error
    */

    /* peel off each part of pname[irow,icol] */
    if (strstr(string, ",") != NULL) {
        pname[0] = '\0';
        row[0]   = '\0';
        col[0]   = '\0';
        icount   = 0;
        jcount   = 0;

        for (i = 0; i < STRLEN(string); i++) {
            if (icount == 0) {
                if (string[i] != '[') {
                    pname[jcount  ] = string[i];
                    pname[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    jcount = 0;
                }
            } else if (icount == 1) {
                if (string[i] != ',') {
                    row[jcount  ] = string[i];
                    row[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    jcount = 0;
                }
            } else {
                if (string[i] != ']') {
                    col[jcount  ] = string[i];
                    col[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    break;
                }
            }
        }

    /* otherwise try peeling off each part of pname[irow] (with icol=1) */
    } else {
        pname[0] = '\0';
        row[0]   = '\0';
        col[0]   = '\0';
        icount   = 0;
        jcount   = 0;

        for (i = 0; i < STRLEN(string); i++) {
            if (icount == 0) {
                if (string[i] != '[') {
                    pname[jcount  ] = string[i];
                    pname[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    jcount = 0;
                }
            } else {
                if (string[i] != ']') {
                    col[0] = '0';
                    col[1] = '\0';

                    row[jcount  ] = string[i];
                    row[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    icount++;
                    break;
                }
            }
        }
    }

    /* return error if not in specified form */
    if (icount != 0 && icount != 3) {
        status = OCSM_ILLEGAL_PMTR_NAME;
        goto cleanup;
    }

    /* convert row and col to an integer */
    if (STRLEN(row) == 0) {
        *irow = 0;
    } else if (strcmp(row, ":") == 0) {
        *irow = -999;
    } else {
        status = str2val(row, MODL, &rownum, &dot, str);
        CHECK_STATUS(str2val:row);
        if (STRLEN(str) > 0) {
            status = OCSM_WRONG_PMTR_TYPE;
            goto cleanup;
        }

        *irow = NINT(rownum);
    }

    if (STRLEN(col) == 0) {
        *icol = 0;
    } else if (strcmp(col, ":") == 0) {
        *icol = -999;
    } else {
        status = str2val(col, MODL, &colnum, &dot, str);
        CHECK_STATUS(str2val:col);
        if (STRLEN(str) > 0) {
            status = OCSM_WRONG_PMTR_TYPE;
            goto cleanup;
        }

        *icol = NINT(colnum);
    }

    /* look for current Parameter index */
    *ipmtr = 0;
    for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
        if (strcmp(MODL->pmtr[jpmtr].name, pname) == 0) {
            if (MODL->pmtr[jpmtr].type == OCSM_OUTPUT) {
                *ipmtr = jpmtr;
                break;
            } else if (MODL->pmtr[jpmtr].scope == MODL->scope[MODL->level]) {
                *ipmtr = jpmtr;
                break;
            }
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   printAttrs - prints Attributes associated with an ebody            *
 *                                                                      *
 ************************************************************************
 */

static int
printAttrs(ego    ebody)                /* (in)  pointer to Body */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nlist, nattr, iattr, nface, nedge, nnode, iface, iedge, inode;

    int       itype, i;
    CINT      *tempIlist;
    double    bbox[6];
    CDOUBLE   *tempRlist;
    CCHAR     *attrName, *tempClist;
    ego       *efaces, *eedges, *enodes;

    ROUTINE(printAttrs);

    /* --------------------------------------------------------------- */

    /* Body Attributes */
    status = EG_attributeNum(ebody, &nattr);
    CHECK_STATUS(EG_attributeNum);

    SPRINT0(0, "    Body");

    for (iattr = 1; iattr <= nattr; iattr++) {
        status = EG_attributeGet(ebody, iattr, &attrName, &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeGet);

        SPRINT1x(0, "        %-20s =", attrName);

        if        (itype == ATTRINT) {
            for (i = 0; i < nlist; i++) {
                SPRINT1x(0, "%5d ", tempIlist[i]);
            }
            SPRINT0(0, " ");
        } else if (itype == ATTRREAL) {
            for (i = 0; i < nlist; i++) {
                SPRINT1x(0, "%11.5f ", tempRlist[i]);
            }
            SPRINT0(0, " ");
        } else if (itype == ATTRCSYS) {
            for (i = 0; i < nlist; i++) {
                SPRINT1x(0, "%11.5f ", tempRlist[i]);
            }
            SPRINT0(0, "                             =");
            for (i = nlist; i < nlist+12; i++) {
                SPRINT1x(0, "%11.5f ", tempRlist[i]);
            }
            SPRINT0(0, " ");
        } else if (itype == ATTRSTRING) {
            SPRINT1(0, "%s", tempClist);
        }
    }

    /* for each Face associated with ebody, get its Attributes and bounding box */
    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    for (iface = 0; iface < nface; iface++) {
        status = EG_getBoundingBox(efaces[iface], bbox);
        CHECK_STATUS(EG_getBoundingBox);

        SPRINT7(0, "    iface  = %d   (%10.5f %10.5f %10.5f -> %10.5f %10.5f %10.5f)",
                iface+1, bbox[0], bbox[1], bbox[2], bbox[3], bbox[4], bbox[5]);

        status = EG_attributeNum(efaces[iface], &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(efaces[iface], iattr, &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            SPRINT1x(0, "        %-20s =", attrName);

            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
                SPRINT0(0, "                             =");
                for (i = nlist; i < nlist+12; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                SPRINT1x(0, "%s", tempClist);
            }
            SPRINT0(0, " ");
        }
    }

    EG_free(efaces);

    /* for each Edge associated with ebody, get its Attributes and bounding box */
    status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, &eedges);
    CHECK_STATUS(EG_getBodyTopos);

    for (iedge = 0; iedge < nedge; iedge++) {
        status = EG_getBoundingBox(eedges[iedge], bbox);
        CHECK_STATUS(EG_getBoundingBox);

        SPRINT7(0, "    iedge  = %d   (%10.5f %10.5f %10.5f -> %10.5f %10.5f %10.5f)",
                iedge+1, bbox[0], bbox[1], bbox[2], bbox[3], bbox[4], bbox[5]);

        status = EG_attributeNum(eedges[iedge], &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(eedges[iedge], iattr, &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            SPRINT1x(0, "        %-20s =", attrName);

            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
                SPRINT0(0, "                             =");
                for (i = nlist; i < nlist+12; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                SPRINT1x(0, "%s", tempClist);
            }
            SPRINT0(0, " ");
        }
    }

    EG_free(eedges);

    /* for each Node associated with ebody, get its Attributes */
    status = EG_getBodyTopos(ebody, NULL, NODE, &nnode, &enodes);
    CHECK_STATUS(EG_getBodyTopos);

    for (inode = 0; inode < nnode; inode++) {
        int oclass, mtype, nchild, *senses;
        ego eref, *echilds;

        status = EG_getTopology(enodes[inode], &eref, &oclass, &mtype, bbox,
                                &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        SPRINT4(0, "    inode  = %d   (%10.5f %10.5f %10.5f)",
                inode+1, bbox[0], bbox[1], bbox[2]);

        status = EG_attributeNum(enodes[inode], &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(enodes[inode], iattr, &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            SPRINT1x(0, "        %-20s =", attrName);

            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
                SPRINT0(0, "                             =");
                for (i = nlist; i < nlist+12; i++) {
                    SPRINT1x(0, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                SPRINT1x(0, "%s", tempClist);
            }
            SPRINT0(0, " ");
        }
    }

    EG_free(enodes);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   printPmtrs - print all Parameters to file                          *
 *                                                                      *
 ************************************************************************
 */

static int
printPmtrs(modl_T *modl,                /* (in)  pointer to MODL */
           FILE   *fp)                  /* (in)  pointer to FILE */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ipmtr, irow, icol, index;

    ROUTINE(printPmtrs);

    /* --------------------------------------------------------------- */

    /* loop through all Parameters and print its name and value */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if        (MODL->pmtr[ipmtr].type == OCSM_EXTERNAL) {
            fprintf(fp, "    %5d [e]  %-32s",   ipmtr,                          MODL->pmtr[ipmtr].name);
        } else if (MODL->pmtr[ipmtr].type == OCSM_CONFIG) {
            fprintf(fp, "    %5d [f]  %-32s",   ipmtr,                          MODL->pmtr[ipmtr].name);
        } else if (MODL->pmtr[ipmtr].type == OCSM_INTERNAL) {
            fprintf(fp, "    %5d [%1d]  %-32s", ipmtr, MODL->pmtr[ipmtr].scope, MODL->pmtr[ipmtr].name);
        } else if (MODL->pmtr[ipmtr].type == OCSM_CONSTANT) {
            fprintf(fp, "    %5d [c]  %-32s",   ipmtr,                          MODL->pmtr[ipmtr].name);
        }

        if (MODL->pmtr[ipmtr].str != NULL) {
            fprintf(fp, " ---------  %-s\n", MODL->pmtr[ipmtr].str);
        } else {
            index = 0;
            for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    if (index > 0) {
                        fprintf(fp, "\n                                               ");
                    }

                    fprintf(fp, " [%3d,%3d] %11.5f %11.5f",
                            irow, icol,
                            MODL->pmtr[ipmtr].value[index],
                            MODL->pmtr[ipmtr].dot[  index]);

                    if (MODL->pmtr[ipmtr].type != OCSM_EXTERNAL &&
                        MODL->pmtr[ipmtr].type != OCSM_CONFIG     ) {
                    } else if (MODL->pmtr[ipmtr].lbnd[index] <= -HUGEQ) {
                        fprintf(fp, "    >>   unbounded");
                    } else {
                        fprintf(fp, "    >> %11.5f", MODL->pmtr[ipmtr].lbnd[ index]);
                    }

                    if (MODL->pmtr[ipmtr].type != OCSM_EXTERNAL &&
                        MODL->pmtr[ipmtr].type != OCSM_CONFIG     ) {
                    } else if (MODL->pmtr[ipmtr].ubnd[index] >= +HUGEQ) {
                        fprintf(fp, " <<   unbounded");
                    } else {
                        fprintf(fp, " << %11.5f",   MODL->pmtr[ipmtr].ubnd[ index]);
                    }

                    index++;
                }
            }
            fprintf(fp, "\n");
        }
    }

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   rank - compute the rank of a matrix                                *
 *                                                                      *
 ************************************************************************
 */

static int
rank(double mat[],                      /* (in)  input matrix */
     int    nrow,                       /* (in)  number of rows */
     int    ncol)                       /* (in)  number of columns */
{
    int       status = SUCCESS;         /* (out) return status or rank */

    int       i, j, ii, jj, pivot;
    double    amax, swap, *A=NULL;

    ROUTINE(rank);

    /* --------------------------------------------------------------- */

    assert(nrow > 0);
    assert(ncol > 0);

    /* make a copy of the matrix */
    MALLOC(A, double, nrow*ncol);

    for (i = 0; i < nrow; i++) {
        for (j = 0; j < ncol; j++) {
            A[i*ncol+j] = mat[i*ncol+j];
        }
    }

    /* convert A to row reduced echelon form */
    i = 0;
    for (j = 0; j < ncol; j++) {

        /* find largest element in column j (in row i or below) */
        amax  = A[i*ncol+j];
        pivot = i;

        for (ii = i+1; ii < nrow; ii++) {
            if (fabs(A[ii*ncol+j]) > fabs(amax)) {
                amax = A[ii*ncol+j];
                pivot = ii;
            }
        }

        /* if pivot is nearly zero, skip to next column */
        if (fabs(amax) < EPS12) continue;

        /* swap rows i and pivot */
        if (i != pivot) {
            for (jj = 0; jj < ncol; jj++) {
                swap             = A[pivot*ncol+jj];
                A[pivot*ncol+jj] = A[i    *ncol+jj];
                A[i    *ncol+jj] = swap;
            }
        }

        /* normalize row i */
        for (jj = 0; jj < ncol; jj++) {
            A[i*ncol+jj] /= amax;
        }

        /* reduce rest of rows */
        for (ii = i+1; ii < nrow; ii++) {
            amax = A[ii*ncol+j];
            for (jj = j; jj < ncol; jj++) {
                A[ii*ncol+jj] -= amax * A[i*ncol+jj];
            }
        }

        /* next row */
        i++;
        if (i >= nrow) break;
    }

    /* rank (which is stored in status) is number of non-zero rows */
    for (i = 0; i < nrow; i++) {
        for (j = 0; j < ncol; j++) {
            if (fabs(A[i*ncol+j]) > EPS06) {
                status++;
                break;
            }
        }
    }

cleanup:
    FREE(A);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   rbfWeights - compute radial-basis function (RBF) weights           *
 *                                                                      *
 ************************************************************************
 */

static int
rbfWeights(int        nbnd,             /* (in)  number of boundary points */
           double     srad2,            /* (in)  support radius squared */
           CDOUBLE    uv[],             /* (in)  location of boundary points */
           double     duv[],            /* (in)  velocity of boundary points */
           double     weights[])        /* (out) RBF weights */
{
    int  status = SUCCESS;

    int        i, j;
    double     *mat=NULL, *rhs=NULL, *W=NULL, *ans=NULL;

    ROUTINE(rbfWeights);

    /* --------------------------------------------------------------- */

    MALLOC(mat, double, nbnd*nbnd);
    MALLOC(rhs, double, nbnd     );
    MALLOC(W,   double, nbnd     );
    MALLOC(ans, double, nbnd     );

    /* set up matrix */
    for (i = 0; i < nbnd; i++) {
        for (j = 0; j < nbnd; j++) {
            mat[(i  )*nbnd+(j  )] = wendland(&uv[2*i], &uv[2*j], srad2);
        }
    }

    /* solve for u-weights */
    for (i = 0; i < nbnd; i++) {
        rhs[i] = duv[2*i  ];
    }

    status = solsvd(mat, rhs, nbnd, nbnd, W, ans);
    CHECK_STATUS(solsvd);

    for (i = 0; i < nbnd; i++) {
        weights[2*i  ] = ans[i];
    }

    /* solve for v-weights */
    for (i = 0; i < nbnd; i++) {
        rhs[i] = duv[2*i+1];
    }

    status = solsvd(mat, rhs, nbnd, nbnd, W, ans);
    CHECK_STATUS(solsvd);

    for (i = 0; i < nbnd; i++) {
        weights[2*i+1] = ans[i];
    }

cleanup:
    FREE(mat);
    FREE(rhs);
    FREE(W   );
    FREE(ans);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtCompareKeys - compare (ikey1,ikey2,ikey3,ikey4) with (jkey1,jkey2,jkey3,jkey4) and return -1/0/+1 *
 *                                                                      *
 ************************************************************************
 */
static int
rbtCompareKeys(int    ikey1,            /* first  key of i */
               int    jkey1,            /* first  key of j */
               int    ikey2,            /* second key of i */
               int    jkey2,            /* second key of j */
               int    ikey3,            /* third  key of i */
               int    jkey3,            /* third  key of j */
               int    ikey4,            /* fourth key of i */
               int    jkey4)            /* fourth key of j */
{
                                        /* (out) -1, or 0, or +1 */

    ROUTINE(rbtCompareKeys);

    /* --------------------------------------------------------------- */

    /* compare primary keys */
    if        (ikey1 < jkey1) {
        return -1;
    } else if (ikey1 > jkey1) {
        return +1;

    /* compare secondary keys */
    } else if (ikey2 < jkey2) {
        return -1;
    } else if (ikey2 > jkey2) {
        return +1;

    /* compare tertiary keys */
    } else if (ikey3 < jkey3) {
        return -1;
    } else if (ikey3 > jkey3) {
        return +1;

    /* compare quaternary keys */
    } else if (ikey4 < jkey4) {
        return -1;
    } else if (ikey4 > jkey4) {
        return +1;

    /* all keys are the same */
    } else {
        return 0;
    }
}


/*
 ************************************************************************
 *                                                                      *
 * rbtCreate - create a new Tree                                        *
 *                                                                      *
 * Reference: "Introduction to Algorithms" by Thomas Cormen,            *
 *             Charles Leiserson, and Ronald Rivest, McGraw-Hill,       *
 *             1991, pp 244-280.                                        *
 *                                                                      *
 ************************************************************************
 */
static int
rbtCreate(int    chunk,                 /* (in)  chunk size for allocations */
          rbt_T  **tree)                /* (out) pointer to new RBT */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(rbtCreate);

    /* --------------------------------------------------------------- */

    /* default return value */
    *tree = NULL;

    /* get a new Tree and a default number of Nodes */
    MALLOC(*tree, rbt_T, 1);

    (*tree)->mnode = chunk;
    (*tree)->chunk = chunk;
    (*tree)->key1  = NULL;
    (*tree)->key2  = NULL;
    (*tree)->key3  = NULL;
    (*tree)->key4  = NULL;
    (*tree)->data  = NULL;
    (*tree)->left  = NULL;
    (*tree)->rite  = NULL;
    (*tree)->prnt  = NULL;
    (*tree)->colr  = NULL;

    MALLOC((*tree)->key1, int, (*tree)->mnode);
    MALLOC((*tree)->key2, int, (*tree)->mnode);
    MALLOC((*tree)->key3, int, (*tree)->mnode);
    MALLOC((*tree)->key4, int, (*tree)->mnode);
    MALLOC((*tree)->data, int, (*tree)->mnode);
    MALLOC((*tree)->left, int, (*tree)->mnode);
    MALLOC((*tree)->rite, int, (*tree)->mnode);
    MALLOC((*tree)->prnt, int, (*tree)->mnode);
    MALLOC((*tree)->colr, int, (*tree)->mnode);

    /* initialize the Tree */
    (*tree)->nnode =  0;
    (*tree)->root  = -1;

cleanup:
    return status;
}


/*
 ******************************************************************************
 *                                                                            *
 * rbtDelete - delete an entire Tree                                          *
 *                                                                            *
 ******************************************************************************
 */
static int
rbtDelete(rbt_T   *tree)                /* (in)  pointer to RBT */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(rbtDelete);

    /* --------------------------------------------------------------- */

    /* check for valid tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* free all elements in the Tree and then the Tree itself */
    FREE(tree->key1);
    FREE(tree->key2);
    FREE(tree->key3);
    FREE(tree->key4);
    FREE(tree->data);
    FREE(tree->left);
    FREE(tree->rite);
    FREE(tree->prnt);
    FREE(tree->colr);

    FREE(tree);

cleanup:
    return status;
}


/*
 ******************************************************************************
 *                                                                            *
 * rbtInsert - insert a Node into a Tree                                      *
 *                                                                            *
 ******************************************************************************
 */
static int
rbtInsert(rbt_T   *tree,                /* (in)  poiner to RBT */
          int     key1,                 /* (in)  first  key */
          int     key2,                 /* (in)  second key */
          int     key3,                 /* (in)  third  key */
          int     key4,                 /* (in)  fourth key */
          int     data)                 /* (in)  associated data */
{
    int       status = SUCCESS;         /* (out) index of node created (bias-0) */
                                        /*       or return status */

    int    inode, ix, iy, iz, ipz, ippz;

    ROUTINE(rbtInsert);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* expand size of Tree if we have used up all available Nodes */
    if (tree->nnode >= tree->mnode) {
        tree->mnode += tree->chunk;
        RALLOC(tree->key1, int, tree->mnode);
        RALLOC(tree->key2, int, tree->mnode);
        RALLOC(tree->key3,  int, tree->mnode);
        RALLOC(tree->key4,  int, tree->mnode);
        RALLOC(tree->data,  int, tree->mnode);
        RALLOC(tree->left,  int, tree->mnode);
        RALLOC(tree->rite,  int, tree->mnode);
        RALLOC(tree->prnt,  int, tree->mnode);
        RALLOC(tree->colr,  int, tree->mnode);
    }

    /* put the new Node at the bottom of the Tree */
    tree->key1[tree->nnode] = key1;
    tree->key2[tree->nnode] = key2;
    tree->key3[tree->nnode] = key3;
    tree->key4[tree->nnode] = key4;
    tree->data[tree->nnode] = data;
    tree->left[tree->nnode] = -1;
    tree->rite[tree->nnode] = -1;
    tree->prnt[tree->nnode] = -1;       /* over-written below */
    tree->colr[tree->nnode] = -1;       /* over-written below */
    tree->nnode ++;

    /* find out where the new Node will fall into the current Tree */
    iz = tree->nnode - 1;
    iy = -1;
    ix = tree->root;

    while (ix >= 0) {
        iy = ix;
        if (rbtCompareKeys(key1, tree->key1[ix],
                           key2, tree->key2[ix],
                           key3, tree->key3[ix],
                           key4, tree->key4[ix]) < 0) {
            ix = tree->left[ix];
        } else {
            ix = tree->rite[ix];
        }
    }

    /* link the new Node to its parent and vice versa */

    tree->prnt[iz] = iy;

    if (iy == -1) {
        tree->root = iz;
    } else if (rbtCompareKeys(key1, tree->key1[iy],
                              key2, tree->key2[iy],
                              key3, tree->key3[iy],
                              key4, tree->key4[iy]) < 0) {
        tree->left[iy] = iz;
    } else {
        tree->rite[iy] = iz;
    }

    /* make inode (the returned value) point to the new Node */
    inode = iz;

    /* now start reordering the Tree following the red-black algorithm
          so that the Tree is a balanced as possible */
    tree->colr[iz] = RBT_RED;

    /* determine what violations of the red-black properties were
          introduced above */
    while ((iz != tree->root) && (tree->colr[tree->prnt[iz]] == RBT_RED)) {

        /* move a violation of the red-child-black-parent violation up
              the Tree while maintaining that every simple path from
              a Nde to a descendent leaf contains the same number
              of black Nodes */

        ipz  = tree->prnt[iz ];
        ippz = tree->prnt[ipz];

        if (ipz == tree->left[ippz]) {
            iy = tree->rite[ippz];

            if ((iy >= 0) && (tree->colr[iy] == RBT_RED)) {
                tree->colr[ipz ] = RBT_BLACK;
                tree->colr[iy  ] = RBT_BLACK;
                tree->colr[ippz] = RBT_RED;
                iz               = ippz;
            } else {
                if (iz == tree->rite[ipz]) {
                    iz = ipz;
                    rbtRotateLeft(tree, iz);
                }

                ipz  = tree->prnt[iz ];
                ippz = tree->prnt[ipz];

                tree->colr[ipz ] = RBT_BLACK;
                tree->colr[ippz] = RBT_RED;
                rbtRotateRite(tree, ippz);
            }
        } else {
            iy = tree->left[ippz];

            if ((iy >= 0) && (tree->colr[iy] == RBT_RED)) {
                tree->colr[ipz ] = RBT_BLACK;
                tree->colr[iy  ] = RBT_BLACK;
                tree->colr[ippz] = RBT_RED;
                iz               = ippz;
            } else {
                if (iz == tree->left[ipz]) {
                    iz = ipz;
                    rbtRotateRite(tree, iz);
                }

                ipz  = tree->prnt[iz ];
                ippz = tree->prnt[ipz];

                tree->colr[ipz ] = RBT_BLACK;
                tree->colr[ippz] = RBT_RED;
                rbtRotateLeft(tree, ippz);
            }
        }
    }

    /* finally color the Root of the tree black */
    tree->colr[tree->root] = RBT_BLACK;

    status = inode;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtLookup - look up data associated with a node                      *
 *                                                                      *
 ************************************************************************
 */
static int
rbtLookup(rbt_T   *tree,                /* pointer to RBT */
          int     inode)                /* node to look up */
{
    int       status = SUCCESS;         /* (out) data value at inode */
                                        /*       or return status */

    ROUTINE(rbtLookup);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* check for valid istart */
    if (inode < 0 || inode >= tree->nnode) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    status = tree->data[inode];

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtMaximum - find rite-most Node in subTree                          *
 *                                                                      *
 ************************************************************************
 */
//$$$static int
//$$$rbtMaximum(rbt_T   *tree,               /* (in)  pointer to RBT */
//$$$           int     istart)              /* (in)  node at which to start search */
//$$${
//$$$    int       status = SUCCESS;         /* (out) index of rite-most node (bias-0) */
//$$$                                        /*       or return status */
//$$$    int ix;
//$$$
//$$$    ROUTINE(rbtMaximum);
//$$$
//$$$    /* --------------------------------------------------------------- */
//$$$
//$$$    /* check for valid Tree */
//$$$    if (tree == NULL) {
//$$$        status = OCSM_ILLEGAL_ARGUMENT;
//$$$        goto cleanup;
//$$$    }
//$$$
//$$$    /* check for valid istart */
//$$$    if (istart < 0 || istart >= tree->nnode) {
//$$$        status = OCSM_ILLEGAL_VALUE;
//$$$        goto cleanup;
//$$$    }
//$$$
//$$$    /* start at given istart or root if istart < 0 */
//$$$    if (istart < 0) {
//$$$        ix = tree->root;
//$$$    } else {
//$$$        ix = istart;
//$$$    }
//$$$
//$$$    /* find the ritemost Node by following the rite children */
//$$$    while (tree->rite[ix] >= 0) {
//$$$        ix = tree->rite[ix];
//$$$    }
//$$$
//$$$    status = ix;
//$$$
//$$$cleanup:
//$$$    return status;
//$$$}


/*
 ************************************************************************
 *                                                                      *
 * rbtMinimum - find left-most Node in subTree                          *
 *                                                                      *
 ************************************************************************
 */
//$$$static int
//$$$rbtMinimum(rbt_T   *tree,               /* (in)  pointer to RBT */
//$$$           int     istart)              /* (in)  node at which to start search */
//$$${
//$$$    int       status = SUCCESS;         /* (out) index of left-most node (bias-0) */
//$$$                                        /*       or return status */
//$$$    int ix;
//$$$
//$$$    ROUTINE(rbtMinimum);
//$$$
//$$$    /* --------------------------------------------------------------- */
//$$$
//$$$    /* check for valid Tree */
//$$$    if (tree == NULL) {
//$$$        status = OCSM_ILLEGAL_ARGUMENT;
//$$$        goto cleanup;
//$$$    }
//$$$
//$$$    /* check for valid istart */
//$$$    if (istart < 0 || istart >= tree->nnode) {
//$$$        status = OCSM_ILLEGAL_VALUE;
//$$$        goto cleanup;
//$$$    }
//$$$
//$$$    /* start at given istart or root if istart < 0 */
//$$$    if (istart < 0) {
//$$$        ix = tree->root;
//$$$    } else {
//$$$        ix = istart;
//$$$    }
//$$$
//$$$    /* find the leftmost Node by following the left children */
//$$$    while (tree->left[ix] >= 0) {
//$$$        ix = tree->left[ix];
//$$$    }
//$$$
//$$$    status = ix;
//$$$
//$$$cleanup:
//$$$    return status;
//$$$}


/*
 ************************************************************************
 *                                                                      *
 * rbtNext - find Node immediately to the rite                          *
 *                                                                      *
 ************************************************************************
 */
//$$$static int
//$$$rbtNext(rbt_T   *tree,                  /* (in)  pointer to RBT */
//$$$        int     istart)                 /* (in)  node at which to start search */
//$$${
//$$$    int       status = SUCCESS;         /* (out) index of node to rite (bias-0) */
//$$$                                        /*       or return status */
//$$$    int ix, iy;
//$$$
//$$$    ROUTINE(rbtNext);
//$$$
//$$$    /* --------------------------------------------------------------- */
//$$$
//$$$    /* check for valid Tree */
//$$$    if (tree == NULL) {
//$$$        status = OCSM_ILLEGAL_ARGUMENT;
//$$$        goto cleanup;
//$$$    }
//$$$
//$$$    /* check for valid istart */
//$$$    if (istart < 0 || istart >= tree->nnode) {
//$$$        status = OCSM_ILLEGAL_VALUE;
//$$$        goto cleanup;
//$$$    }
//$$$
//$$$    /* start at given istart or root if istart < 0 */
//$$$    if (istart < 0) {
//$$$        ix = tree->root;
//$$$    } else {
//$$$        ix = istart;
//$$$    }
//$$$
//$$$    /* if the rite child is not empty, then find the minimum of the
//$$$          Tree starting at the rite child */
//$$$    if (tree->rite[ix] >= 0) {
//$$$        status = rbtMinimum(tree, tree->rite[ix]);
//$$$
//$$$    /* otherwise, iy is the lowest ancestor of ix whose left child
//$$$          is also an ancestor of ix */
//$$$    } else {
//$$$        iy = tree->prnt[ix];
//$$$
//$$$        while ((iy >= 0) && (ix == tree->rite[iy])) {
//$$$            ix = iy;
//$$$            iy = tree->prnt[iy];
//$$$        }
//$$$
//$$$        status = iy;
//$$$    }
//$$$
//$$$cleanup:
//$$$    return status;
//$$$}


/*
 ************************************************************************
 *                                                                      *
 * rbtPrev - find Node immediately to the left                          *
 *                                                                      *
 ************************************************************************
 */
//$$$static int
//$$$rbtPrev(rbt_T   *tree,                  /* (in)  pointer to RBT */
//$$$        int     istart)                 /* (in)  node at which to start */
//$$${
//$$$    int       status = SUCCESS;         /* (out) index of node to left (bias-0) */
//$$$                                        /*       or return status */
//$$$    int ix, iy;
//$$$
//$$$    ROUTINE(rbtPrev);
//$$$
//$$$    /* --------------------------------------------------------------- */
//$$$
//$$$    /* check for valid Tree */
//$$$    if (tree == NULL) {
//$$$        status = OCSM_ILLEGAL_ARGUMENT;
//$$$        goto cleanup;
//$$$    }
//$$$
//$$$    /* check for valid istart */
//$$$    if (istart < 0 || istart >= tree->nnode) {
//$$$        status = OCSM_ILLEGAL_VALUE;
//$$$        goto cleanup;
//$$$    }
//$$$
//$$$    /* start at given istart or root if istart < 0 */
//$$$    if (istart < 0) {
//$$$        ix = tree->root;
//$$$    } else {
//$$$        ix = istart;
//$$$    }
//$$$
//$$$    /* if the left child is not empty, then find the maximum of the
//$$$          Tree starting at the left child */
//$$$    if (tree->left[ix] >= 0) {
//$$$        status = rbtMaximum(tree, tree->left[ix]);
//$$$
//$$$    /* otherwise, iy is the lowest ancestor of ix whose rite child
//$$$          is also an ancestor of ix */
//$$$    } else {
//$$$        iy = tree->prnt[ix];
//$$$
//$$$        while ((iy >= 0) && (ix == tree->left[iy])) {
//$$$            ix = iy;
//$$$            iy = tree->prnt[iy];
//$$$        }
//$$$
//$$$        status = iy;
//$$$    }
//$$$
//$$$cleanup:
//$$$    return status;
//$$$}


/*
 ************************************************************************
 *                                                                      *
 * rbtRotateLeft - rotate Nodes to the left                             *
 *                                                                      *
 ************************************************************************
 */
static void
rbtRotateLeft(rbt_T   *tree,            /* (in)  pointer to RBT */
              int     inode)            /* (in)  node to rotate to the left */
{
    int ix, iy;

    ROUTINE(rbtRotateLeft);

    /* --------------------------------------------------------------- */

    ix = inode;
    iy = tree->rite[ix];

    /* turn iy's left subTree into ix's rite subTree */
    tree->rite[ix] = tree->left[iy];

    if (tree->left[iy] >= 0) {
        tree->prnt[tree->left[iy]] = ix;
    }

    /* link ix's parent to iy */
    tree->prnt[iy] = tree->prnt[ix];

    if (tree->prnt[ix] == -1) {
        tree->root = iy;
    } else if (ix == tree->left[tree->prnt[ix]]) {
        tree->left[tree->prnt[ix]] = iy;
    } else {
        tree->rite[tree->prnt[ix]] = iy;
    }

    /* put ix on iy's left */
    tree->left[iy] = ix;
    tree->prnt[ix] = iy;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtRotateRite - rotate Nodes to the rite                             *
 *                                                                      *
 ************************************************************************
 */
static void
rbtRotateRite(rbt_T   *tree,            /* (in)  pointer to RBT */
              int     inode)            /* (in)  node to rotate to the rite */
{
    int ix, iy;

    ROUTINE(rbtRotateRite);

    /* --------------------------------------------------------------- */

    ix = inode;
    iy = tree->left[ix];

    /* turn iy's rite subTree into ix's left subTree */
    tree->left[ix] = tree->rite[iy];

    if (tree->rite[iy] >= 0) {
        tree->prnt[tree->rite[iy]] = ix;
    }

    /* link ix's parent to iy */
    tree->prnt[iy] = tree->prnt[ix];

    if (tree->prnt[ix] == -1) {
        tree->root = iy;
    } else if (ix == tree->rite[tree->prnt[ix]]) {
        tree->rite[tree->prnt[ix]] = iy;
    } else {
        tree->left[tree->prnt[ix]] = iy;
    }

    /* put ix on iy's rite */
    tree->rite[iy] = ix;
    tree->prnt[ix] = iy;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtSearch - search for Node in Tree                                  *
 *                                                                      *
 ************************************************************************
 */
static int
rbtSearch(rbt_T   *tree,                /* (in)  pointer to RBT */
          int     key1,                 /* (in)  first  key */
          int     key2,                 /* (in)  second key */
          int     key3,                 /* (in)  third  key */
          int     key4)                 /* (in)  fourth key */
{
    int       status = SUCCESS;         /* (out) return status */

    int ix, ians;

    ROUTINE(rbtSearch);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* start at the Root of the Tree */
    ix = tree->root;

    /* iteratively descend the Tree, moving left or rite depending on
          the relative location of the key with the keys in the Tree */
    while(ix >= 0) {
        ians = rbtCompareKeys(key1, tree->key1[ix],
                              key2, tree->key2[ix],
                              key3, tree->key3[ix],
                              key4, tree->key4[ix]);
        if        (ians < 0) {
            ix = tree->left[ix];
        } else if (ians > 0) {
            ix = tree->rite[ix];
        } else {
            break;
        }
    }

    status = ix;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   recycleBody - recycle a Body if its arguments are unchanged        *
 *                                                                      *
 ************************************************************************
 */

static int
recycleBody(modl_T *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1-nbrch) */
            int    brtype,              /* (in)  Branch type */
            varg_T args[],              /* (in)  array  of arguments */
            int    hasdots)             /* (in)  =1 if any arguments have non-zero dots */
{
    int       status = SUCCESS;         /* (out) return status or 1 if successful recycling */

    int       iarg, ival, nval, iattr, nrow, ncol, atype, nattr, len, ipmtr;
    int       oclass, mtype, nchild, *senses, ileft, irite, igroup, botype;
    int       ibody, jbody, okay, numRemaining;
    CINT      *tempIlist;
    double    *values=NULL, *dots=NULL, data[4];
    CDOUBLE   *tempRlist;
    char      *csysname=NULL, str[MAX_STRVAL_LEN], filename[80];
    char      argname[MAX_NAME_LEN], attrname[MAX_NAME_LEN];
    CCHAR     *tempClist, *aname;
    ego       emodel, eref, *echilds, ebody;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(recycleBody);

    /* --------------------------------------------------------------- */

    /* if loadEgads is set, read the file now (if it exists) */
    if (MODL->loadEgads > 0) {

        /* read the file */
        ibody = MODL->nbody + 1;
        sprintf(filename, "Body_%06d.egads", ibody);

        (void) EG_setOutLevel(MODL->context, 0);
        status = EG_loadModel(MODL->context, 0, filename, &emodel);
        (void) EG_setOutLevel(MODL->context, outLevel);
        if (status != SUCCESS) {
            status = SUCCESS;
            goto cleanup;
        }

        SPRINT1(1, "<-- loaded %s", filename);

        /* get Body from Model */
        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        if (status < SUCCESS || oclass != MODEL || nchild != 1) {
            SPRINT3(1, "WARNING:: status=%d, oclass=%d, nchild=%d",
                    status, oclass, nchild);

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          =  0;
            goto cleanup;
        }

        /* make sure .csm filenames match the file */
        status = EG_attributeRet(echilds[0], "__filename__", &atype, &nval,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && atype == ATTRSTRING) {
            if (strcmp(MODL->brch[ibrch].filename, (char*)tempClist) != 0) {
                SPRINT1(1, "WARNING:: Filename in file (%s) does not match", tempClist);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                (MODL->nwarn)++;
                MODL->loadEgads = -1;
                status          =  SUCCESS;
                goto cleanup;
            }
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __filename__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          = SUCCESS;
            goto cleanup;
        }

        /* make sure Branch types match the file */
        status = EG_attributeRet(echilds[0], "__brtype__", &atype, &nval,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && atype == ATTRINT && nval == 1) {
            if (tempIlist[0] != brtype) {
                SPRINT1(1, "WARNING:: Branch type in file (%s) does not match",
                        ocsmGetText(tempIlist[0]));

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                (MODL->nwarn)++;
                MODL->loadEgads = -1;
                status          =  SUCCESS;
                goto cleanup;
            }
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __brtype__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          = SUCCESS;
            goto cleanup;
        }

        /* make sure Branch arguments match the file */
        for (iarg = 1; iarg <= 9; iarg++) {
            snprintf(argname, MAX_NAME_LEN, "__arg%d__", iarg);
            (void) EG_setOutLevel(MODL->context, 0);
            status = EG_attributeRet(echilds[0], argname, &atype, &nval,
                                     &tempIlist, &tempRlist, &tempClist);
            (void) EG_setOutLevel(MODL->context, outLevel);
            if (status == SUCCESS && iarg > MODL->brch[ibrch].narg) {
                SPRINT2(1, "WARNING:: more arguments in file (%d) than current Branch (%d)",
                        iarg, MODL->brch[ibrch].narg);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                (MODL->nwarn)++;
                MODL->loadEgads = -1;
                status          =  SUCCESS;
                goto cleanup;
            } else if (status == SUCCESS && atype == ATTRREAL) {
                if (nval != args[iarg].nval) {
                    SPRINT3(1, "WARNING:: nval=%d does not match args[%d].nval=%d",
                            nval, iarg, args[iarg].nval);

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                    (MODL->nwarn)++;
                    MODL->loadEgads = -1;
                    status          =  SUCCESS;
                    goto cleanup;
                }
                for (ival = 0; ival < nval; ival++) {
                    if (fabs(tempRlist[ival]-args[iarg].val[ival]) > EPS06) {
                        SPRINT6(1, "WARNING:: args[%d].val[%d]=%12.6f but %s[%d]=%12.6f",
                                iarg, ival, args[iarg].val[ival], argname, ival, tempRlist[ival]);

                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        (MODL->nwarn)++;
                        MODL->loadEgads = -1;
                        status          =  SUCCESS;
                        goto cleanup;
                    }
                }
            } else if (status == SUCCESS && atype == ATTRSTRING) {
                if (strcmp(tempClist, args[iarg].str) != 0) {
                    SPRINT4(1, "WARNING:: arg[%d].str=%s but %s=%s",
                            iarg, args[iarg].str, argname, tempClist);

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                    (MODL->nwarn)++;
                    MODL->loadEgads = -1;
                    status          =  SUCCESS;
                    goto cleanup;
                }
            } else if (status != SUCCESS && MODL->brch[ibrch].narg > iarg) {
                SPRINT2(1, "WARNING:: more arguments in current Branch (%d) than file (%d)",
                        MODL->brch[ibrch].narg, iarg);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                (MODL->nwarn)++;
                MODL->loadEgads = -1;
                status          =  SUCCESS;
                goto cleanup;
            }
        }

        /* pull out other Attributes needed to create the new Body */
        status = EG_attributeRet(echilds[0], "__ileft__", &atype, &nval,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && atype == ATTRINT && nval == 1) {
            ileft  = tempIlist[0];
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __ileft__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          =  SUCCESS;
            goto cleanup;
        }

        status = EG_attributeRet(echilds[0], "__irite__", &atype, &nval,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && atype == ATTRINT && nval == 1) {
            irite  = tempIlist[0];
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __irite__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          =  SUCCESS;
            goto cleanup;
        }

        status = EG_attributeRet(echilds[0], "__igroup__", &atype, &nval,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && atype == ATTRINT && nval == 1) {
            igroup = tempIlist[0];
        } else {
            SPRINT0(1, "WARNING:: file does not have the attribute __igroup__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          = SUCCESS;
            goto cleanup;
        }

        status = EG_attributeRet(echilds[0], "__botype__", &atype, &nval,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && atype == ATTRINT && nval == 1) {
            botype = tempIlist[0];
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __botype__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          =  SUCCESS;
            goto cleanup;
        }

        /* create the new Body */
        status = newBody(MODL, ibrch, brtype, ileft, irite, args,
                         hasdots, botype, &ibody);
        CHECK_STATUS(newBody);

        MODL->body[ibody].igroup = igroup;

        status = EG_copyObject(echilds[0], NULL, &ebody);
        CHECK_STATUS(EG_copyObject);

        /* remove temporary Attributes */
        status = EG_attributeDel(ebody, "__ibrch__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__ileft__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__irite__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__igroup__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__botype__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__brtype__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__filename__");
        CHECK_STATUS(EG_attributeDel);

        (void) EG_setOutLevel(MODL->context, 0);
        (void) EG_attributeDel(ebody, "__arg1__");
        (void) EG_attributeDel(ebody, "__arg2__");
        (void) EG_attributeDel(ebody, "__arg3__");
        (void) EG_attributeDel(ebody, "__arg4__");
        (void) EG_attributeDel(ebody, "__arg5__");
        (void) EG_attributeDel(ebody, "__arg6__");
        (void) EG_attributeDel(ebody, "__arg7__");
        (void) EG_attributeDel(ebody, "__arg8__");
        (void) EG_attributeDel(ebody, "__arg9__");
        (void) EG_setOutLevel(MODL->context, outLevel);

        /* set up returns from UDPs and UDFs */
        status = EG_attributeNum(ebody, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = nattr; iattr >= 1; iattr--) {
            status = EG_attributeGet(ebody, iattr, &aname, &atype, &len,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            if (strncmp(aname, "__@@", 4) == 0) {
                strcpy(attrname, &(aname[2]));
                attrname[STRLEN(attrname)-2] = '\0';
                status = ocsmFindPmtr(MODL, attrname, OCSM_INTERNAL, len, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                if        (atype == ATTRINT) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, (double)tempIlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (atype == ATTRREAL) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1,         tempRlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (atype == ATTRSTRING) {
                    status =  ocsmSetValu(MODL, ipmtr, 1, 1, (char *)tempClist   );
                    CHECK_STATUS(ocsmSetValu);
                }
            }

            MODL->bodyLoaded = ibody;
        }

        if (botype != OCSM_SKETCH) {
            MODL->body[ibody].ebody = ebody;
        }

        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        CHECK_STATUS(finishBody);

        status = EG_deleteObject(emodel);
        CHECK_STATUS(EG_deleteObject);

        SPRINT2(1, "                          Body   %4d loaded from \"%s\"",
                ibody, filename);

        /* if a dummy Body associated with a Sketch, delete it now */
        if (botype == OCSM_SKETCH) {
            status = EG_deleteObject(ebody);
            CHECK_STATUS(EG_deleteObject);

        /* if there are more Bodys remaining because Branch created more
           than one Body (such as OCSM_UNION with toMark=1), keep reading */
        } else {
            status = EG_attributeRet(ebody, "__numRemaining__", &atype, &nval,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS && atype == ATTRINT && nval == 1) {
                numRemaining = tempIlist[0];

                if (numRemaining > 0) {
                    status = recycleBody(modl, ibrch, brtype, args, hasdots);
                    return status;
                }
            }
        }

        status = 1;
        goto cleanup;
    }

    /* we are not reading from a file, but rather from memory */

    /* if we have exhaused the recycling, return status=0 (to signify
       that an old Body was not recycled) */
    if (MODL->nbody+1 > MODL->recycle) {
        status = SUCCESS;
        goto cleanup;
    }

    /* by default use the next Body */
    ibody = MODL->nbody + 1;

    /* if a OCSM_UNION and toMark==1, find the last Body that matches ibrch */
    if (brtype == OCSM_UNION && NINT(args[1].val[0]) == 1) {
        while ((ibody+1) <= MODL->recycle) {
            if (MODL->body[ibody+1].ibrch  == ibrch) {
                SPRINT1(0, "                          ... skipping Body %4d", ibody);
                ibody++;
            } else {
                break;
            }
        }
    }

    /* make sure that the next Body's Branch can be recycled.  it
       cannot under the following circumstances: */
    okay = 1;

    /* if the ibrch or brtype is not the expected one (this can happen if
       a previously suppressed Branch has been activated), we need to rebuild */
    if (MODL->body[ibody].ibrch  != ibrch ||
        MODL->body[ibody].brtype != brtype  ) {
        okay = 0;
    }

    /* if the value of any of the arguments has changed, we need to rebuild */
    for (iarg = 1; iarg < 10; iarg++) {
        if (okay == 0) break;

        if (MODL->body[ibody].arg[iarg].nval != args[iarg].nval) {
            okay = 0;
            break;
        }

        for (ival = 0; ival < args[iarg].nval; ival++) {
            if (MODL->body[ibody].arg[iarg].val[ival] != args[iarg].val[ival]) {
                okay = 0;
                break;
            }
        }
    }

    /* if a udprim and any of the arguments of any of its associated udparg's
       arguments have changed, we need to rebuild */
    if (okay == 1) {
        if (MODL->body[ibody].brtype == OCSM_UDPRIM) {
            for (jbody = ibody-1; jbody > 0; jbody--) {
                if (MODL->body[jbody].brtype != OCSM_UDPARG) break;

                if (MODL->body[jbody].hasdots == 2) {
                    okay = 0;
                    break;
                }
            }
        }
    }

    /* if any of the Attributes/Csystems have changed, we need to rebuild */
    for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
        if (okay == 0) break;

        /* evaluate the Branch's Attribute to see what the new values are */
        status = str2vals(MODL->brch[ibrch].attr[iattr].defn, MODL,
                          &nrow, &ncol, &values, &dots, str);
        CHECK_STATUS(str2vals);

        /* get the Attributes that are on the candidate Body to recycle */
        if (STRLEN(str) > 0) {
            status = EG_attributeRet(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name,
                                     &atype, &nval, &tempIlist, &tempRlist, &tempClist);
        } else if (MODL->brch[ibrch].attr[iattr].type == ATTRREAL) {
            status = EG_attributeRet(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name,
                                     &atype, &nval, &tempIlist, &tempRlist, &tempClist);
        } else {
            nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
            MALLOC(csysname, char, nval);
            sprintf(csysname, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
            status = EG_attributeRet(MODL->body[ibody].ebody, csysname,
                                     &atype, &nval, &tempIlist, &tempRlist, &tempClist);
            FREE(csysname);
        }

        /* verify that they are the same length and values */
        if (status != SUCCESS) {
            okay = 0;
            break;
        } else if (STRLEN(str) > 0) {
            if (strcmp(str, tempClist) != 0) {
                okay = 0;
                break;
            } else {
                continue;
            }
        } else if (nval != nrow*ncol) {
            okay = 0;
            break;
        }

        for (ival = 0; ival < nval; ival++) {
            if (fabs(values[ival]-tempRlist[ival]) > EPS06) {
                okay = 0;
                break;
            }
        }
        if (okay == 0) break;

        FREE(values);
        FREE(dots  );
    }

    /* free up all Bodys starting at ibody */
    if (okay == 0) {
        for (jbody = ibody; jbody <= MODL->recycle; jbody++) {
            status = removeVels(MODL, jbody);
            CHECK_STATUS(removeVels);

//$$$            if (MODL->body[jbody].sens != 0) {
//$$$                SPRINT1(2, "resetting .sens for jbody=%d", jbody);
//$$$
//$$$                status = EG_setGeometry_dot(MODL->body[jbody].ebody, 0, 0, NULL, NULL, NULL);
//$$$                CHECK_STATUS(EG_setGeometry_dot);
//$$$
//$$$                MODL->body[jbody].sens = 0;
//$$$            }
//$$$
//$$$            /* if this is a sketch used by a RULE or BLEND, remove the sensitivity
//$$$               cache associted with the RULE or BLEND */
//$$$            kbody = MODL->body[jbody].ichld;
//$$$            while (kbody > 0) {
//$$$                if (MODL->body[kbody].brtype == OCSM_RULE ||
//$$$                    MODL->body[kbody].brtype == OCSM_BLEND  ) {
//$$$                    if (MODL->body[kbody].sens != 0) {
//$$$                        SPRINT1(2, "resetting .sens for kbody=%d", kbody);
//$$$
//$$$                        status = EG_setGeometry_dot(MODL->body[kbody].ebody, 0, 0, NULL, NULL, NULL);
//$$$                        CHECK_STATUS(EG_setGeometry_dot);
//$$$
//$$$                        MODL->body[kbody].sens = 0;
//$$$                    }
//$$$                    break;
//$$$                }
//$$$                kbody = MODL->body[kbody].ichld;
//$$$            }
//$$$
            status = freeBody(MODL, jbody);
            CHECK_STATUS(freeBody);

            if (MODL->body[jbody].etess != NULL) {
                status = EG_deleteObject(MODL->body[jbody].etess);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[jbody].etess = NULL;
            }

            if (MODL->body[jbody].ebody != NULL) {
                status = EG_deleteObject(MODL->body[jbody].ebody);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[jbody].ebody = NULL;
            }
        }

        MODL->recycle = ibody;

        /* return status=0 (to signify that an old Body was not recycled) */
        status = SUCCESS;
        goto cleanup;
    }

    /* set up returns from UDPs and UDFs */
    ebody = MODL->body[ibody].ebody;

    if (ebody != NULL) {
        status = EG_attributeNum(ebody, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = nattr; iattr >= 1; iattr--) {
            status = EG_attributeGet(ebody, iattr, &aname, &atype, &len,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            if (strncmp(aname, "__@@", 4) == 0) {
                strcpy(attrname, &(aname[2]));
                attrname[STRLEN(attrname)-2] = '\0';
                status = ocsmFindPmtr(MODL, attrname, OCSM_INTERNAL, len, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                if        (atype == ATTRINT) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, (double)tempIlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (atype == ATTRREAL) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1,         tempRlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (atype == ATTRSTRING) {
                    status =  ocsmSetValu(MODL, ipmtr, 1, 1, (char *)tempClist   );
                    CHECK_STATUS(ocsmSetValu);
                }
            }
        }
    }

    /* increment number of Bodys */
    MODL->nbody = ibody;
    SPRINT1(1, "                          Body   %4d recycled", MODL->nbody);

    /* store the velocities (since they may have changed even though
       the arguments may not have changed) */
    MODL->body[ibody].hasdots = hasdots;

    for (iarg = 1; iarg < 10; iarg++) {
        for (ival = 0; ival < args[iarg].nval; ival++) {
            MODL->body[ibody].arg[iarg].dot[ival] = args[iarg].dot[ival];
        }
    }

    /* update the Group number */
    MODL->ngroup++;

    /* reset the selection */
    MODL->seltype = -1;
    MODL->selbody = ibody;

    /* set up returns from UDPs and UDFs */
    if (ebody != NULL) {
        status = EG_attributeNum(ebody, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = nattr; iattr >= 1; iattr--) {
            status = EG_attributeGet(ebody, iattr, &aname, &atype, &len,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            if (strncmp(aname, "__@@", 4) == 0) {
                strcpy(attrname, &(aname[2]));
                attrname[STRLEN(attrname)-2] = '\0';
                status = ocsmFindPmtr(MODL, attrname, OCSM_INTERNAL, len, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                if        (atype == ATTRINT) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, (double)tempIlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (atype == ATTRREAL) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1,         tempRlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (atype == ATTRSTRING) {
                    status =  ocsmSetValu(MODL, ipmtr, 1, 1, (char *)tempClist   );
                    CHECK_STATUS(ocsmSetValu);
                }
            }
        }
    }

    status = setupAtPmtrs(MODL, 1);
    CHECK_STATUS(setupAtPmtrs);

    /* recycle other Bodys if there are any remaining */
    status = EG_attributeRet(ebody, "__numRemaining__", &atype, &nval,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS && atype == ATTRINT && nval == 1) {
        numRemaining = tempIlist[0];

        if (numRemaining > 0) {
            status = recycleBody(modl, ibrch, brtype, args, hasdots);
            return status;
        }
    }

    /* return status=1 (to signify that an old Body WAS recycled) */
    status = 1;

cleanup:
    FREE(csysname);
    FREE(values);
    FREE(dots  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   removeFaceAttributes - remove Face Attributes that start with . or _ *
 *                                                                      *
 ************************************************************************
 */

static int
removeFaceAttributes(ego    ebody)      /* (in)  pointer to Body */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nface, iface, nattr, iattr, atype, len;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *aname, *tempClist;
    ego       *efaces;

    ROUTINE(removeFaceAttributes);

    /* --------------------------------------------------------------- */

    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    for (iface = 0; iface < nface; iface++) {
        status = EG_attributeNum(efaces[iface], &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = nattr; iattr >= 1; iattr--) {
            status = EG_attributeGet(efaces[iface], iattr, &aname, &atype, &len,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            if (aname[0] == '.' || aname[0] == '_') {
                status = EG_attributeDel(efaces[iface], aname);
                CHECK_STATUS(EG_attributeDel);
            }
        }
    }

    EG_free(efaces);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   removePerurbation - remove a perturbation if it exists             *
 *                                                                      *
 ************************************************************************
 */

static int
removePerturbation(modl_T *modl)        /* (in)  pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(removePerturbation);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it and reset data */
    if (MODL->perturb != NULL) {
        status = ocsmFree(MODL->perturb);
        CHECK_STATUS(ocsmFree);

        MODL->perturb = NULL;
        MODL->dtime   = 0;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   removeVels - remove velocity information                           *
 *                                                                      *
 ************************************************************************
 */

int
removeVels(modl_T *modl,                /* (in)  pointer to MODL */
           int    ibody)                /* (in)  Body index (bias-1)  or 0 for all*/

{
    int       status = SUCCESS;         /* (out) return status */

    int       jbody, inode, iedge, iface;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(removeVels);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* remove storage for selected Bodys */
    for (jbody = 1; jbody <= MODL->nbody; jbody++) {
        if (ibody != 0 && jbody != ibody) continue;

        for (inode = 1; inode <= MODL->body[jbody].nnode; inode++) {
            FREE(MODL->body[jbody].node[inode].dxyz);
        }

        for (iedge = 1; iedge <= MODL->body[jbody].nedge; iedge++) {
            FREE(MODL->body[jbody].edge[iedge].dt  );
            FREE(MODL->body[jbody].edge[iedge].dxyz);
        }

        for (iface = 1; iface <= MODL->body[jbody].nface;iface++) {
            FREE(MODL->body[jbody].face[iface].duv );
            FREE(MODL->body[jbody].face[iface].dxyz);
        }

        if (MODL->body[jbody].sens != 0) {
            SPRINT1(2, "resetting .sens for jbody=%d", jbody);

            status = EG_setGeometry_dot(MODL->body[jbody].ebody, 0, 0,  NULL, NULL, NULL);
            CHECK_STATUS(EG_setGeometry_dot);

            MODL->body[jbody].sens = 0;
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   reorderLoops - reorder Loops to improve rules and blends           *
 *                                                                      *
 ************************************************************************
 */

static int
reorderLoops(modl_T *modl,              /* (in)  pointer to MODL */
             int    nloop,              /* (in)  number of Loops */
             ego    eloops[],           /* (both)array  of Loops */
             int    startFrom)          /* (in)  +1 to start at beg, -1 to start at end, 0 to return */

{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int      iloop, jloop, iedge, jedge, itest, ishift, modified, sense;
    int      oclassi, oclassj, oclassk, oclassg, mtypei, mtypej, mtypek, mtypeg, nedgei, nedgej, nedgek;
    int      *sensesi, *sensesj, *sensesk, nnode, *sensesnew=NULL;
    double   uvlimitsi[4], uvlimitsj[4], uvlimitsk[4], data[18], *xyzi=NULL, *xyzj=NULL;
    double   areai[3], areaj[3], dotprod, ltest, lshift;
    ego      erefi, erefj, erefk, erefg, *eedgesi, *eedgesj, *eedgesk;
    ego      *enodes, *elist, *eedgesnew=NULL, etemp;

    ROUTINE(reorderLoops);

    /* --------------------------------------------------------------- */

    if (outLevel >= 3) {
        for (iloop = 0; iloop < nloop; iloop++) {
            SPRINT1(3, "at beg of reorderLoops: eloops[%d]", iloop);
            ocsmPrintEgo(eloops[iloop]);
        }
    }

    /* extract just the Loop for interior Sketches and convert bounding
       WireBodys into Loops */
    for (iloop = 0; iloop < nloop; iloop++) {
        status = EG_getTopology(eloops[iloop], &erefi,
                                &oclassi, &mtypei, uvlimitsi, &nedgei, &eedgesi, &sensesi);
        CHECK_STATUS(EG_getTopology);

        /* if a Loop, leave alone */
        if (oclassi == LOOP) {

        /* if a Node, leave alone */
        } else if (oclassi == NODE) {

        /* if an interior Face, convert to Loop */
        } else if (oclassi == FACE) {
            if (iloop > 0 && iloop < nloop-1) {
                eloops[iloop] = eedgesi[0];
            }

        /* if a WireBody, convert to Loop */
        } else if (oclassi == BODY && mtypei == WIREBODY) {
            eloops[iloop] = eedgesi[0];

        /* not a recognized  type */
        } else {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "Sketch %d is not FACE, NODE, or WireBody", iloop);
            status = OCSM_WRONG_TYPES_ON_STACK;
            goto cleanup;
        }
    }

    /* the base Sketch (which will not be modified) is at either end */
    if (startFrom == 0) {
        goto cleanup;
    } else if (startFrom > 0) {
        iloop = 0;
    } else {
        iloop = nloop - 1;
    }

    /* process each pair of Sketches in turn */
    while (1) {
        if (startFrom > 0) {
            jloop = iloop + 1;
            if (jloop >= nloop) break;
        } else {
            jloop = iloop - 1;
            if (jloop < 0) break;
        }
        modified = 0;

        /* get info on iloop */
        status = EG_getTopology(eloops[iloop], &erefi,
                                &oclassi, &mtypei, uvlimitsi, &nedgei, &eedgesi, &sensesi);
        CHECK_STATUS(EG_getTopology);

        if (oclassi == FACE) {
            etemp  = eedgesi[0];
            status = EG_getTopology(etemp, &erefi,
                                    &oclassi, &mtypei, uvlimitsi, &nedgei, &eedgesi, &sensesi);
            CHECK_STATUS(EG_getTopology);
        }

        /* get info on jloop */
        status = EG_getTopology(eloops[jloop], &erefj,
                                &oclassj, &mtypej, uvlimitsj, &nedgej, &eedgesj, &sensesj);
        CHECK_STATUS(EG_getTopology);

        if (oclassj == FACE) {
            etemp  = eedgesj[0];
            status = EG_getTopology(etemp, &erefj,
                                    &oclassj, &mtypej, uvlimitsj, &nedgej, &eedgesj, &sensesj);
            CHECK_STATUS(EG_getTopology);
        }

        if (oclassi != LOOP   || oclassj != LOOP  ) {
            iloop = jloop;
            continue;
        }
        if (mtypei  != CLOSED || mtypej  != CLOSED) {
            iloop = jloop;
            continue;
        }

        /* make sure that Loops have same number of Edges */
        if (nedgei != nedgej) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "Loop %d has %d Edges, but Loop %d has %d Edges", iloop, nedgei, jloop, nedgej);
            SPRINT1(0, "eloops[iloop] has %d Edges", nedgei);
            ocsmPrintEgo(eloops[iloop]);
            SPRINT1(0, "eloops[jloop] has %d Edges", nedgej);
            ocsmPrintEgo(eloops[jloop]);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        } else if (nedgei < 1) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "Loop %d only has %d Edges", iloop, nedgei);
            status = OCSM_INTERNAL_ERROR;
            SPRINT1(0, "eloops[iloop] has %d Edges", nedgei);
            ocsmPrintEgo(eloops[iloop]);
            goto cleanup;
        }

        nedgej = nedgei;

        /* set up the coordinates at the Nodes and midpoints in the two Loops */
        MALLOC(xyzi, double, 6*nedgei);
        MALLOC(xyzj, double, 6*nedgej);

        for (iedge = 0; iedge < nedgei; iedge++) {
            status = EG_getTopology(eedgesi[iedge], &erefk,
                                    &oclassk, &mtypeg, uvlimitsk, &nnode, &enodes, &sensesk);
            CHECK_STATUS(EG_getTopology);

            if (sensesi[iedge] > 0) {
                status = EG_getTopology(enodes[0], &erefk,
                                        &oclassk, &mtypek, &(xyzi[6*iedge]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            } else {
                status = EG_getTopology(enodes[1], &erefk,
                                        &oclassk, &mtypek, &(xyzi[6*iedge]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            }

            if (mtypeg != DEGENERATE) {
                uvlimitsk[2] = (uvlimitsk[0] + uvlimitsk[1]) / 2;

                status = EG_evaluate(eedgesi[iedge], &uvlimitsk[2], data);
                CHECK_STATUS(EG_evaluate);

                xyzi[6*iedge+3] = data[0];
                xyzi[6*iedge+4] = data[1];
                xyzi[6*iedge+5] = data[2];
            } else {
                xyzi[6*iedge+3] = xyzi[3*iedge  ];
                xyzi[6*iedge+4] = xyzi[3*iedge+1];
                xyzi[6*iedge+5] = xyzi[3*iedge+2];
            }
        }

        for (iedge = 0; iedge < nedgej; iedge++) {
            status = EG_getTopology(eedgesj[iedge], &erefk,
                                    &oclassk, &mtypeg, uvlimitsk, &nnode, &enodes, &sensesk);
            CHECK_STATUS(EG_getTopology);

            if (sensesj[iedge] > 0) {
                status = EG_getTopology(enodes[0], &erefk,
                                        &oclassk, &mtypek, &(xyzj[6*iedge]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            } else {
                status = EG_getTopology(enodes[1], &erefk,
                                        &oclassk, &mtypek, &(xyzj[6*iedge]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            }

            if (mtypeg != DEGENERATE) {
                uvlimitsk[2] = (uvlimitsk[0] + uvlimitsk[1]) / 2;

                status = EG_evaluate(eedgesj[iedge], &uvlimitsk[2], data);
                CHECK_STATUS(EG_evaluate);

                xyzj[6*iedge+3] = data[0];
                xyzj[6*iedge+4] = data[1];
                xyzj[6*iedge+5] = data[2];
            } else {
                xyzj[6*iedge+3] = xyzj[3*iedge  ];
                xyzj[6*iedge+4] = xyzj[3*iedge+1];
                xyzj[6*iedge+5] = xyzj[3*iedge+2];
            }
        }

        /* find the area of iloop and jloop */
        areai[0] = areai[1] = areai[2] = 0;
        areaj[0] = areaj[1] = areaj[2] = 0;

        for (iedge = 1; iedge < 2*nedgei-1; iedge++) {
            areai[0] += (xyzi[1] - xyzi[6*nedgei-2]) * (xyzi[3*iedge+2] - xyzi[6*nedgei-1])
                      - (xyzi[2] - xyzi[6*nedgei-1]) * (xyzi[3*iedge+1] - xyzi[6*nedgei-2]);
            areai[1] += (xyzi[2] - xyzi[6*nedgei-1]) * (xyzi[3*iedge  ] - xyzi[6*nedgei-3])
                      - (xyzi[0] - xyzi[6*nedgei-3]) * (xyzi[3*iedge+2] - xyzi[6*nedgei-1]);
            areai[2] += (xyzi[0] - xyzi[6*nedgei-3]) * (xyzi[3*iedge+1] - xyzi[6*nedgei-2])
                      - (xyzi[1] - xyzi[6*nedgei-2]) * (xyzi[3*iedge  ] - xyzi[6*nedgei-3]);

            areaj[0] += (xyzj[1] - xyzj[6*nedgej-2]) * (xyzj[3*iedge+2] - xyzj[6*nedgej-1])
                      - (xyzj[2] - xyzj[6*nedgej-1]) * (xyzj[3*iedge+1] - xyzj[6*nedgej-2]);
            areaj[1] += (xyzj[2] - xyzj[6*nedgej-1]) * (xyzj[3*iedge  ] - xyzj[6*nedgej-3])
                      - (xyzj[0] - xyzj[6*nedgej-3]) * (xyzj[3*iedge+2] - xyzj[6*nedgej-1]);
            areaj[2] += (xyzj[0] - xyzj[6*nedgej-3]) * (xyzj[3*iedge+1] - xyzj[6*nedgej-2])
                      - (xyzj[1] - xyzj[6*nedgej-2]) * (xyzj[3*iedge  ] - xyzj[6*nedgej-3]);
        }

        /* if the dot products of the areas is negative, flip the direction of jloop */
        dotprod = areai[0] * areaj[0] + areai[1] * areaj[1] + areai[2] * areaj[2];
        if (dotprod < 0) {
            SPRINT1(1, "WARNING:: reversing Loop %d", jloop);
            (MODL->nwarn)++;
            modified++;

            etemp  = eloops[jloop];
            status = EG_flipObject(etemp, &(eloops[jloop]));
            CHECK_STATUS(EG_flipObject);

            status = EG_getTopology(eloops[jloop], &erefj,
                                    &oclassj, &mtypej, uvlimitsj, &nedgej, &eedgesj, &sensesj);
            CHECK_STATUS(EG_getTopology);

            if (oclassj == FACE) {
                etemp  = eedgesj[0];
                status = EG_getTopology(etemp, &erefj,
                                        &oclassj, &mtypej, uvlimitsj, &nedgej, &eedgesj, &sensesj);
                CHECK_STATUS(EG_getTopology);
            }

            for (iedge = 0; iedge < nedgej; iedge++) {
                status = EG_getTopology(eedgesj[iedge], &erefk,
                                        &oclassk, &mtypek, uvlimitsk, &nnode, &enodes, &sensesk);
                CHECK_STATUS(EG_getTopology);

                if (sensesj[iedge] > 0) {
                    status = EG_getTopology(enodes[0], &erefk,
                                            &oclassk, &mtypek, &(xyzj[6*iedge]), &nnode, &elist, &sensesk);
                    CHECK_STATUS(EG_getTopology);
                } else {
                    status = EG_getTopology(enodes[1], &erefk,
                                            &oclassk, &mtypek, &(xyzj[6*iedge]), &nnode, &elist, &sensesk);
                    CHECK_STATUS(EG_getTopology);
                }
            }
        }

        /* find the shift of jloop that minimizes the distance between the Nodes of iloop
           and the Nodes of jloop */
        ishift = 0;
        lshift = HUGEQ;

        /* compute the sum of the distances for each candidate shift */
        for (itest = 0; itest < 2*nedgei; itest++) {

            ltest = 0;
            for (iedge = 0; iedge < 2*nedgei; iedge++) {
                jedge = (iedge + itest) % (2*nedgei);

                ltest += sqrt(SQR(xyzi[3*iedge  ]-xyzj[3*jedge  ])
                             +SQR(xyzi[3*iedge+1]-xyzj[3*jedge+1])
                             +SQR(xyzi[3*iedge+2]-xyzj[3*jedge+2]));
            }
            if (ltest < lshift) {
                ishift = itest / 2;
                lshift = ltest;
            }
        }

        /* create the new rotated Loop */
        if (ishift > 0) {
            SPRINT2(1, "WARNING:: shifting  Loop %d with ishift=%d", jloop, ishift);
            (MODL->nwarn)++;
            modified++;

            MALLOC(eedgesnew, ego, 2*nedgej);
            MALLOC(sensesnew, int, 2*nedgej);

            /* shift the Loop by ishift */
            for (iedge = 0; iedge < nedgej; iedge++) {
                jedge = (iedge + ishift) % nedgej;
                eedgesnew[iedge] = eedgesj[jedge];
                sensesnew[iedge] = sensesj[jedge];
            }

            status = EG_getTopology(eloops[jloop], &erefk,
                                    &oclassk, &mtypek, uvlimitsk, &nedgek, &eedgesk, &sensesk);
            CHECK_STATUS(EG_getTopology);

            if (oclassk == FACE) {
                status = EG_getGeometry(erefk, &oclassg, &mtypeg, &erefg, NULL, NULL);
                CHECK_STATUS(EG_getGeometry);

                if (mtypeg != PLANE) {
                    for (iedge = 0; iedge < nedgej; iedge++) {
                        jedge = (iedge + ishift) % nedgej;
                        eedgesnew[iedge+nedgej] = eedgesj[jedge+nedgej];
                        sensesnew[iedge+nedgej] = sensesj[jedge+nedgej];
                    }
                }
            }

            /* make new Loop */
            status = EG_makeTopology(MODL->context, erefk, LOOP, CLOSED,
                                     NULL, nedgej, eedgesnew, sensesnew, &etemp);
            CHECK_STATUS(EG_makeTopology);

            FREE(sensesnew);
            FREE(eedgesnew);

            /* either store the new Loop or make a new Face (if the original jloop
               was a Face) */
            if (oclassk != FACE) {
                eloops[jloop] = etemp;
            } else {
                sense = SFORWARD;
                status = EG_makeTopology(MODL->context, erefk, FACE, mtypek,
                                         NULL, 1, &etemp, &sense, &(eloops[jloop]));
                CHECK_STATUS(EG_makeTopology);
            }
        }

        FREE(xyzj);
        FREE(xyzi);

        /* next iloop,jloop pair */
        iloop = jloop;
    }

cleanup:
    FREE(xyzj);
    FREE(xyzi);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   selectBody - select a Body from a Model                            *
 *                                                                      *
 ************************************************************************
 */

static int
selectBody(ego    emodel,               /* (in)  pointer to Model */
           char*  order,                /* (in)  order type */
           int    index)                /* (in)  index into list (1->nchild) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       i, j, imin, oclass, mtype, nchild, *senses;
    double    box[14], datamin, datamax, data2[4], *data=NULL;
    ego       eref, *ebodys;

    ROUTINE(selectBody);

    /* --------------------------------------------------------------- */

    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                            data2, &nchild, &ebodys, &senses);
    CHECK_STATUS(EG_getTopology);

    /* if nchild is just one, return the answer immediately */
    if (nchild == 1) {
        status = SUCCESS;
        goto cleanup;
    } else if (nchild < 1) {
        SPRINT2(1, "WARNING:: emodel(=%llx) has %d children", (long long)emodel, nchild);
        status = OCSM_INTERNAL_ERROR;
        goto cleanup;
    }

    /* make an array that has data based upon order.  note that we
       will always want to return the (index-1)'th smallest entry so that
       quantities that are to maximized are stored as negative value */

    MALLOC(data, double, nchild);

    if        (strcmp(order, "none") == 0) {
        for (i = 0; i < nchild; i++) {
            data[i] = i;
        }
    } else if (strcmp(order, "xmin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = +box[0];
        }
    } else if (strcmp(order, "xmax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = -box[3];
        }
    } else if (strcmp(order, "ymin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = +box[1];
        }
    } else if (strcmp(order, "ymax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = -box[4];
        }
    } else if (strcmp(order, "zmin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = +box[2];
        }
    } else if (strcmp(order, "zmax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = -box[5];
        }
    } else if (strcmp(order, "amin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getMassProperties(ebodys[i], box);
            CHECK_STATUS(EG_getMassProperties);

            data[i] = +box[1];
        }
    } else if (strcmp(order, "amax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getMassProperties(ebodys[i], box);
            CHECK_STATUS(EG_getMassProperties);

            data[i] = -box[1];
        }
    } else if (strcmp(order, "vmin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getMassProperties(ebodys[i], box);
            CHECK_STATUS(EG_getMassProperties);

            data[i] = +box[0];
        }
    } else if (strcmp(order, "vmax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getMassProperties(ebodys[i], box);
            CHECK_STATUS(EG_getMassProperties);

            data[i] = -box[0];
        }
    } else {
        status = OCSM_ILLEGAL_TYPE;
        goto cleanup;
    }

    /* find the largest entry in data */
    datamax = data[0];
    for (i = 1; i < nchild; i++) {
        if (data[i] > datamax) datamax = data[i];
    }

    /* move the smallest index-1 entries to the end of the list */
    for (j = 0; j < index-1; j++) {
        datamin = data[0];
        imin    = 0;
        for (i = 1; i < nchild; i++) {
            if (data[i] < datamin) {
                datamin = data[i];
                imin    = i;
            }
        }

        data[imin] = (++datamax);
    }

    /* return the smallest entry in data */
    datamin = data[0];
    imin    = 0;
    for (i = 1; i < nchild; i++) {
        if (data[i] < datamin) {
            datamin = data[i];
            imin    = i;
        }
    }

    status = imin;

cleanup:
    FREE(data);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   setEgoAttribute - set Attribute(s) from Branch Attribute           *
 *                                                                      *
 ************************************************************************
 */

static int
setEgoAttribute(modl_T *modl,           /* (in)  pointer to MODL */
                int    ibrch,           /* (in)  Branch index (bias-1) or 0 */
                ego    eobject)         /* (in)  ego to get Attribute */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iattr, nval, nrow, ncol, ival;
    double    value, dot, *values=NULL, *dots=NULL;
    char      aname[MAX_STRVAL_LEN], str[MAX_STRVAL_LEN];
    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(setEgoAttribute);

    /* --------------------------------------------------------------- */

    /* global Attributes */
    if (ibrch == 0) {
        for (iattr = 0; iattr < MODL->nattr; iattr++) {
            if (MODL->attr[iattr].name[0] != '!') {
                strncpy(aname, MODL->attr[iattr].name, MAX_STRVAL_LEN);
            } else {
                status = str2val(&(MODL->attr[iattr].name[1]), MODL, &value, &dot, aname);
                CHECK_STATUS(str2val);

                if (STRLEN(aname) == 0) {
                    signalError(NULL, OCSM_ILLEGAL_ARGUMENT,
                                "Attribute name (%s) must evaluate to a string",
                                MODL->attr[iattr].name);
                    status = OCSM_ILLEGAL_ARGUMENT;
                    goto cleanup;
                }
            }

            SPRINT2x(2, "       setting global attribute %3d: %s -> ",
                     iattr, aname);

            /* global Attribute value is a string */
            if (MODL->attr[iattr].defn[0] == '$') {
                SPRINT1(2, "%s", &(MODL->attr[iattr].defn[1]));
                status = EG_attributeAdd(eobject, aname, ATTRSTRING,
                                         1, NULL, NULL, &(MODL->attr[iattr].defn[1]));
                CHECK_STATUS(EG_attributeAdd);

            /* global Attribute value comes from a Parameter or list of expressions */
            } else {
                status = str2vals(MODL->attr[iattr].defn, MODL, &nrow, &ncol, &values, &dots, str);
                CHECK_STATUS(str2vals);

                if (STRLEN(str) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else {
                    nval = nrow * ncol;

                    if (nval > 0) {
                        for (ival = 0; ival < nval; ival++) {
                            SPRINT1x(2, "%10.4f ", values[ival]);
                        }
                        SPRINT0(2, " ");
                        status = EG_attributeAdd(eobject, aname, ATTRREAL,
                                                 nval, NULL, values, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        if (strcmp(aname, ".tParams") == 0) {
                            status = EG_attributeAdd(eobject, "_tParams", ATTRREAL,
                                                     nval, NULL, values, NULL);
                            CHECK_STATUS(EG_attributeAdd);
                        }

                        FREE(values);
                        FREE(dots  );
                    }
                }
            }
        }

    /* Branch Attributes and Csystems */
    } else {
        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            if (MODL->brch[ibrch].attr[iattr].name[0] != '!') {
                strncpy(aname, MODL->brch[ibrch].attr[iattr].name, MAX_STRVAL_LEN);
            } else {
                status = str2val(&(MODL->brch[ibrch].attr[iattr].name[1]), MODL, &value, &dot, aname);
                CHECK_STATUS(str2val);

                if (STRLEN(aname) == 0) {
                    signalError(NULL, OCSM_ILLEGAL_ARGUMENT,
                                "Attribute name (%s) must evaluate to a string",
                                MODL->brch[ibrch].attr[iattr].name);
                    status = OCSM_ILLEGAL_ARGUMENT;
                    goto cleanup;
                }
            }

            if        (MODL->brch[ibrch].attr[iattr].type == ATTRREAL) {
                SPRINT2x(2, "       setting branch attribute %3d: %s -> ",
                         iattr, aname);
            } else if (MODL->brch[ibrch].attr[iattr].type == ATTRCSYS) {
                SPRINT2x(2, "       setting branch csystem   %3d: %s -> ",
                         iattr, aname);
            }

            /* Branch Attribute value is a string */
            if (MODL->brch[ibrch].attr[iattr].defn[0] == '$'     &&
                MODL->brch[ibrch].attr[iattr].type    == ATTRREAL  ) {

                status = str2val(MODL->brch[ibrch].attr[iattr].defn, MODL, &value, &dot, str);
                CHECK_STATUS(str2val);

                SPRINT1(2, "%s", str);
                status = EG_attributeAdd(eobject, aname, ATTRSTRING,
                                         1, NULL, NULL, str);
                CHECK_STATUS(EG_attributeAdd);

            /* Branch Attribute value comes from a Parameter or list of expressions */
            } else {
                status = str2vals(MODL->brch[ibrch].attr[iattr].defn, MODL, &nrow, &ncol, &values, &dots, str);
                CHECK_STATUS(str2vals);

                if (STRLEN(str) > 0) {
                    SPRINT1(2, "%s", str);
                    status = EG_attributeAdd(eobject, aname, ATTRSTRING,
                                             1, NULL, NULL, str);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    nval = nrow * ncol;

                    if (nval > 0 && values != NULL) {
                        for (ival = 0; ival < nval; ival++) {
#ifndef __clang_analyzer__
                            SPRINT1x(2, "%10.4f ", values[ival]);
#endif
                        }
                        SPRINT0(2, " ");
                        if (MODL->brch[ibrch].attr[iattr].type == ATTRREAL) {
                            status = EG_attributeAdd(eobject, aname, ATTRREAL,
                                                     nval, NULL, values, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            if (strcmp(aname, ".tParams") == 0) {
                                status = EG_attributeAdd(eobject, "_tParams", ATTRREAL,
                                                         nval, NULL, values, NULL);
                                CHECK_STATUS(EG_attributeAdd);
                            }
                        }
                    }
                }

                FREE(values);
                FREE(dots  );
            }
        }
    }

cleanup:
    FREE(values);
    FREE(dots  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   setFaceAttribute - set Attribute(s) to Face                        *
 *                                                                      *
 ************************************************************************
 */

static int
setFaceAttribute(modl_T *modl,          /* (in)  pointer to MODL */
                 int    ibody,          /* (in)  Body index (1-nbody) */
                 int    iface,          /* (in)  Face index (1-nface) */
                 int    jbody,          /* (in)  Branch index (=0 for automatic) */
                 int    jford,          /* (in)  Face order */
                 int    npatn,          /* (in)  number of active patterns */
                 patn_T *patn)          /* (in)  array  of active patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       *iattrib=NULL, nattrib, i, ibrch;
    body_T    *body=NULL;

    int       nface;
    ego       *efaces;

    ROUTINE(setFaceAttribute);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody == 0) {
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* get Body info */
    body = &(MODL->body[ibody]);
    ibrch =  MODL->body[ibody].ibrch;

    /* allocate storage for new Attributes */
    MALLOC(iattrib, int, 2+2*npatn);

    nattrib = 0;

    if (jbody == 0) {
        iattrib[nattrib++] = ibody;
        iattrib[nattrib++] = jford;
    } else {
        iattrib[nattrib++] = jbody;
        iattrib[nattrib++] = jford;
    }

    for (i = npatn-1; i >= 0; i--) {
        if (patn[i].itype == OCSM_PATBEG ||
            patn[i].itype == OCSM_RECALL   ) {
            iattrib[nattrib++] = patn[i].ibeg;
            iattrib[nattrib++] = patn[i].icopy;
        }
    }

    /* save the Body Attributes */
    status = EG_getBodyTopos(body->ebody, NULL, FACE, &nface, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (nface > 0) {
        if (MODL->brch[ibrch].type != OCSM_RESTORE) {
            status = EG_attributeAdd(efaces[iface-1], "_body", ATTRINT,
                                     2, iattrib, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);
        }

        iattrib[0] = ibrch;
        status = EG_attributeAdd(efaces[iface-1], "_brch", ATTRINT,
                                 nattrib, iattrib, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);

        status = setEgoAttribute(MODL, ibrch, efaces[iface-1]);
        CHECK_STATUS(setEgoAttribute);

        EG_free(efaces);
    }

cleanup:
    FREE(iattrib);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   setupAtPmtrs - sets up Parameters starting with @                  *
 *                                                                      *
 ************************************************************************
 */

static int
setupAtPmtrs(modl_T *modl,              /* (in)  pointer to MODL */
             int    havesel)            /* (in)  =+1 if seltype is already set */
                                        /*       =-1 if a mark was selected */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       AT_seltype=0, AT_selbody=0, AT_sellist=0;
    int       AT_nbody=0,   AT_nface=0,   AT_nedge=0,  AT_nnode=0;
    int       AT_ibody=0,   AT_iface=0,   AT_iedge=0,  AT_inode=0;
    int       AT_igroup=0,  AT_itype=0,   AT_nbors=0,  AT_ibody1=0, AT_ibody2=0;
    int       AT_xmin=0,    AT_ymin=0,    AT_zmin=0,   AT_xmax=0,   AT_ymax=0,   AT_zmax=0;
    int       AT_length=0,  AT_area=0,    AT_volume=0;
    int       AT_xcg=0,     AT_ycg=0,     AT_zcg=0;
    int       AT_Ixx=0,     AT_Ixy=0,     AT_Ixz=0;
    int       AT_Iyx=0,     AT_Iyy=0,     AT_Iyz=0;
    int       AT_Izx=0,     AT_Izy=0,     AT_Izz=0;
    int       AT_signal=0,  AT_nwarn=0;
    int       AT_edata=0,   AT_stack=0;
    double    box[6], bbox[6], massprop[14];

    int       ipmtr, itype, nface, nedge, nnode, ntemp, nbors, nlist;
    int       oclass, mtype, nchild, *sense, ilist, periodic;
    CINT      *tempIlist;
    double    data[18], trange[4];
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;
    ego       eref, *echild, *enodes;
#ifdef PRINT_PROGRESS
    time_t    cpu_beg, cpu_end;
#endif

    ROUTINE(setupAtPmtrs);

    /* --------------------------------------------------------------- */

    PPRINT_INIT(enter setupAtPmtrs);

    /* if there are no Bodys, then return without setting up any @-Parameters */
    if (MODL->nbody <= 0) {
        goto cleanup;
    }

    /* initialize selection info if we do not have it already */
    if (havesel == 0) {
        MODL->seltype = -1;
        MODL->selbody = MODL->nbody;
        MODL->selsize = 0;

        FREE(MODL->sellist);
    }

    /* if current Body is NULL, return without setting up any @-Parameters */
    if (havesel == -1) {
        /* handled below */
    } else if (MODL->selbody > 0) {
        if (MODL->body[MODL->selbody].botype == OCSM_NULL_BODY ||
            MODL->body[MODL->selbody].botype == OCSM_SKETCH      ) {
            goto cleanup;
        }
    } else {
        if (MODL->body[MODL->nbody].botype == OCSM_NULL_BODY ||
            MODL->body[MODL->nbody].botype == OCSM_SKETCH      ) {
            goto cleanup;
        }
    }

    /* get the Parameter indices for each of the variables (at this level) */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  == OCSM_INTERNAL           &&
            MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
            if (strcmp(MODL->pmtr[ipmtr].name, "@seltype") == 0) AT_seltype = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@selbody") == 0) AT_selbody = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@sellist") == 0) AT_sellist = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nbody"  ) == 0) AT_nbody   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nface"  ) == 0) AT_nface   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nedge"  ) == 0) AT_nedge   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nnode"  ) == 0) AT_nnode   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ibody"  ) == 0) AT_ibody   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@iface"  ) == 0) AT_iface   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@iedge"  ) == 0) AT_iedge   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@inode"  ) == 0) AT_inode   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@igroup" ) == 0) AT_igroup  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@itype"  ) == 0) AT_itype   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nbors"  ) == 0) AT_nbors   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ibody1" ) == 0) AT_ibody1  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ibody2" ) == 0) AT_ibody2  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@xmin"   ) == 0) AT_xmin    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ymin"   ) == 0) AT_ymin    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zmin"   ) == 0) AT_zmin    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@xmax"   ) == 0) AT_xmax    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ymax"   ) == 0) AT_ymax    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zmax"   ) == 0) AT_zmax    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@length" ) == 0) AT_length  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@area"   ) == 0) AT_area    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@volume" ) == 0) AT_volume  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@xcg"    ) == 0) AT_xcg     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ycg"    ) == 0) AT_ycg     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zcg"    ) == 0) AT_zcg     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixx"    ) == 0) AT_Ixx     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixy"    ) == 0) AT_Ixy     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixz"    ) == 0) AT_Ixz     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyx"    ) == 0) AT_Iyx     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyy"    ) == 0) AT_Iyy     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyz"    ) == 0) AT_Iyz     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izx"    ) == 0) AT_Izx     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izy"    ) == 0) AT_Izy     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izz"    ) == 0) AT_Izz     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@signal" ) == 0) AT_signal  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nwarn"  ) == 0) AT_nwarn   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@edata"  ) == 0) AT_edata   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@stack"  ) == 0) AT_stack   = ipmtr;
        }
    }

    /* make any Parameter that does not exist */
    if (AT_seltype == 0) {
        status = ocsmNewPmtr(MODL, "@seltype", OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_seltype = MODL->npmtr;
    }

    if (AT_selbody == 0) {
        status = ocsmNewPmtr(MODL, "@selbody", OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_selbody = MODL->npmtr;
    }

    if (AT_sellist == 0) {
        status = ocsmNewPmtr(MODL, "@sellist", OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_sellist = MODL->npmtr;
    }

    if (AT_nbody == 0) {
        status = ocsmNewPmtr(MODL, "@nbody",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nbody = MODL->npmtr;
    }

    if (AT_nface == 0) {
        status = ocsmNewPmtr(MODL, "@nface",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nface = MODL->npmtr;
    }

    if (AT_nedge == 0) {
        status = ocsmNewPmtr(MODL, "@nedge",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nedge = MODL->npmtr;
    }

    if (AT_nnode == 0) {
        status = ocsmNewPmtr(MODL, "@nnode",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nnode = MODL->npmtr;
    }

    if (AT_ibody == 0) {
        status = ocsmNewPmtr(MODL, "@ibody",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ibody = MODL->npmtr;
    }

    if (AT_iface == 0) {
        status = ocsmNewPmtr(MODL, "@iface",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_iface = MODL->npmtr;
    }

    if (AT_iedge == 0) {
        status = ocsmNewPmtr(MODL, "@iedge",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_iedge = MODL->npmtr;
    }

    if (AT_inode == 0) {
        status = ocsmNewPmtr(MODL, "@inode",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_inode = MODL->npmtr;
    }

    if (AT_igroup == 0) {
        status = ocsmNewPmtr(MODL, "@igroup",  OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_igroup = MODL->npmtr;
    }

    if (AT_itype == 0) {
        status = ocsmNewPmtr(MODL, "@itype",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_itype = MODL->npmtr;
    }

    if (AT_nbors == 0) {
        status = ocsmNewPmtr(MODL, "@nbors",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nbors = MODL->npmtr;
    }

    if (AT_ibody1 == 0) {
        status = ocsmNewPmtr(MODL, "@ibody1",  OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ibody1 = MODL->npmtr;
    }

    if (AT_ibody2 == 0) {
        status = ocsmNewPmtr(MODL, "@ibody2",  OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ibody2 = MODL->npmtr;
    }

    if (AT_xmin == 0) {
        status = ocsmNewPmtr(MODL, "@xmin",    OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_xmin = MODL->npmtr;
    }

    if (AT_ymin == 0) {
        status = ocsmNewPmtr(MODL, "@ymin",    OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ymin = MODL->npmtr;
    }

    if (AT_zmin == 0) {
        status = ocsmNewPmtr(MODL, "@zmin",    OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_zmin = MODL->npmtr;
    }

    if (AT_xmax == 0) {
        status = ocsmNewPmtr(MODL, "@xmax",    OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_xmax = MODL->npmtr;
    }

    if (AT_ymax == 0) {
        status = ocsmNewPmtr(MODL, "@ymax",    OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ymax = MODL->npmtr;
    }

    if (AT_zmax == 0) {
        status = ocsmNewPmtr(MODL, "@zmax",    OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_zmax = MODL->npmtr;
    }

    if (AT_length == 0) {
        status = ocsmNewPmtr(MODL, "@length",  OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_length = MODL->npmtr;
    }

    if (AT_area == 0) {
        status = ocsmNewPmtr(MODL, "@area",    OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_area = MODL->npmtr;
    }

    if (AT_volume == 0) {
        status = ocsmNewPmtr(MODL, "@volume",  OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_volume = MODL->npmtr;
    }

    if (AT_xcg == 0) {
        status = ocsmNewPmtr(MODL, "@xcg",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_xcg = MODL->npmtr;
    }

    if (AT_ycg == 0) {
        status = ocsmNewPmtr(MODL, "@ycg",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ycg = MODL->npmtr;
    }

    if (AT_zcg == 0) {
        status = ocsmNewPmtr(MODL, "@zcg",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_zcg = MODL->npmtr;
    }

    if (AT_Ixx == 0) {
        status = ocsmNewPmtr(MODL, "@Ixx",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Ixx = MODL->npmtr;
    }

    if (AT_Ixy == 0) {
        status = ocsmNewPmtr(MODL, "@Ixy",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Ixy = MODL->npmtr;
    }

    if (AT_Ixz == 0) {
        status = ocsmNewPmtr(MODL, "@Ixz",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Ixz = MODL->npmtr;
    }

    if (AT_Iyx == 0) {
        status = ocsmNewPmtr(MODL, "@Iyx",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Iyx = MODL->npmtr;
    }

    if (AT_Iyy == 0) {
        status = ocsmNewPmtr(MODL, "@Iyy",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Iyy = MODL->npmtr;
    }

    if (AT_Iyz == 0) {
        status = ocsmNewPmtr(MODL, "@Iyz",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Iyz = MODL->npmtr;
    }

    if (AT_Izx == 0) {
        status = ocsmNewPmtr(MODL, "@Izx",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Izx = MODL->npmtr;
    }

    if (AT_Izy == 0) {
        status = ocsmNewPmtr(MODL, "@Izy",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Izy = MODL->npmtr;
    }

    if (AT_Izz == 0) {
        status = ocsmNewPmtr(MODL, "@Izz",     OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_Izz = MODL->npmtr;
    }

    if (AT_signal == 0) {
        status = ocsmNewPmtr(MODL, "@signal",  OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_signal = MODL->npmtr;
    }

    if (AT_nwarn == 0) {
        status = ocsmNewPmtr(MODL, "@nwarn",   OCSM_INTERNAL, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nwarn = MODL->npmtr;
    }

    if (AT_edata == 0) {
        status = ocsmNewPmtr(MODL, "@edata",   OCSM_INTERNAL, 1, 20);
        CHECK_STATUS(ocsmNewPmtr);
        AT_edata = MODL->npmtr;
    }

    if (AT_stack == 0) {
        status = ocsmNewPmtr(MODL, "@stack",   OCSM_INTERNAL, 1, MAX_STACK_SIZE);
        CHECK_STATUS(ocsmNewPmtr);
        AT_stack = MODL->npmtr;
    }

    if (AT_stack == 0) {
        status = -999;
        goto cleanup;
    }

    PPRINT0(done setting up pmtrs);

    /* initialize @edata */
    MODL->pmtr[AT_edata].ncol = 1;
    status = ocsmSetValuD(MODL, AT_edata, 1, 1, -HUGEQ);
    CHECK_STATUS(ocsmSetValuD);

    /* store the signal and number of warnings */
    status = ocsmSetValuD(MODL, AT_signal, 1, 1, (double)(MODL->sigCode));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_nwarn,  1, 1, (double)(MODL->nwarn));
    CHECK_STATUS(ocsmSetValuD);

    /* special processing if processing a Mark */
    if (havesel == -1) {
        MODL->seltype = -1;
        MODL->selbody =  0;
        FREE(MODL->sellist);

        status = ocsmSetValuD(MODL, AT_seltype, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_selbody, 1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        goto cleanup;
    }

    /* if no Body is selected, select the last Body */
    if (MODL->selbody < 0) {
        MODL->seltype = -1;
        MODL->selbody = MODL->nbody;
        SPRINT1(1, "WARNING:: selecting Body %d by default", MODL->selbody);
        (MODL->nwarn)++;
    }

    /* special processing if selected Body is a NullBody */
    if (MODL->body[MODL->selbody].botype == OCSM_NULL_BODY) {
        status = ocsmSetValuD(MODL, AT_seltype, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_selbody, 1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        MODL->pmtr[AT_sellist].nrow = 1;
        MODL->pmtr[AT_sellist].ncol = 1;

        RALLOC(MODL->pmtr[AT_sellist].value, double, 1);
        RALLOC(MODL->pmtr[AT_sellist].dot,   double, 1);

        status = ocsmSetValuD(MODL, AT_sellist, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nbody,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody,   1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nface,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_iface,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nedge,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_iedge,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nnode,   1, 1,  1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_inode,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_igroup,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_itype,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nbors,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody1,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody2,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xmin,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xmax,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ymin,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ymax,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zmin,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zmax,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_length,  1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_area,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_volume,  1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xcg,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ycg,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zcg,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        goto cleanup;
    }

    /* special processing if selected Body is a NodeBody */
    if (MODL->body[MODL->selbody].botype == OCSM_NODE_BODY) {
        status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_getTopology(enodes[0], &eref, &oclass, &mtype,
                                data, &nchild, &echild, &sense);
        CHECK_STATUS(EG_getTopology);

        EG_free(enodes);

        status = ocsmSetValuD(MODL, AT_seltype, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_selbody, 1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        MODL->pmtr[AT_sellist].nrow = 1;
        MODL->pmtr[AT_sellist].ncol = 1;
        RALLOC(MODL->pmtr[AT_sellist].value, double, 1);
        RALLOC(MODL->pmtr[AT_sellist].dot,   double, 1);

        status = ocsmSetValuD(MODL, AT_sellist, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nbody,   1, 1, (double)(MODL->nbody));
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody,   1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nface,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_iface,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nedge,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_iedge,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nnode,   1, 1,  1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_inode,   1, 1,  1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_igroup,  1, 1, (double)(MODL->body[MODL->selbody].igroup));
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_itype,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nbors,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody1,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody2,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xmin,    1, 1,  data[0]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xmax,    1, 1,  data[0]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ymin,    1, 1,  data[1]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ymax,    1, 1,  data[1]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zmin,    1, 1,  data[2]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zmax,    1, 1,  data[2]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_length,  1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_area,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_volume,  1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xcg,     1, 1,  data[0]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ycg,     1, 1,  data[1]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zcg,     1, 1,  data[2]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        goto cleanup;
    }

    /* set @seltype, @selbody, and @sellist */
    status = ocsmSetValuD(MODL, AT_seltype, 1, 1, (double)(MODL->seltype));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_selbody, 1, 1, (double)(MODL->selbody));
    CHECK_STATUS(ocsmSetValuD);

    /* seltype is Node, Edge, or Face (selsize entries) */
    if (MODL->selsize >= 1) {
        MODL->pmtr[AT_sellist].nrow = 1;
        MODL->pmtr[AT_sellist].ncol = MODL->selsize;
        RALLOC(MODL->pmtr[AT_sellist].value, double, MODL->selsize);
        RALLOC(MODL->pmtr[AT_sellist].dot,   double, MODL->selsize);

        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            status = ocsmSetValuD(MODL, AT_sellist, 1, ilist+1, (double)(MODL->sellist[ilist]));
            CHECK_STATUS(ocsmSetValuD);
        }
    /* seltype is Body (1 entry) */
    } else {
        MODL->pmtr[AT_sellist].nrow = 1;
        MODL->pmtr[AT_sellist].ncol = 1;
        RALLOC(MODL->pmtr[AT_sellist].value, double, 1);
        RALLOC(MODL->pmtr[AT_sellist].dot,   double, 1);

        status = ocsmSetValuD(MODL, AT_sellist, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);
    }

    /* set @nbody and @ibody */
    status = ocsmSetValuD(MODL, AT_nbody, 1, 1, (double)(MODL->nbody));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_ibody, 1, 1, (double)(MODL->selbody));
    CHECK_STATUS(ocsmSetValuD);

    /* set @nface, @nedge, and @nnode */
    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, FACE, &nface, NULL);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, EDGE, &nedge, NULL);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, NODE, &nnode, NULL);
    CHECK_STATUS(EG_getBodyTopos);

    status = ocsmSetValuD(MODL, AT_nface, 1, 1, (double)(nface));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_nedge, 1, 1, (double)(nedge));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_nnode, 1, 1, (double)(nnode));
    CHECK_STATUS(ocsmSetValuD);

    /* set @iface, @iedge, and @inode */
    if (MODL->seltype == 2 && MODL->selsize == 1) {
        status = ocsmSetValuD(MODL, AT_iface, 1, 1, (double)(MODL->sellist[0]));
    } else if (MODL->seltype == 2) {
        status = ocsmSetValuD(MODL, AT_iface, 1, 1, -2.0);
    } else {
        status = ocsmSetValuD(MODL, AT_iface, 1, 1, -1.0);
    }
    CHECK_STATUS(ocsmSetValuD);

    if (MODL->seltype == 1 && MODL->selsize == 1) {
        status = ocsmSetValuD(MODL, AT_iedge, 1, 1, (double)(MODL->sellist[0]));
    } else if (MODL->seltype == 1) {
        status = ocsmSetValuD(MODL, AT_iedge, 1, 1, -2.0);
    } else {
        status = ocsmSetValuD(MODL, AT_iedge, 1, 1, -1.0);
    }
    CHECK_STATUS(ocsmSetValuD);

    if (MODL->seltype == 0 && MODL->selsize == 1) {
        status = ocsmSetValuD(MODL, AT_inode, 1, 1, (double)(MODL->sellist[0]));
    } else if (MODL->seltype == 0) {
        status = ocsmSetValuD(MODL, AT_inode, 1, 1, -2.0);
    } else {
        status = ocsmSetValuD(MODL, AT_inode, 1, 1, -1.0);
    }
    CHECK_STATUS(ocsmSetValuD);

    /* set @igroup */
    status = ocsmSetValuD(MODL, AT_igroup, 1, 1, (double)(MODL->body[MODL->selbody].igroup));
    CHECK_STATUS(ocsmSetValuD);

    /* set @itype */
    if        (MODL->body[MODL->selbody].botype == OCSM_WIRE_BODY) {
        status = ocsmSetValuD(MODL, AT_itype, 1, 1, 1.0);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->body[MODL->selbody].botype == OCSM_SHEET_BODY) {
        status = ocsmSetValuD(MODL, AT_itype, 1, 1, 2.0);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->body[MODL->selbody].botype == OCSM_SOLID_BODY) {
        status = ocsmSetValuD(MODL, AT_itype, 1, 1, 3.0);
        CHECK_STATUS(ocsmSetValuD);
    }

    /* set @nbors */
    if        (MODL->seltype == 0) {
        nbors = 0;
        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody,
                                     MODL->body[MODL->selbody].node[MODL->sellist[ilist]].enode,
                                     EDGE, &ntemp, NULL);
            CHECK_STATUS(EG_getBodyTopos);
            nbors += ntemp;
        }
        status = ocsmSetValuD(MODL, AT_nbors, 1, 1, nbors);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->seltype == 1) {
        nbors  = 0;
        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody,
                                     MODL->body[MODL->selbody].edge[MODL->sellist[ilist]].eedge,
                                     FACE, &ntemp, NULL);
            CHECK_STATUS(EG_getBodyTopos);
            nbors += ntemp;
        }
        status = ocsmSetValuD(MODL, AT_nbors, 1, 1, nbors);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->seltype == 2) {
        nbors  = 0;
        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody,
                                     MODL->body[MODL->selbody].face[MODL->sellist[ilist]].eface,
                                     EDGE, &ntemp, NULL);
            CHECK_STATUS(EG_getBodyTopos);
            nbors += ntemp;
        }
        status = ocsmSetValuD(MODL, AT_nbors, 1, 1, nbors);
        CHECK_STATUS(ocsmSetValuD);
    } else {
        status = ocsmSetValuD(MODL, AT_nbors, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);
    }

    /* set @ibody1 and @ibody2 */
    if (MODL->selsize == 1 && (MODL->seltype == 1 || MODL->seltype == 2)) {
        if (MODL->seltype == 1) {
            status = EG_attributeRet(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                                     "_body", &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);
        } else {
            status = EG_attributeRet(MODL->body[MODL->selbody].face[MODL->sellist[0]].eface,
                                     "_body", &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);
        }

        if (itype == ATTRINT && nlist == 2) {
            status = ocsmSetValuD(MODL, AT_ibody1, 1, 1, (double)(tempIlist[0]));
            CHECK_STATUS(ocsmSetValuD);

            status = ocsmSetValuD(MODL, AT_ibody2, 1, 1, (double)(tempIlist[1]));
            CHECK_STATUS(ocsmSetValuD);
        } else {
            status = ocsmSetValuD(MODL, AT_ibody1, 1, 1, -1.0);
            CHECK_STATUS(ocsmSetValuD);

            status = ocsmSetValuD(MODL, AT_ibody2, 1, 1, -1.0);
            CHECK_STATUS(ocsmSetValuD);
        }
    } else {
        status = ocsmSetValuD(MODL, AT_ibody1, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody2, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);
    }

    PPRINT0(done setting up header);

    /* find the bounding box of all the entities in the sellist */
    bbox[0] = +HUGEQ;          // xmin
    bbox[1] = +HUGEQ;          // ymin
    bbox[2] = +HUGEQ;          // zmin
    bbox[3] = -HUGEQ;          // xmax
    bbox[4] = -HUGEQ;          // ymax
    bbox[5] = -HUGEQ;          // zmax

    if (MODL->seltype == -1) {
        status = EG_getBoundingBox(MODL->body[MODL->selbody].ebody, bbox);
        CHECK_STATUS(EG_getBoundingBox);
    } else if (MODL->seltype == 1 && MODL->selsize == 1) {
        status = EG_getRange(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                             trange, &periodic);
        CHECK_STATUS(EG_getRange);

        status = EG_evaluate(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                             &(trange[0]), data);
        if (status == SUCCESS) {
            bbox[0] = data[0];
            bbox[1] = data[1];
            bbox[2] = data[2];

            status = EG_evaluate(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                                 &(trange[1]), data);
            CHECK_STATUS(EG_evaluate);
            bbox[3] = data[0];
            bbox[4] = data[1];
            bbox[5] = data[2];
        } else if (status == EGADS_DEGEN) {
            status = EG_getTopology(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                                    &eref, &oclass, &mtype, trange, &nchild, &enodes, &sense);
            CHECK_STATUS(EG_getTopology);

            status = EG_getTopology(enodes[0], &eref, &oclass, &mtype,
                                    bbox, &nchild, &echild, &sense);
            CHECK_STATUS(EG_getTopology);

            bbox[3] = bbox[0];
            bbox[4] = bbox[1];
            bbox[5] = bbox[2];
        } else {
            CHECK_STATUS(EG_evaluate);
        }
    } else {
        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            if        (MODL->seltype == 2) {
                status = EG_getBoundingBox(MODL->body[MODL->selbody].face[MODL->sellist[ilist]].eface, box);
                CHECK_STATUS(EG_getBoundingBox);
            } else if (MODL->seltype == 1) {
                status = EG_getBoundingBox(MODL->body[MODL->selbody].edge[MODL->sellist[ilist]].eedge, box);
                CHECK_STATUS(EG_getBoundingBox);
            } else if (MODL->seltype == 0) {
                status = EG_getTopology(MODL->body[MODL->selbody].node[MODL->sellist[ilist]].enode,
                                        &eref, &oclass, &mtype,
                                        box, &nchild, &echild, &sense);
                CHECK_STATUS(EG_getTopology);

                box[3] = box[0];
                box[4] = box[1];
                box[5] = box[2];
            } else {
                SPRINT1(0, "ERROR:: bad MODL->seltype=%d", MODL->seltype);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            bbox[0] = MIN(bbox[0], box[0]);
            bbox[1] = MIN(bbox[1], box[1]);
            bbox[2] = MIN(bbox[2], box[2]);
            bbox[3] = MAX(bbox[3], box[3]);
            bbox[4] = MAX(bbox[4], box[4]);
            bbox[5] = MAX(bbox[5], box[5]);
        }
    }

    /* set @xmin, @xmax, @ymin, @ymax, @zmin, and @zmax */
    status = ocsmSetValuD(MODL, AT_xmin, 1, 1, bbox[0]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_ymin, 1, 1, bbox[1]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_zmin, 1, 1, bbox[2]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_xmax, 1, 1, bbox[3]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_ymax, 1, 1, bbox[4]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_zmax, 1, 1, bbox[5]);
    CHECK_STATUS(ocsmSetValuD);

    PPRINT0(done setting up bounding box info);

    /* find the mass properties of all the entities in the sellist */
    if (MODL->seltype == -1) {
        status = EG_getMassProperties(MODL->body[MODL->selbody].ebody, massprop);
        CHECK_STATUS(EG_getMassProperties);
    } else {
        massprop[ 0] = 0;         // area
        massprop[ 1] = 0;         // volume
        massprop[ 2] = 0;         // xcg
        massprop[ 3] = 0;         // ycg
        massprop[ 4] = 0;         // zcg
        massprop[ 5] = 0;         // Ixx
        massprop[ 6] = 0;         // Ixy
        massprop[ 7] = 0;         // Ixz
        massprop[ 8] = 0;         // Iyx
        massprop[ 9] = 0;         // Iyy
        massprop[10] = 0;         // Iyz
        massprop[11] = 0;         // Izx
        massprop[12] = 0;         // Izy
        massprop[13] = 0;         // Izz

        if        (MODL->seltype == 2) {
            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                status = EG_getMassProperties(MODL->body[MODL->selbody].face[MODL->sellist[ilist]].eface, data);
                CHECK_STATUS(EG_getMassProperties);

                massprop[ 0] += data[ 0];          // should be 0
                massprop[ 1] += data[ 1];
                massprop[ 2] += data[ 2] * data[1];
                massprop[ 3] += data[ 3] * data[1];
                massprop[ 4] += data[ 4] * data[1];
                massprop[ 5] += data[ 5] + data[1] * data[2] * data[2];
                massprop[ 6] += data[ 6] + data[1] * data[2] * data[3];
                massprop[ 7] += data[ 7] + data[1] * data[2] * data[4];
                massprop[ 8] += data[ 8] + data[1] * data[3] * data[2];
                massprop[ 9] += data[ 9] + data[1] * data[3] * data[3];
                massprop[10] += data[10] + data[1] * data[3] * data[4];
                massprop[11] += data[11] + data[1] * data[4] * data[2];
                massprop[12] += data[12] + data[1] * data[4] * data[3];
                massprop[13] += data[13] + data[1] * data[4] * data[4];
            }

            if (fabs(massprop[1]) > EPS20) {
                massprop[ 2] /= massprop[1];
                massprop[ 3] /= massprop[1];
                massprop[ 4] /= massprop[1];
            }
            massprop[ 5] -= massprop[1] * massprop[2] * massprop[2];
            massprop[ 6] -= massprop[1] * massprop[2] * massprop[3];
            massprop[ 7] -= massprop[1] * massprop[2] * massprop[4];
            massprop[ 8] -= massprop[1] * massprop[3] * massprop[2];
            massprop[ 9] -= massprop[1] * massprop[3] * massprop[3];
            massprop[10] -= massprop[1] * massprop[3] * massprop[4];
            massprop[11] -= massprop[1] * massprop[4] * massprop[2];
            massprop[12] -= massprop[1] * massprop[4] * massprop[3];
            massprop[13] -= massprop[1] * massprop[4] * massprop[4];
        } else if (MODL->seltype == 1) {
            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                status = EG_getMassProperties(MODL->body[MODL->selbody].edge[MODL->sellist[ilist]].eedge, data);
                CHECK_STATUS(EG_getMassProperties);

                massprop[ 0] += data[ 0];          // should be 0
                massprop[ 1] += data[ 1];
                massprop[ 2] += data[ 2] * data[1];
                massprop[ 3] += data[ 3] * data[1];
                massprop[ 4] += data[ 4] * data[1];
                massprop[ 5] += data[ 5] + data[1] * data[2] * data[2];
                massprop[ 6] += data[ 6] + data[1] * data[2] * data[3];
                massprop[ 7] += data[ 7] + data[1] * data[2] * data[4];
                massprop[ 8] += data[ 8] + data[1] * data[3] * data[2];
                massprop[ 9] += data[ 9] + data[1] * data[3] * data[3];
                massprop[10] += data[10] + data[1] * data[3] * data[4];
                massprop[11] += data[11] + data[1] * data[4] * data[2];
                massprop[12] += data[12] + data[1] * data[4] * data[3];
                massprop[13] += data[13] + data[1] * data[4] * data[4];
            }

            if (fabs(massprop[1]) > EPS20) {
                massprop[ 2] /= massprop[1];
                massprop[ 3] /= massprop[1];
                massprop[ 4] /= massprop[1];
            }
            massprop[ 5] -= massprop[1] * massprop[2] * massprop[2];
            massprop[ 6] -= massprop[1] * massprop[2] * massprop[3];
            massprop[ 7] -= massprop[1] * massprop[2] * massprop[4];
            massprop[ 8] -= massprop[1] * massprop[3] * massprop[2];
            massprop[ 9] -= massprop[1] * massprop[3] * massprop[3];
            massprop[10] -= massprop[1] * massprop[3] * massprop[4];
            massprop[11] -= massprop[1] * massprop[4] * massprop[2];
            massprop[12] -= massprop[1] * massprop[4] * massprop[3];
            massprop[13] -= massprop[1] * massprop[4] * massprop[4];
        } else if (MODL->seltype == 0) {
            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                massprop[ 0] += 0;
                massprop[ 1] += 1;
                massprop[ 2] += MODL->body[MODL->selbody].node[MODL->sellist[ilist]].x;
                massprop[ 3] += MODL->body[MODL->selbody].node[MODL->sellist[ilist]].y;
                massprop[ 4] += MODL->body[MODL->selbody].node[MODL->sellist[ilist]].z;
            }

            if (fabs(massprop[1]) > EPS20) {
                massprop[ 2] /= massprop[1];
                massprop[ 3] /= massprop[1];
                massprop[ 4] /= massprop[1];
            }
            massprop[ 5]  = 0;
            massprop[ 6]  = 0;
            massprop[ 7]  = 0;
            massprop[ 8]  = 0;
            massprop[ 9]  = 0;
            massprop[10]  = 0;
            massprop[11]  = 0;
            massprop[12]  = 0;
            massprop[13]  = 0;
        } else {
            SPRINT1(0, "ERROR:: bad MODL->seltype=%d", MODL->seltype);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }
    }

    /* set @length, @area, and @volume */
    if        (MODL->seltype == 2) {
        status = ocsmSetValuD(MODL, AT_length, 1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_area,   1, 1, massprop[1]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_volume, 1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);
    }  else if (MODL->seltype == 1) {
        status = ocsmSetValuD(MODL, AT_length, 1, 1, massprop[1]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_area,   1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_volume, 1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);
    }  else if (MODL->seltype == 0) {
        status = ocsmSetValuD(MODL, AT_length, 1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_area,   1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_volume, 1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->seltype == -1 && MODL->body[MODL->selbody].botype == OCSM_WIRE_BODY) {
        status = ocsmSetValuD(MODL, AT_length, 1, 1, massprop[1]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_area,   1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_volume, 1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);
    } else {
        status = ocsmSetValuD(MODL, AT_length, 1, 1, 0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_area,   1, 1, massprop[1]);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_volume, 1, 1, massprop[0]);
        CHECK_STATUS(ocsmSetValuD);
    }

    /* set @xcg, @ycg, and @zcg */
    status = ocsmSetValuD(MODL, AT_xcg, 1, 1, massprop[2]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_ycg, 1, 1, massprop[3]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_zcg, 1, 1, massprop[4]);
    CHECK_STATUS(ocsmSetValuD);

    /* set @Ixx, @Ixy, @Ixz, @Iyx, @Iyy, @Iyz, @Izx, @Izy, and @Izz */
    status = ocsmSetValuD(MODL, AT_Ixx, 1, 1, massprop[5]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_Ixy, 1, 1, massprop[6]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_Ixz, 1, 1, massprop[7]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_Iyx, 1, 1, massprop[8]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_Iyy, 1, 1, massprop[9]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_Iyz, 1, 1, massprop[10]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_Izx, 1, 1, massprop[11]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_Izy, 1, 1, massprop[12]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_Izz, 1, 1, massprop[13]);
    CHECK_STATUS(ocsmSetValuD);

    PPRINT0(done setting up mass properties);

cleanup:
    PPRINT0(exit setupAtPmtrs);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   signalError - add to error message buffer                          *
 *                                                                      *
 ************************************************************************
 */

static void
signalError(void   *modl,               /* (in)  pointer to MODL */
            int    status,              /* (in)  status flag */
            char   format[],            /* (in)  format specifier */
            ...)                        /* (in)  variable arguments for format */
{
    va_list   args;

    char      sigMesg[MAX_STR_LEN];
    int       ibrch;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(signalError);

    /* --------------------------------------------------------------- */

    /* remember the Branch where this error happened */
    ibrch = MODL->ibrch;

    /* set up the va structure */
    va_start(args, format);

    /* save the signal code */
    MODL->sigCode = status;

    /* add the error to the sigMesg */

    /* Branch is known */
    if        (ibrch > 0 && STRLEN(MODL->brch[ibrch].filename) > 0) {
        snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s) in Branch %s at [[%s:%d]]\n        ",
                 ocsmGetText(status), MODL->brch[ibrch].name, MODL->brch[ibrch].filename, MODL->brch[ibrch].linenum);

     /* there are no Branches (yet) */
    } else if (MODL->nbrch == 0) {
        snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s)\n        ",
                 ocsmGetText(status));

    /* Branch is known, but there is not file */
    } else if (ibrch > 0) {
        snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s) in Branch %s [[not in file]]\n        ",
                 ocsmGetText(status), MODL->brch[ibrch].name);

    /* unknown how we got here */
    } else {
        snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s)\n        ",
                 ocsmGetText(status));
    }
    SPRINT1x(0, "%s", MODL->sigMesg);

    vsnprintf(sigMesg, MAX_STR_LEN, format, args);
    SPRINT1(0, "%s", sigMesg);

    strncat(MODL->sigMesg, sigMesg, MAX_STR_LEN-1);

    /* clean up the va structure */
    va_end(args);

//cleanup:
}

#ifdef PRINT_TIMES
static void
printTimes(struct rusage ru_beg,
           struct rusage ru_end,
           struct timeval t_beg,
           struct timeval t_end)
{
    double user_time, sys_time, wall_time;

    user_time = (ru_end.ru_utime.tv_sec+ru_end.ru_utime.tv_usec*0.000001)
               -(ru_beg.ru_utime.tv_sec+ru_beg.ru_utime.tv_usec*0.000001);
    sys_time  = (ru_end.ru_stime.tv_sec+ru_end.ru_stime.tv_usec*0.000001)
               -(ru_beg.ru_stime.tv_sec+ru_beg.ru_stime.tv_usec*0.000001);
    wall_time = ((long)t_end.tv_sec+(long)t_end.tv_usec*0.000001)
               -((long)t_beg.tv_sec+(long)t_beg.tv_usec*0.000001);

    bool_user_time += user_time;
    bool_sys_time  += sys_time;
    bool_wall_time += wall_time;

    SPRINT4(0, "user:%.3f    sys:%.3f     total:%.3f     wall=%.3f",
            user_time, sys_time, user_time+
sys_time, wall_time);
}
#endif


/*
 ************************************************************************
 *                                                                      *
 *   solidBoolean - performs solid boolean and loosens tolers if needed *
 *                                                                      *
 ************************************************************************
 */

static int
solidBoolean(modl_T *MODL,              /* (in)  pointer to MODL */
             ego    ebodyl,             /* (in)  Body on left */
             ego    ebodyr,             /* (in)  Body on rite */
             int    type,               /* (in)  boolean type */
             double maxtol,             /* (in)  maximum allowable tolerance */
             ego    *emodel)            /* (out) model containing result */
{
    int       status = SUCCESS;         /* (out) return status */

    int       oclass, mtype, nchild, *senses, itry, inudge;
    double    tolerl, tolerr, data[4], xform[12];
    char      filename[MAX_FILENAME_LEN];
    ego       eref, *echilds, ebodyll=NULL, ebodyrr=NULL, context, ebodys2[2], emodel2, exform;

#ifdef PRINT_TIMES
    int            nfacel, nfacer;
    struct rusage  beg_rusage, end_rusage;
    struct timeval beg_time,   end_time;
#endif

    ROUTINE(solidBoolean);

    /* --------------------------------------------------------------- */

    status = EG_getContext(ebodyl, &context);
    CHECK_STATUS(EG_getContext);

    if (outLevel >= 3) {
        SPRINT0(3, "before EG_solidBoolean: ebodyl");
        ocsmPrintEgo(ebodyl);
        SPRINT0(3, "before EG_solidBoolean: ebodyr");
        ocsmPrintEgo(ebodyr);
    }

    /* if ebodyl is a model, just do a simple FUSION */
    status = EG_getTopology(ebodyl, &eref, &oclass, &mtype,
                            data, &nchild, &echilds, &senses);
    CHECK_STATUS(eg_gettopology);

    if (oclass == MODEL) {
#ifdef PRINT_TIMES
        EG_getBodyTopos(ebodyl, NULL, FACE, &nfacel, NULL);
        EG_getBodyTopos(ebodyr, NULL, FACE, &nfacer, NULL);
        gettimeofday(&beg_time, NULL);
        getrusage(RUSAGE_SELF, &beg_rusage);
#endif
        status = EG_solidBoolean(ebodyl, ebodyr, type, emodel);
#ifdef PRINT_TIMES
        gettimeofday(&end_time, NULL);
        getrusage(RUSAGE_SELF, &end_rusage);
        SPRINT2x(0, "A: nfacel:%4d nfacer:%4d ", nfacel, nfacer);
        printTimes(beg_rusage, end_rusage, beg_time, end_time);
#endif
        SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
               0.0, -1, status, ocsmGetText(status));

        /* if boolean failed and dumpEgads is specified, then dump
           a model that contains the two offending Bodys*/
        if (status < EGADS_SUCCESS && MODL->dumpEgads == 2) {
            SPRINT1(0, "ERROR:: EG_solidBoolean -> status=%d", status);

            snprintf(filename, MAX_FILENAME_LEN, "BOOL_ERROR_%d.egads", type);
            SPRINT1(0, "ERROR:: dumping \"%s\" for failed Boolean operation", filename);

            status = EG_copyObject(ebodyl, NULL, &(ebodys2[0]));
            CHECK_STATUS(EG_copyObject);
            status = EG_copyObject(ebodyr, NULL, &(ebodys2[1]));
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 2, ebodys2, NULL, &emodel2);
            CHECK_STATUS(EG_makeTopology);

            status = remove(filename);
            if (status == 0) {
                SPRINT1(1, "WARNING:: file \"%s\" is being overwritten", filename);
                (MODL->nwarn)++;
            }

            status = EG_saveModel(emodel2, filename);
            CHECK_STATUS(EG_saveModel);

            status = EG_deleteObject(emodel2);
            CHECK_STATUS(EG_deleteObject);
        }
        goto cleanup;
    }

    /* make copies of Bodys so that any increased tolerance will
       be applied only locally */
    status = EG_copyObject(ebodyl, NULL, &ebodyll);
    CHECK_STATUS(EG_copyObject);

    status = EG_copyObject(ebodyr, NULL, &ebodyrr);
    CHECK_STATUS(EG_copyObject);

    /* if maxtol<0, then use -maxtol as tolerance (and do not do tolerance adjustments) */
    if (maxtol < 0) {
        status = EG_setTolerance(ebodyll, -maxtol);
        CHECK_STATUS(EG_setTolerance);

        status = EG_setTolerance(ebodyrr, -maxtol);
        CHECK_STATUS(EG_setTolerance);

        (void)  EG_setOutLevel(context, 0);
#ifdef PRINT_TIMES
        EG_getBodyTopos(ebodyll, NULL, FACE, &nfacel, NULL);
        EG_getBodyTopos(ebodyrr, NULL, FACE, &nfacer, NULL);
        gettimeofday(&beg_time, NULL);
        getrusage(RUSAGE_SELF, &beg_rusage);
#endif
        status = EG_solidBoolean(ebodyll, ebodyrr, type, emodel);
#ifdef PRINT_TIMES
        gettimeofday(&end_time, NULL);
        getrusage(RUSAGE_SELF, &end_rusage);
        SPRINT2x(0, "B: nfacel:%4d nfacer:%4d ", nfacel, nfacer);
        printTimes(beg_rusage, end_rusage, beg_time, end_time);
#endif
        (void) EG_setOutLevel(context, outLevel);
        SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
               -maxtol, -1, status, ocsmGetText(status));
        CHECK_STATUS(EG_solidBoolean);

        goto cleanup;
    }

    /* find the tolerances of the orginal Bodys */
    status = EG_getTolerance(ebodyll, &tolerl);
    CHECK_STATUS(EG_getTolerance);

    status = EG_getTolerance(ebodyrr, &tolerr);
    CHECK_STATUS(EG_getTolerance);
    SPRINT3(3, "    maxtol=%e, tolerl=%e, tolerr=%e", maxtol, tolerl, tolerr);

    /* loop to keep increasing tolerance until we either get a good
       result or we have reached the specified tolerance */
    for (itry = 0; itry < 10; itry++) {

        /* try the boolean operation */
        (void) EG_setOutLevel(context, 0);
#ifdef PRINT_TIMES
        EG_getBodyTopos(ebodyll, NULL, FACE, &nfacel, NULL);
        EG_getBodyTopos(ebodyrr, NULL, FACE, &nfacer, NULL);
        gettimeofday(&beg_time, NULL);
        getrusage(RUSAGE_SELF, &beg_rusage);
#endif
        status = EG_solidBoolean(ebodyll, ebodyrr, type, emodel);
#ifdef PRINT_TIMES
        gettimeofday(&end_time, NULL);
        getrusage(RUSAGE_SELF, &end_rusage);
        SPRINT2x(0, "C: nfacel:%4d nfacer:%4d ", nfacel, nfacer);
        printTimes(beg_rusage, end_rusage, beg_time, end_time);
#endif
        (void) EG_setOutLevel(context, outLevel);
        SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
               MAX(tolerl,tolerr), -1, status, ocsmGetText(status));

        /* if boolean failed and dumpEgads is specified, then dump
           a model that contains the two offending Bodys*/
        if (status < EGADS_SUCCESS && MODL->dumpEgads == 2) {
            SPRINT1(0, "ERROR:: EG_solidBoolean -> status=%d", status);

            sprintf(filename, "BOOL_ERROR_%d.egads", type);
            SPRINT1(0, "ERROR:: dumping \"%s\" for failed Boolean operation", filename);

            status = EG_copyObject(ebodyl, NULL, &(ebodys2[0]));
            CHECK_STATUS(EG_copyObject);
            status = EG_copyObject(ebodyr, NULL, &(ebodys2[1]));
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 2, ebodys2, NULL, &emodel2);
            CHECK_STATUS(EG_makeTopology);

            status = remove(filename);
            if (status == 0) {
                SPRINT1(1, "WARNING:: file \"%s\" is being overwritten", filename);
                (MODL->nwarn)++;
            }

            status = EG_saveModel(emodel2, filename);
            CHECK_STATUS(EG_saveModel);

            status = EG_deleteObject(emodel2);
            CHECK_STATUS(EG_deleteObject);
        }
        SPRINT2(3, "    EG_solidBoolean(itry=%d) -> status=%d", itry, status);

        /* the operation succeeded */
        if (status == EGADS_SUCCESS) {

            /* if on the first try, so simply return */
            if (itry == 0) {
                goto cleanup;

            /* otherwise, generate a warning about new tolerance */
            } else {
                SPRINT1(1, "WARNING:: tolerance increased to %e to get good result", MAX(tolerl,tolerr));
                (MODL->nwarn)++;
                goto cleanup;
            }
        }

        /* otherwise, remove the bad model and try increasing the tolerance (by a factor of 4)
           up to the user-specified value */
        if (*emodel != NULL) {
            status = EG_deleteObject(*emodel);
            CHECK_STATUS(EG_deleteObject);
        }

        if        (tolerl < tolerr) {
            tolerl = tolerr;
        } else if (tolerr < tolerl) {
            tolerr = tolerl;
        } else if (tolerl < maxtol) {
            tolerl = MIN(4*tolerl, maxtol);
            tolerr = tolerl;
        } else {
            break;
        }

        SPRINT1(3, "    increasing tolerl to %e", tolerl);
        status = EG_setTolerance(ebodyll, tolerl);
        CHECK_STATUS(EG_setTolerance);

        SPRINT1(3, "    increasing tolerr to %e", tolerr);
        status = EG_setTolerance(ebodyrr, tolerr);
        CHECK_STATUS(EG_setTolerance);
    }

    /* now that we have tried changing tolerances, and that has apparently not
       worked, try nudging ebodyr in each of the cardinal directions (this
       is not right, but at least it works sometimes) */
    status = EG_getTolerance(ebodyr, &tolerr);
    CHECK_STATUS(EG_getTolerance);

    xform[0] = 1;   xform[1] = 0;   xform[ 2] = 0;
    xform[4] = 0;   xform[5] = 1;   xform[ 6] = 0;
    xform[8] = 0;   xform[9] = 0;   xform[10] = 1;

    for (inudge = 0; inudge < 6; inudge++) {
        if        (inudge == 0) {
            xform[3] = +2*tolerr;   xform[7] = 0;         xform[11] = 0;
        } else if (inudge == 1) {
            xform[3] = -2*tolerr;   xform[7] = 0;         xform[11] = 0;
        } else if (inudge == 2) {
            xform[3] = 0;           xform[7] = +2*tolerr; xform[11] = 0;
        } else if (inudge == 3) {
            xform[3] = 0;           xform[7] = -2*tolerr; xform[11] = 0;
        } else if (inudge == 4) {
            xform[3] = 0;           xform[7] = 0;         xform[11] = +2*tolerr;
        } else {
            xform[3] = 0;           xform[7] = 0;         xform[11] = -2*tolerr;
        }

        status = EG_makeTransform(MODL->context, xform, &exform);
        CHECK_STATUS(EG_makeTransform);

        if (ebodyrr != NULL) EG_deleteObject(ebodyrr);

        status = EG_copyObject(ebodyr, exform, &ebodyrr);
        CHECK_STATUS(EG_copyObject);

#ifdef PRINT_TIMES
        EG_getBodyTopos(ebodyl, NULL, FACE, &nfacel, NULL);
        EG_getBodyTopos(ebodyr, NULL, FACE, &nfacer, NULL);
        gettimeofday(&beg_time, NULL);
        getrusage(RUSAGE_SELF, &beg_rusage);
#endif
        status = EG_solidBoolean(ebodyl, ebodyrr, type, emodel);
#ifdef PRINT_TIMES
        gettimeofday(&end_time, NULL);
        getrusage(RUSAGE_SELF, &end_rusage);
        SPRINT2x(0, "D: nfacel:%4d nfacer:%4d ", nfacel, nfacer);
        printTimes(beg_rusage, end_rusage, beg_time, end_time);
#endif
        SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
               MAX(tolerl,tolerr), inudge, status, ocsmGetText(status));

        if (status == EGADS_SUCCESS) {
            SPRINT3(1, "WARNING:: nudged rite Body by (%12.4e,%12.4e,%12.4e)",
                    xform[3], xform[7], xform[11]);
            (MODL->nwarn)++;
            goto cleanup;
        }
    }

    /* getting here means nothing we tried worked */
    signalError(MODL, OCSM_INTERNAL_ERROR,
                "max trys exceeded in solidBoolean");
    status = OCSM_INTERNAL_ERROR;

cleanup:
    if (ebodyll != NULL) EG_deleteObject(ebodyll);
    if (ebodyrr != NULL) EG_deleteObject(ebodyrr);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   solveSketch - solve a Sketch                                       *
 *                                                                      *
 ************************************************************************
 */

static int
solveSketch(modl_T *modl,               /* (in)  pointer to MODL */
            sket_T *sket)               /* (both) array of Sketch info */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(solveSketch);

    /* --------------------------------------------------------------- */

    /* try using the (original) Newton solver first */
    status = solveSketchOrig(modl, sket);
    if (status == SUCCESS) goto cleanup;

    /* if it failed, clear the signal and try using the Levenberg-Marquardt solver */
    SPRINT0(1, "trying Levenberg-Marquardt solver");

    MODL->sigCode = 0;

    status = solveSketchLM(modl, sket);
    if (status != SUCCESS) {
    }
    CHECK_STATUS(solveSketchLM);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   solveSketchLM - solve a Sketch (using Levenberg-Marquardt)         *
 *                                                                      *
 ************************************************************************
 */

static int
solveSketchLM(modl_T *modl,             /* (in)  pointer to MODL */
              sket_T *sket)             /* (both) array of Sketch info */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        jpmtr, jndex, ivar, nvar, icon, ncon, iter, niter, iworst, k;
    double     value, dot, rms, rmslast, lambda, f0max, f0worst, save_value, dfdx_max, omega=0.25;
    double     *val_init=NULL, *neg_f0=NULL, *neg_f0old=NULL, *delx=NULL, *dfdx=NULL;
    double     *JtJ=NULL, *JtQ=NULL;
    char       str[MAX_STRVAL_LEN];

    ROUTINE(solveSketchLM);

    /* --------------------------------------------------------------- */

    if (sket->solved == 1) {
        goto cleanup;
    }

    for (icon = 0; icon < sket->ncon; icon++) {
        SPRINT2(2, "    -> setting con[%3d] = %s", icon, sket->con[icon]);
    }

    /* check for under- or over-constrained Sketch */
    if        (sket->ncon < sket->nvar) {
        SPRINT2(1, "WARNING:: under-constrained Sketch (nvar=%d but ncon=%d) will not be solved",
                sket->nvar, sket->ncon);
        (MODL->nwarn)++;
        goto cleanup;
    } else if (sket->ncon > sket->nvar) {
        SPRINT2(1, "WARNING:: over-constrained Sketch (nvar=%d but ncon=%d) will not be solved",
                sket->nvar, sket->ncon);
        (MODL->nwarn)++;
        goto cleanup;
    }

    nvar = sket->nvar;
    ncon = sket->ncon;

    /* get needed arrays */
    MALLOC(val_init,  double,  nvar        );
    MALLOC(neg_f0,    double,         ncon );
    MALLOC(neg_f0old, double,         ncon );
    MALLOC(dfdx,      double, (nvar)*(ncon));
    MALLOC(delx,      double,  nvar        );
    MALLOC(JtJ,       double, (nvar)*(ncon));
    MALLOC(JtQ,       double,  nvar        );

    /* store the initial values in case we need to rvert because solver failed */
    for (ivar = 0; ivar < nvar; ivar++) {
        jpmtr = sket->ipmtr[ivar];
        jndex = sket->index[ivar];
        val_init[ivar] = MODL->pmtr[jpmtr].value[jndex];

        delx[ivar] = 0;
    }

    /* Levenburg-Marquardt iteration to change the Sketch variables until
       the constraints are satisfied */
    niter   = 200;
    lambda  = 0.01;
    rmslast = 1e300;
    iworst  = -1;
    f0worst = 0;

    for (iter = 0; iter < niter; iter++) {
#ifdef GRAFIC
        {
            int   io_kbd=5, io_scr=6, ilin=GR_SOLID, isym=GR_CIRCLE, nper=0, nline=1, indgr=1+4+16+64;
            float xplot[1000], yplot[1000];
            char  pltitl[80];

            /* remember points */
            for (ivar = 0; ivar < sket->nvar; ivar++) {
                jpmtr = sket->ipmtr[ivar];
                jndex = sket->index[ivar];

                if (strcmp(MODL->pmtr[jpmtr].name, "::x") == 0) {
                    xplot[jndex] = MODL->pmtr[jpmtr].value[jndex];
                    nper         = jndex + 1;
                }
                if (strcmp(MODL->pmtr[jpmtr].name, "::y") == 0) {
                    yplot[jndex] = MODL->pmtr[jpmtr].value[jndex];
                    nper         = jndex + 1;
                }
            }

            for (ivar = 0; ivar < nper; ivar++) {
                SPRINT3(1, "%3d %10.5f %10.5f", ivar, xplot[ivar], yplot[ivar]);
            }

            /* close sketch */
            xplot[nper] = xplot[0];
            yplot[nper] = yplot[0];
            nper++;

            /* plot */
            sprintf(pltitl, "~x~y~sketch at beginning of iteration %d", iter);
            grinit_(&io_kbd, &io_scr, "sketch evolution", STRLEN("sketch evolution"));
            grline_(&ilin, &isym, &nline, pltitl,
                    &indgr, xplot, yplot, &nper, STRLEN(pltitl));
        }
#endif

        /* evaluate the constraints */
        f0max = 0;
        rms   = 0;
        for (icon = 0; icon < ncon; icon++) {
            status = str2val(sket->con[icon], MODL, &value, &dot, str);
            CHECK_STATUS(str2val);

            if (STRLEN(str) > 0) {
                signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                            "constraint cannot have a string value (%s)", str);
                goto cleanup;
            }

            if (iter != 0) {
                neg_f0old[icon] = neg_f0[icon];
            }

            neg_f0[icon] = -value;
            SPRINT3(2, "       f0[%4d] = %11.4e  (%s)", icon, value, sket->con[icon]);

            if (iter == 0) {
                neg_f0old[icon] = neg_f0[icon];
            }

            rms += value * value;

            if (fabs(value) > f0max) {
                f0max = fabs(value);
                if (iter == 0) {
                    iworst  = icon;
                    f0worst = f0max;
                }
            }
        }

        SPRINT2(1, "    -> solving   iter = %3d,   f0max = %12.4e", iter, f0max);

        /* if we have converged, stop the Levenburg-Marquardt iterations */
        if (f0max < EPS09) {
            break;
        }

        /* rms <= rmslast, we are converging, so decrease lambda and accept step */
        if (rms <= rmslast) {
            lambda = MAX(0.5*lambda, 1.0e-10);
            SPRINT3(2, "       rmslast=%12.4e  rms=%12.4e  ACCEPT  lambda=%12.4e", rmslast, rms, lambda);

            rmslast = rms;
            omega   = MIN(1.2*omega, 1);

        /* rms > rmslast, not converging, so increase lambda and revert to old step */
        } else {
            lambda = MIN(2.0*lambda, 1.0e+10);
            SPRINT3(2, "       rmslast=%12.4e  rms=%12.4e  REJECT  lambda=%12.4e", rmslast, rms, lambda);

            for (ivar = 0; ivar < nvar; ivar++) {
                jpmtr = sket->ipmtr[ivar];
                jndex = sket->index[ivar];
                MODL->pmtr[jpmtr].value[jndex] -= omega * delx[ivar];

                for (icon = 0; icon < ncon; icon++) {
                    neg_f0[icon] = neg_f0old[icon];
                }
            }
        }

        /* build up the Jacobian matrix by perturbing the solver variables
           one at a time */
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            save_value = MODL->pmtr[jpmtr].value[jndex];
            MODL->pmtr[jpmtr].value[jndex] += EPS06;

            for (icon = 0; icon < ncon; icon++) {
                status = str2val(sket->con[icon], MODL, &value, &dot, str);
                CHECK_STATUS(str2val);

                if (STRLEN(str) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                }

                dfdx[icon*(nvar)+ivar] = (value + neg_f0[icon]) / EPS06;
            }

            MODL->pmtr[jpmtr].value[jndex] = save_value;
        }

        /* print out the Jacobian matrix */
        SPRINT0(2, "Jacobian matrix");
        for (icon = 0; icon < ncon; icon++) {
            dfdx_max = 0;
            SPRINT1x(2, "%3d: ", icon);

            for (ivar = 0; ivar < nvar; ivar++) {
                SPRINT1x(2, "%12.4e ", dfdx[icon*(nvar)+ivar]);
                if (fabs(dfdx[icon*(nvar)+ivar]) > dfdx_max) {
                    dfdx_max = fabs(dfdx[icon*(nvar)+ivar]);
                }
            }
            SPRINT1(2, " | %12.4e", dfdx_max);
        }

        /* find Jtranspose * J */
        for (ivar = 0; ivar < nvar; ivar++) {
            for (icon = 0; icon < ncon; icon++) {
                JtJ[icon*(nvar)+ivar] = 0;
                for (k = 0; k < nvar; k++) {
                    JtJ[icon*(nvar)+ivar] += dfdx[k*(nvar)+ivar] * dfdx[k*(nvar)+icon];
                }
            }
#ifndef __clang_analyzer__
            JtJ[ivar*(nvar)+ivar] *= (1.0 + lambda);
#endif
        }

        /* find Jtranspose * Q */
        for (ivar = 0; ivar < nvar; ivar++) {
            JtQ[ivar] = 0;
            for (icon = 0; icon < ncon; icon++) {
                JtQ[ivar] += dfdx[icon*(nvar)+ivar] * neg_f0[icon];
            }
        }

        /* take the Levenburg-Marquardt step */
        status = matsol(JtJ, JtQ, ncon, delx);
        CHECK_STATUS(matsol);

        /* update design variables */
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            MODL->pmtr[jpmtr].value[jndex] += omega * delx[ivar];

            SPRINT4(2, "       x [%4d] = %11.5f  (%s[%d])",
                    ivar, MODL->pmtr[jpmtr].value[jndex], MODL->pmtr[jpmtr].name, jndex+1);
        }
    }

    /* if converged, print final solution */
    if (f0max < EPS09) {
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            SPRINT3(1, "    -> updating  %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

    /* otherwise we ran out of iterations, so revert to initial guesses */
    } else {
        SPRINT0(1, "WARNING:: reverting to initial solution");

        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            MODL->pmtr[jpmtr].value[jndex] = val_init[ivar];
            SPRINT3(1, "    -> reverting %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

        status = OCSM_NOT_CONVERGED;
        signalError(MODL, status,
                    "initially, constraint %d had worst violation (%s -> %f)",
                    iworst+1, sket->con[iworst], f0worst);
        goto cleanup;
    }

    sket->solved = 1;

cleanup:
    FREE(val_init );
    FREE(delx     );
    FREE(dfdx     );
    FREE(neg_f0   );
    FREE(JtJ      );
    FREE(JtQ      );
    FREE(neg_f0old);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   solveSketchOrig - solve a Sketch (original method)                 *
 *                                                                      *
 ************************************************************************
 */

static int
solveSketchOrig(modl_T *modl,           /* (in)  pointer to MODL */
                sket_T *sket)           /* (both) array of Sketch info */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        jpmtr, jndex, nvar, ivar, ncon, icon, iter, niter, iworst;
    double     value, dot;
    double     *val_init=NULL, *f0neg=NULL, *dfdx=NULL, *delx=NULL;
    double     f0max, f0last, f0worst, save_value, omega, dfdx_max;
    char       str[MAX_STRVAL_LEN];

    ROUTINE(solveSketchOrig);

    /* --------------------------------------------------------------- */

    if (sket->solved == 1) {
        goto cleanup;
    }

    for (icon = 0; icon < sket->ncon; icon++) {
        SPRINT2(2, "    -> setting con[%3d] = %s", icon, sket->con[icon]);
    }

    /* check for under- or over-constrained Sketch */
    if        (sket->ncon < sket->nvar) {
        SPRINT2(1, "WARNING:: under-constrained Sketch (nvar=%d but ncon=%d) will not be solved",
                sket->nvar, sket->ncon);
        (MODL->nwarn)++;
        goto cleanup;
    } else if (sket->ncon > sket->nvar) {
        SPRINT2(1, "WARNING:: over-constrained Sketch (nvar=%d but ncon=%d) will not be solved",
                sket->nvar, sket->ncon);
        (MODL->nwarn)++;
        goto cleanup;
    }

    nvar = sket->nvar;
    ncon = sket->ncon;

    /* set up for function evaluation and Jacobian */
    MALLOC(val_init, double, nvar     );
    MALLOC(f0neg,    double,      ncon);
    MALLOC(dfdx,     double, nvar*ncon);
    MALLOC(delx,     double, nvar     );

    /* store the initial values in case we need to revert because solver failed */
    for (ivar = 0; ivar < nvar; ivar++) {
        jpmtr = sket->ipmtr[ivar];
        jndex = sket->index[ivar];
        val_init[ivar] = MODL->pmtr[jpmtr].value[jndex];
    }

    /* Newton iteration to change the Sketch variables until
       the constraints are satisfied */
    niter   = 25;
    omega   = 0.25;
    f0last  = 1e+100;
    iworst  = -1;
    f0worst = 0;

    for (iter = 0; iter < niter; iter++) {

#ifdef GRAFIC
        {
            int   io_kbd=5, io_scr=6, ilin=GR_SOLID, isym=GR_CIRCLE, nper=0, nline=1, indgr=1+4+16+64;
            float xplot[MAX_SKETCH_SIZE+1], yplot[MAX_SKETCH_SIZE+1];
            char  pltitl[80];

            /* remember points */
            for (ivar = 0; ivar < nvar; ivar++) {
                jpmtr = sket->ipmtr[ivar];
                jndex = sket->index[ivar];

                if (strcmp(MODL->pmtr[jpmtr].name, "::x") == 0) {
                    xplot[jndex] = MODL->pmtr[jpmtr].value[jndex];
                    nper         = jndex + 1;
                }
                if (strcmp(MODL->pmtr[jpmtr].name, "::y") == 0) {
                    yplot[jndex] = MODL->pmtr[jpmtr].value[jndex];
                    nper         = jndex + 1;
                }
            }

            for (ivar = 0; ivar < nper; ivar++) {
                SPRINT3(1, "%3d %10.5f %10.5f", ivar, xplot[ivar], yplot[ivar]);
            }

            /* close sketch */
            xplot[nper] = xplot[0];
            yplot[nper] = yplot[0];
            nper++;

            /* plot */
            sprintf(pltitl, "~x~y~sketch at beginning of iteration %d", iter);
            grinit_(&io_kbd, &io_scr, "sketch evolution", STRLEN("sketch evolution"));
            grline_(&ilin, &isym, &nline, pltitl,
                    &indgr, xplot, yplot, &nper, STRLEN(pltitl));
        }
#endif

        /* evaluate the constraints */
        f0max = 0;
        for (icon = 0; icon < ncon; icon++) {
            status = str2val(sket->con[icon], MODL, &value, &dot, str);
            CHECK_STATUS(str2val);
            if (STRLEN(str) > 0) {
                status = OCSM_WRONG_PMTR_TYPE;
                goto cleanup;
            }

            f0neg[icon] = -value;
            SPRINT2(2, "       f0[%4d] = %11.4e", icon, value);

            if (fabs(value) > f0max) {
                f0max = fabs(value);
                if (iter == 0) {
                    iworst  = icon;
                    f0worst = f0max;
                }
            }
        }

        SPRINT2x(1, "    -> solving   iter = %3d,   f0max = %12.4e", iter, f0max);

        /* if we have converged, stop the Newton iterations */
        if (f0max < EPS12) {
            SPRINT0(1, "   converged");
            break;

        /* f0max < f0last, we are converging, so increase omega */
        } else if (f0max < f0last) {
            f0last = f0max;
            omega  = MIN(1.2*omega, 1);
            SPRINT1(1, "   accepting, omega=%10.5f", omega);

        /* otherwise, revert to last solution and decrease omega */
        } else {
#ifndef __clang_analyzer__
            for (ivar = 0; ivar < nvar; ivar++) {
                jpmtr = sket->ipmtr[ivar];
                jndex = sket->index[ivar];

                MODL->pmtr[jpmtr].value[jndex] -= omega * delx[ivar];
            }
#endif

            omega = omega / 2.0;
            SPRINT1(1, "   rejecting, omega=%10.5f", omega);

            continue;
        }

        /* build up the Jacobian matrix by perturbing the solver variables
           one at a time */
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            save_value = MODL->pmtr[jpmtr].value[jndex];
            MODL->pmtr[jpmtr].value[jndex] += EPS06;

            for (icon = 0; icon < ncon; icon++) {
                status = str2val(sket->con[icon], MODL, &value, &dot, str);
                CHECK_STATUS(str2val);
                if (STRLEN(str) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                }

#ifndef __clang_analyzer__
                dfdx[icon*(ncon)+ivar] = (value + f0neg[icon]) / EPS06;
#endif
            }

            MODL->pmtr[jpmtr].value[jndex] = save_value;
        }

        /* print out the Jacobian matrix */
        SPRINT0(2, "Jacobian matrix");
        for (icon = 0; icon < ncon; icon++) {
            dfdx_max = 0;
            SPRINT1x(2, "%3d: ", icon);

            for (ivar = 0; ivar < nvar; ivar++) {
#ifndef __clang_analyzer__
                SPRINT1x(2, "%12.4e ", dfdx[icon*(ncon)+ivar]);
                if (fabs(dfdx[icon*(ncon)+ivar]) > dfdx_max) {
                    dfdx_max = fabs(dfdx[icon*(ncon)+ivar]);
                }
#endif
            }
            SPRINT1(2, " | %12.4e", dfdx_max);
        }

        /* take the Newton step */
        status = matsol(dfdx, f0neg, ncon, delx);
        CHECK_STATUS(matsol);

        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            MODL->pmtr[jpmtr].value[jndex] += omega * delx[ivar];

            SPRINT4(2, "       x [%4d] = %11.5f  (%s[%d])",
                    ivar, MODL->pmtr[jpmtr].value[jndex], MODL->pmtr[jpmtr].name, jndex+1);
        }
    }

    /* if converged, print final solution */
    if (f0max < EPS06) {
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            SPRINT3(1, "    -> updating  %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

    /* otherwise we ran out of iterations, so revert to initial guesses */
    } else {
        SPRINT0(1, "WARNING:: reverting to initial solution");

        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            MODL->pmtr[jpmtr].value[jndex] = val_init[ivar];
            SPRINT3(1, "    -> reverting %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

        status = OCSM_NOT_CONVERGED;
        signalError(MODL, status,
                    "initially, constraint %d has worst violation (%f)", iworst+1, f0worst);
        goto cleanup;
    }

    sket->solved = 1;

cleanup:
    FREE(delx );
    FREE(dfdx );
    FREE(f0neg);
    FREE(val_init);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   splineVelocityOfEdge - callback function for EG_blend/ruled_vels   *
 *                                                                      *
 ************************************************************************
 */
static int
splineVelocityOfEdge(void*     usrData,        /* (in)  blind pointer to user data */
         /*@unused@*/const ego secs[],         /* (in)  array of sections */
                     int       isec,           /* (in)  currnt section (bias-0) */
                     ego       eedge,          /* (in)  Edge for which sensitivity is desired */
                     CINT      npnt,           /* (in)  number   of t for evaluation */
                     CDOUBLE   ts[],           /* (in)  array    of t for evaluation */
                     CDOUBLE   ts_dot[],       /* (in)  velocity of t for evaluation */
                     double    xyz[],          /* (out) coordinates at ts */
                     double    xyz_dot[],      /* (out) velocity    at ts */
                     double    dxdt_beg[],     /* (out) tangent vector at beg of eedge */
                     double    dxdt_beg_dot[], /* (out) velocity of dxdt_beg */
                     double    dxdt_end[],     /* (out) tangent vector ay end of eedge */
                     double    dxdt_end_dot[]) /* (out) velocity of dxdt_end */
{
    int status = EGADS_SUCCESS;  /* (out) return status */

    int    ipnt, ibody, iedge;
    double x[18], x_dot[18], dt[2], tt[2], xx_dot[6];

    egadsSpline_T *spl;

    ROUTINE(splineVelocityOfEdge);

    /* --------------------------------------------------------------- */

    if (EG_hasGeometry_dot(eedge) == EGADS_SUCCESS) {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            /* evaluate the points and sensitivity */
            status = EG_evaluate_dot(eedge, &ts[ipnt], &ts_dot[ipnt], x, x_dot);
            CHECK_STATUS(EG_evaluate_dot);

            xyz[3*ipnt  ] = x[0];
            xyz[3*ipnt+1] = x[1];
            xyz[3*ipnt+2] = x[2];

            xyz_dot[3*ipnt  ] = x_dot[0];
            xyz_dot[3*ipnt+1] = x_dot[1];
            xyz_dot[3*ipnt+2] = x_dot[2];

            /* set the sensitivity of the tangent at the beginning and end */
            if (ipnt == 0) {
                dxdt_beg[0] = x[3];
                dxdt_beg[1] = x[4];
                dxdt_beg[2] = x[5];

                dxdt_beg_dot[0] = x_dot[3];
                dxdt_beg_dot[1] = x_dot[4];
                dxdt_beg_dot[2] = x_dot[5];
            }

            if (ipnt == npnt-1) {
                dxdt_end[0] = x[3];
                dxdt_end[1] = x[4];
                dxdt_end[2] = x[5];

                dxdt_end_dot[0] = x_dot[3];
                dxdt_end_dot[1] = x_dot[4];
                dxdt_end_dot[2] = x_dot[5];
            }
        }
    } else {
        spl = (egadsSpline_T *)usrData;

        ibody = spl->isketch[isec];
        iedge = 1;
        while( spl->MODL->body[ibody].edge[iedge].eedge != eedge ) {
            iedge++;
            if (iedge > spl->MODL->body[ibody].nedge) {
                SPRINT0(0, "ERROR:: Could not find edge in sketch!");
                status = OCSM_UNKNOWN;
                goto cleanup;
            }
        }

        /* evaluate the points */
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate(eedge, &ts[ipnt], x);
            CHECK_STATUS(EG_evaluate);

            xyz[3*ipnt  ] = x[0];
            xyz[3*ipnt+1] = x[1];
            xyz[3*ipnt+2] = x[2];

            /* set the sensitivity of the tangent at the beginning and end */
            if (ipnt == 0) {
                dxdt_beg[0] = x[3];
                dxdt_beg[1] = x[4];
                dxdt_beg[2] = x[5];
            }

            if (ipnt == npnt-1) {
                dxdt_end[0] = x[3];
                dxdt_end[1] = x[4];
                dxdt_end[2] = x[5];
            }
        }

        /* compute the sensitivites */
        status = velocityOfEdge(spl->MODL, ibody, iedge, npnt,
                                (double *)ts, xyz_dot);
        CHECK_STATUS(velocityOfEdge);

        /* approximate (via finite differences) the sensitivity of the tangent
           at the beginning and end */
        dt[0] = 0.1 * (ts[     1] - ts[     0]);
        dt[1] = 0.1 * (ts[npnt-1] - ts[npnt-2]);

        tt[0] = ts[     0] + dt[0];
        tt[1] = ts[npnt-1] - dt[1];

        status = velocityOfEdge(spl->MODL, ibody, iedge, 2, tt, xx_dot);
        CHECK_STATUS(velocityOfEdge);

        dxdt_beg_dot[0] = (xx_dot[0] - xyz_dot[       0]) / dt[0];
        dxdt_beg_dot[1] = (xx_dot[1] - xyz_dot[       1]) / dt[0];
        dxdt_beg_dot[2] = (xx_dot[2] - xyz_dot[       2]) / dt[0];

        dxdt_end_dot[0] = (xyz_dot[3*npnt-3] - xx_dot[3]) / dt[1];
        dxdt_end_dot[1] = (xyz_dot[3*npnt-2] - xx_dot[4]) / dt[1];
        dxdt_end_dot[2] = (xyz_dot[3*npnt-1] - xx_dot[5]) / dt[1];
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   splineVelocityOfNode - callback function for EG_blend/ruled_vels   *
 *                                                                      *
 ************************************************************************
 */
static int
splineVelocityOfNode(void*     usrData,   /* (in)  blind pointer to user data */
         /*@unused@*/const ego secs[],    /* (in)  array of sections */
                     int       isec,      /* (in)  current section (bias-0) */
                     ego       enode,     /* (in)  Node for which sensitivity is desired */
                     ego       eedge,     /* (in)  Edge attached to the node */
                     double    xyz[],     /* (out) coordinates of enode */
                     double    xyz_dot[]) /* (out) velocity    of enode */
{
    int status = EGADS_SUCCESS;  /* (out) return status */

#ifdef USE_VELOCITYOFEDGE
    int    inode, iedge, ibody, oclass, mtype, nnode, *senses;
    double trange[2], t;
    ego    eref, *enodes;
#else
    int inode, ibody;
#endif
    egadsSpline_T *spl;

    ROUTINE(splineVelocityOfNode);

    /* --------------------------------------------------------------- */

    if (EG_hasGeometry_dot(enode) == EGADS_SUCCESS) {
        /* evaluate the point and sensitivity */
        status = EG_evaluate_dot(enode, NULL, NULL, xyz, xyz_dot);
        CHECK_STATUS(EG_evaluate_dot);
    } else {
        spl = (egadsSpline_T *)usrData;

        ibody = spl->isketch[isec];
        inode = 1;
        while( spl->MODL->body[ibody].node[inode].enode != enode ) {
            inode++;
            if (inode > spl->MODL->body[ibody].nnode) {
                SPRINT0(0, "ERROR:: Could not find node in sketch!");
                status = OCSM_UNKNOWN;
                goto cleanup;
            }
        }

        /* get the coordinate of the Node */
        status = EG_evaluate(enode, NULL, xyz);
        CHECK_STATUS(EG_evaluate);

#ifdef USE_VELOCITYOFEDGE
//$$$  this is wrong, but consistent with old sensitivities
        if (eedge != NULL) {

            iedge = 1;
            while( spl->MODL->body[ibody].edge[iedge].eedge != eedge ) {
                iedge++;
                if (iedge > spl->MODL->body[ibody].nedge) {
                    SPRINT0(0, "ERROR:: Could not find edge in sketch!");
                    status = OCSM_UNKNOWN;
                    goto cleanup;
                }
            }

            /* get nodes from the edge */
            status = EG_getTopology(eedge, &eref,
                    &oclass, &mtype, trange, &nnode, &enodes, &senses);
            CHECK_STATUS(EG_getTopology);

            if (enode == enodes[0]) t = trange[0];
            else                    t = trange[1];

            status = velocityOfEdge(spl->MODL, ibody, iedge, 1,
                                    &t, xyz_dot);
            CHECK_STATUS(velocityOfEdge);

        } else {
            /* get the node velocity */
            status = velocityOfNode(spl->MODL, ibody, inode, xyz_dot);
            CHECK_STATUS(velocityOfNode);
        }
#else
        /* get the velocity */
        status = velocityOfNode(spl->MODL, ibody, inode, xyz_dot);
        CHECK_STATUS(velocityOfNode);
#endif

    }

cleanup:

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   storeCsystem - store Csystem on Body from Branch and parents       *
 *                                                                      *
 ************************************************************************
 */

static int
storeCsystem(modl_T *modl,              /* (in)  pointer to MODL */
             int    ibody)              /* (in)  Body index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int     ibrch, ileft, irite, nattr, iattr, nrow, ncol, nval;
    int     periodic, oclass, mtype, nchild, *senses;
    int     atype1, nlist1, atype2, nlist2, inode, iedge, iface;
    CINT    *tempIlist1, *tempIlist2;
    double  dot, *values=NULL, *dots=NULL, csvalues[9], range[4], uv[2], data[18];
    CDOUBLE *tempRlist1, *tempRlist2;
    char    *csysname=NULL, str[MAX_STRVAL_LEN];
    CCHAR   *aname1, *tempClist1, *tempClist2;
    ego     eref, *echilds;

    ROUTINE(storeCsystem);

    /* --------------------------------------------------------------- */

    ibrch = MODL->body[ibody].ibrch;
    ileft = MODL->body[ibody].ileft;
    irite = MODL->body[ibody].irite;

    /* add Csystem from left parent.  note that if the previous
       operation is a transformation, ibody will already have
       a (possiblye-transformed) Cystem on it already*/
    if (ileft > 0 && ileft <= MODL->nbody) {
        if (MODL->body[ileft].ebody != NULL) {
            status = EG_attributeNum(MODL->body[ileft].ebody, &nattr);
            CHECK_STATUS(EG_attributeNum);

            /* loop through each Csystem in ileft */
            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(MODL->body[ileft].ebody, iattr,
                                         &aname1, &atype1, &nlist1,
                                         &tempIlist1, &tempRlist1, &tempClist1);
                CHECK_STATUS(EG_attributeGet);

                if (atype1 == ATTRCSYS) {
                    SPRINT1(2, "ileft has Csystem %s", aname1);

                    /* only apply this Csystem to ibody if ibody
                       does not already have such a Csystem */
                    status = EG_attributeRet(MODL->body[ibody].ebody, aname1,
                                             &atype2, &nlist2,
                                             &tempIlist2, &tempRlist2, &tempClist2);
                    /* do nothing if it matches */
                    if (status == SUCCESS && atype1 == atype2) {
                        SPRINT1(2, "          Csystem %s already exists on ibody (skipping)", aname1);

                    /* if an Attribute exists, raise an error */
                    } else if (status == SUCCESS) {
                        signalError(MODL, OCSM_NAME_NOT_UNIQUE,
                                    "Attribute or Csystem \"%s\" already exists (left)", aname1);
                        status = MODL->sigCode;
                        goto cleanup;

                    /* otherwise, add the Csystem to ibody */
                    } else {
                        SPRINT0(2, "          adding Csystem to ibody");
                        status = EG_attributeAdd(MODL->body[ibody].ebody, aname1, ATTRCSYS,
                                                 9, NULL, tempRlist1, NULL);
                        CHECK_STATUS(EG_attributeAdd);
                    }
                }
            }
        }
    }

    /* add Csystem from rite parent */
    if (irite > 0 && irite <= MODL->nbody) {
        if (MODL->body[irite].ebody != NULL) {
            status = EG_attributeNum(MODL->body[irite].ebody, &nattr);
            CHECK_STATUS(EG_attributeNum);

            /* loop through each Csystem in irite */
            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(MODL->body[irite].ebody, iattr,
                                         &aname1, &atype1, &nlist1,
                                         &tempIlist1, &tempRlist1, &tempClist1);
                CHECK_STATUS(EG_attributeGet);

                if (atype1 == ATTRCSYS) {
                    SPRINT1(2, "irite has Csystem %s", aname1);

                    /* apply this Csystem to ibody */
                    status = EG_attributeRet(MODL->body[ibody].ebody, aname1,
                                             &atype2, &nlist2,
                                             &tempIlist2, &tempRlist2, &tempClist2);

                    /* if both left and rite had same Csystem name, use the one from the rite */
                    if (status == SUCCESS && atype1 == ATTRCSYS && atype2 == ATTRCSYS) {
                        SPRINT1(1, "WARNING:: Csystem \"%s\" from rite Body overrides the left", aname1);
                        (MODL->nwarn)++;
                        status = EG_attributeAdd(MODL->body[ibody].ebody, aname1, ATTRCSYS,
                                                 9, NULL, tempRlist1, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                    /* if an Attribute or Csystem already exists, raise an error */
                    } else if (status == SUCCESS) {
                        signalError(MODL, OCSM_NAME_NOT_UNIQUE,
                                    "Attribute or Csystem \"%s\" already exists (rite)", aname1);
                        status = MODL->sigCode;
                        goto cleanup;

                    /* otherwise, add the Csystem to ibody */
                    } else {
                        SPRINT0(2, "          adding Csystem to ibody");
                        status = EG_attributeAdd(MODL->body[ibody].ebody, aname1, ATTRCSYS,
                                                 9, NULL, tempRlist1, NULL);
                        CHECK_STATUS(EG_attributeAdd);
                    }
                }
            }
        }
    }

    /* add Cystem from Branch */
    for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
        if (MODL->brch[ibrch].attr[iattr].type == ATTRCSYS) {
            SPRINT1(2, "ibrch has Csystem %s", MODL->brch[ibrch].attr[iattr].name);

            status = str2vals(MODL->brch[ibrch].attr[iattr].defn, MODL,
                              &nrow, &ncol, &values, &dots, str);
            CHECK_STATUS(str2vals);

            /* apply this Csystem to ibody */
            status = EG_attributeRet(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name,
                                     &atype2, &nlist2,
                                     &tempIlist2, &tempRlist2, &tempClist2);

            /* if an Attribute already exists, raise an error */
            if (status == SUCCESS && atype2 != ATTRCSYS) {
                signalError(MODL, OCSM_NAME_NOT_UNIQUE,
                            "Attribute \"%s\" already exists (branch)", MODL->brch[ibrch].attr[iattr].name);
                status = MODL->sigCode;
                goto cleanup;
            }

            /* if there are 9 values, add the Csystem to ibody */
            if (nrow*ncol == 9) {
                /* x0, y0, z0, dx1, dy1, dz1, dx2, dy2, dz2 */
                SPRINT0(2, "          adding Csystem to ibody");

                /* origin (can be anywhere) */
                csvalues[0] = values[0];
                csvalues[1] = values[1];
                csvalues[2] = values[2];
                /* direction 1 */
                csvalues[3] = values[3];
                csvalues[4] = values[4];
                csvalues[5] = values[5];
                /* direction 2 */
                csvalues[6] = values[6];
                csvalues[7] = values[7];
                csvalues[8] = values[8];

                dot = csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];
                if (dot < EPS12) {
                    signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                "Csystem \"%s\" has zero length dirn1", MODL->brch[ibrch].attr[iattr].name);
                    status = MODL->sigCode;
                    goto cleanup;
                }

                /* subtract out of direction 2 the part that is parallel to direction 1 */
                dot = csvalues[3] * csvalues[6] + csvalues[4] * csvalues[7] + csvalues[5] * csvalues[8];
                if (fabs(dot) > EPS06) {
                    SPRINT1(1, "WARNING:: removing non-orthogonal part from dirn2 for csystem \"%s\"",
                            MODL->brch[ibrch].attr[iattr].name);
                    (MODL->nwarn)++;

                    dot /= csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];

                    csvalues[6] -= dot * csvalues[3];
                    csvalues[7] -= dot * csvalues[4];
                    csvalues[8] -= dot * csvalues[5];
                }

                dot = csvalues[6] * csvalues[6] + csvalues[7] * csvalues[7] + csvalues[8] * csvalues[8];
                if (dot < EPS12) {
                    signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                "Csystem \"%s\" has zero length dirn2", MODL->brch[ibrch].attr[iattr].name);
                    status = MODL->sigCode;
                    goto cleanup;
                }

                /* add CSYSTEM to Body */
                status = EG_attributeAdd(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name, ATTRCSYS,
                                         9, NULL, csvalues, NULL);
                CHECK_STATUS(EG_attributeRet);

                /* add _csys_* Attribute that remembers 9 input values */
                nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
                MALLOC(csysname, char, nval);
                sprintf(csysname, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
                status = EG_attributeAdd(MODL->body[ibody].ebody, csysname, ATTRREAL,
                                         9, NULL, values, NULL);
                FREE(csysname);
                CHECK_STATUS(EG_attributeAdd);

            /* if there are 5 values and first is positive, add the Csystem to ibody based upon a Face */
            } else if (nrow*ncol == 5 && values[0] > 0) {
                /* +iface, ubar0, vbar0, du2, dv2 */
                iface = NINT(+values[0]);

                if (iface >= 1 && iface <= MODL->body[ibody].nface) {
                    SPRINT1(2, "          adding Csystem to ibody from iface=%d", iface);

                    status = EG_getTopology(MODL->body[ibody].face[iface].eface, &eref,
                                            &oclass, &mtype, range, &nchild, &echilds, &senses);
                    CHECK_STATUS(EG_getTopology);

                    uv[0] = (1-values[1]) * range[0] + values[1] * range[1];
                    uv[1] = (1-values[2]) * range[2] + values[2] * range[3];

                    status = EG_evaluate(MODL->body[ibody].face[iface].eface, uv, data);
                    CHECK_STATUS(EG_evaluate);

                    /* origin (on Face) */
                    csvalues[0] =  data[0];
                    csvalues[1] =  data[1];
                    csvalues[2] =  data[2];
                    /* direction 1 (normal to Face) */
                    csvalues[3] = (data[4] * data[8]   - data[5] * data[7]) * mtype;
                    csvalues[4] = (data[5] * data[6]   - data[3] * data[8]) * mtype;
                    csvalues[5] = (data[3] * data[7]   - data[4] * data[6]) * mtype;
                    /* direction 2 (specified in terms of du and dv) */
                    csvalues[6] =  data[3] * values[3] + data[6] * values[4];
                    csvalues[7] =  data[4] * values[3] + data[7] * values[4];
                    csvalues[8] =  data[5] * values[3] + data[8] * values[4];

                    dot = csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn1", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    dot = csvalues[6] * csvalues[6] + csvalues[7] * csvalues[7] + csvalues[8] * csvalues[8];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn2", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* add CSYSTEM to Body */
                    status = EG_attributeAdd(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name, ATTRCSYS,
                                             9, NULL, csvalues, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    /* add _csys_* Attribute that remembers 5 input values */
                    nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
                    MALLOC(csysname, char, nval);
                    sprintf(csysname, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
                    status = EG_attributeAdd(MODL->body[ibody].ebody, csysname, ATTRREAL,
                                             5, NULL, values, NULL);
                    FREE(csysname);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    status = OCSM_FACE_NOT_FOUND;
                    goto cleanup;
                }

            /* if there are 5 values and first is negative, add the Csystem to ibody based upon a Edge */
            } else if (nrow*ncol == 5 && values[0] < 0) {
                /* -iedge, tbar, dx2, dy2, dz2 */
                iedge = NINT(-values[0]);
                if (iedge >= 1 && iedge <= MODL->body[ibody].nedge) {
                    SPRINT1(2, "          adding Csystem to ibody from iedge=%d", iedge);

                    status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, range, &periodic);
                    CHECK_STATUS(EG_getRange);

                    uv[0] = (1-values[1]) * range[0] + values[1] * range[1];

                    status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, uv, data);
                    CHECK_STATUS(EG_evaluate);

                    /* origin (on the Edge) */
                    csvalues[0] = data[0];
                    csvalues[1] = data[1];
                    csvalues[2] = data[2];
                    /* direction 1 (tangent to Edge) */
                    csvalues[3] = data[3];
                    csvalues[4] = data[4];
                    csvalues[5] = data[5];
                    /* direction 2 */
                    csvalues[6] = values[2];
                    csvalues[7] = values[3];
                    csvalues[8] = values[4];

                    dot = csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn1", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* subtract out of direction 2 the part that is parallel to direction 1 */
                    dot = csvalues[3] * csvalues[6] + csvalues[4] * csvalues[7] + csvalues[5] * csvalues[8];
                    if (fabs(dot) > EPS06) {
                        SPRINT1(1, "WARNING:: removing non-orthogonal part from dirn2 for csystem \"%s\"",
                                MODL->brch[ibrch].attr[iattr].name);
                        (MODL->nwarn)++;

                        dot /= csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];

                        csvalues[6] -= dot * csvalues[3];
                        csvalues[7] -= dot * csvalues[4];
                        csvalues[8] -= dot * csvalues[5];
                    }

                    dot = csvalues[6] * csvalues[6] + csvalues[7] * csvalues[7] + csvalues[8] * csvalues[8];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn2", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* add CSYSTEM to Body */
                    status = EG_attributeAdd(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name, ATTRCSYS,
                                             9, NULL, csvalues, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    /* add _csys_* Attribute that remembers 5 input values */
                    nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
                    MALLOC(csysname, char, nval);
                    sprintf(csysname, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
                    status = EG_attributeAdd(MODL->body[ibody].ebody, csysname, ATTRREAL,
                                             5, NULL, values, NULL);
                    FREE(csysname);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    status = OCSM_EDGE_NOT_FOUND;
                    goto cleanup;
                }

            /* if there are 7 values, add the Csystem to ibody based upon a Node */
            } else if (nrow*ncol == 7) {
                /* inode, dx1, dy1, dz1, dx2, dy2, dz2 */
                inode = NINT(values[0]);
                if (inode >= 1 && inode <= MODL->body[ibody].nnode) {
                    SPRINT1(2, "          adding Csystem to ibody from inode=%d", inode);

                    /* origin (at Node) */
                    csvalues[0] = MODL->body[ibody].node[inode].x;
                    csvalues[1] = MODL->body[ibody].node[inode].y;
                    csvalues[2] = MODL->body[ibody].node[inode].z;
                    /* direction 1 */
                    csvalues[3] = values[1];
                    csvalues[4] = values[2];
                    csvalues[5] = values[3];
                    /* direction 2 */
                    csvalues[6] = values[4];
                    csvalues[7] = values[5];
                    csvalues[8] = values[6];

                    dot = csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn1", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* subtract out of direction 2 the part that is parallel to direction 1 */
                    dot = csvalues[3] * csvalues[6] + csvalues[4] * csvalues[7] + csvalues[5] * csvalues[8];
                    if (fabs(dot) > EPS06) {
                        SPRINT1(1, "WARNING:: removing non-orthogonal part from dirn2 for csystem \"%s\"",
                                MODL->brch[ibrch].attr[iattr].name);
                        (MODL->nwarn)++;

                        dot /= csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];

                        csvalues[6] -= dot * csvalues[3];
                        csvalues[7] -= dot * csvalues[4];
                        csvalues[8] -= dot * csvalues[5];
                    }

                    dot = csvalues[6] * csvalues[6] + csvalues[7] * csvalues[7] + csvalues[8] * csvalues[8];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn2", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* add CSYSTEM to Body */
                    status = EG_attributeAdd(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name, ATTRCSYS,
                                             9, NULL, csvalues, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    /* add _csys_* Attribute that remembers 7 input values */
                    nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
                    MALLOC(csysname, char, nval);
                    sprintf(csysname, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
                    status = EG_attributeAdd(MODL->body[ibody].ebody, csysname, ATTRREAL,
                                             7, NULL, values, NULL);
                    FREE(csysname);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    status = OCSM_NODE_NOT_FOUND;
                    goto cleanup;
                }

            /* otherwise raise an error */
            } else {
                signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                            "Csystem values \"%s\" do not match expected pattern",
                            MODL->brch[ibrch].attr[iattr].defn);
                status = MODL->sigCode;
                goto cleanup;
            }

            FREE(values);
            FREE(dots  );
        }
    }

cleanup:
    FREE(csysname);
    FREE(values);
    FREE(dots  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   str2rpn - convert expression to Rpn-code                           *
 *                                                                      *
 ************************************************************************
 */

static int
str2rpn(char      str[],                /* (in)  string containing expression */
        rpn_T     *rpn)                 /* (in)  pointer to Rpn-code */
{
    int       status = SUCCESS;         /* (out) return status */

    typedef struct {
        int       type;                 /* type of token */
        char      text[MAX_STRVAL_LEN]; /* text associated with token */
    } tok_T;

    tok_T     token[  MAX_EXPR_LEN],
              opstack[MAX_EXPR_LEN];
    int       istr, jstr, ntoken, nrpn, nopstack, nparen, nbrakt;
    int       i, j, count, type;
    char      text[MAX_STRVAL_LEN], temp_str[MAX_STR_LEN];

    ROUTINE(str2rpn);

#define ADD_TOKEN(TYPE, TEXT)                                \
    if (ntoken < MAX_EXPR_LEN-1) {                           \
        token[ntoken].type = TYPE;                           \
        STRNCPY(token[ntoken].text, TEXT, MAX_STRVAL_LEN);   \
        ntoken++;                                            \
    } else {                                                 \
        status = OCSM_TOKEN_STACK_OVERFLOW;                  \
        goto cleanup;                                        \
    }

#define ADD_TOKEN_CHAR(TYPE, CHAR)                           \
    if (ntoken < MAX_EXPR_LEN-1) {                           \
        token[ntoken].type = TYPE;                           \
        token[ntoken].text[0] = CHAR;                        \
        token[ntoken].text[1] = '\0';                        \
        ntoken++;                                            \
    } else {                                                 \
        status = OCSM_TOKEN_STACK_OVERFLOW;                  \
        goto cleanup;                                        \
    }

#define PUSH_OP(TYPE, TEXT)                                  \
    if (nopstack < MAX_EXPR_LEN-1) {                         \
        opstack[nopstack].type = TYPE;                       \
        STRNCPY(opstack[nopstack].text, TEXT, MAX_STRVAL_LEN); \
        nopstack++;                                          \
    } else {                                                 \
        status = OCSM_OP_STACK_OVERFLOW;                     \
        goto cleanup;                                        \
    }

#define POP_OP(TYPE, TEXT)                                    \
    if (nopstack > 0) {                                       \
        nopstack--;                                           \
        TYPE = opstack[nopstack].type;                        \
        STRNCPY(TEXT, opstack[nopstack].text, MAX_STRVAL_LEN);  \
    } else {                                                  \
        status = OCSM_OP_STACK_UNDERFLOW;                     \
        goto cleanup;                                         \
    }

#define PUSH_RPN(TYPE, TEXT)                                 \
    if (nrpn < MAX_EXPR_LEN-1) {                             \
        rpn[nrpn].type = TYPE;                               \
        STRNCPY(rpn[nrpn].text, TEXT, MAX_STRVAL_LEN);       \
        nrpn++;                                              \
    } else {                                                 \
        status = OCSM_RPN_STACK_OVERFLOW;                    \
        goto cleanup;                                        \
    }

#define POP_RPN(TYPE, TEXT)                                  \
    if (nrpn > 0) {                                          \
        nrpn--;                                              \
        TYPE = rpn[nrpn].type;                               \
        STRNCPY(TEXT, rpn[nrpk].text, MAX_STRVAL_LEN);       \
    } else {                                                 \
        status = OCSM_RPN_STACK_UNDERFLOW;                   \
        goto cleanup;                                        \
    }

    /* --------------------------------------------------------------- */

    SPRINT1(3, "enter str2rpn(str=%s)", str);

    /* convert str to tokens
       - surrounded by parentheses
       - remove white space
       - check for valid character
       - convert unary ops to binary ops:
            (+  to  (0+
            (-  to  (0-
            [+  to  [0+
            [-  to  [0-
            ,+  to  ,0+
            ,-  to  ,0-
       - check count and nesting of parentheses
    */
    ntoken = 0;               /* number of tokens */
    nparen = 1;               /* number of unmatched open parens */
    nbrakt = 0;               /* number of unmatched open brackets */

    /* first token is an open paren */
    ADD_TOKEN(PARSE_OPENP, "(");

    /* loop through all characters of the string containing the expression */
    for (istr = 0; istr < STRLEN(str); istr++) {

        /* if first two characters are "$!", strip them off (so that
           implicit string can be treated as an expression) */
        if (istr == 0 && STRLEN(str) > 1 && str[0] == '$' && str[1] == '!') {
            istr++;
            continue;
        }

        /* ignore exclamation point (for backward compatibility) */
        if        (str[istr] == '!') {

        /* dollar sign introduces string (that is terminated by comma,
           plus, open-bracket, or end-of-line */
        } else if (str[istr] == '$') {
            istr++;
            jstr = 0;
            temp_str[jstr] = '\0';

            while (istr < STRLEN(str)) {
                if (str[istr] == ',' || str[istr] == '+' ||
                    str[istr] == ')'                       ) {
                    istr--;
                    break;
                } else if (str[istr] >= 'a' && str[istr] <= 'z') {
                    temp_str[jstr++] = str[istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] >= 'A' && str[istr] <= 'Z') {
                    temp_str[jstr++] = str[istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] >= '0' && str[istr] <= '9') {
                    temp_str[jstr++] = str[istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] == '@' || str[istr] == '_'  ||
                           str[istr] == ':' || str[istr] == ';'  ||
                           str[istr] == '$' || str[istr] == '.'  ||
                           str[istr] == '-' || str[istr] == '*'  ||
                           str[istr] == '/' || str[istr] == '\\' ||
                           str[istr] == '?' || str[istr] == '%'  ||
                           str[istr] == '(' || str[istr] == '^'  ||
                           str[istr] == '[' || str[istr] == ']'  ||
                           str[istr] == '{' || str[istr] == '}'  ||
                           str[istr] == '<' || str[istr] == '>'  ||
                           str[istr] == '='                        ) {
                    temp_str[jstr++] = str[istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] == '\'' && str[istr+1] == ',') {
                    temp_str[jstr++] = str[++istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] == '\'' && str[istr+1] == '+') {
                    temp_str[jstr++] = str[++istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] == '\'' && str[istr+1] == ')') {
                    temp_str[jstr++] = str[++istr];
                    temp_str[jstr  ] = '\0';
                } else {
                    SPRINT2(0, "ERROR:: illegal character (%c) in string %s", str[istr], str);
                    status = OCSM_ILLEGAL_CHAR_IN_EXPR;
                    goto cleanup;
                }

                istr++;
            }
            ADD_TOKEN(PARSE_STRING, temp_str);

        /* open parenthesis */
        } else if (str[istr] == '(') {

            /* add the new PARSE_OPENP token */
            ADD_TOKEN(PARSE_OPENP, "(");

            nparen++;

        /* close parenthesis */
        } else if (str[istr] == ')') {

            /* add the new PARSE_CLOSEP token */
            ADD_TOKEN(PARSE_CLOSEP, ")");

            nparen--;

            /* make sure there is a matching open for this close */
            if (nparen < 1) {
                SPRINT1(1, ") before ( at character %d", istr);
                status = OCSM_CLOSE_BEFORE_OPEN;
                goto cleanup;
            }

        /* open bracket */
        } else if (str[istr] == '[') {

            /* add the new PARSE_OPENB token */
            ADD_TOKEN(PARSE_OPENB, "[");

            nbrakt++;

        /* close bracket */
        } else if (str[istr] == ']') {

            /* add the new PARSE_CLOSEB token */
            ADD_TOKEN(PARSE_CLOSEB, "]");

            nbrakt--;

            /* make sure there is a matching open for this close */
            if (nbrakt < 0) {
                SPRINT1(1, "] before [ at character %d", istr);
                status = OCSM_CLOSE_BEFORE_OPEN;
                goto cleanup;
            }

        /* comma (which separates the arguments of a function) */
        } else if (str[istr] == ',') {

            /* add the new PARSE_COMMA token */
            ADD_TOKEN(PARSE_COMMA, ",");

        /* digit (0-9) or period (which starts a number) */
        } else if (str[istr] == '.' || isdigit(str[istr]) != 0) {

            /* start a new PARSE_NUMBER token */
            ADD_TOKEN_CHAR(PARSE_NUMBER, str[istr]);

            /* add new characters from str as long as we are within a number */
            i = 1;
            for (jstr = istr+1; jstr < STRLEN(str); jstr++) {
                if (isdigit(str[jstr]) != 0 || str[jstr] == '.') {
                    token[ntoken-1].text[i  ] = str[jstr];
                    token[ntoken-1].text[i+1] = '\0';
                    i++;
                    istr++;

                /* if we find an 'E' or 'e' while making a number, put it
                   and the character after it (which might be a + or - or
                   digit) into the number */
                } else if (str[jstr] == 'E' || str[jstr] == 'e') {
                    token[ntoken-1].text[i  ] = str[jstr  ];
                    token[ntoken-1].text[i+1] = str[jstr+1];
                    token[ntoken-1].text[i+2] = '\0';
                    i++; i++;
                    istr++; istr++;
                    jstr++;   /* advance jstr since we consumed 2 characters */
                } else {
                    break;
                }
            }

        /* letter (a-z, A-Z, :, and @) (which starts a name or func) */
        } else if (isalpha(str[istr]) != 0 || str[istr] == ':'
                                           || str[istr] == '@') {

            /* start a new PARSE_NAME token */
            ADD_TOKEN_CHAR(PARSE_NAME, str[istr]);

            /* add new characters from str as long as we are within a name */
            i = 1;
            for (jstr = istr+1; jstr < STRLEN(str); jstr++) {
                if (isalpha(str[jstr]) !=  0  || isdigit(str[jstr]) !=  0 ||
                            str[jstr]  == '_' ||         str[jstr]  == '@'||
                            str[jstr]  == ':' ||         str[jstr]  == '.'  ) {
                    token[ntoken-1].text[i  ] = str[jstr];
                    token[ntoken-1].text[i+1] = '\0';
                    i++;
                    istr++;

                /* ignore exclamation points */
                } else if (str[jstr] == '!') {
                    istr++;

                /* convert to PARSE_FUNC if followed by open parenthesis */
                } else if (str[jstr] == '(') {
                    token[ntoken-1].type = PARSE_FUNC;
                    break;

                /* convert to PARSE_ARRAY if followed by open bracket */
                } else if (str[jstr] == '[') {
                    token[ntoken-1].type = PARSE_ARRAY;
                    break;

                } else {
                    break;
                }
            }

        /* plus or minus */
        } else if (str[istr] == '+' || str[istr] == '-') {

            /* if previous character is comma or open, convert this
               unary +/- into a binary +/- by adding a "0" before it */
            if (token[ntoken-1].type == PARSE_OPENP ||
                token[ntoken-1].type == PARSE_OPENB ||
                token[ntoken-1].type == PARSE_COMMA   ) {
                ADD_TOKEN(PARSE_NUMBER, "0");
            }

            /* add the new PARSE_OP1 token */
            ADD_TOKEN_CHAR(PARSE_OP1, str[istr]);

        /* asterisk or slash */
        } else if (str[istr] == '*' || str[istr] == '/') {

            /* add the new PARSE_OP2 token */
            ADD_TOKEN_CHAR(PARSE_OP2, str[istr]);

        /* caret */
        } else if (str[istr] == '^') {

            /* add the new PARSE_OP3 token */
            ADD_TOKEN_CHAR(PARSE_OP3, str[istr]);

        /* white space (' ' or \t, \r or \n) */
        } else if (str[istr] == ' '  || str[istr] == '\t' ||
                   str[istr] == '\r' || str[istr] == '\n'   ) {

        /* illegal character */
        } else {
            SPRINT2(1, "Illegal character at character %d (%c)", istr, str[istr]);
            status = OCSM_ILLEGAL_CHAR_IN_EXPR;
            goto cleanup;
        }
    }

    /* add a close parenthesis at the end */
    ADD_TOKEN(PARSE_CLOSEP, ")");

    nparen--;

    /* verify that the open and close parentheses are balanced */
    if        (nparen < 0) {
        SPRINT0(1, "More ) than (");
        status = OCSM_CLOSE_BEFORE_OPEN;
        goto cleanup;
    } else if (nparen > 0) {
        SPRINT0(1, "More ( than )");
        status = OCSM_MISSING_CLOSE;
        goto cleanup;
    }

    if        (nbrakt < 0) {
        SPRINT0(1, "More ] than [:");
        status = OCSM_CLOSE_BEFORE_OPEN;
        goto cleanup;
    } else if (nbrakt > 0) {
        SPRINT0(1, "More [ than ]");
        status = OCSM_MISSING_CLOSE;
        goto cleanup;
    }

    /* verify that the open and close parentheses are properly nested */
    for (i = 1; i < ntoken; i++) {
        if (token[i].type == PARSE_CLOSEP ||
            token[i].type == PARSE_CLOSEB   ) {
            count = 0;
            for (j = i-1; j >= 0; j--) {
                if (token[j].type == PARSE_OPENP ||
                    token[j].type == PARSE_OPENB   ) {
                    if (count == 0) {
                        if        (token[i].type == PARSE_CLOSEP &&
                                   token[j].type != PARSE_OPENP    ) {
                            SPRINT0(1, ") found but expected ]");
                            status = OCSM_IMPROPER_NESTING;
                            goto cleanup;
                        } else if (token[i].type == PARSE_CLOSEB &&
                                   token[j].type != PARSE_OPENB    ) {
                            SPRINT0(1, "] found by expected )");
                            status = OCSM_IMPROPER_NESTING;
                            goto cleanup;
                        }
                        break;
                    } else {
                        count--;
                    }
                } else if (token[j].type == PARSE_CLOSEP ||
                           token[j].type == PARSE_CLOSEB   ) {
                    count++;
                }
            }
        }
    }

    /* check for a proper sequencing of tokens */
    for (i = 0; i < ntoken-1; i++) {
        if         (token[i].type == PARSE_OP1  ||
                    token[i].type == PARSE_OP2  ||
                    token[i].type == PARSE_OP3    ) {
            if (token[i+1].type == PARSE_OP1    ||
                token[i+1].type == PARSE_OP2    ||
                token[i+1].type == PARSE_OP3    ||
                token[i+1].type == PARSE_CLOSEP ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_CLOSEB ||
                token[i+1].type == PARSE_COMMA    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_OPENP) {
            if (token[i+1].type == PARSE_OP1    ||
                token[i+1].type == PARSE_OP2    ||
                token[i+1].type == PARSE_OP3    ||
                token[i+1].type == PARSE_CLOSEP ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_CLOSEB ||
                token[i+1].type == PARSE_COMMA    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_CLOSEP) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_OPENB) {
            if (token[i+1].type == PARSE_OP1    ||
                token[i+1].type == PARSE_OP2    ||
                token[i+1].type == PARSE_OP3    ||
                token[i+1].type == PARSE_CLOSEP ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_CLOSEB ||
                token[i+1].type == PARSE_COMMA    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_CLOSEB) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_COMMA) {
            if (token[i+1].type == PARSE_OP1    ||
                token[i+1].type == PARSE_OP2    ||
                token[i+1].type == PARSE_OP3    ||
                token[i+1].type == PARSE_CLOSEP ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_CLOSEB ||
                token[i+1].type == PARSE_COMMA    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_NAME) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_ARRAY) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_NUMBER) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_FUNC    ) {
            if (token[i+1].type != PARSE_OPENP    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        }
    }

    /* make sure all function names are known */
    for (i = 0; i < ntoken; i++) {
        if (token[i].type == PARSE_FUNC) {
            if (strcmp(token[i].text, "pi"      ) == 0 ||
                strcmp(token[i].text, "min"     ) == 0 ||
                strcmp(token[i].text, "max"     ) == 0 ||
                strcmp(token[i].text, "sqrt"    ) == 0 ||
                strcmp(token[i].text, "abs"     ) == 0 ||
                strcmp(token[i].text, "int"     ) == 0 ||
                strcmp(token[i].text, "nint"    ) == 0 ||
                strcmp(token[i].text, "ceil"    ) == 0 ||
                strcmp(token[i].text, "floor"   ) == 0 ||
                strcmp(token[i].text, "mod"     ) == 0 ||
                strcmp(token[i].text, "sign"    ) == 0 ||
                strcmp(token[i].text, "exp"     ) == 0 ||
                strcmp(token[i].text, "log"     ) == 0 ||
                strcmp(token[i].text, "log10"   ) == 0 ||
                strcmp(token[i].text, "sin"     ) == 0 ||
                strcmp(token[i].text, "sind"    ) == 0 ||
                strcmp(token[i].text, "asin"    ) == 0 ||
                strcmp(token[i].text, "asind"   ) == 0 ||
                strcmp(token[i].text, "cos"     ) == 0 ||
                strcmp(token[i].text, "cosd"    ) == 0 ||
                strcmp(token[i].text, "acos"    ) == 0 ||
                strcmp(token[i].text, "acosd"   ) == 0 ||
                strcmp(token[i].text, "tan"     ) == 0 ||
                strcmp(token[i].text, "tand"    ) == 0 ||
                strcmp(token[i].text, "atan"    ) == 0 ||
                strcmp(token[i].text, "atand"   ) == 0 ||
                strcmp(token[i].text, "atan2"   ) == 0 ||
                strcmp(token[i].text, "atan2d"  ) == 0 ||
                strcmp(token[i].text, "hypot"   ) == 0 ||
                strcmp(token[i].text, "hypot3"  ) == 0 ||
                strcmp(token[i].text, "incline" ) == 0 ||
                strcmp(token[i].text, "Xcent"   ) == 0 ||
                strcmp(token[i].text, "Ycent"   ) == 0 ||
                strcmp(token[i].text, "Xmidl"   ) == 0 ||
                strcmp(token[i].text, "Ymidl"   ) == 0 ||
                strcmp(token[i].text, "seglen"  ) == 0 ||
                strcmp(token[i].text, "radius"  ) == 0 ||
                strcmp(token[i].text, "sweep"   ) == 0 ||
                strcmp(token[i].text, "turnang" ) == 0 ||
                strcmp(token[i].text, "dip"     ) == 0 ||
                strcmp(token[i].text, "smallang") == 0 ||
                strcmp(token[i].text, "val2str" ) == 0 ||
                strcmp(token[i].text, "str2val" ) == 0 ||
                strcmp(token[i].text, "findstr" ) == 0 ||
                strcmp(token[i].text, "slice"   ) == 0 ||
                strcmp(token[i].text, "path"    ) == 0 ||
                strcmp(token[i].text, "ifzero"  ) == 0 ||
                strcmp(token[i].text, "ifpos"   ) == 0 ||
                strcmp(token[i].text, "ifneg"   ) == 0 ||
                strcmp(token[i].text, "ifmatch" ) == 0 ||
                strcmp(token[i].text, "ifnan"   ) == 0   ) {
            } else {
                SPRINT1(1, "Illegel function name: %s", token[i].text);
                status = OCSM_ILLEGAL_FUNC_NAME;
                goto cleanup;
            }
        }
    }

    /* make sure all numbers are properly formed */
    for (i = 0; i < ntoken; i++) {
        if (token[i].type == PARSE_NUMBER) {
            count = 0;
            for (j = 0; j < STRLEN(token[i].text); j++) {
                if (token[i].text[j] == '.') count++;
            }

            if (count > 1) {
                SPRINT1(3, "Illegal number: %s", token[i].text);
                status = OCSM_ILLEGAL_NUMBER;
                goto cleanup;
            }
        }
    }

    /* print the tokens */
    if (outLevel >= 3) {
        SPRINT0(3, "token list");
        for (i = 0; i < ntoken; i++) {
            SPRINT3(3, "    %3d: type=%2d, text=%s", i, token[i].type, token[i].text);
        }
    }

    /* start with empty Rpn-code and op-stacks */
    nrpn     = 0;
    nopstack = 0;

    /* create the Rpn-code stack by cycling through the tokens */
    for (i = 0; i < ntoken; i++) {

        /* PARSE_NAME, PARSE_NUMBER, or PARSE_STRING */
        if (token[i].type == PARSE_NAME   ||
            token[i].type == PARSE_NUMBER ||
            token[i].type == PARSE_STRING   ) {
            PUSH_RPN(token[i].type, token[i].text);

        /* PARSE_OP1 */
        } else if (token[i].type == PARSE_OP1) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP || type == PARSE_OPENB ||
                    type == PARSE_COMMA ||
                    type == PARSE_FUNC  || type == PARSE_ARRAY  ) {
                    PUSH_OP(type, text);
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_OP2 */
        } else if (token[i].type == PARSE_OP2) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP || type == PARSE_OPENB ||
                    type == PARSE_COMMA ||
                    type == PARSE_FUNC  || type == PARSE_ARRAY ||
                    type == PARSE_OP1                            ) {
                    PUSH_OP(type, text);
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_OP3 */
        } else if (token[i].type == PARSE_OP3) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP || type == PARSE_OPENB ||
                    type == PARSE_COMMA ||
                    type == PARSE_FUNC  || type == PARSE_ARRAY ||
                    type == PARSE_OP1   || type == PARSE_OP2    ) {
                    PUSH_OP(type, text);
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_OPENP */
        } else if (token[i].type == PARSE_OPENP) {
            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_CLOSEP */
        } else if (token[i].type == PARSE_CLOSEP) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if  (type == PARSE_OPENP) {
                    if (nopstack <= 0) {

                    } else if (opstack[nopstack-1].type == PARSE_FUNC) {
                        POP_OP(type, text);
                        PUSH_RPN(type, text);
                    }
                    break;
                } else if (type == PARSE_OPENB) {
                    SPRINT0(1, "Found  [ ... )");
                    status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                    goto cleanup;
                } else {
                    PUSH_RPN(type, text);
                }
            }

        /* PARSE_OPENB */
        } else if (token[i].type == PARSE_OPENB) {
            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_CLOSEB */
        } else if (token[i].type == PARSE_CLOSEB) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP) {
                    SPRINT0(1, "Found ( ... ]");
                    status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                    goto cleanup;
                } else if (type == PARSE_OPENB || type == PARSE_COMMA) {
                    PUSH_OP(type, text);
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

            POP_OP(type, text);

            /* two subscripts for array */
            if (type == PARSE_COMMA) {
                POP_OP(type, text);
                POP_OP(type, text);
                PUSH_RPN(type, text);

            /* one subscript for array */
            } else if (type == PARSE_OPENB) {
                PUSH_RPN(PARSE_NUMBER, "0");

                POP_OP(type, text);
                PUSH_RPN(type, text);

            } else {
                SPRINT0(1, "Expected array name when ] found");
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }

        /* PARSE_COMMA */
        } else if (token[i].type == PARSE_COMMA) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP) {
                    PUSH_OP(type, text);
                    break;
                } else if (type == PARSE_OPENB) {
                    PUSH_OP(type, text);
                    PUSH_OP(PARSE_COMMA, ",");
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

        /* PARSE_FUNC */
        } else if (token[i].type == PARSE_FUNC) {
            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_ARRAY */
        } else if (token[i].type == PARSE_ARRAY) {
            PUSH_OP(token[i].type, token[i].text);

        }
    }

    /* add everything left on the op-stack to the Rpn-code */
    while (nopstack > 0) {
        POP_OP(type, text);

        PUSH_RPN(type, text);
    }

    /* add a PARSE_END to the end of the Rpn-code */
    PUSH_RPN(PARSE_END, "");

    /* print the Rpn-code */
    if (outLevel >= 3) {
        SPRINT0(3, "rpn-code list");
        for (i = 0; i < nrpn; i++) {
            SPRINT3(3, "    %3d: type=%2d, text=%s", i, rpn[i].type, rpn[i].text);
        }
        SPRINT0(3, "exit  str2rpn");
    }

#undef PUSH_OP
#undef POP_OP

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   str2val - convert and evaluate expression (in string)              *
 *                                                                      *
 ************************************************************************
 */

static int
str2val(char      expr[],               /* (in)  string containing expression */
        modl_T    *modl,                /* (in)  pointer to MODL */
        double    *val,                 /* (out) value      of expression */
        double    *dot,                 /* (out) derivative of expression */
        char      str[])                /* (out) value if string-valued (w/o leading $) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    rpn_T     *rpn=NULL;                /* Rpn-code */

    ROUTINE(str2val);

    /* --------------------------------------------------------------- */

    SPRINT1(3, "enter str2val(expr=%s)", expr);

    /* default returns */
    *val   = 0;
    *dot   = 0;
    str[0] = '\0';

    MALLOC(rpn, rpn_T, MAX_STACK_SIZE);

    /* short-cut if expression is a single digit */
    if (STRLEN(expr) == 1) {
        if (expr[0] >= '0' && expr[0] <= '9') {
            *val   = expr[0] - '0';
            goto cleanup;
        }
    }

    /* convert the expression to Rpn-code */
    status = str2rpn(expr, rpn);
    if (status != SUCCESS) {
        signalError(MODL, status,
                    "could not parse \"%s\"", expr);
    }
    CHECK_STATUS(str2rpn);

    /* evaluate the Rpn-code */
    status = evalRpn(rpn, modl, val, dot, str);
    if (status != SUCCESS) {
        signalError(MODL, status,
                    "%s when evaluating \"%s\"", str, expr);
    }
    CHECK_STATUS(evalRpn);

cleanup:
    SPRINT3(3, "    %10.5f %10.5f %20s", *val, *dot, str);

    FREE(rpn);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   str2vals - convert and evaluate expression to multiple values      *
 *                                                                      *
 ************************************************************************
 */

static int
str2vals(char      expr[],              /* (in)  string containing expression(s) */
         modl_T    *modl,               /* (in)  pointer to MODL */
         int       *nrow,               /* (out) number of rows (if from Parameter) */
         int       *ncol,               /* (out) number of cols (if from Parameter) */
         double    *vals[],             /* (out) values      of expression (freeable) */
         double    *dots[],             /* (out) derivatives of expression (freeable) */
         char      str[])               /* (out) value if string (w/o leading $) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ival, i, ibeg=0, ipmtr, nval;
    double    val, dot;
    char      tempexpr[MAX_STR_LEN];
    modl_T    *MODL = (modl_T*)modl;

    rpn_T     *rpn=NULL;                /* Rpn-code */

    ROUTINE(str2vals);

    /* --------------------------------------------------------------- */

    SPRINT1(3, "enter str2vals(expr=%s)", expr);

    /* default returns */
    *nrow = 0;
    *ncol = 0;
    *vals = NULL;
    *dots = NULL;
    str[0] = '\0';

    MALLOC(rpn, rpn_T, MAX_STACK_SIZE);

    /* short-cut if expression is a single digit */
    if (STRLEN(expr) == 1) {
        if (expr[0] >= '0' && expr[0] <= '9') {
            MALLOC(*vals, double, 1);
            MALLOC(*dots, double, 1);

            *nrow    = 1;
            *ncol    = 1;
            *vals[0] = expr[0] - '0';
            *dots[0] = 0;

            SPRINT4(3, "    %10.5f %10.5f %20s %5d",
                    *vals[0], *dots[0], "", 0);

            goto cleanup;
        }
    }

    /* if expr matches the name of Parameter, return its value(s) */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (strcmp(MODL->pmtr[ipmtr].name, expr) == 0) {
            if (MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level] ||
                MODL->pmtr[ipmtr].type  == OCSM_CONSTANT            ||
                MODL->pmtr[ipmtr].type  == OCSM_OUTPUT                ) {

                if (MODL->pmtr[ipmtr].str != NULL) {
                    strcpy(str, MODL->pmtr[ipmtr].str);

                    SPRINT4(3, "    %10.5f %10.5f %20s %5d",
                            0., 0., str, 0);
                } else {
                    *nrow = MODL->pmtr[ipmtr].nrow;
                    *ncol = MODL->pmtr[ipmtr].ncol;
                    nval  = (*nrow) * (*ncol);

                    MALLOC(*vals, double, nval);
                    MALLOC(*dots, double, nval);

                    for (i = 0; i < nval; i++) {
                        if (MODL->pmtr[ipmtr].value[i] == -HUGEQ) {
                            status = OCSM_ILLEGAL_VALUE;
                            goto cleanup;
                        }

                        (*vals)[i] = MODL->pmtr[ipmtr].value[i];
                        (*dots)[i] = MODL->pmtr[ipmtr].dot[  i];

                        SPRINT4(3, "    %10.5f %10.5f %20s %5d",
                                (*vals)[i], (*dots)[i], "", 0);
                    }
                }
                goto cleanup;
            }
        }
    }

    /* if it starts with $!, treat as non-string expression */
    if (STRLEN(expr) > 1 && expr[0] == '$' && expr[1] == '!') {
        ibeg = 2;

    /* if it starts with a dollar sign, it should evaluate to one string */
    } else if (expr[0] == '$') {
        STRNCPY(tempexpr, expr, MAX_STR_LEN);

        /* convert the expression to Rpn-code */
        status = str2rpn(tempexpr, rpn);
        if (status != SUCCESS) {
            signalError(MODL, status,
                        "could not parse \"%s\"", tempexpr);
            goto cleanup;
        }
        CHECK_STATUS(str2rpn);

        /* evaluate the Rpn-code */
        status = evalRpn(rpn, modl, &val, &dot, tempexpr);
        if (status != SUCCESS) {
            signalError(MODL, status,
                        "%s when evaluating \"%s\"", tempexpr, expr);
        } else if (STRLEN(tempexpr) == 0) {
            signalError(MODL, status,
                        "%s when evaluating \"%s\"", tempexpr, expr);
        } else {
            *nrow = 0;
            *ncol = 0;
            STRNCPY(str, tempexpr, MAX_STRVAL_LEN);
        }
        goto cleanup;
    }

    /* count the number of semicolons (with an implicit semicolon at the end) */
    *nrow = 0;
    *ncol = 0;
    for (i = 0; i < STRLEN(expr); i++) {
        if (expr[i] == ';') {
            (*ncol)++;
        }
    }
    if (expr[STRLEN(expr)-1] != ';') (*ncol)++;

    if (*ncol <= 0) {
        goto cleanup;
    }

    *nrow = 1;

    /* make arrays to hold the values and dots */
    MALLOC(*vals, double, *ncol);
    MALLOC(*dots, double, *ncol);

    /* loop through the string one value at a time */
    for (ival = 0; ival < *ncol; ival++) {
        STRNCPY(tempexpr, expr, MAX_STR_LEN);

        /* tempexpr contains the part of expr between semicolons */
        i = ibeg;
        while (tempexpr[i] != ';' && i < STRLEN(expr)) {
            i++;
        }
        tempexpr[i] = '\0';

        if (STRLEN(tempexpr) == 0) {
            status = OCSM_ILLEGAL_VALUE;
            signalError(MODL, status,
                        "expression %d is blank", ival);
            goto cleanup;
        }

        /* convert the expression to Rpn-code */
        status = str2rpn(&(tempexpr[ibeg]), rpn);
        if (status != SUCCESS) {
            signalError(MODL, status,
                        "could not parse \"%s\"", &(expr[ibeg]));
        }
        CHECK_STATUS(str2rpn);

        /* evaluate the Rpn-code */
        status = evalRpn(rpn, modl, &val, &dot, tempexpr);
        if (status != SUCCESS) {
            signalError(MODL, status,
                        "%s when evaluating \"%s\"", tempexpr, expr);
            goto cleanup;
        }

        if (STRLEN(tempexpr) > 0) {
            if (*nrow == 1 && *ncol == 1 && ival == 0) {
                *nrow = 0;
                *ncol = 0;
                STRNCPY(str, tempexpr, MAX_STRVAL_LEN);
            } else {
                status = OCSM_WRONG_PMTR_TYPE;
                signalError(MODL, status,
                            "cannot have string in multi-valued expression");
            }
            goto cleanup;
        }

        (*vals)[ival] = val;
        (*dots)[ival] = dot;

        ibeg = i + 1;
    }

cleanup:
    FREE(rpn);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   solsvd - solve  A * x = b  via singular value decomposition        *
 *                                                                      *
 ************************************************************************
 */

static int
solsvd(double A[],                      /* (in)  mrow*ncol matrix */
       double b[],                      /* (in)  mrow-vector (right-hand sides) */
       int    mrow,                     /* (in)  number of rows */
       int    ncol,                     /* (in)  number of columns */
       double W[],                      /* (out) ncol-vector of singular values */
       double x[])                      /* (out) ncol-vector (solution) */
{
    int    status = SUCCESS;            /* (out) return status */

    int    irow, jcol, i, j, k, flag, its, jj, ip1=0, nm=0;
    double *U=NULL, *V=NULL, *r=NULL, *t=NULL;
    double wmin, wmax, s, anorm, c, f, g, h, scale, xx, yy, zz;

    ROUTINE(solsvd);

    /* --------------------------------------------------------------- */

    /* this routine is an adaptation of svf.f found in the netlib
       repository.  it is a modification of a routine from the eispack
       collection, which in turn is a translation of the algol procedure svd,
       num. math. 14, 403-420(1970) by golub and reinsch.
       handbook for auto. comp., vol ii-linear algebra, 134-151(1971). */

    /* default return */
    for (jcol = 0; jcol < ncol; jcol++) {
        x[jcol] = 0;
    }

    /* check for legal size for A */
    if (ncol <= 0) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    } else if (mrow < ncol) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    MALLOC(U, double, mrow*ncol);
    MALLOC(V, double, ncol*ncol);
    MALLOC(r, double, ncol     );
    MALLOC(t, double, ncol     );

    /* initializations needed to avoid clang warning */
    for (i = 0; i < ncol; i++) {
        W[i] = 0;
        r[i] = 0;
        t[i] = 0;
    }

    /* initialize U to the original A */
    for (irow = 0; irow < mrow; irow++) {
        for (jcol = 0; jcol < ncol; jcol++) {
            U[irow*ncol+jcol] = A[irow*ncol+jcol];
        }
    }

    /* decompose A into U*W*V' */
    g     = 0;
    scale = 0;
    anorm = 0;

    /* Householder reduction of U to bidiagonal form */
    for (i = 0; i < ncol; i++) {
        ip1   = i + 1;
        r[i]  = scale * g;
        g     = 0;
        s     = 0;
        scale = 0;
        if (i < mrow) {
            for (k = i; k < mrow; k++) {
                scale += fabs(U[k*ncol+i]);
            }
            if (scale != 0) {
                for (k = i; k < mrow; k++) {
                    U[k*ncol+i] /= scale;
                    s           += U[k*ncol+i] * U[k*ncol+i];
                }
                f           = U[i*ncol+i];
                g           = -FSIGN(sqrt(s), f);
                h           = f * g - s;
                U[i*ncol+i] = f - g;
                for (j = ip1; j < ncol; j++) {
                    s = 0;
                    for (k = i; k < mrow; k++) {
                        s += U[k*ncol+i] * U[k*ncol+j];
                    }
                    f = s / h;
                    for (k = i; k < mrow; k++) {
                        U[k*ncol+j] += f * U[k*ncol+i];
                    }
                }
                for (k = i; k < mrow; k++) {
                    U[k*ncol+i] *= scale;
                }
            }
        }
        W[i]  = scale  * g;
        g     = 0;
        s     = 0;
        scale = 0;
        if (i < mrow && i+1 != ncol) {
            for (k = ip1; k < ncol; k++) {
                scale += fabs(U[i*ncol+k]);
            }
            if (scale != 0) {
                for (k = ip1; k < ncol; k++) {
                    U[i*ncol+k] /= scale;
                    s           += U[i*ncol+k] * U[i*ncol+k];
                }
                f           = U[i*ncol+ip1];
                g           = -FSIGN(sqrt(s), f);
                h           = f * g - s;
                U[i*ncol+ip1] = f - g;
                for (k = ip1; k < ncol; k++) {
                    r[k] = U[i*ncol+k] / h;
                }
                for (j = ip1; j < mrow; j++) {
                    s = 0;
                    for (k = ip1; k < ncol; k++) {
                        s += U[j*ncol+k] * U[i*ncol+k];
                    }
                    for (k = ip1; k < ncol; k++) {
                        U[j*ncol+k] += s * r[k];
                    }
                }
                for (k = ip1; k < ncol; k++) {
                    U[i*ncol+k] *= scale;
                }
            }
        }
        anorm = MAX(anorm, (fabs(W[i]) + fabs(r[i])));
    }

    /* accumulation of right-hand transformations */
    for (i = ncol-1; i >= 0; i--) {
        if (i < ncol-1) {
            if (g != 0) {
                for (j = ip1; j < ncol; j++) {
                    V[j*ncol+i] = (U[i*ncol+j] / U[i*ncol+ip1]) / g; /* avoid possible underflow */
                }
                for (j = ip1; j < ncol; j++) {
                    s = 0;
                    for (k = ip1; k < ncol; k++) {
                        s += U[i*ncol+k] * V[k*ncol+j];
                    }
                    for (k = ip1; k < ncol; k++) {
                        V[k*ncol+j] += s * V[k*ncol+i];
                    }
                }
            }
            for (j = ip1; j < ncol; j++) {
                V[i*ncol+j] = 0;
                V[j*ncol+i] = 0;
            }
        }
        V[i*ncol+i] = 1;
        g           = r[i];
        ip1         = i;
    }

    /* accumulation of left-side transformations */
    for (i = MIN(mrow, ncol)-1; i >= 0; i--) {
        ip1 = i + 1;
        g = W[i];
        for (j = ip1; j < ncol; j++) {
            U[i*ncol+j] = 0;
        }
        if (g != 0) {
            g = 1 / g;
            for (j = ip1; j < ncol; j++) {
                s = 0;
                for (k = ip1; k < mrow; k++) {
                    s += U[k*ncol+i] * U[k*ncol+j];
                }
                f = (s / U[i*ncol+i]) * g;
                for (k = i; k < mrow; k++) {
                    U[k*ncol+j] += f * U[k*ncol+i];
                }
            }
            for (j = i; j < mrow; j++) {
                U[j*ncol+i] *= g;
            }
        } else {
            for (j = i; j < mrow; j++) {
                U[j*ncol+i] = 0;
            }
        }
        ++U[i*ncol+i];
    }

    /* diagonalization of the bidiagonal form */

    /* loop over singular values */
    for (k = ncol-1; k >= 0; k--) {

        /* loop over allowed iterations */
        for (its = 0; its < 30; its++) {

            /* test for splitting */
            flag = 1;
            for (ip1 = k; ip1 >= 0; ip1--) {
                nm = ip1 - 1;

                if ((double)(fabs(r[ip1]) + anorm) == anorm) {
                    flag = 0;
                    break;
                }

                assert (nm >= 0);                 /* needed to avoid clang warning */
                assert (nm < ncol);               /* needed to avoid clang warning */

                if ((double)(fabs(W[nm]) + anorm) == anorm) break;
            }
            if (flag) {
                c = 0;
                s = 1;
                for (i = ip1; i < k+1; i++) {
                    f    = s * r[i];
                    r[i] = c * r[i];
                    if ((double)(fabs(f) + anorm) == anorm) break;
                    g    = W[i];
                    if (fabs(f) > fabs(g)) {
                        h = fabs(f) * sqrt(1 + (g/f) * (g/f));
                    } else if (fabs(g) == 0) {
                        h = 0;
                    } else {
                        h = fabs(g) * sqrt(1 + (f/g) * (f/g));
                    }
                    W[i] = h;
                    h    = 1 / h;
                    c    = g * h;
                    s    = -f * h;
                    for (j = 0; j < mrow; j++) {
                        yy           = U[j*ncol+nm];
                        zz           = U[j*ncol+i ];
                        U[j*ncol+nm] = yy * c + zz * s;
                        U[j*ncol+i ] = zz * c - yy * s;
                    }
                }
            }

            /* test for convergence */
            zz = W[k];
            if (ip1 == k) {

                /* make singular values non-negative */
                if (zz < 0) {
                    W[k] = -zz;
                    for (j = 0; j < ncol; j++) {
                        V[j*ncol+k] = -V[j*ncol+k];
                    }
                }
                break;
            }

            assert (ip1 >= 0);                    /* needed to avoid clang warning */
            assert (ip1 < ncol);                  /* needed to avoid clang warning */

            /* shift from bottom 2*2 minor */
            xx = W[ip1];
            nm = k - 1;
            yy = W[nm];
            g  = r[nm];
            h  = r[k];
            f  = ((yy - zz) * (yy + zz) + (g - h) * (g + h)) / (2 * h * yy);
            g  = sqrt(f * f + 1);
            f  = ((xx - zz) * (xx + zz) + h * ((yy / (f + FSIGN(g, f))) - h)) / xx;

            /* next QR transformation */
            c = 1;
            s = 1;
            for (j = ip1; j <= nm; j++) {
                i    = j + 1;
                g    = r[i];
                yy   = W[i];
                h    = s * g;
                g    = c * g;
                if (fabs(f) > fabs(h)) {
                    zz = fabs(f) * sqrt(1 + (h/f) * (h/f));
                } else if (fabs(h) == 0) {
                    zz = 0;
                } else {
                    zz = fabs(h) * sqrt(1 + (f/h) * (f/h));
                }
                r[j] = zz;
                c    = f / zz;
                s    = h / zz;
                f    = xx * c + g * s;
                g    = g * c - xx * s;
                h    = yy * s;
                yy  *= c;
                for (jj = 0; jj < ncol; jj++) {
                    xx           = V[jj*ncol+j];
                    zz           = V[jj*ncol+i];
                    V[jj*ncol+j] = xx * c + zz * s;
                    V[jj*ncol+i] = zz * c - xx * s;
                }
                if (fabs(f) > fabs(h)) {
                    zz = fabs(f) * sqrt(1 + (h/f) * (h/f));
                } else if (fabs(h) == 0) {
                    zz = 0;
                } else {
                    zz = fabs(h) * sqrt(1 + (f/h) * (f/h));
                }

                /* rotation can be arbitrary if zz=0 */
                W[j] = zz;
                if (zz != 0) {
                    zz = 1 / zz;
                    c  = f * zz;
                    s  = h * zz;
                }
                f  = c * g  + s * yy;
                xx = c * yy - s * g;
                for (jj = 0; jj < mrow; jj++) {
                    yy           = U[jj*ncol+j];
                    zz           = U[jj*ncol+i];
                    U[jj*ncol+j] = yy * c + zz * s;
                    U[jj*ncol+i] = zz * c - yy * s;
                }
            }
            r[ip1] = 0;
            r[k  ] = f;
            W[k  ] = xx;
        }
    }

    /* find the largest singular value (for scaling) */
    wmax = 0;
    for (jcol = 0; jcol < ncol; jcol++) {
        if (W[jcol] > wmax) {
            wmax = W[jcol];
        }
    }

    /* set all singular values less than wmin to zero */
    wmin = wmax * 1.0e-6;
    for (jcol = 0; jcol < ncol; jcol++) {
        if (W[jcol] < wmin) {
            W[jcol] = 0;
        }
    }

    /* perform the back-substitution */
    for (j = 0; j < ncol; j++) {
        s = 0;
        if (W[j] != 0) {
            for (i = 0; i < mrow; i++) {
                s += U[i*ncol+j] * b[i];
            }
            s /= W[j];
        }
        t[j] = s;
    }

    for (j = 0; j < ncol; j++) {
        s = 0;
        for (k = 0; k < ncol; k++) {
            s += V[j*ncol+k] * t[k];
        }
        x[j] = s;
    }

cleanup:
    FREE(t);
    FREE(r);
    FREE(V);
    FREE(U);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   tessellate - tessellate the current Body                           *
 *                                                                      *
 ************************************************************************
 */

static int
tessellate(modl_T *MODL,                /* (in)  pointer to MODL */
           int    ibody)                /* (in)  Body index (bias-1) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       itype, nlist, iface, iedge, oclass, mtype, mtype_face, nlup, ilup;
    int       npnt_edge, npnt_face, ntri_face, nedg, ii, ipnt, itri, nchild;
    int       npnt_egg, nbnd_egg, ntri_egg, nquad, state, npts, count;
    int       nbnd, lup[20], *senses, *tris_new=NULL;
    CINT      *tempIlist, *pindx, *ptype, *tris, *tric, *p_egg, *tris_egg;
    double    params[3], bbox[6], size, uvlims[4], data[18];
    double    *uv_new=NULL, *xyz_new=NULL;
    CDOUBLE   *tempRlist, *xyz_edge, *t_edge, *xyz_face, *uv_face, *uv_egg;
    CCHAR     *tempClist;
    void      *eggdata, *eggdata_new;
    modl_T    *BASE;
    ego       eref, *elups, *eedgs, *echilds, ebody, newBody, newTess;

    ROUTINE(tessellate);

    /* --------------------------------------------------------------- */

    BASE = MODL->basemodl;

    /* if the Body is a Node, return now */
    if (MODL->body[ibody].botype == OCSM_NODE_BODY) {
        goto cleanup;
    }

    /* if there is already a tessellation, return now */
    if (MODL->body[ibody].etess != NULL) {
        goto cleanup;
    }

    /* keep track of the number of Faces that are quadded */
    nquad = 0;

    /* set up the tessellation parameters.  if there are .tParams
       on this Body, use them */
    status = EG_attributeRet(MODL->body[ibody].ebody,
                             ".tParams", &itype, &nlist,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS && nlist == 3) {
        params[0] = tempRlist[0];
        params[1] = tempRlist[1];
        params[2] = tempRlist[2];

    /* otherwise, use the defaults based upon the size of the bounding box */
    } else {
        status = EG_getBoundingBox(MODL->body[ibody].ebody, bbox);
        CHECK_STATUS(EG_getBoundingBox);

        size = sqrt(SQR(bbox[3]-bbox[0]) + SQR(bbox[4]-bbox[1]) + SQR(bbox[5]-bbox[2]));

        params[0] = TESS_PARAM_0 * size;
        params[1] = TESS_PARAM_1 * size;
        params[2] = TESS_PARAM_2;
    }

    /* print tessellation parameters */
    SPRINT4(1, "--> Tessellating Body %6d     (%12.5e %12.5e %7.3f)",
            ibody, params[0], params[1], params[2]);

    /* this is a base (not perturbed) MODL */
    if (BASE == NULL) {

        /* start by using EGADS' tessellator so that the Node and Edges
           get properly tessellated */
        status = EG_makeTessBody(MODL->body[ibody].ebody, params,
                                 &(MODL->body[ibody].etess));
        CHECK_STATUS(EG_makeTessBody);

        /* overwrite the _tParams Attribute so that we know how the Body
           was tessellated */
        status = EG_attributeAdd(MODL->body[ibody].ebody, "_tParams", ATTRREAL,
                                 3, NULL, params, NULL);
        CHECK_STATUS(EG_attributeAdd);

        /* make new-style Quads (whole Body) if Attribute is set on the Body */
        status = EG_attributeRet(MODL->body[ibody].ebody,
                                 "_makeQuads", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS) {
            status = EG_quadTess(MODL->body[ibody].etess, &newTess);
            if (status == SUCCESS) {
                EG_deleteObject(MODL->body[ibody].etess);

                MODL->body[ibody].etess = newTess;
            } else {
                status = SUCCESS;
            }
        } else {
            status = SUCCESS;
        }

        /* make old-style Quads (on a Face) if Attribute is set on the Face */
        params[0] = 0;
        params[1] = 0;
        params[2] = 0;
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_attributeRet(MODL->body[ibody].face[iface].eface,
                                     "_makeQuads", &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS) {
                status = EG_makeQuads(MODL->body[ibody].etess, params, iface);
                if (status == SUCCESS) {
                    nquad++;
                }
            } else {
                status = SUCCESS;
            }
        }
        if (nquad > 0 && nquad < MODL->body[ibody].nface) {
            SPRINT3(1, "WARNING:: only %d of %d Faces were quadded for Body %d",
                    nquad, MODL->body[ibody].nface, ibody);
            (MODL->nwarn)++;
        }

        /* find the minimum number of points in any Face tessellation */
        count = 0;
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                    &ntri_face, &tris, &tric);
            CHECK_STATUS(EG_getTessface);

            if (npnt_face <= 0) count++;
        }

        /* there is an external grid generator */
        if (STRLEN(MODL->eggname) > 0 && count > 0) {
            SPRINT3(1, "WARNING:: external tessellator skipped for Body %d because %d of %d Faces were not tessellated",
                    ibody, count, MODL->body[ibody].nface);
            (MODL->nwarn)++;

        } else if (STRLEN(MODL->eggname) > 0) {

            /* open the current tessellation for editing */
            status = EG_openTessBody(MODL->body[ibody].etess);
            CHECK_STATUS(EG_openTessBody);

            /* loop through each face and make an alternative tessellation */
            for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {

                /* get the EGADS tessellation */
                status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                        &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                        &ntri_face, &tris, &tric);
                CHECK_STATUS(EG_getTessface);

                /* set up the Loop information */
                status = EG_getTopology(MODL->body[ibody].face[iface].eface, &eref,
                                        &oclass, &mtype_face, uvlims, &nlup, &elups, &senses);
                CHECK_STATUS(EG_getTopology);

                nbnd = 0;
                for (ilup = 0; ilup < nlup; ilup++) {
                    lup[ilup] = 0;

                    status = EG_getTopology(elups[ilup], &eref,
                                            &oclass, &mtype, uvlims, &nedg, &eedgs, &senses);
                    CHECK_STATUS(EG_getTopology);

                    for (ii = 0; ii < nedg; ii++) {
                        iedge = EG_indexBodyTopo(MODL->body[ibody].ebody, eedgs[ii]);

                        status = EG_getTopology(eedgs[ii], &eref, &oclass, &mtype,
                                               data, &nchild, &echilds, &senses);
                        CHECK_STATUS(EG_getTopology);

                        /* degenerate Edge has 2 Points, but only one of them
                           is in the Loop */
                        if (mtype == DEGENERATE) continue;

                        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                                &npnt_edge, &xyz_edge, &t_edge);
                        CHECK_STATUS(eg_getTessEdge);

                        lup[ilup] += (npnt_edge - 1);
                    }
                    nbnd += lup[ilup];
                }

                lup[nlup] = 0;

                /* if all the points are Boundary Nodes, there are no Nodes
                   that are internal to the Face that need to be generated */
                if (nbnd == npnt_face) continue;

                /* get enough space to hold the Boundary points */
                MALLOC(uv_new, double, 2*npnt_face);

                /* set up boundary points */
                for (ipnt = 0; ipnt < nbnd; ipnt++) {
                    uv_new[2*ipnt  ] = uv_face[2*ipnt  ];
                    uv_new[2*ipnt+1] = uv_face[2*ipnt+1];
                }

                /* generate the new grid */
                status = MODL->eggGenerate(uv_new, lup, &eggdata);
                /* CHECK_STATUS below */

                FREE(uv_new);

                /* if a successful tessellation, put the tessellation info into
                   EGADS etess object */
                if (status == SUCCESS) {
                    status = MODL->eggInfo(eggdata, &npnt_egg, &nbnd_egg, &uv_egg, &p_egg,
                                           &ntri_egg, &tris_egg);
                    CHECK_STATUS(eggInfo);

                    SPRINT5(1, "WARNING:: using eggGenerate for Face %3d:%-5d  (npnt=%5d, nbnd=%5d, ntri=%5d)",
                            ibody, iface, npnt_egg, nbnd_egg, ntri_egg);
                    (MODL->nwarn)++;

                    MALLOC(uv_new,   double, 2*npnt_egg);
                    MALLOC(xyz_new,  double, 3*npnt_egg);
                    MALLOC(tris_new, int,    3*ntri_egg);

                    for (ipnt = 0; ipnt < nbnd_egg; ipnt++) {
                        uv_new[ 2*ipnt  ] = uv_face[ 2*ipnt  ];
                        uv_new[ 2*ipnt+1] = uv_face[ 2*ipnt+1];
                        xyz_new[3*ipnt  ] = xyz_face[3*ipnt  ];
                        xyz_new[3*ipnt+1] = xyz_face[3*ipnt+1];
                        xyz_new[3*ipnt+2] = xyz_face[3*ipnt+2];
                    }

                    for (ipnt = nbnd_egg; ipnt < npnt_egg; ipnt++) {
                        uv_new[2*ipnt  ] = uv_egg[2*ipnt  ];
                        uv_new[2*ipnt+1] = uv_egg[2*ipnt+1];

                        status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                             &(uv_new[2*ipnt]), data);
                        CHECK_STATUS(EG_evaluate);

                        xyz_new[3*ipnt  ] = data[0];
                        xyz_new[3*ipnt+1] = data[1];
                        xyz_new[3*ipnt+2] = data[2];
                    }

                    if (mtype_face == SFORWARD) {
                        for (itri = 0; itri < ntri_egg; itri++) {
                            tris_new[3*itri  ] = tris_egg[3*itri  ] + 1;
                            tris_new[3*itri+1] = tris_egg[3*itri+1] + 1;
                            tris_new[3*itri+2] = tris_egg[3*itri+2] + 1;
                        }
                    } else {
                        for (itri = 0; itri < ntri_egg; itri++) {
                            tris_new[3*itri  ] = tris_egg[3*itri+2] + 1;
                            tris_new[3*itri+1] = tris_egg[3*itri+1] + 1;
                            tris_new[3*itri+2] = tris_egg[3*itri  ] + 1;
                        }
                    }

                    status = EG_setTessFace(MODL->body[ibody].etess, iface,
                                            npnt_egg, xyz_new, uv_new,
                                            ntri_egg, tris_new);
                    CHECK_STATUS(EG_setTessFace);

                    FREE(tris_new);
                    FREE(uv_new  );
                    FREE(xyz_new );

                    /* remember the new egg data */
                    MODL->body[ibody].face[iface].eggdata = (void*) eggdata;

                /* unsuccessful external tessellator */
                } else {
                    SPRINT2(1, "WARNING:: external tessellator skipped for Face %d:%d", ibody, iface);
                    SPRINT0(1, "          reverting to EGADS");
                    (MODL->nwarn)++;

                    status = MODL->eggFree(eggdata);
                    CHECK_STATUS(eggFree);
                }
            }

            /* cheking the status of the etess closes it */
            status = EG_statusTessBody(MODL->body[ibody].etess, &ebody, &state, &npts);
            CHECK_STATUS(EG_statusTessBody);
        }

        /* print out bounding box info if a Face contains no Triangles */
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                    &ntri_face, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            if (ntri_face <= 0) {
                status = EG_getBoundingBox(MODL->body[ibody].face[iface].eface, bbox);
                CHECK_STATUS(EG_getBoundingBox);

                SPRINT4(1, "WARNING:: Face %3d:%-4d has no triangles,  %12.4f <= x <= %12.4f", ibody, iface, bbox[0], bbox[3]);
                SPRINT2(1, "                                           %12.4f <= y <= %12.4f",               bbox[1], bbox[4]);
                SPRINT2(1, "                                           %12.4f <= z <= %12.4f",               bbox[2], bbox[5]);
                (MODL->nwarn)++;

#ifdef GRAFIC
                {
                    int io_kbd=5, io_scr=6, indgr=1+2+4+16+64, isymb=0;
                    char  pltitl[80];

                    grinit_(&io_kbd, &io_scr, "plotTile", STRLEN("plotTile"));

                    sprintf(pltitl, "~u~v~Face %d:%d", ibody, iface);
                    grctrl_(plotFace, &indgr, pltitl,
                            (void*)(MODL),
                            (void*)(&ibody),
                            (void*)(&iface),
                            (void*)(&isymb),
                            (void*)NULL,
                            (void*)NULL,
                            (void*)NULL,
                            (void*)NULL,
                            (void*)NULL,
                            (void*)NULL,
                            STRLEN(pltitl));
                }
#endif
            }
        }

    /* this is a perturbed MODL */
    } else {

        /* map BASE ibody's tessellation onto the current MODL ibody */
        if (BASE->body[ibody].etess != NULL) {
            if (MODL->body[ibody].etess == NULL) {

                /* check if the body needs to be mapped */
                status = EG_attributeRet(MODL->body[ibody].ebody,
                                         "__mapBody__", &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status != EGADS_SUCCESS) {
                    status = EG_mapBody(BASE->body[ibody].ebody, MODL->body[ibody].ebody,
                                        "_faceID", &newBody);
                    if (status == SUCCESS && newBody != NULL) {
                        EG_deleteObject(MODL->body[ibody].ebody);
                        MODL->body[ibody].ebody = newBody;

                        status = finishBody(MODL,ibody);
                        CHECK_STATUS(finishBody);
                    }

                    /* tag that the body has been mapped */
                    status = EG_attributeAdd(MODL->body[ibody].ebody, "__mapBody__", ATTRINT,
                                             1, &ibody, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }

                status = EG_mapTessBody(BASE->body[ibody].etess, MODL->body[ibody].ebody,
                                        &(MODL->body[ibody].etess));
                CHECK_STATUS(EG_mapTessBody);
            }
        }

        /* if there is a registered external grid generator, edit the tessellation
           that was made above */
        if (STRLEN(BASE->eggname) > 0 && MORPH_GRID == 1) {

            /* open the current tessellation for editing */
            status = EG_openTessBody(MODL->body[ibody].etess);
            CHECK_STATUS(EG_openTessBody);

            for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                eggdata = BASE->body[ibody].face[iface].eggdata;

                /* call the external grid generator to put the
                   morphed tessellation onto the Faces of the ptrb Body */
                if (eggdata != NULL) {
                    status = BASE->eggInfo(eggdata, &npnt_egg, &nbnd_egg, &uv_egg, &p_egg,
                                           &ntri_egg, &tris_egg);
                    CHECK_STATUS(eggInfo);

                    SPRINT5(1, "WARNING:: using eggMorph for Face %3d:%-5d  (npnt=%5d, nbnd=%5d, ntri=%5d)",
                            ibody, iface, npnt_egg, nbnd_egg, ntri_egg);
                    (MODL->nwarn)++;

                    status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                            &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                            &ntri_face, &tris, &tric);
                    CHECK_STATUS(EG_getTessFace);

                    MALLOC(xyz_new, double, 3*npnt_egg);
                    MALLOC(uv_new,  double, 2*npnt_egg);

                    for (ipnt = 0; ipnt < nbnd_egg; ipnt++) {
                        uv_new[ 2*ipnt  ] = uv_face[ 2*ipnt ];
                        uv_new[ 2*ipnt+1] = uv_face[ 2*ipnt+1];
                        xyz_new[3*ipnt  ] = xyz_face[3*ipnt  ];
                        xyz_new[3*ipnt+1] = xyz_face[3*ipnt+1];
                        xyz_new[3*ipnt+2] = xyz_face[3*ipnt+2];
                    }

                    status = BASE->eggMorph(eggdata, uv_new, &eggdata_new);
                    CHECK_STATUS(eggMorph);

                    status = BASE->eggFree(eggdata_new);
                    CHECK_STATUS(eggFree);

                    for (ipnt = nbnd_egg; ipnt < npnt_egg; ipnt++) {
                        status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                             &(uv_new[2*ipnt]), data);
                        CHECK_STATUS(EG_evaluate);

                        xyz_new[3*ipnt  ] = data[0];
                        xyz_new[3*ipnt+1] = data[1];
                        xyz_new[3*ipnt+2] = data[2];
                    }

                    status = EG_setTessFace(MODL->body[ibody].etess, iface,
                                            npnt_face, xyz_new, uv_new,
                                            ntri_face, tris);
                    CHECK_STATUS(EG_setTessFace);

                    FREE(xyz_new);
                    FREE(uv_new);
                }
            }

            /* cheking the status of the etess closes it */
            status = EG_statusTessBody(MODL->body[ibody].etess, &ebody, &state, &npts);
            CHECK_STATUS(EG_statusTessBody);

            SPRINT1(1, "--> EG_statusTessBody -> status=%d", status);
        }
    }

    /* if there were no quads, create the global IDs */
    if (nquad == 0) {
        MODL->body[ibody].npnts = MODL->body[ibody].nnode;
        MODL->body[ibody].ntris = 0;

        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            MODL->body[ibody].edge[iedge].globid = MODL->body[ibody].npnts - 1;

            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt_edge, &xyz_edge, &t_edge);
            CHECK_STATUS(EG_getTessEdge);

            MODL->body[ibody].npnts += (npnt_edge-2);
        }

        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                    &ntri_face, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                if (ptype[ipnt] < 0) {
                    MODL->body[ibody].face[iface].globid = MODL->body[ibody].npnts - ipnt + 1;
                    MODL->body[ibody].npnts += (npnt_face - ipnt);
                    break;
                }
            }

            MODL->body[ibody].ntris += ntri_face;
        }

    /* otherwise (there are quads), so initialize global IDs to zero */
    } else {
        MODL->body[ibody].npnts = 0;
        MODL->body[ibody].ntris = 0;

        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            MODL->body[ibody].edge[iedge].globid = 0;
        }
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            MODL->body[ibody].face[iface].globid = 0;
        }
    }

cleanup:
    FREE(uv_new);
    FREE(xyz_new);
    FREE(tris_new);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   velocityOfEdge - compute Edge velocities analytically              *
 *                                                                      *
 ************************************************************************
 */

int
velocityOfEdge(modl_T *MODL,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (bias-1) */
               int    iedge,            /* (in)  Edge index (bias-1) */
               int    npnt,             /* (in)  number of points */
     /*@null@*/double t[],              /* (in)  para coords ( npnt in length) */
               double dxyz[])           /* (out) velocities (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       jedge, kedge, ipnt, jbody, kbody, jbrch, npnt_tess, ileft, irite, iarg, nchange;
    int       atype, alen, i;
    CINT      *tempIlistI, *tempIlistJ, *tempIlist;
    double    tt, uvleft[6], uvrite[6], dxyzleft[3], dxyzrite[3], xyzleft[18], xyzrite[18];
    double    normleft[4], normrite[4], A[9], b[3];
    double    data[18], data_dot[18], data2[3], mat[12], ubar, vbar, wbar;
    double    dx, dy, dz, num, numdot, den, dendot;
    double    xbeg, xbegdot, ybeg, ybegdot, zbeg, zbegdot;
    double    xend, xenddot, yend, yenddot, zend, zenddot;
    double    xbase, xbasedot, ybase, ybasedot, zbase, zbasedot;
    double    xvrtx, xvrtxdot, yvrtx, yvrtxdot, zvrtx, zvrtxdot, rad, raddot;
    double    tht, thtdot, phi, phidot, len, lendot, psi, psidot;
    double    x1, x1dot, y1, y1dot, z1, z1dot;
    double    x2, x2dot, y2, y2dot, z2, z2dot;
    double    x3, x3dot, y3, y3dot, z3, z3dot;
    double    x4, x4dot, y4, y4dot, z4, z4dot;
    double    x5, x5dot, r5, r5dot, t5, t5dot, s5, s5dot;
    double    perm[9];
    double    *ts=NULL, *xyz_pnt=NULL;
    CDOUBLE   *xyz_tess, *t_tess, *tempRlist;
    CCHAR     *tempClist;
#ifndef EDGE_HIST_TRANSFORM
    int       nfaces;
    ego       *efaces;
#else
    int       oclass, mtype, nchild, *senses, ktgt;
    double    scale;
    ego       eref, *echilds, rgeom;
#endif

    int         ibrch, udp_num, *udp_types, *udp_idef, needfd;
    double      *udp_ddef;
    char        **udp_names, primtype[MAX_EXPR_LEN];

    ROUTINE(velocityOfEdge);

    /* --------------------------------------------------------------- */

    SPRINT3(2, " -> velocityOfEdge(ibody=%d, iedge=%d, npnt=%d)", ibody, iedge, npnt);

    if        (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    } else if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
        status = OCSM_EDGE_NOT_FOUND;
        goto cleanup;
    }

    /* if this is a degenerate Edge, return zero velocities */
    if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] = 0;
            dxyz[3*ipnt+1] = 0;
            dxyz[3*ipnt+2] = 0;
        }

        goto cleanup;
    }

    /* if there is an active perturbation, get velocity by finite
       differences */
    if (MODL->perturb != NULL) {
        status = finiteDifference(MODL, ibody, OCSM_EDGE, iedge, npnt, t, dxyz);
        CHECK_STATUS(finiteDifference);

        goto cleanup;
    }

    /* jbody is the Body in which this Edge first appeared */
    jbody = MODL->body[ibody].edge[iedge].ibody;
    jbrch = MODL->body[jbody].ibrch;

    /* find the Edge in jbody that maps to Edge iedge in ibody */
    if (jbody == ibody) {
        jedge = iedge;
    /* non-manifold --- assume same as parent */
    } else if (MODL->body[ibody].edge[iedge].iford == -3) {
        jedge = iedge;
    } else {
        status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_edgeID",
                                 &atype, &alen, &tempIlistI, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        jedge = -1;

        /* try matching _edgeID, including iseq */
        for (kedge = 1; kedge <= MODL->body[jbody].nedge; kedge++) {
            status = EG_attributeRet(MODL->body[jbody].edge[kedge].eedge, "_edgeID",
                                     &atype, &alen, &tempIlistJ, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);

            if (tempIlistI[0] == tempIlistJ[0] &&
                tempIlistI[1] == tempIlistJ[1] &&
                tempIlistI[2] == tempIlistJ[2] &&
                tempIlistI[3] == tempIlistJ[3] &&
                tempIlistI[4] == tempIlistJ[4]   ) {
                jedge = kedge;
                break;
            }
        }

        /* if that diddn't work, try matching _edgeID, ignoring iseq */
        if (jedge == -1) {
            for (kedge = 1; kedge <= MODL->body[jbody].nedge; kedge++) {
                status = EG_attributeRet(MODL->body[jbody].edge[kedge].eedge, "_edgeID",
                                         &atype, &alen, &tempIlistJ, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlistI[0] == tempIlistJ[0] &&
                    tempIlistI[1] == tempIlistJ[1] &&
                    tempIlistI[2] == tempIlistJ[2] &&
                    tempIlistI[3] == tempIlistJ[3]   ) {
                    jedge = kedge;
                    break;
                }
            }
        }
    }

    SPRINT2(2, "        maps to jbody=%d, jedge=%d", jbody, jedge);

    /* if the Edge has velocities, get them and then transform them to ibody */
    if ((MODL->body[jbody].brtype == OCSM_RULE ||
         MODL->body[jbody].brtype == OCSM_BLEND  ) && jedge > 0) {

        /* find the transformation matrix which is required
           to track a point from its location in ibody back to
           its corresponding location in jbody */
        status = xformToOriginal(MODL, ibody, jbody, mat);
        CHECK_STATUS(xformToOriginal);

        /* get the tessellation points */
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt_tess, &xyz_tess, &t_tess);
        CHECK_STATUS(EG_getTessEdge);

        if (t == NULL) {
            assert(npnt == npnt_tess);
        } else {
            npnt_tess = npnt;
        }

        MALLOC(xyz_pnt, double, 3*npnt);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            if (t == NULL) {
                tt = t_tess[ipnt];

                xyz_pnt[3*ipnt  ] = xyz_tess[3*ipnt  ] * mat[ 0]
                                  + xyz_tess[3*ipnt+1] * mat[ 1]
                                  + xyz_tess[3*ipnt+2] * mat[ 2] + mat[ 3];
                xyz_pnt[3*ipnt+1] = xyz_tess[3*ipnt  ] * mat[ 4]
                                  + xyz_tess[3*ipnt+1] * mat[ 5]
                                  + xyz_tess[3*ipnt+2] * mat[ 6] + mat[ 7];
                xyz_pnt[3*ipnt+2] = xyz_tess[3*ipnt  ] * mat[ 8]
                                  + xyz_tess[3*ipnt+1] * mat[ 9]
                                  + xyz_tess[3*ipnt+2] * mat[10] + mat[11];
            } else {
                tt = t[ipnt];
                status = EG_evaluate(MODL->body[jbody].edge[jedge].eedge, &tt, data);
                CHECK_STATUS(EG_evaluate);

                xyz_pnt[3*ipnt  ] = data[0];
                xyz_pnt[3*ipnt+1] = data[1];
                xyz_pnt[3*ipnt+2] = data[2];
            }

            if (EG_hasGeometry_dot(MODL->body[jbody].edge[jedge].eedge) == EGADS_SUCCESS) {

                /* evaluate the sensitivity (in jbody) */
                status = EG_evaluate_dot(MODL->body[jbody].edge[jedge].eedge, &tt, NULL, data, data_dot);
                CHECK_STATUS(EG_evaluate_dot);

                dxyz[3*ipnt  ] = data_dot[0];
                dxyz[3*ipnt+1] = data_dot[1];
                dxyz[3*ipnt+2] = data_dot[2];
            } else {

                dxyz[3*ipnt  ] = 0;
                dxyz[3*ipnt+1] = 0;
                dxyz[3*ipnt+2] = 0;
            }
        }

#ifndef EDGE_HIST_TRANSFORM
        /* find the history for one of the adjoining Faces */
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].edge[iedge].eedge, FACE,
                                 &nfaces, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_attributeRet(efaces[0], "_hist", &atype, &alen,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        EG_free(efaces);
#else
        /* use the history of the edge to transform velocities */
        status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_hist", &atype, &alen,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);
#endif

        /* transform the velocities */
        for (i = 0; i < alen; i++) {
            if (tempIlist[i] > jbody) {
                status = xformVelocity(MODL, tempIlist[i], npnt_tess, xyz_pnt, npnt, dxyz);
                CHECK_STATUS(xformVelocity);
            }
        }

        goto cleanup;
    }

#ifndef EDGE_HIST_TRANSFORM
    /* if the Edge is supported by only one Face, get the velocity
       from the Face */
    if (MODL->body[ibody].edge[iedge].nface == 1) {
        ileft = abs(MODL->body[ibody].edge[iedge].ileft);
        /* if t==NULL, then we need to get tessellation info for iedge */
        if (t == NULL) {
            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt_tess, &xyz_tess, &t_tess);
            CHECK_STATUS(EG_getTessEdge);

            if (npnt != npnt_tess) {
                status = OCSM_ILLEGAL_ARGUMENT;
                goto cleanup;
            }
        }

        SPRINT2(2, "        getting Edge velocity from Face %d:%d", ibody, ileft);
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            if (t == NULL) {
                tt = t_tess[ipnt];
            } else {
                tt = t[ipnt];
            }

            status = EG_getEdgeUVeval(MODL->body[ibody].face[ileft].eface,
                                      MODL->body[ibody].edge[iedge].eedge, 0, tt, uvleft);
            CHECK_STATUS(EG_getEdgeUVeval);

            status = velocityOfFace(MODL, ibody, ileft, 1, uvleft, dxyzleft);
            CHECK_STATUS(velocityOfFace);

            dxyz[3*ipnt  ] = dxyzleft[0];
            dxyz[3*ipnt+1] = dxyzleft[1];
            dxyz[3*ipnt+2] = dxyzleft[2];
        }

        goto cleanup;
    }
#endif

//$$$    /* if the Edge can about because of a scribe (SUBTRACT), the
//$$$       velocity can be obtained from Face and scribing velocities */
//$$$    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "__scribeID__",
//$$$                             &atype, &alen, &tempIlist, &tempRlist, &tempClist);
//$$$    printf("status=%d\n", status);
//$$$    if (status == EGADS_SUCCESS) {
//$$$        ileft = MODL->body[ibody].edge[iedge].ileft;
//$$$        jbody = tempIlist[0];
//$$$        irite = tempIlist[1];
//$$$
//$$$        /* if t==NULL, then we need to get tessellation info for iedge */
//$$$        if (t == NULL) {
//$$$            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
//$$$                                    &npnt_tess, &xyz_tess, &t_tess);
//$$$            CHECK_STATUS(EG_getTessEdge);
//$$$
//$$$            if (npnt != npnt_tess) {
//$$$                status = OCSM_ILLEGAL_ARGUMENT;
//$$$                goto cleanup;
//$$$            }
//$$$        }
//$$$
//$$$        for (ipnt = 0; ipnt < npnt; ipnt++) {
//$$$            if (t == NULL) {
//$$$                tt = t_tess[ipnt];
//$$$            } else {
//$$$                tt = t[ipnt];
//$$$            }
//$$$            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
//$$$                                 &tt, data);
//$$$            CHECK_STATUS(EG_evaluate);
//$$$
//$$$            /* velocity of left Face */
//$$$            status = EG_getEdgeUVeval(MODL->body[ibody].face[ileft].eface,
//$$$                                      MODL->body[ibody].edge[iedge].eedge, 0, tt, uvleft);
//$$$            CHECK_STATUS(EG_getEdgeUVeval);
//$$$
//$$$            status = velocityOfFace(MODL, ibody, ileft, 1, uvleft, dxyzleft);
//$$$            CHECK_STATUS(velocityOfFace);
//$$$
//$$$            /* velocity of rite Face */
//$$$            status = EG_invEvaluate(MODL->body[jbody].face[irite].eface, data, uvrite, xyzrite);
//$$$            CHECK_STATUS(EG_invEvaluate);
//$$$
//$$$            status = velocityOfFace(MODL, jbody, irite, 1, uvrite, dxyzrite);
//$$$            CHECK_STATUS(velocityOfFace);
//$$$        }
//$$$
//$$$        /* left Face normal */
//$$$        status = EG_evaluate(MODL->body[ibody].face[ileft].eface, uvleft, xyzleft);
//$$$        CHECK_STATUS(EG_evaluate);
//$$$
//$$$        normleft[0] = xyzleft[4] * xyzleft[8] - xyzleft[5] * xyzleft[7];
//$$$        normleft[1] = xyzleft[5] * xyzleft[6] - xyzleft[3] * xyzleft[8];
//$$$        normleft[2] = xyzleft[3] * xyzleft[7] - xyzleft[4] * xyzleft[6];
//$$$        normleft[3] = sqrt(normleft[0]*normleft[0] + normleft[1]*normleft[1] + normleft[2]*normleft[2]);
//$$$
//$$$        /* rite Face normal */
//$$$        status = EG_evaluate(MODL->body[jbody].face[irite].eface, uvrite, xyzrite);
//$$$        CHECK_STATUS(EG_evaluate);
//$$$
//$$$        normrite[0] = xyzrite[4] * xyzrite[8] - xyzrite[5] * xyzrite[7];
//$$$        normrite[1] = xyzrite[5] * xyzrite[6] - xyzrite[3] * xyzrite[8];
//$$$        normrite[2] = xyzrite[3] * xyzrite[7] - xyzrite[4] * xyzrite[6];
//$$$        normrite[3] = sqrt(normrite[0]*normrite[0] + normrite[1]*normrite[1] + normrite[2]*normrite[2]);
//$$$
//$$$        /* find a common velocity that is consistent with the
//$$$           normal velocities of the left and rite Face */
//$$$        A[0] = normleft[0];
//$$$        A[1] = normleft[1];
//$$$        A[2] = normleft[2];
//$$$        b[0] = normleft[0] * dxyzleft[0] + normleft[1] * dxyzleft[1] + normleft[2] * dxyzleft[2];
//$$$
//$$$        A[3] = normrite[0];
//$$$        A[4] = normrite[1];
//$$$        A[5] = normrite[2];
//$$$        b[1] = normrite[0] * dxyzrite[0] + normrite[1] * dxyzrite[1] + normrite[2] * dxyzrite[2];
//$$$
//$$$        A[6] = data[3];
//$$$        A[7] = data[4];
//$$$        A[8] = data[5];
//$$$        b[2] = 0;
//$$$
//$$$        status = matsol(A, b, 3, &(dxyz[3*ipnt]));
//$$$        if (status < 0) {
//$$$            SPRINT0(1, "WARNING:: singular matrix detected.  setting vel=0");
//$$$            SPRINT3(1, "ibody=%d,  ileft=%d,  irite=%d", ibody,       ileft,       irite);
//$$$            SPRINT3(1, "xyzleft   %10.4f %10.4f %10.4f", xyzleft[0],  xyzleft[1],  xyzleft[2]);
//$$$            SPRINT3(1, "xyzrite   %10.4f %10.4f %10.4f", xyzrite[0],  xyzrite[1],  xyzrite[2]);
//$$$            SPRINT3(1, "normleft  %10.4f %10.4f %10.4f", normleft[0], normleft[1], normleft[2]);
//$$$            SPRINT3(1, "normrite  %10.4f %10.4f %10.4f", normrite[0], normrite[1], normrite[2]);
//$$$            SPRINT3(1, "dxyzleft  %10.4f %10.4f %10.4f", dxyzleft[0], dxyzleft[1], dxyzleft[2]);
//$$$            SPRINT3(1, "dxyzrite  %10.4f %10.4f %10.4f", dxyzrite[0], dxyzrite[1], dxyzrite[2]);
//$$$            dxyz[3*ipnt  ] = 0;
//$$$            dxyz[3*ipnt+1] = 0;
//$$$            dxyz[3*ipnt+2] = 0;
//$$$            status = EGADS_SUCCESS;
//$$$        }
//$$$
//$$$        goto cleanup;
//$$$    }

    /* if the Edge was generated by an OCSM_BOOLEAN or an OCSM_GROWN,
       the velocity can be obtained from Face velocities */
    if (MODL->brch[jbrch].bclass == OCSM_BOOLEAN ||
        MODL->brch[jbrch].bclass == OCSM_GROWN    ) {

        ileft = MODL->body[ibody].edge[iedge].ileft;
        irite = MODL->body[ibody].edge[iedge].irite;

        /* if t==NULL, then we need to get tessellation info for iedge */
        if (t == NULL) {
            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt_tess, &xyz_tess, &t_tess);
            CHECK_STATUS(EG_getTessEdge);

            if (npnt != npnt_tess) {
                status = OCSM_ILLEGAL_ARGUMENT;
                goto cleanup;
            }
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            if (t == NULL) {
                tt = t_tess[ipnt];
            } else {
                tt = t[ipnt];
            }
            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                 &tt, data);
            CHECK_STATUS(EG_evaluate);

            /* velocity of left Face */
            if (ileft > 0) {
                status = EG_getEdgeUVeval(MODL->body[ibody].face[ileft].eface,
                                          MODL->body[ibody].edge[iedge].eedge, 0, tt, uvleft);
                CHECK_STATUS(EG_getEdgeUVeval);

                status = velocityOfFace(MODL, ibody, ileft, 1, uvleft, dxyzleft);
                CHECK_STATUS(velocityOfFace);
            }

            /* velocity of rite Face */
            if (irite > 0) {
                status = EG_getEdgeUVeval(MODL->body[ibody].face[irite].eface,
                                          MODL->body[ibody].edge[iedge].eedge, 0, tt, uvrite);
                CHECK_STATUS(EG_getEdgeUVeval);

                status = velocityOfFace(MODL, ibody, irite, 1, uvrite, dxyzrite);
                CHECK_STATUS(velocityOfFace);
            }

            /* if both ileft and irite are non-positive, returned velocity is 0 */
            if (ileft <= 0 && irite <= 0) {
                dxyz[3*ipnt  ] = 0;
                dxyz[3*ipnt+1] = 0;
                dxyz[3*ipnt+2] = 0;

            /* if irite <= 0, just use left velocity */
            } else if (irite <= 0) {
                dxyz[3*ipnt  ] = dxyzleft[0];
                dxyz[3*ipnt+1] = dxyzleft[1];
                dxyz[3*ipnt+2] = dxyzleft[2];

            /* if ileft <= 0, just use rite velocity */
            } else if (ileft <= 0) {
                dxyz[3*ipnt  ] = dxyzrite[0];
                dxyz[3*ipnt+1] = dxyzrite[1];
                dxyz[3*ipnt+2] = dxyzrite[2];

            /* if all velocities are 0, then returned velocity is 0 too */
            } else if (fabs(dxyzleft[0]) < EPS06 &&
                       fabs(dxyzleft[1]) < EPS06 &&
                       fabs(dxyzleft[2]) < EPS06 &&
                       fabs(dxyzrite[0]) < EPS06 &&
                       fabs(dxyzrite[1]) < EPS06 &&
                       fabs(dxyzrite[2]) < EPS06   ) {
                dxyz[3*ipnt  ] = 0;
                dxyz[3*ipnt+1] = 0;
                dxyz[3*ipnt+2] = 0;

            /* otherwise find a combination of the Face velocities */
            } else {

                /* left Face normal */
                status = EG_evaluate(MODL->body[ibody].face[ileft].eface, uvleft, xyzleft);
                CHECK_STATUS(EG_evaluate);

                normleft[0] = xyzleft[4] * xyzleft[8] - xyzleft[5] * xyzleft[7];
                normleft[1] = xyzleft[5] * xyzleft[6] - xyzleft[3] * xyzleft[8];
                normleft[2] = xyzleft[3] * xyzleft[7] - xyzleft[4] * xyzleft[6];
                normleft[3] = sqrt(normleft[0]*normleft[0] + normleft[1]*normleft[1] + normleft[2]*normleft[2]);

                /* rite Face normal */
                status = EG_evaluate(MODL->body[ibody].face[irite].eface, uvrite, xyzrite);
                CHECK_STATUS(EG_evaluate);

                normrite[0] = xyzrite[4] * xyzrite[8] - xyzrite[5] * xyzrite[7];
                normrite[1] = xyzrite[5] * xyzrite[6] - xyzrite[3] * xyzrite[8];
                normrite[2] = xyzrite[3] * xyzrite[7] - xyzrite[4] * xyzrite[6];
                normrite[3] = sqrt(normrite[0]*normrite[0] + normrite[1]*normrite[1] + normrite[2]*normrite[2]);

                /* just use face velocity if normleft and normrite are parallel */
                if (fabs(normleft[1]*normrite[2]-normleft[2]*normrite[1]) < EPS12*normleft[3]*normrite[3] &&
                    fabs(normleft[2]*normrite[0]-normleft[0]*normrite[2]) < EPS12*normleft[3]*normrite[3] &&
                    fabs(normleft[0]*normrite[1]-normleft[1]*normrite[0]) < EPS12*normleft[3]*normrite[3]   ) {
                    dxyz[3*ipnt  ] = dxyzleft[0];
                    dxyz[3*ipnt+1] = dxyzleft[1];
                    dxyz[3*ipnt+2] = dxyzleft[2];

                /* just use rite Face velocity if normleft is zero */
                } else if (fabs(normleft[0]) < EPS06 &&
                           fabs(normleft[1]) < EPS06 &&
                           fabs(normleft[2]) < EPS06   ) {
                    dxyz[3*ipnt  ] = dxyzrite[0];
                    dxyz[3*ipnt+1] = dxyzrite[1];
                    dxyz[3*ipnt+2] = dxyzrite[2];

                /* just use left Face velocity if normrite is zero */
                } else if (fabs(normrite[0]) < EPS06 &&
                           fabs(normrite[1]) < EPS06 &&
                           fabs(normrite[2]) < EPS06   ) {
                    dxyz[3*ipnt  ] = dxyzleft[0];
                    dxyz[3*ipnt+1] = dxyzleft[1];
                    dxyz[3*ipnt+2] = dxyzleft[2];

                /* find a common velocity that is consistent with the
                   normal velocities of the left and rite Face */
                } else {
                    A[0] = normleft[0];
                    A[1] = normleft[1];
                    A[2] = normleft[2];
                    b[0] = normleft[0] * dxyzleft[0] + normleft[1] * dxyzleft[1] + normleft[2] * dxyzleft[2];

                    A[3] = normrite[0];
                    A[4] = normrite[1];
                    A[5] = normrite[2];
                    b[1] = normrite[0] * dxyzrite[0] + normrite[1] * dxyzrite[1] + normrite[2] * dxyzrite[2];

                    A[6] = data[3];
                    A[7] = data[4];
                    A[8] = data[5];
                    b[2] = 0;

                    status = matsol(A, b, 3, &(dxyz[3*ipnt]));
                    if (status < 0) {
                        SPRINT0(1, "WARNING:: singular matrix detected.  setting vel=0");
                        SPRINT3(1, "ibody=%d,  ileft=%d,  irite=%d", ibody,       ileft,       irite);
                        SPRINT3(1, "xyzleft   %10.4f %10.4f %10.4f", xyzleft[0],  xyzleft[1],  xyzleft[2]);
                        SPRINT3(1, "xyzrite   %10.4f %10.4f %10.4f", xyzrite[0],  xyzrite[1],  xyzrite[2]);
                        SPRINT3(1, "normleft  %10.4f %10.4f %10.4f", normleft[0], normleft[1], normleft[2]);
                        SPRINT3(1, "normrite  %10.4f %10.4f %10.4f", normrite[0], normrite[1], normrite[2]);
                        SPRINT3(1, "dxyzleft  %10.4f %10.4f %10.4f", dxyzleft[0], dxyzleft[1], dxyzleft[2]);
                        SPRINT3(1, "dxyzrite  %10.4f %10.4f %10.4f", dxyzrite[0], dxyzrite[1], dxyzrite[2]);
                        dxyz[3*ipnt  ] = 0;
                        dxyz[3*ipnt+1] = 0;
                        dxyz[3*ipnt+2] = 0;
                        status = EGADS_SUCCESS;
                    }
                }
            }
        }

        goto cleanup;
    }

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    status = xformToOriginal(MODL, ibody, jbody, mat);
    CHECK_STATUS(xformToOriginal);

    /* if t==NULL, then find the locations of the tessellation points when
       the Edge was first created */
    if (t == NULL) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt_tess, &xyz_tess, &t_tess);
        CHECK_STATUS(EG_getTessEdge);

        if (npnt != npnt_tess) {
            status = OCSM_ILLEGAL_ARGUMENT;
            goto cleanup;
        } else {
            MALLOC(xyz_pnt, double, 3*npnt_tess);

            /* xyz_pnt are the tessellation points transformed back
               to the their locations in jbody */
            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                xyz_pnt[3*ipnt  ] = xyz_tess[3*ipnt  ] * mat[ 0]
                                  + xyz_tess[3*ipnt+1] * mat[ 1]
                                  + xyz_tess[3*ipnt+2] * mat[ 2] + mat[ 3];
                xyz_pnt[3*ipnt+1] = xyz_tess[3*ipnt  ] * mat[ 4]
                                  + xyz_tess[3*ipnt+1] * mat[ 5]
                                  + xyz_tess[3*ipnt+2] * mat[ 6] + mat[ 7];
                xyz_pnt[3*ipnt+2] = xyz_tess[3*ipnt  ] * mat[ 8]
                                  + xyz_tess[3*ipnt+1] * mat[ 9]
                                  + xyz_tess[3*ipnt+2] * mat[10] + mat[11];
            }
        }

    /* otherwise, find the locations at the given t's when the Edge
       was first created */
    } else {
        npnt_tess = npnt;
        MALLOC(xyz_pnt, double, 3*npnt_tess);

        for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, &(t[ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            xyz_pnt[3*ipnt  ] = data[0] * mat[ 0]
                              + data[1] * mat[ 1]
                              + data[2] * mat[ 2] + mat[ 3];
            xyz_pnt[3*ipnt+1] = data[0] * mat[ 4]
                              + data[1] * mat[ 5]
                              + data[2] * mat[ 6] + mat[ 7];
            xyz_pnt[3*ipnt+2] = data[0] * mat[ 8]
                              + data[1] * mat[ 9]
                              + data[2] * mat[10] + mat[11];
        }
    }

    /* find the number of Parameters that have changed */
    nchange = MODL->body[jbody].hasdots;

    /* if there are no Parameter changes, then the velocities are all 0 (and do not
       bother computing the derivatives below) */
    if (nchange == 0) {
        SPRINT0(2, "        -> setting to zero");
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] = 0;
            dxyz[3*ipnt+1] = 0;
            dxyz[3*ipnt+2] = 0;
        }

    /* get the velocities for a box */
    } else if (MODL->body[jbody].brtype == OCSM_BOX) {
        SPRINT0(2, "        -> analytical for BOX");

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            data2[0] = xyz_pnt[3*ipnt  ];
            data2[1] = xyz_pnt[3*ipnt+1];
            data2[2] = xyz_pnt[3*ipnt+2];

            if (fabs(MODL->body[jbody].arg[4].val[0]) > EPS06) {
                ubar = (data2[0] - MODL->body[jbody].arg[1].val[0]) / MODL->body[jbody].arg[4].val[0];
            } else {
                ubar = 0;
            }
            if (fabs(MODL->body[jbody].arg[5].val[0]) > EPS06) {
                vbar = (data2[1] - MODL->body[jbody].arg[2].val[0]) / MODL->body[jbody].arg[5].val[0];
            } else {
                vbar = 0;
            }
            if (fabs(MODL->body[jbody].arg[6].val[0]) > EPS06) {
                wbar = (data2[2] - MODL->body[jbody].arg[3].val[0]) / MODL->body[jbody].arg[6].val[0];
            } else {
                wbar = 0;
            }

            dxyz[3*ipnt  ] = MODL->body[jbody].arg[1].dot[0] + MODL->body[jbody].arg[4].dot[0] * ubar;
            dxyz[3*ipnt+1] = MODL->body[jbody].arg[2].dot[0] + MODL->body[jbody].arg[5].dot[0] * vbar;
            dxyz[3*ipnt+2] = MODL->body[jbody].arg[3].dot[0] + MODL->body[jbody].arg[6].dot[0] * wbar;
        }

    /* get the velocities for a sphere */
    } else if (MODL->body[jbody].brtype == OCSM_SPHERE) {
        SPRINT0(2, "        -> analytical for SPHERE");

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            data2[0] = xyz_pnt[3*ipnt  ];
            data2[1] = xyz_pnt[3*ipnt+1];
            data2[2] = xyz_pnt[3*ipnt+2];

            ubar = (data2[0] - MODL->body[jbody].arg[1].val[0]) / MODL->body[jbody].arg[4].val[0];
            vbar = (data2[1] - MODL->body[jbody].arg[2].val[0]) / MODL->body[jbody].arg[4].val[0];
            wbar = (data2[2] - MODL->body[jbody].arg[3].val[0]) / MODL->body[jbody].arg[4].val[0];

            dxyz[3*ipnt  ] = MODL->body[jbody].arg[1].dot[0] + MODL->body[jbody].arg[4].dot[0] * ubar;
            dxyz[3*ipnt+1] = MODL->body[jbody].arg[2].dot[0] + MODL->body[jbody].arg[4].dot[0] * vbar;
            dxyz[3*ipnt+2] = MODL->body[jbody].arg[3].dot[0] + MODL->body[jbody].arg[4].dot[0] * wbar;
        }

    /* get the velocities for a cone */
    } else if (MODL->body[jbody].brtype == OCSM_CONE) {
        SPRINT0(2, "        -> analytical for CONE");

        dx = MODL->body[jbody].arg[4].val[0] - MODL->body[jbody].arg[1].val[0];
        dy = MODL->body[jbody].arg[5].val[0] - MODL->body[jbody].arg[2].val[0];
        dz = MODL->body[jbody].arg[6].val[0] - MODL->body[jbody].arg[3].val[0];

        /* permute the coordinates so that fabs(dx) is largest */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            perm[0] = 1;  perm[1] = 0;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 1;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 0;  perm[8] = 1;
        } else if (fabs(dy) >= fabs(dz)) {
            perm[0] = 0;  perm[1] = 1;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 0;  perm[5] = 1;
            perm[6] = 1;  perm[7] = 0;  perm[8] = 0;
        } else {
            perm[0] = 0;  perm[1] = 0;  perm[2] = 1;
            perm[3] = 1;  perm[4] = 0;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 1;  perm[8] = 0;
        }

        xvrtx = perm[0] * MODL->body[jbody].arg[1].val[0]
              + perm[1] * MODL->body[jbody].arg[2].val[0]
              + perm[2] * MODL->body[jbody].arg[3].val[0];
        yvrtx = perm[3] * MODL->body[jbody].arg[1].val[0]
              + perm[4] * MODL->body[jbody].arg[2].val[0]
              + perm[5] * MODL->body[jbody].arg[3].val[0];
        zvrtx = perm[6] * MODL->body[jbody].arg[1].val[0]
              + perm[7] * MODL->body[jbody].arg[2].val[0]
              + perm[8] * MODL->body[jbody].arg[3].val[0];

        xbase = perm[0] * MODL->body[jbody].arg[4].val[0]
              + perm[1] * MODL->body[jbody].arg[5].val[0]
              + perm[2] * MODL->body[jbody].arg[6].val[0];
        ybase = perm[3] * MODL->body[jbody].arg[4].val[0]
              + perm[4] * MODL->body[jbody].arg[5].val[0]
              + perm[5] * MODL->body[jbody].arg[6].val[0];
        zbase = perm[6] * MODL->body[jbody].arg[4].val[0]
              + perm[7] * MODL->body[jbody].arg[5].val[0]
              + perm[8] * MODL->body[jbody].arg[6].val[0];

        rad  = MODL->body[jbody].arg[7].val[0];

        xvrtxdot = perm[0] * MODL->body[jbody].arg[1].dot[0]
                 + perm[1] * MODL->body[jbody].arg[2].dot[0]
                 + perm[2] * MODL->body[jbody].arg[3].dot[0];
        yvrtxdot = perm[3] * MODL->body[jbody].arg[1].dot[0]
                 + perm[4] * MODL->body[jbody].arg[2].dot[0]
                 + perm[5] * MODL->body[jbody].arg[3].dot[0];
        zvrtxdot = perm[6] * MODL->body[jbody].arg[1].dot[0]
                 + perm[7] * MODL->body[jbody].arg[2].dot[0]
                 + perm[8] * MODL->body[jbody].arg[3].dot[0];

        xbasedot = perm[0] * MODL->body[jbody].arg[4].dot[0]
                 + perm[1] * MODL->body[jbody].arg[5].dot[0]
                 + perm[2] * MODL->body[jbody].arg[6].dot[0];
        ybasedot = perm[3] * MODL->body[jbody].arg[4].dot[0]
                 + perm[4] * MODL->body[jbody].arg[5].dot[0]
                 + perm[5] * MODL->body[jbody].arg[6].dot[0];
        zbasedot = perm[6] * MODL->body[jbody].arg[4].dot[0]
                 + perm[7] * MODL->body[jbody].arg[5].dot[0]
                 + perm[8] * MODL->body[jbody].arg[6].dot[0];

        raddot  = MODL->body[jbody].arg[7].dot[0];

        dx = xbase - xvrtx;
        dy = ybase - yvrtx;
        dz = zbase - zvrtx;

        tht = atan2(dy, dx);
        phi = atan2(dz, sqrt(dy*dy + dx*dx));
        len = sqrt(dx*dx + dy*dy + dz*dz);
        psi = atan2(rad, len);

        num = dy;
        den = dx;
        if (fabs(num) > EPS06 || fabs(den) > EPS06) {
            numdot = ybasedot - yvrtxdot;
            dendot = xbasedot - xvrtxdot;
            thtdot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            thtdot = 0;
        }

        num = dz;
        den = sqrt(dy*dy + dx*dx);
        if (fabs(den) > EPS06) {
            numdot = zbasedot - zvrtxdot;
            dendot = (dx * (xbasedot - xvrtxdot) + dy * (ybasedot - yvrtxdot)) / den;
            phidot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            phidot = 0;
        }

        lendot = ( dx * (xbasedot - xvrtxdot)
                 + dy * (ybasedot - yvrtxdot)
                 + dz * (zbasedot - zvrtxdot)) / len;

        psidot = (len * raddot - lendot * rad) / (len * len * rad * rad);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            x1 = perm[0] * xyz_pnt[3*ipnt] + perm[1] * xyz_pnt[3*ipnt+1] + perm[2] * xyz_pnt[3*ipnt+2];
            y1 = perm[3] * xyz_pnt[3*ipnt] + perm[4] * xyz_pnt[3*ipnt+1] + perm[5] * xyz_pnt[3*ipnt+2];
            z1 = perm[6] * xyz_pnt[3*ipnt] + perm[7] * xyz_pnt[3*ipnt+1] + perm[8] * xyz_pnt[3*ipnt+2];

            /* move to origin */
            x2 = x1 - xvrtx;
            y2 = y1 - yvrtx;
            z2 = z1 - zvrtx;

            /* rotate around z2 axis so that cone lies in (x3,z3) plane */
            x3 = x2 * cos(tht) + y2 * sin(tht);
            y3 = y2 * cos(tht) - x2 * sin(tht);
            z3 = z2;

            /* rotate around y3 axis so that cone lies along x3 axis */
            x4 = x3 * cos(phi) + z3 * sin(phi);
            y4 = y3;
            z4 = z3 * cos(phi) - x3 * sin(phi);

            /* conical coordinates (x, psi, theta) */
            x5 = x4;
            s5 = atan2(sqrt(y4*y4 + z4*z4), x4);   /* psi5 */
            t5 = atan2(z4, y4);                    /* theta5 */

            /* set velocities on the cone in its canonical orientation */
            x5dot = x5 / len * lendot;
            t5dot = 0;
            s5dot = s5 / psi * psidot;

            /* transform velocities back to original orientation */
            x4dot = x5dot;
            y4dot = x5dot * cos(t5)       * tan(s5)
                  + s5dot * cos(t5)  * x5 / cos(s5) / cos(s5)
                  - t5dot * sin(t5)  * x5 * tan(s5);
            z4dot = x5dot * sin(t5)       * tan(s5)
                  + s5dot * sin(t5)  * x5 / cos(s5) / cos(s5)
                  + t5dot * cos(t5)  * x5 * tan(s5);

            x3dot = x4dot * cos(phi) - x4 * phidot * sin(phi)
                  - z4dot * sin(phi) - z4 * phidot * cos(phi);
            y3dot = y4dot;
            z3dot = z4dot * cos(phi) - z4 * phidot * sin(phi)
                  + x4dot * sin(phi) + x4 * phidot * cos(phi);

            x2dot = x3dot * cos(tht) - x3 * thtdot * sin(tht)
                  - y3dot * sin(tht) - y3 * thtdot * cos(tht);
            y2dot = y3dot * cos(tht) - y3 * thtdot * sin(tht)
                  + x3dot * sin(tht) + x3 * thtdot * cos(tht);
            z2dot = z3dot;

            x1dot = x2dot + xvrtxdot;
            y1dot = y2dot + yvrtxdot;
            z1dot = z2dot + zvrtxdot;

            dxyz[3*ipnt  ] = perm[0] * x1dot + perm[3] * y1dot + perm[6] * z1dot;
            dxyz[3*ipnt+1] = perm[1] * x1dot + perm[4] * y1dot + perm[7] * z1dot;
            dxyz[3*ipnt+2] = perm[2] * x1dot + perm[5] * y1dot + perm[8] * z1dot;
        }

    /* get the velocities for a cylinder */
    } else if (MODL->body[jbody].brtype == OCSM_CYLINDER) {
        SPRINT0(2, "        -> analytical for CYLINDER");

        dx = MODL->body[jbody].arg[4].val[0] - MODL->body[jbody].arg[1].val[0];
        dy = MODL->body[jbody].arg[5].val[0] - MODL->body[jbody].arg[2].val[0];
        dz = MODL->body[jbody].arg[6].val[0] - MODL->body[jbody].arg[3].val[0];

        /* permute the coordinates so that fabs(dx) is largest */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            perm[0] = 1;  perm[1] = 0;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 1;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 0;  perm[8] = 1;
        } else if (fabs(dy) >= fabs(dz)) {
            perm[0] = 0;  perm[1] = 1;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 0;  perm[5] = 1;
            perm[6] = 1;  perm[7] = 0;  perm[8] = 0;
        } else {
            perm[0] = 0;  perm[1] = 0;  perm[2] = 1;
            perm[3] = 1;  perm[4] = 0;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 1;  perm[8] = 0;
        }

        xbeg = perm[0] * MODL->body[jbody].arg[1].val[0]
             + perm[1] * MODL->body[jbody].arg[2].val[0]
             + perm[2] * MODL->body[jbody].arg[3].val[0];
        ybeg = perm[3] * MODL->body[jbody].arg[1].val[0]
             + perm[4] * MODL->body[jbody].arg[2].val[0]
             + perm[5] * MODL->body[jbody].arg[3].val[0];
        zbeg = perm[6] * MODL->body[jbody].arg[1].val[0]
             + perm[7] * MODL->body[jbody].arg[2].val[0]
             + perm[8] * MODL->body[jbody].arg[3].val[0];

        xend = perm[0] * MODL->body[jbody].arg[4].val[0]
             + perm[1] * MODL->body[jbody].arg[5].val[0]
             + perm[2] * MODL->body[jbody].arg[6].val[0];
        yend = perm[3] * MODL->body[jbody].arg[4].val[0]
             + perm[4] * MODL->body[jbody].arg[5].val[0]
             + perm[5] * MODL->body[jbody].arg[6].val[0];
        zend = perm[6] * MODL->body[jbody].arg[4].val[0]
             + perm[7] * MODL->body[jbody].arg[5].val[0]
             + perm[8] * MODL->body[jbody].arg[6].val[0];

        rad  = MODL->body[jbody].arg[7].val[0];

        xbegdot = perm[0] * MODL->body[jbody].arg[1].dot[0]
                + perm[1] * MODL->body[jbody].arg[2].dot[0]
                + perm[2] * MODL->body[jbody].arg[3].dot[0];
        ybegdot = perm[3] * MODL->body[jbody].arg[1].dot[0]
                + perm[4] * MODL->body[jbody].arg[2].dot[0]
                + perm[5] * MODL->body[jbody].arg[3].dot[0];
        zbegdot = perm[6] * MODL->body[jbody].arg[1].dot[0]
                + perm[7] * MODL->body[jbody].arg[2].dot[0]
                + perm[8] * MODL->body[jbody].arg[3].dot[0];

        xenddot = perm[0] * MODL->body[jbody].arg[4].dot[0]
                + perm[1] * MODL->body[jbody].arg[5].dot[0]
                + perm[2] * MODL->body[jbody].arg[6].dot[0];
        yenddot = perm[3] * MODL->body[jbody].arg[4].dot[0]
                + perm[4] * MODL->body[jbody].arg[5].dot[0]
                + perm[5] * MODL->body[jbody].arg[6].dot[0];
        zenddot = perm[6] * MODL->body[jbody].arg[4].dot[0]
                + perm[7] * MODL->body[jbody].arg[5].dot[0]
                + perm[8] * MODL->body[jbody].arg[6].dot[0];

        raddot  = MODL->body[jbody].arg[7].dot[0];

        dx = xend - xbeg;
        dy = yend - ybeg;
        dz = zend - zbeg;

        tht = atan2(dy, dx);                      /* -azimuth  from  xz plane */
        phi = atan2(dz, sqrt(dy*dy + dx*dx));     /* elevation above xy plane */
        len = sqrt(dx*dx + dy*dy + dz*dz);

        num = dy;
        den = dx;
        if (fabs(num) > EPS06 || fabs(den) > EPS06) {
            numdot = yenddot - ybegdot;
            dendot = xenddot - xbegdot;
            thtdot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            thtdot = 0;
        }

        num = dz;
        den = sqrt(dy*dy + dx*dx);
        if (fabs(den) > EPS06) {
            numdot = zenddot - zbegdot;
            dendot = (dx * (xenddot - xbegdot) + dy * (yenddot - ybegdot)) / den;
            phidot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            phidot = 0;
        }

        lendot = ( dx * (xenddot - xbegdot)
                 + dy * (yenddot - ybegdot)
                 + dz * (zenddot - zbegdot)) / len;

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            x1 = perm[0] * xyz_pnt[3*ipnt] + perm[1] * xyz_pnt[3*ipnt+1] + perm[2] * xyz_pnt[3*ipnt+2];
            y1 = perm[3] * xyz_pnt[3*ipnt] + perm[4] * xyz_pnt[3*ipnt+1] + perm[5] * xyz_pnt[3*ipnt+2];
            z1 = perm[6] * xyz_pnt[3*ipnt] + perm[7] * xyz_pnt[3*ipnt+1] + perm[8] * xyz_pnt[3*ipnt+2];

            /* move to origin */
            x2 = x1 - xbeg;
            y2 = y1 - ybeg;
            z2 = z1 - zbeg;

            /* rotate around z2 axis so that cylinder lies in (x3,z3) plane */
            x3 = x2 * cos(tht) + y2 * sin(tht);
            y3 = y2 * cos(tht) - x2 * sin(tht);
            z3 = z2;

            /* rotate around y3 axis so that cylinder lies along x3 axis */
            x4 = x3 * cos(phi) + z3 * sin(phi);
            y4 = y3;
            z4 = z3 * cos(phi) - x3 * sin(phi);

            /* cylindrical coordinates (x, r, theta) */
            x5 = x4;
            r5 = sqrt(y4*y4 + z4*z4);   /* rad5 */
            t5 = atan2(z4, y4);         /* theta5 */

            /* set velocities on the cylinder in its canonical orientation */
            x5dot = x5 / len * lendot;
            r5dot = r5 / rad * raddot;
            t5dot = 0;

            /* transform velocities back to original orientation */
            x4dot = x5dot;
            y4dot = r5dot * cos(t5)  - r5 * t5dot  * sin(t5);
            z4dot = r5dot * sin(t5)  + r5 * t5dot  * cos(t5);

            x3dot = x4dot * cos(phi) - x4 * phidot * sin(phi)
                  - z4dot * sin(phi) - z4 * phidot * cos(phi);
            y3dot = y4dot;
            z3dot = z4dot * cos(phi) - z4 * phidot * sin(phi)
                  + x4dot * sin(phi) + x4 * phidot * cos(phi);

            x2dot = x3dot * cos(tht) - x3 * thtdot * sin(tht)
                  - y3dot * sin(tht) - y3 * thtdot * cos(tht);
            y2dot = y3dot * cos(tht) - y3 * thtdot * sin(tht)
                  + x3dot * sin(tht) + x3 * thtdot * cos(tht);
            z2dot = z3dot;

            x1dot = x2dot + xbegdot;
            y1dot = y2dot + ybegdot;
            z1dot = z2dot + zbegdot;

            dxyz[3*ipnt  ] = perm[0] * x1dot + perm[3] * y1dot + perm[6] * z1dot;
            dxyz[3*ipnt+1] = perm[1] * x1dot + perm[4] * y1dot + perm[7] * z1dot;
            dxyz[3*ipnt+2] = perm[2] * x1dot + perm[5] * y1dot + perm[8] * z1dot;
        }

    /* get the velocities for a udprim */
    } else if (MODL->body[jbody].brtype == OCSM_UDPRIM) {
        SPRINT0(2, "        -> analytical for UDPRIM");

        /* load and execute the user-defined primitive */
        ibrch = MODL->body[jbody].ibrch;

        STRNCPY(primtype, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);

        status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
        if (status == EGADS_NOLOAD) {
            status = EGADS_SUCCESS;
        }
        CHECK_STATUS(udp_initialize);

        status = udp_clrArguments(primtype);
        CHECK_STATUS(udp_clrArguments);

        needfd = 0;

        /* go back to first associated udparg statement whose primtype matches the
           udprim's primtype */
        kbody = jbody - 1;
        while (kbody > 0 && MODL->body[kbody].brtype == OCSM_UDPARG &&
               strcmp(MODL->body[kbody].arg[1].str, MODL->body[jbody].arg[1].str) == 0 ) {
            kbody--;
        }
        kbody++;

        while (kbody <= jbody) {
            for (iarg = 3; iarg < 10; iarg+=2) {
                if (MODL->body[kbody].arg[iarg].nval < 0) break;

                if (MODL->body[kbody].arg[iarg].nval > 0) {
                    status = udp_setVelocity(MODL->body[kbody].arg[1].str,
                                             MODL->body[jbody].ebody,
                                             MODL->body[kbody].arg[iarg-1].str,
                                             MODL->body[kbody].arg[iarg  ].dot,
                                             MODL->body[kbody].arg[iarg  ].nval);
                    if (status != EGADS_SUCCESS) {
                        /* indexerr indicates that a variable is not available for sensitivity,
                           (for example an integer), so we will just get zeroes */
                        if (status == EGADS_INDEXERR) {
                            SPRINT2(1, "WARNING:: sensitivity cannot be computed for \"%s\" in %s (1)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* notfound indicates that a variable is not available for sensitivity,
                           so compute sensitivity by finite differences */
                        } else if (status == EGADS_NOTFOUND) {
                            if (MODL->perturb == NULL && MODL->dtime > 0) {
                                SPRINT2(2, "    creating perturbation for ibody=%d (because dtime=%15.10f)",
                                        ibody, MODL->dtime);

                                status = createPerturbation(MODL);
                                CHECK_STATUS(createPerturbation);
                            } else {
                                SPRINT2(1, "WARNING:: sensitivity cannot be computed for \"%s\" in %s (2)",
                                        MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                                (MODL->nwarn)++;
                            }
                            needfd++;
                        /* unknown error type */
                        } else {
                            needfd++;
                        }
                    }
                }
            }

            kbody++;
        }

        /* if any of the velocities could not be set, we need finite differences */
        if (needfd > 0) {
            SPRINT0(2, "        -> analytical derivaitives not available, so reverting to finiteDifferences");

            status = finiteDifference(MODL, ibody, OCSM_EDGE, iedge, npnt, t, dxyz);
            CHECK_STATUS(finiteDifference);
            goto cleanup;
        }

        MALLOC(ts, double, npnt);

        if (t == NULL) {
            for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                ts[ipnt]  = t_tess[ipnt];
            }
        } else {
            for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                ts[ipnt] = t[ipnt];
            }
        }

        if (jedge > 0) {

#ifdef EDGE_HIST_TRANSFORM
            status = EG_getTopology(MODL->body[jbody].edge[jedge].eedge, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(eref, &oclass, &mtype, &rgeom, NULL, NULL);
            CHECK_STATUS(EG_getGeometry);

            if (oclass == CURVE && mtype == LINE) {

                /* xformToOriginal could return the scale */
                scale = 1.0;

                /* walk from ibody back to jbody (which is the first Body
                   in which inode appeared).  see comment at bottom
                   of loop to see how we make sure that we choose the
                   correct parent */
                kbody = ibody;
                while (kbody != jbody) {

                    /* scale */
                    if (MODL->body[kbody].brtype == OCSM_SCALE) {
                        SPRINT1(2, "            -> scale     (kbody=%d)", kbody);

                        scale *= MODL->body[kbody].arg[1].val[0];
                    }

                    /* go to kbody's left or rite parent.  the only way to get
                       the correct parent is to start over from jbody until
                       the parent is the old kbody (which we call ktgt) */
                    ktgt  = kbody;
                    kbody = jbody;
                    while (kbody > 0) {
                        if (MODL->body[kbody].ichld == ktgt) break;

                        kbody = MODL->body[kbody].ichld;
                    }
                }

                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    ts[ipnt] /= scale;
                }
            }
#endif
            status = udp_sensitivity(primtype, MODL->body[jbody].ebody,
                                     npnt, OCSM_EDGE, jedge, ts, dxyz);
            CHECK_STATUS(udp_sensitivity);
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "cannot find Edge %d:%d in jbody=%d", ibody, iedge, jbody);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

    /* unknown primitive type, so get velocities by finite differences */
    } else {
        SPRINT1(2, "        -> using finiteDifference (brtype=%s)",
                ocsmGetText(MODL->body[jbody].brtype));

        status = finiteDifference(MODL, ibody, OCSM_EDGE, iedge, npnt, t, dxyz);
        CHECK_STATUS(finiteDifference);
        goto cleanup;
    }

#ifndef EDGE_HIST_TRANSFORM
    /* follow the children (up to the root or the first GROWN) and modify the velocities
       for any OCSM_TRANSFORM that is visited */
    while (jbody != 0) {
        if (MODL->brch[MODL->body[jbody].ibrch].bclass == OCSM_GROWN &&
            MODL->body[jbody].brtype != OCSM_BLEND                   &&
            MODL->body[jbody].brtype != OCSM_RULE                      ) break;

        status = xformVelocity(MODL, jbody, npnt_tess, xyz_pnt, npnt, dxyz);
        CHECK_STATUS(xformVelocity);

        jbody = MODL->body[jbody].ichld;
    }

#else

    /* use the history of the edge to transform velocities */
    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_hist", &atype, &alen,
                             &tempIlist, &tempRlist, &tempClist);
    CHECK_STATUS(EG_attributeRet);

    /* transform the velocities */
    for (i = 0; i < alen; i++) {
        if (tempIlist[i] > jbody) {
            status = xformVelocity(MODL, tempIlist[i], npnt_tess, xyz_pnt, npnt, dxyz);
            CHECK_STATUS(xformVelocity);
        }
    }

#endif

cleanup:
    SPRINT6(2, " <- velocityOfEdge(ibody=%3d, iedge=%3d, npnt=%5d) -> %12.6f %12.6f %12.6f",
            ibody, iedge, npnt, dxyz[0], dxyz[1], dxyz[2]);
    for (ipnt = 1; ipnt < MIN(3,npnt); ipnt++) {
        SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                dxyz[3*ipnt], dxyz[3*ipnt+1], dxyz[3*ipnt+2]);
    }

    FREE(ts);
    FREE(xyz_pnt);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   velocityOfFace - compute Face velocities analytically              *
 *                                                                      *
 ************************************************************************
 */

int
velocityOfFace(modl_T *MODL,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (bias-1) */
               int    iface,            /* (in)  Face index (bias-1) */
               int    npnt,             /* (in)  number of points */
     /*@null@*/double uv[],             /* (in)  para coords (2*npnt in length) */
               double dxyz[])           /* (out) velocities  (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       jface, kface, ipnt, jbody, kbody, lbody, npnt_tess, ntri_tess;
    int       iarg, nchange, nedge, nsketch=0, isketch[MAX_NUM_SKETCHES];
    int       iedge, attrtype, attrlen, *iinfo=NULL;
    int       oclass, mtype, nchild, *senses, istrip, i, isplane;
    CINT      *tris, *tric, *ptype, *pindx, *tempIlist;
    double    params[2], data[18], data2[3], mat[12], mat2[12], ubar, vbar, wbar, trange[4];
    double    dx, dy, dz, num, numdot, den, dendot, frac;
    double    *ts=NULL, *tn=NULL, *vels=NULL;
    double    xbeg, xbegdot, ybeg, ybegdot, zbeg, zbegdot;
    double    xend, xenddot, yend, yenddot, zend, zenddot;
    double    xbase, xbasedot, ybase, ybasedot, zbase, zbasedot;
    double    xvrtx, xvrtxdot, yvrtx, yvrtxdot, zvrtx, zvrtxdot, rad, raddot;
    double    tht, thtdot, phi, phidot, len, lendot, psi, psidot;
    double    x1, x1dot, y1, y1dot, z1, z1dot;
    double    x2, x2dot, y2, y2dot, z2, z2dot;
    double    x3, x3dot, y3, y3dot, z3, z3dot;
    double    x4, x4dot, y4, y4dot, z4, z4dot;
    double    x5, x5dot, r5, r5dot, t5, t5dot, s5, s5dot;
    double    perm[9];
    double    *uvs=NULL, *xyz_pnt=NULL, *xyz_pnt2=NULL;
    double    *Rbeg, Rbeg_local[2], *Rbeg_dot, *Rend, *Rend_dot, Rend_local[2];
    double    data_dot[18];
    double    edgeData[4], *rinfo=NULL, xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd;
    double    A, B, C, D, E, F, s, t, scale;
    CDOUBLE   *xyz_tess, *uv_tess, *tempRlist;
    CCHAR     *tempClist;
    ego       esketch[MAX_NUM_SKETCHES], ebody, esurf, eref, *echilds, rgeom;

    int       ibrch, udp_num, *udp_types, *udp_idef, needfd, periodic;
    double    *udp_ddef;
    char      **udp_names, primtype[MAX_EXPR_LEN];

    egadsSplineVels  splData;
    egadsSpline_T    spl;

    ROUTINE(velocityOfFace);

    /* --------------------------------------------------------------- */

    SPRINT3(2, " -> velocityOfFace(ibody=%d, iface=%d, npnt=%d)", ibody, iface, npnt);

    if        (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    } else if (iface < 1 || iface > MODL->body[ibody].nface) {
        status = OCSM_FACE_NOT_FOUND;
        goto cleanup;
    }

    /* if there is an active perturbation, get velocity by finite
       differences */
    if (MODL->perturb != NULL) {
        SPRINT0(2, "        -> finite differencing");
        status = finiteDifference(MODL, ibody, OCSM_FACE, iface, npnt, uv, dxyz);
        CHECK_STATUS(finiteDifference);

        goto cleanup;
    }

    /* see if the Face is a PLANE */
    status = EG_getTopology(MODL->body[ibody].face[iface].eface, &esurf, &oclass, &mtype,
                            data, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    status = EG_getGeometry(esurf, &oclass, &mtype, &eref, NULL, NULL);
    CHECK_STATUS(EG_getGeometry);

    if (oclass == SURFACE && mtype == PLANE) {
        isplane = 1;
    } else {
        isplane = 0;
    }

    /* jbody is the Body in which this Face first appeared */
    jbody = MODL->body[ibody].face[iface].ibody;

    /* find the Face in jbody that maps to face iface in ibody */
    jface = -1;
    for (kface = 1; kface <= MODL->body[jbody].nface; kface++) {
        if (MODL->body[jbody].face[kface].iford == MODL->body[ibody].face[iface].iford) {
            jface = kface;
            break;
        }
    }
    SPRINT4(2, "        ibody=%d,iface=%d maps to jbody=%d,jface=%d", ibody, iface, jbody, jface);

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    status = xformFaceToOriginal(MODL, ibody, iface, mat, &scale);
    CHECK_STATUS(xformFaceToOriginal);

    /* if uv==NULL, then find the locations of the tessellation points when
       the Face was first created */
    if (uv == NULL) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                &ntri_tess, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        if (npnt != npnt_tess) {
            status = OCSM_ILLEGAL_ARGUMENT;
            goto cleanup;
        } else {
            MALLOC(xyz_pnt,  double, 3*npnt_tess);
            MALLOC(xyz_pnt2, double, 3*npnt_tess);

            /* xyz_pnt are the tessellation points transformed back
               to the their locations in jbody */
            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                xyz_pnt[3*ipnt  ] = xyz_tess[3*ipnt  ] * mat[ 0]
                                  + xyz_tess[3*ipnt+1] * mat[ 1]
                                  + xyz_tess[3*ipnt+2] * mat[ 2] + mat[ 3];
                xyz_pnt[3*ipnt+1] = xyz_tess[3*ipnt  ] * mat[ 4]
                                  + xyz_tess[3*ipnt+1] * mat[ 5]
                                  + xyz_tess[3*ipnt+2] * mat[ 6] + mat[ 7];
                xyz_pnt[3*ipnt+2] = xyz_tess[3*ipnt  ] * mat[ 8]
                                  + xyz_tess[3*ipnt+1] * mat[ 9]
                                  + xyz_tess[3*ipnt+2] * mat[10] + mat[11];
            }
        }

    /* otherwise, find the locations at the given uv's when the Face
       was first created */
    } else {
        npnt_tess = npnt;
        MALLOC(xyz_pnt,  double, 3*npnt_tess);
        MALLOC(xyz_pnt2, double, 3*npnt_tess);

        for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
            params[0] = uv[2*ipnt  ];
            params[1] = uv[2*ipnt+1];

            status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                 params, data);
            CHECK_STATUS(EG_evaluate);

            xyz_pnt[3*ipnt  ] = data[0] * mat[ 0]
                              + data[1] * mat[ 1]
                              + data[2] * mat[ 2] + mat[ 3];
            xyz_pnt[3*ipnt+1] = data[0] * mat[ 4]
                              + data[1] * mat[ 5]
                              + data[2] * mat[ 6] + mat[ 7];
            xyz_pnt[3*ipnt+2] = data[0] * mat[ 8]
                              + data[1] * mat[ 9]
                              + data[2] * mat[10] + mat[11];
        }
    }

    /* find the number of Parameters that have changed */
    nchange = MODL->body[jbody].hasdots;

    /* if a OCSM_EXTRUDE, count changes associated with the Sketch and
       any Branches between the Sketch and the EXTRUDE */
    if (MODL->body[jbody].brtype == OCSM_EXTRUDE) {
        kbody = MODL->body[jbody].ileft;
        isketch[nsketch++] = kbody;

        lbody = kbody;
        while (lbody > 0) {
            nchange += MODL->body[lbody].hasdots;
            if (MODL->brch[MODL->body[lbody].ibrch].bclass == OCSM_PRIMITIVE ||
                MODL->brch[MODL->body[lbody].ibrch].bclass == OCSM_SKETCH      ) break;

            lbody = MODL->body[lbody].ileft;
        }
    }

    /* if a OCSM_RULE or OCSM_BLEND, count changes associated with the Sketches and
       any Branches between the Sketch(es) and the RULE or BLEND */
    if (MODL->body[jbody].brtype == OCSM_RULE  ||
        MODL->body[jbody].brtype == OCSM_BLEND   ) {
        for (kbody = MODL->body[jbody].ileft; kbody <= MODL->body[jbody].irite; kbody++) {
            if (MODL->body[kbody].ichld != jbody) continue;
            isketch[nsketch++] = kbody;

            lbody = kbody;
            while (lbody > 0) {
                nchange += MODL->body[lbody].hasdots;
                if (MODL->body[lbody].brtype == OCSM_RESTORE) {
                    lbody = MODL->body[lbody].ileft;
                } else if (MODL->brch[MODL->body[lbody].ibrch].bclass == OCSM_PRIMITIVE ||
                           MODL->brch[MODL->body[lbody].ibrch].bclass == OCSM_SKETCH      ) {
                    break;
                } else {
                    lbody = MODL->body[lbody].ileft;
                }
            }
        }
    }

    /* normally the "original" location is the same as the current location */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        xyz_pnt2[3*ipnt  ] = xyz_pnt[3*ipnt  ];
        xyz_pnt2[3*ipnt+1] = xyz_pnt[3*ipnt+1];
        xyz_pnt2[3*ipnt+2] = xyz_pnt[3*ipnt+2];
    }

    /* if there are no Parameter changes, then the velocities are all 0 (and do not
       bother computing the derivatives below) */
    if (nchange == 0) {
        SPRINT0(2, "        -> setting to zero");
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] = 0;
            dxyz[3*ipnt+1] = 0;
            dxyz[3*ipnt+2] = 0;
        }

    /* get the velocities for a box */
    } else if (MODL->body[jbody].brtype == OCSM_BOX) {
        SPRINT0(2, "        -> analytical for BOX");

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            data2[0] = xyz_pnt[3*ipnt  ];
            data2[1] = xyz_pnt[3*ipnt+1];
            data2[2] = xyz_pnt[3*ipnt+2];

            if (fabs(MODL->body[jbody].arg[4].val[0]) > EPS06) {
                ubar = (data2[0] - MODL->body[jbody].arg[1].val[0]) / MODL->body[jbody].arg[4].val[0];
            } else {
                ubar = 0;
            }
            if (fabs(MODL->body[jbody].arg[5].val[0]) > EPS06) {
                vbar = (data2[1] - MODL->body[jbody].arg[2].val[0]) / MODL->body[jbody].arg[5].val[0];
            } else {
                vbar = 0;
            }
            if (fabs(MODL->body[jbody].arg[6].val[0]) > EPS06) {
                wbar = (data2[2] - MODL->body[jbody].arg[3].val[0]) / MODL->body[jbody].arg[6].val[0];
            } else {
                wbar = 0;
            }

            dxyz[3*ipnt  ] = MODL->body[jbody].arg[1].dot[0] + MODL->body[jbody].arg[4].dot[0] * ubar;
            dxyz[3*ipnt+1] = MODL->body[jbody].arg[2].dot[0] + MODL->body[jbody].arg[5].dot[0] * vbar;
            dxyz[3*ipnt+2] = MODL->body[jbody].arg[3].dot[0] + MODL->body[jbody].arg[6].dot[0] * wbar;
        }

    /* get the velocities for a sphere */
    } else if (MODL->body[jbody].brtype == OCSM_SPHERE) {
        SPRINT0(2, "        -> analytical for SPHERE");

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            data2[0] = xyz_pnt[3*ipnt  ];
            data2[1] = xyz_pnt[3*ipnt+1];
            data2[2] = xyz_pnt[3*ipnt+2];

            ubar = (data2[0] - MODL->body[jbody].arg[1].val[0]) / MODL->body[jbody].arg[4].val[0];
            vbar = (data2[1] - MODL->body[jbody].arg[2].val[0]) / MODL->body[jbody].arg[4].val[0];
            wbar = (data2[2] - MODL->body[jbody].arg[3].val[0]) / MODL->body[jbody].arg[4].val[0];

            dxyz[3*ipnt  ] = MODL->body[jbody].arg[1].dot[0] + MODL->body[jbody].arg[4].dot[0] * ubar;
            dxyz[3*ipnt+1] = MODL->body[jbody].arg[2].dot[0] + MODL->body[jbody].arg[4].dot[0] * vbar;
            dxyz[3*ipnt+2] = MODL->body[jbody].arg[3].dot[0] + MODL->body[jbody].arg[4].dot[0] * wbar;
        }

    /* get the velocities for a cone */
    } else if (MODL->body[jbody].brtype == OCSM_CONE) {
        SPRINT0(2, "        -> analytical for CONE");

        dx = MODL->body[jbody].arg[4].val[0] - MODL->body[jbody].arg[1].val[0];
        dy = MODL->body[jbody].arg[5].val[0] - MODL->body[jbody].arg[2].val[0];
        dz = MODL->body[jbody].arg[6].val[0] - MODL->body[jbody].arg[3].val[0];

        /* permute the coordinates so that fabs(dx) is largest */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            perm[0] = 1;  perm[1] = 0;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 1;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 0;  perm[8] = 1;
        } else if (fabs(dy) >= fabs(dz)) {
            perm[0] = 0;  perm[1] = 1;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 0;  perm[5] = 1;
            perm[6] = 1;  perm[7] = 0;  perm[8] = 0;
        } else {
            perm[0] = 0;  perm[1] = 0;  perm[2] = 1;
            perm[3] = 1;  perm[4] = 0;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 1;  perm[8] = 0;
        }

        xvrtx = perm[0] * MODL->body[jbody].arg[1].val[0]
              + perm[1] * MODL->body[jbody].arg[2].val[0]
              + perm[2] * MODL->body[jbody].arg[3].val[0];
        yvrtx = perm[3] * MODL->body[jbody].arg[1].val[0]
              + perm[4] * MODL->body[jbody].arg[2].val[0]
              + perm[5] * MODL->body[jbody].arg[3].val[0];
        zvrtx = perm[6] * MODL->body[jbody].arg[1].val[0]
              + perm[7] * MODL->body[jbody].arg[2].val[0]
              + perm[8] * MODL->body[jbody].arg[3].val[0];

        xbase = perm[0] * MODL->body[jbody].arg[4].val[0]
              + perm[1] * MODL->body[jbody].arg[5].val[0]
              + perm[2] * MODL->body[jbody].arg[6].val[0];
        ybase = perm[3] * MODL->body[jbody].arg[4].val[0]
              + perm[4] * MODL->body[jbody].arg[5].val[0]
              + perm[5] * MODL->body[jbody].arg[6].val[0];
        zbase = perm[6] * MODL->body[jbody].arg[4].val[0]
              + perm[7] * MODL->body[jbody].arg[5].val[0]
              + perm[8] * MODL->body[jbody].arg[6].val[0];

        rad  = MODL->body[jbody].arg[7].val[0];

        xvrtxdot = perm[0] * MODL->body[jbody].arg[1].dot[0]
                 + perm[1] * MODL->body[jbody].arg[2].dot[0]
                 + perm[2] * MODL->body[jbody].arg[3].dot[0];
        yvrtxdot = perm[3] * MODL->body[jbody].arg[1].dot[0]
                 + perm[4] * MODL->body[jbody].arg[2].dot[0]
                 + perm[5] * MODL->body[jbody].arg[3].dot[0];
        zvrtxdot = perm[6] * MODL->body[jbody].arg[1].dot[0]
                 + perm[7] * MODL->body[jbody].arg[2].dot[0]
                 + perm[8] * MODL->body[jbody].arg[3].dot[0];

        xbasedot = perm[0] * MODL->body[jbody].arg[4].dot[0]
                 + perm[1] * MODL->body[jbody].arg[5].dot[0]
                 + perm[2] * MODL->body[jbody].arg[6].dot[0];
        ybasedot = perm[3] * MODL->body[jbody].arg[4].dot[0]
                 + perm[4] * MODL->body[jbody].arg[5].dot[0]
                 + perm[5] * MODL->body[jbody].arg[6].dot[0];
        zbasedot = perm[6] * MODL->body[jbody].arg[4].dot[0]
                 + perm[7] * MODL->body[jbody].arg[5].dot[0]
                 + perm[8] * MODL->body[jbody].arg[6].dot[0];

        raddot  = MODL->body[jbody].arg[7].dot[0];

        dx = xbase - xvrtx;
        dy = ybase - yvrtx;
        dz = zbase - zvrtx;

        tht = atan2(dy, dx);
        phi = atan2(dz, sqrt(dy*dy + dx*dx));
        len = sqrt(dx*dx + dy*dy + dz*dz);
        psi = atan2(rad, len);

        num = dy;
        den = dx;
        if (fabs(num) > EPS06 || fabs(den) > EPS06) {
            numdot = ybasedot - yvrtxdot;
            dendot = xbasedot - xvrtxdot;
            thtdot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            thtdot = 0;
        }

        num = dz;
        den = sqrt(dy*dy + dx*dx);
        if (fabs(den) > EPS06) {
            numdot = zbasedot - zvrtxdot;
            dendot = (dx * (xbasedot - xvrtxdot) + dy * (ybasedot - yvrtxdot)) / den;
            phidot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            phidot = 0;
        }

        lendot = ( dx * (xbasedot - xvrtxdot)
                 + dy * (ybasedot - yvrtxdot)
                 + dz * (zbasedot - zvrtxdot)) / len;

        psidot = (raddot * len - lendot * rad) / (len * len * rad * rad);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            x1 = perm[0] * xyz_pnt[3*ipnt] + perm[1] * xyz_pnt[3*ipnt+1] + perm[2] * xyz_pnt[3*ipnt+2];
            y1 = perm[3] * xyz_pnt[3*ipnt] + perm[4] * xyz_pnt[3*ipnt+1] + perm[5] * xyz_pnt[3*ipnt+2];
            z1 = perm[6] * xyz_pnt[3*ipnt] + perm[7] * xyz_pnt[3*ipnt+1] + perm[8] * xyz_pnt[3*ipnt+2];

            /* move to origin */
            x2 = x1 - xvrtx;
            y2 = y1 - yvrtx;
            z2 = z1 - zvrtx;

            /* rotate around z2 axis so that cone lies in (x3,z3) plane */
            x3 = x2 * cos(tht) + y2 * sin(tht);
            y3 = y2 * cos(tht) - x2 * sin(tht);
            z3 = z2;

            /* rotate around y3 axis so that cone lies along x3 axis */
            x4 = x3 * cos(phi) + z3 * sin(phi);
            y4 = y3;
            z4 = z3 * cos(phi) - x3 * sin(phi);

            /* conical coordinates (x, psi, theta) */
            x5 = x4;
            s5 = atan2(sqrt(y4*y4 + z4*z4), x4);   /* psi5 */
            t5 = atan2(z4, y4);                    /* theta5 */

            /* set velocities on the cone in its canonical orientation */
            x5dot = x5 / len * lendot;
            t5dot = 0;
            s5dot = s5 / psi * psidot;

            /* transform velocities back to original orientation */
            x4dot = x5dot;
            y4dot = x5dot * cos(t5)       * tan(s5)
                  + s5dot * cos(t5)  * x5 / cos(s5) / cos(s5)
                  - t5dot * sin(t5)  * x5 * tan(s5);
            z4dot = x5dot * sin(t5)       * tan(s5)
                  + s5dot * sin(t5)  * x5 / cos(s5) / cos(s5)
                  + t5dot * cos(t5)  * x5 * tan(s5);

            x3dot = x4dot * cos(phi) - x4 * phidot * sin(phi)
                  - z4dot * sin(phi) - z4 * phidot * cos(phi);
            y3dot = y4dot;
            z3dot = z4dot * cos(phi) - z4 * phidot * sin(phi)
                  + x4dot * sin(phi) + x4 * phidot * cos(phi);

            x2dot = x3dot * cos(tht) - x3 * thtdot * sin(tht)
                  - y3dot * sin(tht) - y3 * thtdot * cos(tht);
            y2dot = y3dot * cos(tht) - y3 * thtdot * sin(tht)
                  + x3dot * sin(tht) + x3 * thtdot * cos(tht);
            z2dot = z3dot;

            x1dot = x2dot + xvrtxdot;
            y1dot = y2dot + yvrtxdot;
            z1dot = z2dot + zvrtxdot;

            dxyz[3*ipnt  ] = perm[0] * x1dot + perm[3] * y1dot + perm[6] * z1dot;
            dxyz[3*ipnt+1] = perm[1] * x1dot + perm[4] * y1dot + perm[7] * z1dot;
            dxyz[3*ipnt+2] = perm[2] * x1dot + perm[5] * y1dot + perm[8] * z1dot;
        }

    /* get the velocities for a cylinder */
    } else if (MODL->body[jbody].brtype == OCSM_CYLINDER) {
        SPRINT0(2, "        -> analytical for CYLINDER");

        dx = MODL->body[jbody].arg[4].val[0] - MODL->body[jbody].arg[1].val[0];
        dy = MODL->body[jbody].arg[5].val[0] - MODL->body[jbody].arg[2].val[0];
        dz = MODL->body[jbody].arg[6].val[0] - MODL->body[jbody].arg[3].val[0];

        /* permute the coordinates so that fabs(dx) is largest */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            perm[0] = 1;  perm[1] = 0;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 1;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 0;  perm[8] = 1;
        } else if (fabs(dy) >= fabs(dz)) {
            perm[0] = 0;  perm[1] = 1;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 0;  perm[5] = 1;
            perm[6] = 1;  perm[7] = 0;  perm[8] = 0;
        } else {
            perm[0] = 0;  perm[1] = 0;  perm[2] = 1;
            perm[3] = 1;  perm[4] = 0;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 1;  perm[8] = 0;
        }

        xbeg = perm[0] * MODL->body[jbody].arg[1].val[0]
             + perm[1] * MODL->body[jbody].arg[2].val[0]
             + perm[2] * MODL->body[jbody].arg[3].val[0];
        ybeg = perm[3] * MODL->body[jbody].arg[1].val[0]
             + perm[4] * MODL->body[jbody].arg[2].val[0]
             + perm[5] * MODL->body[jbody].arg[3].val[0];
        zbeg = perm[6] * MODL->body[jbody].arg[1].val[0]
             + perm[7] * MODL->body[jbody].arg[2].val[0]
             + perm[8] * MODL->body[jbody].arg[3].val[0];

        xend = perm[0] * MODL->body[jbody].arg[4].val[0]
             + perm[1] * MODL->body[jbody].arg[5].val[0]
             + perm[2] * MODL->body[jbody].arg[6].val[0];
        yend = perm[3] * MODL->body[jbody].arg[4].val[0]
             + perm[4] * MODL->body[jbody].arg[5].val[0]
             + perm[5] * MODL->body[jbody].arg[6].val[0];
        zend = perm[6] * MODL->body[jbody].arg[4].val[0]
             + perm[7] * MODL->body[jbody].arg[5].val[0]
             + perm[8] * MODL->body[jbody].arg[6].val[0];

        rad  = MODL->body[jbody].arg[7].val[0];

        xbegdot = perm[0] * MODL->body[jbody].arg[1].dot[0]
                + perm[1] * MODL->body[jbody].arg[2].dot[0]
                + perm[2] * MODL->body[jbody].arg[3].dot[0];
        ybegdot = perm[3] * MODL->body[jbody].arg[1].dot[0]
                + perm[4] * MODL->body[jbody].arg[2].dot[0]
                + perm[5] * MODL->body[jbody].arg[3].dot[0];
        zbegdot = perm[6] * MODL->body[jbody].arg[1].dot[0]
                + perm[7] * MODL->body[jbody].arg[2].dot[0]
                + perm[8] * MODL->body[jbody].arg[3].dot[0];

        xenddot = perm[0] * MODL->body[jbody].arg[4].dot[0]
                + perm[1] * MODL->body[jbody].arg[5].dot[0]
                + perm[2] * MODL->body[jbody].arg[6].dot[0];
        yenddot = perm[3] * MODL->body[jbody].arg[4].dot[0]
                + perm[4] * MODL->body[jbody].arg[5].dot[0]
                + perm[5] * MODL->body[jbody].arg[6].dot[0];
        zenddot = perm[6] * MODL->body[jbody].arg[4].dot[0]
                + perm[7] * MODL->body[jbody].arg[5].dot[0]
                + perm[8] * MODL->body[jbody].arg[6].dot[0];

        raddot  = MODL->body[jbody].arg[7].dot[0];

        dx = xend - xbeg;
        dy = yend - ybeg;
        dz = zend - zbeg;

        tht = atan2(dy, dx);                      /* -azimuth  from  xz plane */
        phi = atan2(dz, sqrt(dy*dy + dx*dx));     /* elevation above xy plane */
        len = sqrt(dx*dx + dy*dy + dz*dz);

        num = dy;
        den = dx;
        if (fabs(num) > EPS06 || fabs(den) > EPS06) {
            numdot = yenddot - ybegdot;
            dendot = xenddot - xbegdot;
            thtdot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            thtdot = 0;
        }

        num = dz;
        den = sqrt(dy*dy + dx*dx);
        if (fabs(den) > EPS06) {
            numdot = zenddot - zbegdot;
            dendot = (dx * (xenddot - xbegdot) + dy * (yenddot - ybegdot)) / den;
            phidot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            phidot = 0;
        }

        lendot = ( dx * (xenddot - xbegdot)
                 + dy * (yenddot - ybegdot)
                 + dz * (zenddot - zbegdot)) / len;

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            x1 = perm[0] * xyz_pnt[3*ipnt] + perm[1] * xyz_pnt[3*ipnt+1] + perm[2] * xyz_pnt[3*ipnt+2];
            y1 = perm[3] * xyz_pnt[3*ipnt] + perm[4] * xyz_pnt[3*ipnt+1] + perm[5] * xyz_pnt[3*ipnt+2];
            z1 = perm[6] * xyz_pnt[3*ipnt] + perm[7] * xyz_pnt[3*ipnt+1] + perm[8] * xyz_pnt[3*ipnt+2];

            /* move to origin */
            x2 = x1 - xbeg;
            y2 = y1 - ybeg;
            z2 = z1 - zbeg;

            /* rotate around z2 axis so that cylinder lies in (x3,z3) plane */
            x3 = x2 * cos(tht) + y2 * sin(tht);
            y3 = y2 * cos(tht) - x2 * sin(tht);
            z3 = z2;

            /* rotate around y3 axis so that cylinder lies along x3 axis */
            x4 = x3 * cos(phi) + z3 * sin(phi);
            y4 = y3;
            z4 = z3 * cos(phi) - x3 * sin(phi);

            /* cylindrical coordinates (x, r, theta) */
            x5 = x4;
            r5 = sqrt(y4*y4 + z4*z4);   /* rad5 */
            t5 = atan2(z4, y4);         /* theta5 */

            /* set velocities on the cylinder in its canonical orientation */
            x5dot = x5 / len * lendot;
            r5dot = r5 / rad * raddot;
            t5dot = 0;

            /* transform velocities back to original orientation */
            x4dot = x5dot;
            y4dot = r5dot * cos(t5)  - r5 * t5dot  * sin(t5);
            z4dot = r5dot * sin(t5)  + r5 * t5dot  * cos(t5);

            x3dot = x4dot * cos(phi) - x4 * phidot * sin(phi)
                  - z4dot * sin(phi) - z4 * phidot * cos(phi);
            y3dot = y4dot;
            z3dot = z4dot * cos(phi) - z4 * phidot * sin(phi)
                  + x4dot * sin(phi) + x4 * phidot * cos(phi);

            x2dot = x3dot * cos(tht) - x3 * thtdot * sin(tht)
                  - y3dot * sin(tht) - y3 * thtdot * cos(tht);
            y2dot = y3dot * cos(tht) - y3 * thtdot * sin(tht)
                  + x3dot * sin(tht) + x3 * thtdot * cos(tht);
            z2dot = z3dot;

            x1dot = x2dot + xbegdot;
            y1dot = y2dot + ybegdot;
            z1dot = z2dot + zbegdot;

            dxyz[3*ipnt  ] = perm[0] * x1dot + perm[3] * y1dot + perm[6] * z1dot;
            dxyz[3*ipnt+1] = perm[1] * x1dot + perm[4] * y1dot + perm[7] * z1dot;
            dxyz[3*ipnt+2] = perm[2] * x1dot + perm[5] * y1dot + perm[8] * z1dot;
        }

    /* get the velocities for a udprim */
    } else if (MODL->body[jbody].brtype == OCSM_UDPRIM) {
        SPRINT0(2, "        -> analytical for UDPRIM");

        /* load and execute the user-defined primitive */
        ibrch = MODL->body[jbody].ibrch;

        STRNCPY(primtype, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);

        status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
        if (status == EGADS_NOLOAD) {
            status = EGADS_SUCCESS;
        }
        CHECK_STATUS(udp_initialize);

        status = udp_clrArguments(primtype);
        CHECK_STATUS(udp_clrArguments);

        needfd = 0;

        /* go back to first associated udparg statement whose primtype matches the
           udprim's primtype */
        kbody = jbody - 1;
        while (kbody > 0 && MODL->body[kbody].brtype == OCSM_UDPARG &&
              strcmp(MODL->body[kbody].arg[1].str, MODL->body[jbody].arg[1].str) == 0) {
            kbody--;
        }
        kbody++;

        while (kbody <= jbody) {
            for (iarg = 3; iarg < 10; iarg+=2) {
                if (MODL->body[kbody].arg[iarg].nval < 0) break;

                if (MODL->body[kbody].arg[iarg].nval > 0) {
                    status = udp_setVelocity(MODL->body[kbody].arg[1].str,
                                             MODL->body[jbody].ebody,
                                             MODL->body[kbody].arg[iarg-1].str,
                                             MODL->body[kbody].arg[iarg  ].dot,
                                             MODL->body[kbody].arg[iarg  ].nval);
                    if (status != EGADS_SUCCESS) {
                        /* indexerr indicates that a variable is not available for sensitivity,
                           (for example an integer), so we will just get zeroes */
                        if (status == EGADS_INDEXERR) {
                            SPRINT2(1, "WARNING:: sensitivity cannot be computed for \"%s\" in %s (3)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* notfound indicates that a variable is not available for sensitivity,
                           so compute sensitivity by finite differences */
                        } else if (status == EGADS_NOTFOUND) {
                            if (MODL->perturb == NULL && MODL->dtime > 0) {
                                SPRINT2(2, "    creating perturbation for ibody=%d (because dtime=%15.10f)",
                                        ibody, MODL->dtime);

                                status = createPerturbation(MODL);
                                CHECK_STATUS(createPerturbation);
                            } else {
                                SPRINT2(1, "WARNING:: sensitivity cannot be computed for \"%s\" in %s (4)",
                                        MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                                (MODL->nwarn)++;
                            }
                            needfd++;
                        /* unknown error type */
                        } else {
                            needfd++;
                        }
                    }
                }
            }

            kbody++;
        }

        /* if any of the velocities could not be set, we need finite differences */
        if (needfd > 0) {
            SPRINT0(2, "        -> analytical derivaitives not available, so reverting to finiteDifferences");

            status = finiteDifference(MODL, ibody, OCSM_FACE, iface, npnt, uv, dxyz);
            CHECK_STATUS(finiteDifference);
            goto cleanup;
        }

        MALLOC(uvs, double, 2*npnt);

        if (uv == NULL) {
            for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                uvs[2*ipnt  ]  = uv_tess[2*ipnt  ];
                uvs[2*ipnt+1]  = uv_tess[2*ipnt+1];
            }
        } else {
            for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                uvs[2*ipnt  ]  = uv[     2*ipnt  ];
                uvs[2*ipnt+1]  = uv[     2*ipnt+1];
            }
        }

#ifndef EDGE_HIST_TRANSFORM

        /* scale uvs if the Face has an _scaleuv Attribute */
        status = EG_attributeRet(MODL->body[jbody].face[jface].eface, "_scaleuv",
                                 &attrtype, &attrlen, &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrtype == ATTRINT && attrlen == 1) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                uvs[2*ipnt  ] /= scale;
                uvs[2*ipnt+1] /= scale;
            }
        }
#else
        status = EG_getTopology(MODL->body[jbody].face[jface].eface, &eref, &oclass, &mtype,
                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        status = EG_getGeometry(eref, &oclass, &mtype, &rgeom, NULL, NULL);
        CHECK_STATUS(EG_getGeometry);

        if (oclass == SURFACE && mtype == PLANE) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                uvs[2*ipnt  ] /= scale;
                uvs[2*ipnt+1] /= scale;
            }
        }
#endif

        if (jface > 0) {
            status = udp_sensitivity(primtype, MODL->body[jbody].ebody,
                                     npnt, OCSM_FACE, jface, uvs, dxyz);
            CHECK_STATUS(udp_sensitivity);
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "cannot find Face %d:%d in jbody=%d", ibody, iface, jbody);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

    /* get the velocities for an extrusion */
    } else if (MODL->body[jbody].brtype == OCSM_EXTRUDE) {
        SPRINT0x(2, "        -> analytical for EXTRUDE");

        MALLOC(ts,   double,   npnt);
        MALLOC(tn,   double,   npnt);
        MALLOC(vels, double, 3*npnt);

        /* count number of Edges in isketch[0] */
        nedge = MODL->body[isketch[0]].nedge;

        /* analytical derivatives from Sketch */
        if (jface <= nedge) {
            iedge = jface;

            SPRINT1(2, "  (edge %d)", iedge);

            /* check to see if Edge is a line */
            kbody = MODL->body[jbody].ileft;
            status = EG_getTopology(MODL->body[kbody].edge[iedge].eedge, &eref, &oclass, &mtype,
                                    edgeData, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(eref, &oclass, &mtype, &rgeom, &iinfo, &rinfo);
            if (status != SUCCESS) {
                EG_free(iinfo);
                EG_free(rinfo);
            }
            CHECK_STATUS(EG_getGeometry);

            if (oclass == CURVE && mtype == LINE) {
                xa = rinfo[0];
                ya = rinfo[1];
                za = rinfo[2];
                xb = rinfo[0] + rinfo[3];
                yb = rinfo[1] + rinfo[4];
                zb = rinfo[2] + rinfo[5];

                EG_free(iinfo);
                EG_free(rinfo);

                for (ipnt = 0; ipnt < npnt; ipnt++) {

                    /* find the physical coordinates */
                    if (uv == NULL) {
                        status = EG_evaluate(MODL->body[jbody].face[jface].eface,
                                             &(uv_tess[2*ipnt]), data);
                    } else {
                        status = EG_evaluate(MODL->body[jbody].face[jface].eface,
                                             &(uv[2*ipnt]), data);
                    }
                    CHECK_STATUS(EG_evaluate);

                    xc = data[0];
                    yc = data[1];
                    zc = data[2];
                    xd = data[0] - MODL->body[jbody].arg[1].val[0];
                    yd = data[1] - MODL->body[jbody].arg[2].val[0];
                    zd = data[2] - MODL->body[jbody].arg[3].val[0];

                    /* find the intersection of the line along the Edge (t) and
                       a line from the point in the negative extrusion direction (s) */
                    A = (xc - xd) * (xc - xd) + (yc - yd) * (yc - yd) + (zc - zd) * (zc - zd);
                    B = (xb - xa) * (xc - xd) + (yb - ya) * (yc - yd) + (zb - za) * (zc - zd);
                    C = (xc - xa) * (xc - xd) + (yc - ya) * (yc - yd) + (zc - za) * (zc - zd);
                    D = (xb - xa) * (xc - xd) + (yb - ya) * (yc - yd) + (zb - za) * (zc - zd);
                    E = (xb - xa) * (xb - xa) + (yb - ya) * (yb - ya) + (zb - za) * (zb - za);
                    F = (xc - xa) * (xb - xa) + (yc - ya) * (yb - ya) + (zc - za) * (zb - za);

                    s = (C * E - F * B) / (A * E - D * B);
                    t = (A * F - D * C) / (A * E - D * B);

                    /* get velocities from the Edge */
                    status = velocityOfEdge(MODL, kbody, iedge, 1, &t, vels);
                    CHECK_STATUS(velocityOfEdge);

                    /* apply velocities to Face */
                    dxyz[3*ipnt  ] = vels[0] + s * MODL->body[jbody].arg[1].dot[0];
                    dxyz[3*ipnt+1] = vels[1] + s * MODL->body[jbody].arg[2].dot[0];
                    dxyz[3*ipnt+2] = vels[2] + s * MODL->body[jbody].arg[3].dot[0];
                }

            /* Edge is not a line, so we can just use mapped parametric coordinates */
            } else {
                EG_free(iinfo);
                EG_free(rinfo);

                status = EG_getRange(MODL->body[jbody].face[iedge].eface, trange, &periodic);
                CHECK_STATUS(EG_getRange);

                /* assume that jface=1 maps to iedge=1 in Sketch */
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    if (uv == NULL) {
                        ts[ipnt] = uv_tess[2*ipnt  ];
                        tn[ipnt] = uv_tess[2*ipnt+1];
                    } else {
                        ts[ipnt] = uv[     2*ipnt  ];
                        tn[ipnt] = uv[     2*ipnt+1];
                    }
                }

                /* get velocities from (the possibly-transformed) Sketch */
                kbody = MODL->body[jbody].ileft;
                status = velocityOfEdge(MODL, kbody, iedge, npnt, ts, vels);
                CHECK_STATUS(velocityOfEdge);

                /* apply velocities to Face */
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    frac = (tn[ipnt] - trange[3]) / (trange[2] - trange[3]);

                    dxyz[3*ipnt  ] = vels[3*ipnt  ] + frac * MODL->body[jbody].arg[1].dot[0];
                    dxyz[3*ipnt+1] = vels[3*ipnt+1] + frac * MODL->body[jbody].arg[2].dot[0];
                    dxyz[3*ipnt+2] = vels[3*ipnt+2] + frac * MODL->body[jbody].arg[3].dot[0];
                }
            }

        /* analytical derivatives for ends */
        } else if (jface == nedge+1) {
            kbody = isketch[0];
            SPRINT1(2, "  (beg [at Sketch %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the EXTRUDE) back to
               its corresponding location in kbody (the Sketch) */
            status = xformToOriginal(MODL, jbody, kbody, mat2);
            CHECK_STATUS(xformToOriginal);

           /* get velocity from Sketch (EXTRUDE beg) */
            if (MODL->body[kbody].nface == 1) {
                MALLOC(uvs, double, 2*npnt);

                if (uv == NULL) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv_tess[2*ipnt  ];
                        uvs[2*ipnt+1]  = uv_tess[2*ipnt+1];
                    }
                } else {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv[     2*ipnt  ];
                        uvs[2*ipnt+1]  = uv[     2*ipnt+1];
                    }
                }

                if (isplane == 1) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ] /= scale;
                        uvs[2*ipnt+1] /= scale;
                    }
                }

                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);

                FREE(uvs);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }
        } else if (jface == nedge+2) {
            kbody = isketch[0];
            SPRINT1(2, "  (end [at Sketch %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the EXTRUDE) back to
               its corresponding location in kbody (the Sketch) */
            status = xformToOriginal(MODL, jbody, kbody, mat2);
            CHECK_STATUS(xformToOriginal);

           /* get velocity from Sketch (EXTRUDE end) */
            if (MODL->body[kbody].nface == 1) {
                MALLOC(uvs, double, 2*npnt);

                if (uv == NULL) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv_tess[2*ipnt  ];
                        uvs[2*ipnt+1]  = uv_tess[2*ipnt+1];
                    }
                } else {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv[     2*ipnt  ];
                        uvs[2*ipnt+1]  = uv[     2*ipnt+1];
                    }
                }

                if (isplane == 1) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ] /= scale;
                        uvs[2*ipnt+1] /= scale;
                    }
                }

                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);

                FREE(uvs);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }

        } else {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        FREE(vels);
        FREE(tn  );
        FREE(ts  );

    /* get the velocities for a rule */
    } else if (MODL->body[jbody].brtype == OCSM_RULE) {
        SPRINT0(2, "        -> analytical for RULE");

        /* count number of Edges */
        nedge = MAX(MODL->body[isketch[0]].nedge,
                    MODL->body[isketch[1]].nedge);

        /* if the sensitivity is not present, make it now */
        if (MODL->body[jbody].sens == 0) {
            SPRINT1(2, "           creating RULE cache for jbody=%d", jbody);

            /* create array of Sketches */
            for (i = 0; i < nsketch; i++) {
                ebody   = MODL->body[isketch[i]].ebody;
                echilds = NULL;

                status = EG_getTopology(ebody, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                esketch[i] = NULL;
                if        (oclass == BODY && mtype == WIREBODY) {
                    status = EG_getBodyTopos(ebody, NULL, NODE, &nchild, &echilds);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (nchild == 1) {
                        esketch[i] = echilds[0];
                    } else {
                        EG_free(echilds);

                        status = EG_getBodyTopos(ebody, NULL, LOOP, &nchild, &echilds);
                        CHECK_STATUS(EG_getBodyTopos);

                        esketch[i] = echilds[0];
                    }
                } else if (oclass == BODY && (mtype == FACEBODY || mtype == SHEETBODY)) {
                    if (i == 0 || i == nsketch-1) {
                        status = EG_getBodyTopos(ebody, NULL, FACE, &nchild, &echilds);
                        CHECK_STATUS(EG_getBodyTopos);

                        esketch[i] = echilds[0];
                    } else {
                        status = EG_getBodyTopos(ebody, NULL, LOOP, &nchild, &echilds);
                        CHECK_STATUS(EG_getBodyTopos);

                        esketch[i] = echilds[0];
                    }
                }
                if (echilds != NULL) {
                    EG_free(echilds);
                }

                if (esketch[i] == NULL) {
                    status = -9999;
                    goto cleanup;
                }
            }

            /* compute data required to get design velocities */
            spl.isketch = isketch;
            spl.MODL    = MODL;

            splData.usrData           = &spl;
            splData.velocityOfRange   = NULL;
            splData.velocityOfNode    = &splineVelocityOfNode;
            splData.velocityOfEdge    = &splineVelocityOfEdge;
            splData.velocityOfBspline = NULL;

            /* reorder Loops to eliminate twisting */
            status = reorderLoops(MODL, nsketch, esketch, NINT(MODL->body[jbody].arg[1].val[0]));
            CHECK_STATUS(reorderLoops);

            status = EG_ruled_vels(nsketch, esketch, &splData, MODL->body[jbody].ebody);
            CHECK_STATUS(EG_ruled_vels);

            MODL->body[jbody].sens = 1;
        } else {
            SPRINT1(2, "           reusing  RULE cache for jbody=%d", jbody);
        }

        /* Face is one for which the EG_evaluate_dot works */
        if (jface <= nedge*(nsketch-1)) {
            SPRINT1(2, "  (jface %d)", jface);

            if (uv == NULL) {
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    status = EG_evaluate_dot(MODL->body[jbody].face[jface].eface,
                                             &(uv_tess[2*ipnt]), NULL, data, data_dot);
                    CHECK_STATUS(EG_evaluate_dot);

                    dxyz[3*ipnt  ] = data_dot[0];
                    dxyz[3*ipnt+1] = data_dot[1];
                    dxyz[3*ipnt+2] = data_dot[2];
                }
            } else {
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    status = EG_evaluate_dot(MODL->body[jbody].face[jface].eface,
                                             &(uv[2*ipnt]), NULL, data, data_dot);
                    CHECK_STATUS(EG_evaluate_dot);

                    dxyz[3*ipnt  ] = data_dot[0];
                    dxyz[3*ipnt+1] = data_dot[1];
                    dxyz[3*ipnt+2] = data_dot[2];
                }
            }

        /* analytical derivative for beg */
        } else if (jface == nedge*(nsketch-1)+1) {
            kbody = isketch[0];
            SPRINT1(2, "  (beg [at Sketch %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the RULE) back to
               its corresponding location in kbody (the original Sketch) */
            status = xformToOriginal(MODL, jbody, kbody, mat2);
            CHECK_STATUS(xformToOriginal);

           /* get velocity from Sketch (RULE beg) */
            if (MODL->body[kbody].nface == 1) {
                MALLOC(uvs, double, 2*npnt);

                if (uv == NULL) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv_tess[2*ipnt  ];
                        uvs[2*ipnt+1]  = uv_tess[2*ipnt+1];
                    }
                } else {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv[     2*ipnt  ];
                        uvs[2*ipnt+1]  = uv[     2*ipnt+1];
                    }
                }

                if (isplane == 1) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ] /= scale;
                        uvs[2*ipnt+1] /= scale;
                    }
                }

                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);

                FREE(uvs);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }

        /* analytical derivative for end */
        } else if (jface == nedge*(nsketch-1)+2) {
            kbody = isketch[nsketch-1];
            SPRINT1(2, "  (end [at Sketch %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the RULE) back to
               its corresponding location in kbody (the original Sketch) */
            status = xformToOriginal(MODL, jbody, kbody, mat2);
            CHECK_STATUS(xformToOriginal);

            /* get velocity from Sketch (RULE end) */
            if (MODL->body[kbody].nface == 1) {
                MALLOC(uvs, double, 2*npnt);

                if (uv == NULL) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv_tess[2*ipnt  ];
                        uvs[2*ipnt+1]  = uv_tess[2*ipnt+1];
                    }
                } else {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv[     2*ipnt  ];
                        uvs[2*ipnt+1]  = uv[     2*ipnt+1];
                    }
                }

                if (isplane == 1) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ] /= scale;
                        uvs[2*ipnt+1] /= scale;
                    }
                }

                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);

                FREE(uvs);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }
        } else {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

    /* get the velocities for a blend */
    } else if (MODL->body[jbody].brtype == OCSM_BLEND) {
        SPRINT0(2, "        -> analytical for BLEND");

        /* if the sensitivity is not present, make it now */
        if (MODL->body[jbody].sens == 0) {
            SPRINT1(2, "           creating BLEND cache for jbody=%d", jbody);

            /* create array of Sketches */
            for (i = 0; i < nsketch; i++) {
                ebody   = MODL->body[isketch[i]].ebody;
                echilds = NULL;

                status = EG_getTopology(ebody, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                esketch[i] = NULL;
                if        (oclass == BODY && mtype == WIREBODY) {
                    status = EG_getBodyTopos(ebody, NULL, NODE, &nchild, &echilds);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (nchild == 1) {
                        esketch[i] = echilds[0];
                    } else {
                        EG_free(echilds);

                        status = EG_getBodyTopos(ebody, NULL, LOOP, &nchild, &echilds);
                        CHECK_STATUS(EG_getBodyTopos);

                        esketch[i] = echilds[0];
                    }
                } else if (oclass == BODY && (mtype == FACEBODY || mtype == SHEETBODY)) {
                    if (i == 0 || i == nsketch-1) {
                        status = EG_getBodyTopos(ebody, NULL, FACE, &nchild, &echilds);
                        CHECK_STATUS(EG_getBodyTopos);

                        esketch[i] = echilds[0];
                    } else {
                        status = EG_getBodyTopos(ebody, NULL, LOOP, &nchild, &echilds);
                        CHECK_STATUS(EG_getBodyTopos);

                        esketch[i] = echilds[0];
                    }
                }
                if (echilds != NULL) {
                    EG_free(echilds);
                }

                if (esketch[i] == NULL) {
                    status = -9999;
                    goto cleanup;
                }
            }

            /* compute data required to get design velocities */
            if        (MODL->body[jbody].arg[1].nval >= 8) {
                Rbeg          = MODL->body[jbody].arg[1].val;
                Rbeg_dot      = MODL->body[jbody].arg[1].dot;
            } else if (MODL->body[jbody].arg[1].nval >= 4) {
                Rbeg          = MODL->body[jbody].arg[1].val;
                Rbeg_dot      = MODL->body[jbody].arg[1].dot;
            } else if (MODL->body[jbody].arg[1].nval >= 2) {
                Rbeg_local[0] = 0;
                Rbeg_local[1] = MODL->body[jbody].arg[1].val[1];
                Rbeg          = Rbeg_local;
                Rbeg_dot      = MODL->body[jbody].arg[1].dot;
            } else {
                Rbeg          = NULL;
                Rbeg_dot      = NULL;
            }

            if        (MODL->body[jbody].arg[2].nval >= 8) {
                Rend          = MODL->body[jbody].arg[2].val;
                Rend_dot      = MODL->body[jbody].arg[2].dot;
            } else if (MODL->body[jbody].arg[2].nval >= 4) {
                Rend          = MODL->body[jbody].arg[2].val;
                Rend_dot      = MODL->body[jbody].arg[2].dot;
            } else if (MODL->body[jbody].arg[2].nval >= 2) {
                Rend_local[0] = 0;
                Rend_local[1] = MODL->body[jbody].arg[2].val[1];
                Rend          = Rend_local;
                Rend_dot      = MODL->body[jbody].arg[2].dot;
            } else {
                Rend          = NULL;
                Rend_dot      = NULL;
            }

            spl.isketch = isketch;
            spl.MODL    = MODL;

            splData.usrData           = &spl;
            splData.velocityOfRange   = NULL;
            splData.velocityOfNode    = &splineVelocityOfNode;
            splData.velocityOfEdge    = &splineVelocityOfEdge;
            splData.velocityOfBspline = NULL;

            /* reorder Loops to eliminate twisting */
            status = reorderLoops(MODL, nsketch, esketch, NINT(MODL->body[jbody].arg[3].val[0]));
            CHECK_STATUS(reorderLoops);

            status = EG_blend_vels(nsketch, esketch, Rbeg, Rbeg_dot, Rend, Rend_dot,
                                   &splData, MODL->body[jbody].ebody);
            CHECK_STATUS(EG_blend_vels);

            MODL->body[jbody].sens = 1;
        } else {
            SPRINT1(2, "           reusing  BLEND cache for jbody=%d", jbody);
        }

        /* now that we have a good cache, determine the strip associated
           with iface */
        status = EG_attributeRet(MODL->body[jbody].face[jface].eface, ".blendStrip",
                                 &attrtype, &attrlen, &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);
        istrip = tempIlist[0];

        /* Face is one for which the EG_evaluate_dot works */
        if (istrip == -1 || istrip == -2 || istrip > 0) {
            SPRINT1(2, "  (strip %d)", istrip);

            if (uv == NULL) {
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    status = EG_evaluate_dot(MODL->body[jbody].face[jface].eface,
                                             &(uv_tess[2*ipnt]), NULL, data, data_dot);
                    CHECK_STATUS(EG_evaluate_dot);

                    dxyz[3*ipnt  ] = data_dot[0];
                    dxyz[3*ipnt+1] = data_dot[1];
                    dxyz[3*ipnt+2] = data_dot[2];
                }
            } else {
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    status = EG_evaluate_dot(MODL->body[jbody].face[jface].eface,
                                             &(uv[2*ipnt]), NULL, data, data_dot);
                    CHECK_STATUS(EG_evaluate_dot);

                    dxyz[3*ipnt  ] = data_dot[0];
                    dxyz[3*ipnt+1] = data_dot[1];
                    dxyz[3*ipnt+2] = data_dot[2];
                }
            }

        /* analytical derivative for beg */
        } else if (istrip == -3) {
            kbody = isketch[0];
            SPRINT1(2, "  (beg [at Sketch %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the BLEND) back to
               its corresponding location in kbody (the original Sketch) */
            status = xformToOriginal(MODL, jbody, kbody, mat2);
            CHECK_STATUS(xformToOriginal);

           /* get velocity from Sketch (BLEND beg) */
            if (MODL->body[kbody].nface == 1) {
                MALLOC(uvs, double, 2*npnt);

                if (uv == NULL) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv_tess[2*ipnt  ];
                        uvs[2*ipnt+1]  = uv_tess[2*ipnt+1];
                    }
                } else {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv[     2*ipnt  ];
                        uvs[2*ipnt+1]  = uv[     2*ipnt+1];
                    }
                }

                if (isplane == 1) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ] /= scale;
                        uvs[2*ipnt+1] /= scale;
                    }
                }

                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);

                FREE(uvs);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }

        /* analytical derivative for end */
        } else if (istrip == -4) {
            kbody = isketch[nsketch-1];
            SPRINT1(2, "  (end [at Sketch %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the BLEND) back to
               its corresponding location in kbody (the original Sketch) */
            status = xformToOriginal(MODL, jbody, kbody, mat2);
            CHECK_STATUS(xformToOriginal);

            /* get velocity from Sketch (BLEND end) */
            if (MODL->body[kbody].nface == 1) {
                MALLOC(uvs, double, 2*npnt);

                if (uv == NULL) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv_tess[2*ipnt  ];
                        uvs[2*ipnt+1]  = uv_tess[2*ipnt+1];
                    }
                } else {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ]  = uv[     2*ipnt  ];
                        uvs[2*ipnt+1]  = uv[     2*ipnt+1];
                    }
                }

                if (isplane == 1) {
                    for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                        uvs[2*ipnt  ] /= scale;
                        uvs[2*ipnt+1] /= scale;
                    }
                }

                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);

                FREE(uvs);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }
        } else {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

    /* unknown primitive type, so get velocities by finite differences */
    } else {
        SPRINT1(2, "        -> using finiteDifference (brtype=%s)",
                ocsmGetText(MODL->body[jbody].brtype));

        status = finiteDifference(MODL, ibody, OCSM_FACE, iface, npnt, uv, dxyz);
        CHECK_STATUS(finiteDifference);
        goto cleanup;
    }

    /* follow the children (up to the root) and modify the velocities
       for any OCSM_TRANSFORM that is visited */
    status = xformFaceVelocity(MODL, ibody, iface, npnt_tess, xyz_pnt2, npnt, dxyz);
    CHECK_STATUS(xformFaceVelocity);

cleanup:
    SPRINT6(2, " <- velocityOfFace(ibody=%3d, iface=%3d, npnt=%5d) -> %12.6f %12.6f %12.6f",
            ibody, iface, npnt, dxyz[0], dxyz[1], dxyz[2]);
    for (ipnt = 1; ipnt < MIN(3,npnt); ipnt++) {
        SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                dxyz[3*ipnt], dxyz[3*ipnt+1], dxyz[3*ipnt+2]);
    }

    FREE(xyz_pnt2);
    FREE(xyz_pnt );
    FREE(uvs);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   velocityOfNode - compute Node velocities analytically              *
 *                                                                      *
 ************************************************************************
 */

int
velocityOfNode(modl_T *MODL,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (bias-1) */
               int    inode,            /* (in)  Node index (bias-1) */
               double dxyz[])           /* (out) velocities (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iedge, jbody, kbody, jnode, knode, j, jbrch, oclass, mtype, nchild, *senses;
    int       nfaces, atype, alen, i;
    CINT      *tempIlist;
    double    tang[3], tang1[3], tang2[3], A[4], b[2], x[2], t;
    double    velo[3], velo1[3], velo2[3], trange[4];
    double    data[18], data_dot[18], data2[3], mat[12], ubar, vbar, wbar;
    double    dx, dy, dz, num, numdot, den, dendot, xyz_pnt[3];
    double    xbeg, xbegdot, ybeg, ybegdot, zbeg, zbegdot;
    double    xend, xenddot, yend, yenddot, zend, zenddot;
    double    xbase, xbasedot, ybase, ybasedot, zbase, zbasedot;
    double    xvrtx, xvrtxdot, yvrtx, yvrtxdot, zvrtx, zvrtxdot, rad, raddot;
    double    tht, thtdot, phi, phidot, len, lendot, psi, psidot;
    double    x1, x1dot, y1, y1dot, z1, z1dot;
    double    x2, x2dot, y2, y2dot, z2, z2dot;
    double    x3, x3dot, y3, y3dot, z3, z3dot;
    double    x4, x4dot, y4, y4dot, z4, z4dot;
    double    x5, x5dot, r5, r5dot, t5, t5dot, s5, s5dot;
    double    perm[9];
    double    *uvs=NULL;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;
    ego       eref, *echilds, *efaces;

    int       ibrch, iarg, udp_num, *udp_types, *udp_idef, needfd;
    double    *udp_ddef;
    char      **udp_names, primtype[MAX_EXPR_LEN];

    ROUTINE(velocityOfNode);

    /* --------------------------------------------------------------- */

    SPRINT2(2, " -> velocityOfNode(ibody=%d, inode=%d)", ibody, inode);

    if        (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    } else if (inode < 1 || inode > MODL->body[ibody].nnode) {
        status = OCSM_NODE_NOT_FOUND;
        goto cleanup;
    }

    /* if there is an active perturbation, get velocity by finite
       differences */
    if (MODL->perturb != NULL) {
        status = finiteDifference(MODL, ibody, OCSM_NODE, inode, 1, NULL, dxyz);
        CHECK_STATUS(finiteDifference);

        goto cleanup;
    }

    /* if the Node is supported by only one Edge, get the velocity
       from the Edge */
    if (MODL->body[ibody].node[inode].nedge == 1) {
//$$$        /* how did we get here??? sketches are finite differenced and BOX and udpBox are differentiated */
        SPRINT0(0, "ERROR:: found Node that is supported by only one Edge");
        SPRINT3(0, "        body[%d].node[%d].nedge=%d", ibody, inode, MODL->body[ibody].node[inode].nedge);
        status = OCSM_UNKNOWN;
        goto cleanup;
    }

    /* if the Node was generated by an OCSM_BOOLEAN or an OCSM_GROWN,
       the velocity can be obtained from Edge velocities */
    jbody = MODL->body[ibody].node[inode].ibody;
    jbrch = MODL->body[jbody].ibrch;

    /* jbody is the Body in which this Node first appeared */
    jbody = MODL->body[ibody].node[inode].ibody;

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    status = xformToOriginal(MODL, ibody, jbody, mat);
    CHECK_STATUS(xformToOriginal);

    /* xyz_pnt is the Node location transformed back
       to the its location in jbody */
    xyz_pnt[0] = MODL->body[ibody].node[inode].x * mat[ 0]
               + MODL->body[ibody].node[inode].y * mat[ 1]
               + MODL->body[ibody].node[inode].z * mat[ 2] + mat[ 3];
    xyz_pnt[1] = MODL->body[ibody].node[inode].x * mat[ 4]
               + MODL->body[ibody].node[inode].y * mat[ 5]
               + MODL->body[ibody].node[inode].z * mat[ 6] + mat[ 7];
    xyz_pnt[2] = MODL->body[ibody].node[inode].x * mat[ 8]
               + MODL->body[ibody].node[inode].y * mat[ 9]
               + MODL->body[ibody].node[inode].z * mat[10] + mat[11];

    /* find the Node in jbody that maps to Node inode in ibody */
    if (jbody == ibody) {
        jnode = inode;
    } else {
        jnode = -1;
        for (knode = 1; knode <= MODL->body[jbody].nnode; knode++) {
            if (fabs(MODL->body[jbody].node[knode].x-xyz_pnt[0]) < EPS06 &&
                fabs(MODL->body[jbody].node[knode].y-xyz_pnt[1]) < EPS06 &&
                fabs(MODL->body[jbody].node[knode].z-xyz_pnt[2]) < EPS06   ) {
                jnode = knode;
                break;
            }
        }
    }

    /* if the are _dots associated with this Node, use them */
    if (jnode > 0 && EG_hasGeometry_dot(MODL->body[jbody].node[jnode].enode) == EGADS_SUCCESS) {

        /* evaluate the points and sensitivity */
        status = EG_evaluate_dot(MODL->body[jbody].node[jnode].enode, NULL, NULL, data, data_dot);
        CHECK_STATUS(EG_evaluate_dot);

        dxyz[0] = data_dot[0];
        dxyz[1] = data_dot[1];
        dxyz[2] = data_dot[2];

        /* find the history for one of the adjoining Faces */
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].node[inode].enode, FACE,
                                 &nfaces, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_attributeRet(efaces[0], "_hist", &atype, &alen,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        EG_free(efaces);

        /* transform the velocities */
        for (i = 0; i < alen; i++) {
            if (tempIlist[i] > jbody) {
                status = xformVelocity(MODL, tempIlist[i], 1, xyz_pnt, 1, dxyz);
                CHECK_STATUS(xformVelocity);
            }
        }

        goto cleanup;
    }

    /* if the Node was generated by an OCSM_BOOLEAN or OCSM_GROWN,
       the velocity can be obtained from Edge velocities */
    if (MODL->brch[jbrch].bclass == OCSM_BOOLEAN ||
        MODL->brch[jbrch].bclass == OCSM_GROWN     ) {

        velo1[0] = velo1[1] = velo1[2] = 0;
        tang1[0] = tang1[1] = tang1[2] = 0;

        /* find two non-parallel Edges */
        j = 0;
        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            if (MODL->body[ibody].edge[iedge].ibeg == inode ||
                MODL->body[ibody].edge[iedge].iend == inode   ) {

                status = EG_getTopology(MODL->body[ibody].edge[iedge].eedge,
                                        &eref, &oclass, &mtype,
                                        trange, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (mtype == DEGENERATE) continue;

                if (MODL->body[ibody].edge[iedge].ibeg == inode) {
                    t = trange[0];
                } else {
                    t = trange[1];
                }

                /* velocity normal to Edge */
                status = velocityOfEdge(MODL, ibody, iedge, 1, &t, velo);
                CHECK_STATUS(velocityOfEdge);

                /* normalize tangent such that largest element is one */
                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, &t, data);
                CHECK_STATUS(EG_evaluate);

                /* if the slope we get is zero (which may happen at a C0 junction
                   in a blend), step a little away from the actual Node */
                if (fabs(data[3]) < EPS12 && fabs(data[4]) < EPS12 && fabs(data[5]) < EPS12) {
                    if (MODL->body[ibody].edge[iedge].ibeg == inode) {
                        t = 0.999 * trange[0] + 0.001 * trange[1];
                    } else {
                        t = 0.001 * trange[0] + 0.999 * trange[1];
                    }

                    status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, &t, data);
                    CHECK_STATUS(EG_evaluate);
                }

                if (fabs(data[3]) < EPS12 && fabs(data[4]) < EPS12 && fabs(data[5]) < EPS12) {
                    signalError(MODL, OCSM_INTERNAL_ERROR,
                                "cannot compute velocity of Node %d:%d", ibody, inode);
                    goto cleanup;
                } else if (fabs(data[3]) >= MAX(fabs(data[4]), fabs(data[5]))) {
                    tang[0] = 1;
                    tang[1] = data[4] / data[3];
                    tang[2] = data[5] / data[3];
                } else if (fabs(data[4]) >= fabs(data[5])) {
                    tang[0] = data[3] / data[4];
                    tang[1] = 1;
                    tang[2] = data[5] / data[4];
                } else {
                    tang[0] = data[3] / data[5];
                    tang[1] = data[4] / data[5];
                    tang[2] = 1;
                }

                /* first Edge */
                if        (j == 0) {
                    tang1[0] = tang[0];
                    tang1[1] = tang[1];
                    tang1[2] = tang[2];
                    velo1[0] = velo[0];
                    velo1[1] = velo[1];
                    velo1[2] = velo[2];
                    j++;

                /* second Edge */
                } else if (j == 1) {
                    tang2[0] = tang[0];
                    tang2[1] = tang[1];
                    tang2[2] = tang[2];
                    velo2[0] = velo[0];
                    velo2[1] = velo[1];
                    velo2[2] = velo[2];

                    /* process second Edge if not parallel to first Edge */
                    if (fabs(tang1[0]-tang2[0]) > EPS03 ||
                        fabs(tang1[1]-tang2[1]) > EPS03 ||
                        fabs(tang1[2]-tang2[2]) > EPS03   ) {

                        /* minimize (velo1+x[0]*tang1) - (velo2+x[1]*tang2) */
                        A[0] =   tang1[0]*tang1[0] + tang1[1]*tang1[1] + tang1[2]*tang1[2];
                        A[1] = - tang1[0]*tang2[0] - tang1[1]*tang2[1] - tang1[2]*tang2[2];
                        A[2] = - tang2[0]*tang1[0] - tang2[1]*tang1[1] - tang2[2]*tang1[2];
                        A[3] =   tang2[0]*tang2[0] + tang2[1]*tang2[1] + tang2[2]*tang2[2];

                        b[0] = (velo2[0]-velo1[0]) * tang1[0]
                             + (velo2[1]-velo1[1]) * tang1[1]
                             + (velo2[2]-velo1[2]) * tang1[2];
                        b[1] = (velo1[0]-velo2[0]) * tang2[0]
                             + (velo1[1]-velo2[1]) * tang2[1]
                             + (velo1[2]-velo2[2]) * tang2[2];

                        status = matsol(A, b, 2, x);
                        CHECK_STATUS(matsol);

                        /* reconstruct velocity by velo+x[0]*tang1 */
                        dxyz[0] = velo1[0] + x[0] * tang1[0];
                        dxyz[1] = velo1[1] + x[0] * tang1[1];
                        dxyz[2] = velo1[2] + x[0] * tang1[2];

                        goto cleanup;
                    }
                }
            }
        }

        /* getting here means that we did not find two non-parallel Edges,
           so just return the (local) Edge velocity */
        SPRINT0(2, "WARNING:: could not find two non-parallel Edges");
        (MODL->nwarn)++;

        dxyz[0] = velo1[0];
        dxyz[1] = velo1[1];
        dxyz[2] = velo1[2];

        goto cleanup;
    }

    /* if the .dots are all zero, then the velocities are 0 (and do not
       bother computing the derivatives below) */
    if (MODL->body[jbody].hasdots == 0) {
        SPRINT0(2, "        -> setting to zero");
        dxyz[0] = 0;
        dxyz[1] = 0;
        dxyz[2] = 0;

    /* get the velocities for a point */
    } else if (MODL->body[jbody].brtype == OCSM_POINT) {
        SPRINT0(2, "        -> analytical for POINT");

        dxyz[0] = MODL->body[jbody].arg[1].dot[0];
        dxyz[1] = MODL->body[jbody].arg[2].dot[0];
        dxyz[2] = MODL->body[jbody].arg[3].dot[0];

    /* get the velocities for a box */
    } else if (MODL->body[jbody].brtype == OCSM_BOX) {
        SPRINT0(2, "        -> analytical for BOX");

        data2[0] = xyz_pnt[0];
        data2[1] = xyz_pnt[1];
        data2[2] = xyz_pnt[2];

        if (fabs(MODL->body[jbody].arg[4].val[0]) > EPS06) {
            ubar = (data2[0] - MODL->body[jbody].arg[1].val[0]) / MODL->body[jbody].arg[4].val[0];
        } else {
            ubar = 0;
        }
        if (fabs(MODL->body[jbody].arg[5].val[0]) > EPS06) {
            vbar = (data2[1] - MODL->body[jbody].arg[2].val[0]) / MODL->body[jbody].arg[5].val[0];
        } else {
            vbar = 0;
        }
        if (fabs(MODL->body[jbody].arg[6].val[0]) > EPS06) {
            wbar = (data2[2] - MODL->body[jbody].arg[3].val[0]) / MODL->body[jbody].arg[6].val[0];
        } else {
            wbar = 0;
        }

        dxyz[0] = MODL->body[jbody].arg[1].dot[0] + MODL->body[jbody].arg[4].dot[0] * ubar;
        dxyz[1] = MODL->body[jbody].arg[2].dot[0] + MODL->body[jbody].arg[5].dot[0] * vbar;
        dxyz[2] = MODL->body[jbody].arg[3].dot[0] + MODL->body[jbody].arg[6].dot[0] * wbar;

    /* get the velocities for a sphere */
    } else if (MODL->body[jbody].brtype == OCSM_SPHERE) {
        SPRINT0(2, "        -> analytical for SPHERE");

        data2[ 0] = xyz_pnt[0];
        data2[ 1] = xyz_pnt[1];
        data2[ 2] = xyz_pnt[2];

        ubar = (data2[0] - MODL->body[jbody].arg[1].val[0]) / MODL->body[jbody].arg[4].val[0];
        vbar = (data2[1] - MODL->body[jbody].arg[2].val[0]) / MODL->body[jbody].arg[4].val[0];
        wbar = (data2[2] - MODL->body[jbody].arg[3].val[0]) / MODL->body[jbody].arg[4].val[0];

        dxyz[0] = MODL->body[jbody].arg[1].dot[0] + MODL->body[jbody].arg[4].dot[0] * ubar;
        dxyz[1] = MODL->body[jbody].arg[2].dot[0] + MODL->body[jbody].arg[4].dot[0] * vbar;
        dxyz[2] = MODL->body[jbody].arg[3].dot[0] + MODL->body[jbody].arg[4].dot[0] * wbar;

    /* get the velocities for a cone */
    } else if (MODL->body[jbody].brtype == OCSM_CONE) {
        SPRINT0(2, "        analytical for CONE");

        dx = MODL->body[jbody].arg[4].val[0] - MODL->body[jbody].arg[1].val[0];
        dy = MODL->body[jbody].arg[5].val[0] - MODL->body[jbody].arg[2].val[0];
        dz = MODL->body[jbody].arg[6].val[0] - MODL->body[jbody].arg[3].val[0];

        /* permute the coordinates so that fabs(dx) is largest */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            perm[0] = 1;  perm[1] = 0;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 1;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 0;  perm[8] = 1;
        } else if (fabs(dy) >= fabs(dz)) {
            perm[0] = 0;  perm[1] = 1;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 0;  perm[5] = 1;
            perm[6] = 1;  perm[7] = 0;  perm[8] = 0;
        } else {
            perm[0] = 0;  perm[1] = 0;  perm[2] = 1;
            perm[3] = 1;  perm[4] = 0;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 1;  perm[8] = 0;
        }

        xvrtx = perm[0] * MODL->body[jbody].arg[1].val[0]
              + perm[1] * MODL->body[jbody].arg[2].val[0]
              + perm[2] * MODL->body[jbody].arg[3].val[0];
        yvrtx = perm[3] * MODL->body[jbody].arg[1].val[0]
              + perm[4] * MODL->body[jbody].arg[2].val[0]
              + perm[5] * MODL->body[jbody].arg[3].val[0];
        zvrtx = perm[6] * MODL->body[jbody].arg[1].val[0]
              + perm[7] * MODL->body[jbody].arg[2].val[0]
              + perm[8] * MODL->body[jbody].arg[3].val[0];

        xbase = perm[0] * MODL->body[jbody].arg[4].val[0]
              + perm[1] * MODL->body[jbody].arg[5].val[0]
              + perm[2] * MODL->body[jbody].arg[6].val[0];
        ybase = perm[3] * MODL->body[jbody].arg[4].val[0]
              + perm[4] * MODL->body[jbody].arg[5].val[0]
              + perm[5] * MODL->body[jbody].arg[6].val[0];
        zbase = perm[6] * MODL->body[jbody].arg[4].val[0]
              + perm[7] * MODL->body[jbody].arg[5].val[0]
              + perm[8] * MODL->body[jbody].arg[6].val[0];

        rad  = MODL->body[jbody].arg[7].val[0];

        xvrtxdot = perm[0] * MODL->body[jbody].arg[1].dot[0]
                 + perm[1] * MODL->body[jbody].arg[2].dot[0]
                 + perm[2] * MODL->body[jbody].arg[3].dot[0];
        yvrtxdot = perm[3] * MODL->body[jbody].arg[1].dot[0]
                 + perm[4] * MODL->body[jbody].arg[2].dot[0]
                 + perm[5] * MODL->body[jbody].arg[3].dot[0];
        zvrtxdot = perm[6] * MODL->body[jbody].arg[1].dot[0]
                 + perm[7] * MODL->body[jbody].arg[2].dot[0]
                 + perm[8] * MODL->body[jbody].arg[3].dot[0];

        xbasedot = perm[0] * MODL->body[jbody].arg[4].dot[0]
                 + perm[1] * MODL->body[jbody].arg[5].dot[0]
                 + perm[2] * MODL->body[jbody].arg[6].dot[0];
        ybasedot = perm[3] * MODL->body[jbody].arg[4].dot[0]
                 + perm[4] * MODL->body[jbody].arg[5].dot[0]
                 + perm[5] * MODL->body[jbody].arg[6].dot[0];
        zbasedot = perm[6] * MODL->body[jbody].arg[4].dot[0]
                 + perm[7] * MODL->body[jbody].arg[5].dot[0]
                 + perm[8] * MODL->body[jbody].arg[6].dot[0];

        raddot  = MODL->body[jbody].arg[7].dot[0];

        dx = xbase - xvrtx;
        dy = ybase - yvrtx;
        dz = zbase - zvrtx;

        tht = atan2(dy, dx);
        phi = atan2(dz, sqrt(dy*dy + dx*dx));
        len = sqrt(dx*dx + dy*dy + dz*dz);
        psi = atan2(rad, len);

        num = dy;
        den = dx;
        if (fabs(num) > EPS06 || fabs(den) > EPS06) {
            numdot = ybasedot - yvrtxdot;
            dendot = xbasedot - xvrtxdot;
            thtdot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            thtdot = 0;
        }

        num = dz;
        den = sqrt(dy*dy + dx*dx);
        if (fabs(den) > EPS06) {
            numdot = zbasedot - zvrtxdot;
            dendot = (dx * (xbasedot - xvrtxdot) + dy * (ybasedot - yvrtxdot)) / den;
            phidot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            phidot = 0;
        }

        lendot = ( dx * (xbasedot - xvrtxdot)
                 + dy * (ybasedot - yvrtxdot)
                 + dz * (zbasedot - zvrtxdot)) / len;

        psidot = (len * raddot - lendot * rad) / (len * len * rad * rad);

        x1 = perm[0] * xyz_pnt[0] + perm[1] * xyz_pnt[1] + perm[2] * xyz_pnt[2];
        y1 = perm[3] * xyz_pnt[0] + perm[4] * xyz_pnt[1] + perm[5] * xyz_pnt[2];
        z1 = perm[6] * xyz_pnt[0] + perm[7] * xyz_pnt[1] + perm[8] * xyz_pnt[2];

        /* move to origin */
        x2 = x1 - xvrtx;
        y2 = y1 - yvrtx;
        z2 = z1 - zvrtx;

        /* rotate around z2 axis so that cone lies in (x3,z3) plane */
        x3 = x2 * cos(tht) + y2 * sin(tht);
        y3 = y2 * cos(tht) - x2 * sin(tht);
        z3 = z2;

        /* rotate around y3 axis so that cone lies along x3 axis */
        x4 = x3 * cos(phi) + z3 * sin(phi);
        y4 = y3;
        z4 = z3 * cos(phi) - x3 * sin(phi);

        /* conical coordinates (x, psi, theta) */
        x5 = x4;
        s5 = atan2(sqrt(y4*y4 + z4*z4), x4);   /* psi5 */
        t5 = atan2(z4, y4);                    /* theta5 */

        /* set velocities on the cone in its canonical orientation */
        x5dot = x5 / len * lendot;
        t5dot = 0;
        s5dot = s5 / psi * psidot;

        /* transform velocities back to original orientation */
        x4dot = x5dot;
        y4dot = x5dot * cos(t5)       * tan(s5)
              + s5dot * cos(t5)  * x5 / cos(s5) / cos(s5)
              - t5dot * sin(t5)  * x5 * tan(s5);
        z4dot = x5dot * sin(t5)       * tan(s5)
              + s5dot * sin(t5)  * x5 / cos(s5) / cos(s5)
              + t5dot * cos(t5)  * x5 * tan(s5);

        x3dot = x4dot * cos(phi) - x4 * phidot * sin(phi)
              - z4dot * sin(phi) - z4 * phidot * cos(phi);
        y3dot = y4dot;
        z3dot = z4dot * cos(phi) - z4 * phidot * sin(phi)
              + x4dot * sin(phi) + x4 * phidot * cos(phi);

        x2dot = x3dot * cos(tht) - x3 * thtdot * sin(tht)
              - y3dot * sin(tht) - y3 * thtdot * cos(tht);
        y2dot = y3dot * cos(tht) - y3 * thtdot * sin(tht)
              + x3dot * sin(tht) + x3 * thtdot * cos(tht);
        z2dot = z3dot;

        x1dot = x2dot + xvrtxdot;
        y1dot = y2dot + yvrtxdot;
        z1dot = z2dot + zvrtxdot;

        dxyz[0] = perm[0] * x1dot + perm[3] * y1dot + perm[6] * z1dot;
        dxyz[1] = perm[1] * x1dot + perm[4] * y1dot + perm[7] * z1dot;
        dxyz[2] = perm[2] * x1dot + perm[5] * y1dot + perm[8] * z1dot;

    /* get the velocities for a cylinder */
    } else if (MODL->body[jbody].brtype == OCSM_CYLINDER) {
        SPRINT0(2, "        -> analytical for CYLINDER");

        dx = MODL->body[jbody].arg[4].val[0] - MODL->body[jbody].arg[1].val[0];
        dy = MODL->body[jbody].arg[5].val[0] - MODL->body[jbody].arg[2].val[0];
        dz = MODL->body[jbody].arg[6].val[0] - MODL->body[jbody].arg[3].val[0];

        /* permute the coordinates so that fabs(dx) is largest */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            perm[0] = 1;  perm[1] = 0;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 1;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 0;  perm[8] = 1;
        } else if (fabs(dy) >= fabs(dz)) {
            perm[0] = 0;  perm[1] = 1;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 0;  perm[5] = 1;
            perm[6] = 1;  perm[7] = 0;  perm[8] = 0;
        } else {
            perm[0] = 0;  perm[1] = 0;  perm[2] = 1;
            perm[3] = 1;  perm[4] = 0;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 1;  perm[8] = 0;
        }

        xbeg = perm[0] * MODL->body[jbody].arg[1].val[0]
             + perm[1] * MODL->body[jbody].arg[2].val[0]
             + perm[2] * MODL->body[jbody].arg[3].val[0];
        ybeg = perm[3] * MODL->body[jbody].arg[1].val[0]
             + perm[4] * MODL->body[jbody].arg[2].val[0]
             + perm[5] * MODL->body[jbody].arg[3].val[0];
        zbeg = perm[6] * MODL->body[jbody].arg[1].val[0]
             + perm[7] * MODL->body[jbody].arg[2].val[0]
             + perm[8] * MODL->body[jbody].arg[3].val[0];

        xend = perm[0] * MODL->body[jbody].arg[4].val[0]
             + perm[1] * MODL->body[jbody].arg[5].val[0]
             + perm[2] * MODL->body[jbody].arg[6].val[0];
        yend = perm[3] * MODL->body[jbody].arg[4].val[0]
             + perm[4] * MODL->body[jbody].arg[5].val[0]
             + perm[5] * MODL->body[jbody].arg[6].val[0];
        zend = perm[6] * MODL->body[jbody].arg[4].val[0]
             + perm[7] * MODL->body[jbody].arg[5].val[0]
             + perm[8] * MODL->body[jbody].arg[6].val[0];

        rad  = MODL->body[jbody].arg[7].val[0];

        xbegdot = perm[0] * MODL->body[jbody].arg[1].dot[0]
                + perm[1] * MODL->body[jbody].arg[2].dot[0]
                + perm[2] * MODL->body[jbody].arg[3].dot[0];
        ybegdot = perm[3] * MODL->body[jbody].arg[1].dot[0]
                + perm[4] * MODL->body[jbody].arg[2].dot[0]
                + perm[5] * MODL->body[jbody].arg[3].dot[0];
        zbegdot = perm[6] * MODL->body[jbody].arg[1].dot[0]
                + perm[7] * MODL->body[jbody].arg[2].dot[0]
                + perm[8] * MODL->body[jbody].arg[3].dot[0];

        xenddot = perm[0] * MODL->body[jbody].arg[4].dot[0]
                + perm[1] * MODL->body[jbody].arg[5].dot[0]
                + perm[2] * MODL->body[jbody].arg[6].dot[0];
        yenddot = perm[3] * MODL->body[jbody].arg[4].dot[0]
                + perm[4] * MODL->body[jbody].arg[5].dot[0]
                + perm[5] * MODL->body[jbody].arg[6].dot[0];
        zenddot = perm[6] * MODL->body[jbody].arg[4].dot[0]
                + perm[7] * MODL->body[jbody].arg[5].dot[0]
                + perm[8] * MODL->body[jbody].arg[6].dot[0];

        raddot  = MODL->body[jbody].arg[7].dot[0];

        dx = xend - xbeg;
        dy = yend - ybeg;
        dz = zend - zbeg;

        tht = atan2(dy, dx);                      /* -azimuth  from  xz plane */
        phi = atan2(dz, sqrt(dy*dy + dx*dx));     /* elevation above xy plane */
        len = sqrt(dx*dx + dy*dy + dz*dz);

        num = dy;
        den = dx;
        if (fabs(num) > EPS06 || fabs(den) > EPS06) {
            numdot = yenddot - ybegdot;
            dendot = xenddot - xbegdot;
            thtdot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            thtdot = 0;
        }

        num = dz;
        den = sqrt(dy*dy + dx*dx);
        if (fabs(den) > EPS06) {
            numdot = zenddot - zbegdot;
            dendot = (dx * (xenddot - xbegdot) + dy * (yenddot - ybegdot)) / den;
            phidot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            phidot = 0;
        }

        lendot = ( dx * (xenddot - xbegdot)
                 + dy * (yenddot - ybegdot)
                 + dz * (zenddot - zbegdot)) / len;

        x1 = perm[0] * xyz_pnt[0] + perm[1] * xyz_pnt[1] + perm[2] * xyz_pnt[2];
        y1 = perm[3] * xyz_pnt[0] + perm[4] * xyz_pnt[1] + perm[5] * xyz_pnt[2];
        z1 = perm[6] * xyz_pnt[0] + perm[7] * xyz_pnt[1] + perm[8] * xyz_pnt[2];

        /* move to origin */
        x2 = x1 - xbeg;
        y2 = y1 - ybeg;
        z2 = z1 - zbeg;

        /* rotate around z2 axis so that cylinder lies in (x3,z3) plane */
        x3 = x2 * cos(tht) + y2 * sin(tht);
        y3 = y2 * cos(tht) - x2 * sin(tht);
        z3 = z2;

        /* rotate around y3 axis so that cylinder lies along x3 axis */
        x4 = x3 * cos(phi) + z3 * sin(phi);
        y4 = y3;
        z4 = z3 * cos(phi) - x3 * sin(phi);

        /* cylindrical coordinates (x, r, theta) */
        x5 = x4;
        r5 = sqrt(y4*y4 + z4*z4);   /* rad5 */
        t5 = atan2(z4, y4);         /* theta5 */

        /* set velocities on the cylinder in its canonical orientation */
        x5dot = x5 / len * lendot;
        r5dot = r5 / rad * raddot;
        t5dot = 0;

        /* transform velocities back to original orientation */
        x4dot = x5dot;
        y4dot = r5dot * cos(t5)  - r5 * t5dot  * sin(t5);
        z4dot = r5dot * sin(t5)  + r5 * t5dot  * cos(t5);

        x3dot = x4dot * cos(phi) - x4 * phidot * sin(phi)
              - z4dot * sin(phi) - z4 * phidot * cos(phi);
        y3dot = y4dot;
        z3dot = z4dot * cos(phi) - z4 * phidot * sin(phi)
              + x4dot * sin(phi) + x4 * phidot * cos(phi);

        x2dot = x3dot * cos(tht) - x3 * thtdot * sin(tht)
              - y3dot * sin(tht) - y3 * thtdot * cos(tht);
        y2dot = y3dot * cos(tht) - y3 * thtdot * sin(tht)
              + x3dot * sin(tht) + x3 * thtdot * cos(tht);
        z2dot = z3dot;

        x1dot = x2dot + xbegdot;
        y1dot = y2dot + ybegdot;
        z1dot = z2dot + zbegdot;

        dxyz[0] = perm[0] * x1dot + perm[3] * y1dot + perm[6] * z1dot;
        dxyz[1] = perm[1] * x1dot + perm[4] * y1dot + perm[7] * z1dot;
        dxyz[2] = perm[2] * x1dot + perm[5] * y1dot + perm[8] * z1dot;

    /* get the velocity for a udprim */
    } else if (MODL->body[jbody].brtype == OCSM_UDPRIM) {
        SPRINT0(2, "        -> analytical for UDPRIM");

        /* load and execute the user-defined primitive */
        ibrch = MODL->body[jbody].ibrch;

        STRNCPY(primtype, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);

        status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
        if (status == EGADS_NOLOAD) {
            status = EGADS_SUCCESS;
        }
        CHECK_STATUS(udp_initialize);

        status = udp_clrArguments(primtype);
        CHECK_STATUS(udp_clrArguments);

        needfd = 0;

        /* go back to first associated udparg statement whose primtype matches the
           udprim's primtype */
        kbody = jbody - 1;
        while (kbody > 0 && MODL->body[kbody].brtype == OCSM_UDPARG &&
               strcmp(MODL->body[kbody].arg[1].str, MODL->body[jbody].arg[1].str) == 0 ) {
            kbody--;
        }
        kbody++;

        while (kbody <= jbody) {
            for (iarg = 3; iarg < 10; iarg+=2) {
                if (MODL->body[kbody].arg[iarg].nval < 0) break;

                if (MODL->body[kbody].arg[iarg].nval > 0) {
                    status = udp_setVelocity(MODL->body[kbody].arg[1].str,
                                             MODL->body[jbody].ebody,
                                             MODL->body[kbody].arg[iarg-1].str,
                                             MODL->body[kbody].arg[iarg  ].dot,
                                             MODL->body[kbody].arg[iarg  ].nval);
                    if (status != EGADS_SUCCESS) {
                        /* indexerr indicates that a variable is not available for sensitivity,
                           (for example an integer), so we will just get zeroes */
                        if (status == EGADS_INDEXERR) {
                            SPRINT2(1, "WARNING:: sensitivity cannot be computed for \"%s\" in %s (5)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* notfound indicates that a variable is not available for sensitivity,
                           so compute sensitivity by finite differences */
                        } else if (status == EGADS_NOTFOUND) {
                            if (MODL->perturb == NULL && MODL->dtime > 0) {
                                SPRINT2(2, "    creating perturbation for ibody=%d (because dtime=%15.10f)",
                                        ibody, MODL->dtime);

                                status = createPerturbation(MODL);
                                CHECK_STATUS(createPerturbation);
                            } else {
                                SPRINT2(1, "WARNING:: sensitivity cannot be computed for \"%s\" in %s (6)",
                                        MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                                (MODL->nwarn)++;
                            }
                            needfd++;
                        /* unknown error type */
                        } else {
                            needfd++;
                        }
                    }
                }
            }

            kbody++;
        }

        /* if any of the velocities could not be set, we need finite differences */
        if (needfd > 0) {
            SPRINT0(2, "        -> analytical derivaitives not available, so reverting to finiteDifferences");

            status = finiteDifference(MODL, ibody, OCSM_NODE, inode, 1, &t, dxyz);
            CHECK_STATUS(finiteDifference);
            goto cleanup;
        }

        /* find the Node in jbody that maps to Node inode in ibody */
        if (jbody == ibody) {
            jnode = inode;
        } else {
            jnode = -1;
            for (knode = 1; knode <= MODL->body[jbody].nnode; knode++) {
                if (fabs(MODL->body[jbody].node[knode].x-xyz_pnt[0]) < EPS06 &&
                    fabs(MODL->body[jbody].node[knode].y-xyz_pnt[1]) < EPS06 &&
                    fabs(MODL->body[jbody].node[knode].z-xyz_pnt[2]) < EPS06   ) {
                    jnode = knode;
                    break;
                }
            }
        }
        SPRINT4(2, "        ibody=%d,inode=%d maps to jbody=%d,jnode=%d", ibody, inode, jbody, jnode);

        if (jnode > 0) {
            status = udp_sensitivity(primtype, MODL->body[jbody].ebody,
                                     1, OCSM_NODE, jnode, NULL, dxyz);
            CHECK_STATUS(udp_sensitivity);
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "cannot find Node %d:%d in jbody=%d", ibody, inode, jbody);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

    /* unknown primitive type, so get velocities by finite differences */
    } else {
        SPRINT1(2, "        -> using finiteDifference (brtype=%s)",
                ocsmGetText(MODL->body[jbody].brtype));

        status = finiteDifference(MODL, ibody, OCSM_NODE, inode, 1, NULL, dxyz);
        CHECK_STATUS(finiteDifference);
        goto cleanup;
    }

    /* follow the children (up to the root) and modify the velocities
       for any OCSM_TRANSFORM that is visited */
    while (jbody != 0) {

        status = xformVelocity(MODL, jbody, 1, xyz_pnt, 1, dxyz);
        CHECK_STATUS(xformVelocity);

        jbody = MODL->body[jbody].ichld;
    }

cleanup:
    SPRINT5(2, " <- velocityOfNode(ibody=%3d, inode=%3d) -> %12.6f %12.6f %12.6f",
            ibody, inode, dxyz[0], dxyz[1], dxyz[2]);

    FREE(uvs);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   wendland - wendland C2 basis function                              *
 *                                                                      *
 ************************************************************************
 */

static double
wendland(CDOUBLE    uv1[],              /* (in)  location of first  point */
         CDOUBLE    uv2[],              /* (in)  location of second point */
         double     srad2)              /* (in)  support radius sqraured */
{
    double  phi;                        /* (out) value to C2-Wendland */

    double  r2bar, rbar;

    /* ---------------------------------------------------------- */

    r2bar = ((uv1[0] - uv2[0]) * (uv1[0] - uv2[0])
           + (uv1[1] - uv2[1]) * (uv1[1] - uv2[1])) / srad2;

    if (fabs(r2bar) > 1) {
        phi = 0;
    } else {
        rbar = sqrt(r2bar);
        phi  = pow(1-rbar, 4) * (4 * rbar + 1);
    }

//cleanup:
    return phi;
}


/*
 ************************************************************************
 *                                                                      *
 *   writeAsciiStl - write ASCII .stl file                              *
 *                                                                      *
 ************************************************************************
 */

static int
writeAsciiStl(modl_T *MODL,             /* (in)  pointer to MODL */
              int    nstack,            /* (in)  number of Bodys on stack */
              int    *stack,            /* (in)  array  of Bodys on stack */
              char   filename[])        /* (in)  name of output file */
{
    int      status = SUCCESS;          /* (out) return status */

    int      istack, ibody, iface, npnt, ntri, itri;
    CINT     *ptype, *pindx, *tris, *tric;
    double   x0, y0, z0, x1, y1, z1, x2, y2, z2;
    CDOUBLE  *xyz, *uv;
    FILE     *fp;

    ROUTINE(writeAsciiStl);

    /* --------------------------------------------------------------- */

    /* make sure that we have a tessellation */
    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        status = tessellate(MODL, ibody);
        CHECK_STATUS(tessellate);
    }

    /* open the output file */
    fp = fopen(filename, "w");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: cannot open \"%s\"", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* create header */
    fprintf(fp, "solid OBJECT\n");

    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        /* write the Triangles */
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt, &xyz, &uv, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (itri = 0; itri < ntri; itri++) {
                x0 = xyz[3*tris[3*itri  ]-3];
                y0 = xyz[3*tris[3*itri  ]-2];
                z0 = xyz[3*tris[3*itri  ]-1];
                x1 = xyz[3*tris[3*itri+1]-3];
                y1 = xyz[3*tris[3*itri+1]-2];
                z1 = xyz[3*tris[3*itri+1]-1];
                x2 = xyz[3*tris[3*itri+2]-3];
                y2 = xyz[3*tris[3*itri+2]-2];
                z2 = xyz[3*tris[3*itri+2]-1];

                fprintf(fp, "  facet normal %14.6e %14.6e %14.6e\n",
                        (y1 - y0) * (z2 - z0) - (y2 - y0) * (z1 - z0),
                        (z1 - z0) * (x2 - x0) - (z2 - z0) * (x1 - x0),
                        (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0));
                fprintf(fp, "    outer loop\n");
                fprintf(fp, "      vertex   %14.6e %14.6e %14.6e\n", x0, y0, z0);
                fprintf(fp, "      vertex   %14.6e %14.6e %14.6e\n", x1, y1, z1);
                fprintf(fp, "      vertex   %14.6e %14.6e %14.6e\n", x2, y2, z2);
                fprintf(fp, "    endloop\n");
                fprintf(fp, "  endfacet\n");
            }
        }
    }

    fprintf(fp, "endsolid OBJECT\n");
    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   writeAsciiUgrid - write ASCII .ugrid file                          *
 *                                                                      *
 ************************************************************************
 */

static int
writeAsciiUgrid(modl_T *MODL,           /* (in)  pointer to MODL */
                int    ibody,           /* (in)  Body index (bias-1) */
                char   filename[])      /* (in)  name of output file */
{
    int      status = SUCCESS;          /* (out) return status */

    int      inode, iedge, iface, npnt, ntri, ipnt, itri, ip0, ip1, ip2;
    CINT     *ptype, *pindx, *tris, *tric;
    CDOUBLE  *xyz, *uv;
    FILE     *fp;

    ROUTINE(writeAsciiUgrid);

    /* --------------------------------------------------------------- */

    /* make sure that we have a tessellation */
    status = tessellate(MODL, ibody);
    CHECK_STATUS(tessellate);

    /* open the output file */
    fp = fopen(filename, "w");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: cannot open \"%s\"", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* create header */
    fprintf(fp, "%8d %8d %8d %8d %8d %8d %8d\n",
            MODL->body[ibody].npnts,
            MODL->body[ibody].ntris,   0, 0, 0, 0, 0);

    /* write the Points (Nodes, then Edges, then Faces) */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        fprintf(fp, "%22.15e %22.15e %22.15e\n",
                MODL->body[ibody].node[inode].x,
                MODL->body[ibody].node[inode].y,
                MODL->body[ibody].node[inode].z);
    }

    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt, &xyz, &uv);
        CHECK_STATUS(EG_getTessEdge);

        for (ipnt = 1; ipnt < npnt-1; ipnt++) {
            fprintf(fp, "%22.15e %22.15e %22.15e\n",
                    xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
        }
    }

    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            if (ptype[ipnt] < 0) {
                fprintf(fp, "%22.15e %22.15e %22.15e\n",
                        xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
            }
        }
    }

    /* write the Triangles */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (itri = 0; itri < ntri; itri++) {
            ip0 = tris[3*itri  ] - 1;
            if        (ptype[ip0] < 0) {       /* interior to Face */
                ip0   = MODL->body[ibody].face[iface].globid + ip0;
            } else if (ptype[ip0] > 0) {       /* interior to Edge */
                iedge = pindx[ip0];
                ip0   = MODL->body[ibody].edge[iedge].globid + ptype[ip0];
            } else {                           /* at Node */
                inode = pindx[ip0];
                ip0   = inode;
            }

            ip1 = tris[3*itri+1] - 1;
            if        (ptype[ip1] < 0) {       /* interior to Face */
                ip1   = MODL->body[ibody].face[iface].globid + ip1;
            } else if (ptype[ip1] > 0) {       /* interior to Edge */
                iedge = pindx[ip1];
                ip1   = MODL->body[ibody].edge[iedge].globid + ptype[ip1];
            } else {                           /* at Node */
                inode = pindx[ip1];
                ip1   = inode;
            }

            ip2 = tris[3*itri+2] - 1;
            if        (ptype[ip2] < 0) {       /* interior to Face */
                ip2   = MODL->body[ibody].face[iface].globid + ip2;
            } else if (ptype[ip2] > 0) {       /* interior to Edge */
                iedge = pindx[ip2];
                ip2   = MODL->body[ibody].edge[iedge].globid + ptype[ip2];
            } else {                           /* at Node */
                inode = pindx[ip2];
                ip2   = inode;
            }

            fprintf(fp, "%8d %8d %8d\n", ip0, ip1, ip2);
        }
    }

    /* write out Face number for each Triangle */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (itri = 0; itri < ntri; itri++) {
            fprintf(fp, "%8d\n", iface);
        }
    }

    /* close the file */
    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   writeBinaryStl - binary ASCII .stl file                            *
 *                                                                      *
 ************************************************************************
 */

int
writeBinaryStl(modl_T *MODL,            /* (in)  pointer to MODL */
               int    nstack,           /* (in)  number of Bodys on stack */
               int    *stack,           /* (in)  array  of Bodys on stack */
               char   filename[])       /* (in)  name of output file */
{
    int    status = SUCCESS;            /* (out) return status */

#define UINT16 unsigned short int
#define UINT32 unsigned int
#define REAL32 float

    int     istack, ibody, iface, npnt, ntri, itri, atype, len;
    CINT    *ptype, *pindx, *tris, *tric, *tempIlist;
    CDOUBLE *xyz, *uv, *tempRlist;
    CCHAR   *tempClist;

    UINT16 icolr;
    UINT32 ntris;
    REAL32 vert0[3], vert1[3], vert2[3], norm[3];
    char   header[]  = "written by OpenCSM                                                             ";
    FILE   *fp = NULL;

    ROUTINE(writeBinaryStl);

    /* --------------------------------------------------------------- */

    /* make sure that we have a tessellation */
    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        status = tessellate(MODL, ibody);
        CHECK_STATUS(tessellate);
    }

    /* open the output file */
    fp = fopen(filename, "wb");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: cannot open \"%s\"", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* create header */
    (void) fwrite(header, sizeof(char), 80, fp);

    /* count and write the number of Triangles */
    ntris = 0;
    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt, &xyz, &uv, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            ntris += ntri;
        }
    }
    (void) fwrite(&ntris, sizeof(UINT32), 1, fp);

    /* process each of the Faces in each Body on the stack */
    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt, &xyz, &uv, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            /* the default color is 0 */
            icolr = 0;

            /* if Body has _stlColor attribute, use it */
            status = EG_attributeRet(MODL->body[ibody].ebody, "_stlColor",
                                     &atype, &len, &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS) {
                if (atype == ATTRREAL && len == 1) {
                    icolr = NINT(tempRlist[0]);
                }
            }

            /* if Face has _stlColor attribute, use it */
            status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_stlColor",
                                     &atype, &len, &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS) {
                if (atype == ATTRREAL && len == 1) {
                    icolr = NINT(tempRlist[0]);
                }
            }

            /* reset status in case we got an error above */
            status = SUCCESS;

            /* write the triangles */
            for (itri = 0; itri < ntri; itri++) {
                vert0[0] = xyz[3*tris[3*itri  ]-3];
                vert0[1] = xyz[3*tris[3*itri  ]-2];
                vert0[2] = xyz[3*tris[3*itri  ]-1];
                vert1[0] = xyz[3*tris[3*itri+1]-3];
                vert1[1] = xyz[3*tris[3*itri+1]-2];
                vert1[2] = xyz[3*tris[3*itri+1]-1];
                vert2[0] = xyz[3*tris[3*itri+2]-3];
                vert2[1] = xyz[3*tris[3*itri+2]-2];
                vert2[2] = xyz[3*tris[3*itri+2]-1];

                norm[0] = (vert1[1] - vert0[1]) * (vert2[2] - vert0[2])
                        - (vert2[1] - vert0[1]) * (vert1[2] - vert0[2]);
                norm[1] = (vert1[2] - vert0[2]) * (vert2[0] - vert0[0])
                        - (vert2[2] - vert0[2]) * (vert1[0] - vert0[0]);
                norm[2] = (vert1[0] - vert0[0]) * (vert2[1] - vert0[1])
                        - (vert2[0] - vert0[0]) * (vert1[1] - vert0[1]);

                (void) fwrite(norm,   sizeof(REAL32), 3, fp);
                (void) fwrite(vert0,  sizeof(REAL32), 3, fp);
                (void) fwrite(vert1,  sizeof(REAL32), 3, fp);
                (void) fwrite(vert2,  sizeof(REAL32), 3, fp);
                (void) fwrite(&icolr, sizeof(UINT16), 1, fp);
            }
        }
    }

    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   xformFaceToOriginal - collect transformation for Face to original  *
 *                                                                      *
 ************************************************************************
 */

static int
xformFaceToOriginal(modl_T *MODL,       /* (in)  pointer to MODL */
                    int    ibody,       /* (in)  Body index of source (bias-1) */
                    int    iface,       /* (in)  Face index of source (bias-1) */
                    double mat[],       /* (out) transformation matrix */
                    double *scale)      /* (out) scale factor */
{
    int      status = SUCCESS;          /* (out) return status */

    int      atype, atype2, alen, alen2, kk, kbody, j;
    CINT     *tempIlist, *tempIlist2;
    double   dx, dy, dz, costht, sintht, temp0, temp1, temp2;
    double   xcent, ycent, zcent, fact, nx, ny, nz, dist;
    CDOUBLE  *tempRlist, *tempRlist2;
    CCHAR    *tempClist, *tempClist2;

    ROUTINE(xformFaceToOriginal);

    /* --------------------------------------------------------------- */

    SPRINT2(2, "        xformFaceToOriginal(ibody=%d, iface=%d)", ibody, iface);

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    mat[ 0] = 1;   mat[ 1] = 0;   mat[ 2] = 0;   mat[ 3] = 0;
    mat[ 4] = 0;   mat[ 5] = 1;   mat[ 6] = 0;   mat[ 7] = 0;
    mat[ 8] = 0;   mat[ 9] = 0;   mat[10] = 1;   mat[11] = 0;

    *scale = 1;

    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_hist",
                             &atype, &alen, &tempIlist, &tempRlist, &tempClist);
    CHECK_STATUS(EG_attributeRet);

    if (atype != ATTRINT) {
        status= OCSM_INTERNAL_ERROR;
        signalError(MODL, status,
                    "_hist attribute is not an integer");
        goto cleanup;
    }

    /* walk from ibody back to the original */
    for (kk = alen-1; kk >= 0; kk--) {
        kbody = tempIlist[kk];

        /* translate */
        if        (MODL->body[kbody].brtype == OCSM_TRANSLATE) {
            SPRINT1(2, "            -> translate (kbody=%d)", kbody);

            dx = MODL->body[kbody].arg[1].val[0];
            dy = MODL->body[kbody].arg[2].val[0];
            dz = MODL->body[kbody].arg[3].val[0];

            mat[ 3] -= dx;
            mat[ 7] -= dy;
            mat[11] -= dz;

        /* rotatex */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEX) {
            SPRINT1(2, "            -> rotatex   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dy     =     MODL->body[kbody].arg[2].val[0];
            dz     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[4+j] =   temp1 * costht + temp2 * sintht;
                mat[8+j] = - temp1 * sintht + temp2 * costht;
            }

            mat[ 7] += dy - dy * costht - dz * sintht;
            mat[11] += dz + dy * sintht - dz * costht;

        /* rotatey */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEY) {
            SPRINT1(2, "            -> rotatey   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dz     =     MODL->body[kbody].arg[2].val[0];
            dx     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp2 = mat[8+j];
                temp0 = mat[  j];

                mat[8+j] =   temp2 * costht + temp0 * sintht;
                mat[  j] = - temp2 * sintht + temp0 * costht;
            }

            mat[11] += dz - dz * costht - dx * sintht;
            mat[ 3] += dx + dz * sintht - dx * costht;

        /* rotatez */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEZ) {
            SPRINT1(2, "            -> rotatez   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dx     =     MODL->body[kbody].arg[2].val[0];
            dy     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];

                mat[  j] =   temp0 * costht + temp1 * sintht;
                mat[4+j] = - temp0 * sintht + temp1 * costht;
            }

            mat[ 3] += dx - dx * costht - dy * sintht;
            mat[ 7] += dy + dx * sintht - dy * costht;

        /* scale */
        } else if (MODL->body[kbody].brtype == OCSM_SCALE) {
            SPRINT1(2, "            -> scale     (kbody=%d)", kbody);

            fact  = MODL->body[kbody].arg[1].val[0];
            xcent = MODL->body[kbody].arg[2].val[0];
            ycent = MODL->body[kbody].arg[3].val[0];
            zcent = MODL->body[kbody].arg[4].val[0];

            mat[ 0] /= fact;
            mat[ 1] /= fact;
            mat[ 2] /= fact;
            mat[ 3]  = (mat[ 3] - xcent) / fact + xcent;
            mat[ 4] /= fact;
            mat[ 5] /= fact;
            mat[ 6] /= fact;
            mat[ 7]  = (mat[ 7] - ycent) / fact + ycent;
            mat[ 8] /= fact;
            mat[ 9] /= fact;
            mat[10] /= fact;
            mat[11]  = (mat[11] - zcent) / fact + zcent;

            *scale *= fact;

        /* mirror */
        } else if (MODL->body[kbody].brtype == OCSM_MIRROR) {
            SPRINT1(2, "            -> mirror    (kbody=%d)", kbody);

            nx    = MODL->body[kbody].arg[1].val[0];
            ny    = MODL->body[kbody].arg[2].val[0];
            nz    = MODL->body[kbody].arg[3].val[0];
            dist  = MODL->body[kbody].arg[4].val[0];

            fact  = sqrt(nx*nx + ny*ny + nz*nz);
            dx    = nx / fact;
            dy    = ny / fact;
            dz    = nz / fact;

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[  j] = temp0 * (1-2*dx*dx) + temp1 * ( -2*dy*dx) + temp2 * ( -2*dz*dx);
                mat[4+j] = temp0 * ( -2*dx*dy) + temp1 * (1-2*dy*dy) + temp2 * ( -2*dz*dy);
                mat[8+j] = temp0 * ( -2*dx*dz) + temp1 * ( -2*dy*dz) + temp2 * (1-2*dz*dz);
            }

            mat[ 3] += 2 * dist * dx;
            mat[ 7] += 2 * dist * dy;
            mat[11] += 2 * dist * dz;

        /* applycsys */
        } else if (MODL->body[kbody].brtype == OCSM_APPLYCSYS) {
            SPRINT1(2, "            -> applycsys (kbody=%d)", kbody);

        /* extrude (but only for iford=2) */
        } else if (MODL->body[kbody].brtype == OCSM_EXTRUDE) {
            status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_body",
                                     &atype2, &alen2, &tempIlist2, &tempRlist2, &tempClist2);
            CHECK_STATUS(EG_attributeRet);

            if (tempIlist2[1] == 2) {
                SPRINT1(2, "            -> extrude   (kbody=%d)", kbody);
                dx = MODL->body[kbody].arg[1].val[0];
                dy = MODL->body[kbody].arg[2].val[0];
                dz = MODL->body[kbody].arg[3].val[0];

                mat[ 3] -= dx;
                mat[ 7] -= dy;
                mat[11] -= dz;
            }
        }
    }

    if (*scale != 1) {
        SPRINT1(2, "              *scale = %12.5f", *scale);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   xformFaceVelocity - transform Face velocity and xyz_pnt            *
 *                                                                      *
 ************************************************************************
 */

static int
xformFaceVelocity(modl_T *MODL,         /* (in)  pointer to MODL */
                  int    ibody,         /* (in)  Body index (bias-1) */
                  int    iface,         /* (in)  Face index (bias-1) */
                  int    nxyz,          /* (in)  number of xyz_pnt */
                  double xyz_pnt[],     /* (both)coordinates to be transformed */
                  int    ndxyz,         /* (in)  number of dxyz */
                  double dxyz[])        /* (both)velocities  to be transformed */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipnt, atype, atype2, alen, alen2, kk, kbody;
    CINT      *tempIlist, *tempIlist2;
    double    dx, dy, dz, sintht, costht, fact, nx, ny, nz, dist;
    double    xold, xolddot, yold, yolddot, zold, zolddot, thtdot;
    double    xbase, ybase, zbase;
    double    dxdot, dydot, dzdot, factdot, nxdot, nydot, nzdot, distdot;
    double    xcent, ycent, zcent, xcentdot, ycentdot, zcentdot;
    CDOUBLE   *tempRlist, *tempRlist2;
    CCHAR     *tempClist, *tempClist2;

    ROUTINE(xformVelocity);

    /* --------------------------------------------------------------- */

    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_hist",
                             &atype, &alen, &tempIlist, &tempRlist, &tempClist);
    CHECK_STATUS(EG_attributeRet);

    if (atype != ATTRINT) {
        status= OCSM_INTERNAL_ERROR;
        signalError(MODL, status,
                    "_hist attribute is not an integer");
        goto cleanup;
    }

    for (kk = 0; kk < alen; kk++) {
        kbody = tempIlist[kk];

        SPRINT3(2, "        xformVelocity(kbody=%d, nxyz=%d, ndxyz=%d)", kbody, nxyz, ndxyz);

        /* translate */
        if (MODL->body[kbody].brtype == OCSM_TRANSLATE) {
            SPRINT1(2, "            -> translate (kbody=%d)", kbody);

            dx    = MODL->body[kbody].arg[1].val[0];
            dy    = MODL->body[kbody].arg[2].val[0];
            dz    = MODL->body[kbody].arg[3].val[0];

            dxdot = MODL->body[kbody].arg[1].dot[0];
            dydot = MODL->body[kbody].arg[2].dot[0];
            dzdot = MODL->body[kbody].arg[3].dot[0];

            for (ipnt = 0; ipnt < ndxyz; ipnt++) {
                dxyz[3*ipnt  ] += dxdot;
                dxyz[3*ipnt+1] += dydot;
                dxyz[3*ipnt+2] += dzdot;
            }

            for (ipnt = 0; ipnt < nxyz; ipnt++) {
                xyz_pnt[3*ipnt  ] += dx;
                xyz_pnt[3*ipnt+1] += dy;
                xyz_pnt[3*ipnt+2] += dz;
            }

        /* rotatex */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEX) {
            SPRINT1(2, "            -> rotatex   (kbody=%d)", kbody);

            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            thtdot = PIo180 * MODL->body[kbody].arg[1].dot[0];

            for (ipnt = 0; ipnt < ndxyz; ipnt++) {
                yold    = xyz_pnt[3*ipnt+1];
                zold    = xyz_pnt[3*ipnt+2];

                yolddot = dxyz[   3*ipnt+1];
                zolddot = dxyz[   3*ipnt+2];

                dxyz[3*ipnt+1] = MODL->body[kbody].arg[2].dot[0]
                    + (yolddot - MODL->body[kbody].arg[2].dot[0]) * costht
                    - (yold    - MODL->body[kbody].arg[2].val[0]) * sintht * thtdot
                    - (zolddot - MODL->body[kbody].arg[3].dot[0]) * sintht
                    - (zold    - MODL->body[kbody].arg[3].val[0]) * costht * thtdot;
                dxyz[3*ipnt+2] = MODL->body[kbody].arg[3].dot[0]
                    + (yolddot - MODL->body[kbody].arg[2].dot[0]) * sintht
                    + (yold    - MODL->body[kbody].arg[2].val[0]) * costht * thtdot
                    + (zolddot - MODL->body[kbody].arg[3].dot[0]) * costht
                    - (zold    - MODL->body[kbody].arg[3].val[0]) * sintht * thtdot;
            }

            ybase = MODL->body[kbody].arg[2].val[0];
            zbase = MODL->body[kbody].arg[3].val[0];

            for (ipnt = 0; ipnt < nxyz; ipnt++) {
                yold = xyz_pnt[3*ipnt+1];
                zold = xyz_pnt[3*ipnt+2];

                xyz_pnt[3*ipnt+1] = ybase + (yold-ybase) * costht - (zold-zbase) * sintht;
                xyz_pnt[3*ipnt+2] = zbase + (yold-ybase) * sintht + (zold-zbase) * costht;
            }

        /* rotatey */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEY) {
            SPRINT1(2, "            -> rotatey   (kbody=%d)", kbody);

            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            thtdot = PIo180 * MODL->body[kbody].arg[1].dot[0];

            for (ipnt = 0; ipnt < ndxyz; ipnt++) {
                zold    = xyz_pnt[3*ipnt+2];
                xold    = xyz_pnt[3*ipnt  ];

                zolddot = dxyz[   3*ipnt+2];
                xolddot = dxyz[   3*ipnt  ];

                dxyz[3*ipnt+2] = MODL->body[kbody].arg[2].dot[0]
                    + (zolddot - MODL->body[kbody].arg[2].dot[0]) * costht
                    - (zold    - MODL->body[kbody].arg[2].val[0]) * sintht * thtdot
                    - (xolddot - MODL->body[kbody].arg[3].dot[0]) * sintht
                    - (xold    - MODL->body[kbody].arg[3].val[0]) * costht * thtdot;
                dxyz[3*ipnt  ] = MODL->body[kbody].arg[3].dot[0]
                    + (zolddot - MODL->body[kbody].arg[2].dot[0]) * sintht
                    + (zold    - MODL->body[kbody].arg[2].val[0]) * costht * thtdot
                    + (xolddot - MODL->body[kbody].arg[3].dot[0]) * costht
                    - (xold    - MODL->body[kbody].arg[3].val[0]) * sintht * thtdot;
            }

            zbase = MODL->body[kbody].arg[2].val[0];
            xbase = MODL->body[kbody].arg[3].val[0];

            for (ipnt = 0; ipnt < nxyz; ipnt++) {
                zold = xyz_pnt[3*ipnt+2];
                xold = xyz_pnt[3*ipnt  ];

                xyz_pnt[3*ipnt+2] = zbase + (zold-zbase) * costht - (xold-xbase) * sintht;
                xyz_pnt[3*ipnt  ] = xbase + (zold-zbase) * sintht + (xold-xbase) * costht;
            }

        /* rotatez */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEZ) {
            SPRINT1(2, "            -> rotatez   (kbody=%d)", kbody);

            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            thtdot = PIo180 * MODL->body[kbody].arg[1].dot[0];

            for (ipnt = 0; ipnt < ndxyz; ipnt++) {
                xold    = xyz_pnt[3*ipnt  ];
                yold    = xyz_pnt[3*ipnt+1];

                xolddot = dxyz[   3*ipnt  ];
                yolddot = dxyz[   3*ipnt+1];

                dxyz[3*ipnt  ] = MODL->body[kbody].arg[2].dot[0]
                    + (xolddot - MODL->body[kbody].arg[2].dot[0]) * costht
                    - (xold    - MODL->body[kbody].arg[2].val[0]) * sintht * thtdot
                    - (yolddot - MODL->body[kbody].arg[3].dot[0]) * sintht
                    - (yold    - MODL->body[kbody].arg[3].val[0]) * costht * thtdot;
                dxyz[3*ipnt+1] = MODL->body[kbody].arg[3].dot[0]
                    + (xolddot - MODL->body[kbody].arg[2].dot[0]) * sintht
                    + (xold    - MODL->body[kbody].arg[2].val[0]) * costht * thtdot
                    + (yolddot - MODL->body[kbody].arg[3].dot[0]) * costht
                    - (yold    - MODL->body[kbody].arg[3].val[0]) * sintht * thtdot;
            }

            xbase = MODL->body[kbody].arg[2].val[0];
            ybase = MODL->body[kbody].arg[3].val[0];

            for (ipnt = 0; ipnt < nxyz; ipnt++) {
                xold = xyz_pnt[3*ipnt  ];
                yold = xyz_pnt[3*ipnt+1];

                xyz_pnt[3*ipnt  ] = xbase + (xold-xbase) * costht - (yold-ybase) * sintht;
                xyz_pnt[3*ipnt+1] = ybase + (xold-xbase) * sintht + (yold-ybase) * costht;
            }

        /* scale */
        } else if (MODL->body[kbody].brtype == OCSM_SCALE) {
            SPRINT1(2, "            -> scale     (kbody=%d)", kbody);

            fact     = MODL->body[kbody].arg[1].val[0];
            xcent    = MODL->body[kbody].arg[2].val[0];
            ycent    = MODL->body[kbody].arg[3].val[0];
            zcent    = MODL->body[kbody].arg[4].val[0];

            factdot  = MODL->body[kbody].arg[1].dot[0];
            xcentdot = MODL->body[kbody].arg[2].dot[0];
            ycentdot = MODL->body[kbody].arg[3].dot[0];
            zcentdot = MODL->body[kbody].arg[4].dot[0];

            for (ipnt = 0; ipnt < ndxyz; ipnt++) {
                xold    = xyz_pnt[3*ipnt  ];
                yold    = xyz_pnt[3*ipnt+1];
                zold    = xyz_pnt[3*ipnt+2];

                xolddot = dxyz[   3*ipnt  ];
                yolddot = dxyz[   3*ipnt+1];
                zolddot = dxyz[   3*ipnt+2];

                dxyz[3*ipnt  ] = factdot * (xold - xcent) + xolddot * fact + xcentdot * (1 - fact);
                dxyz[3*ipnt+1] = factdot * (yold - ycent) + yolddot * fact + ycentdot * (1 - fact);
                dxyz[3*ipnt+2] = factdot * (zold - zcent) + zolddot * fact + zcentdot * (1 - fact);
            }

            for (ipnt = 0; ipnt < nxyz; ipnt++) {
                xyz_pnt[3*ipnt  ] = xyz_pnt[3*ipnt  ] * fact + xcent * (1 - fact);
                xyz_pnt[3*ipnt+1] = xyz_pnt[3*ipnt+1] * fact + ycent * (1 - fact);
                xyz_pnt[3*ipnt+2] = xyz_pnt[3*ipnt+2] * fact + zcent * (1 - fact);
            }

        /* mirror */
        } else if (MODL->body[kbody].brtype == OCSM_MIRROR) {
            SPRINT1(2, "            -> mirror    (kbody=%d)", kbody);

            nx       = MODL->body[kbody].arg[1].val[0];
            ny       = MODL->body[kbody].arg[2].val[0];
            nz       = MODL->body[kbody].arg[3].val[0];
            dist     = MODL->body[kbody].arg[4].val[0];

            nxdot    = MODL->body[kbody].arg[1].dot[0];
            nydot    = MODL->body[kbody].arg[2].dot[0];
            nzdot    = MODL->body[kbody].arg[3].dot[0];
            distdot  = MODL->body[kbody].arg[4].dot[0];

            fact     = sqrt(nx*nx    + ny*ny    + nz*nz   );
            factdot  =     (nx*nxdot + ny*nydot + nz*nzdot) / fact;

            dx       = nx / fact;
            dy       = ny / fact;
            dz       = nz / fact;

            dxdot    = (fact * nxdot - nx * factdot) / fact / fact;
            dydot    = (fact * nydot - ny * factdot) / fact / fact;
            dzdot    = (fact * nzdot - nz * factdot) / fact / fact;

            for (ipnt = 0; ipnt < ndxyz; ipnt++) {
                xold    = xyz_pnt[3*ipnt  ];
                yold    = xyz_pnt[3*ipnt+1];
                zold    = xyz_pnt[3*ipnt+2];

                xolddot = dxyz[   3*ipnt  ];
                yolddot = dxyz[   3*ipnt+1];
                zolddot = dxyz[   3*ipnt+2];

                dxyz[3*ipnt  ] = xolddot * (1-2*dx*dx) + xold * (-4*dx*dxdot           )
                               + yolddot * ( -2*dx*dy) + yold * (-2*dx*dydot-2*dy*dxdot)
                               + zolddot * ( -2*dx*dz) + zold * (-2*dx*dzdot-2*dz*dxdot)
                               + distdot * (  2*dx   ) + dist * (            2*   dxdot);
                dxyz[3*ipnt+1] = xolddot * ( -2*dy*dx) + xold * (-2*dy*dxdot-2*dx*dydot)
                               + yolddot * (1-2*dy*dy) + yold * (-4*dy*dydot           )
                               + zolddot * ( -2*dy*dz) + zold * (-2*dy*dzdot-2*dz*dydot)
                               + distdot * (  2*dy   ) + dist * (            2*   dydot);
                dxyz[3*ipnt+2] = xolddot * ( -2*dz*dx) + xold * (-2*dz*dxdot-2*dx*dzdot)
                               + yolddot * ( -2*dz*dy) + yold * (-2*dz*dydot-2*dy*dzdot)
                               + zolddot * (1-2*dz*dz) + zold * (-4*dz*dzdot           )
                               + distdot * (  2*dz   ) + dist * (            2*   dzdot);
            }

            for (ipnt = 0; ipnt < nxyz; ipnt++) {
                xold = xyz_pnt[3*ipnt  ];
                yold = xyz_pnt[3*ipnt+1];
                zold = xyz_pnt[3*ipnt+2];

                xyz_pnt[3*ipnt  ] = xold * (1-2*dx*dx) + yold * ( -2*dy*dx) + zold * ( -2*dz*dx) + 2*dist*dx;
                xyz_pnt[3*ipnt+1] = xold * ( -2*dx*dy) + yold * (1-2*dy*dy) + zold * ( -2*dz*dy) + 2*dist*dy;
                xyz_pnt[3*ipnt+2] = xold * ( -2*dx*dz) + yold * ( -2*dy*dz) + zold * (1-2*dz*dz) + 2*dist*dz;
            }

        /* applycsys */
        } else if (MODL->body[kbody].brtype == OCSM_APPLYCSYS) {
            SPRINT1(2, "            -> applycsys (kbody=%d)", kbody);

        /* extrude (but only for iford==2) */
        } else if (MODL->body[kbody].brtype == OCSM_EXTRUDE) {
            status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_body",
                                     &atype2, &alen2, &tempIlist2, &tempRlist2, &tempClist2);
            CHECK_STATUS(EG_attributeRet);

            if (tempIlist2[1] == 2) {
                SPRINT1(2, "            -> extrude   (kbody=%d)", kbody);

                dx    = MODL->body[kbody].arg[1].val[0];
                dy    = MODL->body[kbody].arg[2].val[0];
                dz    = MODL->body[kbody].arg[3].val[0];

                dxdot = MODL->body[kbody].arg[1].dot[0];
                dydot = MODL->body[kbody].arg[2].dot[0];
                dzdot = MODL->body[kbody].arg[3].dot[0];

                for (ipnt = 0; ipnt < ndxyz; ipnt++) {
                    dxyz[3*ipnt  ] += dxdot;
                    dxyz[3*ipnt+1] += dydot;
                    dxyz[3*ipnt+2] += dzdot;
                }

                for (ipnt = 0; ipnt < nxyz; ipnt++) {
                    xyz_pnt[3*ipnt  ] += dx;
                    xyz_pnt[3*ipnt+1] += dy;
                    xyz_pnt[3*ipnt+2] += dz;
                }
            }
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   xformToOriginal - collect transformation from final to original    *
 *                                                                      *
 ************************************************************************
 */

static int
xformToOriginal(modl_T *MODL,           /* (in)  pointer to MODL */
                int    ibody,           /* (in)  Body index of source (bias-1) */
                int    jbody,           /* (in)  Body index of target (bias-1) */
                double mat[])           /* (out) transformation matrix */
{
    int      status = SUCCESS;          /* (out) return status */

    int      kbody, ktgt, j;
    double   dx, dy, dz, costht, sintht, temp0, temp1, temp2;
    double   xcent, ycent, zcent, fact, nx, ny, nz, dist;

    ROUTINE(xformToOriginal);

    /* --------------------------------------------------------------- */

    SPRINT2(2, "        xformToOriginal(ibody=%d, jbody=%d)", ibody, jbody);

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    mat[ 0] = 1;   mat[ 1] = 0;   mat[ 2] = 0;   mat[ 3] = 0;
    mat[ 4] = 0;   mat[ 5] = 1;   mat[ 6] = 0;   mat[ 7] = 0;
    mat[ 8] = 0;   mat[ 9] = 0;   mat[10] = 1;   mat[11] = 0;

    /* walk from ibody back to jbody (which is the first Body
       in which inode appeared).  see comment at bottom
       of loop to see how we make sure that we choose the
       correct parent */
    kbody = ibody;
    while (kbody != jbody) {

        /* translate */
        if        (MODL->body[kbody].brtype == OCSM_TRANSLATE) {
            SPRINT1(2, "            -> translate (kbody=%d)", kbody);

            dx = MODL->body[kbody].arg[1].val[0];
            dy = MODL->body[kbody].arg[2].val[0];
            dz = MODL->body[kbody].arg[3].val[0];

            mat[ 3] -= dx;
            mat[ 7] -= dy;
            mat[11] -= dz;

        /* rotatex */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEX) {
            SPRINT1(2, "            -> rotatex   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dy     =     MODL->body[kbody].arg[2].val[0];
            dz     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[4+j] =   temp1 * costht + temp2 * sintht;
                mat[8+j] = - temp1 * sintht + temp2 * costht;
            }

            mat[ 7] += dy - dy * costht - dz * sintht;
            mat[11] += dz + dy * sintht - dz * costht;

        /* rotatey */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEY) {
            SPRINT1(2, "            -> rotatey   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dz     =     MODL->body[kbody].arg[2].val[0];
            dx     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp2 = mat[8+j];
                temp0 = mat[  j];

                mat[8+j] =   temp2 * costht + temp0 * sintht;
                mat[  j] = - temp2 * sintht + temp0 * costht;
            }

            mat[11] += dz - dz * costht - dx * sintht;
            mat[ 3] += dx + dz * sintht - dx * costht;

        /* rotatez */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEZ) {
            SPRINT1(2, "            -> rotatez   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dx     =     MODL->body[kbody].arg[2].val[0];
            dy     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];

                mat[  j] =   temp0 * costht + temp1 * sintht;
                mat[4+j] = - temp0 * sintht + temp1 * costht;
            }

            mat[ 3] += dx - dx * costht - dy * sintht;
            mat[ 7] += dy + dx * sintht - dy * costht;

        /* scale */
        } else if (MODL->body[kbody].brtype == OCSM_SCALE) {
            SPRINT1(2, "            -> scale     (kbody=%d)", kbody);

            fact  = MODL->body[kbody].arg[1].val[0];
            xcent = MODL->body[kbody].arg[2].val[0];
            ycent = MODL->body[kbody].arg[3].val[0];
            zcent = MODL->body[kbody].arg[4].val[0];

            mat[ 0] /= fact;
            mat[ 1] /= fact;
            mat[ 2] /= fact;
            mat[ 3]  = (mat[ 3] - xcent) / fact + xcent;
            mat[ 4] /= fact;
            mat[ 5] /= fact;
            mat[ 6] /= fact;
            mat[ 7]  = (mat[ 7] - ycent) / fact + ycent;
            mat[ 8] /= fact;
            mat[ 9] /= fact;
            mat[10] /= fact;
            mat[11]  = (mat[11] - zcent) / fact + zcent;

        /* mirror */
        } else if (MODL->body[kbody].brtype == OCSM_MIRROR) {
            SPRINT1(2, "            -> mirror    (kbody=%d)", kbody);

            nx    = MODL->body[kbody].arg[1].val[0];
            ny    = MODL->body[kbody].arg[2].val[0];
            nz    = MODL->body[kbody].arg[3].val[0];
            dist  = MODL->body[kbody].arg[4].val[0];

            fact  = sqrt(nx*nx + ny*ny + nz*nz);
            dx    = nx / fact;
            dy    = ny / fact;
            dz    = nz / fact;

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[  j] = temp0 * (1-2*dx*dx) + temp1 * ( -2*dy*dx) + temp2 * ( -2*dz*dx);
                mat[4+j] = temp0 * ( -2*dx*dy) + temp1 * (1-2*dy*dy) + temp2 * ( -2*dz*dy);
                mat[8+j] = temp0 * ( -2*dx*dz) + temp1 * ( -2*dy*dz) + temp2 * (1-2*dz*dz);
            }

            mat[ 3] += 2 * dist * dx;
            mat[ 7] += 2 * dist * dy;
            mat[11] += 2 * dist * dz;

        /* applycsys */
        } else if (MODL->body[kbody].brtype == OCSM_APPLYCSYS) {
            SPRINT1(2, "            -> applycsys (kbody=%d)", kbody);

        }

        /* go to kbody's left or rite parent.  the only way to get
           the correct parent is to start over from jbody until
           the parent is the old kbody (which we call ktgt) */
        ktgt  = kbody;
        kbody = jbody;
        while (kbody > 0) {
            if (MODL->body[kbody].ichld == ktgt) break;

            kbody = MODL->body[kbody].ichld;
        }

        if (kbody <= 0) break;
    }

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   xformVelocity - transform velocity and xyz_pnt by following tree   *
 *                                                                      *
 ************************************************************************
 */

static int
xformVelocity(modl_T *MODL,             /* (in)  pointer to MODL */
              int    jbody,             /* (in)  Body index (bias-1) */
              int    nxyz,              /* (in)  number of xyz_pnt */
              double xyz_pnt[],         /* (both)coordinates to be transformed */
              int    ndxyz,             /* (in)  number of dxyz */
              double dxyz[])            /* (both)velocities  to be transformed */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipnt;
    double    dx, dy, dz, sintht, costht, fact, nx, ny, nz, dist;
    double    xold, xolddot, yold, yolddot, zold, zolddot, thtdot;
    double    xbase, ybase, zbase;
    double    dxdot, dydot, dzdot, factdot, nxdot, nydot, nzdot, distdot;
    double    xcent, ycent, zcent, xcentdot, ycentdot, zcentdot;

    ROUTINE(xformVelocity);

    /* --------------------------------------------------------------- */

    SPRINT3(2, "        xformVelocity(jbody=%d, nxyz=%d, ndxyz=%d)", jbody, nxyz, ndxyz);

    /* translate */
    if (MODL->body[jbody].brtype == OCSM_TRANSLATE) {
        SPRINT1(2, "            -> translate (jbody=%d)", jbody);

        dx    = MODL->body[jbody].arg[1].val[0];
        dy    = MODL->body[jbody].arg[2].val[0];
        dz    = MODL->body[jbody].arg[3].val[0];

        dxdot = MODL->body[jbody].arg[1].dot[0];
        dydot = MODL->body[jbody].arg[2].dot[0];
        dzdot = MODL->body[jbody].arg[3].dot[0];

        for (ipnt = 0; ipnt < ndxyz; ipnt++) {
            dxyz[3*ipnt  ] += dxdot;
            dxyz[3*ipnt+1] += dydot;
            dxyz[3*ipnt+2] += dzdot;
        }

        for (ipnt = 0; ipnt < nxyz; ipnt++) {
            xyz_pnt[3*ipnt  ] += dx;
            xyz_pnt[3*ipnt+1] += dy;
            xyz_pnt[3*ipnt+2] += dz;
        }

    /* rotatex */
    } else if (MODL->body[jbody].brtype == OCSM_ROTATEX) {
        SPRINT1(2, "            -> rotatex   (jbody=%d)", jbody);

        sintht = sin(MODL->body[jbody].arg[1].val[0] * PIo180);
        costht = cos(MODL->body[jbody].arg[1].val[0] * PIo180);
        thtdot = PIo180 * MODL->body[jbody].arg[1].dot[0];

        for (ipnt = 0; ipnt < ndxyz; ipnt++) {
            yold    = xyz_pnt[3*ipnt+1];
            zold    = xyz_pnt[3*ipnt+2];

            yolddot = dxyz[   3*ipnt+1];
            zolddot = dxyz[   3*ipnt+2];

            dxyz[3*ipnt+1] = MODL->body[jbody].arg[2].dot[0]
                + (yolddot - MODL->body[jbody].arg[2].dot[0]) * costht
                - (yold    - MODL->body[jbody].arg[2].val[0]) * sintht * thtdot
                - (zolddot - MODL->body[jbody].arg[3].dot[0]) * sintht
                - (zold    - MODL->body[jbody].arg[3].val[0]) * costht * thtdot;
            dxyz[3*ipnt+2] = MODL->body[jbody].arg[3].dot[0]
                + (yolddot - MODL->body[jbody].arg[2].dot[0]) * sintht
                + (yold    - MODL->body[jbody].arg[2].val[0]) * costht * thtdot
                + (zolddot - MODL->body[jbody].arg[3].dot[0]) * costht
                - (zold    - MODL->body[jbody].arg[3].val[0]) * sintht * thtdot;
        }

        ybase = MODL->body[jbody].arg[2].val[0];
        zbase = MODL->body[jbody].arg[3].val[0];

        for (ipnt = 0; ipnt < nxyz; ipnt++) {
            yold = xyz_pnt[3*ipnt+1];
            zold = xyz_pnt[3*ipnt+2];

            xyz_pnt[3*ipnt+1] = ybase + (yold-ybase) * costht - (zold-zbase) * sintht;
            xyz_pnt[3*ipnt+2] = zbase + (yold-ybase) * sintht + (zold-zbase) * costht;
        }

    /* rotatey */
    } else if (MODL->body[jbody].brtype == OCSM_ROTATEY) {
        SPRINT1(2, "            -> rotatey   (jbody=%d)", jbody);

        sintht = sin(MODL->body[jbody].arg[1].val[0] * PIo180);
        costht = cos(MODL->body[jbody].arg[1].val[0] * PIo180);
        thtdot = PIo180 * MODL->body[jbody].arg[1].dot[0];

        for (ipnt = 0; ipnt < ndxyz; ipnt++) {
            xold    = xyz_pnt[3*ipnt  ];
            zold    = xyz_pnt[3*ipnt+2];

            xolddot = dxyz[   3*ipnt  ];
            zolddot = dxyz[   3*ipnt+2];

            dxyz[3*ipnt+2] = MODL->body[jbody].arg[2].dot[0]
                + (zolddot - MODL->body[jbody].arg[2].dot[0]) * costht
                - (zold    - MODL->body[jbody].arg[2].val[0]) * sintht * thtdot
                - (xolddot - MODL->body[jbody].arg[3].dot[0]) * sintht
                - (xold    - MODL->body[jbody].arg[3].val[0]) * costht * thtdot;
            dxyz[3*ipnt  ] = MODL->body[jbody].arg[3].dot[0]
                + (zolddot - MODL->body[jbody].arg[2].dot[0]) * sintht
                + (zold    - MODL->body[jbody].arg[2].val[0]) * costht * thtdot
                + (xolddot - MODL->body[jbody].arg[3].dot[0]) * costht
                - (xold    - MODL->body[jbody].arg[3].val[0]) * sintht * thtdot;
        }

        zbase = MODL->body[jbody].arg[2].val[0];
        xbase = MODL->body[jbody].arg[3].val[0];

        for (ipnt = 0; ipnt < nxyz; ipnt++) {
            zold = xyz_pnt[3*ipnt+2];
            xold = xyz_pnt[3*ipnt  ];

            xyz_pnt[3*ipnt+2] = zbase + (zold-zbase) * costht - (xold-xbase) * sintht;
            xyz_pnt[3*ipnt  ] = xbase + (zold-zbase) * sintht + (xold-xbase) * costht;
        }

    /* rotatez */
    } else if (MODL->body[jbody].brtype == OCSM_ROTATEZ) {
        SPRINT1(2, "            -> rotatez   (jbody=%d)", jbody);

        sintht = sin(MODL->body[jbody].arg[1].val[0] * PIo180);
        costht = cos(MODL->body[jbody].arg[1].val[0] * PIo180);
        thtdot = PIo180 * MODL->body[jbody].arg[1].dot[0];

        for (ipnt = 0; ipnt < ndxyz; ipnt++) {
            xold    = xyz_pnt[3*ipnt  ];
            yold    = xyz_pnt[3*ipnt+1];

            xolddot = dxyz[   3*ipnt  ];
            yolddot = dxyz[   3*ipnt+1];

            dxyz[3*ipnt  ] = MODL->body[jbody].arg[2].dot[0]
                + (xolddot - MODL->body[jbody].arg[2].dot[0]) * costht
                - (xold    - MODL->body[jbody].arg[2].val[0]) * sintht * thtdot
                - (yolddot - MODL->body[jbody].arg[3].dot[0]) * sintht
                - (yold    - MODL->body[jbody].arg[3].val[0]) * costht * thtdot;
            dxyz[3*ipnt+1] = MODL->body[jbody].arg[3].dot[0]
                + (xolddot - MODL->body[jbody].arg[2].dot[0]) * sintht
                + (xold    - MODL->body[jbody].arg[2].val[0]) * costht * thtdot
                + (yolddot - MODL->body[jbody].arg[3].dot[0]) * costht
                - (yold    - MODL->body[jbody].arg[3].val[0]) * sintht * thtdot;
        }

        xbase = MODL->body[jbody].arg[2].val[0];
        ybase = MODL->body[jbody].arg[3].val[0];

        for (ipnt = 0; ipnt < nxyz; ipnt++) {
            xold = xyz_pnt[3*ipnt  ];
            yold = xyz_pnt[3*ipnt+1];

            xyz_pnt[3*ipnt  ] = xbase + (xold-xbase) * costht - (yold-ybase) * sintht;
            xyz_pnt[3*ipnt+1] = ybase + (xold-xbase) * sintht + (yold-ybase) * costht;
        }

    /* scale */
    } else if (MODL->body[jbody].brtype == OCSM_SCALE) {
        SPRINT1(2, "            -> scale     (jbody=%d)", jbody);

        fact     = MODL->body[jbody].arg[1].val[0];
        xcent    = MODL->body[jbody].arg[2].val[0];
        ycent    = MODL->body[jbody].arg[3].val[0];
        zcent    = MODL->body[jbody].arg[4].val[0];

        factdot  = MODL->body[jbody].arg[1].dot[0];
        xcentdot = MODL->body[jbody].arg[2].dot[0];
        ycentdot = MODL->body[jbody].arg[3].dot[0];
        zcentdot = MODL->body[jbody].arg[4].dot[0];

        for (ipnt = 0; ipnt < ndxyz; ipnt++) {
            xold    = xyz_pnt[3*ipnt  ];
            yold    = xyz_pnt[3*ipnt+1];
            zold    = xyz_pnt[3*ipnt+2];

            xolddot = dxyz[   3*ipnt  ];
            yolddot = dxyz[   3*ipnt+1];
            zolddot = dxyz[   3*ipnt+2];

            dxyz[3*ipnt  ] = factdot * (xold - xcent) + xolddot * fact + xcentdot * (1 - fact);
            dxyz[3*ipnt+1] = factdot * (yold - ycent) + yolddot * fact + ycentdot * (1 - fact);
            dxyz[3*ipnt+2] = factdot * (zold - zcent) + zolddot * fact + zcentdot * (1 - fact);
        }

        for (ipnt = 0; ipnt < nxyz; ipnt++) {
            xyz_pnt[3*ipnt  ] = xyz_pnt[3*ipnt  ] * fact + xcent * (1 - fact);
            xyz_pnt[3*ipnt+1] = xyz_pnt[3*ipnt+1] * fact + ycent * (1 - fact);
            xyz_pnt[3*ipnt+2] = xyz_pnt[3*ipnt+2] * fact + zcent * (1 - fact);
        }

    /* mirror */
    } else if (MODL->body[jbody].brtype == OCSM_MIRROR) {
        SPRINT1(2, "            -> mirror    (jbody=%d)", jbody);

        nx       = MODL->body[jbody].arg[1].val[0];
        ny       = MODL->body[jbody].arg[2].val[0];
        nz       = MODL->body[jbody].arg[3].val[0];
        dist     = MODL->body[jbody].arg[4].val[0];

        nxdot    = MODL->body[jbody].arg[1].dot[0];
        nydot    = MODL->body[jbody].arg[2].dot[0];
        nzdot    = MODL->body[jbody].arg[3].dot[0];
        distdot  = MODL->body[jbody].arg[4].dot[0];

        fact     = sqrt(nx*nx    + ny*ny    + nz*nz   );
        factdot  =     (nx*nxdot + ny*nydot + nz*nzdot) / fact;

        dx       = nx / fact;
        dy       = ny / fact;
        dz       = nz / fact;

        dxdot    = (fact * nxdot - nx * factdot) / fact / fact;
        dydot    = (fact * nydot - ny * factdot) / fact / fact;
        dzdot    = (fact * nzdot - nz * factdot) / fact / fact;

        for (ipnt = 0; ipnt < ndxyz; ipnt++) {
            xold    = xyz_pnt[3*ipnt  ];
            yold    = xyz_pnt[3*ipnt+1];
            zold    = xyz_pnt[3*ipnt+2];

            xolddot = dxyz[   3*ipnt  ];
            yolddot = dxyz[   3*ipnt+1];
            zolddot = dxyz[   3*ipnt+2];

            dxyz[3*ipnt  ] = xolddot * (1-2*dx*dx) + xold * (-4*dx*dxdot           )
                           + yolddot * ( -2*dx*dy) + yold * (-2*dx*dydot-2*dy*dxdot)
                           + zolddot * ( -2*dx*dz) + zold * (-2*dx*dzdot-2*dz*dxdot)
                           + distdot * (  2*dx   ) + dist * (            2*   dxdot);
            dxyz[3*ipnt+1] = xolddot * ( -2*dy*dx) + xold * (-2*dy*dxdot-2*dx*dydot)
                           + yolddot * (1-2*dy*dy) + yold * (-4*dy*dydot           )
                           + zolddot * ( -2*dy*dz) + zold * (-2*dy*dzdot-2*dz*dydot)
                           + distdot * (  2*dy   ) + dist * (            2*   dydot);
            dxyz[3*ipnt+2] = xolddot * ( -2*dz*dx) + xold * (-2*dz*dxdot-2*dx*dzdot)
                           + yolddot * ( -2*dz*dy) + yold * (-2*dz*dydot-2*dy*dzdot)
                           + zolddot * (1-2*dz*dz) + zold * (-4*dz*dzdot           )
                           + distdot * (  2*dz   ) + dist * (            2*   dzdot);
        }

        for (ipnt = 0; ipnt < nxyz; ipnt++) {
            xold = xyz_pnt[3*ipnt  ];
            yold = xyz_pnt[3*ipnt+1];
            zold = xyz_pnt[3*ipnt+2];

            xyz_pnt[3*ipnt  ] = xold * (1-2*dx*dx) + yold * ( -2*dy*dx) + zold * ( -2*dz*dx) + 2*dist*dx;
            xyz_pnt[3*ipnt+1] = xold * ( -2*dx*dy) + yold * (1-2*dy*dy) + zold * ( -2*dz*dy) + 2*dist*dy;
            xyz_pnt[3*ipnt+2] = xold * ( -2*dx*dz) + yold * ( -2*dy*dz) + zold * (1-2*dz*dz) + 2*dist*dz;
        }

    /* applycsys */
    } else if (MODL->body[jbody].brtype == OCSM_APPLYCSYS) {
        SPRINT1(2, "            -> applycsys (jbody=%d)", jbody);

    }

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   plotFace - level 3 GRAFIC routine for plotting tiled domain        *
 *                                                                      *
 ************************************************************************
 */

#ifdef GRAFIC
static void
plotFace(int    *ifunct,                /* (in)  GRAFIC function indicator */
         void   *modl,                  /* (in)  pointer to tile   structure */
         void   *ibodyP,                /* (in)  Body index (bias-1) */
         void   *ifaceP,                /* (in)  Face index (bias-1) */
         void   *isymbP,                /* (in)  =1 if symbols to be plotted */
         void   *a4,                    /* (in)  dummy GRAFIC argument */
         void   *a5,                    /* (in)  dummy GRAFIC argument */
         void   *a6,                    /* (in)  dummy GRAFIC argument */
         void   *a7,                    /* (in)  dummy GRAFIC argument */
         void   *a8,                    /* (in)  dummy GRAFIC argument */
         void   *a9,                    /* (in)  dummy GRAFIC argument */
         float  *scale,                 /* (out) array of scales */
         char   *text,                  /* (out) help text */
         int    textlen)                /* (in)  length of text */
{
    modl_T   *MODL   = (modl_T   *) modl;
    int      *ibody  = (int      *) ibodyP;
    int      *iface  = (int      *) ifaceP;
    int      *isymb  = (int      *) isymbP;

    int      status, nloop, iloop, iedge, nedge, ibest;
    int      oclass, mtype, *senses, i, periodic, ipnt, npnt=101;
    double   data[18], uvrange[4], tt, dbest, dtest, ubest, vbest;
    double   umin=0, umax=0, vmin=0, vmax=0;
    float    u4, v4, ucrsgr, vcrsgr;
    char     dum[] = " ";
    ego      *eloops, eref, *eedges;

    int      iblack  = GR_BLACK;
    int      isquare = GR_SQUARE;
    int      iplus   = GR_PLUS;
    int      icircle = GR_CIRCLE;
    int      init    = 1;
    int      izero   = 0;
    int      icolor  = 0;
    int      jcolors[] = {GR_RED, GR_GREEN, GR_BLUE, GR_CYAN, GR_MAGENTA};

    ROUTINE(plotFace);

    /* --------------------------------------------------------------- */

    /* return scales */
    if (*ifunct == 0) {
        status = EG_getRange(MODL->body[*ibody].face[*iface].eface, uvrange, &periodic);
        CHECK_STATUS(EG_getRange);

        scale[0] = uvrange[0];
        scale[1] = uvrange[1];
        scale[2] = uvrange[2];
        scale[3] = uvrange[3];

        sprintf(text, "Exam Near Symb");

    /* plot image */
    } else if (*ifunct == 1) {

        /* get the Loops for this Face */
        status = EG_getBodyTopos(MODL->body[*ibody].ebody, MODL->body[*ibody].face[*iface].eface,
                                 LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);

        /* get the Edges in each Loop */
        for (iloop = 0; iloop < nloop; iloop++) {
            status = EG_getTopology(eloops[iloop], &eref, &oclass, &mtype, data, &nedge, &eedges, &senses);
            CHECK_STATUS(EG_getTopology);

            for (i = 0; i < nedge; i++) {
                grcolr_(&(jcolors[icolor]));

                status = EG_getRange(eedges[nedge+i], uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    tt = uvrange[0] + (uvrange[1] - uvrange[0]) * (double)(ipnt) / (double)(npnt-1);

                    status = EG_evaluate(eedges[nedge+i], &tt, data);
                    CHECK_STATUS(EG_evaluate);

                    u4 = data[0];
                    v4 = data[1];

                    if (ipnt == 0) {
                        grmov2_(&u4, &v4);
                    } else {
                        grdrw2_(&u4, &v4);
                    }

                    if (ipnt == 0 || ipnt == npnt-1) {
                        grsymb_(&isquare);
                    } else if (*isymb == 1) {
                        grsymb_(&iplus);
                    }
                }

                icolor = (icolor + 1) % 5;   // next color
                npnt++;                      // discretize each Edge a bit differently
            }
        }

        EG_free(eloops);

        grcolr_(&iblack);

    /* "E"xamine option */
    } else if (*ifunct == -5) {

        ocsmPrintEgo(MODL->body[*ibody].face[*iface].eface);

        /* get the Loops for this Face */
        status = EG_getBodyTopos(MODL->body[*ibody].ebody, MODL->body[*ibody].face[*iface].eface,
                                 LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);

        /* get the Edges in each Loop */
        for (iloop = 0; iloop < nloop; iloop++) {
            SPRINT1(1, "Loop %5d", iloop+1);
            status = EG_getTopology(eloops[iloop], &eref, &oclass, &mtype, data, &nedge, &eedges, &senses);
            CHECK_STATUS(EG_getTopology);

            for (iedge = 0; iedge < nedge; iedge++) {
                status = EG_getRange(eedges[nedge+iedge], uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    tt = uvrange[0] + (uvrange[1] - uvrange[0]) * (double)(ipnt) / (double)(npnt-1);

                    status = EG_evaluate(eedges[nedge+iedge], &tt, data);
                    CHECK_STATUS(EG_evaluate);

                    if (ipnt == 0) {
                        umin = data[0];
                        umax = data[0];
                        vmin = data[1];
                        vmax = data[1];
                    } else {
                        if (data[0] < umin) umin = data[0];
                        if (data[0] > umax) umax = data[0];
                        if (data[1] < vmin) vmin = data[1];
                        if (data[1] > vmax) vmax = data[1];
                    }
                }

                SPRINT5(1, "Edge %5d: umin=%12.4f, umax=%12.4f, vmin=%12.4f, vmax=%12.4f",
                        EG_indexBodyTopo(MODL->body[*ibody].ebody, eedges[iedge]),
                        umin, umax, vmin, vmax);
            }
        }

        EG_free(eloops);

    /* "N"earest option */
    } else if (*ifunct == -14) {
        grvalu_("XCRSGR", &izero, &ucrsgr, dum, STRLEN("XCRSGR"), STRLEN(dum));
        grvalu_("YCRSGR", &izero, &vcrsgr, dum, STRLEN("YCRSGR"), STRLEN(dum));
        SPRINT2(1, "ucrsgr=%f, vcrsgr=%f", ucrsgr, vcrsgr);

        dbest = HUGEQ;
        ibest = -1;

        /* get the Loops for this Face */
        status = EG_getBodyTopos(MODL->body[*ibody].ebody, MODL->body[*ibody].face[*iface].eface,
                                 LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);

        /* get the Edges in each Loop */
        for (iloop = 0; iloop < nloop; iloop++) {
            status = EG_getTopology(eloops[iloop], &eref, &oclass, &mtype, data, &nedge, &eedges, &senses);
            CHECK_STATUS(EG_getTopology);

            for (iedge = 0; iedge < nedge; iedge++) {
                status = EG_getRange(eedges[nedge+iedge], uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    tt = uvrange[0] + (uvrange[1] - uvrange[0]) * (double)(ipnt) / (double)(npnt-1);

                    status = EG_evaluate(eedges[nedge+iedge], &tt, data);
                    CHECK_STATUS(EG_evaluate);

                    dtest = (ucrsgr - data[0]) * (ucrsgr - data[0])
                          + (vcrsgr - data[1]) * (vcrsgr - data[1]);
                    if (dtest < dbest) {
                        dbest = dtest;
                        ibest = iedge;
                        ubest = data[0];
                        vbest = data[1];
                    }
                }

                npnt++;
            }
        }

        EG_free(eloops);

        SPRINT3(1, "ibest=%d, uvbest=%f, %f", ibest, ubest, vbest);

        u4 = ubest;
        v4 = vbest;
        grmov2_(&u4, &v4);
        grsymb_(&icircle);

    /* "S"ymbols option */
    } else if (*ifunct == -19) {
        if (*isymb == 0) {
            *isymb  = 1;
        } else {
            *isymb  = 0;
        }

        isymbP = (void*)(isymb);

        grscpt_(&init, "R", STRLEN("R"));

    } else {
        SPRINT0(0, "Illegal option selected");
    }

cleanup:
    return;
}
#endif // GRAFIC


/*
 ************************************************************************
 *                                                                      *
 *   printBacktrace - print a backtrace                                 *
 *                                                                      *
 ************************************************************************
 */

#ifdef BACKTRACE
static void
printBacktrace()
{
    void*  callstack[128];
    int    i, frames = backtrace(callstack, 128);
    char** strs = backtrace_symbols(callstack, frames);

    for (i = 0; i < frames; ++i) {
        SPRINT1(0, "%s", strs[i]);
    }

    free(strs);
}
#endif // BACKTRACE
