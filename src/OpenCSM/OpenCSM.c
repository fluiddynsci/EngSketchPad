/*
 ************************************************************************
 *                                                                      *
 * OpenCSM -- an open-source constructive solid modeler                 *
 *                                                                      *
 *            Written by John Dannenhoffer @ Syracuse University        *
 *                                                                      *
 ************************************************************************
 */

/*
 * Copyright (C) 2010/2022  John F. Dannenhoffer, III (Syracuse University)
 *
 * This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 *     MA  02110-1301  USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <float.h>
#include <math.h>
#include <assert.h>
#include <sys/stat.h>

#define FORCE_FINITE_DIFFS  0           /* =1 to force finite differences */
#define INTERP_VEL          6           /* =0 use eggMorph, =1 use MVC, =2 use VR-MVC, =3 use RBF, =4 use smoothing, =5 use Laplace, =6 use egads coarse mapping */
#define MORPH_GRID          1           /* =0 use EG_mapTessBody, =1 use EGG_morph if possible */

/*#define ANALYTIC_SKETCH     1*/           /* uncomment to compute analytic sketch sensitivities */

#define PRINT_BODYS         0           /* =1 to print Bodys for each statement */
#define PRINT_PROGRESS      0           /* =1 to print progress at end of each Branch */
#define PRINT_TESSSENS      0           /* =1 to print at each stage of tessellation sensitivity generation */
#define PRINT_BODY_INFO     0           /* =1 to print Body info for all Bodys on stack */
#define SHOW_SPLINES        0           /* =1 to show splines with GRAFIC */
#define PRINT_CALLHISTORY   0           /* =1 to generate callHistory associated with sensitivities */

#define PLOT_ARCLENGTHS     0           /* =1 to plot arclength distributions           (need "make grafic") */
#define PLOT_TRIMCURVES     0           /* =1 to plot trim curves at end of ocsmBuild   (need "make grafic") */

#include "common.h"
#include "OpenCSM.h"
#include "udp.h"
#include "egg.h"
#include "egads_dot.h"
#include "egadsSplineVels.h"

#if PRINT_PROGRESS
    #define PPRINT_INIT(MESG)  cpu_beg = clock(); SPRINT0(0, #MESG);
    #define PPRINT0(MESG)      cpu_end = clock(); SPRINT1(0, "...%10.3f sec: " #MESG, (double)(cpu_end-cpu_beg)/(double)(CLOCKS_PER_SEC)); cpu_beg=cpu_end;
    #define PPRINT1(MESG,A)    cpu_end = clock(); SPRINT2(0, "...%10.3f sec: " #MESG, (double)(cpu_end-cpu_beg)/(double)(CLOCKS_PER_SEC), A); cpu_beg=cpu_end;
    #define PPRINT2(MESG,A,B)  cpu_end = clock(); SPRINT3(0, "...%10.3f sec: " #MESG, (double)(cpu_end-cpu_beg)/(double)(CLOCKS_PER_SEC), A, B); cpu_beg=cpu_end;
#else
    #define PPRINT_INIT(MESG)
    #define PPRINT0(MESG)
    #define PPRINT1(MESG,A)
    #define PPRINT2(MESG,A,B)
#endif

#ifdef WIN32
    #include <windows.h>
    #include <direct.h>
    #define  snprintf    _snprintf
    #define  strcasecmp  _stricmp
    #define  SLASH       '\\'
    #define  DLL         HINSTANCE
    #define  getcwd      _getcwd
    #define  MKDIR(A)    mkdir(A)
#else
    #include <strings.h>
    #include <unistd.h>
    #include <dlfcn.h>
    #define  SLASH       '/'
    #define  DLL         void *
    #define  MKDIR(A)    mkdir(A, 0777)
#endif

#define CINT    const int
#define CDOUBLE const double
#define CCHAR   const char
#define STRNCPY(TO, FROM, LEN) strncpy(TO, FROM, LEN); TO[LEN-1] = '\0';

#define   DTIME_NOM           0.00001     /* nominal finite difference step */

#if SHOW_SPLINES
    #include "grafic.h"
#endif

#ifdef GRAFIC
    #include "grafic.h"
#endif

#ifndef WIN32
//    #define BACKTRACE
#endif
#ifdef BACKTRACE
    #include <execinfo.h>
#endif

#define OCSM_MAGIC        4433340       /* magic number */
#define TESS_PARAM_0      0.0250
#define TESS_PARAM_1      0.0075
#define TESS_PARAM_2      20.0

/*
 ************************************************************************
 *                                                                      *
 * Structures                                                           *
 *                                                                      *
 ************************************************************************
 */

/* "Rpn" contains information associated with Rpn (pseudo-code) */
typedef struct {
    int    type;                       /* type (see below) */
    char   text[MAX_STRVAL_LEN];       /* associated text */
} rpn_T;

/* "Stack" is used within the RPN evaluator */
typedef struct {
    double val;                        /* value */
    double dot;                        /* velocity */
    int    nan;                        /* =1 if NaN */
    char   str[MAX_STRVAL_LEN];        /* string value */
} stack_T;

/* "Patn" contains information associated with a patbeg/patend,
          ifthen/elseif/else/endif, catbeg/catend, or macbeg/macend pair */
typedef struct {
    int    itype;                      /* OCSM_PATBEG, OCSM_IFTHEN, OCSM_CATBEG, or OCSM_RECALL */
    int    ibeg;                       /* Branch number of patbeg, ifthen, catbeg, or recall */
    int    iend;                       /* Branch number of patend, endif,  catend */
    int    ncopy;                      /* total number of copies */
    int    icopy;                      /* current instance number (1:ncopy) */
    int    ipmtr;                      /* Parameter index of iterator */
} patn_T;

/* "Sket" is a Sketch */
typedef struct {
    int    type;                       /* 0 for old style, 1 for xy, 2 for yz, 3 for zx */
    int    irel;                       /* =1 if coordinates are relative to SKBEG */
    int    size;                       /* size of x[], y[], and z[] */
    int    solved;                     /* =1 if Sketch is solved */
    int    signal;                     /* =0 if no signal */
    int    ix;                         /* Parameter index associated with ::x[] */
    int    iy;                         /* Parameter index associated with ::y[] */
    int    iz;                         /* Parameter index associated with ::z[] */
    int    id;                         /* Parameter index associated with ::d[] */

    double xbase;                      /* X-coordinate in skbeg statement */
    double ybase;                      /* Y-coordinate in skbeg statement */
    double zbase;                      /* Z-coordinate in skbeg statement */
    double ubase;                      /* X-velocity   in skbeg statement */
    double vbase;                      /* Y-velocity   in skbeg statement */
    double wbase;                      /* Z-velocity   in skbeg statement */

    int    nseg;                       /* number of segments */
    int    itype[MAX_SKETCH_SIZE];     /* Branch type */
    int    ibrch[MAX_SKETCH_SIZE];     /* Branch index */
    double x[    MAX_SKETCH_SIZE];     /* X-coordinate at end of segment */
    double y[    MAX_SKETCH_SIZE];     /* Y-coordinate at end of segment */
    double z[    MAX_SKETCH_SIZE];     /* Z-coordinate at end of segment */
    double u[    MAX_SKETCH_SIZE];     /* X-velocity   at end of segment */
    double v[    MAX_SKETCH_SIZE];     /* Y-velocity   at end of segment */
    double w[    MAX_SKETCH_SIZE];     /* Z-velocity   at end of segment */

    int    nvar;                       /* number of variables (at least 2*nseg) */
    int    ipmtr[MAX_SKETCH_SIZE];     /* Parameter index */
    int    index[MAX_SKETCH_SIZE];     /* value index */

    int    ncon;                       /* number of constraints */
    char   ctype[MAX_SKETCH_SIZE];     /* constraint type (letter) */
    int    ipnt[ MAX_SKETCH_SIZE];     /* first  constraint index */
    int    ip1[  MAX_SKETCH_SIZE];     /* second constraint index */
    char   con[MAX_SKETCH_SIZE][MAX_EXPR_LEN];
} sket_T;

/* user data information for EG_*_vels spline sensitvity functions */
typedef struct {
    int           *isketch;            /* array  of Body numbers sketches */
    modl_T        *MODL;               /* pointer to MODL */
} egadsSpline_T;

/* red-black tree */
typedef struct {
    int    nnode;                      /* current number of Nodes */
    int    mnode;                      /* maximum number of Nodes */
    int    root;                       /* index of root Node */
    int    chunk;                      /* chunk size */
    int*   key1;                       /* array of primary    keys */
    int*   key2;                       /* array of secondary  keys */
    int*   key3;                       /* array of tertiary   keys */
    int*   key4;                       /* array of quaternary keys */
    int*   data;                       /* data associated with entry */
    int*   left;                       /* array of left children */
    int*   rite;                       /* array of rite children */
    int*   prnt;                       /* array of parents */
    int*   colr;                       /* array of colors */
} rbt_T;

/*
 ************************************************************************
 *                                                                      *
 * Definitions (for structures above)                                   *
 *                                                                      *
 ************************************************************************
 */

#define           PARSE_NOP         0   /* no operation */
#define           PARSE_OP1         1   /* either add "+" or subtract "-" */
#define           PARSE_OP2         2   /* either multiply "*" or divide "/" */
#define           PARSE_OP3         3   /* exponentiation "^" */
#define           PARSE_OPENP       4   /* open  parenthesis "(" */
#define           PARSE_CLOSEP      5   /* close parenthesis ")" */
#define           PARSE_OPENB       6   /* open  bracket "[" */
#define           PARSE_CLOSEB      7   /* close bracket "]" */
#define           PARSE_COMMA       8   /* comma "," */
#define           PARSE_NAME        9   /* variable name */
#define           PARSE_ARRAY      10   /* array name */
#define           PARSE_FUNC       11   /* function name */
#define           PARSE_NUMBER     12   /* number */
#define           PARSE_STRING     13   /* string */
#define           PARSE_END        14   /* end of Rpn-code */

#define           RBT_BLACK         0
#define           RBT_RED           1

/*
 ************************************************************************
 *                                                                      *
 * Macros (including those that go along with common.h)                 *
 *                                                                      *
 ************************************************************************
 */

static void *realloc_temp=NULL;              /* used by RALLOC macro */

/*
 ************************************************************************
 *                                                                      *
 * Declarations for support routines defined below                      *
 *                                                                      *
 ************************************************************************
 */

static int addTraceToEdge(modl_T *modl, int ibody, int iedge);
static int addTraceToFace(modl_T *modl, int ibody, int iface);
static int addTraceToNode(modl_T *modl, int ibody, int inode);
static int buildApplied(  modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[]);
static int buildBoolean(  modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[]);
static int buildGrown(    modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[]);
static int buildPrimitive(modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[]);
static int buildSketch(   modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[],
                          int npatn, patn_T patn[], sket_T *sket);
static int buildSolver(   modl_T *modl, int ibrch, varg_T args[], int *nvar, int solvars[],
                          int *ncon, int solcons[]);
static int buildTransform(modl_T *modl, int ibrch, varg_T args[], int *nstack, int stack[]);
static int colorizeEdge(modl_T *modl, int ibody, int iedge);
static int colorizeFace(modl_T *modl, int ibody, int iface);
static int colorizeNode(modl_T *modl, int ibody, int inode);
static int computeMassProps(modl_T *modl);
static int computeMassPropsDot(modl_T *modl);
       int convertToBSplines(ego inbody, double mat[], ego *ebody);
static int createPerturbation(modl_T *modl);
       int createTessVels(modl_T *modl, int ibody);
static int createVelocityCache(modl_T *MODL, int jbody);
static int delPmtrByName(modl_T *modl, char name[]);
static int dumpEgadsFile(modl_T *modl, int ibody);
static int efaceJacobian(modl_T *MODL, int ibody, int iface, double dudue[], double dvdue[], double dudve[], double dvdve[]);
static int evalRpn(rpn_T *rpn, /*@null@*/modl_T *modl, double *val, double *dot, char str[]);
static int faceContains(ego eface, double xx, double yy, double zz);
static int finishBody(modl_T *modl, int ibody);
static int finishCopy(modl_T *modl, int src, /*@null@*/double matrix[], int ibody);
static int finiteDifference(modl_T *modl, int ibody, int seltype, int iselect, int npnt, /*@null@*/double uv[], double dxyz[]);
static int fixSketch(sket_T *sket, char vars_in[], char cons_mod[]);
static int fixSketchRank(sket_T *sket, int npnt, int segtyp[], int *jrank);
static int freeBody(modl_T *modl, int ibody);
static int getBodyTolerance(ego ebody, double *toler);
static int getEdgeHistory(modl_T *MODL, int ibody, int iedge, int *nhist, int *hist[]);
static int getToken(char *text, int nskip, char sep, int maxtok, char *token);
static int joinSheetBodys(modl_T *modl, int ibodyl, int ibodyr, int itype, double toler, ego *ebody);
static int joinWireBodys(modl_T *modl, int ibodyl, int ibodyr, double toler, ego *ebody);
static int makeEdge(modl_T *modl, ego ebeg, ego eend, ego *eedge);
static int makeFace(modl_T *modl, ego eedges[], int fillstyle, int dirn, double toler, ego *eface);
static int matches(char pattern[], const char string[]);
static int matchLoop(ego eloops[]);
static int matchValue(varg_T arg, int itype, int nlist, CINT *tempIlist, CDOUBLE *tempRlist, CCHAR *tempClist);
static int matsol(double A[], double b[], int n, double x[]);
static int mvcInterp(int nloop, CINT nper[], CDOUBLE uvframe[], CDOUBLE uv[], double weights[]);
static int newBody(modl_T *modl, int ibrch, int brtype, int ileft, int irite, /*@null@*/varg_T args[], int hasdots, int botype, int *ibody);
static int parseName(modl_T *modl, char string[], char pname[], int *ipmtr, int *irow, int *icol);
static int printAttrs(ego ebody);
static int printBodyInfo(body_T *body);
static int printPmtrs(modl_T *modl, FILE *fp);
static int rank(double mat[], int nrow, int ncol);
static int rbfWeights(int nbnd, double srad2, CDOUBLE uv[], double duv[], double weights[]);
static int rbtCompareKeys(int ikey1, int jkey1, int ikey2, int jkey2, int ikey3, int jkey3, int ikey4, int jkey4);
static int rbtCreate(int chunk, rbt_T **tree);
static int rbtDelete(rbt_T *tree);
static int rbtInsert(rbt_T *tree, int key1, int key2, int key3, int key4, int data);
static int rbtLookup(rbt_T *tree, int inode);
//$$$static int rbtMaximum(rbt_T *tree, int istart);
//$$$static int rbtMinimum(rbt_T *tree, int istart);
//$$$static int rbtNext(rbt_T *tree, int istart);
//$$$static int rbtPrev(rbt_T *tree, int istart);
static void rbtRotateLeft(rbt_T *tree, int inode);
static void rbtRotateRite(rbt_T *tree, int inode);
static int rbtSearch(rbt_T *tree, int key1, int key2, int key3, int key4);
static int recycleBody(modl_T *modl, int ibrch, int brtype, varg_T args[], int hasdots);
static int removeFaceAttributes(ego ebody);
static int removePerturbation(modl_T *modl);
       int removeVels(modl_T *modl,  int ibody);
static int reorderLoops(modl_T *modl, int nloop, ego eloops[], int startFrom);
static int selectBody(ego emodel, char *order, int index);
static int setEgoAttribute(modl_T *modl, int ibrch, ego eobject);
static int setFaceAttribute(modl_T *modl, int ibody, int iface, int jbody, int jford, int npatn, patn_T *patn);
static int setupAtPmtrs(modl_T *modl, int havesel);
static int setupForFiniteDifferences(modl_T *modl);
static int setupUdprimFile(modl_T *modl, int itype, FILE *csm_file, char filename[], int *linenum, char str[]);
static void signalError(/*@null@*/void *modl, int status, char format[], ...);
static void signalError2(/*@null@*/void *modl, int status, char filename[], int linenum, char format[], ...);
static int solidBoolean(modl_T *modl, ego ebodyl, ego ebodyr, int type, double maxtol, ego *emodel);
static int solveSketch(modl_T *modl, sket_T *sket);
static int solveSketchLM(modl_T *modl, sket_T *sket);
static int solveSketchOrig(modl_T *modl, sket_T *sket);
static int splineVelocityOfBspline(/*@unused@*/void* usrData, /*@unused@*/const ego secs[], /*@unused@*/int isec, /*@unused@*/ego eedge, ego egeom, int *ivec[], double *rvec[], double *rvec_dot[]);
static int splineVelocityOfEdge(void* usrData, /*@unused@*/const ego secs[], int isec, ego eedge, CINT npnt, CDOUBLE ts[], CDOUBLE ts_dot[], double xyz[], double xyz_dot[], double dxdt_beg[], double dxdt_beg_dot[], double dxdt_end[], double dxdt_end_dot[]);
static int splineVelocityOfNode(void* usrData, /*@unused@*/const ego secs[], int isec, ego enode, /*@unused@*/ego eedge, double xyz[], double xyz_dot[]);
static int splineVelocityOfRange(void* usrData, /*@unused@*/const ego secs[], int isec, ego eedge, double trange[], double trange_dot[]);
static int storeCsystem(modl_T *modl, int ibody);
static int str2rpn(char str[], rpn_T *rpn);
static int str2val(char expr[], /*@null@*/modl_T *modl, double *val, double *dot, char str[]);
static int str2valNoSignal(char expr[], modl_T *modl, double *val, double *dot, char str[]);
static int str2vals(char expr[], modl_T *modl, int *nrow, int *ncol, double *vals[], double *dots[], char str[]);
static int solsvd(double A[], double b[], int mrow, int ncol, double W[], double x[]);
static int velocityForPrimitive(modl_T *modl, int ibody, int npnt, double xyz[], double xyz_dot[]);
       int velocityOfEdge(modl_T *modl, int ibody, int iedge, int npnt, /*@null@*/double t[], double dxyz[]);
       int velocityOfFace(modl_T *modl, int ibody, int iface, int npnt, /*@null@*/double uv[], double dxyz[]);
       int velocityOfNode(modl_T *modl, int ibody, int inode, double dxyz[]);
static double wendland(CDOUBLE uv1[], CDOUBLE uv2[], double srad2);
static int writeAsciiStl(modl_T *modl, int nstack, int stack[], char filename[]);
static int writeAsciiUgrid(modl_T *modl, int ibody, char filename[]);
static int writeBinaryStl(modl_T *modl, int nstack, int stack[], char filename[]);
static int writePlotFile(modl_T *modl, int ibody, char filename[]);
static int writeSensFile(modl_T *modl, int ibody, char filename[]);
static int writeTessFile(modl_T *modl, int ibody, char filename[]);
static int xformEdgeToOriginal(modl_T *modl, int ibody, int iedge, double mat[], double *scale);
static int xformFaceToOriginal(modl_T *modl, int ibody, int iface, double mat[], double *scale);
static int xformNodeToOriginal(modl_T *modl, int ibody, int inode, double mat[], double *scale);
static int xformVelocity(modl_T *modl, int jbody, int nxyz, double xyz_pnt[], double dxyz[]);

#ifdef GRAFIC
static void plotFace(int*, void*, void*, void*, void*, void*,
                           void*, void*, void*, void*, void*, float*, char*, int);
static void plotVels(int*, void*, void*, void*, void*, void*,
                           void*, void*, void*, void*, void*, float*, char*, int);
#endif

#ifdef BACKTRACE
static void printBacktrace();
#endif

/* non-prototyped EGADS routines */
extern int EG_getEdgeUVeval(ego eface, ego eedge, int sense, double t, double *uv);
extern int EG_getTessEFace(ego tess, int index, ego *faces, double *uvs);
extern int EG_sensitTopo(int iface, double r[], double dxyz[]);
extern int EG_setUserPointer(ego context, void *ptr);
extern int EG_spline1dTan(int imaxx, /*@null@*/const double *t1, const double *xyz, /*@null@*/const double *tn, /*@null@*/const double *kn, double tol, int *ivec, double **rdata);
extern int EG_getTessFrame(const ego tess, int index, const egBary **bary, int *nftri, const int **ftris);

#if PRINT_CALLHISTORY > 0
   FILE *fp_callHistory;
   int  i_callHistory, indent_callHistory=0;
#endif

/*
 ************************************************************************
 *                                                                      *
 * Global variables and defines                                         *
 *                                                                      *
 ************************************************************************
 */

static int outLevel  = 1;     /* global since it needs to be settable
                                 before a MODL is created */

static void *auxPtr  = NULL;  /* auxiliary pointer */

/*
 ************************************************************************
 *                                                                      *
 * Process for computing sensitivities                                  *
 *                                                                      *
 ************************************************************************

   ocsmLoad, ocsmCopy
      dtime   = 0
      perturb = NULL

   ocsmFree, ocsmNewBrch, ocsmSetBrch, ocsmDelBrch, ocsmSetArg, ocsmSetValu, ocsmSetValuD, ocsmSetVel, ocsmSetVelD
      removePerturbation
      removeVels

   ocsmSetDtime
      dtime = input
      removePerturbation
      removeVels
      if (dtime != 0)
         createPerturbation

   ocsmGetVel
      ocsmTessellate
      setupForFiniteDifferences
      if (dtime == -2)
         vel = 0
         return
      if (NODE)
         vel = velocityOfNode
      elseif (EDGE)
         temp = velocityOfEdge
         vel = normal component of temp
      elseif (FACE)
         vel = velocityOfFace

   ocsmGetTessVel
      setupForFiniteDifferences
      createTessVels
      if (NODE)
         vel = node.dxyz
      elseif (EDGE)
         vel = edge.dxyz
      elseif (FACE)
         vel = face.dxyz

   ===================================

   setupForFiniteDifferences
      if (FORCE_FINITE_DIFFS)
         dtime = DTIME_NOM
      if (perturb == NULL && dtime == 0 && ibody has a Branch that does not have analytic sensitivities)
         dtime = DTIME_NOM
      if (perturb == NULL && dtime > 0)
         createPerturbation

   createPerturbation
      if (dtime == -2)
         return
      if (perturb != NULL)
         mapTessBody(base -> perturb)
         return
      try increasingly smaller dtime
         copy(base -> perturb)
         ocsmBuild(perturb)
         if (base and perturb match topologically)
            return
         elseif (ran out of tries)
            dtime = -2
            return
         else
            dtime /= -2

   createTessVels
      ocsmTessellate
      initialize node.dxyz, edge.dt, edge.dxyz, face.duv. face.dxyz
      if (perturb != NULL)
         dxyz.node = (perturb - base) / dtime
         dyxz.edge = (perturb - base) / dtime
         dxyz.face = (perturb - base) / dtime
         return
      face.dxyz = velocityOfFace
      edge.dxyz = combination of face.dxyz
      node.dxyz = combination of edge.dxyz
      update boundary edge.dt because of trimming changes
      update boundary face.duv because of trimming changes
      if (EGG)
         update interior face.duv by morphing
      else
         update interior face.duv by MVC
         update face.dxyz from face.duv

   finiteDifferences
      if (dtime == -2)
         vel = 0
      elseif (FACE or EDGE or NODE)
         vel = (perturb - base) / dtime

   removePerturbation
      free(perturb)
      dtime   = 0
      perturb = NULL

   removeVels
      free(node.dxyz)
      free(edge.dt)
      free(edge.dxyz)
      free(face.duv)
      free(face.dxyz)

   velocityOfFace(ibody, iface)
      if (perturb != NULL)
         vel = finiteDifferences
         return
      find Body and Face in which Face first exists (jbody,jface)
      find transformation matrix from (ibody,iface) to (jbody,jface)
      if (jbody.hasdots == 0)
         vel = 0
      elseif (BOX, SPHERE, CONE, CYLINDER, or UDPRIM)
         ...
      elseif (EXTRUDE)
         if (side)
            vel = velocityOfEdge
         elseif (beg or end)
            find transformation between EXTRUDE and SKETCH
            vel = 0
            apply transformation back to EXTRUDE
      elseif (RULE)
         ...
      else
         vel = finiteDifferences
         return
      transform velocity back to ibody

   velocityOfEdge(ibody, iedge)
      if (DEGENERATE)
         vel = 0
         return
      if (perturb != NULL)
         vel = finiteDifferences
         return
      find Body and Edge in which Edge first exists (jbody,jedge)
      if (jedge was generated by BOOLEAN or GROWN)
         vleft = velocityOfFace(ileft)
         vrite = velocityOfFace(irite)
         vel = combination of vleft and vrite
         return
      find transformation matrix from (ibody,iedge) to (jbody,jedge)
      if (jbody.hasdots == 0)
         vel = 0
      elseif (BOX, SPHERE, CONE, CYLINDER, or UDPRIM)
         ...
      else
         vel = finiteDifferences
         return
      transform velocity back to ibody

   velocityOfNode(ibody, inode)
      if (perturb != NULL)
         vel = finiteDifferences
         return
      find Body and Node in which Node first exists (jbody, jnode)
      if (jnode was generate by BOOLEAN, GROWN, or UDPRIM)
         v1 = velocityOfEdge(edge1)
         ..
         vel = combination of v1, v2, ...
         return
      find transformation matrix from (ibody,inode) to (jbody,jnode)
      if (jbody.hasdits == 0)
         vel = 0
      elseif (BOX, SPHERE, CONE, or CYLINDER)
         ...
      else
         vel = finiteDifferences
         return
      transform velocity back to ibody
 */


/*
 ************************************************************************
 *                                                                      *
 *   ocsmVersion - return current version                               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmVersion(int    *imajor,             /* (out) major version number */
            int    *iminor)             /* (out) minor version number */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(ocsmVersion);

    /* --------------------------------------------------------------- */

    *imajor = OCSM_MAJOR_VERSION;
    *iminor = OCSM_MINOR_VERSION;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetOutLevel - set output level                                 *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetOutLevel(int    ilevel)      /* (in)  output level: */
                                    /*       <0 do not change */
                                    /*       =0 errors only */
                                    /*       =1 nominal (default) */
                                    /*       =2 debug */
{
    int       old_outLevel = 0;     /* (out) previous outLevel */

    ROUTINE(ocsmSetOutLevel);

    /* --------------------------------------------------------------- */

    /* note that this does not change EGADS' outLevel (since we do not
       have access to the EGADS context -- in fact it might not be
       created yet) */

    old_outLevel = outLevel;       /* global variable */
    if (ilevel >= 0) {
        outLevel     = ilevel;
    }

//cleanup:
    return old_outLevel;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetAuxPtr - set (global) auxiliary pointer                     *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetAuxPtr(void   *newAuxPtr)        /* (in)  auxiliary pointer */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(ocsmSetAuxPtr);

    /* --------------------------------------------------------------- */

    auxPtr = newAuxPtr;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetAuxPtr - get (global) auxiliary pointer                     *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetAuxPtr(void   **oldAuxPtr)       /* (out) auxiliary pointer */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(ocsmGetAuxPtr);

    /* --------------------------------------------------------------- */

    *oldAuxPtr = auxPtr;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmLoad - create a MODL by reading a .csm file                    *
 *                                                                      *
 ************************************************************************
 */

int
ocsmLoad(char   filename[],             /* (in)  file to be read (with .csm) */
         void   **modl)                 /* (out) pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL=NULL;

    /* Sketch contains linsegs, cirarcs, splines, and beziers */
    int       nskpt;

    /* number of open patterns */
    int       npatn = 0;

    int       filelen, filetype, linenum, numudc;
    int       i, j, k, inquote, narg, irow, nrow, icol, ncol, indx, count;
    int       ibrch, jbrch, ipmtr, jpmtr, icount, jcount, insolver, ival, nval;
    int       udp_num, *udp_types, *udp_idef, ifound;
    double    value, dot, bound, *udp_ddef;
    char      *templine=NULL, *nextline=NULL, *command=NULL, *str=NULL;
    char      *str1=NULL, *str2=NULL, *str3=NULL;
    char      *str4=NULL, *str5=NULL, *str6=NULL;
    char      *str7=NULL, *str8=NULL, *str9=NULL;
    char      defn[MAX_EXPR_LEN], tmpfilename[MAX_EXPR_LEN], pathname[MAX_EXPR_LEN];
    char      pmtrName[MAX_EXPR_LEN], **udp_names;
    void      *temp;

    FILE      *fp_csm=NULL;

    ROUTINE(ocsmLoad);

#define CHECK_STATUS2(X)                                                \
    if (status < SUCCESS) {                                             \
        signalError2(MODL, status,                                      \
                     filename, linenum,                                 \
                     "error detected in %s during ocsmLoad()", #X);     \
        goto cleanup;                                                   \
    }

    /* --------------------------------------------------------------- */

    SPRINT1(1, "--> enter ocsmLoad(filename=%s)", filename);

    linenum = 0;

    /* check for valid extension */
    filelen = STRLEN(filename);
    if (filelen == 0) {
        filetype = -1;
    } else if (filelen < 5) {
        SPRINT0(2, "    illegal filename");
        filetype = 0;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'c' &&
               filename[filelen-2] == 's' && filename[filelen-1] == 'm'   ) {
        SPRINT0(2, "    reading .csm file");
        filetype = 0;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'c' &&
               filename[filelen-2] == 'p' && filename[filelen-1] == 'c'   ) {
        SPRINT0(2, "    reading .cpc file");
        filetype = 1;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'u' &&
               filename[filelen-2] == 'd' && filename[filelen-1] == 'c'   ) {
        SPRINT0(2, "    reading .udc file");
        filetype = 2;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'v' &&
               filename[filelen-2] == 'f' && filename[filelen-1] == 'y'   ) {
        SPRINT0(2, "    reading .vfy file");
        filetype = 3;
    } else {
        *modl  = NULL;
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    if (FORCE_FINITE_DIFFS == 1) {
        SPRINT0(0, "WARNING:: ***************************************");
        SPRINT0(0, "WARNING:: all sensitivities by finite differences");
        SPRINT0(0, "WARNING:: ***************************************");
    }

    if (MORPH_GRID != 1) {
        SPRINT1(0, "MORPH_GRID = %d", MORPH_GRID);
    }

    MALLOC(templine, char, MAX_LINE_LEN);
    MALLOC(nextline, char, MAX_LINE_LEN);
    MALLOC(command,  char, MAX_LINE_LEN);

    MALLOC(str,  char, MAX_STRVAL_LEN);

    MALLOC(str1, char, MAX_LINE_LEN);
    MALLOC(str2, char, MAX_LINE_LEN);
    MALLOC(str3, char, MAX_LINE_LEN);
    MALLOC(str4, char, MAX_LINE_LEN);
    MALLOC(str5, char, MAX_LINE_LEN);
    MALLOC(str6, char, MAX_LINE_LEN);
    MALLOC(str7, char, MAX_LINE_LEN);
    MALLOC(str8, char, MAX_LINE_LEN);
    MALLOC(str9, char, MAX_LINE_LEN);

    /* initializtions are only done if a .csm or .cpc file */
    if (filetype == -1 || filetype == 0 || filetype == 1) {

        /* make a new MODL and initialize it */
        MALLOC(MODL, modl_T, 1);

        MODL->magic      = OCSM_MAGIC;
        MODL->checked    = 0;
        MODL->ibrch      = 0;
        MODL->nextseq    = 1;
        MODL->ngroup     = 0;
        MODL->recycle    = 0;
        MODL->verify     = 0;
        MODL->cleanup    = 25;
        MODL->dumpEgads  = 0;
        MODL->loadEgads  = 0;
        MODL->hasMPs     = 0;
        MODL->printStack = 0;
        MODL->tessAtEnd  = 1;
        MODL->erepAtEnd  = 0;
        MODL->bodyLoaded = 0;

        MODL->seltype = -1;
        MODL->selbody = -1;
        MODL->selsize =  0;
        MODL->sellist = NULL;

        MODL->level = 0;

        for (i = 0; i < 11; i++) {
            MODL->scope[i] = 0;
        }

        if (STRLEN(filename) == 0) {
            MODL->filename[0] = '\0';
        } else {
            /*@ignore@*/
            STRNCPY(MODL->filename, filename, MAX_FILENAME_LEN);
            /*@end@*/
        }

        MODL->tmpDirNum = -1;

        MODL->ninline = 0;
        MODL->minline = 0;
        MODL->sinline = NULL;

        MODL->nattr = 0;
        MODL->attr  = NULL;

        MODL->nstor = 0;
        MODL->stor  = NULL;

        MODL->nbrch = 0;
        MODL->mbrch = 0;
        MODL->brch  = NULL;

        MODL->npmtr = 0;
        MODL->mpmtr = 0;
        MODL->pmtr  = NULL;

        MODL->nbody = 0;
        MODL->mbody = 0;
        MODL->body  = NULL;

        MODL->numdots    = 0;
        MODL->perturb    = NULL;
        MODL->basemodl   = NULL;
        MODL->dtime      = 0;

        MODL->context     = NULL;
        MODL->userdata    = NULL;
        MODL->mesgCB      = NULL;
        MODL->sizeCB      = NULL;
        MODL->eggname[0]  = '\0';
        MODL->eggGenerate = NULL;
        MODL->eggMorph    = NULL;
        MODL->eggInfo     = NULL;
        MODL->eggDump     = NULL;
        MODL->eggLoad     = NULL;
        MODL->eggFree     = NULL;

        MODL->nwarn   = 0;
        MODL->sigCode = 0;
        MODL->sigMesg = NULL;
        MALLOC(MODL->sigMesg, char, MAX_STR_LEN);
        MODL->sigMesg[0] = '\0';

        for (i = 0; i < 101; i++) {
            MODL->profile[i].ncall = 0;
            MODL->profile[i].time  = 0;
        }

    /* if reading a .udc file ensure that we are already
       reading a .csm or .cpc file */
    } else if (filetype == 2) {
        MODL = *modl;

        assert (MODL != NULL);
        assert (STRLEN(MODL->filename) > 0);

    /* if reading a .vfy file ensure that we are already
       reading a .csm or .cpc file */
    } else {
        MODL = *modl;

        assert (MODL != NULL);
        assert (STRLEN(MODL->filename) > 0);
    }

    /* return value */
    *modl = MODL;

    if (filetype == -1) {
        SPRINT0(1, "WARNING:: loading empty MODL");
        (MODL->nwarn)++;
        goto cleanup;
    }

    if (STRLEN(filename) > MAX_FILENAME_LEN) {
        status = OCSM_ILLEGAL_ARGUMENT;
        signalError2(MODL, status, filename, linenum,
                    "filename has more than %d characters", MAX_FILENAME_LEN);
        goto cleanup;
    }

    /* open the file */
    if (STRLEN(filename) > 0) {
        fp_csm = fopen(filename, "r");
        if (fp_csm == NULL) {
            if (strstr(filename, ".vfy") != NULL) {
                SPRINT1(0, "WARNING:: cannot open \"%s\", so verification is being skipped", filename);
                (MODL->nwarn)++;
                status = SUCCESS;
            } else {
                status = OCSM_FILE_NOT_FOUND;
                signalError2(MODL, status, filename, linenum,
                            "file \"%s\" not found", filename);
                goto cleanup;
            }
            goto cleanup;
        }
    }

    /* initialize the number of active Sketch points, patterns, and active UDCs */
    nskpt  = 0;
    npatn  = 0;
    numudc = 0;

    insolver = 0;

    SPLINT_CHECK_FOR_NULL(MODL);

    /* read commands from .csm file until the end of file */
    /*   note that we should not use feof here since we will
         prematurely exit loop if last line does not end with CR/LF */
    while (fp_csm != NULL) {

        /* read the next line */
        temp = fgets(templine, MAX_LINE_LEN, fp_csm);
        linenum++;

        /* we have found the end of the current file (without an end statement) */
        if (temp == NULL) {

            /* in a UDC */
            if (filetype == 2) {
                SPLINT_CHECK_FOR_NULL(MODL->brch);

                /* if there is no END, add it now */
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_END, filename, linenum,
                                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                    CHECK_STATUS2(ocsmNewBrch);

                /* decrement the level */
                (MODL->level)--;

                SPRINT0(1, "\n<<< Reverting to parent file (EOF detected)\n");
            }

            /* close the file and exit */
            fclose(fp_csm);
            fp_csm = NULL;

            break;
        }

        /* ignore spaces at the beginning of the line */
        for (j = 0; j < STRLEN(templine); j++) {
            if (templine[0] == ' ') {
                for (k = 0; k < STRLEN(templine); k++) {
                    templine[k] = templine[k+1];
                }
            }
        }

        /* process the next line:
           - ignore anything after a #
           - ignore anything after a \ and concatenate next line
           - remove any spaces between double quotes (") so that a user
             could include spaces within an expression as long as
             it is surrounded by double quotes */
        if (templine[0] != '#') {
            SPLINT_CHECK_FOR_NULL(fp_csm);

            inquote = 0;
            j       = 0;
            for (i = 0; i < STRLEN(templine); i++) {
                if (templine[i] == '#') {
                    nextline[j++] = '\0';
                    break;
                } else if (templine[i] == '\\') {
                    linenum++;
                    if (fgets(templine, MAX_LINE_LEN, fp_csm) == NULL) break;
                    i = -1;
                } else if (templine[i] == '"') {
                    inquote = 1 - inquote;
                } else if (templine[i] == ' '  || templine[i] == '\t' ||
                           templine[i] == '\r' || templine[i] == '\n'   ) {
                    if (inquote == 0 && j > 0) {
                        nextline[j++] = templine[i];
                    }
                } else {
                    nextline[j++] = templine[i];
                }

                if (j >= MAX_LINE_LEN-2) {
                    status = OCSM_ILLEGAL_STATEMENT;
                    signalError2(MODL, status, filename, linenum,
                                "input line is too long");
                    goto cleanup;
                }
            }
        } else {
            STRNCPY(nextline, templine, MAX_LINE_LEN);
            j = STRLEN(nextline);
        }
        nextline[j++] = '\0';

        /* strip white spaces from end of nextline */
        for (i = j-2; i >= 0; i--) {
            if (nextline[i] == ' '  || nextline[i] == '\t' ||
                nextline[i] == '\r' || nextline[i] == '\n'   ) {
                nextline[i] = '\0';
            } else {
                break;
            }
        }
        SPRINT4(1, "    nextline (%2d:%4d)[%4d]: %s", MODL->level, linenum, MODL->ibrch+1, nextline);
        if (STRLEN(nextline) <= 1) continue;

        /* get the command from the next input line */
        sscanf(nextline, "%2047s", command);

        /* input is: "# comment" */
        if (strncmp(command, "#", 1) == 0) {
            /* nothing to do */

        /* input is: "applycsys $csysName ibody=0" */
        } else if (strcmp(command, "applycsys") == 0 ||
                   strcmp(command, "APPLYCSYS") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "APPLYCSYS cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "APPLYCSYS cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "APPLYCSYS requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_APPLYCSYS, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "assert arg1 arg2 toler=0 verify=0" */
        } else if (strcmp(command, "assert") == 0 ||
                   strcmp(command, "ASSERT") == 0   ) {

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg < 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "ASSERT requires at least 2 arguments");
                goto cleanup;
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }
            if (narg < 4) {
                strcpy(str4, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_ASSERT, filename, linenum,
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "arc xend yend zend dist $plane=xy" */
        } else if (strcmp(command, "arc") == 0 ||
                   strcmp(command, "ARC") == 0   ) {
            if (nskpt == 0) {
                status = OCSM_SKETCH_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "ARC must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "ARC cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str5, "$");
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2046s\n",
                          str1, str2, str3, str4, &(str5[1]));
            if (narg == 4) {
                STRNCPY(str5, "$xy", MAX_EXPR_LEN);
            } else if (narg == 5) {
                if        (strcmp(str5, "$xy") == 0 || strcmp(str5, "$XY") == 0) {
                    STRNCPY(str5, "$xy", MAX_EXPR_LEN);
                } else if (strcmp(str5, "$yz") == 0 || strcmp(str5, "$YZ") == 0) {
                    STRNCPY(str5, "$yz", MAX_EXPR_LEN);
                } else if (strcmp(str5, "$zx") == 0 || strcmp(str5, "$ZX") == 0) {
                    STRNCPY(str5, "$zx", MAX_EXPR_LEN);
                } else {
                    status = OCSM_ILLEGAL_VALUE;
                    signalError2(MODL, status, filename, linenum,
                                "PLANE must be XY, YZ, or ZX");
                    goto cleanup;
                }
            } else {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "ARC requires at least 4 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_ARC, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++; nskpt++;

        /* input is: "attribute $attrName attrList */
        } else if (strcmp(command, "attribute") == 0 ||
                   strcmp(command, "ATTRIBUTE") == 0   ) {

            /* determine which Branch should be attributed, or if it is
               a global Attribute (ibrch=0) */
            ibrch = 0;
            for (jbrch = MODL->ibrch; jbrch > 0; jbrch--) {
                SPLINT_CHECK_FOR_NULL(MODL->brch);

                if (MODL->brch[jbrch].type != OCSM_SET      &&
                    MODL->brch[jbrch].type != OCSM_DIMENSION  ) {
                    ibrch = jbrch;
                    break;
                }
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "ATTRIBUTE requires 2 arguments");
                goto cleanup;
            }

            /* set the Branch's Attribute */
            if        (ibrch == 0) {
                status = ocsmSetAttr(MODL, ibrch, str1, str2);
                CHECK_STATUS2(ocsmSetAttr);
            } else {
                SPLINT_CHECK_FOR_NULL(MODL->brch);

                if (MODL->brch[ibrch].type == OCSM_ASSERT    ||
                    MODL->brch[ibrch].type == OCSM_CATBEG    ||
                    MODL->brch[ibrch].type == OCSM_CATEND    ||
                    MODL->brch[ibrch].type == OCSM_DIMENSION ||
                    MODL->brch[ibrch].type == OCSM_ELSE      ||
                    MODL->brch[ibrch].type == OCSM_ELSEIF    ||
                    MODL->brch[ibrch].type == OCSM_END       ||
                    MODL->brch[ibrch].type == OCSM_ENDIF     ||
                    MODL->brch[ibrch].type == OCSM_IFTHEN    ||
                    MODL->brch[ibrch].type == OCSM_INTERFACE ||
//                  MODL->brch[ibrch].type == OCSM_LBOUND    ||
                    MODL->brch[ibrch].type == OCSM_MACBEG    ||
                    MODL->brch[ibrch].type == OCSM_MACEND    ||
                    MODL->brch[ibrch].type == OCSM_MARK      ||
                    MODL->brch[ibrch].type == OCSM_PATBEG    ||
                    MODL->brch[ibrch].type == OCSM_PATBREAK  ||
                    MODL->brch[ibrch].type == OCSM_PATEND    ||
                    MODL->brch[ibrch].type == OCSM_PROJECT   ||
//                  MODL->brch[ibrch].type == OCSM_SELECT    ||
                    MODL->brch[ibrch].type == OCSM_SET       ||
                    MODL->brch[ibrch].type == OCSM_EVALUATE  ||
                    MODL->brch[ibrch].type == OCSM_GETATTR   ||
                    MODL->brch[ibrch].type == OCSM_SKBEG     ||
                    MODL->brch[ibrch].type == OCSM_SKCON     ||
                    MODL->brch[ibrch].type == OCSM_SKVAR     ||
                    MODL->brch[ibrch].type == OCSM_SOLBEG    ||
                    MODL->brch[ibrch].type == OCSM_SOLEND    ||
                    MODL->brch[ibrch].type == OCSM_STORE     ||
                    MODL->brch[ibrch].type == OCSM_MESSAGE   ||
                    MODL->brch[ibrch].type == OCSM_SPECIAL   ||
                    MODL->brch[ibrch].type == OCSM_THROW     ||
//                  MODL->brch[ibrch].type == OCSM_UBOUND    ||
                    MODL->brch[ibrch].type == OCSM_UDPARG      ) {
                    status = OCSM_ILLEGAL_ATTRIBUTE;
                    signalError2(MODL, status, filename, linenum,
                                 "a \"%s\" Branch cannot be attributed", ocsmGetText(MODL->brch[ibrch].type));
                    goto cleanup;
                } else {
                    status = ocsmSetAttr(MODL, ibrch, str1, str2);
                    CHECK_STATUS2(ocsmSetAttr);
                }
            }

        /* input is: "bezier x y z" */
        } else if (strcmp(command, "bezier") == 0 ||
                   strcmp(command, "BEZIER") == 0   ) {
            if (nskpt == 0) {
                status = OCSM_SKETCH_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "BEZIER must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "BEZIER cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "BEZIRE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_BEZIER, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "blend begList=0 endList=0 reorder=0 oneFace=0 periodic=0" */
        } else if (strcmp(command, "blend") == 0 ||
                   strcmp(command, "BLEND") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "BLEND cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "BLEND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5);
            if   (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }
            if (narg < 4) {
                STRNCPY(str4, "0", MAX_EXPR_LEN);
            }
            if (narg < 5) {
                STRNCPY(str5, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_BLEND, filename, linenum,
                                 str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "box xbase ybase zbase dx dy dz" */
        } else if (strcmp(command, "box") == 0 ||
                   strcmp(command, "BOX") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "BOX cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "BOX cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6);
            if (narg != 6) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "BOX requires 6 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_BOX, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "catbeg sigCode" */
        } else if (strcmp(command, "catbeg") == 0 ||
                   strcmp(command, "CATBEG") == 0   ) {

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CATBEG requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_CATBEG, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "catend" */
        } else if (strcmp(command, "catend") == 0 ||
                   strcmp(command, "CATEND") == 0   ) {

            /* find the matching catbeg */
            i = 1;
            for (ibrch = MODL->nbrch; ibrch > 0; ibrch--) {
                SPLINT_CHECK_FOR_NULL(MODL->brch);

                if        (MODL->brch[ibrch].type == OCSM_CATEND) {
                    i++;
                } else if (MODL->brch[ibrch].type == OCSM_CATBEG) {
                    i--;
                    if (i == 0) {
                        break;
                    }
                }
            }
            if (ibrch <= 0) {
                status = OCSM_IMPROPER_NESTING;
                signalError2(MODL, status, filename, linenum,
                            "CATEND must follow a CATBEG");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_CATEND, filename, linenum,
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            npatn--;

        /* input is: "cfgpmtr $pmtrName value" */
        } else if (strcmp(command, "cfgpmtr") == 0 ||
                   strcmp(command, "CFGPMTR") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CFGPMTR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CFGPMTR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "CFGPMTR not allowed except at top level");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CFGPMTR requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* make sure that values is a semicolon-separated list of numbers */
            icount = 0;
            while (icount < STRLEN(str2)) {
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] =str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                /* check for a valid number */
                if (sscanf(defn, "%lf", &value) == 0) {
                    status = OCSM_ILLEGAL_VALUE;
                    signalError2(MODL, status, filename, linenum,
                                "values must only contain numbers");
                    goto cleanup;
                }
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS2(parseName);

            /* if it does not exist, create it now */
            if (ipmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_CFGPMTR, 1, 1);
                CHECK_STATUS2(ocsmNewPmtr);
                ipmtr = MODL->npmtr;
            } else {
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                /* if it exists and is UNKNOWN (because of a DIMENSION statemet),
                   convert to a CFGPMTR */
                if (MODL->pmtr[ipmtr].type == OCSM_UNKNOWN) {
                    MODL->pmtr[ipmtr].type = OCSM_CFGPMTR;

                    /* make sure that Parameter is CFGPMTR */
                } else if (MODL->pmtr[ipmtr].type == OCSM_LOCALVAR) {
                    status = OCSM_PMTR_IS_LOCALVAR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is an internal parameter", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {
                    status = OCSM_PMTR_IS_OUTPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is an OUTPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_CONPMTR) {
                    status = OCSM_PMTR_IS_CONPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is a CONPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR) {
                    status = OCSM_PMTR_IS_DESPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is a CFGPMTR", str1);
                    goto cleanup;
                }
            }

            /* store the values for the whole Parameter */
            if ((irow ==    0 && icol ==    0) ||
                (irow == -999 && icol == -999)   ) {
                icount = 0;
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        jcount = 0;

                        while (icount < STRLEN(str2)) {
                            if (str2[icount] == ';') {
                                icount++;
                                break;
                            } else {
                                defn[jcount  ] = str2[icount];
                                defn[jcount+1] = '\0';
                                icount++;
                                jcount++;
                            }
                        }

                        status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                        CHECK_STATUS2(ocsmGetValu);

                        if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                            SPRINT0(1, "WARNING:: value not overwritten");
                            (MODL->nwarn)++;
                        } else {
                            if (strcmp(defn, "") != 0) {
                                status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                                CHECK_STATUS2(ocsmSetValu);
                            }
                        }
                    }
                }

            /* store the values for all rows of the Parameter */
            } else if (irow == -999) {
                icount = 0;
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                    CHECK_STATUS2(ocsmGetValu);

                    if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                        SPRINT0(1, "WARNING:: value not overwritten");
                        (MODL->nwarn)++;
                    } else {
                        if (strcmp(defn, "") != 0) {
                            status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                            CHECK_STATUS2(ocsmSetValu);
                        }
                    }
                }

            /* store the values for all columns of the Parameter */
            } else if (icol == -999) {
                icount = 0;
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                    CHECK_STATUS2(ocsmGetValu);

                    if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                        SPRINT0(1, "WARNING:: value not overwritten");
                        (MODL->nwarn)++;
                    } else {
                        if (strcmp(defn, "") != 0) {
                            status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                            CHECK_STATUS2(ocsmSetValu);
                        }
                    }
                }

            /* store a single value into the Parameter */
            } else {
                if (irow <= 0) irow = 1;
                if (icol <= 0) icol = 1;

                icount = 0;
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] = str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                CHECK_STATUS2(ocsmGetValu);

                if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                    SPRINT0(1, "WARNING:: value not overwritten");
                    (MODL->nwarn)++;
                } else {
                    if (strcmp(defn, "") != 0) {
                        status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                        CHECK_STATUS2(ocsmSetValu);
                    }
                }
            }

        /* input is: "chamfer radius edgeList=0 listStyle=0" */
        } else if (strcmp(command, "chamfer") == 0 ||
                   strcmp(command, "CHAMFER") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CHAMFER cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CHAMFER cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if        (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CHAMFER requires at least 1 argument");
                goto cleanup;
            } else if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_CHAMFER, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "cirarc xon yon zon xend yend zend" */
        } else if (strcmp(command, "cirarc") == 0 ||
                   strcmp(command, "CIRARC") == 0   ) {
            if (nskpt == 0) {
                status = OCSM_SKETCH_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CIRARC msut be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CIRARC cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6);

            if (narg != 6) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CIRARC requires 6 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_CIRARC, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++; nskpt++;

        /* input is: "combine toler=0" */
        } else if (strcmp(command, "combine") == 0 ||
                   strcmp(command, "COMBINE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "COMBINE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "COMBINE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_COMBINE, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "cone xvrtx yvrtx zvrtx xbase ybase zbase radius" */
        } else if (strcmp(command, "cone") == 0 ||
                   strcmp(command, "CONE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CONE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CONE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7);
            if (narg != 7) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CONE requires 7 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_CONE, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "connect faceList1 faceList2 edgeList1=0 edgeList2=0 toler=0" */
        } else if (strcmp(command, "connect") == 0 ||
                   strcmp(command, "CONNECT") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CONNECT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CONNECT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5);
            if (narg < 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CONNECT requires 2 arguments");
                goto cleanup;
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }
            if (narg < 4) {
                strcpy(str4, "0");
            }
            if (narg < 5) {
                strcpy(str5, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_CONNECT, filename, linenum,
                                 str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "conpmtr $pmtrName values" */
        } else if (strcmp(command, "conpmtr") == 0 ||
                   strcmp(command, "CONPMTR") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CONPMTR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CONPMTR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "CONPMTR not allowed except at top level");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CONPMTR requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* check if pmtrName already exists, and if it does
               ensure that it is a CONPMTR parameter */
            ipmtr = -1;
            for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                if (strcmp(MODL->pmtr[jpmtr].name, &(str1[1])) == 0) {

                    if (MODL->pmtr[jpmtr].type == OCSM_CONPMTR) {
                        ipmtr = jpmtr;
                        break;
                    } else if (MODL->pmtr[jpmtr].type == OCSM_LOCALVAR) {
                        status = OCSM_PMTR_IS_LOCALVAR;
                        signalError2(MODL, status, filename, linenum,
                                    "%s is an internal parameter", str1);
                        goto cleanup;
                    } else if (MODL->pmtr[jpmtr].type == OCSM_OUTPMTR) {
                        status = OCSM_PMTR_IS_OUTPMTR;
                        signalError2(MODL, status, filename, linenum,
                                    "%s is a OUTPMTR", str1);
                        goto cleanup;
                    } else if (MODL->pmtr[jpmtr].type == OCSM_DESPMTR ||
                               MODL->pmtr[jpmtr].type == OCSM_CFGPMTR   ) {
                        status = OCSM_PMTR_IS_DESPMTR;
                        signalError2(MODL, status, filename, linenum,
                                    "%s is a CFGPMTR or CFGPMTR", str1);
                        goto cleanup;
                    }
                }
            }

            /* find the number of entries in the values argument */
            nval = 1;
            for (i = 1; i < STRLEN(str2)-1; i++) {
                if (str2[i] == ';') nval++;
            }

            /* create the Parameter (if it does not already exist) */
            if (ipmtr < 0) {
                status = ocsmNewPmtr(MODL, str1, OCSM_CONPMTR, 1, nval);
                CHECK_STATUS2(ocsmNewPmtr);

                ipmtr = MODL->npmtr;
            }

            /* store the values */
            i = 0;
            for (ival = 1; ival <= nval; ival++) {
                j = 0;
                while (i <= STRLEN(str2)) {
                    if (str2[i] == ';' || i == STRLEN(str2)) {
                        str3[j] = '\0';

                        status = str2val(str3, NULL, &value, &dot, str);
                        CHECK_STATUS2(str2val);
                        if (STRLEN(str) > 0) {
                            status = OCSM_WRONG_PMTR_TYPE;
                            signalError2(MODL, status, filename, linenum,
                                         "expression must evaluate to a number");
                            goto cleanup;
                        } else {
                            SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                            if (fabs(MODL->pmtr[ipmtr].value[ival-1]+HUGEQ) < EPS06) {
                                status = ocsmSetValu(MODL, ipmtr, 1, ival, str3);
                                CHECK_STATUS2(ocsmSetValu);
                            } else if (fabs(MODL->pmtr[ipmtr].value[ival-1]-value) < EPS06) {
                                /* value already defined */
                            } else {
                                /* already defined with a different value */
                                status = OCSM_NAME_ALREADY_DEFINED;
                                signalError2(MODL, status, filename, linenum,
                                             "%s is already defined with a different value", str1);
                                goto cleanup;
                            }
                        }

                        i++;
                        break;
                    } else {
                        str3[j++] = str2[i++];
                    }
                }
            }

        /* input is: "csystem $csysName csysList */
        } else if (strcmp(command, "csystem") == 0 ||
                   strcmp(command, "CSYSTEM") == 0   ) {

            SPLINT_CHECK_FOR_NULL(MODL->brch);

            /* determine which Branch should be attributed, or if it is
               a global Attribute (ibrch=0) */
            ibrch = 0;
            for (jbrch = MODL->ibrch; jbrch > 0; jbrch--) {
                if (MODL->brch[jbrch].type != OCSM_SET      &&
                    MODL->brch[jbrch].type != OCSM_DIMENSION  ) {
                    ibrch = jbrch;
                    break;
                }
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CSYSTEM requires 2 arguments");
                goto cleanup;
            }

            /* set the Branch's csystem */
            if (MODL->brch[ibrch].type == OCSM_ASSERT    ||
                MODL->brch[ibrch].type == OCSM_CATBEG    ||
                MODL->brch[ibrch].type == OCSM_CATEND    ||
                MODL->brch[ibrch].type == OCSM_DIMENSION ||
                MODL->brch[ibrch].type == OCSM_ELSE      ||
                MODL->brch[ibrch].type == OCSM_ELSEIF    ||
                MODL->brch[ibrch].type == OCSM_END       ||
                MODL->brch[ibrch].type == OCSM_ENDIF     ||
                MODL->brch[ibrch].type == OCSM_IFTHEN    ||
                MODL->brch[ibrch].type == OCSM_INTERFACE ||
//              MODL->brch[ibrch].type == OCSM_LBOUND    ||
                MODL->brch[ibrch].type == OCSM_MACBEG    ||
                MODL->brch[ibrch].type == OCSM_MACEND    ||
                MODL->brch[ibrch].type == OCSM_MARK      ||
                MODL->brch[ibrch].type == OCSM_PATBEG    ||
                MODL->brch[ibrch].type == OCSM_PATBREAK  ||
                MODL->brch[ibrch].type == OCSM_PATEND    ||
                MODL->brch[ibrch].type == OCSM_PROJECT   ||
//              MODL->brch[ibrch].type == OCSM_SELECT    ||
                MODL->brch[ibrch].type == OCSM_SET       ||
                MODL->brch[ibrch].type == OCSM_EVALUATE  ||
                MODL->brch[ibrch].type == OCSM_GETATTR   ||
                MODL->brch[ibrch].type == OCSM_SKBEG     ||
                MODL->brch[ibrch].type == OCSM_SKCON     ||
                MODL->brch[ibrch].type == OCSM_SKVAR     ||
                MODL->brch[ibrch].type == OCSM_SOLBEG    ||
                MODL->brch[ibrch].type == OCSM_SOLEND    ||
                MODL->brch[ibrch].type == OCSM_STORE     ||
                MODL->brch[ibrch].type == OCSM_MESSAGE   ||
                MODL->brch[ibrch].type == OCSM_SPECIAL   ||
                MODL->brch[ibrch].type == OCSM_THROW     ||
//              MODL->brch[ibrdh].type == OCSM_UBOUND    ||
                MODL->brch[ibrch].type == OCSM_UDPARG      ) {
                status = OCSM_ILLEGAL_CSYSTEM;
                signalError2(MODL, status, filename, linenum,
                            "a \"%s\" Branch cannot get Csystem", ocsmGetText(MODL->brch[ibrch].type));
                goto cleanup;
            } else {
                status = ocsmSetCsys(MODL, ibrch, str1, str2);
                CHECK_STATUS2(ocsmSetCsys);
            }

        /* input is: "cylinder xbeg ybeg zbeg xend yend zend radius" */
        } else if (strcmp(command, "cylinder") == 0 ||
                   strcmp(command, "CYLINDER") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CYLINDER cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "CYLINDER cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7);
            if (narg != 7) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "CYLINDER requires 7 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_CYLINDER, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "despmtr $pmtrName values" */
        } else if (strcmp(command, "despmtr") == 0 ||
                   strcmp(command, "DESPMTR") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "DESPMTR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "DESPMTR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "DESPMTR not allowed except at top level");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "DESPMTR requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* make sure that values is a semicolon-separated list of numbers */
            icount = 0;
            while (icount < STRLEN(str2)) {
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] =str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                /* check for a valid number */
                if (sscanf(defn, "%lf", &value) == 0) {
                    status = OCSM_ILLEGAL_VALUE;
                    signalError2(MODL, status, filename, linenum,
                                "values must only contain numbers");
                    goto cleanup;
                }
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS2(parseName);

            /* if it does not exist, create it now */
            if (ipmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_DESPMTR, 1, 1);
                CHECK_STATUS2(ocsmNewPmtr);
                ipmtr = MODL->npmtr;
            } else {
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                /* if it exists and is UNKNOWN (because of a DIMENSION statemet),
                   convert to a DESPMTR */
                if (MODL->pmtr[ipmtr].type == OCSM_UNKNOWN) {
                    MODL->pmtr[ipmtr].type = OCSM_DESPMTR;

                /* make sure that Parameter is DESPMTR */
                } else if (MODL->pmtr[ipmtr].type == OCSM_LOCALVAR) {
                    status = OCSM_PMTR_IS_LOCALVAR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is an internal parameter", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {
                    status = OCSM_PMTR_IS_OUTPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is an OUTPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_CONPMTR) {
                    status = OCSM_PMTR_IS_CONPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is a CONPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_CFGPMTR) {
                    status = OCSM_PMTR_IS_DESPMTR;
                    signalError2(MODL, status, filename, linenum,     // OCSM_PMTR_IS_CFGPMTR is not defined
                                 "%s is a CFGPMTR", str1);
                    goto cleanup;
                }
            }

            /* store the values for the whole Parameter */
            if ((irow ==    0 && icol ==    0) ||
                (irow == -999 && icol == -999)   ) {
                icount = 0;
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        jcount = 0;

                        while (icount < STRLEN(str2)) {
                            if (str2[icount] == ';') {
                                icount++;
                                break;
                            } else {
                                defn[jcount  ] = str2[icount];
                                defn[jcount+1] = '\0';
                                icount++;
                                jcount++;
                            }
                        }

                        status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                        CHECK_STATUS2(ocsmGetValu);

                        if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                            SPRINT0(1, "WARNING:: value not overwritten");
                            (MODL->nwarn)++;
                        } else {
                            if (strcmp(defn, "") != 0) {
                                status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                                CHECK_STATUS2(ocsmSetValu);
                            }
                        }
                    }
                }

            /* store the values for all rows of the Parameter */
            } else if (irow == -999) {
                icount = 0;
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                    CHECK_STATUS2(ocsmGetValu);

                    if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                        SPRINT0(1, "WARNING:: value not overwritten");
                        (MODL->nwarn)++;
                    } else {
                        if (strcmp(defn, "") != 0) {
                            status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                            CHECK_STATUS2(ocsmSetValu);
                        }
                    }
                }

            /* store the values for all columns of the Parameter */
            } else if (icol == -999) {
                icount = 0;
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                    CHECK_STATUS2(ocsmGetValu);

                    if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                        SPRINT0(1, "WARNING:: value not overwritten");
                        (MODL->nwarn)++;
                    } else {
                        if (strcmp(defn, "") != 0) {
                            status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                            CHECK_STATUS2(ocsmSetValu);
                        }
                    }
                }

            /* store a single value into the Parameter */
            } else {
                if (irow <= 0) irow = 1;
                if (icol <= 0) icol = 1;

                icount = 0;
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] = str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                status = ocsmGetValu(MODL, ipmtr, irow, icol, &value, &dot);
                CHECK_STATUS2(ocsmGetValu);

                if (fabs(value+HUGEQ) > 1 && fabs(dot+HUGEQ) > 1) {
                    SPRINT0(1, "WARNING:: value not overwritten");
                    (MODL->nwarn)++;
                } else {
                    if (strcmp(defn, "") != 0) {
                        status = ocsmSetValu(MODL, ipmtr, irow, icol, defn);
                        CHECK_STATUS2(ocsmSetValu);
                    }
                }
            }

        /* input is: "dimension $pmtrName nrow ncol" */
        } else if (strcmp(command, "dimension") == 0 ||
                   strcmp(command, "DIMENSION") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "DIMENSION cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "DIMENSION cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "DIMENSION requires at least 3 arguments");
                goto cleanup;
            } else if (narg >= 4) {
                SPRINT0(1, "WARNING:: despmtr argument is obsolete and will be ignored");
                (MODL->nwarn)++;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[1] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /*  create a Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_DIMENSION, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* create an UNKNOWN Parameter if one does not already exist and str2 and str3
               both can be evaluated to a number

               notes:  1. the type will get changed from UNKNOWN to DESPMTR by a DESPMTR statement
                       2. the type will get changed from UNKNOWN to CFGPMTR by a CFGPMTR statement
                       3. the type will get changed from UNKNOWN to OUTPMTR by a OUTPMTR statement
                       4. all UNKNOWNs will be deleted at the end of ocsmLoad
            */
            ipmtr = -1;
            for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                if (strcmp(&str1[1], MODL->pmtr[jpmtr].name) == 0) {
                    ipmtr = jpmtr;
                    break;
                }
            }

            if (ipmtr < 0) {
                status = str2valNoSignal(str2, MODL, &value, &dot, str);
                if (status == SUCCESS && strlen(str) == 0) {
                    nrow = NINT(value);
                    if (nrow <= 0) {
                        signalError2(MODL, status, filename, linenum,
                                     "nrow is not positive");
                        goto cleanup;
                    }
                } else {
                    nrow = -1;
                }

                status = str2valNoSignal(str3, MODL, &value, &dot, str);
                if (status == SUCCESS && strlen(str) == 0) {
                    ncol = NINT(value);
                    if (ncol <= 0) {
                        signalError2(MODL, status, filename, linenum,
                                     "ncol is not positive");
                        goto cleanup;
                    }
                } else {
                    ncol = -1;
                }

                status = SUCCESS;

                if (nrow > 0 && ncol > 0) {
                    status = ocsmNewPmtr(MODL, &(str1[1]), OCSM_UNKNOWN, nrow, ncol);
                    CHECK_STATUS2(ocsmNewPmtr);
                }
            }

        /* input is: "dump $filename remove=0 toMark=0 withTess=0" */
        } else if (strcmp(command, "dump") == 0 ||
                   strcmp(command, "DUMP") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "DUMP cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "DUMP cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s %2047s\n",
                          &(str1[1]), str2, str3, str4);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "DUMP requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }
            if (narg < 4) {
                STRNCPY(str4, "0", MAX_EXPR_LEN);
            }

            /* convert filename if it starts with "$/" to relative pathname */
            if (strncmp(str1, "$$/", 3) == 0) {
                STRNCPY(pathname, filename, MAX_EXPR_LEN);
                i = STRLEN(pathname) - 1;
                while (pathname[i] != SLASH) {
                    pathname[i] = '\0';
                    i--;
                    if (i < 0) break;
                }
                STRNCPY(tmpfilename, &(str1[3]), MAX_EXPR_LEN);
                snprintf(str1, MAX_EXPR_LEN, "$%s%s", pathname, tmpfilename);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_DUMP, filename, linenum,
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "else" */
        } else if (strcmp(command, "else") == 0 ||
                   strcmp(command, "ELSE") == 0   ) {

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_ELSE, filename, linenum,
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "elseif val1 op1 val2 op2=and val3=0 op3=eq val4=0" */
        } else if (strcmp(command, "elseif") == 0 ||
                   strcmp(command, "ELSEIF") == 0   ) {

            /* extract arguments */
            strcpy(str2, "$");
            strcpy(str4, "$");
            strcpy(str6, "$");
            strcpy(str8, "$");
            narg = sscanf(nextline, "%*s %2047s %2046s %2047s %2046s %2047s %2046s %2047s\n",
                          str1, &(str2[1]), str3, &(str4[1]), str5, &(str6[1]), str7);
            if (narg < 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "ELSEIF requires at least 3 arguments");
                goto cleanup;
            }

            if (narg < 4) {
                strcpy(str4, "$and");
            }
            if (narg < 5) {
                strcpy(str5, "0");
            }
            if (narg < 6) {
                strcpy(str6, "$eq");
            }
            if (narg < 7) {
                strcpy(str7, "0");
            }

            if (strcmp(str2, "$lt") != 0 && strcmp(str2, "$LT") != 0 &&
                strcmp(str2, "$le") != 0 && strcmp(str2, "$LE") != 0 &&
                strcmp(str2, "$eq") != 0 && strcmp(str2, "$EQ") != 0 &&
                strcmp(str2, "$ge") != 0 && strcmp(str2, "$GE") != 0 &&
                strcmp(str2, "$gt") != 0 && strcmp(str2, "$GT") != 0 &&
                strcmp(str2, "$ne") != 0 && strcmp(str2, "$NE") != 0   ) {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "op1 must be LT, LE, EQ, GE, GT, or NE");
                goto cleanup;
            }
            if (strcmp(str4, "$or" ) != 0 && strcmp(str4, "$OR" ) != 0 &&
                strcmp(str4, "$and") != 0 && strcmp(str4, "$AND") != 0 &&
                strcmp(str4, "$xor") != 0 && strcmp(str4, "$XOR") != 0   ) {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "op2 must be OR, AND, or XOR");
                goto cleanup;
            }
            if (strcmp(str6, "$lt") != 0 && strcmp(str6, "$LT") != 0 &&
                strcmp(str6, "$le") != 0 && strcmp(str6, "$LE") != 0 &&
                strcmp(str6, "$eq") != 0 && strcmp(str6, "$EQ") != 0 &&
                strcmp(str6, "$ge") != 0 && strcmp(str6, "$GE") != 0 &&
                strcmp(str6, "$gt") != 0 && strcmp(str6, "$GT") != 0 &&
                strcmp(str6, "$ne") != 0 && strcmp(str6, "$NE") != 0   ) {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "op3 must be LT, LE, EQ, GE, GT, or NE");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_ELSEIF, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "end" */
        } else if (strcmp(command, "end") == 0 ||
                   strcmp(command, "END") == 0   ) {

            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "END cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "END cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* if in a .csm file, we are done */
            if (filetype == 0) {
                SPLINT_CHECK_FOR_NULL(fp_csm);

                fclose(fp_csm);
                fp_csm = NULL;

                break;

            /* if reading .cpc file and there are one or more open UDCs, create a new Branch */
            } else if (filetype == 1 && numudc > 0) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_END, filename, linenum,
                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                CHECK_STATUS2(ocsmNewBrch);

                numudc--;

            /* if reading .cpc file and there are no open UDCs, we are done */
            } else if (filetype == 1) {
                SPLINT_CHECK_FOR_NULL(fp_csm);

                fclose(fp_csm);
                fp_csm = NULL;

                break;

            /* if reading .udc file, add the END and we are done */
            } else if (filetype == 2) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_END, filename, linenum,
                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                CHECK_STATUS2(ocsmNewBrch);

                (MODL->level)--;

                SPLINT_CHECK_FOR_NULL(fp_csm);

                SPRINT0(1, "\n<<< Reverting to parent file (END detected)\n");

                fclose(fp_csm);
                fp_csm = NULL;

                break;

            /* if reading a .vfy file, then we are done */
            } else if (filetype == 3) {
                SPLINT_CHECK_FOR_NULL(fp_csm);

                fclose(fp_csm);
                fp_csm = NULL;

                break;

            /* otherwise, close file and revert to previous level */
            } else {
                SPLINT_CHECK_FOR_NULL(fp_csm);

                fclose(fp_csm);
                fp_csm = NULL;

                /* create a new Branch and decrement the level */
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_END, filename, linenum,
                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                CHECK_STATUS2(ocsmNewBrch);

                (MODL->level)--;

                SPRINT1(1, "\n<<< Reverting to parent file (END detected in filetype=%d)\n", filetype);
                break;
            }

        /* input is: "endif" */
        } else if (strcmp(command, "endif") == 0 ||
                   strcmp(command, "ENDIF") == 0   ) {

            /* find the matching ifthen */
            i = 1;
            for (ibrch = MODL->nbrch; ibrch > 0; ibrch--) {
                SPLINT_CHECK_FOR_NULL(MODL->brch);

                if        (MODL->brch[ibrch].type == OCSM_ENDIF ) {
                    i++;
                } else if (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                    i--;
                    if (i == 0) {
                        break;
                    }
                }
            }
            if (ibrch <= 0) {
                status = OCSM_IMPROPER_NESTING;
                signalError2(MODL, status, filename, linenum,
                            "ENDIF must follow IFTHEN");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_ENDIF, filename, linenum,
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            npatn--;

        /* input is: "evaluate $type ..." */
        } else if (strcmp(command, "evaluate") == 0 ||
                   strcmp(command, "EVALUATE") == 0   ) {

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s %2047s %2047s %2047s\n",
                          &(str1[1]), str2, str3, str4, str5, str6);

            /* $node ibody inode */
            if        (strcmp(str1, "$node") == 0 ||
                       strcmp(str1, "$NODE") == 0   ) {
                if (narg != 3) {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "EVALUATE NODE requires 3 arguments");
                    goto cleanup;
                }

            /* $edge ibody iedge t */
            } else if (strcmp(str1, "$edge") == 0 ||
                       strcmp(str1, "$EDGE") == 0   ) {
                if (narg != 4) {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "EVALUATE EDGE requires 4 arguments");
                    goto cleanup;
                }

            /* $edgerng ibody iedge */
            } else if (strcmp(str1, "$edgerng") == 0 ||
                       strcmp(str1, "$EDGERNG") == 0   ) {
                if (narg != 3) {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "EVALUATE EDGERNG requires 3 arguments");
                    goto cleanup;
                }

            /* $edgeinv ibody iedge x y z */
            } else if (strcmp(str1, "$edgeinv") == 0 ||
                       strcmp(str1, "$EDGEINV") == 0   ) {
                if (narg != 6) {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "EVALUATE EDGEINV requires 6 arguments");
                    goto cleanup;
                }

            /* $face ibody iface u v */
            } else if (strcmp(str1, "$face") == 0 ||
                       strcmp(str1, "$FACE") == 0   ) {
                if (narg != 5) {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "EVALUATE FACE requires 5 arguments");
                    goto cleanup;
                }

            /* $facerng ibody iface */
            } else if (strcmp(str1, "$facerng") == 0 ||
                       strcmp(str1, "$FACERNG") == 0   ) {
                if (narg != 3) {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "EVALUATE FACERNG requires 3 arguments");
                    goto cleanup;
                }

            /* $faceinv ibody iface x y z */
            } else if (strcmp(str1, "$faceinv") == 0 ||
                       strcmp(str1, "$FACEINV") == 0   ) {
                if (narg != 6) {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "EVALUATE FACEINV requires 6 arguments");
                    goto cleanup;
                }
            } else {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "type must be NODE, EDGE, EDGERNG, EDGEINV, FACE, FACERNG, or FACEINV");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_EVALUATE, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "extract entList" */
        } else if (strcmp(command, "extract") == 0 ||
                   strcmp(command, "EXTRACT") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "EXTRACT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "EXTRACT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "EXTRACT requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_EXTRACT, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "extrude dx dy dz" */
        } else if (strcmp(command, "extrude") == 0 ||
                   strcmp(command, "EXTRUDE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "EXTRUDE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "EXTRUDE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "EXTRUDE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_EXTRUDE, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "fillet radius edgeList=0 listStyle=0" */
        } else if (strcmp(command, "fillet") == 0 ||
                   strcmp(command, "FILLET") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "FILLET cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "FILLET cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if        (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "ASSERT requires at least 1 argument");
                goto cleanup;
            } else if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_FILLET, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "getattr $pmtrName attrID global=0" */
        } else if (strcmp(command, "getattr") == 0 ||
                   strcmp(command, "GETATTR") == 0   ) {

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "GETATTR requires at least 2 arguments");
                goto cleanup;
            }

            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[1] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_GETATTR, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "group nbody=0" */
        } else if (strcmp(command, "group") == 0 ||
                   strcmp(command, "GROUP") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "GROUP cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "GROUP cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_GROUP, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "hollow thick=0 entList=0 listStyle=0" */
        } else if (strcmp(command, "hollow") == 0 ||
                   strcmp(command, "HOLLOW") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "HOLLOW cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "HOLLOW cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if        (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
                STRNCPY(str2, "0", MAX_EXPR_LEN);
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_HOLLOW, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "ifthen val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0" */
        } else if (strcmp(command, "ifthen") == 0 ||
                   strcmp(command, "IFTHEN") == 0   ) {

            /* extract arguments */
            strcpy(str2, "$");
            strcpy(str4, "$");
            strcpy(str6, "$");
            strcpy(str8, "$");
            narg = sscanf(nextline, "%*s %2047s %2046s %2047s %2046s %2047s %2046s %2047s\n",
                          str1, &(str2[1]), str3, &(str4[1]), str5, &(str6[1]), str7);
            if (narg < 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "IFTHEN requires at least 3 arguments");
                goto cleanup;
            }

            if (narg < 4) {
                strcpy(str4, "$and");
            }
            if (narg < 5) {
                strcpy(str5, "0");
            }
            if (narg < 6) {
                strcpy(str6, "$eq");
            }
            if (narg < 7) {
                strcpy(str7, "0");
            }

            if (strcmp(str2, "$lt") != 0 && strcmp(str2, "$LT") != 0 &&
                strcmp(str2, "$le") != 0 && strcmp(str2, "$LE") != 0 &&
                strcmp(str2, "$eq") != 0 && strcmp(str2, "$EQ") != 0 &&
                strcmp(str2, "$ge") != 0 && strcmp(str2, "$GE") != 0 &&
                strcmp(str2, "$gt") != 0 && strcmp(str2, "$GT") != 0 &&
                strcmp(str2, "$ne") != 0 && strcmp(str2, "$NE") != 0   ) {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "op1 must be LT, LE, EQ, GE, GT, or NE");
                goto cleanup;
            }
            if (strcmp(str4, "$or" ) != 0 && strcmp(str4, "$OR" ) != 0 &&
                strcmp(str4, "$and") != 0 && strcmp(str4, "$AND") != 0 &&
                strcmp(str4, "$xor") != 0 && strcmp(str4, "$XOR") != 0   ) {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "op2 must be OR, AND, or XOR");
                goto cleanup;
            }
            if (strcmp(str6, "$lt") != 0 && strcmp(str6, "$LT") != 0 &&
                strcmp(str6, "$le") != 0 && strcmp(str6, "$LE") != 0 &&
                strcmp(str6, "$eq") != 0 && strcmp(str6, "$EQ") != 0 &&
                strcmp(str6, "$ge") != 0 && strcmp(str6, "$GE") != 0 &&
                strcmp(str6, "$gt") != 0 && strcmp(str6, "$GT") != 0 &&
                strcmp(str6, "$ne") != 0 && strcmp(str6, "$NE") != 0   ) {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "op3 must be LT, LE, EQ, GE, GT, or NE");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_IFTHEN, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "import $filename bodynumber=1" */
        } else if (strcmp(command, "import") == 0 ||
                   strcmp(command, "IMPORT") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "IMPORT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "IMPORT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if        (narg == 1) {
                STRNCPY(str2, "1", MAX_EXPR_LEN);
            } else if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "IMPORT requires at least 1 argument");
                goto cleanup;
            }

            /* convert filename if it starts with "$/" or "$$/" to relative pathname */
            if (strncmp(str1, "$$/", 3) == 0) {
                STRNCPY(pathname, filename, MAX_EXPR_LEN);
                i = STRLEN(pathname) - 1;
                while (pathname[i] != SLASH) {
                    pathname[i] = '\0';
                    i--;
                    if (i < 0) break;
                }
                STRNCPY(tmpfilename, &(str1[3]), MAX_EXPR_LEN);
                snprintf(str1, MAX_EXPR_LEN, "$%s%s", pathname, tmpfilename);
            } else if (strncmp(str1, "$$$/", 4) == 0) {
                STRNCPY(pathname, filename, MAX_EXPR_LEN);
                i = STRLEN(pathname) - 1;
                while (pathname[i] != SLASH) {
                    pathname[i] = '\0';
                    i--;
                    if (i < 0) break;
                }
                STRNCPY(tmpfilename, &(str1[4]), MAX_EXPR_LEN);
                snprintf(str1, MAX_EXPR_LEN, "$%s%s", pathname, tmpfilename);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_IMPORT, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "interface $argName $argType default=0" */
        } else if (strcmp(command, "interface") == 0 ||
                   strcmp(command, "INTERFACE") == 0   ) {
            if (filetype == 0 && MODL->level <= 0) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "INTERFACE not allowed in .csm file");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");  strcpy(str2, "$");
            narg = sscanf(nextline, "%*s %2046s %2046s %2047s\n",
                          &(str1[1]), &(str2[1]), str3);
            if        (narg == 2) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            } else if (narg != 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "INTERFACE requires at least 2 arguments");
                goto cleanup;
            }

            /* ensure that valid argType is given */
            if (strcmp(str2, "$dim") == 0 || strcmp(str2, "$DIM") == 0) {
                SPRINT0(1, "WARNING:: INTERFACE DIM is obsolete. use DIMENSION instead");
                (MODL->nwarn)++;
            } else if ((strcmp(str2, "$in")  != 0) && (strcmp(str2, "$IN" ) != 0) &&
                       (strcmp(str2, "$out") != 0) && (strcmp(str2, "$OUT") != 0) &&
                       (strcmp(str2, "$all") != 0) && (strcmp(str2, "$ALL") != 0)   ) {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "argType must be IN, OUT, DIM, or ALL");
                goto cleanup;
            }

            /* if an include-type UDC, reduce the scope back (note: it was
               increased by the UDPRIM statement) */
            if ((strcmp(str2, "$all") == 0) || (strcmp(str2, "$ALL") == 0)) {
                    MODL->scope[MODL->level] = MODL->scope[MODL->level-1];
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_INTERFACE, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "intersect $order=none index=1 maxtol=0" */
        } else if (strcmp(command, "intersect") == 0 ||
                   strcmp(command, "INTERSECT") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "INTERSECT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "INTERSECT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 1) {
                STRNCPY(str1, "$none", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "1",     MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_INTERSECT, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "join toler=0 toMark=0" */
        } else if (strcmp(command, "join") == 0 ||
                   strcmp(command, "JOIN") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "JOIN cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "JOIN cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if        (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            } else if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_JOIN, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "lbound $pmtrName expression" */
        } else if (strcmp(command, "lbound") == 0 ||
                   strcmp(command, "LBOUND") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "LBOUND cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "LBOUND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "LBOUND not allowed except at top level");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "LBOUND requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* make sure that bounds is a semicolon-separated list of numbers */
            icount = 0;
            while (icount < STRLEN(str2)) {
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] =str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                /* check for a valid number */
                if (sscanf(defn, "%lf", &value) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    signalError2(MODL, status, filename, linenum,
                                "expression must evaluate to a number");
                    goto cleanup;
                }
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS2(parseName);

            /* if it does not exist, signal error */
            if (ipmtr == 0) {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                             "\"%s\" does not exist", pmtrName);
                goto cleanup;
            } else {
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                /* make sure that Parameter is DESPMTR or CFGPMTR */
                if (MODL->pmtr[ipmtr].type == OCSM_LOCALVAR) {
                    status = OCSM_PMTR_IS_LOCALVAR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is an internal parameter", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {
                    status = OCSM_PMTR_IS_OUTPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is an OUTPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_CONPMTR) {
                    status = OCSM_PMTR_IS_CONPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is a CONPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_UNKNOWN) {
                    status = OCSM_ILLEGAL_PMTR_NAME;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is an unknown type", str1);
                    goto cleanup;
                }
            }

            /* store the bounds for the whole Parameter */
            if ((irow ==    0 && icol ==    0) ||
                (irow == -999 && icol == -999)   ) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        jcount = 0;

                        while (icount < STRLEN(str2)) {
                            if (str2[icount] == ';') {
                                icount++;
                                break;
                            } else {
                                defn[jcount  ] = str2[icount];
                                defn[jcount+1] = '\0';
                                icount++;
                                jcount++;
                            }
                        }

                        status = str2val(defn, MODL, &bound, &dot, str);
                        CHECK_STATUS2(str2val);
                        if (STRLEN(str) > 0) {
                            status = OCSM_WRONG_PMTR_TYPE;
                            signalError2(MODL, status, filename, linenum,
                                        "expression must evaluate to a number");
                            goto cleanup;
                        }

                        indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                        MODL->pmtr[ipmtr].lbnd[indx] = bound;
                    }
                }

            /* store the bounds for all rows of the Parameter */
            } else if (irow == -999) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = str2val(defn, MODL, &bound, &dot, str);
                    CHECK_STATUS2(str2val);
                    if (STRLEN(str) > 0) {
                        status = OCSM_WRONG_PMTR_TYPE;
                        signalError2(MODL, status, filename, linenum,
                                    "expression must evaluate to a number");
                        goto cleanup;
                    }

                    indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                    MODL->pmtr[ipmtr].lbnd[indx] = bound;
                }

            /* store the bounds for all columns of the Parameter */
            } else if (icol == -999) {
                icount = 0;
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = str2val(defn, MODL, &bound, &dot, str);
                    CHECK_STATUS2(str2val);
                    if (STRLEN(str) > 0) {
                        status = OCSM_WRONG_PMTR_TYPE;
                        signalError2(MODL, status, filename, linenum,
                                    "expression must evaluate to a number");
                        goto cleanup;
                    }

                    indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                    MODL->pmtr[ipmtr].lbnd[indx] = bound;
                }

            /* store a single bound into the Parameter */
            } else {
                if (irow <= 0) irow = 1;
                if (icol <= 0) icol = 1;

                icount = 0;
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] = str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                status = str2val(defn, MODL, &bound, &dot, str);
                CHECK_STATUS2(str2val);
                if (STRLEN(str) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    signalError2(MODL, status, filename, linenum,
                                "expression must evaluate to a number");
                    goto cleanup;
                }

                indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                MODL->pmtr[ipmtr].lbnd[indx] = bound;
            }

        /* input is: "linseg x y z" */
        } else if (strcmp(command, "linseg") == 0 ||
                   strcmp(command, "LINSEG") == 0   ) {
            if (nskpt == 0) {
                status = OCSM_SKETCH_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "LINSEG must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "LINSEG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "LINSEG requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_LINSEG, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "loft smooth" */
        } else if (strcmp(command, "loft") == 0 ||
                   strcmp(command, "LOFT") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "LOFT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "LOFT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "LOFT requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_LOFT, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "macbeg imacro" */
        } else if (strcmp(command, "macbeg") == 0 ||
                   strcmp(command, "MACBEG") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "MACBEG cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "MACBEG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "MACBEG requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_MACBEG, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "macend" */
        } else if (strcmp(command, "macend") == 0 ||
                   strcmp(command, "MACEND") == 0   ) {
            if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "MACEND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_MACEND, filename, linenum,
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "mark" */
        } else if (strcmp(command, "mark") == 0 ||
                   strcmp(command, "MARK") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "MARK cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "MARK cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_MARK, filename, linenum,
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "message $text $schar=_" */
        } else if (strcmp(command, "message") == 0 ||
                   strcmp(command, "MESSAGE") == 0   ) {

            /* extract argument */
            strcpy(str1, "$");
            strcpy(str2, "$");
            narg = sscanf(nextline, "%*s %2046s %2046s\n",
                          &(str1[1]), &(str2[1]));
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "MESSAGE requires at least 1 argument");
                goto cleanup;
            } else if (narg < 2) {
                strcpy(str2, "$_");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_MESSAGE, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);


        /* input is: "mirror nx ny nz dist=0" */
        } else if (strcmp(command, "mirror") == 0 ||
                   strcmp(command, "MIRROR") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "MIRROR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "MIRROR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg == 3) {
                STRNCPY(str4, "0", MAX_EXPR_LEN);
            } else if (narg != 4) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "MIRROR requires 4 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_MIRROR, filename, linenum,
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "name $branchName" */
        } else if (strcmp(command, "name") == 0 ||
                   strcmp(command, "NAME") == 0   ) {

            /* previous Branch will be named */
            ibrch = MODL->ibrch;
            if (ibrch < 1) {
                status = OCSM_ILLEGAL_BRCH_INDEX;
                signalError2(MODL, status, filename, linenum,
                            "NAME must follow a Branch");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "NAME requires 1 argument");
                goto cleanup;
            }

            /* set the Branch's name */
            status = ocsmSetName(MODL, ibrch, str1);
            CHECK_STATUS2(ocsmSetName);

        /* input is: "outpmtr $pmtrName" */
        } else if (strcmp(command, "outpmtr") == 0 ||
                   strcmp(command, "OUTPMTR") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "OUTPMTR cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "OUTPMTR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "OUTPMTR not allowed except at top level");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "OUTPMTR requires 1 argument");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS2(parseName);

            /* if it does not exist, create it now */
            if (ipmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_OUTPMTR, 1, 1);
                CHECK_STATUS2(ocsmNewPmtr);
                ipmtr = MODL->npmtr;
            } else {
                SPLINT_CHECK_FOR_NULL(MODL->pmtr);

                /* if it exists and is UNKNOWN (because of a DIMENSION statemet),
                   convert to a OUTPMTR */
                if (MODL->pmtr[ipmtr].type == OCSM_UNKNOWN) {
                    MODL->pmtr[ipmtr].type = OCSM_OUTPMTR;

                /* make sure that Parameter is OUTPMTR */
                } else if (MODL->pmtr[ipmtr].type == OCSM_LOCALVAR) {
                    status = OCSM_PMTR_IS_LOCALVAR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is an internal parameter", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR) {
                    status = OCSM_PMTR_IS_DESPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is a DESPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_CFGPMTR) {
                    status = OCSM_PMTR_IS_DESPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is a CFGPMTR", str1);
                    goto cleanup;
                } else if (MODL->pmtr[ipmtr].type == OCSM_CONPMTR) {
                    status = OCSM_PMTR_IS_CONPMTR;
                    signalError2(MODL, status, filename, linenum,
                                 "%s is a CONPMTR", str1);
                    goto cleanup;
                }
            }

        /* input is: "patbeg $pmtrName ncopy" */
        } else if (strcmp(command, "patbeg") == 0 ||
                   strcmp(command, "PATBEG") == 0   ) {
            if (npatn >= MAX_NESTING) {
                status = OCSM_NESTED_TOO_DEEPLY;
                signalError2(MODL, status, filename, linenum,
                            "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "PATBEG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else {
                npatn++;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "PATBEG requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[1] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_PATBEG, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "patbreak expr" */
        } else if (strcmp(command, "patbreak") == 0 ||
                   strcmp(command, "PATBREAK") == 0   ) {

            if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "PATBREAK cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* find the matching patbeg */
            i = 1;
            for (ibrch = MODL->nbrch; ibrch > 0; ibrch--) {
                SPLINT_CHECK_FOR_NULL(MODL->brch);

                if        (MODL->brch[ibrch].type == OCSM_PATEND) {
                    i++;
                } else if (MODL->brch[ibrch].type == OCSM_PATBEG) {
                    i--;
                    if (i == 0) {
                        break;
                    }
                }
            }
            if (ibrch <= 0) {
                status = OCSM_IMPROPER_NESTING;
                signalError2(MODL, status, filename, linenum,
                            "PATBREAK must follow a PATBEG");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "PATBREAK requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_PATBREAK, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "patend" */
        } else if (strcmp(command, "patend") == 0 ||
                   strcmp(command, "PATEND") == 0   ) {
            if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "PATEND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* find the matching patbeg */
            i = 1;
            for (ibrch = MODL->nbrch; ibrch > 0; ibrch--) {
                SPLINT_CHECK_FOR_NULL(MODL->brch);

                if        (MODL->brch[ibrch].type == OCSM_PATEND) {
                    i++;
                } else if (MODL->brch[ibrch].type == OCSM_PATBEG) {
                    i--;
                    if (i == 0) {
                        break;
                    }
                }
            }
            if (ibrch <= 0) {
                status = OCSM_IMPROPER_NESTING;
                signalError2(MODL, status, filename, linenum,
                            "PATEND must follow a PATBEG");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_PATEND, filename, linenum,
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            npatn--;

        /* input is: "point xloc yloc zloc" */
        } else if (strcmp(command, "point") == 0 ||
                   strcmp(command, "POINT") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "POINT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "POINT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "POINT requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_POINT, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "project x y z dx dy dz useEdges=0" */
        } else if (strcmp(command, "project") == 0 ||
                   strcmp(command, "PROJECT") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "PROJECT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "PROJECT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument and save*/
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7);
            if (narg < 6) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "PROJECT requires at least 6 arguments");
                goto cleanup;
            }
            if (narg < 7) {
                strcpy(str7, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_PROJECT, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "recall imacro" */
        } else if (strcmp(command, "recall") == 0 ||
                   strcmp(command, "RECALL") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "RECALL cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "RECALL cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract argument and save*/
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "RECALL requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_RECALL, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "reorder ishift iflip=0" */
        } else if (strcmp(command, "reorder") == 0 ||
                   strcmp(command, "REORDER") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "REORDER cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "REORDER cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg == 1) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            } else if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "REORDER requires at least 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_REORDER, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "restore $name index=0" */
        } else if (strcmp(command, "restore") == 0 ||
                   strcmp(command, "RESTORE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "RESTORE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "RESTORE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg == 1) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            } else if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "RESTORE requires at least 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_RESTORE, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "revolve xorig yorig zorig dxaxis dyaxis dzaxis angDeg" */
        } else if (strcmp(command, "revolve") == 0 ||
                   strcmp(command, "REVOLVE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "REVOLVE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "REVOLVE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7);
            if (narg != 7) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "REVOLVE requires 7 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_REVOLVE, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "rotatex angDeg yaxis=0 zaxis=0" */
        } else if (strcmp(command, "rotatex") == 0 ||
                   strcmp(command, "ROTATEX") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEX cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEX cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEX requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                strcpy(str2, "0");
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_ROTATEX, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "rotatey angDeg zaxis-0 xaxis=0" */
        } else if (strcmp(command, "rotatey") == 0 ||
                   strcmp(command, "ROTATEY") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEY cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEY cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEY requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                strcpy(str2, "0");
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_ROTATEY, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "rotatez angDeg xaxis=0 yaxis=0" */
        } else if (strcmp(command, "rotatez") == 0 ||
                   strcmp(command, "ROTATEZ") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEZ cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEZ cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "ROTATEZ requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                strcpy(str2, "0");
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_ROTATEZ, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "rule reorder=0 periodic=0 " */
        } else if (strcmp(command, "rule") == 0 ||
                   strcmp(command, "RULE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "RULE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "RULE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_RULE, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "scale fact xcent=0 ycent=0 zcent=0" */
        } else if (strcmp(command, "scale") == 0 ||
                   strcmp(command, "SCALE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SCALE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SCALE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SCALE requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                strcpy(str2, "0");
            }
            if (narg < 3) {
                strcpy(str3, "0");
            }
            if (narg < 4) {
                strcpy(str4, "0");
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SCALE, filename, linenum,
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "select $type arg1 ..." */
        } else if (strcmp(command, "select") == 0 ||
                   strcmp(command, "SELECT") == 0   ) {

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          &(str1[1]), str2, str3, str4, str5, str6, str7, str8);

            /* create the new Branch */
            if        (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SELECT requires at least 1 argument");
                goto cleanup;
            } else if (strcmp(str1, "$body") == 0 || strcmp(str1, "$BODY") == 0) {
                /* body */
                if        (narg == 1) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* body attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* body attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* body attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* body ibody */
                } else if (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "SELECT BODY requires 1, 2, 3, 5, or 7 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$face") == 0 || strcmp(str1, "$FACE") == 0) {
                /* face */
                if (narg == 1) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* face attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* face attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* face attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* face iface  */
                } else if (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* face ibody1 iford1 (0 for any) */
                } else if (narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
                /* face ibody1 iford1 iseq=1 (0 for any) */
                } else if (narg == 3 || narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* face xmin xmax ymin ymax zmin zmax */
                } else if (narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7, NULL, NULL);

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "SELECT FACE requires 1, 2, 3, 4, 5, or 7 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$edge") == 0 || strcmp(str1, "$EDGE") == 0) {
                /* edge */
                if (narg == 1) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* edge attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* edge attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* edge attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* edge iedge */
                } else if (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* edge ibody1 iford1 ibody2 iford2 (0 for any) */
                } else if (narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);
                /* edge ibody1 iford1 ibody2 iford2 iseq=1 (0 for any) */
                } else if (narg == 5 || narg == 6) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);
                /* edge x y z */
                } else if (narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* edge xmin xmax ymin ymax zmin zmax */
                } else if (narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7, NULL, NULL);

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "SELECT EDGE requires 1, 2, 3, 4, 5, 6, or 7 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$loop") == 0 || strcmp(str1, "$LOOP") == 0) {
                /* loop iface iloop */
                if (narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, NULL, NULL ,NULL, NULL, NULL, NULL);
                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "SELECT LOOP requires 2 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$node") == 0 || strcmp(str1, "$NODE") == 0) {
                /* node */
                if (narg == 1) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* node attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* node attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* node attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* node inode */
                } else if (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                /* node x y z */
                } else if (narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* node xmin xmax ymin ymax zmin zmax */
                } else if (narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7, NULL, NULL);

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "SELECT NODE requires 1, 2, 3, 4, 5, or 7 arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$add") == 0 || strcmp(str1, "$ADD") == 0) {
                /* add iface  -or-  add iedge  -or-  add inode */
                if        (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

                /* add attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* add attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* add attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
                /* add ibody1 iford1 */
                } else if (narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);

                /* add ibody1 iford1 iseq=1 */
                } else if (narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* add ibody1 iford1 ibody2 iford2 */
                } else if (narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);

                /* add ibody1 iford1 ibody2 iford2 iseq=1 */
                } else if (narg == 6) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                                "SELECT ADD has wrong number of arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$sub") == 0 || strcmp(str1, "$SUB") == 0) {
                /* sub ient */
                if        (narg == 2) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

                /* sub attrName1 attrValue1 */
                } else if (str2[0] == '$' && narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, "$*", "$*", "$*", "$*", NULL, NULL);
                /* sub attrName1 attrValue1 attrName2 attrValue2 */
                } else if (str2[0] == '$' && narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, "$*", "$*", NULL, NULL);
                /* sub attrName1 attrValue1 attrName2 attrValue2 attrName3 attrValue3 */
                } else if (str2[0] == '$' && narg == 7) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, str7,  NULL, NULL);
                /* sub ibody1 iford1 */
                } else if (narg == 3) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);

                /* sub ibody1 iford1 iseq=1 */
                } else if (narg == 4) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);

                /* sub ibody1 iford1 ibody2 iford2 */
                } else if (narg == 5) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);

                /* sub ibody1 iford1 ibody2 iford2 iseq=1 */
                } else if (narg == 6) {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, str3, str4, str5, str6, NULL, NULL, NULL);

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                            "SELECT SUB has wrong number of arguments");
                    goto cleanup;
                }
            } else if (strcmp(str1, "$sort") == 0 || strcmp(str1, "$SORT") == 0) {
                /* sort $key */
                if (narg == 2 && str2[0] == '$') {
                    status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SELECT, filename, linenum,
                                         str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    signalError2(MODL, status, filename, linenum,
                            "SELECT SORT has wrong number of arguments");
                    goto cleanup;
                }
            } else {
                status = OCSM_ILLEGAL_TYPE;
                signalError2(MODL, status, filename, linenum,
                            "type must be BODY, FACE, EDGE, NODE, ADD, SUB, or SORT");
                goto cleanup;
            }
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "set $pmtrName exprs" */
        } else if (strcmp(command, "set") == 0 ||
                   strcmp(command, "SET") == 0   ) {
            if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SET cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SET requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[1] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SET, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "skbeg x y z relative=0" */
        } else if (strcmp(command, "skbeg") == 0 ||
                   strcmp(command, "SKBEG") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SKBEG cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SKBEG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg < 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SKBEG requires at least 3 arguments");
                goto cleanup;
            }
            if (narg < 4) {
                STRNCPY(str4, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SKBEG, filename, linenum,
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "skcon $type index1 index2=-1 $value=0" */
        } else if (strcmp(command, "skcon") == 0 ||
                   strcmp(command, "SKCON") == 0   ) {
            if (nskpt <= 0) {
                status = OCSM_SKETCH_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SKCON must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SKCON cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* make sure that this follows a skvar or skcon statement */
            SPLINT_CHECK_FOR_NULL(MODL->brch);

            if (MODL->brch[MODL->ibrch].type != OCSM_SKVAR &&
                MODL->brch[MODL->ibrch].type != OCSM_SKCON   ) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "only SKVAR or SKCON can preceed SKCON statement");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            strcpy(str4, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s %2046s\n",
                          &(str1[1]), str2, str3, &(str4[1]));
            if (narg < 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SKCON requires 2 arguments");
                goto cleanup;
            }
            if (narg < 3) {
                STRNCPY(str3, "-1", MAX_EXPR_LEN);
            }
            if (narg < 4) {
                STRNCPY(str4, "$0", MAX_EXPR_LEN);
            }

            if        (strcmp(str1, "$X") == 0) {
            } else if (strcmp(str1, "$Y") == 0) {
            } else if (strcmp(str1, "$P") == 0) {
            } else if (strcmp(str1, "$T") == 0) {
            } else if (strcmp(str1, "$A") == 0) {
            } else if (strcmp(str1, "$W") == 0) {
            } else if (strcmp(str1, "$D") == 0) {
            } else if (strcmp(str1, "$H") == 0) {
            } else if (strcmp(str1, "$V") == 0) {
            } else if (strcmp(str1, "$I") == 0) {
            } else if (strcmp(str1, "$Z") == 0) {
            } else if (strcmp(str1, "$L") == 0) {
            } else if (strcmp(str1, "$R") == 0) {
            } else if (strcmp(str1, "$S") == 0) {
            } else {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "type must be X, Y, P, T, A, W, D, H, V, I, Z, L, R, or S");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SKCON, filename, linenum,
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "skend wireonly=0" */
        } else if (strcmp(command, "skend") == 0 ||
                   strcmp(command, "SKEND") == 0   ) {
            if (nskpt < 1) {
                status = OCSM_COLINEAR_SKETCH_POINTS;
                signalError2(MODL, status, filename, linenum,
                            "all Sketch points are colinear");
                goto cleanup;
            } else if (nskpt > MAX_SKETCH_SIZE) {
                status = OCSM_TOO_MANY_SKETCH_POINTS;
                signalError2(MODL, status, filename, linenum,
                            "more than %d sketch points", MAX_SKETCH_SIZE);
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SKEND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg <= 0) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SKEND, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* reset the number of Sketch points */
            nskpt = 0;

        /* input is: "skvar $type valList" */
        } else if (strcmp(command, "skvar") == 0 ||
                   strcmp(command, "SKVAR") == 0   ) {
            if (nskpt <= 0) {
                status = OCSM_SKETCH_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SKBAR must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SKVAR cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* make sure that this follows a skbeg statement */
            SPLINT_CHECK_FOR_NULL(MODL->brch);

            if (MODL->brch[MODL->ibrch].type != OCSM_SKBEG) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "only SKBEG can preceed SKVAR statement");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s\n",
                          &(str1[1]), str2);
            if (narg < 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SKVAR requires 2 arguments");
                goto cleanup;
            }

            if        (strcmp(str1, "$xy") == 0 || strcmp(str1, "$XY") == 0) {
                STRNCPY(str1, "$xy", MAX_EXPR_LEN);
            } else if (strcmp(str1, "$yz") == 0 || strcmp(str1, "$YZ") == 0) {
                STRNCPY(str1, "$yz", MAX_EXPR_LEN);
            } else if (strcmp(str1, "$zx") == 0 || strcmp(str1, "$ZX") == 0) {
                STRNCPY(str1, "$zx", MAX_EXPR_LEN);
            } else {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                            "PLANE must be XY, YZ, or ZX");
                goto cleanup;
            }

            /* make sure that str2 contains the correct number of semicolons */
            count = 0;
            for (i = 0; i < STRLEN(str2); i++) {
                if (str2[i] == ';') {
                    count++;
                }
            }

            if (count == 0 || count%3 != 0) {
                status = OCSM_ILLEGAL_VALUE;
                signalError2(MODL, status, filename, linenum,
                             "valList has %d semi-colons, but must contain triplets", count);
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SKVAR, filename, linenum,
                                 str1, str2, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "solbeg $varList" */
        } else if (strcmp(command, "solbeg") == 0 ||
                   strcmp(command, "SOLBEG") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SOLBEG cannot be in SKBEG/SKEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s\n",
                          &(str1[1]));
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SOLBEG requires 1 argument");
                goto cleanup;
            }

            /* remember that we are in a solver block */
            insolver = 1;

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SOLBEG, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "solcon $expr" */
        } else if (strcmp(command, "solcon") == 0 ||
                   strcmp(command, "SOLCON") == 0   ) {
            if (insolver != 1) {
                status = OCSM_SOLVER_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SOLCON must be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s\n",
                          &(str1[1]));
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SOLCON requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SOLCON, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "solend" */
        } else if (strcmp(command, "solend") == 0 ||
                   strcmp(command, "SOLEND") == 0   ) {
            if (insolver != 1) {
                status = OCSM_SOLVER_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SOLEND must be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* no arguments */

            /* close the solver */
            insolver = 0;

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SOLEND, filename, linenum,
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "special arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9" */
        } else if (strcmp(command, "special") == 0 ||
                   strcmp(command, "SPECIAL") == 0   ) {

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7, str8, str9);
            if (narg != 9) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SPECIAL requires at 9 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SPECIAL, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, str7, str8, str9);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "sphere xcent ycent zcent radius" */
        } else if (strcmp(command, "sphere") == 0 ||
                   strcmp(command, "SPHERE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SPHERE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SPHERE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4);
            if (narg != 4) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SPHERE requires 4 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SPHERE, filename, linenum,
                                 str1, str2, str3, str4, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "spline x y z" */
        } else if (strcmp(command, "spline") == 0 ||
                   strcmp(command, "SPLINE") == 0   ) {
            if (nskpt == 0) {
                status = OCSM_SKETCH_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SPLINE must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SPLINE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SPLINE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SPLINE, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "sslope dx dy dz" */
        } else if (strcmp(command, "sslope") == 0 ||
                   strcmp(command, "SSLOPE") == 0   ) {
            if (nskpt == 0) {
                status = OCSM_SKETCH_IS_NOT_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SSLOPE must be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SSLOPE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "SSLOPE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SSLOPE, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

            /* increment the number of Sketch points */
            nskpt++;

        /* input is: "store $name index=0 keep=0" */
        } else if (strcmp(command, "store") == 0 ||
                   strcmp(command, "STORE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "STORE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "STORE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "STORE requires at least 1 argument");
                goto cleanup;
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_STORE, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "subtract $order=none index=1 maxtol=0" */
        } else if (strcmp(command, "subtract") == 0 ||
                   strcmp(command, "SUBTRACT") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SUBTRACT cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SUBTRACT cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");
            narg = sscanf(nextline, "%*s %2046s %2047s %2047s\n",
                          &(str1[1]), str2, str3);
            if (narg < 1) {
                STRNCPY(str1, "$none", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "1",     MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0",     MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SUBTRACT, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "sweep" */
        } else if (strcmp(command, "sweep") == 0 ||
                   strcmp(command, "SWEEP") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SWEEP cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "SWEEP cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* no arguments */

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_SWEEP, filename, linenum,
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "throw sigCode" */
        } else if (strcmp(command, "throw") == 0 ||
                   strcmp(command, "THROW") == 0   ) {

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s\n",
                          str1);
            if (narg != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "THROW requires 1 argument");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_THROW, filename, linenum,
                                 str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "torus xcent ycent zcent dxaxis dyaxis dzaxis majorRad minorRad" */
        } else if (strcmp(command, "torus") == 0 ||
                   strcmp(command, "TORUS") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "TORUS cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "TORUS cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s %2047s %2047s %2047s %2047s %2047s\n",
                          str1, str2, str3, str4, str5, str6, str7, str8);
            if (narg != 8) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "TORUS requires 8 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_TORUS, filename, linenum,
                                 str1, str2, str3, str4, str5, str6, str7, str8, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "translate dx dy dz" */
        } else if (strcmp(command, "translate") == 0 ||
                   strcmp(command, "TRANSLATE") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "TRANSLATE cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "TRANSLATE cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg != 3) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "TRANSLATE requires 3 arguments");
                goto cleanup;
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_TRANSLATE, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "ubound $pmtrName expression" */
        } else if (strcmp(command, "ubound") == 0 ||
                   strcmp(command, "UBOUND") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "UBOUND cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "UBOUND cannot be in SOLBEG/SOLEND");
                goto cleanup;
            } else if (MODL->scope[MODL->level] > 0) {
                status = OCSM_ILLEGAL_STATEMENT;
                signalError2(MODL, status, filename, linenum,
                            "UBOUND not allowed except at top level");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s\n",
                          str1, str2);
            if (narg != 2) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "UBOUND requires 2 arguments");
                goto cleanup;
            }

            /* do not allow pmtrName to start with '@' */
            if (str1[0] == '@') {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "pmtrName cannot start with an at-sign");
                goto cleanup;
            }

            /* make sure that values is a semicolon-separated list of numbers */
            icount = 0;
            while (icount < STRLEN(str2)) {
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] =str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                /* check for a valid number */
                if (sscanf(defn, "%lf", &value) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    signalError2(MODL, status, filename, linenum,
                                "expression must evaluate to a number");
                    goto cleanup;
                }
            }

            /* break str1 into pmtrName[irow,icol] */
            status = parseName(MODL, str1, pmtrName, &ipmtr, &irow, &icol);
            CHECK_STATUS2(parseName);

            SPLINT_CHECK_FOR_NULL(MODL->pmtr);

            /* if it does not exist, signal error */
            if (ipmtr == 0) {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                             "\"%s\" does not exist", pmtrName);
                goto cleanup;

            /* make sure that Parameter is DESPMTR or CFGPMTR */
            } else if (MODL->pmtr[ipmtr].type == OCSM_LOCALVAR) {
                status = OCSM_PMTR_IS_LOCALVAR;
                signalError2(MODL, status, filename, linenum,
                            "%s is an internal parameter", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {
                status = OCSM_PMTR_IS_OUTPMTR;
                signalError2(MODL, status, filename, linenum,
                            "%s is an OUTPMTR", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_CONPMTR) {
                status = OCSM_PMTR_IS_CONPMTR;
                signalError2(MODL, status, filename, linenum,
                            "%s is a CONPMTR", str1);
                goto cleanup;
            } else if (MODL->pmtr[ipmtr].type == OCSM_UNKNOWN) {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError2(MODL, status, filename, linenum,
                            "%s is an unknown type", str1);
                goto cleanup;
            }

            /* store the bounds for the whole Parameter */
            if ((irow ==    0 && icol ==    0) ||
                (irow == -999 && icol == -999)   ) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        jcount = 0;

                        while (icount < STRLEN(str2)) {
                            if (str2[icount] == ';') {
                                icount++;
                                break;
                            } else {
                                defn[jcount  ] = str2[icount];
                                defn[jcount+1] = '\0';
                                icount++;
                                jcount++;
                            }
                        }

                        status = str2val(defn, MODL, &bound, &dot, str);
                        CHECK_STATUS2(str2val);
                        if (STRLEN(str) > 0) {
                            status = OCSM_WRONG_PMTR_TYPE;
                            signalError2(MODL, status, filename, linenum,
                                        "expression must evaluate to a number");
                            goto cleanup;
                        }

                        indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                        MODL->pmtr[ipmtr].ubnd[indx] = bound;
                    }
                }

            /* store the bounds for all rows of the Parameter */
            } else if (irow == -999) {
                icount = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = str2val(defn, MODL, &bound, &dot, str);
                    CHECK_STATUS2(str2val);
                    if (STRLEN(str) > 0) {
                        status = OCSM_WRONG_PMTR_TYPE;
                        signalError2(MODL, status, filename, linenum,
                                    "expression must evaluate to a number");
                        goto cleanup;
                    }

                    indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                    MODL->pmtr[ipmtr].ubnd[indx] = bound;
                }

            /* store the bounds for all columns of the Parameter */
            } else if (icol == -999) {
                icount = 0;
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    jcount = 0;

                    while (icount < STRLEN(str2)) {
                        if (str2[icount] == ';') {
                            icount++;
                            break;
                        } else {
                            defn[jcount  ] = str2[icount];
                            defn[jcount+1] = '\0';
                            icount++;
                            jcount++;
                        }
                    }

                    status = str2val(defn, MODL, &bound, &dot, str);
                    CHECK_STATUS2(str2val);
                    if (STRLEN(str) > 0) {
                        status = OCSM_WRONG_PMTR_TYPE;
                        signalError2(MODL, status, filename, linenum,
                                    "expression must evaluate to a number");
                        goto cleanup;
                    }

                    indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                    MODL->pmtr[ipmtr].ubnd[indx] = bound;
                }

            /* store a single bound into the Parameter */
            } else {
                if (irow <= 0) irow = 1;
                if (icol <= 0) icol = 1;

                icount = 0;
                jcount = 0;

                while (icount < STRLEN(str2)) {
                    if (str2[icount] == ';') {
                        icount++;
                        break;
                    } else {
                        defn[jcount  ] = str2[icount];
                        defn[jcount+1] = '\0';
                        icount++;
                        jcount++;
                    }
                }

                status = str2val(defn, MODL, &bound, &dot, str);
                CHECK_STATUS2(str2val);
                if (STRLEN(str) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    signalError2(MODL, status, filename, linenum,
                                "expression must evaluate to a number");
                    goto cleanup;
                }

                indx = icol-1 + (irow-1)*MODL->pmtr[ipmtr].ncol;
                MODL->pmtr[ipmtr].ubnd[indx] = bound;
            }

        /* input is: "udparg $primtype $argName1 argValue1 $argName2 argValue2 $argName3 argValue3 $argName4 argValue4" */
        } else if (strcmp(command, "udparg") == 0 ||
                   strcmp(command, "UDPARG") == 0   ) {

            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "UDPARG cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "UDPARG cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");  strcpy(str2, "$");  strcpy(str4, "$");  strcpy(str6, "$");  strcpy(str8, "$");
            narg = sscanf(nextline, "%*s %2046s %2046s %2047s %2046s %2047s %2046s %2047s %2046s %2047s\n",
                          &(str1[1]), &(str2[1]), str3, &(str4[1]), str5,
                                      &(str6[1]), str7, &(str8[1]), str9);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "UDPARG requires at least 1 argument");
                goto cleanup;
            } else if (narg%2 != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "UDPARG  requires 1, 3, 5, 7, or 9 arguments");
                goto cleanup;
            }

            if (narg < 3) str3[0] = '\0';
            if (narg < 5) str5[0] = '\0';
            if (narg < 7) str7[0] = '\0';
            if (narg < 9) str9[0] = '\0';

            /* get the arguments associated with the UDP */
            if ((str1[1] >= 'a' && str1[1] <= 'z') || (str1[1] >= 'A' && str1[1] <= 'Z')) {
                status = udp_initialize(&str1[1], &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);

                /* if we got an error, then we will not process any filename-like arguments */
                if (status != EGADS_SUCCESS) {

                /* adjust file spec or extract "inline" file */
                } else {
                    SPLINT_CHECK_FOR_NULL(fp_csm);

                    ifound = 0;
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(&str2[1], udp_names[i]) == 0 && udp_types[i] == ATTRFILE) {
                            status = setupUdprimFile(MODL, 1, fp_csm, filename, &linenum, str3);
                            CHECK_STATUS2(setupUdprimFile);

                            ifound = 1;
                            break;
                        }
                    }
                    if (ifound == 0) {
                        status = setupUdprimFile(MODL, 0, fp_csm, filename, &linenum, str3);
                        CHECK_STATUS2(setupUdprimFile);
                    }

                    ifound = 0;
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(&str4[1], udp_names[i]) == 0 && udp_types[i] == ATTRFILE) {
                            status = setupUdprimFile(MODL, 1, fp_csm, filename, &linenum, str5);
                            CHECK_STATUS2(setupUdprimFile);

                            ifound = 1;
                        break;
                        }
                    }
                    if (ifound == 0) {
                        status = setupUdprimFile(MODL, 0, fp_csm, filename, &linenum, str5);
                        CHECK_STATUS2(setupUdprimFile);
                    }

                    ifound = 0;
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(&str6[1], udp_names[i]) == 0 && udp_types[i] == ATTRFILE) {
                            status = setupUdprimFile(MODL, 1, fp_csm, filename, &linenum, str7);
                            CHECK_STATUS2(setupUdprimFile);

                            ifound = 1;
                            break;
                        }
                    }
                    if (ifound == 0) {
                        status = setupUdprimFile(MODL, 0, fp_csm, filename, &linenum, str7);
                        CHECK_STATUS2(setupUdprimFile);
                    }

                    ifound = 0;
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(&str8[1], udp_names[i]) == 0 && udp_types[i] == ATTRFILE) {
                            status = setupUdprimFile(MODL, 1, fp_csm, filename, &linenum, str9);
                            CHECK_STATUS2(setupUdprimFile);

                            ifound = 1;
                            break;
                        }
                    }
                    if (ifound == 0) {
                        status = setupUdprimFile(MODL, 0, fp_csm, filename, &linenum, str9);
                        CHECK_STATUS2(setupUdprimFile);
                    }
                }
            }

            /* create the new Branch */
            if        (narg < 3) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPARG, filename, linenum,
                                     str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            } else if (narg < 5) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPARG, filename, linenum,
                                     str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            } else if (narg < 7) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPARG, filename, linenum,
                                     str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);
            } else if (narg < 9) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPARG, filename, linenum,
                                     str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            } else {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPARG, filename, linenum,
                                     str1, str2, str3, str4, str5, str6, str7, str8, str9);
            }
            CHECK_STATUS2(ocsmNewBrch);

        /* input is: "udprim $primtype $argName1 argValue1 $argName2 argValue2 $argName3 argValue3 $argName4 argValue4" */
        } else if (strcmp(command, "udprim") == 0 ||
                   strcmp(command, "UDPRIM") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "UDPRIM cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "UDPRIM cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            strcpy(str1, "$");  strcpy(str2, "$");  strcpy(str4, "$");  strcpy(str6, "$");  strcpy(str8, "$");
            narg = sscanf(nextline, "%*s %2046s %2046s %2047s %2046s %2047s %2046s %2047s %2046s %2047s\n",
                          &(str1[1]), &(str2[1]), str3, &(str4[1]), str5,
                                      &(str6[1]), str7, &(str8[1]), str9);
            if (narg < 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "UDPRIM requires at least 1 argument");
                goto cleanup;
            } else if (narg%2 != 1) {
                status = OCSM_NOT_ENOUGH_ARGS;
                signalError2(MODL, status, filename, linenum,
                            "UDPRIM requires 1, 3, 5, 7, or 9 arguments");
                goto cleanup;
            }

            if (narg < 3) str3[0] = '\0';
            if (narg < 5) str5[0] = '\0';
            if (narg < 7) str7[0] = '\0';
            if (narg < 9) str9[0] = '\0';

            /* get the arguments associated with the UDP */
            if ((str1[1] >= 'a' && str1[1] <= 'z') || (str1[1] >= 'A' && str1[1] <= 'Z')) {
                status = udp_initialize(&str1[1], &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);

                /* if we got an error, then we will not process any filename-like arguments */
                if (status != EGADS_SUCCESS) {

                /* adjust file spec or extract "inline" file */
                } else {
                    SPLINT_CHECK_FOR_NULL(fp_csm);

                    ifound = 0;
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(&str2[1], udp_names[i]) == 0 && udp_types[i] == ATTRFILE) {
                            status = setupUdprimFile(MODL, 1, fp_csm, filename, &linenum, str3);
                            CHECK_STATUS2(setupUdprimFile);

                            ifound = 1;
                            break;
                        }
                    }
                    if (ifound == 0) {
                        status = setupUdprimFile(MODL, 0, fp_csm, filename, &linenum, str3);
                        CHECK_STATUS2(setupUdprimFile);
                    }

                    ifound = 0;
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(&str4[1], udp_names[i]) == 0 && udp_types[i] == ATTRFILE) {
                            status = setupUdprimFile(MODL, 1, fp_csm, filename, &linenum, str5);
                            CHECK_STATUS2(setupUdprimFile);

                            ifound = 1;
                            break;
                        }
                    }
                    if (ifound == 0) {
                        status = setupUdprimFile(MODL, 0, fp_csm, filename, &linenum, str5);
                        CHECK_STATUS2(setupUdprimFile);
                    }

                    ifound = 0;
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(&str6[1], udp_names[i]) == 0 && udp_types[i] == ATTRFILE) {
                            status = setupUdprimFile(MODL, 1, fp_csm, filename, &linenum, str7);
                            CHECK_STATUS2(setupUdprimFile);

                            ifound = 1;
                            break;
                        }
                    }
                    if (ifound == 0) {
                        status = setupUdprimFile(MODL, 0, fp_csm, filename, &linenum, str7);
                        CHECK_STATUS2(setupUdprimFile);
                    }

                    ifound = 0;
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(&str8[1], udp_names[i]) == 0 && udp_types[i] == ATTRFILE) {
                            status = setupUdprimFile(MODL, 1, fp_csm, filename, &linenum, str9);
                            CHECK_STATUS2(setupUdprimFile);

                            ifound = 1;
                            break;
                        }
                    }
                    if (ifound == 0) {
                        status = setupUdprimFile(MODL, 0, fp_csm, filename, &linenum, str9);
                        CHECK_STATUS2(setupUdprimFile);
                    }
                }
            }

            /* create the new Branch */
            if        (narg < 3) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPRIM, filename, linenum,
                                     str1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            } else if (narg < 5) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPRIM, filename, linenum,
                                     str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            } else if (narg < 7) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPRIM, filename, linenum,
                                     str1, str2, str3, str4, str5, NULL, NULL, NULL, NULL);
            } else if (narg < 9) {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPRIM, filename, linenum,
                                     str1, str2, str3, str4, str5, str6, str7, NULL, NULL);
            } else {
                status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UDPRIM, filename, linenum,
                                     str1, str2, str3, str4, str5, str6, str7, str8, str9);
            }
            CHECK_STATUS2(ocsmNewBrch);

            /* if in a .cpc file, increment the number of UDCs if str1 starts with "$/" or "$$" */
            if (filetype == 1) {
                if (str1[1] == '$' || str1[1] == '$') {
                    numudc++;
                }
            }

        /* input is: "union toMark=0 trimList=0 maxtol=0" */
        } else if (strcmp(command, "union") == 0 ||
                   strcmp(command, "UNION") == 0   ) {
            if (nskpt > 0) {
                status = OCSM_SKETCH_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "UNION cannot be in SKBEG/SKEND");
                goto cleanup;
            } else if (insolver != 0) {
                status = OCSM_SOLVER_IS_OPEN;
                signalError2(MODL, status, filename, linenum,
                            "UNION cannot be in SOLBEG/SOLEND");
                goto cleanup;
            }

            /* extract arguments */
            narg = sscanf(nextline, "%*s %2047s %2047s %2047s\n",
                          str1, str2, str3);
            if (narg < 1) {
                STRNCPY(str1, "0", MAX_EXPR_LEN);
            }
            if (narg < 2) {
                STRNCPY(str2, "0", MAX_EXPR_LEN);
            }
            if (narg < 3) {
                STRNCPY(str3, "0", MAX_EXPR_LEN);
            }

            /* create the new Branch */
            status = ocsmNewBrch(MODL, MODL->ibrch, OCSM_UNION, filename, linenum,
                                 str1, str2, str3, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS2(ocsmNewBrch);

        /* illegal command */
        } else {
            status = OCSM_ILLEGAL_STATEMENT;
            signalError2(MODL, status, filename, linenum,
                         "unrecognized command \"%s\"", command);
            goto cleanup;
        }
    }

    /* remove all UNKNOWN Parameters, no matter its scope (since they were created by a DIMENSION
       statement in preparation for a DESPMTR, CFGPMTR, or OUTPMTR statement) */
    if (filetype == -1 || filetype == 0 || filetype == 1) {
        for (ipmtr = MODL->npmtr; ipmtr > 0; ipmtr--) {
            SPLINT_CHECK_FOR_NULL(MODL->pmtr);

            if (MODL->pmtr[ipmtr].type == OCSM_UNKNOWN) {
                MODL->pmtr[ipmtr].scope = MODL->scope[MODL->level];
                status = ocsmDelPmtr(MODL, ipmtr);
                CHECK_STATUS2(ocsmDelPmtr);
            }
        }
    }

cleanup:
#undef CHECK_STATUS2
    if (MODL != NULL) {
        if (status == 0) {
            status = MODL->sigCode;
        }

        /* close the .csm file */
        if (fp_csm != NULL) fclose(fp_csm);
    }

    FREE(str9);
    FREE(str8);
    FREE(str7);
    FREE(str6);
    FREE(str5);
    FREE(str4);
    FREE(str3);
    FREE(str2);
    FREE(str1);

    FREE(str );

    FREE(command );
    FREE(nextline);
    FREE(templine);

    return status;
}


/***********************************************************************/
/*                                                                     */
/*   ocsmLoadFromModel - create a MODL from an ego MODEL               */
/*                                                                     */
/***********************************************************************/

int
ocsmLoadFromModel(ego    emodel,        /* egads MODEL */
                  void   **modl)        /* (out) pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL=NULL;

    int    i, oclass1, mtype1, oclass2, mtype2, nchild, *senses, ichild, nnode;
    int    ibody, okay, stat, npts;
    double data[4];
    ego    eref, topref, prev, next, *echilds, ebody;

    ROUTINE(ocsmLoadFromModel);

    /* --------------------------------------------------------------- */

    SPRINT0(1, "--> enter ocsmLoadFromModel()");

    /* make a new MODL and initialize it */
    MALLOC(MODL, modl_T, 1);

    MODL->magic      = OCSM_MAGIC;
    MODL->checked    = 0;
    MODL->ibrch      = 0;
    MODL->nextseq    = 1;
    MODL->ngroup     = 0;
    MODL->recycle    = 0;
    MODL->verify     = 0;
    MODL->cleanup    = 25;
    MODL->dumpEgads  = 0;
    MODL->loadEgads  = 0;
    MODL->hasMPs     = 0;
    MODL->printStack = 0;
    MODL->tessAtEnd  = 1;
    MODL->erepAtEnd  = 0;
    MODL->bodyLoaded = 0;

    MODL->seltype = -1;
    MODL->selbody = -1;
    MODL->selsize =  0;
    MODL->sellist = NULL;

    MODL->level = 0;

    for (i = 0; i < 11; i++) {
        MODL->scope[i] = 0;
    }

    MODL->filename[0] = '\0';

    MODL->tmpDirNum = -1;

    MODL->ninline = 0;
    MODL->minline = 0;
    MODL->sinline = NULL;

    MODL->nattr = 0;
    MODL->attr  = NULL;

    MODL->nstor = 0;
    MODL->stor  = NULL;

    MODL->nbrch = 0;
    MODL->mbrch = 0;
    MODL->brch  = NULL;

    MODL->npmtr = 0;
    MODL->mpmtr = 0;
    MODL->pmtr  = NULL;

    MODL->nbody = 0;
    MODL->mbody = 0;
    MODL->body  = NULL;

    MODL->numdots    = 0;
    MODL->perturb    = NULL;
    MODL->basemodl   = NULL;
    MODL->dtime      = 0;

    status = EG_getContext(emodel, &(MODL->context));
    CHECK_STATUS(EG_getContext);

    MODL->userdata    = NULL;
    MODL->mesgCB      = NULL;
    MODL->sizeCB      = NULL;
    MODL->eggname[0]  = '\0';
    MODL->eggGenerate = NULL;
    MODL->eggMorph    = NULL;
    MODL->eggInfo     = NULL;
    MODL->eggDump     = NULL;
    MODL->eggLoad     = NULL;
    MODL->eggFree     = NULL;

    MODL->nwarn   = 0;
    MODL->sigCode = 0;
    MODL->sigMesg = NULL;
    MALLOC(MODL->sigMesg, char, MAX_STR_LEN);
    MODL->sigMesg[0] = '\0';

    for (i = 0; i < 101; i++) {
        MODL->profile[i].ncall = 0;
        MODL->profile[i].time  = 0;
    }

    /* return value */
    *modl = MODL;

    /* get info from emodel */
    status = EG_getTopology(emodel, &eref, &oclass1, &mtype1,
                            data, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    if (oclass1 != MODEL) {
        status = OCSM_UNSUPPORTED;
        signalError2(MODL, status, "<emodel>", 0,
                     "emodel is not a MODEL");
        goto cleanup;
    }

    /* loop through the children of the MODEL */
    for (ichild = 0; ichild < MAX(nchild,mtype1); ichild++) {
        status = EG_getInfo(echilds[ichild], &oclass2, &mtype2, &topref, &prev, &next);
        CHECK_STATUS(EG_getInfo);

        if (oclass2 == BODY) {
            if        (mtype2 == SOLIDBODY) {
                status = newBody(MODL, 0, 0, 0, 0, NULL, 0, OCSM_SOLID_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else if (mtype2 == SHEETBODY) {
                status = newBody(MODL, 0, 0, 0, 0, NULL, 0, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else {
                status = EG_getBodyTopos(echilds[ichild], NULL, NODE, &nnode, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nnode > 1) {
                    status = newBody(MODL, 0, 0, 0, 0, NULL, 0, OCSM_WIRE_BODY, &ibody);
                    CHECK_STATUS(newBody);
                } else {
                    status = newBody(MODL, 0, 0, 0, 0, NULL, 0, OCSM_NODE_BODY, &ibody);
                    CHECK_STATUS(newBody);
                }
            }

            SPLINT_CHECK_FOR_NULL(MODL->body);

            status = EG_copyObject(echilds[ichild], NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            status = finishBody(MODL, ibody);
            CHECK_STATUS(finishBody);

            MODL->body[ibody].onstack = 1;

        } else if (oclass2 == EBODY) {
            status = OCSM_UNSUPPORTED;
            signalError2(MODL, status, "<emodel>", 0,
                         "emodel cannot contain an EBODY");
            goto cleanup;

        } else if (oclass2 == TESSELLATION) {
            SPLINT_CHECK_FOR_NULL(MODL->body);

            status = EG_statusTessBody(echilds[ichild], &ebody, &stat, &npts);
            CHECK_STATUS(EG_statusTessBody);

            okay = 0;
            for (ibody = 0; ibody < nchild; ibody++) {
                if (echilds[ibody] == ebody) {
                    status = EG_copyObject(echilds[ichild], MODL->body[ibody+1].ebody,
                                           &(MODL->body[ibody+1].etess));
                    CHECK_STATUS(EG_copyObject);
                    okay = 1;
                    break;
                }
            }

            if (okay == 0) {
                status = OCSM_UNSUPPORTED;
                signalError2(MODL, status, "<emodel>", 0,
                             "TESSELLATION found that does not link to a BODY");
                goto cleanup;
            }
        }
    }

    SPLINT_CHECK_FOR_NULL(MODL->body);

    /* create default tessellations for any Body that does not already have a tessellation */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        if (MODL->body[ibody].etess == NULL) {
            status = ocsmTessellate(MODL, ibody);
            CHECK_STATUS(ocsmTessellate);
        }
    }


cleanup:
    return status;
}


/***********************************************************************/
/*                                                                     */
/*   ocsmLoadDict - load dictionary from dictname                      */
/*                                                                     */
/***********************************************************************/

int
ocsmLoadDict(void   *modl,              /* (in)  pointer to MODL */
             char   dictname[])         /* (in)  file that contains dictionary */
{
    int       status = SUCCESS;         /* (out) return status */

    int       jpmtr, ipmtr, nrow, irow, ncol, icol, index;
    double    *vals=NULL, *dots=NULL;
    char      pmtrName[MAX_EXPR_LEN], pmtrDefn[MAX_EXPR_LEN], str[MAX_EXPR_LEN];
    FILE      *dict_fp=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmLoadDict);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if there was a dictionary, load the definitions from it now */
    if (STRLEN(dictname) <= 0) goto cleanup;

    dict_fp = fopen(dictname, "r");
    if (dict_fp == NULL) {
        SPRINT1(0, "ERROR:: dictionary \"%s\" not found", dictname);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    SPRINT1(0, "--> Opening dictionary \"%s\"", dictname);

    while (1) {
        status = fscanf(dict_fp, "%s %s\n", pmtrName, pmtrDefn);
        if (status < 2) break;

        /* make sure we have a good Parameter name */
        SPRINT2(0, "    defining constant %-20s = %s", pmtrName, pmtrDefn);

        if (pmtrName[0] == '@') {
            SPRINT0(0, "ERROR:: constant name cannot start with @");
            status = OCSM_ILLEGAL_PMTR_NAME;
            goto cleanup;
        }

        /* parse the value(s) */
        status = str2vals(pmtrDefn, MODL, &nrow, &ncol, &vals, &dots, str);
        if (status < SUCCESS) {
            SPRINT1(0, "ERROR:: constant value(s) \"%s\"could not be parsed", pmtrDefn);
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        } else if (strlen(str) > 0) {
            SPRINT1(0, "ERROR:: constant value(s)\"%s\" must not be a string", pmtrDefn);
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        }
        SPLINT_CHECK_FOR_NULL(vals);
        SPLINT_CHECK_FOR_NULL(dots);

        /* see if a CONPMTR already exists and if it matches the current definition */
        ipmtr = -1;
        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            if (strcmp(MODL->pmtr[jpmtr].name, pmtrName) == 0) {
                if (MODL->pmtr[jpmtr].type != OCSM_CONPMTR ||
                    MODL->pmtr[jpmtr].nrow != nrow         ||
                    MODL->pmtr[jpmtr].ncol != ncol           ) {
                    SPRINT1(0, "ERROR:: \"%s\" is already defined and does not match file", pmtrName);
                    status = OCSM_NAME_ALREADY_DEFINED;
                    goto cleanup;
                }

                index = 0;
                for (irow = 1; irow <= nrow; irow++) {
                    for (icol = 1; icol <= ncol; icol++) {
                        if (fabs(MODL->pmtr[jpmtr].value[index]-vals[index]) > EPS06) {
                            SPRINT5(0, "ERROR:: for %s[%d,%d], new value (%10.5f) and old value (%10.5f) do not agree",
                                    pmtrName, irow, icol, MODL->pmtr[jpmtr].value[index], vals[index]);
                            status = OCSM_ILLEGAL_VALUE;
                            goto cleanup;
                        }
                        index++;
                    }
                }
                ipmtr = jpmtr;
                break;
            }
        }

        /* we found a CONPMTR that matches, so read next line of file */
        if (ipmtr > 0) {
            FREE(vals);
            FREE(dots);
            continue;
        }

        /* create a CONPMTR and set its values */
        status = ocsmNewPmtr(MODL, pmtrName, OCSM_CONPMTR, nrow, ncol);
        if (status != SUCCESS) {
            SPRINT1(0, "ERROR:: problem creating \"%s\"", pmtrName);
            status = OCSM_ILLEGAL_PMTR_NAME;
            goto cleanup;
        }

        for (index = 0; index < nrow*ncol; index++) {
            MODL->pmtr[MODL->npmtr].value[index] = vals[index];
            MODL->pmtr[MODL->npmtr].dot[  index] = dots[index];
        }

        FREE(vals);
        FREE(dots);
    }

    /* getting here means that we succeeded */
    status = SUCCESS;

cleanup:
    if (dict_fp != NULL) fclose(dict_fp);

    FREE(vals);
    FREE(dots);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *  ocsmAdjustUDCs - adjust UDCs to be colocated with the .csm file     *
 *                                                                      *
 ************************************************************************
 */

int
ocsmAdjustUDCs(void   *modl)            /* (in)  pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ibrch, jbrch, seen, i;
    char      csmFilename[MAX_FILENAME_LEN+2], udcFilename[MAX_FILENAME_LEN+2];
    char      ext[5], buf[MAX_LINE_LEN];
    FILE      *fp_src=NULL, *fp_tgt=NULL;
    modl_T    *MODL = (modl_T *)modl;

    ROUTINE(ocsmAdjustUDCs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    csmFilename[0] = '\0';
    udcFilename[0] = '\0';

    /* copy all .udc files into the same directory as the .csm file */
    for (ibrch = 1;  ibrch <= MODL->nbrch; ibrch++) {
        strncpy(ext, &(MODL->brch[ibrch].filename[strlen(MODL->brch[ibrch].filename)-4]), 4);

        /* .csm file */
        if (strcmp(ext, ".csm") == 0) {
            if (strlen(csmFilename) == 0) {
                strncpy(csmFilename, MODL->brch[ibrch].filename, MAX_FILENAME_LEN);
            } else if (strcmp(csmFilename, MODL->brch[ibrch].filename) != 0) {
                SPRINT3(0, "ERROR:: \"%s\" and \"%s\" differ for ibrch=%d",
                        csmFilename, MODL->brch[ibrch].filename, ibrch);
                status = OCSM_NAME_ALREADY_DEFINED;
                goto cleanup;
            }

        /* .udc file */
        } else if (strcmp(ext, ".udc") == 0) {

            /* check if we have seen ths file before */
            seen = 0;
            for (jbrch = 1; jbrch < ibrch; jbrch++) {
                if (strcmp(MODL->brch[jbrch].filename, MODL->brch[ibrch].filename) == 0) {
                    seen = 1;
                    break;
                }
            }

            /* no further processing if we have seen this filename before */
            if (seen == 1) continue;

            /* make the name of the new UDC file as the part of the .csm
               filename up to the last slash, followed by the part of the
               Branch's .udc filename after the last slash */
            strncpy(udcFilename, csmFilename, MAX_FILENAME_LEN);

            seen = 0;
            for (i = strlen(udcFilename)-1; i >= 0; i--) {
                if (udcFilename[i] == SLASH) {
                    udcFilename[i+1] = '\0';
                    seen = 1;
                    break;
                }
            }
            if (seen == 0) {
                udcFilename[0] = '\0';
            }

            seen = 0;
            for (i = strlen(MODL->brch[ibrch].filename)-1; i >= 0; i--) {
                if (MODL->brch[ibrch].filename[i] == SLASH) {
                    strncat(udcFilename, &(MODL->brch[ibrch].filename[i+1]), MAX_FILENAME_LEN);
                    seen = 1;
                    break;
                }
            }
            if (seen == 0) {
                strncat(udcFilename, MODL->brch[ibrch].filename, MAX_FILENAME_LEN);
            }

            /* copy the file */
            if (strcmp(udcFilename, MODL->brch[ibrch].filename) == 0) {
                SPRINT2(0, "WARNING:: skipping copy of \"%s\" to \"%s\"", MODL->brch[ibrch].filename, udcFilename);
                continue;
            }

            fp_src = fopen(MODL->brch[ibrch].filename, "r");
            if (fp_src == NULL) {
                SPRINT2(0, "ERROR:: \"%s\" not found while processing ibrch=%d",
                        MODL->brch[ibrch].filename, ibrch);
                status = OCSM_FILE_NOT_FOUND;
                goto cleanup;
            }

            fp_tgt = fopen(udcFilename, "w");
            if (fp_tgt == NULL) {
                SPRINT2(0, "ERROR:: \"%s\" cannot be created while processing ibrch=%d",
                        udcFilename, ibrch);
                status = OCSM_FILE_NOT_FOUND;
                goto cleanup;
            }

            while (fgets(buf, MAX_LINE_LEN, fp_src) != NULL) {
                fputs(buf, fp_tgt);
            }

            fclose(fp_src);   fp_src = NULL;
            fclose(fp_tgt);   fp_tgt = NULL;

        /* unknown filetype */
        } else {
            SPRINT2(0, "ERROR:: \"%s\" at ibrch=%d is neither .csm nor .udc",
                    MODL->brch[ibrch].filename, ibrch);
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        }
    }

    /* adjust the Branches to point to the new .udc locations */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {

        /* adjust filename entry */
        if (strstr(MODL->brch[ibrch].filename, ".udc") != NULL) {

            /* make the name of the new UDC file as the part of the .csm
               filename up to the last slash, followed by the part of the
               Branch's .udc filename after the last slash */
            strncpy(udcFilename, csmFilename, MAX_FILENAME_LEN);

            seen = 0;
            for (i = strlen(udcFilename)-1; i >= 0; i--) {
                if (udcFilename[i] == SLASH) {
                    udcFilename[i+1] = '\0';
                    seen = 1;
                    break;
                }
            }
            if (seen == 0) {
                udcFilename[0] = '\0';
            }

            seen = 0;
            for (i = strlen(MODL->brch[ibrch].filename)-1; i >= 0; i--) {
                if (MODL->brch[ibrch].filename[i] == SLASH) {
                    strncat(udcFilename, &(MODL->brch[ibrch].filename[i+1]), MAX_FILENAME_LEN);
                    seen = 1;
                    break;
                }
            }
            if (seen == 0) {
                strncat(udcFilename, MODL->brch[ibrch].filename, MAX_FILENAME_LEN);
            }

            strcpy(MODL->brch[ibrch].filename, udcFilename);
        }

        /* adjust primtype associated with UDPARG or UDPRIM */
        SPLINT_CHECK_FOR_NULL(buf);

        if (MODL->brch[ibrch].type == OCSM_UDPARG ||
            MODL->brch[ibrch].type == OCSM_UDPRIM   ) {

            /* original .udc in pwd */
            if        (strncmp(MODL->brch[ibrch].arg1, "$/",   2) == 0) {
                strncpy(buf, MODL->brch[ibrch].arg1, MAX_LINE_LEN);
                snprintf(MODL->brch[ibrch].arg1, MAX_LINE_LEN, "$$/%s", &(buf[2]));

            /* original .udc in system directory */
            } else if (strncmp(MODL->brch[ibrch].arg1, "$$$/", 4) == 0) {
                strncpy(buf, MODL->brch[ibrch].arg1, MAX_LINE_LEN);
                snprintf(MODL->brch[ibrch].arg1, MAX_LINE_LEN, "$$/%s", &(buf[4]));
            }
        }
    }

cleanup:
    if (fp_src != NULL) fclose(fp_src);
    if (fp_tgt != NULL) fclose(fp_tgt);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *  ocsmUpdateDespmtrs - update CFGPMTRs and DESPMTRs from filename     *
 *                                                                      *
 ************************************************************************
 */

int
ocsmUpdateDespmtrs(void   *modl,        /* (in)  pointer to MODL */
                   char   filename[])   /* (in)  file that contains DESPMTRs */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipmtr, irow, icol;
    double    pmtrvalue;
    char      pname[MAX_NAME_LEN], pmtrname[MAX_NAME_LEN];
    FILE      *fp=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmUpdateDespmtrs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if there was a file, update the DESPMTRs mentioned in it now */
    if (STRLEN(filename) <= 0) goto cleanup;

    fp = fopen(filename, "r");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: DESPMTR file \"%s\" not found", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    SPRINT1(0, "--> Opening DESPMTR file \"%s\"", filename);

    /* read lines in the form pmtrname pmtrvalue */
    while (1) {
        status = fscanf(fp, "%s %lf\n", pname, &pmtrvalue);
        if (status < 2) break;

        /* break pname into pmtrName[irow,icol] */
        status = parseName(MODL, pname, pmtrname, &ipmtr, &irow, &icol);
        if (status < EGADS_SUCCESS) goto cleanup;

        /* make sure we found a valid DESPMTR */
        if (ipmtr <= 0) {
            SPRINT1(0, "ERROR:: \"%s\" is not a valid DESPMTR or CFGPMTR", pname);
            status = OCSM_ILLEGAL_PMTR_NAME;
            goto cleanup;
        } else if (MODL->pmtr[ipmtr].type != OCSM_DESPMTR &&
                   MODL->pmtr[ipmtr].type != OCSM_CFGPMTR   ) {
            SPRINT1(0, "ERROR:: \"%s\" is not a valid DESPMTR or CFGPMTR", pname);
            status = OCSM_ILLEGAL_PMTR_NAME;
            goto cleanup;
        }

        if (irow == 0 && icol == 0) {
            if (MODL->pmtr[ipmtr].nrow != 1 || MODL->pmtr[ipmtr].ncol != 1) {
                SPRINT1(0, "ERROR:: \"%s\" is not a scalar DESPMTR or CFGPMTR", MODL->pmtr[ipmtr].name);
                status = OCSM_ILLEGAL_PMTR_NAME;
                goto cleanup;
            }

            irow = 1;
            icol = 1;
        } else if (irow <= 0 || irow > MODL->pmtr[ipmtr].nrow) {
            SPRINT2(0, "ERROR:: row %d is not in range for \"%s\"", irow, MODL->pmtr[ipmtr].name);
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol <= 0 || icol > MODL->pmtr[ipmtr].ncol) {
            SPRINT2(0, "ERROR:: column %d is not in range for \"%s\"", icol, MODL->pmtr[ipmtr].name);
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        /* set the DESPMTR value */
        status = ocsmSetValuD(MODL, ipmtr, irow, icol, pmtrvalue);
        if (status < EGADS_SUCCESS) goto cleanup;

        if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR) {
            SPRINT4(0, "    updating DESPMTR %-32s[%2d,%2d] = %12.6f",
                    pmtrname, irow, icol, pmtrvalue);
        } else {
            SPRINT4(0, "    updating CFGPMTR %-32s[%2d,%2d] = %12.6f",
                    pmtrname, irow, icol, pmtrvalue);
        }
    }

    /* getting here means that we succeeded */
    status = SUCCESS;

cleanup:
    if (fp != NULL) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetFilelist - get a list of all .csm, .cpc, and .udc file      *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetFilelist(void   *modl,           /* (in)  pointer to MODL */
                char   *filelist[])     /* (out) bar-separated list of files */
                                        /*       must be freed by user */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        ibrch, lenFilelist=0;
    char       tmpFilename[MAX_FILENAME_LEN+2], *myFilelist=NULL;

    ROUTINE(ocsmGetFilelist);

    /* --------------------------------------------------------------- */

    /* initialize filelist */
    lenFilelist = MAX_FILENAME_LEN + 1000;
    MALLOC(myFilelist, char, lenFilelist);

    /* start with .csm or .cpc file */
    STRNCPY(myFilelist, MODL->filename, MAX_FILENAME_LEN);
    strcat(myFilelist, "|");

    /* look through all Branches and add its filename if not already in filelist */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        strcpy(tmpFilename, MODL->brch[ibrch].filename);
        strcat(tmpFilename, "|");

        if (strstr(myFilelist, tmpFilename) == NULL) {
            if (STRLEN(myFilelist)+STRLEN(MODL->brch[ibrch].filename)+2 > lenFilelist) {
                lenFilelist += 1000;
                RALLOC(myFilelist, char, lenFilelist);
            }

            strcat(myFilelist, tmpFilename);
        }
    }

    /* return the filelist (which must be freed by user) */
    *filelist = myFilelist;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSave - save a MODL to a file                                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSave(void   *modl,                  /* (in)  pointer to MODL */
         char   filename[])             /* (in)  file to be written (with extension) */
                                        /*       .csm -> write outer .csm file */
                                        /*       .cpc -> write checkpointed .csm file */
                                        /*       .udc -> write a .udc file */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       filelen, filetype, i, j;
    int       ipmtr, jpmtr, ibrch, jbrch, kbrch=-1, iattr, irow, icol, index, indent, nindent=0, n_inline;
    char      udcname[MAX_EXPR_LEN], templine[MAX_LINE_LEN];
    FILE      *csm_file, *fp_inline;

    ROUTINE(ocsmSave);

    /* --------------------------------------------------------------- */

    SPRINT1(1, "--> enter ocsmSave(filename=%s)", filename);

    csm_file  = NULL;
    fp_inline = NULL;

    /* check for a valid extension */
    filelen = STRLEN(filename);
    if (filelen < 5) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'c' &&
               filename[filelen-2] == 's' && filename[filelen-1] == 'm'   ) {
        SPRINT0(2, "    writing .csm file");
        filetype = 0;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'c' &&
               filename[filelen-2] == 'p' && filename[filelen-1] == 'c'   ) {
        SPRINT0(2, "    writing .cpc file");
        filetype = 1;
    } else if (filename[filelen-4] == '.' && filename[filelen-3] == 'u' &&
               filename[filelen-2] == 'd' && filename[filelen-1] == 'c'   ) {
        SPRINT0(2, "    writing .udc file");
        filetype = 2;

        /* get udc name (part after last $ or / ) */
        j          = 0;
        udcname[j] = '\0';
        for (i = 0; i < STRLEN(filename)-4; i++) {
            if (filename[i] == '$' || filename[i] == '/') {
                j          = 0;
                udcname[j] = '\0';
            } else {
                udcname[j  ] = filename[i];
                udcname[j+1] = '\0';
                j++;
            }
        }

        /* find the UDPRIM statement that refers to udcname */
        kbrch = -1;
        for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
            if (       MODL->brch[ibrch].type           == OCSM_UDPRIM &&
                strstr(MODL->brch[ibrch].arg1, udcname) != NULL        &&
                (MODL->brch[ibrch].arg1[1] == '/' || MODL->brch[ibrch].arg1[1] == '$')) {
                kbrch = ibrch;
                break;
            }
        }
    } else {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* open file */
    if (STRLEN(filename) == 0) {
        SPRINT0(0, "ERROR:: filename not specified");
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    csm_file = fopen(filename, "w");
    if (csm_file == NULL) {
        SPRINT1(0, "ERROR:: cannot open \"%s\"", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* write header */
    fprintf(csm_file, "# %s written by ocsmSave (v%d.%02d)\n",
            filename, OCSM_MAJOR_VERSION, OCSM_MINOR_VERSION);

    /* write the constant, output, and design Parameters */
    if (filetype == 0 || filetype == 1) {
        fprintf(csm_file, "\n# Constant, Design, and Output Parameters:\n");
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (MODL->pmtr[ipmtr].type  == OCSM_CONPMTR) {

                fprintf(csm_file, "CONPMTR   %s   %11.5f\n",
                        MODL->pmtr[ipmtr].name, MODL->pmtr[ipmtr].value[0]);
            } else if (MODL->pmtr[ipmtr].type  == OCSM_OUTPMTR) {

                fprintf(csm_file, "OUTPMTR   %s\n",
                        MODL->pmtr[ipmtr].name);
            } else if (MODL->pmtr[ipmtr].type  == OCSM_DESPMTR) {

                /* see if there is a DIMENSION statement associated with this DESPMTR */
                ibrch = 0;
                for (jbrch = 1; jbrch <= MODL->nbrch; jbrch++) {
                    if (MODL->brch[jbrch].type == OCSM_DIMENSION &&
                        strcmp(MODL->pmtr[ipmtr].name, &(MODL->brch[jbrch].arg1[1])) == 0) {
                        ibrch = jbrch;
                        break;
                    }
                }

                if (ibrch > 0) {
                    fprintf(csm_file, "DIMENSION %s   %s   %s\n",
                            &(MODL->brch[ibrch].arg1[1]),
                            MODL->brch[ibrch].arg2,
                            MODL->brch[ibrch].arg3);

                    index = 0;
                    for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                        fprintf(csm_file, "DESPMTR   %s[%d,:]   \"", MODL->pmtr[ipmtr].name, irow);
                        for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                            fprintf(csm_file, " %11.5f;", MODL->pmtr[ipmtr].value[index]);
                            index++;
                        }
                        fprintf(csm_file, "\"\n");
                    }
                } else if (MODL->pmtr[ipmtr].nrow > 1 || MODL->pmtr[ipmtr].ncol > 1) {
                    fprintf(csm_file, "DIMENSION %s   %d   %d\n",
                            MODL->pmtr[ipmtr].name,
                            MODL->pmtr[ipmtr].nrow,
                            MODL->pmtr[ipmtr].ncol);

                    index = 0;
                    for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                        fprintf(csm_file, "DESPMTR   %s[%d,:]   \"", MODL->pmtr[ipmtr].name, irow);
                        for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                            fprintf(csm_file, " %11.5f;", MODL->pmtr[ipmtr].value[index]);
                            index++;
                        }
                        fprintf(csm_file, "\"\n");
                    }

                } else {
                    fprintf(csm_file, "DESPMTR   %s   %11.5f\n",
                            MODL->pmtr[ipmtr].name, MODL->pmtr[ipmtr].value[0]);
                }

                index = 0;
                for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                        if (MODL->pmtr[ipmtr].lbnd[index] > -HUGEQ) {
                            fprintf(csm_file, "LBOUND      %s[%d,%d]   %f\n",
                                    MODL->pmtr[ipmtr].name,
                                    irow, icol,
                                    MODL->pmtr[ipmtr].lbnd[index]);
                        }
                        if (MODL->pmtr[ipmtr].ubnd[index] < +HUGEQ) {
                            fprintf(csm_file, "UBOUND      %s[%d,%d]   %f\n",
                                    MODL->pmtr[ipmtr].name,
                                    irow, icol,
                                    MODL->pmtr[ipmtr].ubnd[index]);
                        }

                        index++;
                    }
                }
            } else if (MODL->pmtr[ipmtr].type == OCSM_CFGPMTR) {
                fprintf(csm_file, "CFGPMTR   %s   %11.5f\n",
                            MODL->pmtr[ipmtr].name, MODL->pmtr[ipmtr].value[0]);
            }
        }
    }

    /* write the global Attributes */
    if (filetype == 0 || filetype == 1) {
        fprintf(csm_file, "\n# Global Attributes:\n");
        for (iattr = 0; iattr < MODL->nattr; iattr++) {
            fprintf(csm_file, "ATTRIBUTE %s   %s\n",
                    MODL->attr[iattr].name,
                    MODL->attr[iattr].defn);
        }
    }

    /* make sure indentation is up to date */
    status = ocsmCheck(MODL);
    CHECK_STATUS(ocsmCheck);

    /* write the Branches */
    fprintf(csm_file, "\n# Branches:\n");
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {

        /* special treatment if writing a .udc file and there is a matching UDPRIM */
        if (filetype == 2 && kbrch > 0) {

            /* advance to first Branch following UDPRIM statement */
            if (ibrch <= kbrch) {
                nindent = MODL->brch[ibrch].indent + 1;
                continue;

            /* we are done if an END statement */
            } else if (MODL->brch[ibrch].type == OCSM_END) {
                break;
            }

        /* special treatment if writing a .udc file and there is no matching UDPRIM */
        } else if (filetype == 2 && ibrch == 1) {
            fprintf(csm_file, "INTERFACE . all\n");

        }

        for (indent = nindent; indent < MODL->brch[ibrch].indent; indent++) {
            fprintf(csm_file, "   ");
        }

        if        (MODL->brch[ibrch].type == OCSM_APPLYCSYS) {
            fprintf(csm_file, "APPLYCSYS %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_ARC) {
            fprintf(csm_file, "ARC       %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                  &(MODL->brch[ibrch].arg5[1]));
        } else if (MODL->brch[ibrch].type == OCSM_ASSERT) {
            fprintf(csm_file, "ASSERT    %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_BEZIER) {
            fprintf(csm_file, "BEZIER    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_BLEND) {
            fprintf(csm_file, "BLEND     %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5);
        } else if (MODL->brch[ibrch].type == OCSM_BOX) {
            fprintf(csm_file, "BOX       %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6);
        } else if (MODL->brch[ibrch].type == OCSM_CATBEG) {
            fprintf(csm_file, "CATBEG    %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_CATEND) {
            fprintf(csm_file, "CATEND\n");
        } else if (MODL->brch[ibrch].type == OCSM_CHAMFER) {
            fprintf(csm_file, "CHAMFER   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_CIRARC) {
            fprintf(csm_file, "CIRARC    %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6);
        } else if (MODL->brch[ibrch].type == OCSM_COMBINE) {
            fprintf(csm_file, "COMBINE   %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_CONE) {
            fprintf(csm_file, "CONE      %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_CONNECT) {
            fprintf(csm_file, "CONNECT   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5);
        } else if (MODL->brch[ibrch].type == OCSM_CYLINDER) {
            fprintf(csm_file, "CYLINDER  %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_DIMENSION) {
            ipmtr = 0;
            for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                if (strcmp(MODL->pmtr[jpmtr].name, &(MODL->brch[ibrch].arg1[1])) == 0) {
                    if (MODL->pmtr[jpmtr].type == OCSM_DESPMTR ||
                        MODL->pmtr[jpmtr].type == OCSM_CFGPMTR   ) {
                        ipmtr = jpmtr;
                        break;
                    }
                }
            }

            if (ipmtr == 0) {
                fprintf(csm_file, "DIMENSION %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3);
            }
        } else if (MODL->brch[ibrch].type == OCSM_DUMP) {
            fprintf(csm_file, "DUMP      %s   %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_ELSE) {
            fprintf(csm_file, "ELSE\n");
        } else if (MODL->brch[ibrch].type == OCSM_ELSEIF) {
            fprintf(csm_file, "ELSEIF    %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                  &(MODL->brch[ibrch].arg2[1]),
                    MODL->brch[ibrch].arg3,
                  &(MODL->brch[ibrch].arg4[1]),
                    MODL->brch[ibrch].arg5,
                  &(MODL->brch[ibrch].arg6[1]),
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_END) {
            fprintf(csm_file, "END\n");
        } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
            fprintf(csm_file, "ENDIF\n");
        } else if (MODL->brch[ibrch].type == OCSM_EVALUATE) {
            if        (strcmp(MODL->brch[ibrch].arg1, "$node") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$NODE") == 0   ) {
                fprintf(csm_file, "EVALUATE  %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$edge") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$EDGE") == 0   ) {
                fprintf(csm_file, "EVALUATE  %s   %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3,
                        MODL->brch[ibrch].arg4);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$edgerng") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$EDGERNG") == 0   ) {
                fprintf(csm_file, "EVALUATE  %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$edgeinv") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$EDGEINV") == 0   ) {
                fprintf(csm_file, "EVALUATE  %s   %s   %s   %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3,
                        MODL->brch[ibrch].arg4,
                        MODL->brch[ibrch].arg5,
                        MODL->brch[ibrch].arg6);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$face") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$FACE") == 0   ) {
                fprintf(csm_file, "EVALUATE  %s   %s   %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3,
                        MODL->brch[ibrch].arg4,
                        MODL->brch[ibrch].arg5);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$facerng") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$FACERNG") == 0   ) {
                fprintf(csm_file, "EVALUATE  %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$faceinv") == 0 ||
                       strcmp(MODL->brch[ibrch].arg1, "$FACEINV") == 0   ) {
                fprintf(csm_file, "EVALUATE  %s   %s   %s   %s   %s   %s\n",
                      &(MODL->brch[ibrch].arg1[1]),
                        MODL->brch[ibrch].arg2,
                        MODL->brch[ibrch].arg3,
                        MODL->brch[ibrch].arg4,
                        MODL->brch[ibrch].arg5,
                        MODL->brch[ibrch].arg6);
            }
        } else if (MODL->brch[ibrch].type == OCSM_EXTRACT) {
            fprintf(csm_file, "EXTRACT   %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_EXTRUDE) {
            fprintf(csm_file, "EXTRUDE   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_FILLET) {
            fprintf(csm_file, "FILLET    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_GETATTR) {
            fprintf(csm_file, "GETATTR   %s %s %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_GROUP) {
            fprintf(csm_file, "GROUP     %s\n",
                MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_HOLLOW) {
            fprintf(csm_file, "HOLLOW    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_IFTHEN) {
            fprintf(csm_file, "IFTHEN    %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                  &(MODL->brch[ibrch].arg2[1]),
                    MODL->brch[ibrch].arg3,
                  &(MODL->brch[ibrch].arg4[1]),
                    MODL->brch[ibrch].arg5,
                  &(MODL->brch[ibrch].arg6[1]),
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_IMPORT) {
            fprintf(csm_file, "IMPORT    %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_INTERFACE) {
            fprintf(csm_file, "INTERFACE %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                  &(MODL->brch[ibrch].arg2[1]),
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_INTERSECT) {
            fprintf(csm_file, "INTERSECT %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3    );
        } else if (MODL->brch[ibrch].type == OCSM_JOIN) {
            fprintf(csm_file, "JOIN     %s    %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_LINSEG) {
            fprintf(csm_file, "LINSEG    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_LOFT) {
            fprintf(csm_file, "LOFT      %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_MACBEG) {
            fprintf(csm_file, "MACBEG    %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_MACEND) {
            fprintf(csm_file, "MACEND\n");
        } else if (MODL->brch[ibrch].type == OCSM_MARK) {
            fprintf(csm_file, "MARK\n");
        } else if (MODL->brch[ibrch].type == OCSM_MESSAGE) {
            fprintf(csm_file, "MESSAGE   %s   %s\n",
                 &(MODL->brch[ibrch].arg1[1]),
                 &(MODL->brch[ibrch].arg2[1]));
        } else if (MODL->brch[ibrch].type == OCSM_MIRROR) {
            fprintf(csm_file, "MIRROR    %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_PATBEG) {
            fprintf(csm_file, "PATBEG    %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2    );
        } else if (MODL->brch[ibrch].type == OCSM_PATBREAK) {
            fprintf(csm_file, "PATBREAK  %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_PATEND) {
            fprintf(csm_file, "PATEND\n");
        } else if (MODL->brch[ibrch].type == OCSM_POINT) {
            fprintf(csm_file, "POINT     %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_PROJECT) {
            fprintf(csm_file, "PROJECT   %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_RECALL) {
            fprintf(csm_file, "RECALL    %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_REORDER) {
            fprintf(csm_file, "REORDER   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_RESTORE) {
            fprintf(csm_file, "RESTORE   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2    );
        } else if (MODL->brch[ibrch].type == OCSM_REVOLVE) {
            fprintf(csm_file, "REVOLVE   %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7);
        } else if (MODL->brch[ibrch].type == OCSM_ROTATEX) {
            fprintf(csm_file, "ROTATEX   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_ROTATEY) {
            fprintf(csm_file, "ROTATEY   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_ROTATEZ) {
            fprintf(csm_file, "ROTATEZ   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_RULE) {
            fprintf(csm_file, "RULE      %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_SCALE) {
            fprintf(csm_file, "SCALE     %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_SELECT) {
            fprintf(csm_file, "SELECT    %s",
                  &(MODL->brch[ibrch].arg1[1]));
            if (MODL->brch[ibrch].narg >= 2) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg2);
            }
            if (MODL->brch[ibrch].narg >= 3) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg3);
            }
            if (MODL->brch[ibrch].narg >= 4) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg4);
            }
            if (MODL->brch[ibrch].narg >= 5) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg5);
            }
            if (MODL->brch[ibrch].narg >= 6) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg6);
            }
            if (MODL->brch[ibrch].narg >= 7) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg7);
            }
            if (MODL->brch[ibrch].narg >= 8) {
                fprintf(csm_file, "   %s",
                    MODL->brch[ibrch].arg8);
            }
            fprintf(csm_file, "\n");
        } else if (MODL->brch[ibrch].type == OCSM_SET) {
            fprintf(csm_file, "SET       %s %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_SKBEG) {
            fprintf(csm_file, "SKBEG     %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_SKCON) {
            fprintf(csm_file, "SKCON     %s   %s   %s  %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                  &(MODL->brch[ibrch].arg4[1]));
        } else if (MODL->brch[ibrch].type == OCSM_SKEND) {
            fprintf(csm_file, "SKEND     %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_SKVAR) {
            fprintf(csm_file, "SKVAR     %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2);
        } else if (MODL->brch[ibrch].type == OCSM_SOLBEG) {
            fprintf(csm_file, "SOLBEG    %s\n",
                  &(MODL->brch[ibrch].arg1[1]));
        } else if (MODL->brch[ibrch].type == OCSM_SOLCON) {
            fprintf(csm_file, "SOLCON    %s\n",
                  &(MODL->brch[ibrch].arg1[1]));
        } else if (MODL->brch[ibrch].type == OCSM_SOLEND) {
            fprintf(csm_file, "SOLEND\n");
        } else if (MODL->brch[ibrch].type == OCSM_SPECIAL) {
            fprintf(csm_file, "SPECIAL   %s   %s   %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7,
                    MODL->brch[ibrch].arg8,
                    MODL->brch[ibrch].arg9);
        } else if (MODL->brch[ibrch].type == OCSM_SPHERE) {
            fprintf(csm_file, "SPHERE    %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4);
        } else if (MODL->brch[ibrch].type == OCSM_SPLINE) {
            fprintf(csm_file, "SPLINE    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_SSLOPE) {
            fprintf(csm_file, "SSLOPE    %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_STORE) {
            fprintf(csm_file, "STORE     %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3    );
        } else if (MODL->brch[ibrch].type == OCSM_SUBTRACT) {
            fprintf(csm_file, "SUBTRACT  %s   %s   %s\n",
                  &(MODL->brch[ibrch].arg1[1]),
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3    );
        } else if (MODL->brch[ibrch].type == OCSM_SWEEP) {
            fprintf(csm_file, "SWEEP\n");
        } else if (MODL->brch[ibrch].type == OCSM_THROW) {
            fprintf(csm_file, "THROW     %s\n",
                    MODL->brch[ibrch].arg1);
        } else if (MODL->brch[ibrch].type == OCSM_TORUS) {
            fprintf(csm_file, "TORUS     %s   %s   %s   %s   %s   %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3,
                    MODL->brch[ibrch].arg4,
                    MODL->brch[ibrch].arg5,
                    MODL->brch[ibrch].arg6,
                    MODL->brch[ibrch].arg7,
                    MODL->brch[ibrch].arg8);
        } else if (MODL->brch[ibrch].type == OCSM_TRANSLATE) {
            fprintf(csm_file, "TRANSLATE %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        } else if (MODL->brch[ibrch].type == OCSM_UDPARG ||
                   MODL->brch[ibrch].type == OCSM_UDPRIM   ) {
            fp_inline = NULL;           // no inline file by default
            n_inline  = -1;

            if (MODL->brch[ibrch].type == OCSM_UDPARG) {
                fprintf(csm_file, "UDPARG    %s",
                        &(MODL->brch[ibrch].arg1[1]));
            } else {
                fprintf(csm_file, "UDPRIM    %s",
                        &(MODL->brch[ibrch].arg1[1]));
            }

            if (MODL->brch[ibrch].narg >= 3) {
                if        (strncmp(MODL->brch[ibrch].arg3, "$tmp_OpenCSM_", 13) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg2[1]));
                    fp_inline = fopen(&MODL->brch[ibrch].arg3[1], "r");
                } else if (strncmp(MODL->brch[ibrch].arg3, "$<<inline/", 10) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg2[1]));
                    n_inline = strtol(&(MODL->brch[ibrch].arg3[10]), NULL, 10);
                } else {
                    fprintf(csm_file, "   %s   %s",
                            &(MODL->brch[ibrch].arg2[1]),
                              MODL->brch[ibrch].arg3);
                }
            }
            if (MODL->brch[ibrch].narg >= 5) {
                if        (strncmp(MODL->brch[ibrch].arg5, "$tmp_OpenCSM_", 13) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg4[1]));
                    fp_inline = fopen(&MODL->brch[ibrch].arg5[1], "r");
                } else if (strncmp(MODL->brch[ibrch].arg5, "$<<inline/", 10) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg4[1]));
                    n_inline = strtol(&(MODL->brch[ibrch].arg5[10]), NULL, 10);
                } else {
                    fprintf(csm_file, "   %s   %s",
                            &(MODL->brch[ibrch].arg4[1]),
                              MODL->brch[ibrch].arg5);
                }
            }
            if (MODL->brch[ibrch].narg >= 7) {
                if        (strncmp(MODL->brch[ibrch].arg7, "$tmp_OpenCSM_", 13) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg6[1]));
                    fp_inline = fopen(&MODL->brch[ibrch].arg7[1], "r");
                } else if (strncmp(MODL->brch[ibrch].arg7, "$<<inline/", 10) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg6[1]));
                    n_inline = strtol(&(MODL->brch[ibrch].arg7[10]), NULL, 10);
                } else {
                    fprintf(csm_file, "   %s   %s",
                            &(MODL->brch[ibrch].arg6[1]),
                              MODL->brch[ibrch].arg7);
                }
            }
            if (MODL->brch[ibrch].narg >= 9) {
                if        (strncmp(MODL->brch[ibrch].arg9, "$tmp_OpenCSM_", 13) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg8[1]));
                    fp_inline = fopen(&MODL->brch[ibrch].arg9[1], "r");
                } else if (strncmp(MODL->brch[ibrch].arg9, "$<<inline/", 10) == 0) {
                    fprintf(csm_file, "   %s   <<",
                            &(MODL->brch[ibrch].arg8[1]));
                    n_inline = strtol(&(MODL->brch[ibrch].arg9[10]), NULL, 10);
                } else {
                    fprintf(csm_file, "   %s   %s",
                            &(MODL->brch[ibrch].arg8[1]),
                              MODL->brch[ibrch].arg9);
                }
            }
            fprintf(csm_file, "\n");

            /* write an inline file (if there is one) */
            if (fp_inline != NULL) {
                while (1) {
                    if (fgets(templine, MAX_LINE_LEN, fp_inline) == NULL) break;

                    fprintf(csm_file, "%s", templine);
                }

                fclose(fp_inline);
                fp_inline = NULL;
                fprintf(csm_file, ">>\n");

            } else if (n_inline >= 0) {
                fprintf(csm_file, "%s", &(MODL->sinline[n_inline+3]));
                fprintf(csm_file, ">>\n");
            }

            /* skip Branches within this enclosed .udc (if not writing .cpc file) */
            if (filetype != 1 && MODL->brch[ibrch].type == OCSM_UDPRIM) {
                if (strncmp(MODL->brch[ibrch].arg1, "$/",   2) == 0 ||
                    strncmp(MODL->brch[ibrch].arg1, "$$/",  3) == 0 ||
                    strncmp(MODL->brch[ibrch].arg1, "$$$/", 4) == 0   ) {
                    jbrch = ibrch;
                    while (MODL->brch[ibrch].type   != OCSM_END                ||
                           MODL->brch[ibrch].indent != MODL->brch[jbrch].indent  ) {
                        ibrch++;
                        if (ibrch > MODL->nbrch) {
                            signalError(MODL, OCSM_INTERNAL_ERROR,
                                        "could not find matching END statement");
                            status = OCSM_INTERNAL_ERROR;
                            goto cleanup;
                        }
                    }
                }
            }
        } else if (MODL->brch[ibrch].type == OCSM_UNION) {
            fprintf(csm_file, "UNION     %s   %s   %s\n",
                    MODL->brch[ibrch].arg1,
                    MODL->brch[ibrch].arg2,
                    MODL->brch[ibrch].arg3);
        }

        /* write the name of the Branch (if not the default name) */
        if (strncmp(MODL->brch[ibrch].name, "Brch_", 5) != 0) {
            fprintf(csm_file, "NAME      %s\n",
                    MODL->brch[ibrch].name);
        }

        /* write the Attributes for the Branch */
        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            if        (MODL->brch[ibrch].attr[iattr].type != ATTRCSYS) {
                fprintf(csm_file, "ATTRIBUTE %s   %s\n",
                        MODL->brch[ibrch].attr[iattr].name,
                        MODL->brch[ibrch].attr[iattr].defn);
            } else {
                fprintf(csm_file, "CSYSTEM   %s   %s\n",
                        MODL->brch[ibrch].attr[iattr].name,
                        MODL->brch[ibrch].attr[iattr].defn);
            }
        }
    }

    /* close the file */
    fprintf(csm_file, "\nEND\n");
    fclose(csm_file);
    csm_file = NULL;

cleanup:
    if (csm_file  != NULL) fclose(csm_file );
    if (fp_inline != NULL) fclose(fp_inline);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *  ocsmSaveDespmtrs - save CFGPMTRs and DESPMTRs to filename           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSaveDespmtrs(void   *modl,          /* (in)  pointer to MODL */
                 char   filename[])     /* (in)  file to write */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipmtr, irow, icol, index;
    FILE      *fp=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSaveDespmtrs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* create the file */
    fp = fopen(filename, "w");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: DESPMTR file \"%s\" could not be created", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* loop through the CFGPMTRS */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type != OCSM_CFGPMTR) continue;

        index = 0;
        for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
            for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                fprintf(fp, "%s[%d,%d]  %15.8e\n",
                        MODL->pmtr[ipmtr].name, irow, icol,
                        MODL->pmtr[ipmtr].value[index]);
                index++;
            }
        }
    }

    /* loop through the DESPMTRS */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type != OCSM_DESPMTR) continue;

        index = 0;
        for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
            for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                fprintf(fp, "%s[%d,%d]  %15.8e\n",
                        MODL->pmtr[ipmtr].name, irow, icol,
                        MODL->pmtr[ipmtr].value[index]);
                index++;
            }
        }
    }

cleanup:
    if (fp != NULL) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmCopy - copy a MODL                                             *
 *                                                                      *
 ************************************************************************
 */

int
ocsmCopy(void   *srcModl,               /* (in)  pointer to source MODL */
         void   **newModl)              /* (out) pointer to new    MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *SRC_MODL = (modl_T*)srcModl;
    modl_T    *NEW_MODL = NULL;

    int       ibrch, iattr, istor, ipmtr, irow, icol, index, i, j, itmp;
    char      filename_src[MAX_FILENAME_LEN], filename_new[MAX_FILENAME_LEN];
    char      templine[MAX_LINE_LEN];
    FILE      *fp_src, *fp_new;

    ROUTINE(ocsmCopy);

    /* --------------------------------------------------------------- */

    /* default return value */
    *newModl = NULL;

    /* check magic number */
    if (SRC_MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (SRC_MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* make a new MODL and initialize it */
    MALLOC(NEW_MODL, modl_T, 1);

    NEW_MODL->magic      = OCSM_MAGIC;
    NEW_MODL->checked    = 0;
    NEW_MODL->ibrch      = 0;
    NEW_MODL->nextseq    = 1;
    NEW_MODL->ngroup     = SRC_MODL->ngroup;
    NEW_MODL->recycle    = 0;
    NEW_MODL->verify     = SRC_MODL->verify;
    NEW_MODL->cleanup    = SRC_MODL->cleanup;
    NEW_MODL->dumpEgads  = SRC_MODL->dumpEgads;
    NEW_MODL->loadEgads  = SRC_MODL->loadEgads;
    NEW_MODL->hasMPs     = SRC_MODL->hasMPs;
    NEW_MODL->printStack = SRC_MODL->printStack;
    NEW_MODL->tessAtEnd  = SRC_MODL->tessAtEnd;
    NEW_MODL->erepAtEnd  = SRC_MODL->erepAtEnd;
    NEW_MODL->bodyLoaded = SRC_MODL->bodyLoaded;

    NEW_MODL->seltype = -1;
    NEW_MODL->selbody = -1;
    NEW_MODL->selsize =  0;
    NEW_MODL->sellist = NULL;

    NEW_MODL->level = SRC_MODL->level;
    for (i = 0; i < 11; i++) {
        NEW_MODL->scope[i] = SRC_MODL->scope[i];
    }

    strcpy(NEW_MODL->filename, SRC_MODL->filename);

    NEW_MODL->ninline = SRC_MODL->ninline;
    NEW_MODL->minline = SRC_MODL->minline;
    NEW_MODL->sinline = NULL;

    if (NEW_MODL->minline > 0) {
        MALLOC(NEW_MODL->sinline, char, NEW_MODL->minline);
        memcpy(NEW_MODL->sinline, SRC_MODL->sinline, (NEW_MODL->minline)*sizeof(char));
    }

    NEW_MODL->nattr = 0;
    NEW_MODL->attr  = NULL;

    NEW_MODL->nstor = 0;
    NEW_MODL->stor  = NULL;

    NEW_MODL->nbrch = 0;
    NEW_MODL->mbrch = 0;
    NEW_MODL->brch  = NULL;

    NEW_MODL->npmtr = 0;
    NEW_MODL->mpmtr = 0;
    NEW_MODL->pmtr  = NULL;

    NEW_MODL->nbody = 0;
    NEW_MODL->mbody = 0;
    NEW_MODL->body  = NULL;

    NEW_MODL->numdots    = SRC_MODL->numdots;
    NEW_MODL->perturb    = NULL;
    NEW_MODL->basemodl   = NULL;
    NEW_MODL->dtime      = 0;

    NEW_MODL->context     = SRC_MODL->context;
    NEW_MODL->userdata    = SRC_MODL->userdata;
    NEW_MODL->mesgCB      = SRC_MODL->mesgCB;
    NEW_MODL->sizeCB      = SRC_MODL->sizeCB;
    strcpy(NEW_MODL->eggname, SRC_MODL->eggname);
    NEW_MODL->eggGenerate = SRC_MODL->eggGenerate;
    NEW_MODL->eggMorph    = SRC_MODL->eggMorph;
    NEW_MODL->eggDump     = SRC_MODL->eggDump;
    NEW_MODL->eggLoad     = SRC_MODL->eggLoad;
    NEW_MODL->eggFree     = SRC_MODL->eggFree;

    NEW_MODL->nwarn   = 0;
    NEW_MODL->sigCode = 0;
    NEW_MODL->sigMesg = NULL;
    MALLOC(NEW_MODL->sigMesg, char, MAX_STR_LEN);
    NEW_MODL->sigMesg[0] = '\0';

    for (i = 0; i < 101; i++) {
        NEW_MODL->profile[i].ncall = SRC_MODL->profile[i].ncall;
        NEW_MODL->profile[i].time  = SRC_MODL->profile[i].time;
    }

    /* return value */
    *newModl = NEW_MODL;

    /* copy the global Parameters */
    for (iattr = 0; iattr < SRC_MODL->nattr; iattr++) {
        status = ocsmSetAttr(NEW_MODL, 0,
                             SRC_MODL->attr[iattr].name,
                             SRC_MODL->attr[iattr].defn);
    }

    /* copy the Storge locations */
    NEW_MODL->nstor = SRC_MODL->nstor;

    MALLOC(NEW_MODL->stor, stor_T, NEW_MODL->nstor);

    for (istor = 0; istor < NEW_MODL->nstor; istor++) {
        STRNCPY(NEW_MODL->stor[istor].name, SRC_MODL->stor[istor].name, MAX_NAME_LEN);

        NEW_MODL->stor[istor].index = SRC_MODL->stor[istor].index;
        NEW_MODL->stor[istor].nbody = SRC_MODL->stor[istor].nbody;
        NEW_MODL->stor[istor].ibody = NULL;
        NEW_MODL->stor[istor].ebody = NULL;

        MALLOC(NEW_MODL->stor[istor].ibody, int, NEW_MODL->stor[istor].nbody);
        MALLOC(NEW_MODL->stor[istor].ebody, ego, NEW_MODL->stor[istor].nbody);

        for (i = 0; i < NEW_MODL->stor[istor].nbody; i++) {
            NEW_MODL->stor[istor].ibody[i] = SRC_MODL->stor[istor].ibody[i];
            NEW_MODL->stor[istor].ebody[i] = SRC_MODL->stor[istor].ebody[i];
        }
    }

    /* copy the Parameter table (done before Branch table so that
       new Parameters do not get created by a OCSM_SET, OCSM_GETATTR, or OCSM_PATBEG) */

    /* make sure new Parameter is created with the correct scope */
    for (ipmtr = 1; ipmtr <= SRC_MODL->npmtr; ipmtr++) {
        for (j = 0; j < 11; j++) {
            if (SRC_MODL->scope[j] == SRC_MODL->pmtr[ipmtr].scope) {
                NEW_MODL->level = j;
                break;
            }
        }
        if        (strcmp(SRC_MODL->pmtr[ipmtr].name, "@stack") == 0) {
            status = ocsmNewPmtr(NEW_MODL,
                                 SRC_MODL->pmtr[ipmtr].name,
                                 SRC_MODL->pmtr[ipmtr].type,
                                 1,
                                 MAX_STACK_SIZE);
        } else if (strcmp(SRC_MODL->pmtr[ipmtr].name, "@edata") == 0) {
            status = ocsmNewPmtr(NEW_MODL,
                                 SRC_MODL->pmtr[ipmtr].name,
                                 SRC_MODL->pmtr[ipmtr].type,
                                 1,
                                 23);
        } else {
            status = ocsmNewPmtr(NEW_MODL,
                                 SRC_MODL->pmtr[ipmtr].name,
                                 SRC_MODL->pmtr[ipmtr].type,
                                 SRC_MODL->pmtr[ipmtr].nrow,
                                 SRC_MODL->pmtr[ipmtr].ncol);
        }
        CHECK_STATUS(ocsmNewPmtr);
        SPLINT_CHECK_FOR_NULL(NEW_MODL->pmtr);
        NEW_MODL->level = SRC_MODL->level;

        if (SRC_MODL->pmtr[ipmtr].value != NULL) {
            index = 0;
            for (irow = 1; irow <= SRC_MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 1; icol <= SRC_MODL->pmtr[ipmtr].ncol; icol++) {
                    NEW_MODL->pmtr[ipmtr].value[index] = SRC_MODL->pmtr[ipmtr].value[index];
                    NEW_MODL->pmtr[ipmtr].dot[  index] = SRC_MODL->pmtr[ipmtr].dot[  index];

                    if (SRC_MODL->pmtr[ipmtr].type == OCSM_DESPMTR) {
                        NEW_MODL->pmtr[ipmtr].lbnd[ index] = SRC_MODL->pmtr[ipmtr].lbnd[ index];
                        NEW_MODL->pmtr[ipmtr].ubnd[ index] = SRC_MODL->pmtr[ipmtr].ubnd[ index];
                    }

                    index++;
                }
            }
        }
        if (SRC_MODL->pmtr[ipmtr].str != NULL) {
            strcpy(NEW_MODL->pmtr[ipmtr].str, SRC_MODL->pmtr[ipmtr].str);
        }

        NEW_MODL->pmtr[ipmtr].mprop = SRC_MODL->pmtr[ipmtr].mprop;
    }

    /* copy the Branch table.  Note that this cannot be done with
       ocsmNewBrch since we do not want UDCs to make recursive calls
       to ocsmLoad */
    NEW_MODL->mbrch = SRC_MODL->mbrch;
    NEW_MODL->nbrch = SRC_MODL->nbrch;

    RALLOC(NEW_MODL->brch, brch_T, NEW_MODL->mbrch+1);

    for (ibrch = 1; ibrch <= SRC_MODL->nbrch; ibrch++) {
        NEW_MODL->brch[ibrch].name     = NULL;
        NEW_MODL->brch[ibrch].type     = SRC_MODL->brch[ibrch].type;
        NEW_MODL->brch[ibrch].bclass   = SRC_MODL->brch[ibrch].bclass;
        NEW_MODL->brch[ibrch].level    = SRC_MODL->brch[ibrch].level;
        NEW_MODL->brch[ibrch].indent   = SRC_MODL->brch[ibrch].indent;
        NEW_MODL->brch[ibrch].filename = NULL;
        NEW_MODL->brch[ibrch].linenum  = SRC_MODL->brch[ibrch].linenum;
        NEW_MODL->brch[ibrch].actv     = SRC_MODL->brch[ibrch].actv;
        NEW_MODL->brch[ibrch].dirty    = SRC_MODL->brch[ibrch].dirty;
        NEW_MODL->brch[ibrch].nattr    = 0;
        NEW_MODL->brch[ibrch].attr     = NULL;
        NEW_MODL->brch[ibrch].ileft    = SRC_MODL->brch[ibrch].ileft;
        NEW_MODL->brch[ibrch].irite    = SRC_MODL->brch[ibrch].irite;
        NEW_MODL->brch[ibrch].ichld    = SRC_MODL->brch[ibrch].ichld;
        NEW_MODL->brch[ibrch].nmprp    = 0;
        NEW_MODL->brch[ibrch].mprp     = NULL;
        NEW_MODL->brch[ibrch].narg     = SRC_MODL->brch[ibrch].narg;
        NEW_MODL->brch[ibrch].arg1     = NULL;
        NEW_MODL->brch[ibrch].arg2     = NULL;
        NEW_MODL->brch[ibrch].arg3     = NULL;
        NEW_MODL->brch[ibrch].arg4     = NULL;
        NEW_MODL->brch[ibrch].arg5     = NULL;
        NEW_MODL->brch[ibrch].arg6     = NULL;
        NEW_MODL->brch[ibrch].arg7     = NULL;
        NEW_MODL->brch[ibrch].arg8     = NULL;
        NEW_MODL->brch[ibrch].arg9     = NULL;

        MALLOC(NEW_MODL->brch[ibrch].name, char, 12);
        strcpy(NEW_MODL->brch[ibrch].name, SRC_MODL->brch[ibrch].name);

        MALLOC(NEW_MODL->brch[ibrch].filename, char, MAX_FILENAME_LEN);
        strcpy(NEW_MODL->brch[ibrch].filename, SRC_MODL->brch[ibrch].filename);

        if (SRC_MODL->brch[ibrch].arg1 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg1, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg1)+1);
            strcpy(NEW_MODL->brch[ibrch].arg1,                   SRC_MODL->brch[ibrch].arg1   );
        }

        if (SRC_MODL->brch[ibrch].arg2 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg2, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg2)+1);
            strcpy(NEW_MODL->brch[ibrch].arg2,                   SRC_MODL->brch[ibrch].arg2   );
        }

        if (SRC_MODL->brch[ibrch].arg3 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg3, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg3)+1);
            strcpy(NEW_MODL->brch[ibrch].arg3,                   SRC_MODL->brch[ibrch].arg3   );
        }

        if (SRC_MODL->brch[ibrch].arg4 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg4, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg4)+1);
            strcpy(NEW_MODL->brch[ibrch].arg4,                   SRC_MODL->brch[ibrch].arg4   );
        }

        if (SRC_MODL->brch[ibrch].arg5 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg5, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg5)+1);
            strcpy(NEW_MODL->brch[ibrch].arg5,                   SRC_MODL->brch[ibrch].arg5   );
        }

        if (SRC_MODL->brch[ibrch].arg6 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg6, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg6)+1);
            strcpy(NEW_MODL->brch[ibrch].arg6,                   SRC_MODL->brch[ibrch].arg6   );
        }

        if (SRC_MODL->brch[ibrch].arg7 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg7, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg7)+1);
            strcpy(NEW_MODL->brch[ibrch].arg7,                   SRC_MODL->brch[ibrch].arg7   );
        }

        if (SRC_MODL->brch[ibrch].arg8 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg8, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg8)+1);
            strcpy(NEW_MODL->brch[ibrch].arg8,                   SRC_MODL->brch[ibrch].arg8   );
        }

        if (SRC_MODL->brch[ibrch].arg9 != NULL) {
            MALLOC(NEW_MODL->brch[ibrch].arg9, char, (int)STRLEN(SRC_MODL->brch[ibrch].arg9)+1);
            strcpy(NEW_MODL->brch[ibrch].arg9,                   SRC_MODL->brch[ibrch].arg9   );
        }

        /* copy the Attributes */
        for (iattr = 0; iattr < SRC_MODL->brch[ibrch].nattr; iattr++) {
            if (SRC_MODL->brch[ibrch].attr[iattr].type != ATTRCSYS) {
                status = ocsmSetAttr(NEW_MODL, ibrch,
                                     SRC_MODL->brch[ibrch].attr[iattr].name,
                                     SRC_MODL->brch[ibrch].attr[iattr].defn);
            } else {
                status = ocsmSetCsys(NEW_MODL, ibrch,
                                     SRC_MODL->brch[ibrch].attr[iattr].name,
                                     SRC_MODL->brch[ibrch].attr[iattr].defn);
            }
        }
    }

    /* restore the sequence number */
    NEW_MODL->nextseq = SRC_MODL->nextseq;

    if (SRC_MODL->tmpDirNum < 0) {
        NEW_MODL->tmpDirNum = SRC_MODL->tmpDirNum;
    } else {
        snprintf(filename_src, MAX_FILENAME_LEN, "tmp_OpenCSM_%02d/00", SRC_MODL->tmpDirNum);

        /* find a directory for the new tmp_OpenCSM files */
        for (itmp = 0; itmp < 999; itmp++) {
            snprintf(filename_new, MAX_FILENAME_LEN, "tmp_OpenCSM_%02d/00", itmp);

            fp_new = fopen(filename_new, "r");
            if (fp_new != NULL) {
                fclose(fp_new);
                continue;
            }

            /* we found an unused directory, so make it now */
            snprintf(filename_new, MAX_FILENAME_LEN, "tmp_OpenCSM_%02d", itmp);
            if (MKDIR(filename_new) != 0) {
                SPRINT1(0, "ERROR:: could not make \"%s\"", filename_new);
                status = OCSM_FILE_NOT_FOUND;
                goto cleanup;
            }

            NEW_MODL->tmpDirNum = itmp;
            break;
        }

        if (NEW_MODL->tmpDirNum < 0) {
            SPRINT0(0, "ERROR:: could not find possible tmpdir");
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }

        /* change from using old tmp_OpenCSM files to new ones */
        for (itmp = 0; itmp < 999; itmp++) {

            /* try to copy the files (starting at 00) */
            snprintf(filename_src, MAX_FILENAME_LEN, "tmp_OpenCSM_%02d/%02d", SRC_MODL->tmpDirNum, itmp);
            fp_src = fopen(filename_src, "r");
            if (fp_src == NULL) break;

            snprintf(filename_new, MAX_FILENAME_LEN, "tmp_OpenCSM_%02d/%02d", NEW_MODL->tmpDirNum, itmp);
            fp_new = fopen(filename_new, "w");
            if (fp_new == NULL) {
                SPRINT1(0, "ERROR:: file \"%s\" could nt be created", filename_new);
                status = OCSM_FILE_NOT_FOUND;
                goto cleanup;
            }

            snprintf(filename_src, MAX_FILENAME_LEN, "$tmp_OpenCSM_%02d/%02d", SRC_MODL->tmpDirNum, itmp);
            snprintf(filename_new, MAX_FILENAME_LEN, "$tmp_OpenCSM_%02d/%02d", NEW_MODL->tmpDirNum, itmp);

            /* copy the file */
            while (1) {
                if (fgets(templine, MAX_LINE_LEN, fp_src) == NULL) break;
                fprintf(fp_new, "%s", templine);
            }
            fclose(fp_src);
            fclose(fp_new);

            /* change all mentions in UDPARG and UDPRIM Branches of old filename to new filename */
            for (ibrch = 1; ibrch <= SRC_MODL->nbrch; ibrch++) {
                if (SRC_MODL->brch[ibrch].type == OCSM_UDPARG ||
                    SRC_MODL->brch[ibrch].type == OCSM_UDPRIM   ) {

                    if (SRC_MODL->brch[ibrch].narg >= 3 && strcmp(SRC_MODL->brch[ibrch].arg3, filename_src) == 0) {
                        strcpy(NEW_MODL->brch[ibrch].arg3, filename_new);
                    }
                    if (SRC_MODL->brch[ibrch].narg >= 5 && strcmp(SRC_MODL->brch[ibrch].arg5, filename_src) == 0) {
                        strcpy(NEW_MODL->brch[ibrch].arg5, filename_new);
                    }
                    if (SRC_MODL->brch[ibrch].narg >= 7 && strcmp(SRC_MODL->brch[ibrch].arg7, filename_src) == 0) {
                        strcpy(NEW_MODL->brch[ibrch].arg7, filename_new);
                    }
                    if (SRC_MODL->brch[ibrch].narg >= 9 && strcmp(SRC_MODL->brch[ibrch].arg9, filename_src) == 0) {
                        strcpy(NEW_MODL->brch[ibrch].arg9, filename_new);
                    }
                }
            }
        }
    }

    /* do NOT copy the Body table */

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmFree - free all storage associated with a MODL                 *
 *                                                                      *
 ************************************************************************
 */

int
ocsmFree(
/*@null@*/void   *modl)                 /* (in)  pointer to MODL (or NULL) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       itmp, ibrch, iattr, iface, istor, ipmtr, ibody;
    char      tmpdirname[MAX_EXPR_LEN];

    ROUTINE(ocsmFree);

    /* --------------------------------------------------------------- */

    /* if modl is NULL, then we are cleaning up the udp cache */
    if (MODL == NULL) {

        /* clean the udp cache */
        udp_cleanupAll();

        goto cleanup;
    }

    /* check magic number */
    if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* clean up tmp files */
    if (MODL->tmpDirNum >= 0) {
        for (itmp = 0; itmp < 999; itmp++) {
            snprintf(tmpdirname, MAX_EXPR_LEN, "tmp_OpenCSM_%02d/%02d", MODL->tmpDirNum, itmp);
            if (remove(tmpdirname) != 0) {
                break;
            }
        }

        snprintf(tmpdirname, MAX_EXPR_LEN, "tmp_OpenCSM_%02d", MODL->tmpDirNum);
        if (rmdir(tmpdirname) == 0) {
            SPRINT1(1, "--> temporary directory \"%s\" removed", tmpdirname);
            MODL->tmpDirNum = -1;
        } else {
            SPRINT1(0, "ERROR:: could not remove \"%s\"\n", tmpdirname);
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* free up the Body table */
    for (ibody = 1; ibody <= MODL->mbody; ibody++) {
        if (MODL->body[ibody].etess != NULL) {
            status = EG_deleteObject(MODL->body[ibody].etess);
            if (status < EGADS_SUCCESS) {
                SPRINT1(0, "WARNING:: problem removing MODL->body[%d].etess", ibody);
            }
//$$$            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].etess = NULL;
        }

        if (MODL->body[ibody].eetess != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eetess);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].eetess = NULL;
        }

        if (MODL->body[ibody].eebody != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eebody);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].eebody = NULL;
        }

        ibrch = MODL->body[ibody].ibrch;
        if (ibrch > 0 && ibrch <= MODL->nbrch) {
            if (MODL->brch[ibrch].type == OCSM_UDPRIM) {
                status = udp_clean(&(MODL->brch[ibrch].arg1[1]), MODL->body[ibody].ebody);
                if (status == EGADS_NOTFOUND || status == EGADS_NOTMODEL) {
                    /* this means that some other Body probably cleaned up this udp
                       or that this is a user-defined component (udc) */
                } else {
                    CHECK_STATUS(udp_clean);
                }
            }
        }

        if (MODL->body[ibody].ebody != NULL) {
            /* ignore "dereference with active objects" message and/or any errors
               that may occur since this happens for Bodys that are restored */
            (void) EG_setOutLevel(MODL->context, 0);
            (void) EG_deleteObject(MODL->body[ibody].ebody);
            (void) EG_setOutLevel(MODL->context, outLevel);

            MODL->body[ibody].ebody = NULL;
        }

        status = removeVels(MODL, ibody);
        CHECK_STATUS(removeVels);

        if (MODL->body[ibody].face != NULL) {
            for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                if (MODL->body[ibody].face[iface].eggdata != NULL) {
                    status = MODL->eggFree(MODL->body[ibody].face[iface].eggdata);
                    CHECK_STATUS(eggFree);
                }
            }
        }

        status = freeBody(MODL, ibody);
        CHECK_STATUS(freeBody);
    }

    FREE(MODL->body);
    MODL->nbody = 0;

    /* free up the Parameter table */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        FREE(MODL->pmtr[ipmtr].name );
        FREE(MODL->pmtr[ipmtr].value);
        FREE(MODL->pmtr[ipmtr].dot  );
        FREE(MODL->pmtr[ipmtr].lbnd );
        FREE(MODL->pmtr[ipmtr].ubnd );
        FREE(MODL->pmtr[ipmtr].str  );
    }

    FREE(MODL->pmtr);
    MODL->npmtr = 0;

    /* free up the Branch table */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            FREE(MODL->brch[ibrch].attr[iattr].name);
            FREE(MODL->brch[ibrch].attr[iattr].defn);
        }

        FREE(MODL->brch[ibrch].name    );
        FREE(MODL->brch[ibrch].filename);
        FREE(MODL->brch[ibrch].attr    );
        FREE(MODL->brch[ibrch].mprp    );
        FREE(MODL->brch[ibrch].arg1    );
        FREE(MODL->brch[ibrch].arg2    );
        FREE(MODL->brch[ibrch].arg3    );
        FREE(MODL->brch[ibrch].arg4    );
        FREE(MODL->brch[ibrch].arg5    );
        FREE(MODL->brch[ibrch].arg6    );
        FREE(MODL->brch[ibrch].arg7    );
        FREE(MODL->brch[ibrch].arg8    );
        FREE(MODL->brch[ibrch].arg9    );
    }

    FREE(MODL->brch);
    MODL->nbrch = 0;

    /* free up the selection list */
    MODL->selsize = 0;
    FREE(MODL->sellist);

    /* free up the global Attributes */
    for (iattr = 0; iattr < MODL->nattr; iattr++) {
        FREE(MODL->attr[iattr].name);
        FREE(MODL->attr[iattr].defn);
    }

    FREE(MODL->attr);
    MODL->nattr = 0;

    /* free up the Storage table */
    for (istor = 0; istor < MODL->nstor; istor++) {
        FREE(MODL->stor[istor].ibody);
        FREE(MODL->stor[istor].ebody);
    }

    FREE(MODL->stor);
    MODL->nstor = 0;

    /* free up the inline file stream */
    FREE(MODL->sinline);

    /* free up the message buffer */
    FREE(MODL->sigMesg);

    /* free up the MODL structure */
    FREE(MODL);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmInfo - get info about a MODL                                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmInfo(void   *modl,                  /* (in)  pointer to MODL */
         int    *nbrch,                 /* (out) number of Branches */
         int    *npmtr,                 /* (out) number of Parameters */
         int    *nbody)                 /* (out) number of Bodys */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmInfo);

    /* --------------------------------------------------------------- */

    /* default return values */
    *nbrch = -1;
    *npmtr = -1;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* return values */
    *nbrch = MODL->nbrch;
    *npmtr = MODL->npmtr;
    *nbody = MODL->nbody;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmCheck - check that Branches are properly ordered               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmCheck(void   *modl)                 /* (in)  pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ibrch, ipass, indent;
    int       inest[MAX_NESTING], jnest[MAX_NESTING], knest, nnest, ifound;

    ROUTINE(ocsmCheck);

    /* --------------------------------------------------------------- */

    SPRINT0(1, "--> enter ocsmCheck()");

    /* initially there are no errors */
    ipass = 0;

    /* clear the signals */
    MODL->nwarn      = 0;
    MODL->sigCode    = 0;
    MODL->sigMesg[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        signalError(MODL, OCSM_NOT_MODL_STRUCTURE,
                    "MODL=NULL");
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        signalError(MODL, OCSM_NOT_MODL_STRUCTURE,
                    "bad magic number");
        goto cleanup;
    }

    /* if we have already checked, just return */
    if (MODL->checked == 1) {
        goto cleanup;
    }

    /* make sure Blocks of Branches are properly nested */
    nnest = 0;

    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        MODL->ibrch = ibrch;

        if        (MODL->brch[ibrch].type == OCSM_PATBEG) {
            if (nnest >= MAX_NESTING) {
                signalError(MODL, OCSM_NESTED_TOO_DEEPLY,
                            "can only be nested %d levels deep", MAX_NESTING);
                goto cleanup;
            }

            inest[nnest] = OCSM_PATBEG;
            jnest[nnest] = ibrch;
            nnest++;
        } else if (MODL->brch[ibrch].type == OCSM_PATBREAK) {
            ifound = 0;
            for (knest = nnest-1; knest >= 0; knest--) {
                if (inest[knest] == OCSM_PATBEG) {
                    ifound++;
                    break;
                }
            }

            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATBREAK without matching PATBEG");
                goto cleanup;
            } else if (ifound == 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATBREAK is improperly nested (follows \"%s\" on line %d)",
                            ocsmGetText(inest[nnest-1]), MODL->brch[jnest[nnest-1]].linenum);
                goto cleanup;
            }
        } else if (MODL->brch[ibrch].type == OCSM_PATEND) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATEND without matching PATBEG");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_PATBEG) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "PATEND is improperly nested (follows \"%s\" on line %d)",
                            ocsmGetText(inest[nnest-1]), MODL->brch[jnest[nnest-1]].linenum);
                goto cleanup;
            }

            nnest--;
        } else if (MODL->brch[ibrch].type == OCSM_IFTHEN) {
            if (nnest >= MAX_NESTING) {
                signalError(MODL, OCSM_NESTED_TOO_DEEPLY,
                            "can only be nested %d levels deep", MAX_NESTING);
                goto cleanup;
            }

            inest[nnest] = OCSM_IFTHEN;
            jnest[nnest] = ibrch;
            nnest++;
        } else if (MODL->brch[ibrch].type == OCSM_ELSEIF) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ELSEIF without matching IFTHEN");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_IFTHEN) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ELSEIF is improperly nested (follows \"%s\" on line %d)",
                            ocsmGetText(inest[nnest-1]),MODL->brch[jnest[nnest-1]].linenum);
                goto cleanup;
            }
        } else if (MODL->brch[ibrch].type == OCSM_ELSE) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ELSE without matching IFTHEN");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_IFTHEN) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ELSE is improperly nested (follows \"%s\" on line %d)",
                            ocsmGetText(inest[nnest-1]),MODL->brch[jnest[nnest-1]].linenum);
                goto cleanup;
            }

            inest[nnest-1] = OCSM_ELSE;
            jnest[nnest-1] = ibrch;
        } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ENDIF without matching IFTHEN");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_IFTHEN &&
                       inest[nnest-1] != OCSM_ELSE     ) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "ENDIF is improperly nested (follows \"%s\" on line %d)",
                            ocsmGetText(inest[nnest-1]),MODL->brch[jnest[nnest-1]].linenum);
                goto cleanup;
            }

            nnest--;
        } else if (MODL->brch[ibrch].type == OCSM_CATBEG) {
            if (nnest >= MAX_NESTING) {
                signalError(MODL, OCSM_NESTED_TOO_DEEPLY,
                            "can only be nested %d levels deep", MAX_NESTING);
                goto cleanup;
            }

            inest[nnest] = OCSM_CATBEG;
            jnest[nnest] = ibrch;
            nnest++;
        } else if (MODL->brch[ibrch].type == OCSM_CATEND) {
            if (nnest <= 0) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "CATEND without matching CATBEG");
                goto cleanup;
            } else if (inest[nnest-1] != OCSM_CATBEG) {
                signalError(MODL, OCSM_IMPROPER_NESTING,
                            "CATEND is improperly nested (follows \"%s\" on line %d)",
                            ocsmGetText(inest[nnest-1]), MODL->brch[jnest[nnest-1]].linenum);
                goto cleanup;
            }

            nnest--;
        }
    }

    if (nnest > 0) {
        signalError(MODL, OCSM_NESTING_NOT_CLOSED,
                    "%d block(s) are still open (last one is \"%s\" on line %d)",
                    nnest, ocsmGetText(inest[nnest-1]), MODL->brch[jnest[nnest-1]].linenum);
        goto cleanup;
    }

    /* initialize all indentation and parent/child relationships */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        MODL->brch[ibrch].indent = -1;
        MODL->brch[ibrch].ileft  = -2;
        MODL->brch[ibrch].irite  = -2;
        MODL->brch[ibrch].ichld  = -2;
    }

    /* set up the indentation */
    indent = 0;

    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {

        /* decrease indentation at the end of a block */
        if        (MODL->brch[ibrch].type == OCSM_MACEND   ||
                   MODL->brch[ibrch].type == OCSM_PATBREAK ||
                   MODL->brch[ibrch].type == OCSM_PATEND   ||
                   MODL->brch[ibrch].type == OCSM_ELSEIF   ||
                   MODL->brch[ibrch].type == OCSM_ELSE     ||
                   MODL->brch[ibrch].type == OCSM_ENDIF    ||
                   MODL->brch[ibrch].type == OCSM_CATEND   ||
                   MODL->brch[ibrch].type == OCSM_SKEND    ||
                   MODL->brch[ibrch].type == OCSM_SOLEND   ||
                   MODL->brch[ibrch].type == OCSM_END        ) {
            indent--;
        }

        if (indent < 0) {
            SPRINT0(1, "WARNING:: fixing indentation");
            (MODL->nwarn)++;
            indent = 0;
        }

        /* set the indentation */
        MODL->brch[ibrch].indent = indent;

        /* increase indentation at the beginning of a block */
        if        (MODL->brch[ibrch].type == OCSM_MACBEG   ||
                   MODL->brch[ibrch].type == OCSM_PATBEG   ||
                   MODL->brch[ibrch].type == OCSM_PATBREAK ||
                   MODL->brch[ibrch].type == OCSM_IFTHEN   ||
                   MODL->brch[ibrch].type == OCSM_ELSEIF   ||
                   MODL->brch[ibrch].type == OCSM_ELSE     ||
                   MODL->brch[ibrch].type == OCSM_CATBEG   ||
                   MODL->brch[ibrch].type == OCSM_SKBEG    ||
                   MODL->brch[ibrch].type == OCSM_SOLBEG     ) {
            indent++;
        } else if (MODL->brch[ibrch].type    == OCSM_UDPRIM &&
                   MODL->brch[ibrch].arg1[1] == '/'           ) {
            indent++;
        } else if (MODL->brch[ibrch].type    == OCSM_UDPRIM &&
                   MODL->brch[ibrch].arg1[1] == '$'         &&
                   MODL->brch[ibrch].arg1[2] == '/'           ) {
            indent++;
        } else if (MODL->brch[ibrch].type    == OCSM_UDPRIM &&
                   MODL->brch[ibrch].arg1[1] == '$'         &&
                   MODL->brch[ibrch].arg1[2] == '$'         &&
                   MODL->brch[ibrch].arg1[3] == '/'           ) {
            indent++;
        }
    }

    /* warn if improper nesting was found */
    if (indent == 1 && MODL->brch[MODL->nbrch].type != OCSM_END) {
        /* okay */
    } else if (indent != 0) {
        SPRINT1(1, "WARNING:: indent=%d, but should be 0", indent);
        (MODL->nwarn)++;
    }

    /* MODL has passed all checks */
    MODL->checked = 1;

cleanup:
    if (MODL->checked == 1) {
        SPRINT0(1, "--> checks passed");
    } else {
        SPRINT0(1, "--> checks failed");

        /* mark the Branch after the last one that passed as the Branch with the error */
        if (ipass < MODL->nbrch) {
            MODL->brch[ipass+1].ileft = -3;
        } else {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "");
        }
    }

    status = MODL->sigCode;

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmRegMesgCB - register callback function for exporting mesgs     *
 *                                                                      *
 ************************************************************************
 */

int
ocsmRegMesgCB(void   *modl,             /* (in)  pointer to MODL */
              void   (*callback)(char*))
                                        /* (in)  handle of callback function */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* store pointer to callback */
    MODL->mesgCB = callback;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmRegSizeCB - register callback function for DESPMTR size changes*
 *                                                                      *
 ************************************************************************
 */

int
ocsmRegSizeCB(void   *modl,             /* (in)  pointer to MODL */
              void   (*callback)(void*, int, int, int))
                                        /* (in)  handle of callback function */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* store pointer to callback */
    MODL->sizeCB = callback;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmBuild - build Bodys by executing the MODL up to a given Branch *
 *                                                                      *
 ************************************************************************
 */

int
ocsmBuild(void   *modl,                 /* (in)  pointer to MODL */
          int    buildTo,               /* (in)  last Branch to execute (or 0 for all, or -1 for no recycling) */
          int    *builtTo,              /* (out) last Branch executed successfully */
          int    *nbody,                /* (in)  number of entries allocated in body[] */
                                        /* (out) number of Bodys on the stack if body!=NULL*/
/*@null@*/int    body[])                /* (out) array  of Bodys on the stack (LIFO)
                                                 (at least *nbody long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    /* stack contains Body indices, Sketch indices (if negative), or 0 for MARKs */
    int       nstack, nstackSave, *stack=NULL, nbodySave;

    /* Sketch contains linsegs, cirarcs, splines, and beziers */
    sket_T    *sket=NULL;

    /* storage loaction information */
    int        imacro, *macros=NULL;

    /* pattern information */
    int        npatn, npatn_sig, bool1, bool2, bool3;
    patn_T     *patn=NULL;
    double     newValue;

    /* solver information */
    int        nsolvar, nsolcon;
    int        *solvars=NULL, *solcons=NULL;

    /* select/sort information */
    int        nobjs, ient, ipass, nswap, iswap;
    double     rswap, *props=NULL, bbox[6];
    ego        *eobjs;

    int        status2, ibrch, jbrch, type, ibrchl, i, j, iface, iedge, iloop, inode, nbodyMax;
    int        nloops, nedges;
    int        iattr, ipmtr, jpmtr, istor, jstor, kstor, icount, nmacro, jstack, verify, icatch;
    int        ibody, jbody, jface, ibodyl, irow, nrow, icol, ncol, indx, itype, nlist, ilist, jlist;
    int        *iblist=NULL, nblist, iseq, ileft, irite, attrType, attrLen, nefaces;
    varg_T     args[10];
    double     dihedral, toler, value, dot, *values=NULL, *dots=NULL;
    char       pname[MAX_EXPR_LEN], pmtrName[MAX_EXPR_LEN], thisArg[MAX_LINE_LEN], str[MAX_STRVAL_LEN], temp[MAX_STRVAL_LEN];
    ego        *eloops, *eedges;

    CINT       *tempIlist;
    CDOUBLE    *tempRlist;
    CCHAR      *tempClist, *aname;

    int        imajor, iminor, iarg, ival, hasdots, istack, igroup, ngroup, nattr, nego1, nego2;
    int        ibest, npnt, ipnt, ntri, itri, AT_iedge, AT_iface, AT_xcg, AT_ycg, AT_zcg;
    int        match1, match2, match3, periodic, iter, oclass, mtype, nchild, *senses;
    int        udp_num, *udp_types, *udp_idef, iflag;
    CINT       *ptype, *pindx, *tris, *tric;
    double     tbest, xbest, ybest, zbest, dbest, dtest;
    double     u0, v0, x0, y0, z0, u1, v1, x1, y1, z1, u2, v2, x2, y2, z2, s0, s1, tt, mat[9], rhs[3], res[3], sval[3], s0s1tt[3];
    double     xyz_[3], uv_[3], data[18], uvrange[4], duvt[3], dmin, *udp_ddef;
    CDOUBLE    *xyz, *uv;
    char       dumpfile[MAX_EXPR_LEN], *extension, **udp_names;

    CCHAR      *OC_ver;
    FILE       *fp;
    ego        ebodyl, ebody, emodel, *etemp=NULL, enode, eedge, eface, eobj, eref, *echilds;
    clock_t    old_time, new_time;

    ROUTINE(ocsmBuild);

#define CATCH_STATUS(X)                                                 \
    if (status < SUCCESS) {                                             \
        MODL->sigCode = status;                                         \
        printf( "ERROR:: build terminated early due to BAD STATUS = %d (%s) from %s (called from %s:%d)\n", status, ocsmGetText(status), #X, routine, __LINE__); \
        goto finalize;                                                  \
    }

    /* --------------------------------------------------------------- */

#if PRINT_CALLHISTORY > 0
    fp_callHistory = fopen("callHistory", "w");
    indent_callHistory = 0;
#endif

    SPRINT1(1, "--> enter ocsmBuild(buildTo=%d)", buildTo);

    for (iarg = 1; iarg < 10; iarg++) {
        args[iarg].val = NULL;
        args[iarg].dot = NULL;
    }

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    MODL->cleanup = 25;

    /* clear the signals */
    MODL->nwarn      = 0;
    MODL->sigCode    = 0;
    MODL->sigMesg[0] = '\0';

    MODL->ibrch      = 0;

    MALLOC(stack,   int,    MAX_STACK_SIZE);
    MALLOC(macros,  int,    MAX_NUM_MACROS+1);
    MALLOC(patn,    patn_T, MAX_NESTING);
    MALLOC(sket,    sket_T, 1);
    MALLOC(solvars, int,    MAX_SOLVER_SIZE);
    MALLOC(solcons, int,    MAX_SOLVER_SIZE);

    *builtTo = 0;
    nbodyMax = *nbody;

    /* reset the profile info */
    for (i = 0; i < 101; i++) {
        MODL->profile[i].ncall = 0;
        MODL->profile[i].time  = 0;
    }

    /* if MODL is not checked already, do it now (since checking a MODL
       has side-effects that are needed during build process) */
    if (MODL->checked != 1) {
        status = ocsmCheck(MODL);
        CHECK_STATUS(ocsmCheck);
    }

    /* defer all active Branches within macro definitions */
    nmacro = 0;
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        if (MODL->brch[ibrch].actv == OCSM_ACTIVE && nmacro > 0) {
            MODL->brch[ibrch].actv = OCSM_DEFERRED;
        }
        if        (MODL->brch[ibrch].type == OCSM_MACBEG) {
            nmacro++;
        } else if (MODL->brch[ibrch].type == OCSM_MACEND) {
            nmacro--;
        }
    }

    /* initialize all parent/child flags for Branches */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        MODL->brch[ibrch].ileft = -2;
        MODL->brch[ibrch].irite = -2;
        MODL->brch[ibrch].ichld = -2;
    }

    EG_revision(&imajor, &iminor, &OC_ver);
    if (strstr(OC_ver, "Interim") == NULL) {
        SPRINT3(1, "\n    EGADS version %2d.%02d (with %s)\n", imajor, iminor, &(OC_ver[5]));
    } else {
        SPRINT3(1, "\n    Interim EGADS version %2d.%02d (with %s)\n", imajor, iminor, &(OC_ver)[20]);
    }

    /* create a new EGADS context (if not already set) */
    if (MODL->context == NULL) {
        status = EG_open(&(MODL->context));
        CHECK_STATUS(EG_open);
    }

    /* update the thread used by EGADS */
    status = EG_updateThread(MODL->context);
    CHECK_STATUS(EG_updateThread);

    status = EG_setOutLevel(MODL->context, outLevel);
    CHECK_STATUS(EG_setOutLevel);

    /* store the MODL pointer in the context */
    status = EG_setUserPointer(MODL->context, (void*)MODL);
    CHECK_STATUS(EG_setUserPointer);

    /* set the global level */
    MODL->level = 0;
    MODL->scope[MODL->level] = 0;

    /* reset the number of Groups */
    MODL->ngroup = 0;

    /* reset the last Body loaded from a Body_*.egads file */
    MODL->bodyLoaded = 0;

    /* reset the storage */
    for (istor = 0; istor < MODL->nstor; istor++) {
        FREE(MODL->stor[istor].ibody);
        FREE(MODL->stor[istor].ebody);
    }
    FREE(MODL->stor);
    MODL->nstor = 0;

    /* remove internal Parameters that may be left over from a failure
          in a Sketch that was being solved */
    status = delPmtrByName(MODL, "::d");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::z");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::y");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::x");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    /* errors if any DESPMTR Parameters are out of bounds.  this can
       only happen based upon values in the .csm file */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type != OCSM_DESPMTR) continue;

        indx = 0;
        for (irow = 0; irow < MODL->pmtr[ipmtr].nrow; irow++) {
            for (icol = 0; icol < MODL->pmtr[ipmtr].ncol; icol++) {
                if (MODL->pmtr[ipmtr].value[indx] < MODL->pmtr[ipmtr].lbnd[indx]) {
                    status = OCSM_ILLEGAL_VALUE;
                    signalError(MODL, status,
                                "value of %s (%f) is lower  than lower bound (%f)",
                                MODL->pmtr[ipmtr].name,
                                MODL->pmtr[ipmtr].value[indx],
                                MODL->pmtr[ipmtr].lbnd[ indx]);
                    *builtTo = -99999;
                    SET_STATUS(status, despmtr);
                }

                if (MODL->pmtr[ipmtr].value[indx] > MODL->pmtr[ipmtr].ubnd[indx]) {
                    status = OCSM_ILLEGAL_VALUE;
                    signalError(MODL, status,
                                "value of %s (%f) is higher than upper bound (%f)",
                                MODL->pmtr[ipmtr].name,
                                MODL->pmtr[ipmtr].value[indx],
                                MODL->pmtr[ipmtr].ubnd[ indx]);
                    *builtTo = -99999;
                    SET_STATUS(status, despmtr);
                }

                indx++;
            }
        }
    }

    /* count number of non-zero dots associated with DESPMTRs */
    MODL->numdots = 0;
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  != OCSM_DESPMTR) continue;

        indx = 0;
        for (irow = 0; irow < MODL->pmtr[ipmtr].nrow; irow++) {
            for (icol = 0; icol < MODL->pmtr[ipmtr].ncol; icol++) {
                if (MODL->pmtr[ipmtr].dot[indx] != 0) {
                    (MODL->numdots)++;
                }

                indx++;
            }
        }
    }

    /* reinitailize values of all OUTPMTR Parameters */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  != OCSM_OUTPMTR) continue;

        if (MODL->pmtr[ipmtr].str != NULL) {
            MODL->pmtr[ipmtr].str[0] = '\0';
        } else {
            indx = 0;
            for (irow = 0; irow < MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 0; icol < MODL->pmtr[ipmtr].ncol; icol++) {
                    MODL->pmtr[ipmtr].value[indx] = -HUGEQ;
                    indx++;
                }
            }
        }
    }

    /* convert any internal Parameters (other than @edata and @stack) that are a matrix or
       has a string value into a scalar (so that rebuilding will start with
       exactly the same assumptions as the first build) */
    for (ipmtr = MODL->npmtr; ipmtr > 0; ipmtr--) {
        if (MODL->pmtr[ipmtr].type != OCSM_LOCALVAR &&
            MODL->pmtr[ipmtr].type != OCSM_OUTPMTR    ) continue;

        if (strcmp(MODL->pmtr[ipmtr].name, "@edata") == 0 ||
            strcmp(MODL->pmtr[ipmtr].name, "@stack") == 0   ) continue;

        if        (MODL->pmtr[ipmtr].nrow >  1 || MODL->pmtr[ipmtr].ncol >  1) {
            if (strcmp(MODL->pmtr[ipmtr].name, "@sellist") != 0) {
                SPRINT1(2, "INFO:: %s is a vector and is being converted to scalar", MODL->pmtr[ipmtr].name);
            }
            MODL->pmtr[ipmtr].nrow = 1;
            MODL->pmtr[ipmtr].ncol = 1;
        } else if (MODL->pmtr[ipmtr].nrow == 0 || MODL->pmtr[ipmtr].ncol == 0) {
            SPRINT1(2, "INFO:: %s is a string and is being converted to scalar", MODL->pmtr[ipmtr].name);
            FREE(MODL->pmtr[ipmtr].str);

            MALLOC(MODL->pmtr[ipmtr].value, double, 1);
            MALLOC(MODL->pmtr[ipmtr].dot,   double, 1);

            MODL->pmtr[ipmtr].value[0] = -HUGEQ;
            MODL->pmtr[ipmtr].dot[  0] = 0;

            if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR ||
                MODL->pmtr[ipmtr].type == OCSM_CFGPMTR   ) {
                MALLOC(MODL->pmtr[ipmtr].lbnd,  double, 1);
                MALLOC(MODL->pmtr[ipmtr].ubnd,  double, 1);

                MODL->pmtr[ipmtr].lbnd[ 0] = -HUGEQ;
                MODL->pmtr[ipmtr].ubnd[ 0] = +HUGEQ;
            }

            MODL->pmtr[ipmtr].nrow = 1;
            MODL->pmtr[ipmtr].ncol = 1;
        }
    }

    /* initialize the hasdots flag for all Bodys */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        MODL->body[ibody].hasdots = 0;
        MODL->body[ibody].hasdxyz = 0;
    }

    /* remove any EBodys that might exist */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        if (MODL->body[ibody].eetess != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eetess);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].eetess = NULL;
        }

        if (MODL->body[ibody].eebody != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eebody);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].eebody = NULL;
        }
    }

    /* reset the loadEgads flag */
    MODL->loadEgads = abs(MODL->loadEgads);

    /* if buildTo was set to -1, mark all Branches as being dirty */
    if (buildTo == -1) {
        for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
            MODL->brch[ibrch].dirty = 1;
        }

        buildTo = 0;
    }

    /* find the first Body that has to be regenerated, because its
       Branch is dirty */
    MODL->recycle = 0;
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        ibrch = MODL->body[ibody].ibrch;
        if (MODL->nbrch == 0 || ibrch == 0 || ibrch > MODL->nbrch || MODL->brch[ibrch].dirty > 0) {

            /* free up all Bodys starting at ibody */
            for (jbody = ibody; jbody <= MODL->nbody; jbody++) {

                status = removeVels(MODL, jbody);
                CHECK_STATUS(removeVels);

                for (jface = 1; jface <= MODL->body[jbody].nface; jface++) {
                    if (MODL->body[jbody].face[jface].eggdata != NULL) {
                        status = MODL->eggFree(MODL->body[jbody].face[jface].eggdata);
                        CHECK_STATUS(eggFree);
                    }
                }

                status = freeBody(MODL, jbody);
                CHECK_STATUS(freeBody);

                if (MODL->body[jbody].etess != NULL) {
                    status = EG_deleteObject(MODL->body[jbody].etess);
                    CHECK_STATUS(EG_deleteObject);

                    MODL->body[jbody].etess = NULL;
                }

                if (MODL->body[jbody].eetess != NULL) {
                    status = EG_deleteObject(MODL->body[jbody].eetess);
                    CHECK_STATUS(EG_deleteObject);

                    MODL->body[jbody].eetess = NULL;
                }

                if (MODL->body[jbody].eebody != NULL) {
                    status = EG_deleteObject(MODL->body[jbody].eebody);
                    CHECK_STATUS(EG_deleteObject);

                    MODL->body[jbody].eebody = NULL;
                }

                if (MODL->body[jbody].ebody != NULL) {
                    if (ibrch > 0 && ibrch <= MODL->nbrch) {
                        if (MODL->brch[ibrch].type == OCSM_UDPRIM) {
                            status = udp_clean(&(MODL->brch[ibrch].arg1[1]), MODL->body[jbody].ebody);
                            if (status == EGADS_NOTFOUND || status == EGADS_NOTMODEL) {
                                /* this means that some other Body probably cleaned up this udp
                                   or that this is a user-defined component (udc) */
                            } else {
                                CHECK_STATUS(udp_clean);
                            }
                        }
                    }

                    status = EG_deleteObject(MODL->body[jbody].ebody);
                    if (status == EGADS_EMPTY) status = SUCCESS;
                    CHECK_STATUS(EG_deleteObject);

                    MODL->body[jbody].ebody = NULL;
                }
            }

            /* remove any .ichld pointers to any Bodys at
               ibody or beyond */
            for (jbody = 1; jbody <= MODL->nbody; jbody++) {
                if (MODL->body[jbody].ichld >= ibody) {
                    MODL->body[jbody].ichld = 0;
                }
            }

            break;
        }
        MODL->recycle = ibody;
    }
    MODL->nbody = 0;

    /* any Body after ibody should be freed */
    for (jbody = MODL->recycle+1; jbody <= MODL->mbody; jbody++) {
        status = freeBody(MODL, jbody);
        CHECK_STATUS(freeBody);
    }

    /* initialize the stack */
    nstack = 0;

    /* initialize the number of active Sketch points (and constraints) */
    sket->type   = 0;
    sket->size   = 0;
    sket->solved = 1;
    sket->signal = 0;
    sket->nseg   = 0;
    sket->nvar   = 0;
    sket->ncon   = 0;

    /* initiailze the number of nested patterns and the number of
       patterns when a signal was detected */
    npatn     = 0;
    npatn_sig = -1;

    /* initialize the number of solver constraints */
    nsolvar = 0;
    nsolcon = 0;

    /* initialize the storage locations */
    for (imacro = 1; imacro <= MAX_NUM_MACROS; imacro++) {
        macros[imacro] = -1;
    }

    /* initialize the arguments */
    for (iarg = 1; iarg < 10; iarg++) {
        args[iarg].nval = -1;
        args[iarg].nrow =  0;
        args[iarg].ncol =  0;
        args[iarg].val  = NULL;
        args[iarg].dot  = NULL;
    }

    /* if buildTo was set to zero, reset it (locally) to be greater
       then MODL->nbrch */
    if (buildTo == 0) {
        buildTo = MODL->nbrch + 1;
    }

    /* initially we do not need finite differences and we have not
       yet calculated the mass properties */
    MODL->needFDs = FORCE_FINITE_DIFFS;
    MODL->hasMPs  = 0;

    /* set up the at-Parameters (so that @version gets set) */
    status = setupAtPmtrs(MODL, 0);
    CHECK_STATUS(setupAtPmtrs);

    /* loop through and process all the Branches (up to buildTo) */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        nstackSave = nstack;
        nbodySave  = MODL->nbody;

        type = MODL->brch[ibrch].type;

        MODL->ibrch = ibrch;

        /* exit if we exceeded buildTo */
        if (ibrch > buildTo) {
            break;
        }

        /* if Branch is deferred, mark it as active but skip it for now */
        if (MODL->brch[ibrch].actv == OCSM_DEFERRED) {
            MODL->brch[ibrch].actv =  OCSM_ACTIVE;
            SPRINT1(1, "    deferring [%4d]:", ibrch);
            continue;
        }

        /* skip this Branch if it is not active */
        if (MODL->brch[ibrch].actv != OCSM_ACTIVE) {
            SPRINT1(1, "    skipping  [%4d]:", ibrch);
            continue;
        }

        /* if there is an uncaught signal, determine what to do with
           it.  note: checking if CATBEG matches the signal is done during
           the execution of the CATBEG */
        if (MODL->sigCode != 0) {

            /* if this is the first time we have seen the signal, remember the
               number of entries in the pattern table */
            if (npatn_sig == -1) {
                npatn_sig = npatn;
            }

            /* if this is the beginning of a block, add it to the pattern list */
            if        (type == OCSM_PATBEG ||
                       type == OCSM_IFTHEN ||
                       type == OCSM_RECALL   ) {
                if (npatn < MAX_NESTING) {
                    patn[npatn].itype = type;
                    patn[npatn].ibeg  = ibrch;
                    npatn++;
                    continue;
                } else {
                    status = OCSM_NESTED_TOO_DEEPLY;
                    signalError(MODL, status,
                                "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                    SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
                }

            /* if this is the beginning of a UDC, add it to the pattern list (and
               increment the level) */
            } else if (type == OCSM_UDPRIM) {
                if ((MODL->brch[ibrch].arg1[1] >= 'a' && MODL->brch[ibrch].arg1[1] <= 'z') ||
                    (MODL->brch[ibrch].arg1[1] >= 'A' && MODL->brch[ibrch].arg1[1] <= 'Z')   ) {
                    continue;
                } else if (npatn < MAX_NESTING) {
                    patn[npatn].itype = type;
                    patn[npatn].ibeg  = ibrch;
                    npatn++;

                    (MODL->level)++;
                    continue;
                } else {
                    status = OCSM_NESTED_TOO_DEEPLY;
                    signalError(MODL, status,
                                "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                    SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
                }

            /* if this is the end of a UDC, remove it and the variables at the
               local scope from the pattern list */
            } else if (type == OCSM_END) {
                if (MODL->level > 0 && MODL->scope[MODL->level] > MODL->scope[MODL->level-1]) {
                    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                        if (MODL->pmtr[ipmtr].scope >= MODL->scope[MODL->level]) {
                            FREE(MODL->pmtr[ipmtr].name );
                            FREE(MODL->pmtr[ipmtr].value);
                            FREE(MODL->pmtr[ipmtr].dot  );
                            FREE(MODL->pmtr[ipmtr].lbnd );
                            FREE(MODL->pmtr[ipmtr].ubnd );
                            FREE(MODL->pmtr[ipmtr].str  );

                            for (jpmtr = ipmtr+1; jpmtr <= MODL->npmtr; jpmtr++) {

                                /* copy jpmtr over jpmtr-1 */
                                MODL->pmtr[jpmtr-1].name  = MODL->pmtr[jpmtr].name;
                                MODL->pmtr[jpmtr-1].type  = MODL->pmtr[jpmtr].type;
                                MODL->pmtr[jpmtr-1].scope = MODL->pmtr[jpmtr].scope;
                                MODL->pmtr[jpmtr-1].mprop = MODL->pmtr[jpmtr].mprop;
                                MODL->pmtr[jpmtr-1].nrow  = MODL->pmtr[jpmtr].nrow;
                                MODL->pmtr[jpmtr-1].ncol  = MODL->pmtr[jpmtr].ncol;
                                MODL->pmtr[jpmtr-1].value = MODL->pmtr[jpmtr].value;
                                MODL->pmtr[jpmtr-1].dot   = MODL->pmtr[jpmtr].dot;
                                MODL->pmtr[jpmtr-1].lbnd  = MODL->pmtr[jpmtr].lbnd;
                                MODL->pmtr[jpmtr-1].ubnd  = MODL->pmtr[jpmtr].ubnd;
                                MODL->pmtr[jpmtr-1].str   = MODL->pmtr[jpmtr].str;
                            }

                            ipmtr--;            /* revisit imptr in next trip through loop */

                            MODL->pmtr[MODL->npmtr].name  = NULL;
                            MODL->pmtr[MODL->npmtr].value = NULL;
                            MODL->pmtr[MODL->npmtr].dot   = NULL;
                            MODL->pmtr[MODL->npmtr].lbnd  = NULL;
                            MODL->pmtr[MODL->npmtr].ubnd  = NULL;
                            MODL->pmtr[MODL->npmtr].str   = NULL;
                            (MODL->npmtr)--;
                        }
                    }
                }

                /* decrement the level */
                (MODL->level)--;

                npatn--;
                npatn_sig = MIN(npatn_sig, npatn);
                continue;

            /* if this is the end of a block, remove it from the pattern list */
            } else if (type == OCSM_PATEND ||
                       type == OCSM_ENDIF  ||
                       type == OCSM_MACEND   ) {
                npatn--;
                npatn_sig = MIN(npatn_sig, npatn);
                continue;

            /* if this is a CATBEG but we are in a block that was entered
               after the signal was created, skip the CATBEG */
            } else if (type == OCSM_CATBEG && npatn > npatn_sig) {
                continue;

            /* otherwise if this is not a CATBEG, go to the next Branch */
            } else if (type != OCSM_CATBEG) {
                continue;
            }
        }

        /* if this is an executable Sketch statement and we need
           to solve the Sketch, do it before interpreting the
           arguments and velocities */
        if (type == OCSM_LINSEG || type == OCSM_CIRARC ||
            type == OCSM_ARC    || type == OCSM_SPLINE ||
            type == OCSM_SSLOPE || type == OCSM_BEZIER   ) {
            status = solveSketch(MODL, sket);

            if (status == OCSM_UNDERCONSTRAINED ||
                status == OCSM_OVERCONSTRAINED  ||
                status == OCSM_NOT_CONVERGED      ) {
                sket->signal = status;
                status = SUCCESS;
            } else {
                CATCH_STATUS(solveSketch);
            }
        }

        SPRINT1x(3, "----------%s", ocsmGetText(type));
        if (MODL->brch[ibrch].narg >= 1) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg1);}
        if (MODL->brch[ibrch].narg >= 2) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg2);}
        if (MODL->brch[ibrch].narg >= 3) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg3);}
        if (MODL->brch[ibrch].narg >= 4) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg4);}
        if (MODL->brch[ibrch].narg >= 5) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg5);}
        if (MODL->brch[ibrch].narg >= 6) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg6);}
        if (MODL->brch[ibrch].narg >= 7) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg7);}
        if (MODL->brch[ibrch].narg >= 8) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg8);}
        if (MODL->brch[ibrch].narg >= 9) {SPRINT1x(3, "  %s", MODL->brch[ibrch].arg9);}
        SPRINT0(3, "----------");

        /* get the values for the arguments and velocities */
        for (iarg = 1; iarg < 10; iarg++) {
            args[iarg].nval = -1;
            args[iarg].nrow =  0;
            args[iarg].ncol =  0;

            if (iarg > MODL->brch[ibrch].narg) continue;

                                  thisArg[0] = '\0';
            if (iarg == 1) strcpy(thisArg, MODL->brch[ibrch].arg1);
            if (iarg == 2) strcpy(thisArg, MODL->brch[ibrch].arg2);
            if (iarg == 3) strcpy(thisArg, MODL->brch[ibrch].arg3);
            if (iarg == 4) strcpy(thisArg, MODL->brch[ibrch].arg4);
            if (iarg == 5) strcpy(thisArg, MODL->brch[ibrch].arg5);
            if (iarg == 6) strcpy(thisArg, MODL->brch[ibrch].arg6);
            if (iarg == 7) strcpy(thisArg, MODL->brch[ibrch].arg7);
            if (iarg == 8) strcpy(thisArg, MODL->brch[ibrch].arg8);
            if (iarg == 9) strcpy(thisArg, MODL->brch[ibrch].arg9);

            if        (iarg == 1 && type == OCSM_SET) {      // allows comma in a[1,2]
                STRNCPY(str, &(thisArg[1]), MAX_STRVAL_LEN);
            } else if (iarg == 4 && type == OCSM_SKCON) {    // delays parse of constraint
                STRNCPY(str, &(thisArg[1]), MAX_STRVAL_LEN);
            } else if (iarg == 1 && type == OCSM_SOLCON) {   // delays parse of constraint
                STRNCPY(str, &(thisArg[1]), MAX_STRVAL_LEN);
            } else if (iarg >  4 && type == OCSM_IFTHEN) {   // allows for lazy evaluations
                break;
            } else if (iarg >  4 && type == OCSM_ELSEIF) {   // allows for lazy evaluations
                break;
            } else {
                status = str2vals(thisArg, MODL, &(args[iarg].nrow), &(args[iarg].ncol), &values, &dots, str);

                if (status < SUCCESS) {
                    SPRINT4(0, "ERROR:: problem evaluating argument %d (%s) for Branch %d (%s)",
                           iarg, thisArg, ibrch, ocsmGetText(MODL->brch[ibrch].type));
                    FREE(values);
                    FREE(dots  );
                    goto next_branch;
                }
            }

            if (STRLEN(str) > 0) {
                FREE(args[iarg].str);
                MALLOC(args[iarg].str, char, MAX_STRVAL_LEN);

                args[iarg].nval = 0;
                STRNCPY(args[iarg].str, str, MAX_STRVAL_LEN);
            } else {
                args[iarg].nval = (args[iarg].nrow) * (args[iarg].ncol);

                FREE(  args[iarg].val);   /* also free's .str since they are unioned */
                MALLOC(args[iarg].val, double, args[iarg].nval);

                FREE(  args[iarg].dot);
                MALLOC(args[iarg].dot, double, args[iarg].nval);

                SPLINT_CHECK_FOR_NULL(values);
                SPLINT_CHECK_FOR_NULL(dots  );

                for (i = 0; i < args[iarg].nval; i++) {
                    args[iarg].val[i] = values[i];
                    args[iarg].dot[i] = dots[  i];
                }
            }

            FREE(values);
            FREE(dots  );
        }

        /* if this is a UDPARG or UDPRIM statment for a UDF or UDF and if it
           has an ATTRINT or ATTRREAL argument that has dots, we will need to
           compute sensitivities via finite differences */
        if (MODL->needFDs == 0 && (type == OCSM_UDPARG || type == OCSM_UDPRIM)) {
            if ((args[1].str[0] >= 'A' && args[1].str[0] <= 'Z') ||
                (args[1].str[0] >= 'a' && args[1].str[0] <= 'z')   ) {

                status = udp_initialize(args[1].str, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
                if (status == EGADS_NOLOAD) {
                    status = EGADS_SUCCESS;
                } else if (status == EGADS_NULLOBJ) {
                    status = OCSM_UDP_ERROR1;
                    signalError(MODL, status,
                                "UDP/UDF \"%s\" could not be loaded", args[1].str);
                    goto cleanup;
                }
                CHECK_STATUS(udp_initialize);

                for (iarg = 2; iarg < MODL->brch[ibrch].narg; iarg+=2) {

                    /* set iflag is the argument has any non-zero dots */
                    iflag = 0;
                    for (i = 0; i < args[iarg+1].nval; i++) {
                        if (fabs(args[iarg+1].dot[i]) > EPS12) {
                            iflag++;
                        }
                    }
                    if (iflag == 0) continue;

                    /* see if the corresponding UDP argument is an ATTRINT or ATTRREAL */
                    for (i = 0; i < udp_num; i++) {
                        if (strcasecmp(args[iarg].str, udp_names[i]) == 0) {
                            if (udp_types[i] == ATTRINT || udp_types[i] == ATTRREAL) {
                                SPRINT1(1, "--> finite differences will be used because \"%s\" has non-zero dots", args[iarg].str);
                                MODL->needFDs = 1;
                                break;
                            }
                        }
                    }
                }
            }
        }

        /* make sure that there is enough room on the stack */
        if (nstack >= MAX_STACK_SIZE-1) {
            status = OCSM_TOO_MANY_BODYS_ON_STACK;
            goto cleanup;
        }

        MODL->brch[ibrch].ileft = -1;
        MODL->brch[ibrch].irite = -1;
        MODL->brch[ibrch].ichld = -1;

        /* execute Branch ibrch */
        old_time = clock();

        if        (MODL->brch[ibrch].bclass == OCSM_PRIMITIVE) {
            status = buildPrimitive(MODL, ibrch, args, &nstack, stack, npatn, patn);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildPrimitive);

            if ( MODL->brch[ibrch].type == OCSM_UDPRIM) {
                if (MODL->brch[ibrch].arg1[1] == '/' ||
                    MODL->brch[ibrch].arg1[1] == '$'   ) {
                    if (npatn < MAX_NESTING) {
                        patn[npatn].itype = OCSM_UDPRIM;
                        patn[npatn].ibeg  = ibrch;
                        npatn++;
                    } else {
                        status = OCSM_NESTED_TOO_DEEPLY;
                        signalError(MODL, status,
                                    "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                        SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
                    }
                }
            }
        } else if (MODL->brch[ibrch].bclass == OCSM_GROWN) {
            status = buildGrown(MODL, ibrch, args, &nstack, stack, npatn, patn);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildGrown);
        } else if (MODL->brch[ibrch].bclass == OCSM_APPLIED) {
            status = buildApplied(MODL, ibrch, args, &nstack, stack, npatn, patn);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildApplied);
        } else if (MODL->brch[ibrch].bclass == OCSM_BOOLEAN) {
            status = buildBoolean(MODL, ibrch, args, &nstack, stack, npatn, patn);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildBoolean);
        } else if (MODL->brch[ibrch].bclass == OCSM_TRANSFORM) {
            status = buildTransform(MODL, ibrch, args, &nstack, stack);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildTransform);
        } else if (MODL->brch[ibrch].bclass == OCSM_SKETCH) {
            status = buildSketch(MODL, ibrch, args, &nstack, stack, npatn, patn, sket);
            if (MODL->sigCode == OCSM_UNDERCONSTRAINED ||
                MODL->sigCode == OCSM_OVERCONSTRAINED  ||
                MODL->sigCode == OCSM_NOT_CONVERGED      ) {
                // do nothing
            } else if (MODL->sigCode != SUCCESS) {
                goto next_branch;
            }
//            CATCH_STATUS(buildSketch);

            if (MODL->brch[ibrch].type != OCSM_SKBEG &&
                MODL->brch[ibrch].type != OCSM_SKVAR &&
                MODL->brch[ibrch].type != OCSM_SKCON   ) {
                MODL->brch[ibrch  ].ileft = ibrch - 1;
                MODL->brch[ibrch-1].ichld = ibrch;
            }
        } else if (MODL->brch[ibrch].bclass == OCSM_SOLVER) {
            status = buildSolver(MODL, ibrch, args, &nsolvar, solvars, &nsolcon, solcons);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(buildSolver);

        /* execute: "dimension $pmtrName nrow ncol" */
        } else if (type == OCSM_DIMENSION) {
            SPRINT4(1, "    executing [%4d] dimension:     %s  %11.5f  %11.5f",
                    ibrch, args[1].str, args[2].val[0], args[3].val[0]);

            status = ocsmNewPmtr(MODL, args[1].str, OCSM_UNKNOWN,
                                 NINT(args[2].val[0]), NINT(args[3].val[0]));
            CHECK_STATUS(ocsmNewPmtr);

        /* execute: "set $pmtrName exprs" */
        } else if (type == OCSM_SET) {
            SPRINT3(1, "    executing [%4d] set:            %s  %s",
                    ibrch, args[1].str, MODL->brch[ibrch].arg2);

            /* if $pmtrName is an implicit string, evaluate it */
            if (args[1].str[0] != '!') {
                STRNCPY(pname, args[1].str, MAX_EXPR_LEN);
            } else {
                status = str2val(args[1].str, MODL, &value, &dot, pname);
                if (MODL->sigCode != SUCCESS) goto next_branch;
                CHECK_STATUS(str2val);
            }

            /* break pname into pmtrName[irow,icol] */
            status = parseName(MODL, pname, pmtrName, &jpmtr, &irow, &icol);
            CATCH_STATUS(parseName);

            /* if it does not exist, create it now */
            if (jpmtr == 0) {
                status = ocsmNewPmtr(MODL, pmtrName, OCSM_LOCALVAR, 1, 1);
                CHECK_STATUS(ocsmNewPmtr);
                jpmtr = MODL->npmtr;

            /* make sure that Parameter is INTERNAL or OUTPMTR */
            } else if (MODL->pmtr[jpmtr].type == OCSM_DESPMTR) {
                status = OCSM_PMTR_IS_DESPMTR;
                signalError(MODL, status,
                            "\"%s\" cannot be SET because it is a DESPMTR", pmtrName);
                goto cleanup;
            } else if (MODL->pmtr[jpmtr].type == OCSM_CFGPMTR) {
                status = OCSM_PMTR_IS_DESPMTR;
                signalError(MODL, status,
                            "\"%s\" cannot be SET because it is a CFGPMTR", pmtrName);
                goto cleanup;
            } else if (MODL->pmtr[jpmtr].type == OCSM_CONPMTR) {
                status = OCSM_PMTR_IS_CONPMTR;
                signalError(MODL, status,
                            "\"%s\" cannot be SET because it is a CONPMTR", pmtrName);
                goto cleanup;

            /* convert UNKNOWN to LOCALVAR */
            } else if (MODL->pmtr[jpmtr].type == OCSM_UNKNOWN) {
                MODL->pmtr[jpmtr].type = OCSM_LOCALVAR;
            }

            /* string-value mode (expression evaluates to string) */
            if (args[2].nval == 0) {
                if (irow != 0 || icol != 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    CATCH_STATUS(set);
                }

                /* remove previous values and velocities and make
                   room for string */
                if (MODL->pmtr[jpmtr].str == NULL) {
                    FREE(MODL->pmtr[jpmtr].value);
                    FREE(MODL->pmtr[jpmtr].dot  );
                    FREE(MODL->pmtr[jpmtr].lbnd );
                    FREE(MODL->pmtr[jpmtr].ubnd );

                    MALLOC(MODL->pmtr[jpmtr].str, char, MAX_STRVAL_LEN);

                    MODL->pmtr[jpmtr].nrow = 0;
                    MODL->pmtr[jpmtr].ncol = 0;
                }

                /* store the string value */
                status = ocsmSetValu(MODL, jpmtr, 1, 1, MODL->brch[ibrch].arg2);
                CATCH_STATUS(ocsmSetValu);

                status = ocsmGetValuS(MODL, jpmtr, thisArg);
                CATCH_STATUS(ocsmGetValuS);

                SPRINT2(1, "                          %s = $%s",
                        pmtrName, thisArg);

            /* single-set mode (non-string) */
            } else if (args[2].nval == 1) {

                /* if currently a string value, remove it and make
                   room for single value */
                if (MODL->pmtr[jpmtr].str != NULL) {
                    FREE(MODL->pmtr[jpmtr].str);

                    MALLOC(MODL->pmtr[jpmtr].value, double, 1);
                    MALLOC(MODL->pmtr[jpmtr].dot,   double, 1);

                    MODL->pmtr[jpmtr].value[0] = -HUGEQ;
                    MODL->pmtr[jpmtr].dot[  0] = 0;

                    MODL->pmtr[jpmtr].nrow = 1;
                    MODL->pmtr[jpmtr].ncol = 1;
                }

                /* store the value(s) */
                if (irow == 0 && icol == 0) {
                    if (MODL->pmtr[jpmtr].nrow > 1 || MODL->pmtr[jpmtr].ncol > 1) {
                        for (irow = 1; irow <= MODL->pmtr[jpmtr].nrow; irow++) {
                            for (icol = 1; icol <= MODL->pmtr[jpmtr].ncol; icol++) {
                                status = ocsmSetValuD(MODL, jpmtr, irow, icol, args[2].val[0]);
                                CHECK_STATUS(ocsmSetValuD);

                                status = ocsmSetVelD( MODL, jpmtr, irow, icol, args[2].dot[0]);
                                CHECK_STATUS(ocsmSetVelD);

                                SPRINT5(1, "                          %s[%d,%d] = %11.5f %11.5f",
                                        pmtrName, irow, icol, args[2].val[0], args[2].dot[0]);
                            }
                        }
                    } else {
                        status = ocsmSetValuD(MODL, jpmtr, 1, 1, args[2].val[0]);
                        CHECK_STATUS(ocsmSetValuD);

                        status = ocsmSetVelD( MODL, jpmtr, 1, 1, args[2].dot[0]);
                        CHECK_STATUS(ocsmSetVelD);

                        SPRINT3(1, "                          %s = %11.5f %11.5f",
                                pmtrName, args[2].val[0], args[2].dot[0]);
                    }
                } else if (icol == 0) {
                    if (irow < 1 || irow > MODL->pmtr[jpmtr].nrow*MODL->pmtr[jpmtr].ncol) {
                        status = OCSM_ILLEGAL_PMTR_INDEX;
                        signalError(MODL, status,
                                    "index must be between 1 and %d", MODL->pmtr[jpmtr].nrow);
                    } else {
                        status = ocsmSetValuD(MODL, jpmtr, irow, icol, args[2].val[0]);
                        CATCH_STATUS(ocsmSetValuD);

                        status = ocsmSetVelD( MODL, jpmtr, irow, icol, args[2].dot[0]);
                        CATCH_STATUS(ocsmSetVelD);

                        SPRINT3(1, "                          %s = %11.5f %11.5f",
                                pmtrName, args[2].val[0], args[2].dot[0]);
                    }
                } else if (irow < 1 || irow > MODL->pmtr[jpmtr].nrow) {
                    status = OCSM_ILLEGAL_PMTR_INDEX;
                    signalError(MODL, status,
                                "row index must be between 1 and %d", MODL->pmtr[jpmtr].nrow);
                } else if (icol < 1 || icol > MODL->pmtr[jpmtr].ncol) {
                    status = OCSM_ILLEGAL_PMTR_INDEX;
                    signalError(MODL, status,
                                "column index must be between 1 and %d", MODL->pmtr[jpmtr].ncol);
                } else {
                    status = ocsmSetValuD(MODL, jpmtr, irow, icol, args[2].val[0]);
                    CATCH_STATUS(ocsmSetValuD);

                    status = ocsmSetVelD( MODL, jpmtr, irow, icol, args[2].dot[0]);
                    CATCH_STATUS(ocsmSetVelD);

                    SPRINT3(1, "                          %s = %11.5f %11.5f",
                            pmtrName, args[2].val[0], args[2].dot[0]);
                }

            /* multi-set mode */
            } else {

                /* we cannot be storing to a string value */
                if (MODL->pmtr[jpmtr].str != NULL) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    CATCH_STATUS(set);
                }

                /* store the values */
                icount = 0;
                value  = 0;
                dot    = 0;
                for (irow = 1; irow <= MODL->pmtr[jpmtr].nrow; irow++) {
                    for (icol = 1; icol <= MODL->pmtr[jpmtr].ncol; icol++) {

                        /* next value (if it exists; otherwise it is extended) */
                        if (icount < args[2].nval) {
                            value = args[2].val[icount];
                            dot   = args[2].dot[icount];
                        }

                        status = ocsmSetValuD(MODL, jpmtr, irow, icol, value);
                        CATCH_STATUS(ocsmSetValuD);

                        status = ocsmSetVelD(MODL, jpmtr, irow, icol, dot);
                        CATCH_STATUS(ocsmSetVelD);

                        if (icount < args[2].nval) {
                            if (value != -HUGEQ) {
                                SPRINT5(1, "                          %s[%d,%d] = %11.5f %11.5f",
                                        pmtrName, irow, icol, value, dot);
                            } else {
                                SPRINT3(1, "                          %s[%d,%d] = undefined",
                                        pmtrName, irow, icol);
                            }
                        } else {
                            if (value != -HUGEQ) {
                                SPRINT5(1, "                          %s[%d,%d] = %11.5f %11.5f (extended)",
                                        pmtrName, irow, icol, value, dot);
                            } else {
                                SPRINT3(1, "                          %s[%d,%d] = undefined (extended)",
                                        pmtrName, irow, icol);
                            }
                        }

                        icount++;
                    }
                }
            }

            /* if the SET statment has Attributes, create the global Attributes now */
            if (MODL->brch[ibrch].nattr > 0) {
                for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
                    status = ocsmSetAttr(MODL, 0, MODL->brch[ibrch].attr[iattr].name,
                                         MODL->brch[ibrch].attr[iattr].defn);
                    CHECK_STATUS(ocsmSetAttr);
                }
            }

        /* execute: "evaluate $type ..." */
        } else if (type == OCSM_EVALUATE) {

            /* require finite differences */
            MODL->needFDs = 1;

            jpmtr = 0;
            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                if (strcmp(MODL->pmtr[ipmtr].name, "@edata") == 0      &&
                    MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                    jpmtr = ipmtr;
                    break;
                }
            }

            if (jpmtr == 0) {
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            /* "evaluate $node ibody inode" */
            if (strcmp(args[1].str, "node") == 0 ||
                strcmp(args[1].str, "NODE") == 0   ) {
                SPRINT4(1, "    executing [%4d] evaluate:       %s  %11.5f  %11.5f",
                        ibrch, args[1].str, args[2].val[0],
                                            args[3].val[0]);

                ibody = NINT(args[2].val[0]);
                inode = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (inode < 1 || inode > MODL->body[ibody].nnode) {
                    status = OCSM_NODE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Node");
                    goto next_branch;
                }

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = MODL->body[ibody].node[inode].x;
                MODL->pmtr[jpmtr].value[ 1] = MODL->body[ibody].node[inode].y;
                MODL->pmtr[jpmtr].value[ 2] = MODL->body[ibody].node[inode].z;
                MODL->pmtr[jpmtr].ncol      = 3;

            /* "evaluate $edge ibody iedge t" */
            } else if (strcmp(args[1].str, "edge") == 0 ||
                       strcmp(args[1].str, "EDGE") == 0   ) {
                SPRINT5(1, "    executing [%4d] evaluate:       %s  %11.5f  %11.5f  %11.5f",
                        ibrch, args[1].str, args[2].val[0],
                                            args[3].val[0],
                                            args[4].val[0]);

                ibody = NINT(args[2].val[0]);
                iedge = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
                    status = OCSM_EDGE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Edge");
                    goto next_branch;
                }

                status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                if        (strcmp(args[4].str, "beg") == 0) {
                    uv_[0] = uvrange[0];
                } else if (strcmp(args[4].str, "end") == 0) {
                    uv_[0] = uvrange[1];
                } else if (args[4].val[0] < uvrange[0]) {
                    uv_[0] = uvrange[0];
                } else if (args[4].val[0] > uvrange[1]) {
                    uv_[0] = uvrange[1];
                } else {
                    uv_[0] = args[4].val[0];
                }

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, uv_, data);
                CHECK_STATUS(EG_evaluate);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uv_[0];
                MODL->pmtr[jpmtr].value[ 1] = data[0];
                MODL->pmtr[jpmtr].value[ 2] = data[1];
                MODL->pmtr[jpmtr].value[ 3] = data[2];
                MODL->pmtr[jpmtr].value[ 4] = data[3];
                MODL->pmtr[jpmtr].value[ 5] = data[4];
                MODL->pmtr[jpmtr].value[ 6] = data[5];
                MODL->pmtr[jpmtr].value[ 7] = data[6];
                MODL->pmtr[jpmtr].value[ 8] = data[7];
                MODL->pmtr[jpmtr].value[ 9] = data[8];
                MODL->pmtr[jpmtr].ncol      = 10;

            /* "evaluate $edgerng ibody iedge" */
            } else if (strcmp(args[1].str, "edgerng") == 0 ||
                       strcmp(args[1].str, "EDGERNG") == 0   ) {
                SPRINT4(1, "    executing [%4d] evaluate:       %s  %11.5f  %11.5f",
                        ibrch, args[1].str, args[2].val[0],
                                            args[3].val[0]);

                ibody = NINT(args[2].val[0]);
                iedge = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
                    status = OCSM_EDGE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Edge");
                    goto next_branch;
                }

                status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uvrange[0];
                MODL->pmtr[jpmtr].value[ 1] = uvrange[1];
                MODL->pmtr[jpmtr].ncol      = 2;

            /* "evaluate $edgeinv ibody iedge x y z" */
            } else if (strcmp(args[1].str, "edgeinv") == 0 ||
                       strcmp(args[1].str, "EDGEINV") == 0   ) {
                SPRINT7(1, "    executing [%4d] evaluate:       %s  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                        ibrch, args[1].str, args[2].val[0],
                                            args[3].val[0],
                                            args[4].val[0],
                                            args[5].val[0],
                                            args[6].val[0]);

                ibody = NINT(args[2].val[0]);
                iedge = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
                    status = OCSM_EDGE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Edge");
                    goto next_branch;
                }

                xyz_[0] = args[4].val[0];
                xyz_[1] = args[5].val[0];
                xyz_[2] = args[6].val[0];

                status = EG_invEvaluate(MODL->body[ibody].edge[iedge].eedge, xyz_, uv_, data);
                CHECK_STATUS(EG_invEvaluate);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uv_[ 0];
                MODL->pmtr[jpmtr].value[ 1] = data[0];
                MODL->pmtr[jpmtr].value[ 2] = data[1];
                MODL->pmtr[jpmtr].value[ 3] = data[2];
                MODL->pmtr[jpmtr].ncol      = 4;

            /* "evaluate $face ibody iface u v" */
            } else if (strcmp(args[1].str, "face") == 0 ||
                       strcmp(args[1].str, "FACE") == 0   ) {
                SPRINT6(1, "    executing [%4d] evaluate:       %s  %11.5f  %11.5f  %11.5f  %11.5f",
                        ibrch, args[1].str, args[2].val[0],
                                            args[3].val[0],
                                            args[4].val[0],
                                            args[5].val[0]);

                ibody = NINT(args[2].val[0]);
                iface = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iface < 1 || iface > MODL->body[ibody].nface) {
                    status = OCSM_FACE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Face");
                    goto next_branch;
                }

                status = EG_getRange(MODL->body[ibody].face[iface].eface, uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                if        (args[4].val[0] < uvrange[0]) {
                    uv_[0] = uvrange[0];
                } else if (args[4].val[0] > uvrange[1]) {
                    uv_[0] = uvrange[1];
                } else {
                    uv_[0] = args[4].val[0];
                }

                if        (args[5].val[0] < uvrange[2]) {
                    uv_[1] = uvrange[2];
                } else if (args[5].val[0] > uvrange[3]) {
                    uv_[1] = uvrange[3];
                } else {
                    uv_[1] = args[5].val[0];
                }

                status = EG_getTopology(MODL->body[ibody].face[iface].eface, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                status = EG_evaluate(MODL->body[ibody].face[iface].eface, uv_, data);
                CHECK_STATUS(EG_evaluate);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uv_[  0];
                MODL->pmtr[jpmtr].value[ 1] = uv_[  1];
                MODL->pmtr[jpmtr].value[ 2] = data[ 0];
                MODL->pmtr[jpmtr].value[ 3] = data[ 1];
                MODL->pmtr[jpmtr].value[ 4] = data[ 2];
                MODL->pmtr[jpmtr].value[ 5] = data[ 3];
                MODL->pmtr[jpmtr].value[ 6] = data[ 4];
                MODL->pmtr[jpmtr].value[ 7] = data[ 5];
                MODL->pmtr[jpmtr].value[ 8] = data[ 6];
                MODL->pmtr[jpmtr].value[ 9] = data[ 7];
                MODL->pmtr[jpmtr].value[10] = data[ 8];
                MODL->pmtr[jpmtr].value[11] = data[ 9];
                MODL->pmtr[jpmtr].value[12] = data[10];
                MODL->pmtr[jpmtr].value[13] = data[11];
                MODL->pmtr[jpmtr].value[14] = data[12];
                MODL->pmtr[jpmtr].value[15] = data[13];
                MODL->pmtr[jpmtr].value[16] = data[14];
                MODL->pmtr[jpmtr].value[17] = data[15];
                MODL->pmtr[jpmtr].value[18] = data[16];
                MODL->pmtr[jpmtr].value[19] = data[17];
                MODL->pmtr[jpmtr].value[20] = (data[4] * data[8] - data[5] * data[7]) * mtype;
                MODL->pmtr[jpmtr].value[21] = (data[5] * data[6] - data[3] * data[8]) * mtype;
                MODL->pmtr[jpmtr].value[22] = (data[3] * data[7] - data[4] * data[6]) * mtype;
                MODL->pmtr[jpmtr].ncol      = 23;

            /* "evaluate $facerng ibody iface" */
            } else if (strcmp(args[1].str, "facerng") == 0 ||
                       strcmp(args[1].str, "FACERNG") == 0   ) {
                SPRINT4(1, "    executing [%4d] evaluate:       %s  %11.5f  %11.5f",
                        ibrch, args[1].str, args[2].val[0],
                                            args[3].val[0]);

                ibody = NINT(args[2].val[0]);
                iface = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iface < 1 || iface > MODL->body[ibody].nface) {
                    status = OCSM_FACE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Face");
                    goto next_branch;
                }

                status = EG_getRange(MODL->body[ibody].face[iface].eface, uvrange, &periodic);
                CHECK_STATUS(EG_getRange);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uvrange[0];
                MODL->pmtr[jpmtr].value[ 1] = uvrange[1];
                MODL->pmtr[jpmtr].value[ 2] = uvrange[2];
                MODL->pmtr[jpmtr].value[ 3] = uvrange[3];
                MODL->pmtr[jpmtr].ncol      = 4;

            /* "evaluate $faceinv ibody iface x y z" */
            } else if (strcmp(args[1].str, "faceinv") == 0 ||
                       strcmp(args[1].str, "FACEINV") == 0   ) {
                SPRINT7(1, "    executing [%4d] evaluate:       %s  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                        ibrch, args[1].str, args[2].val[0],
                                            args[3].val[0],
                                            args[4].val[0],
                                            args[5].val[0],
                                            args[6].val[0]);

                ibody = NINT(args[2].val[0]);
                iface = NINT(args[3].val[0]);

                if (ibody < 1 || ibody > MODL->nbody) {
                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Body");
                    goto next_branch;
                } else if (iface < 1 || iface > MODL->body[ibody].nface) {
                    status = OCSM_FACE_NOT_FOUND;
                    signalError(MODL, status,
                                "EVALUATE specified nonexistant Face");
                    goto next_branch;
                }

                xyz_[0] = args[4].val[0];
                xyz_[1] = args[5].val[0];
                xyz_[2] = args[6].val[0];

                status = EG_invEvaluate(MODL->body[ibody].face[iface].eface, xyz_, uv_, data);
                CHECK_STATUS(EG_invEvaluate);

                /* resize */
                MODL->pmtr[jpmtr].value[ 0] = uv_[0];
                MODL->pmtr[jpmtr].value[ 1] = uv_[1];
                MODL->pmtr[jpmtr].value[ 2] = data[0];
                MODL->pmtr[jpmtr].value[ 3] = data[1];
                MODL->pmtr[jpmtr].value[ 4] = data[2];
                MODL->pmtr[jpmtr].ncol      = 5;
            }

        /* execute: "getattr $pmtrName attrID global=0" */
        } else if (type == OCSM_GETATTR) {
            SPRINT4(1, "    executing [%4d] getattr:        %s  %s  %s",
                    ibrch, args[1].str, MODL->brch[ibrch].arg2, MODL->brch[ibrch].arg3);

            /* make sure that there are no subscripts in pmtrName */
            if (strstr(args[1].str, "[") != NULL) {
                status = OCSM_ILLEGAL_PMTR_NAME;
                signalError(MODL, status,
                            "pmtrName cannot contain [");
                goto next_branch;
            }

            /* find pmtrName in list of Parameters */
            jpmtr = -1;
            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                if (strcmp(MODL->pmtr[ipmtr].name, args[1].str) == 0          &&
                           MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                    jpmtr = ipmtr;

                    /* if the Parameter is CONPMTR, DESPMTR, or CFGPMTR we have a problem */
                    if        (MODL->pmtr[jpmtr].type == OCSM_DESPMTR ||
                               MODL->pmtr[jpmtr].type == OCSM_CFGPMTR   ) {
                        status = OCSM_PMTR_IS_DESPMTR;
                        CATCH_STATUS(getattr);
                    } else if (MODL->pmtr[jpmtr].type == OCSM_CONPMTR) {
                        status = OCSM_PMTR_IS_CONPMTR;
                        CATCH_STATUS(getattr);
                    }

                    break;
                }
            }

            status = str2val(MODL->brch[ibrch].arg2, MODL, &value, &dot, str);
            CATCH_STATUS(str2val);

            /* get the ego associated with the selected entity */
            if        (NINT(args[3].val[0]) > 0) {
                eobj = NULL;
            } else if (MODL->seltype == 0) {
                eobj = MODL->body[MODL->selbody].node[MODL->sellist[0]].enode;
            } else if (MODL->seltype == 1) {
                eobj = MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge;
            } else if (MODL->seltype == 2) {
                eobj = MODL->body[MODL->selbody].face[MODL->sellist[0]].eface;
            } else if (MODL->selbody >= 1) {
                eobj = MODL->body[MODL->selbody].ebody;
            } else {
                status = OCSM_INTERNAL_ERROR;
                signalError(MODL, status,
                            "nothing is selected");
                goto next_branch;
            }

            /* get the number of Attributes for this selected object */
            if (eobj != NULL) {
                status = EG_attributeNum(eobj, &nattr);
                CATCH_STATUS(EG_attributeNum);
            } else {
                nattr = MODL->nattr;
            }

            /* if attrID is an integer, return the name of the attrID'th attribute */
            if (STRLEN(str) == 0) {
                iattr = NINT(value);

                /* ensure that iattr is in range */
                if (iattr < 1 || iattr > nattr) {
                    status = OCSM_ILLEGAL_ATTRIBUTE;
                    signalError(MODL, status,
                                "iattr is out of range");
                    goto next_branch;
                }

                /* if pmtrName does not exist, make it now */
                if (jpmtr < 0) {
                    status = ocsmNewPmtr(MODL, args[1].str, OCSM_LOCALVAR, 0, 0);
                    CATCH_STATUS(ocsmNewPmtr);
                    jpmtr = MODL->npmtr;

                /* otherwise if it has rows and columns, convert to string */
                } else if (MODL->pmtr[jpmtr].nrow > 0 ||
                           MODL->pmtr[jpmtr].ncol > 0   ) {
                    FREE(MODL->pmtr[jpmtr].value);
                    FREE(MODL->pmtr[jpmtr].dot  );
                    FREE(MODL->pmtr[jpmtr].lbnd );
                    FREE(MODL->pmtr[jpmtr].ubnd );

                    MALLOC(MODL->pmtr[jpmtr].str, char, MAX_STRVAL_LEN);

                    MODL->pmtr[jpmtr].nrow = 0;
                    MODL->pmtr[jpmtr].ncol = 0;
                }

                /* store the name in jpmtr */
                if (eobj != NULL) {
                    status = EG_attributeGet(eobj, iattr, &aname, &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CATCH_STATUS(EG_attributeGet);

                    STRNCPY(MODL->pmtr[jpmtr].str, aname, MAX_STRVAL_LEN);
                } else {
                    STRNCPY(MODL->pmtr[jpmtr].str, MODL->attr[iattr-1].name, MAX_STRVAL_LEN);
                }

                SPRINT2(1, "                          %s = $%s",
                        args[1].str, MODL->pmtr[jpmtr].str);

            /* if attrID is $_nattr_, return the number of Attributes */
            } else if (strcmp(str, "_nattr_") == 0) {

                /* if pmtrName does not exist, make it now */
                if (jpmtr < 0) {
                    status = ocsmNewPmtr(MODL, args[1].str, OCSM_LOCALVAR, 1, 1);
                    CATCH_STATUS(ocsmNewPmtr);
                    jpmtr = MODL->npmtr;

                /* otherwise if it is a string, convert to a number */
                } else if (MODL->pmtr[jpmtr].nrow == 0 &&
                           MODL->pmtr[jpmtr].ncol == 0   ) {
                    FREE(MODL->pmtr[jpmtr].str);

                    MALLOC(MODL->pmtr[jpmtr].value, double, 1);
                    MALLOC(MODL->pmtr[jpmtr].dot,   double, 1);

                    MODL->pmtr[jpmtr].value[0] = -HUGEQ;
                    MODL->pmtr[jpmtr].dot[  0] = 0;

                    MODL->pmtr[jpmtr].nrow = 1;
                    MODL->pmtr[jpmtr].ncol = 1;
                }

                /* store the result */
                if (MODL->pmtr[jpmtr].type == OCSM_UNKNOWN) {
                    MODL->pmtr[jpmtr].type =  OCSM_LOCALVAR;
                }

                status = ocsmSetValuD(MODL, jpmtr, 1, 1, (double)nattr);
                CATCH_STATUS(ocsmSetValuD);

                SPRINT2(1, "                          %s = %11.5f",
                        args[1].str, (double)nattr);

            /* otherwise, look up the value of the given Attribute */
            } else {
                if (eobj != NULL) {
                    status = EG_attributeRet(eobj, str, &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    if (status != SUCCESS) {
                        status = OCSM_ILLEGAL_ATTRIBUTE;
                        signalError(MODL, status,
                                    "Attribute \"%s\" not found", str);
                        goto next_branch;
                    }
                } else {
                    itype = -999;
                    for (iattr = 0; iattr < MODL->nattr; iattr++) {
                        if (strcmp(str, MODL->attr[iattr].name) == 0) {
                            itype     = ATTRSTRING;
                            nlist     = STRLEN(MODL->attr[iattr].defn);
                            tempClist = MODL->attr[iattr].defn;
                            break;
                        }
                    }
                    if (itype == -999) {
                        status = OCSM_ILLEGAL_ATTRIBUTE;
                        signalError(MODL, status,
                                    "Attribute \"%s\" not found", str);
                        goto next_branch;
                    }

                    if (MODL->attr[iattr].defn[0] == '$') {
                        itype     = ATTRSTRING;
                        nlist     = STRLEN(MODL->attr[iattr].defn) - 1;
                        tempClist = &(MODL->attr[iattr].defn[1]);
                    } else {
                        status = str2vals(MODL->attr[iattr].defn, MODL, &nrow, &ncol, &values, &dots, str);
                        CATCH_STATUS(str2val);

                        itype     = ATTRREAL;
                        nlist     = nrow * ncol;
                        tempRlist = values;
                    }
                }

                if (itype != ATTRINT  && itype != ATTRREAL  &&
                    itype != ATTRCSYS && itype != ATTRSTRING  ) {
                    status = OCSM_ILLEGAL_ATTRIBUTE;
                    signalError(MODL, status,
                                "Attribute \"%s\" is wrong type (%d)", str, itype);
                    goto next_branch;
                }

                /* if pmtrName does not exist, create it now */
                if (jpmtr < 0) {
                    if (itype == ATTRINT || itype == ATTRREAL || itype == ATTRCSYS) {
                        status = ocsmNewPmtr(MODL, args[1].str, OCSM_LOCALVAR, 1, nlist);
                        CATCH_STATUS(ocsmNewPmtr);
                    } else {
                        status = ocsmNewPmtr(MODL, args[1].str, OCSM_LOCALVAR, 0, 0);
                        CATCH_STATUS(ocsmNewPmtr);
                    }
                    jpmtr = MODL->npmtr;

                /* otherwise adjust type/size */
                } else if (itype == ATTRINT || itype == ATTRREAL || itype == ATTRCSYS) {
                    FREE(MODL->pmtr[jpmtr].value);
                    FREE(MODL->pmtr[jpmtr].dot  );
                    FREE(MODL->pmtr[jpmtr].lbnd );
                    FREE(MODL->pmtr[jpmtr].ubnd );
                    FREE(MODL->pmtr[jpmtr].str  );

                    MALLOC(MODL->pmtr[jpmtr].value, double, nlist);
                    MALLOC(MODL->pmtr[jpmtr].dot,   double, nlist);

                    for (i = 0; i < nlist; i++) {
                        MODL->pmtr[jpmtr].value[i] = -HUGEQ;
                        MODL->pmtr[jpmtr].dot[  i] = 0;
                    }

                    MODL->pmtr[jpmtr].nrow = 1;
                    MODL->pmtr[jpmtr].ncol = nlist;
                } else if (itype == ATTRSTRING) {
                    FREE(MODL->pmtr[jpmtr].value);
                    FREE(MODL->pmtr[jpmtr].dot  );
                    FREE(MODL->pmtr[jpmtr].lbnd );
                    FREE(MODL->pmtr[jpmtr].ubnd );
                    FREE(MODL->pmtr[jpmtr].str  );

                    MALLOC(MODL->pmtr[jpmtr].str, char, MAX_STRVAL_LEN);

                    MODL->pmtr[jpmtr].nrow = 0;
                    MODL->pmtr[jpmtr].ncol = 0;
                }

                /* store the values in jpmtr */
                if (MODL->pmtr[jpmtr].type == OCSM_UNKNOWN) {
                    MODL->pmtr[jpmtr].type =  OCSM_LOCALVAR;
                }

                if (itype == ATTRINT) {
                    SPLINT_CHECK_FOR_NULL(tempIlist);

                    for (ilist = 0; ilist < nlist; ilist++) {
                        status = ocsmSetValuD(MODL, jpmtr, 1, ilist+1, (double)tempIlist[ilist]);
                        CATCH_STATUS(ocsmSetValuD);

                        SPRINT3(1, "                          %s[1,%2d] = %11.5f",
                                args[1].str, ilist+1, (double)tempIlist[ilist]);
                    }
                } else if (itype == ATTRREAL || itype == ATTRCSYS) {
                    SPLINT_CHECK_FOR_NULL(tempRlist);
                    for (ilist = 0; ilist < nlist; ilist++) {
                        status = ocsmSetValuD(MODL, jpmtr, 1, ilist+1, tempRlist[ilist]);
                        CATCH_STATUS(ocsmSetValuD);

                        SPRINT3(1, "                          %s[1,%2d] = %11.5f",
                                args[1].str, ilist+1, tempRlist[ilist]);
                    }
                } else {
                    SPLINT_CHECK_FOR_NULL(tempClist);

                    STRNCPY(MODL->pmtr[jpmtr].str, tempClist, MAX_STRVAL_LEN);

                    SPRINT2(1, "                          %s = $%s",
                            args[1].str, tempClist);

                }
            }

            FREE(values);
            FREE(dots  );

        /* execute: "udparg $primtype $argName1 argValue1 $argName2 argValue2 $argName3 argValue3 $argName4 argValue4" */
        } else if (type == OCSM_UDPARG) {
            SPRINT2x(1, "    executing [%4d] udparg:     %s",
                    ibrch, args[1].str);

            hasdots = 0;

            for (iarg = 3; iarg <= MODL->brch[ibrch].narg; iarg+=2) {
                if (args[iarg].nval == 0) {
                    SPRINT2x(1, " %s %s",
                             args[iarg-1].str, args[iarg].str);
                } else {
                    SPRINT2x(1, " %s %11.5f",
                             args[iarg-1].str, args[iarg].val[0]);

                    for (ival = 0; ival < args[iarg].nval; ival++) {
                        if (args[iarg].dot[ival] != 0) hasdots = 1;
                    }

                    /* set hasdots to 2 if any arguments changed (so that we know to
                       rebuild the UDPRIM) */
                    ibody = MODL->nbody + 1;
                    if (ibody <= MODL->recycle) {
                        if (MODL->body[ibody].arg[iarg].nval == args[iarg].nval) {
                            for (ival = 0; ival < args[iarg].nval; ival++) {
                                if (MODL->body[ibody].arg[iarg].val[ival] != args[iarg].val[ival]) {
                                    hasdots = 2;
                                }
                            }
                        } else {
                            hasdots = 2;
                        }
                    }
                }
            }
            SPRINT0(1, " ");

            /* free a previuos Body if it exists */
            if (MODL->nbody+1 <= MODL->recycle) {
                if (MODL->body[MODL->nbody+1].arg[1].val != NULL) {
                    status = freeBody(MODL, MODL->nbody+1);
                    CATCH_STATUS(freeBody);
                }
            }

            /* create a Body */
            status = newBody(MODL, ibrch, OCSM_UDPARG, -1, -1,
                             args, hasdots, OCSM_NULL_BODY, &ibody);
            CATCH_STATUS(newBody);

            /* finish the Body (UDPARG) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto next_branch;
            CATCH_STATUS(finishBody);

            /* do not push the Body onto the stack */
            SPRINT1(1, "                          Body   %4d created  (NULL Body)",
                    ibody);

        /* execute: "select $type arg1..." */
        } else if (type == OCSM_SELECT) {

            /* make sure we get new mass properties */
            MODL->hasMPs = 0;

            /* "select body ..." */
            if        (strcmp(args[1].str, "body") == 0 || strcmp(args[1].str, "BODY") == 0) {

                /* "body" */
                if        (MODL->brch[ibrch].narg == 1) {
                    SPRINT1(1, "    executing [%4d] select:   body", ibrch);

                    MODL->seltype = -1;
                    for (MODL->selbody = MODL->nbody; MODL->selbody > 0; (MODL->selbody)--) {
                        if (MODL->body[MODL->selbody].botype != OCSM_NULL_BODY) break;
                    }

                /* "body attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    SPRINT7(1, "    executing [%4d] select:   body  %s  %s  %s  %s  %s  %s", ibrch,
                            args[2].str, args[3].str, args[4].str, args[5].str, args[6].str, args[7].str);

                    ibody = -1;
                    for (jbody = 1; jbody <= MODL->nbody; jbody++) {
                        if (MODL->body[jbody].botype == OCSM_NULL_BODY) continue;
                        if (MODL->body[jbody].ebody == NULL) continue;

                        status = EG_attributeNum(MODL->body[jbody].ebody, &nattr);
                        CHECK_STATUS(EG_attributeNum);

                        match1 = 0;
                        match2 = 0;
                        match3 = 0;

                        for (iattr = 1; iattr <= nattr; iattr++) {
                            status = EG_attributeGet(MODL->body[jbody].ebody,
                                                     iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeGet);

                            if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                            }

                            if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                            }

                            if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                            }
                        }

                        if (match1 == 1 && match2 == 1 && match3 == 1) {
                            if (ibody == -1) {
                                ibody = jbody;
                            } else {
                                status = OCSM_BODY_NOT_FOUND;
                                signalError(MODL, status,
                                            "more than one Body matches SELECT");
                                goto next_branch;
                            }
                        }
                    }

                    if (ibody > 0) {
                        MODL->seltype = -1;
                        MODL->selbody = ibody;
                        MODL->selsize = 0;

                        FREE(MODL->sellist);
                    } else {
                        status = OCSM_BODY_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specifies nonexistant Body");
                        goto next_branch;
                    }

                /* "body ibody" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    SPRINT2(1, "    executing [%4d] select:   body  %d", ibrch,
                            NINT(args[2].val[0]));

                    if (NINT(args[2].val[0]) >= 1 && NINT(args[2].val[0]) <= MODL->nbody) {
                        MODL->seltype = -1;
                        MODL->selbody = NINT(args[2].val[0]);
                        MODL->selsize = 0;

                        FREE(MODL->sellist);
                    } else if (NINT(args[2].val[0]) < 0 && nstack >= -NINT(args[2].val[0])) {
                        MODL->seltype = -1;
                        MODL->selbody = stack[nstack+NINT(args[2].val[0])];
                        MODL->selsize = 0;

                        FREE(MODL->sellist);

                        if (MODL->selbody == 0) {
                            status = setupAtPmtrs(MODL, -1);
                            goto next_branch;
                        }
                    } else {
                        status = OCSM_BODY_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specifies nonexistant Body");
                        goto next_branch;
                    }
                }

            /* "select face ..." */
            } else if (strcmp(args[1].str, "face") == 0 || strcmp(args[1].str, "FACE") == 0) {
                if (MODL->selbody < 0) {
                    SPRINT1x(1, "    executing [%4d] select: ", ibrch);
                    for (iarg = 1; iarg <= MODL->brch[ibrch].narg; iarg++) {
                        if (args[iarg].nval > 0) {
                            SPRINT1x(1, "  %11.5f",  args[iarg].val[0]);
                        } else {
                            SPRINT1x(1, "  %s",      args[iarg].str);
                        }
                    }
                    SPRINT0(1, " ");

                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT FACE specified nonexistant Body");
                    goto next_branch;

                /* "face" */
                } else if (MODL->brch[ibrch].narg == 1) {
                    SPRINT1(1, "    executing [%4d] select:   face", ibrch);

                    MODL->seltype = 2;
                    MODL->selsize = MODL->body[MODL->selbody].nface;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        MODL->sellist[iface-1] = iface;
                    }

                /* "face iface" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    SPRINT2(1, "    executing [%4d] select:   face  %d", ibrch,
                            NINT(args[2].val[0]));

                    if (NINT(args[2].val[0]) >= 1 && NINT(args[2].val[0]) <= MODL->body[MODL->selbody].nface) {
                        MODL->seltype = 2;
                        MODL->selsize = 1;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        MODL->sellist[0] = NINT(args[2].val[0]);
                    } else {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    }

                /* "face ibody1 iford1 iseq=1" (0 for any) */
                } else if (MODL->brch[ibrch].narg == 3 || MODL->brch[ibrch].narg == 4) {
                    if (MODL->brch[ibrch].narg == 3) {
                        SPRINT3(1, "    executing [%4d] select:   face  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]));
                    } else {
                        SPRINT4(1, "    executing [%4d] select:   face  %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]));
                    }

                    MODL->seltype = 2;
                    MODL->selsize = 0;

                    if (MODL->brch[ibrch].narg == 4) {
                        iseq = NINT(args[4].val[0]);
                    } else if (NINT(args[2].val[0]) == 0 || NINT(args[3].val[0]) == 0) {
                        iseq = 0;
                    } else {
                        iseq = 1;
                    }

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                 "_faceID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                            (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                            (                iseq == 0 ||                 iseq == tempIlist[2])   ) {
                            MODL->selsize++;
                        }
                    }

                    if (MODL->selsize > 0) {
                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);

                        i = 0;
                        for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                            status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                     "_faceID", &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CATCH_STATUS(EG_attributeRet);

                            if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                                (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                                (                iseq == 0 ||                 iseq == tempIlist[2])    ) {
                                MODL->sellist[i] = iface;

                                i++;
                            }
                        }
                    } else {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    }

                /* "face xmin xmax ymin ymax zmin zmax" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 1 && args[3].nval == 1 &&
                                                          args[4].nval == 1 && args[5].nval == 1 &&
                                                          args[6].nval == 1 && args[7].nval == 1   ) {
                    SPRINT7(1, "    executing [%4d] select:   face  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f", ibrch,
                            args[2].val[0], args[3].val[0], args[4].val[0],
                            args[5].val[0], args[6].val[0], args[7].val[0]);

                    MODL->seltype = 2;
                    MODL->selsize = 0;

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        status = EG_getBoundingBox(MODL->body[MODL->selbody].face[iface].eface, bbox);
                        CATCH_STATUS(EG_getBoundingBox);

                        if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                            bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                            bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                            MODL->selsize++;
                        }
                    }

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MAX(MODL->selsize, 1));
                    if (MODL->selsize == 0) {
                        MODL->sellist[0] = -1;

                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    } else {
                        MODL->selsize = 0;

                        for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                            status = EG_getBoundingBox(MODL->body[MODL->selbody].face[iface].eface, bbox);
                            CATCH_STATUS(EG_getBoundingBox);

                            if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                                bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                                bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                                MODL->sellist[MODL->selsize] = iface;
                                MODL->selsize++;
                            }
                        }
                    }

                /* "face attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    SPRINT7(1, "    executing [%4d] select:   face  %s  %s  %s  %s  %s  %s", ibrch,
                            args[2].str, args[3].str, args[4].str, args[5].str, args[6].str, args[7].str);

                    MODL->seltype = 2;
                    MODL->selsize = 0;

                    FREE(  MODL->sellist);

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        status = EG_attributeNum(MODL->body[MODL->selbody].face[iface].eface, &nattr);
                        CHECK_STATUS(EG_attributeNum);

                        match1 = 0;
                        match2 = 0;
                        match3 = 0;

                        for (iattr = 1; iattr <= nattr; iattr++) {
                            status = EG_attributeGet(MODL->body[MODL->selbody].face[iface].eface,
                                                     iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeGet);

                            if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                            }

                            if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                            }

                            if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                            }
                        }

                        if (match1 == 1 && match2 == 1 && match3 == 1) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iface;
                        }
                    }

                    if (MODL->selsize == 0) {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    }
                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_face);
                }

            /* "select edge ..." */
            } else if (strcmp(args[1].str, "edge") == 0 || strcmp(args[1].str, "EDGE") == 0) {
                if (MODL->selbody < 0) {
                    SPRINT1x(1, "    executing [%4d] select: ", ibrch);
                    for (iarg = 1; iarg <= MODL->brch[ibrch].narg; iarg++) {
                        if (args[iarg].nval > 0) {
                            SPRINT1x(1, "  %11.5f",  args[iarg].val[0]);
                        } else {
                            SPRINT1x(1, "  %s",      args[iarg].str);
                        }
                    }
                    SPRINT0(1, " ");

                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT EDGE specified nonexistant Body");
                    goto next_branch;

                /* "edge" */
                } else if (MODL->brch[ibrch].narg == 1) {
                    SPRINT1(1, "    executing [%4d] select:   edge", ibrch);

                    MODL->seltype = 1;
                    MODL->selsize = MODL->body[MODL->selbody].nedge;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        MODL->sellist[iedge-1] = iedge;
                    }

                /* "edge iedge" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    SPRINT2(1, "    executing [%4d] select:   edge  %d", ibrch,
                            NINT(args[2].val[0]));

                    if (NINT(args[2].val[0]) >= 1 && NINT(args[2].val[0]) <= MODL->body[MODL->selbody].nedge) {
                        MODL->seltype = 1;
                        MODL->selsize = 1;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        MODL->sellist[0] = NINT(args[2].val[0]);
                    } else {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    }


                /* "edge ibody1 iford1 ibody2 iford2 iseq=1" (0 for any) */
                } else if (MODL->brch[ibrch].narg == 5 || MODL->brch[ibrch].narg == 6) {
                    if (MODL->brch[ibrch].narg == 5) {
                        SPRINT5(1, "    executing [%4d] select:   edge  %d  %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]),
                                NINT(args[5].val[0]));
                    } else {
                        SPRINT6(1, "    executing [%4d] select:   edge  %d  %d  %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]),
                                NINT(args[5].val[0]), NINT(args[6].val[0]));
                    }

                    MODL->seltype = 1;
                    MODL->selsize = 0;

                    if (MODL->brch[ibrch].narg == 6) {
                        iseq = NINT(args[6].val[0]);
                    } else if (NINT(args[2].val[0]) == 0 || NINT(args[3].val[0]) == 0 ||
                               NINT(args[4].val[0]) == 0 || NINT(args[5].val[0]) == 0   ) {
                        iseq = 0;
                    } else {
                        iseq = 1;
                    }

                    if (NINT(args[2].val[0]) == 0 && NINT(args[3].val[0]) == 0 &&
                        NINT(args[4].val[0]) != 0 && NINT(args[5].val[0]) != 0   ) {
                        SPRINT0(1, "WARNING:: to SELECT non-manifold Edge, add \"SELECT SUB $_nface 2\" statement");
                        (MODL->nwarn)++;
                    }

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                 "_edgeID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                            (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                            (NINT(args[4].val[0]) == 0 || NINT(args[4].val[0]) == tempIlist[2]) &&
                            (NINT(args[5].val[0]) == 0 || NINT(args[5].val[0]) == tempIlist[3]) &&
                            (                iseq == 0 ||                 iseq == tempIlist[4])   ) {
                            MODL->selsize++;
                        }
                    }

                    if (MODL->selsize > 0) {
                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);

                        i = 0;
                        for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                            status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                     "_edgeID", &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CATCH_STATUS(EG_attributeRet);

                            if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                                (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                                (NINT(args[4].val[0]) == 0 || NINT(args[4].val[0]) == tempIlist[2]) &&
                                (NINT(args[5].val[0]) == 0 || NINT(args[5].val[0]) == tempIlist[3]) &&
                                (                iseq == 0 ||                 iseq == tempIlist[4])   ) {
                                MODL->sellist[i] = iedge;
                                i++;
                            }
                        }
                    } else {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    }

                /* "edge xmin xmax ymin ymax zmin zmax" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 1 && args[3].nval == 1 &&
                                                          args[4].nval == 1 && args[5].nval == 1 &&
                                                          args[6].nval == 1 && args[7].nval == 1   ) {
                    SPRINT7(1, "    executing [%4d] select:   edge  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f", ibrch,
                            args[2].val[0], args[3].val[0], args[4].val[0],
                            args[5].val[0], args[6].val[0], args[7].val[0]);

                            MODL->seltype = 1;
                    MODL->selsize = 0;

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        if (MODL->body[MODL->selbody].edge[iedge].itype == DEGENERATE) continue;

                        status = EG_getBoundingBox(MODL->body[MODL->selbody].edge[iedge].eedge, bbox);
                        CATCH_STATUS(EG_getBoundingBox);

                        if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                            bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                            bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                            MODL->selsize++;
                        }
                    }

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MAX(MODL->selsize, 1));
                    if (MODL->selsize == 0) {
                        MODL->sellist[0] = -1;

                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    } else {
                        MODL->selsize = 0;

                        for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                            status = EG_getBoundingBox(MODL->body[MODL->selbody].edge[iedge].eedge, bbox);
                            CATCH_STATUS(EG_getBoundingBox);

                            if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                                bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                                bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                                MODL->sellist[MODL->selsize] = iedge;
                                MODL->selsize++;
                            }
                        }
                    }

                /* "edge attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    SPRINT7(1, "    executing [%4d] select:   edge  %s  %s  %s  %s  %s  %s", ibrch,
                            args[2].str, args[3].str, args[4].str, args[5].str, args[6].str, args[7].str);

                    MODL->seltype = 1;
                    MODL->selsize = 0;

                    FREE(  MODL->sellist);

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        status = EG_attributeNum(MODL->body[MODL->selbody].edge[iedge].eedge, &nattr);
                        CHECK_STATUS(EG_attributeNum);

                        match1 = 0;
                        match2 = 0;
                        match3 = 0;

                        for (iattr = 1; iattr <= nattr; iattr++) {
                            status = EG_attributeGet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                     iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeGet);

                            if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                            }

                            if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                            }

                            if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                            }
                        }

                        if (match1 == 1 && match2 == 1 && match3 == 1) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iedge;
                        }
                    }

                    if (MODL->selsize == 0) {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Edge");
                        goto next_branch;
                    }

                /* "edge x y z" */
                } else if (MODL->brch[ibrch].narg == 4 && args[2].nval == 1 &&
                                                          args[3].nval == 1 &&
                                                          args[4].nval == 1   ) {
                    SPRINT4(1, "    executing [%4d] select:   edge  %11.5f  %11.5f  %11.5f", ibrch,
                            args[2].val[0], args[3].val[0], args[4].val[0]);

                    MODL->seltype = 1;
                    MODL->selsize = 1;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    MODL->sellist[0] = -1;

                    dmin = HUGEQ;
                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        if (MODL->body[MODL->selbody].edge[iedge].itype == DEGENERATE) continue;

                        status = EG_getRange(MODL->body[MODL->selbody].edge[iedge].eedge, uvrange, &periodic);
                        CATCH_STATUS(EG_getRange);

                        uvrange[0] = (uvrange[0] + uvrange[1]) / 2;
                        status = EG_evaluate(MODL->body[MODL->selbody].edge[iedge].eedge, uvrange, data);
                        CATCH_STATUS(EG_evaluate);

                        dtest = sqrt((data[0]-args[2].val[0]) * (data[0]-args[2].val[0])
                                    +(data[1]-args[3].val[0]) * (data[1]-args[3].val[0])
                                    +(data[2]-args[4].val[0]) * (data[2]-args[4].val[0]));
                        if (dtest < dmin) {
                            dmin = dtest;
                            MODL->sellist[0] = iedge;
                        }
                    }

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_edge);
                }

            /* "select loop ..." */
            } else if (strcmp(args[1].str, "loop") == 0 || strcmp(args[1].str, "LOOP") == 0) {
                /* "loop iface iloop" */
                if (MODL->brch[ibrch].narg == 3 && args[2].nval == 1 &&
                                                   args[3].nval == 1   ) {
                    SPRINT3(1, "    executing [%4d] select:   loop  %11.5f  %11.5f", ibrch,
                            args[2].val[0], args[3].val[0]);

                    iface = NINT(args[2].val[0]);
                    iloop = NINT(args[3].val[0]);

                    if (iface >= 1 && iface <= MODL->body[MODL->selbody].nface) {
                        status = EG_getTopology(MODL->body[MODL->selbody].face[iface].eface, &eref,
                                                &oclass, &mtype, data, &nloops, &eloops, &senses);
                        CHECK_STATUS(EG_getTopology);

                        if (iloop >= 1 && iloop <= nloops) {
                            status = EG_getTopology(eloops[iloop-1], &eref,
                                                    &oclass, &mtype, data, &nedges, &eedges, &senses);
                            CHECK_STATUS(EG_getTopology);

                            MODL->seltype = 1;
                            MODL->selsize = nedges;

                            FREE(  MODL->sellist);
                            MALLOC(MODL->sellist, int, MODL->selsize);

                            for (i = 0; i < nedges; i++) {
                                iedge = status = EG_indexBodyTopo(MODL->body[MODL->selbody].ebody, eedges[i]);
                                CHECK_STATUS(EG_indexBodyTopo);

                                MODL->sellist[i] = iedge;
                            }
                        } else {
                            status = OCSM_ILLEGAL_VALUE;
                            signalError(MODL, status,
                                        "SELECT specified nonexistant Loop for Face %d", iface);
                            goto next_branch;
                        }
                    } else {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Face");
                        goto next_branch;
                    }
                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_edge);
                }

            /* "select node ..." */
            } else if (strcmp(args[1].str, "node") == 0 || strcmp(args[1].str, "NODE") == 0) {
                if (MODL->selbody < 0) {
                    SPRINT1x(1, "    executing [%4d] select: ", ibrch);
                    for (iarg = 1; iarg <= MODL->brch[ibrch].narg; iarg++) {
                        if (args[iarg].nval > 0) {
                            SPRINT1x(1, "  %11.5f",  args[iarg].val[0]);
                        } else {
                            SPRINT1x(1, "  %s",      args[iarg].str);
                        }
                    }
                    SPRINT0(1, " ");

                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT NODE specified nonexistant Body");
                    goto next_branch;

                /* "node" */
                } else if (MODL->brch[ibrch].narg == 1) {
                    SPRINT1(1, "    executing [%4d] select:   node", ibrch);

                    MODL->seltype = 0;
                    MODL->selsize = MODL->body[MODL->selbody].nnode;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                        MODL->sellist[inode-1] = inode;
                    }

                /* "node inode" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    SPRINT2(1, "    executing [%4d] select:   node  %d", ibrch,
                            NINT(args[2].val[0]));

                    if (NINT(args[2].val[0]) >= 1 && NINT(args[2].val[0]) <= MODL->body[MODL->selbody].nnode) {
                        MODL->seltype = 0;
                        MODL->selsize = 1;

                        FREE(  MODL->sellist);
                        MALLOC(MODL->sellist, int, MODL->selsize);
                        MODL->sellist[0] = NINT(args[2].val[0]);
                    } else {
                        status = OCSM_NODE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Node");
                        goto next_branch;
                    }

                /* "node x y z" */
                } else if (MODL->brch[ibrch].narg == 4) {
                    SPRINT4(1, "    executing [%4d] select:   node  %11.5f  %11.5f  %11.5f", ibrch,
                            args[2].val[0], args[3].val[0], args[4].val[0]);

                    MODL->seltype = 0;
                    MODL->selsize = 1;

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MODL->selsize);
                    MODL->sellist[0] = 1;
                    dbest = SQR(MODL->body[MODL->selbody].node[1].x-args[2].val[0])
                          + SQR(MODL->body[MODL->selbody].node[1].y-args[3].val[0])
                          + SQR(MODL->body[MODL->selbody].node[1].z-args[4].val[0]);

                    for (inode = 2;  inode <= MODL->body[MODL->selbody].nnode; inode++) {
                         dtest = SQR(MODL->body[MODL->selbody].node[inode].x-args[2].val[0])
                               + SQR(MODL->body[MODL->selbody].node[inode].y-args[3].val[0])
                               + SQR(MODL->body[MODL->selbody].node[inode].z-args[4].val[0]);
                         if (dtest < dbest) {
                             MODL->sellist[0] = inode;
                             dbest = dtest;
                         }
                    }

                /* "node xmin xmax ymin ymax zmin zmax" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 1 && args[3].nval == 1 &&
                                                          args[4].nval == 1 && args[5].nval == 1 &&
                                                          args[6].nval == 1 && args[7].nval == 1   ) {
                    SPRINT7(1, "    executing [%4d] select:   node  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f", ibrch,
                            args[2].val[0], args[3].val[0], args[4].val[0],
                            args[5].val[0], args[6].val[0], args[7].val[0]);

                            MODL->seltype = 0;
                    MODL->selsize = 0;

                    for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                        status = EG_getBoundingBox(MODL->body[MODL->selbody].node[inode].enode, bbox);
                        CATCH_STATUS(EG_getBoundingBox);

                        if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                            bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                            bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                            MODL->selsize++;
                        }
                    }

                    FREE(  MODL->sellist);
                    MALLOC(MODL->sellist, int, MAX(MODL->selsize, 1));
                    if (MODL->selsize == 0) {
                        MODL->sellist[0] = -1;

                        status = OCSM_NODE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Node");
                        goto next_branch;
                    } else {
                        MODL->selsize = 0;

                        for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                            status = EG_getBoundingBox(MODL->body[MODL->selbody].node[inode].enode, bbox);
                            CATCH_STATUS(EG_getBoundingBox);

                            if (bbox[0] >= args[2].val[0] && bbox[3] <= args[3].val[0] &&
                                bbox[1] >= args[4].val[0] && bbox[4] <= args[5].val[0] &&
                                bbox[2] >= args[6].val[0] && bbox[5] <= args[7].val[0]   ) {
                                MODL->sellist[MODL->selsize] = inode;
                                MODL->selsize++;
                            }
                        }
                    }

                /* "node attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    SPRINT7(1, "    executing [%4d] select:   node  %s  %s  %s  %s  %s  %s", ibrch,
                            args[2].str, args[3].str, args[4].str, args[5].str, args[6].str, args[7].str);

                    MODL->seltype = 0;
                    MODL->selsize = 0;

                    FREE(  MODL->sellist);

                    for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                        status = EG_attributeNum(MODL->body[MODL->selbody].node[inode].enode, &nattr);
                        CHECK_STATUS(EG_attributeNum);

                        match1 = 0;
                        match2 = 0;
                        match3 = 0;

                        for (iattr = 1; iattr <= nattr; iattr++) {
                            status = EG_attributeGet(MODL->body[MODL->selbody].node[inode].enode,
                                                     iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeGet);

                            if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                            }

                            if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                            }

                            if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                            }
                        }

                        if (match1 == 1 && match2 == 1 && match3 == 1) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = inode;
                        }
                    }

                    if (MODL->selsize == 0) {
                        status = OCSM_NODE_NOT_FOUND;
                        signalError(MODL, status,
                                    "SELECT specified nonexistant Node");
                        goto next_branch;
                    }
                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_node);
                }

            /* "select add ..." */
            } else if (strcmp(args[1].str, "add") == 0 || strcmp(args[1].str, "ADD") == 0) {
                if (MODL->selbody < 0) {
                    SPRINT1x(1, "    executing [%4d] select: ", ibrch);
                    for (iarg = 1; iarg <= MODL->brch[ibrch].narg; iarg++) {
                        if (args[iarg].nval > 0) {
                            SPRINT1x(1, "  %11.5f",  args[iarg].val[0]);
                        } else {
                            SPRINT1x(1, "  %s",      args[iarg].str);
                        }
                    }
                    SPRINT0(1, " ");

                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT ADD specified nonexistant Body");
                    goto next_branch;

                } else if (MODL->seltype != 0 && MODL->seltype != 1 && MODL->seltype != 2) {
                    SPRINT1x(1, "    executing [%4d] select: ", ibrch);
                    for (iarg = 1; iarg <= MODL->brch[ibrch].narg; iarg++) {
                        if (args[iarg].nval > 0) {
                            SPRINT1x(1, "  %11.5f",  args[iarg].val[0]);
                        } else {
                            SPRINT1x(1, "  %s",      args[iarg].str);
                        }
                    }
                    SPRINT0(1, " ");

                    status = OCSM_ILLEGAL_ARGUMENT;
                    signalError(MODL, status,
                                "SELECT ADD must follow SELECT NODE, EDGE, or FACE");
                    goto next_branch;

                /* "add iface" and seltype==2 */
                } else if (MODL->brch[ibrch].narg == 2 && MODL->seltype == 2) {
                    SPRINT2(1, "    executing [%4d] select:    add  %d", ibrch,
                            NINT(args[2].val[0]));

                    iface = NINT(args[2].val[0]);

                    if (iface >= 1 && iface <= MODL->body[MODL->selbody].nface) {
                        (MODL->selsize)++;
                        RALLOC(MODL->sellist, int, MODL->selsize);

                        MODL->sellist[MODL->selsize-1] = iface;
                    } else {
                        status = OCSM_FACE_NOT_FOUND;
                        signalError(MODL, status,
                                    "Face not found");
                        goto next_branch;
                    }

                /* "add iedge" and seltype==1 */
                } else if (MODL->brch[ibrch].narg == 2 && MODL->seltype == 1) {
                    SPRINT2(1, "    executing [%4d] select:    add  %d", ibrch,
                            NINT(args[2].val[0]));

                    iedge = NINT(args[2].val[0]);

                    if (iedge >= 1 && iedge <= MODL->body[MODL->selbody].nedge) {
                        (MODL->selsize)++;
                        RALLOC(MODL->sellist, int, MODL->selsize);

                        MODL->sellist[MODL->selsize-1] = iedge;
                    } else {
                        status = OCSM_EDGE_NOT_FOUND;
                        signalError(MODL, status,
                                    "Edge not found");
                        goto next_branch;
                    }

                /* "add inode" and seltype==0 */
                } else if (MODL->brch[ibrch].narg == 2 && MODL->seltype == 0) {
                    SPRINT2(1, "    executing [%4d] select:    add  %d", ibrch,
                            NINT(args[2].val[0]));

                    inode = NINT(args[2].val[0]);

                    if (inode >= 1 && inode <= MODL->body[MODL->selbody].nnode) {
                        (MODL->selsize)++;
                        RALLOC(MODL->sellist, int, MODL->selsize);

                        MODL->sellist[MODL->selsize-1] = inode;
                    } else {
                        status = OCSM_NODE_NOT_FOUND;
                        signalError(MODL, status,
                                    "Node not found");
                        goto next_branch;
                    }

                /* "add attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    SPRINT6(1, "    executing [%4d] select:   add   %d  %d  %d  %d  %d", ibrch,
                            NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]),
                            NINT(args[5].val[0]), NINT(args[6].val[0]));

                    if (MODL->seltype == 2) {
                        for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                            match1 = 0;
                            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                                if (MODL->sellist[ilist] == iface) {
                                    match1 = 1;
                                    break;
                                }
                            }
                            if (match1 == 1) continue;

                            status = EG_attributeNum(MODL->body[MODL->selbody].face[iface].eface, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].face[iface].eface,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                    match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                    match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                    match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                (MODL->selsize)++;
                                RALLOC(MODL->sellist, int, MODL->selsize);

                                MODL->sellist[MODL->selsize-1] = iface;
                            }
                        }
                    } else if (MODL->seltype == 1) {
                        for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                            match1 = 0;
                            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                                if (MODL->sellist[ilist] == iedge) {
                                    match1 = 1;
                                    break;
                                }
                            }
                            if (match1 == 1) continue;

                            status = EG_attributeNum(MODL->body[MODL->selbody].edge[iedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                    match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                    match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                    match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                (MODL->selsize)++;
                                RALLOC(MODL->sellist, int, MODL->selsize);

                                MODL->sellist[MODL->selsize-1] = iedge;
                            }
                        }
                    } else if (MODL->seltype == 0) {
                        for (inode = 1; inode <= MODL->body[MODL->selbody].nnode; inode++) {
                            match1 = 0;
                            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                                if (MODL->sellist[ilist] == inode) {
                                    match1 = 1;
                                    break;
                                }
                            }
                            if (match1 == 1) continue;

                            status = EG_attributeNum(MODL->body[MODL->selbody].node[inode].enode, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].node[inode].enode,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                    match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                    match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                    match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                (MODL->selsize)++;
                                RALLOC(MODL->sellist, int, MODL->selsize);

                                MODL->sellist[MODL->selsize-1] = inode;
                            }
                        }
                    }

                /* "add ibody1 iford1 iseq=1" and seltype==2 */
                } else if ( MODL->seltype == 2                                         &&
                           (MODL->brch[ibrch].narg == 3 || MODL->brch[ibrch].narg == 4)  ) {
                    if (MODL->brch[ibrch].narg == 3) {
                        SPRINT3(1, "    executing [%4d] select:   add   %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]));
                    } else {
                        SPRINT4(1, "    executing [%4d] select:   add   %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]));
                    }

                    if (MODL->brch[ibrch].narg == 3) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[4].val[0]);
                    }

                    for (iface = 1; iface <= MODL->body[MODL->selbody].nface; iface++) {
                        match1 = 0;
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            if (MODL->sellist[ilist] == iface) {
                                match1 = 1;
                                break;
                            }
                        }
                        if (match1 == 1) continue;

                        status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                 "_faceID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                            (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                                                                          iseq == tempIlist[2]   ) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iface;
                        }
                    }

                /* "add ibody1 iford1 ibody2 iford2 iseq=1" amd seltype==1 */
                } else if ( MODL->seltype == 1                                         &&
                           (MODL->brch[ibrch].narg == 5 || MODL->brch[ibrch].narg == 6)  ) {
                    if (MODL->brch[ibrch].narg == 5) {
                        SPRINT5(1, "    executing [%4d] select:   add   %d  %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]),
                                NINT(args[5].val[0]));
                    } else {
                        SPRINT6(1, "    executing [%4d] select:   add   %d  %d  %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]),
                                NINT(args[5].val[0]), NINT(args[6].val[0]));
                    }

                    if (MODL->brch[ibrch].narg == 5) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[6].val[0]);
                    }

                    for (iedge = 1; iedge <= MODL->body[MODL->selbody].nedge; iedge++) {
                        match1 = 0;
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            if (MODL->sellist[ilist] == iedge) {
                                match1 = 1;
                                break;
                            }
                        }
                        if (match1 == 1) continue;

                        status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                 "_edgeID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CATCH_STATUS(EG_attributeRet);

                        if        ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                                   (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                                   (NINT(args[4].val[0]) == 0 || NINT(args[4].val[0]) == tempIlist[2]) &&
                                   (NINT(args[5].val[0]) == 0 || NINT(args[5].val[0]) == tempIlist[3]) &&
                                                                                 iseq == tempIlist[4]   ) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iedge;
                        } else if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[2]) &&
                                   (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[3]) &&
                                   (NINT(args[4].val[0]) == 0 || NINT(args[4].val[0]) == tempIlist[0]) &&
                                   (NINT(args[5].val[0]) == 0 || NINT(args[5].val[0]) == tempIlist[1]) &&
                                                                                 iseq == tempIlist[4]   ) {
                            (MODL->selsize)++;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            MODL->sellist[MODL->selsize-1] = iedge;
                        }
                    }

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_node);
                }

            /* "select sub ..." */
            } else if (strcmp(args[1].str, "sub") == 0 || strcmp(args[1].str, "SUB") == 0) {
                if (MODL->selbody < 0) {
                    SPRINT1x(1, "    executing [%4d] select: ", ibrch);
                    for (iarg = 1; iarg <= MODL->brch[ibrch].narg; iarg++) {
                        if (args[iarg].nval > 0) {
                            SPRINT1x(1, "  %11.5f",  args[iarg].val[0]);
                        } else {
                            SPRINT1x(1, "  %s",      args[iarg].str);
                        }
                    }
                    SPRINT0(1, " ");

                    status = OCSM_BODY_NOT_FOUND;
                    signalError(MODL, status,
                                "SELECT SUB specified nonexistant Body");
                    goto next_branch;

                } else if (MODL->seltype != 0 && MODL->seltype != 1 && MODL->seltype != 2) {
                    SPRINT1x(1, "    executing [%4d] select: ", ibrch);
                    for (iarg = 1; iarg <= MODL->brch[ibrch].narg; iarg++) {
                        if (args[iarg].nval > 0) {
                            SPRINT1x(1, "  %11.5f",  args[iarg].val[0]);
                        } else {
                            SPRINT1x(1, "  %s",      args[iarg].str);
                        }
                    }
                    SPRINT0(1, " ");

                    status = OCSM_ILLEGAL_ARGUMENT;
                    signalError(MODL, status,
                                "SELECT SUB must follow SELECT node, edge, or face");
                    goto next_branch;

                /* "sub ient" */
                } else if (MODL->brch[ibrch].narg == 2) {
                    SPRINT2(1, "    executing [%4d] select:   sub   %d", ibrch,
                            NINT(args[2].val[0]));

                    ient   = NINT(args[2].val[0]);
                    match1 = 0;
                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        if (MODL->sellist[ilist] == ient) {
                            for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                MODL->sellist[jlist] = MODL->sellist[jlist+1];
                            }

                            (MODL->selsize)--;
                            RALLOC(MODL->sellist, int, MODL->selsize);

                            match1++;
                            break;
                        }
                    }

                    if (match1 == 0) {
                        status = OCSM_ILLEGAL_VALUE;
                        signalError(MODL, status,
                                    "SELECT SUB must specify a value in @sellist");
                        goto next_branch;
                    }

                /* "sub attrName1 attrValue1 attrName2=$* attrValue2=$* attrName3=$* attrValue3=$*" */
                } else if (MODL->brch[ibrch].narg == 7 && args[2].nval == 0 &&
                                                          args[4].nval == 0 &&
                                                          args[6].nval == 0   ) {
                    SPRINT7(1, "    executing [%4d] select:   sub   %s  %s  %s  %s  %s  %s", ibrch,
                            args[2].str, args[3].str, args[4].str, args[5].str, args[6].str, args[7].str);

                    if (MODL->seltype == 2) {
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            iface = MODL->sellist[ilist];

                            status = EG_attributeNum(MODL->body[MODL->selbody].face[iface].eface, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].face[iface].eface,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                    match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                    match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                    match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                    MODL->sellist[jlist] = MODL->sellist[jlist+1];
                                }
                                ilist--;

                                (MODL->selsize)--;
                                RALLOC(MODL->sellist, int, MODL->selsize);
                            }
                        }
                    } else if (MODL->seltype == 1) {
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            iedge = MODL->sellist[ilist];

                            status = EG_attributeNum(MODL->body[MODL->selbody].edge[iedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                    match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                    match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                    match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                    MODL->sellist[jlist] = MODL->sellist[jlist+1];
                                }
                                ilist--;

                                (MODL->selsize)--;
                                RALLOC(MODL->sellist, int, MODL->selsize);
                            }
                        }
                    } else if (MODL->seltype == 0) {
                        for (ilist = 0; ilist < MODL->selsize; ilist++) {
                            inode = MODL->sellist[ilist];

                            status = EG_attributeNum(MODL->body[MODL->selbody].node[inode].enode, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            match1 = 0;
                            match2 = 0;
                            match3 = 0;

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[MODL->selbody].node[inode].enode,
                                                         iattr, &aname, &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                                CHECK_STATUS(EG_attributeGet);

                                if (match1 == 0 && matches((char*)args[2].str, aname) == 1) {
                                    match1 = matchValue(args[3], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match2 == 0 && matches((char*)args[4].str, aname) == 1) {
                                    match2 = matchValue(args[5], itype, nlist, tempIlist, tempRlist, tempClist);
                                }

                                if (match3 == 0 && matches((char*)args[6].str, aname) == 1) {
                                    match3 = matchValue(args[7], itype, nlist, tempIlist, tempRlist, tempClist);
                                }
                            }

                            if (match1 == 1 && match2 == 1 && match3 == 1) {
                                for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                    MODL->sellist[jlist] = MODL->sellist[jlist+1];
                                }
                                ilist--;

                                (MODL->selsize)--;
                                RALLOC(MODL->sellist, int, MODL->selsize);
                            }
                        }
                    }

                /* "sub ibody1 iford1 iseq=1" and seltype==2 */
                } else if ( MODL->seltype == 2                                         &&
                           (MODL->brch[ibrch].narg == 3 || MODL->brch[ibrch].narg == 4)  ) {
                    if (MODL->brch[ibrch].narg == 3) {
                        SPRINT3(1, "    executing [%4d] select:   sub   %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]));
                    } else {
                        SPRINT4(1, "    executing [%4d] select:   sub   %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]));
                    }

                    if (MODL->brch[ibrch].narg == 3) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[4].val[0]);
                    }

                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        iface = MODL->sellist[ilist];

                        status = EG_attributeRet(MODL->body[MODL->selbody].face[iface].eface,
                                                 "_faceID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                            (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                                                                          iseq == tempIlist[2]   ) {
                            for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                MODL->sellist[jlist] = MODL->sellist[jlist+1];
                            }
                            ilist--;

                            (MODL->selsize)--;
                            RALLOC(MODL->sellist, int, MODL->selsize);
                        }
                    }

                /* "sub ibody1 iford1 ibody2 iford2 iseq=1" and seltype==1 */
                } else if (MODL->seltype == 1                                         &&
                          (MODL->brch[ibrch].narg == 5 || MODL->brch[ibrch].narg == 6)  ) {
                    if (MODL->brch[ibrch].narg == 5) {
                        SPRINT5(1, "    executing [%4d] select:   sub   %d  %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]),
                                NINT(args[5].val[0]));
                    } else {
                        SPRINT6(1, "    executing [%4d] select:   sub   %d  %d  %d  %d  %d", ibrch,
                                NINT(args[2].val[0]), NINT(args[3].val[0]), NINT(args[4].val[0]),
                                NINT(args[5].val[0]), NINT(args[6].val[0]));
                    }

                    if (MODL->brch[ibrch].narg == 5) {
                        iseq = 1;
                    } else {
                        iseq = NINT(args[6].val[0]);
                    }

                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        iedge = MODL->sellist[ilist];

                        status = EG_attributeRet(MODL->body[MODL->selbody].edge[iedge].eedge,
                                                 "_edgeID", &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        if        ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[0]) &&
                                   (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[1]) &&
                                   (NINT(args[4].val[0]) == 0 || NINT(args[4].val[0]) == tempIlist[2]) &&
                                   (NINT(args[5].val[0]) == 0 || NINT(args[5].val[0]) == tempIlist[3]) &&
                                                   iseq == tempIlist[4]   ) {
                            for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                MODL->sellist[jlist] = MODL->sellist[jlist+1];
                            }

                            (MODL->selsize)--;
                            RALLOC(MODL->sellist, int, MODL->selsize);
                        } else if ((NINT(args[2].val[0]) == 0 || NINT(args[2].val[0]) == tempIlist[2]) &&
                                   (NINT(args[3].val[0]) == 0 || NINT(args[3].val[0]) == tempIlist[3]) &&
                                   (NINT(args[4].val[0]) == 0 || NINT(args[4].val[0]) == tempIlist[0]) &&
                                   (NINT(args[5].val[0]) == 0 || NINT(args[5].val[0]) == tempIlist[1]) &&
                                                   iseq == tempIlist[4]   ) {
                            for (jlist = ilist; jlist < MODL->selsize-1; jlist++) {
                                MODL->sellist[jlist] = MODL->sellist[jlist+1];
                            }
                            ilist--;

                            (MODL->selsize)--;
                            RALLOC(MODL->sellist, int, MODL->selsize);
                        }
                    }

                } else {
                    status = OCSM_NOT_ENOUGH_ARGS;
                    CATCH_STATUS(select_node);
                }

            /* "select sort $key" */
            } else if (strcmp(args[1].str, "sort") == 0 || strcmp(args[1].str, "SORT") == 0) {
                SPRINT2(1, "    executing [%4d] select:   sort  %s", ibrch,
                        args[2].str);

                if (MODL->selsize <= 0 || MODL->seltype < 0 || MODL->seltype > 2) {
                    SPRINT0(0, "ERROR:: there is nothing selected");
                    status = OCSM_NO_SELECTION;
                    CATCH_STATUS(select);
                }

                /* make a list of the properties */
                MALLOC(props, double, MODL->selsize);

                if        (MODL->seltype == 0) {
                    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, NODE, &nobjs, &eobjs);
                } else if (MODL->seltype == 1) {
                    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, EDGE, &nobjs, &eobjs);
                } else if (MODL->seltype == 2) {
                    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, FACE, &nobjs, &eobjs);
                }
                CATCH_STATUS(select);
                SPLINT_CHECK_FOR_NULL(eobjs);

                for (ilist = 0; ilist < MODL->selsize; ilist++) {
                    ient = MODL->sellist[ilist] - 1;

                    if        (strcmp(args[2].str, "xmin") == 0 || strcmp(args[2].str, "XMIN") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[0];
                    } else if (strcmp(args[2].str, "ymin") == 0 || strcmp(args[2].str, "YMIN") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[1];
                    } else if (strcmp(args[2].str, "zmin") == 0 || strcmp(args[2].str, "ZMIN") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[2];
                    } else if (strcmp(args[2].str, "xmax") == 0 || strcmp(args[2].str, "XMAX") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[3];
                    } else if (strcmp(args[2].str, "ymax") == 0 || strcmp(args[2].str, "YMAX") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[4];
                    } else if (strcmp(args[2].str, "zmax") == 0 || strcmp(args[2].str, "ZMAX") == 0) {
                        status = EG_getBoundingBox(eobjs[ient], data);
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);

                        props[ilist] = data[5];
                    } else if (strcmp(args[2].str, "area") == 0 || strcmp(args[2].str, "AREA") == 0) {
                        if (MODL->seltype == 2) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[1];
                        } else {
                            status = OCSM_ILLEGAL_ARGUMENT;
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);
                        }
                    } else if (strcmp(args[2].str, "length") == 0 || strcmp(args[2].str, "LENGTH") == 0) {
                        if (MODL->seltype == 1) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[1];
                        } else {
                            status = OCSM_ILLEGAL_ARGUMENT;
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);
                        }
                    } else if (strcmp(args[2].str, "xcg") == 0 || strcmp(args[2].str, "XCG") == 0) {
                        if (MODL->seltype != 0) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[2];
                        } else {
                            props[ilist] = MODL->body[MODL->selbody].node[ient+1].x;
                        }
                    } else if (strcmp(args[2].str, "ycg") == 0 || strcmp(args[2].str, "YCG") == 0) {
                        if (MODL->seltype != 0) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[3];
                        } else {
                            props[ilist] = MODL->body[MODL->selbody].node[ient+1].y;
                        }
                    } else if (strcmp(args[2].str, "zcg") == 0 || strcmp(args[2].str, "ZCG") == 0) {
                        if (MODL->seltype != 0) {
                            status = EG_getMassProperties(eobjs[ient], data);
                            if (status != SUCCESS) EG_free(eobjs);
                            CATCH_STATUS(select);

                            props[ilist] = data[4];
                        } else {
                            props[ilist] = MODL->body[MODL->selbody].node[ient+1].z;
                        }
                    } else {
                        status = OCSM_ILLEGAL_ARGUMENT;
                        if (status != SUCCESS) EG_free(eobjs);
                        CATCH_STATUS(select);
                    }
                }

                EG_free(eobjs);

                /* bubble sort */
                for (ipass = 0; ipass < MODL->selsize; ipass++) {
                    nswap = 0;
                    for (ilist = 0; ilist < MODL->selsize-1; ilist++) {
                        if (props[ilist+1] < props[ilist]-EPS06) {
                            iswap                  = MODL->sellist[ilist  ];
                            MODL->sellist[ilist  ] = MODL->sellist[ilist+1];
                            MODL->sellist[ilist+1] = iswap;

                            rswap          = props[ilist  ];
                            props[ilist  ] = props[ilist+1];
                            props[ilist+1] = rswap;

                            nswap++;
                        }
                    }
                    if (nswap == 0) break;
                }

                /* cleanup */
                FREE(props);

            } else {
                status = OCSM_ILLEGAL_ARGUMENT;
                CATCH_STATUS(select);
            }

            /* clear any signals that might have been thrown by str2val */
            MODL->sigCode    =   0;
            MODL->sigMesg[0] = '\0';

            /* update @-parameters (SELECT) */
            status = setupAtPmtrs(MODL, 1);
            CATCH_STATUS(setupAtPmtrs);

            /* put Attributes for OCSM_SELECT on the selected Body/Faces/Edges/Nodes */
            if (MODL->brch[ibrch].nattr > 0) {
                if        (MODL->seltype == 2) {
                    SPLINT_CHECK_FOR_NULL(MODL->sellist);

                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        iface = MODL->sellist[ilist];
                        eface = MODL->body[MODL->selbody].face[iface].eface;

                        SPRINT1(1, "                     putting Branch Attributes on Face %d", iface);

                        status = setEgoAttribute(MODL, ibrch, eface);
                        CATCH_STATUS(setEgoAttribute);

                        status = colorizeFace(MODL, MODL->selbody, iface);
                        CATCH_STATUS(colorizeFace);
                    }
                } else if (MODL->seltype == 1) {
                    SPLINT_CHECK_FOR_NULL(MODL->sellist);

                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        iedge = MODL->sellist[ilist];
                        eedge = MODL->body[MODL->selbody].edge[iedge].eedge;

                        SPRINT1(1, "                     putting Branch Attributes on Edge %d", iedge);

                        status = setEgoAttribute(MODL, ibrch, eedge);
                        CATCH_STATUS(setEgoAttribute);

                        status = colorizeEdge(MODL, MODL->selbody, iedge);
                        CATCH_STATUS(colorizeEdge);
                    }
                } else if (MODL->seltype == 0) {
                    SPLINT_CHECK_FOR_NULL(MODL->sellist);

                    for (ilist = 0; ilist < MODL->selsize; ilist++) {
                        inode = MODL->sellist[ilist];
                        enode = MODL->body[MODL->selbody].node[inode].enode;

                        SPRINT1(1, "                     putting Branch Attributes on Node %d", inode);

                        status = setEgoAttribute(MODL, ibrch, enode);
                        CATCH_STATUS(setEgoAttribute);

                        status = colorizeNode(MODL, MODL->selbody, inode);
                        CATCH_STATUS(colorizeNode);
                    }
                } else {
                    SPRINT0(1, "                    putting Branch Attributes on Body");

                    status = setEgoAttribute(MODL, ibrch, MODL->body[MODL->selbody].ebody);
                    CATCH_STATUS(setEgoAttribute);
                }
            }

        /* execute: "interface $argName $argType default=0" */
        } else if (type == OCSM_INTERFACE) {
            if (args[3].nval == 0) {
                SPRINT4(1, "              [%4d] interface:  %s  %s  %s",
                        ibrch, args[1].str, args[2].str, args[3].str);
            } else {
                SPRINT4(1, "              [%4d] interface:  %s  %s  %11.5f",
                        ibrch, args[1].str, args[2].str, args[3].val[0]);
            }

            /* make sure that the local variable name is not the same
               as a constant or output Parameter */
            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                if        (strcmp(MODL->pmtr[ipmtr].name, args[1].str) == 0 &&
                           MODL->pmtr[ipmtr].type == OCSM_CONPMTR            ) {
                    status = OCSM_PMTR_IS_CONPMTR;
                    signalError(MODL, status,
                                "INTERFACE variable \"%s\" cannot match CONPMTR", args[1].str);
                    goto next_branch;
                } else if (strcmp(MODL->pmtr[ipmtr].name, args[1].str) == 0 &&
                           MODL->pmtr[ipmtr].type == OCSM_OUTPMTR             ) {
                    status = OCSM_PMTR_IS_OUTPMTR;
                    signalError(MODL, status,
                                "INTERFACE variable \"%s\" cannot match OUTPMTR", args[1].str);
                    goto next_branch;
                }
            }

            /* this is skipped because it was processed as part of the UDPRIM
               statement */

        /* execute: "project x y z dx dy dz useEdges=0" */
        } else if (type == OCSM_PROJECT) {
            SPRINT8(1, "    executing [%4d] project:    %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                    ibrch, args[1].val[0], args[2].val[0], args[3].val[0],
                           args[4].val[0], args[5].val[0], args[6].val[0], args[7].val[0]);

            /* get the Bodys on the top of the stack */
            if (nstack < 1) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "PROJECT expects a Body on stack");
                goto next_branch;
            } else {
                ibodyl = stack[nstack-1];
            }

            /* make sure that the current Body has a tessellation */
            status = ocsmTessellate(MODL, ibodyl);
            CHECK_STATUS(ocsmTessellate);

            /* loop through all Triangles in all Faces to find closest projection */
            if (NINT(args[7].val[0]) == 0) {
                ibest = 0;
                tbest = HUGEQ;
                xbest = HUGEQ;
                ybest = HUGEQ;
                zbest = HUGEQ;

                for (iface = 1; iface <= MODL->body[ibodyl].nface; iface++) {
                    status = EG_getTessFace(MODL->body[ibodyl].etess, iface,
                                            &npnt, &xyz, &uv, &ptype, &pindx,
                                            &ntri, &tris, &tric);
                    CATCH_STATUS(EG_getFaceTess);

                    for (itri = 0; itri < ntri; itri++) {
                        u0 = uv[ 2*tris[3*itri  ]-2];
                        v0 = uv[ 2*tris[3*itri  ]-1];
                        x0 = xyz[3*tris[3*itri  ]-3];
                        y0 = xyz[3*tris[3*itri  ]-2];
                        z0 = xyz[3*tris[3*itri  ]-1];
                        u1 = uv[ 2*tris[3*itri+1]-2];
                        v1 = uv[ 2*tris[3*itri+1]-1];
                        x1 = xyz[3*tris[3*itri+1]-3];
                        y1 = xyz[3*tris[3*itri+1]-2];
                        z1 = xyz[3*tris[3*itri+1]-1];
                        u2 = uv[ 2*tris[3*itri+2]-2];
                        v2 = uv[ 2*tris[3*itri+2]-1];
                        x2 = xyz[3*tris[3*itri+2]-3];
                        y2 = xyz[3*tris[3*itri+2]-2];
                        z2 = xyz[3*tris[3*itri+2]-1];

                        mat[0] = x0 - x2;  mat[1] = x1 - x2;  mat[2] = -args[4].val[0];  rhs[0] = args[1].val[0] - x2;
                        mat[3] = y0 - y2;  mat[4] = y1 - y2;  mat[5] = -args[5].val[0];  rhs[1] = args[2].val[0] - y2;
                        mat[6] = z0 - z2;  mat[7] = z1 - z2;  mat[8] = -args[6].val[0];  rhs[2] = args[3].val[0] - z2;

                        status = matsol(mat, rhs, 3, s0s1tt);
                        if (status != SUCCESS) continue;

                        s0 = s0s1tt[0];
                        s1 = s0s1tt[1];
                        tt = s0s1tt[2];

                        if (tt < -EPS06 || s0 < -EPS06 || s1 < -EPS06 || (1-s0-s1) < -EPS06) continue;

                        if (tt < tbest) {
                            ibest  = iface;
                            tbest  = tt;
                            uv_[0] = s0 * (u0 - u2) + s1 * (u1 - u2) + u2;
                            uv_[1] = s0 * (v0 - v2) + s1 * (v1 - v2) + v2;
                            uv_[2] = tt;

                            /* newton iteration to put it on the surface (should usually converge
                               in fewer than 5 iterations) */
                            for (iter = 0; iter < 30; iter++) {
                                status = EG_evaluate(MODL->body[ibodyl].face[iface].eface, uv_, data);
                                CHECK_STATUS(EG_evaluate);

                                /* actually -1.0*residual */
                                rhs[0] = data[0] - (args[1].val[0] + uv_[2] * args[4].val[0]);
                                rhs[1] = data[1] - (args[2].val[0] + uv_[2] * args[5].val[0]);
                                rhs[2] = data[2] - (args[3].val[0] + uv_[2] * args[6].val[0]);

                                if (fabs(rhs[0]) < EPS06 && fabs(rhs[1]) < EPS06 && fabs(rhs[2]) < EPS06) break;

                                mat[0] = -data[3];   mat[1] = -data[6];   mat[2] = args[4].val[0];
                                mat[3] = -data[4];   mat[4] = -data[7];   mat[5] = args[5].val[0];
                                mat[6] = -data[5];   mat[7] = -data[8];   mat[8] = args[6].val[0];

                                status = matsol(mat, rhs, 3, duvt);
                                CHECK_STATUS(matsol);

                                uv_[0] += duvt[0];
                                uv_[1] += duvt[1];
                                uv_[2] += duvt[2];
                            }

                            xbest = data[0];
                            ybest = data[1];
                            zbest = data[2];
                        }
                    }
                }

            /* loop through all segments in all Edges to find closest projection */
            } else {
                ibest = 0;
                tbest = HUGEQ;
                xbest = HUGEQ;
                ybest = HUGEQ;
                zbest = HUGEQ;

                for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {
                    status = EG_getTessEdge(MODL->body[ibodyl].etess, iedge,
                                            &npnt, &xyz, &uv);
                    CATCH_STATUS(EG_getTessEdge);

                    for (ipnt = 1; ipnt < npnt; ipnt++) {
                        u0 = uv[   ipnt-1];
                        x0 = xyz[3*ipnt-3];
                        y0 = xyz[3*ipnt-2];
                        z0 = xyz[3*ipnt-1];
                        u1 = uv[   ipnt  ];
                        x1 = xyz[3*ipnt  ];
                        y1 = xyz[3*ipnt+1];
                        z1 = xyz[3*ipnt+2];

                        mat[0] = x0 - x1;  mat[1] = -args[4].val[0];  rhs[0] = args[1].val[0] - x0;
                        mat[2] = y0 - y1;  mat[3] = -args[5].val[0];  rhs[1] = args[2].val[0] - y0;
                        mat[4] = z0 - z1;  mat[5] = -args[6].val[0];  rhs[2] = args[3].val[0] - z0;

                        status = solsvd(mat, rhs, 3, 2, sval, s0s1tt);
                        if (status != SUCCESS) continue;

                        s0 = s0s1tt[0];
                        tt = s0s1tt[1];

                        if (tt < 0 || s0 < 0 || s0 > 1) continue;

                        if (tt < tbest) {
                            ibest  = iedge;
                            tbest  = tt;
                            uv_[0] = (1 - tt) * u0 + tt * u1;
                            uv_[1] = tt;

                            /* newton iteration to put it on the curve (should usually converge
                               in fewer than 5 iterations) */
                            for (iter = 0; iter < 30; iter++) {
                                status = EG_evaluate(MODL->body[ibodyl].edge[iedge].eedge, uv_, data);
                                CHECK_STATUS(EG_evaluate);

                                res[0] = data[0] - (args[1].val[0] + uv_[1] * args[4].val[0]);
                                res[1] = data[1] - (args[2].val[0] + uv_[1] * args[5].val[0]);
                                res[2] = data[2] - (args[3].val[0] + uv_[1] * args[6].val[0]);

                                if (fabs(res[0]) < EPS06 && fabs(res[1]) < EPS06 && fabs(res[2]) < EPS06) break;

                                mat[0] =  data[3]        * data[3]        + data[4]        * data[4]        + data[5]        * data[5];
                                mat[1] = -data[3]        * args[4].val[0] - data[4]        * args[5].val[0] - data[5]        * args[6].val[0];
                                mat[2] =  mat[1];
                                mat[3] =  args[4].val[0] * args[4].val[0] + args[5].val[0] * args[5].val[0] + args[6].val[0] * args[6].val[0];

                                rhs[0] = -data[3]        * res[0]         - data[4]        * res[1]         - data[5]        * res[2];
                                rhs[1] =  args[4].val[0] * res[0]         + args[5].val[0] * res[1]         + args[6].val[0] * res[2];

                                status = matsol(mat, rhs, 2, duvt);
                                CHECK_STATUS(matsol);

                                uv_[0] += duvt[0];
                                uv_[1] += duvt[1];
                            }

                            xbest = data[0];
                            ybest = data[1];
                            zbest = data[2];
                        }
                    }
                }
            }

            /* if any hits, store the results of the best in the @-parameters */
            if (ibest > 0) {
                if (NINT(args[7].val[0]) == 0) {
                    status = ocsmFindPmtr(MODL, "@iface", OCSM_LOCALVAR, 1, 1, &AT_iface);
                    CATCH_STATUS(ocsmFindPmtr);

                    status = ocsmSetValuD(MODL, AT_iface, 1, 1, (double)ibest);
                    CATCH_STATUS(ocsmSetValuD);
                } else {
                    status = ocsmFindPmtr(MODL, "@iedge", OCSM_LOCALVAR, 1, 1, &AT_iedge);
                    CATCH_STATUS(ocsmFindPmtr);

                    status = ocsmSetValuD(MODL, AT_iedge, 1, 1, (double)ibest);
                    CATCH_STATUS(ocsmSetValuD);
                }

                status = ocsmFindPmtr(MODL, "@xcg", OCSM_LOCALVAR, 1, 1, &AT_xcg);
                CATCH_STATUS(ocsmFindPmtr);

                status = ocsmSetValuD(MODL, AT_xcg, 1, 1, xbest);
                CATCH_STATUS(ocsmSetValuD);

                status = ocsmFindPmtr(MODL, "@ycg", OCSM_LOCALVAR, 1, 1, &AT_ycg);
                CATCH_STATUS(ocsmFindPmtr);

                status = ocsmSetValuD(MODL, AT_ycg, 1, 1, ybest);
                CATCH_STATUS(ocsmSetValuD);

                status = ocsmFindPmtr(MODL, "@zcg", OCSM_LOCALVAR, 1, 1, &AT_zcg);
                CATCH_STATUS(ocsmFindPmtr);

                status = ocsmSetValuD(MODL, AT_zcg, 1, 1, zbest);
                CATCH_STATUS(ocsmSetValuD);

                /* do not recompute mass properties (to overwrite the values that we just set) */
                MODL->hasMPs = 1;

            /* otherwise, return an error */
            } else {
                status = OCSM_FACE_NOT_FOUND;
                signalError(MODL, status,
                            "no Face was found");
                goto next_branch;
            }

        /* execute: "macbeg imacro" */
        } else if (type == OCSM_MACBEG) {
            SPRINT2(1, "    executing [%4d] macbeg:     %11.5f",
                    ibrch, args[1].val[0]);

            /* determine the storage location */
            imacro = NINT(args[1].val[0]);

            if (imacro < 1 || imacro > MAX_NUM_MACROS) {
                status = OCSM_ILLEGAL_MACRO_INDEX;
                CATCH_STATUS(macbeg);
            }

            /* an error if storage location is not empty */
            if (macros[imacro] > 0) {
                status = OCSM_STORAGE_ALREADY_USED;
                CATCH_STATUS(macbeg);
            }


            macros[imacro] = ibrch;

            SPRINT2(1, "                          Storing Branch %4d in storage %d", ibrch, imacro);

        /* execute: "macend" */
        } else if (type == OCSM_MACEND) {
            SPRINT1(1, "    executing [%4d] macend:",
                    ibrch);

            npatn--;
            ibrch = patn[npatn].iend;

        /* execute: "recall imacro" */
        } else if (type == OCSM_RECALL) {
            SPRINT2(1, "    executing [%4d] recall:     %11.5f",
                    ibrch, args[1].val[0]);

            /* determine the storage location */
            imacro = NINT(args[1].val[0]);

            if (imacro < 1 || imacro > MAX_NUM_MACROS) {
                status = OCSM_ILLEGAL_MACRO_INDEX;
                CATCH_STATUS(recall);
            } else if (macros[imacro] <= 0) {
                status = OCSM_NOTHING_PREVIOUSLY_STORED;
                CATCH_STATUS(recall);
            }

            if (npatn < MAX_NESTING) {
                patn[npatn].itype = OCSM_RECALL;
                patn[npatn].ibeg  = macros[imacro];
                patn[npatn].iend  = ibrch;
                patn[npatn].ncopy =  1;
                patn[npatn].icopy = +1;
                patn[npatn].ipmtr = -1;
                npatn++;
            } else {
                status = OCSM_NESTED_TOO_DEEPLY;
                signalError(MODL, status,
                            "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
            }

            /* start executing just after the macbeg */
            ibrch = macros[imacro];

            SPRINT1(1, "                          Entering storage %d", imacro);

        /* execute: "store $name index=0 keep=0" */
        } else if (type == OCSM_STORE) {
            SPRINT4(1, "    executing [%4d] store:      %s  %11.5f  %11.5f",
                    ibrch, args[1].str, args[2].val[0], args[3].val[0]);

            /* if $name is . (dot), pop one Body off the stack */
            if (strcmp(args[1].str, ".") == 0) {
                if (args[2].val[0] != 0 || args[3].val[0] != 0) {
                    SPRINT0(1, "WARNING:: index and keep ignored since $name=.");
                    (MODL->nwarn)++;
                }

                nstack--;
                SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack]);

                if (stack[nstack] == 0) {
                    status = setupAtPmtrs(MODL, -1);

                    goto next_branch;
                }

            /* if $name is .. (dot-dot), pop all Bodys off stack back to the Mark
               (or until stack is empty) */
            } else  if (strcmp(args[1].str, "..") == 0) {
                if (args[2].val[0] != 0 || args[3].val[0] != 0) {
                    SPRINT0(1, "WARNING:: index and keep ignored since $name=..");
                    (MODL->nwarn)++;
                }

                while (nstack > 0) {
                    if (stack[nstack-1] == 0) {
                        nstack--;
                        break;
                    } else {
                        nstack--;
                        SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack]);
                    }
                }

            /* if $name is ... (ellipsis), pop all Bodys off stack */
            } else if (strcmp(args[1].str, "...") == 0) {
                if (args[2].val[0] != 0 || args[3].val[0] != 0) {
                    SPRINT0(1, "WARNING:: index and keep ignored since $name=...");
                    (MODL->nwarn)++;
                }

                while (nstack > 0) {
                    nstack--;
                    SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack]);
                }

            } else {
                /* find the Body on the top of the stack */
                if (nstack < 1) {
                    status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                    signalError(MODL, status,
                                "STORE expects a Body on the stack");
                    goto next_branch;
                } else {
                    ibodyl = stack[nstack-1];
                }

                /* if ibodyl is 0, it is a mark, so return an error */
                if (ibodyl == 0) {
                    status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                    signalError(MODL, status,
                                "STORE cannot be applied to a MARK");
                    goto next_branch;
                } else {
                    igroup = MODL->body[ibodyl].igroup;
                }

                /* if index is negative, find first unused index */
                if (NINT(args[2].val[0]) < 0) {
                    if (MODL->stor == NULL) {
                        kstor = 0;
                    } else {
                        for (kstor = 0; kstor <= MODL->nstor; kstor++) {
                            icount = 0;
                            for (jstor = 0; jstor < MODL->nstor; jstor++) {
                                if (strcmp(args[1].str, MODL->stor[jstor].name) == 0 &&
                                    kstor == MODL->stor[jstor].index    ) {
                                    icount++;
                                    break;
                                }
                            }
                            if (icount == 0) {
                                SPRINT2(1, "INFO:: storage %s (%d) begin used",
                                        args[1].str, kstor);
                                break;
                            }
                        }
                    }
                } else {
                    kstor = NINT(args[2].val[0]);
                }

                /* see if name/index is already used */
                istor = -1;
                for (jstor = 0; jstor < MODL->nstor; jstor++) {
                    SPLINT_CHECK_FOR_NULL(MODL->stor);

                    if (strcmp(args[1].str, MODL->stor[jstor].name) == 0 &&
                        kstor ==  MODL->stor[jstor].index                  ) {
                        istor = jstor;
                        SPRINT2(1, "WARNING:: storage %s (%d) is being overwritten",
                                MODL->stor[jstor].name, MODL->stor[jstor].index);
                        (MODL->nwarn)++;
                        break;
                    }
                }

                /* make a list to keep track of the Bodys that should be stored */
                MALLOC(iblist, int, nstack);

                nblist = 0;
                while (nstack > 0) {
                    ibodyl = stack[--nstack];
                    if (ibodyl <= 0) {
                        if (nstack < MAX_STACK_SIZE) {
                            nstack++;
                        } else {
                            status = OCSM_TOO_MANY_BODYS_ON_STACK;
                            signalError(MODL, status,
                                        "Too many Bodys on Stack");
                            goto cleanup;
                        }
                        break;
                    }

                    if (MODL->body[ibodyl].igroup != igroup) {
                        if (nstack < MAX_STACK_SIZE) {
                            nstack++;
                        } else {
                            status = OCSM_TOO_MANY_BODYS_ON_STACK;
                            signalError(MODL, status,
                                        "Too many Bodys on Stack");
                            goto cleanup;
                        }
                        break;
                    }

                    iblist[nblist++] = ibodyl;
                }

                /* if storage does not exist, create it now */
                if (istor < 0) {
                    istor = MODL->nstor;

                    (MODL->nstor)++;
                    RALLOC(MODL->stor, stor_T, MODL->nstor);

                    STRNCPY(MODL->stor[istor].name, args[1].str, MAX_NAME_LEN);
                    MODL->stor[istor].index = kstor;
                    MODL->stor[istor].nbody = nblist;
                    MODL->stor[istor].ibody = NULL;
                    MODL->stor[istor].ebody = NULL;

                    MALLOC(MODL->stor[istor].ibody, int, MODL->stor[istor].nbody);
                    MALLOC(MODL->stor[istor].ebody, ego, MODL->stor[istor].nbody);

                /* if it already exists, update the info */
                } else {
                    SPLINT_CHECK_FOR_NULL(MODL->stor);

                    MODL->stor[istor].nbody = nblist;

                    RALLOC(MODL->stor[istor].ibody, int, MODL->stor[istor].nbody);
                    RALLOC(MODL->stor[istor].ebody, ego, MODL->stor[istor].nbody);
                }

                /* if the keep flag is set, restore the stack */
                if (NINT(args[3].val[0]) == 1) {
                    if (nstack+nblist < MAX_STACK_SIZE) {
                        nstack += nblist;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }

                /* save the Body info */
                SPLINT_CHECK_FOR_NULL(MODL->stor);

                for (i = MODL->stor[istor].nbody-1; i >= 0; i--) {
                    ibodyl = iblist[i];

                    MODL->stor[istor].ibody[i] = ibodyl;
                    MODL->stor[istor].ebody[i] = MODL->body[ibodyl].ebody;

                    SPRINT1(1, "                          Body   %4d stored", ibodyl);
                }

                FREE(iblist);
            }

        /* execute: "patbeg $pmtrName ncopy" */
        } else if (type == OCSM_PATBEG) {
            SPRINT3(1, "    executing [%4d] patbeg:         %s  %11.5f",
                    ibrch, args[1].str, args[2].val[0]);

            if (npatn < MAX_NESTING) {
                patn[npatn].itype = OCSM_PATBEG;
                patn[npatn].ibeg  = ibrch;
                patn[npatn].iend  = -1;
                patn[npatn].ncopy = NINT(args[2].val[0]);
                patn[npatn].icopy =  1;
                patn[npatn].ipmtr = -1;
            } else {
                status = OCSM_NESTED_TOO_DEEPLY;
                signalError(MODL, status,
                            "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                CATCH_STATUS(patbeg);
            }

            /* store info about this pattern */
            /* find matching patend */
            icount = 1;
            for (ibrchl = ibrch+1; ibrchl <= MODL->nbrch; ibrchl++) {
                if        (MODL->brch[ibrchl].type == OCSM_PATBEG) {
                    icount++;
                } else if (MODL->brch[ibrchl].type == OCSM_PATEND) {
                    icount--;

                    if (icount == 0) {
                        patn[npatn].iend = ibrchl;
                        break;
                    }
                }
            }

            /* find the pmtrName */
            status = ocsmFindPmtr(MODL, args[1].str, OCSM_LOCALVAR, 1, 1,
                                  &(patn[npatn].ipmtr));
            CATCH_STATUS(ocsmFindPmtr);

            /* if no copies are required, jump to Branch after patend */
            if (patn[npatn].ncopy < 1) {
                if (patn[npatn].iend > patn[npatn].ibeg) {
                    ibrch = patn[npatn].iend;
                } else {
                    break;    /* used if no matching patend */
                }

            /* otherwise increment the number of patterns and continue */
            } else {
                irow = icol = 1;

                status = ocsmSetValuD(MODL, patn[npatn].ipmtr, irow, icol, 1.0);
                CATCH_STATUS(ocsmSetValuD);

                SPRINT2(1, "                          pattern counter: %s = %3d",
                        MODL->pmtr[patn[npatn].ipmtr].name, 1);

                npatn++;
            }

        /* execute: "patbreak expr" */
        } else if (type == OCSM_PATBREAK) {
            SPRINT2(1, "    executing [%4d] patbreak:       %11.5f",
                    ibrch, args[1].val[0]);

            /* break out of this pattern if the argument is positive */
            if (args[1].val[0] > 0) {
                npatn--;

                while (ibrch < MODL->nbrch && MODL->brch[ibrch].type != OCSM_PATEND) {
                    ibrch++;
                }
            }

        /* execute: "patend" */
        } else if (type == OCSM_PATEND) {
            SPRINT1(1, "    executing [%4d] patend:",
                    ibrch);

            /* increment the iterator */
            (patn[npatn-1].icopy)++;

            /* go back for another copy */
            if (patn[npatn-1].icopy <= patn[npatn-1].ncopy) {
                newValue = patn[npatn-1].icopy;

                irow = icol = 1;

                status = ocsmSetValuD(MODL, patn[npatn-1].ipmtr, irow, icol, newValue);
                CATCH_STATUS(ocsmSetValuD);

                ibrch = patn[npatn-1].ibeg;

                SPRINT2(1, "                          pattern counter: %s = %3d",
                        MODL->pmtr[patn[npatn-1].ipmtr].name, patn[npatn-1].icopy);

            /* otherwise, we are finished with the pattern */
            } else {
                npatn--;
            }

        /* execute: "ifthen val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0" */
        } else if (type == OCSM_IFTHEN) {

            /* evaluate val1 $op1 val2 */
            bool1 = 0;
            if        (strcmp(args[2].str, "lt") == 0 ||
                       strcmp(args[2].str, "LT") == 0   ) {
                if (args[1].val[0] <  args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "le") == 0 ||
                       strcmp(args[2].str, "LE") == 0   ) {
                if (args[1].val[0] <= args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "eq") == 0 ||
                       strcmp(args[2].str, "EQ") == 0   ) {
                if (args[1].val[0] == args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "ge") == 0 ||
                       strcmp(args[2].str, "GE") == 0   ) {
                if (args[1].val[0] >= args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "gt") == 0 ||
                       strcmp(args[2].str, "GT") == 0   ) {
                if (args[1].val[0] >  args[3].val[0]) bool1 = 1;
            } else if (strcmp(args[2].str, "ne") == 0 ||
                       strcmp(args[2].str, "NE") == 0   ) {
                if (args[1].val[0] != args[3].val[0]) bool1 = 1;
            }

            /* set up for lazy evaluations */
            if        (strcmp(args[4].str, "and") == 0 ||
                       strcmp(args[4].str, "AND") == 0   ) {
                if (bool1 == 0) {
                    bool2  =  0;
                } else {
                    bool2  = -1;
                }
            } else if (strcmp(args[4].str, "or") == 0 ||
                       strcmp(args[4].str, "OR") == 0   ) {
                if (bool1 == 0) {
                    bool2  = -1;
                } else {
                    bool2  =  1;
                }
            } else if (strcmp(args[4].str, "xor") == 0 ||
                       strcmp(args[4].str, "XOR") == 0   ) {
                bool2  = -1;
            } else {
                bool2 = 0;
            }

            /* no need to evaluate last 3 arguments */
            if (bool2 >= 0) {
                SPRINT5(1, "    executing [%4d] ifthen:         %11.5f  %s  %11.5f  %s  ...",
                        ibrch, args[1].val[0], args[2].str, args[3].val[0], args[4].str);

            /* evaluate last 3 arguments */
            } else {
                for (iarg = 5; iarg <= 7; iarg++) {
                    if (iarg == 5) strcpy(thisArg, MODL->brch[ibrch].arg5);
                    if (iarg == 6) strcpy(thisArg, MODL->brch[ibrch].arg6);
                    if (iarg == 7) strcpy(thisArg, MODL->brch[ibrch].arg7);

                    status = str2vals(thisArg, MODL, &(args[iarg].nrow), &(args[iarg].ncol), &values, &dots, str);
                    if (status < SUCCESS) {
                        SPRINT4(0, "ERROR:: problem evaluating argument %d (%s) for Branch %d (%s)",
                                iarg, thisArg, ibrch, ocsmGetText(MODL->brch[ibrch].type));
                        CATCH_STATUS(str2vals);
                    }

                    if (STRLEN(str) > 0) {
                        FREE(  args[iarg].str);
                        MALLOC(args[iarg].str, char, MAX_STRVAL_LEN);

                        args[iarg].nval = 0;
                        STRNCPY(args[iarg].str, str, MAX_STRVAL_LEN);
                    } else {
                        args[iarg].nval = (args[iarg].nrow) * (args[iarg].ncol);

                        FREE(  args[iarg].val);   /* also free's .str since they are unioned */
                        MALLOC(args[iarg].val, double, args[iarg].nval);

                        FREE(  args[iarg].dot);
                        MALLOC(args[iarg].dot, double, args[iarg].nval);

                        SPLINT_CHECK_FOR_NULL(values);
                        SPLINT_CHECK_FOR_NULL(dots  );

                        for (i = 0; i < args[iarg].nval; i++) {
                            args[iarg].val[i] = values[i];
                            args[iarg].dot[i] = dots[  i];
                        }
                    }

                    FREE(values);
                    FREE(dots  );
                }

                SPRINT8(1, "    executing [%4d] ifthen:         %11.5f  %s  %11.5f  %s  %11.5f  %s  %11.5f",
                        ibrch, args[1].val[0], args[2].str, args[3].val[0], args[4].str,
                        args[5].val[0], args[6].str, args[7].val[0]);

                /* evaluate val3 $op3 val4 */
                bool2 = 0;
                if        ((strcmp(args[4].str, "or") == 0 ||
                            strcmp(args[4].str, "OR") == 0   ) && bool1 == 1) {
                    bool2 = 1;
                } else if ((strcmp(args[4].str, "and") == 0 ||
                            strcmp(args[4].str, "AND") == 0   ) && bool1 == 0) {
                    bool2 = 0;
                } else if (strcmp(args[6].str, "lt") == 0 ||
                           strcmp(args[6].str, "LT") == 0   ) {
                    if (args[5].val[0] <  args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "le") == 0 ||
                           strcmp(args[6].str, "LE") == 0   ) {
                    if (args[5].val[0] <= args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "eq") == 0 ||
                           strcmp(args[6].str, "EQ") == 0   ) {
                    if (args[5].val[0] == args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "ge") == 0 ||
                           strcmp(args[6].str, "GE") == 0   ) {
                    if (args[5].val[0] >= args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "gt") == 0 ||
                           strcmp(args[6].str, "GT") == 0   ) {
                    if (args[5].val[0] >  args[7].val[0]) bool2 = 1;
                } else if (strcmp(args[6].str, "ne") == 0 ||
                           strcmp(args[6].str, "NE") == 0   ) {
                    if (args[5].val[0] != args[7].val[0]) bool2 = 1;
                }
            }

            /* evaluate (val1 $op1 val2) $op2 (val3 $op3 val4) */
            bool3 = 0;
            if        (strcmp(args[4].str, "or") == 0 ||
                       strcmp(args[4].str, "OR") == 0   ) {
                bool3 = (bool1 == 1) || (bool2 == 1);
            } else if (strcmp(args[4].str, "and") == 0 ||
                       strcmp(args[4].str, "AND") == 0   ) {
                bool3 = (bool1 == 1) && (bool2 == 1);
            } else if (strcmp(args[4].str, "xor") == 0 ||
                       strcmp(args[4].str, "XOR") == 0   ) {
                bool3 = (bool1 == 1) != (bool2 == 1);
            }

            /* remember that we are in an IFTHEN structure */
            if (npatn < MAX_NESTING) {
                patn[npatn].itype = OCSM_IFTHEN;
                patn[npatn].ibeg  = ibrch;
                patn[npatn].iend  = -1;
                patn[npatn].ncopy = bool3;
                patn[npatn].icopy = -1;
                patn[npatn].ipmtr = -1;
                npatn++;
            } else {
                status = OCSM_NESTED_TOO_DEEPLY;
                signalError(MODL, status,
                            "npatn=%d >0 MAX_NESTING=%d", npatn, MAX_NESTING);
                SET_STATUS(OCSM_NESTED_TOO_DEEPLY, patbeg);
            }

            /* if expression evaluated to false, skip to next matching
               ELSEIF, ELSE, or ENDIF */
            if (bool3 == 0) {
                ibrch++;
                icount = 0;   /* tells number of IFTHEN blocks that are within
                                 the one that evaluated to false */
                while (ibrch <= MODL->nbrch) {
                    if        (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                        icount++;
                    } else if (MODL->brch[ibrch].type == OCSM_ELSEIF ||
                               MODL->brch[ibrch].type == OCSM_ELSE     ) {
                        if (icount == 0) {
                            ibrch--;
                            break;
                        }
                    } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
                        if (icount == 0) {
                            ibrch--;
                            break;
                        } else {
                            icount--;
                        }
                    }
                    ibrch++;
                }
            }

        /* execute: "elseif val1 $op1 val2 $op2=and val3=0 $op3=eq val4=0" */
        } else if (type == OCSM_ELSEIF) {

            /* if we got here by executing the previous IFTHEN block, skip to
               just before the next matching ENDIF Branch */
            if (patn[npatn-1].ncopy == 1) {
                icount = 0;   /* tells number of IFTHEN blocks that are within
                                 the one that evaluated to false */
                while (ibrch <= MODL->nbrch) {
                    if        (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                        icount++;
                    } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
                        if (icount == 0) {
                            ibrch--;
                            break;
                        } else {
                            icount--;
                        }
                    }
                    ibrch++;
                }
            } else {

                /* evaluate val1 $op1 val2 */
                bool1 = 0;
                if        (strcmp(args[2].str, "lt") == 0 ||
                           strcmp(args[2].str, "LT") == 0   ) {
                    if (args[1].val[0] <  args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "le") == 0 ||
                           strcmp(args[2].str, "LE") == 0   ) {
                    if (args[1].val[0] <= args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "eq") == 0 ||
                           strcmp(args[2].str, "EQ") == 0   ) {
                    if (args[1].val[0] == args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "ge") == 0 ||
                           strcmp(args[2].str, "GE") == 0   ) {
                    if (args[1].val[0] >= args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "gt") == 0 ||
                           strcmp(args[2].str, "GT") == 0   ) {
                    if (args[1].val[0] >  args[3].val[0]) bool1 = 1;
                } else if (strcmp(args[2].str, "ne") == 0 ||
                           strcmp(args[2].str, "NE") == 0   ) {
                    if (args[1].val[0] != args[3].val[0]) bool1 = 1;
                }

                /* set up for lazy evaluations */
                if        (strcmp(args[4].str, "and") == 0 ||
                           strcmp(args[4].str, "AND") == 0   ) {
                    if (bool1 == 0) {
                        bool2  =  0;
                    } else {
                        bool2  = -1;
                    }
                } else if (strcmp(args[4].str, "or") == 0 ||
                           strcmp(args[4].str, "OR") == 0   ) {
                    if (bool1 == 0) {
                        bool2  = -1;
                    } else {
                        bool2  =  1;
                    }
                } else if (strcmp(args[4].str, "xor") == 0 ||
                           strcmp(args[4].str, "XOR") == 0   ) {
                    bool2  = -1;
                } else {
                    bool2 = 0;
                }

                /* no need to evaluate last 3 arguments */
                if (bool2 >= 0) {
                    SPRINT4(1, "    executing [%4d] elseif:         %11.5f  %s  %11.5f  ...",
                            ibrch, args[1].val[0], args[2].str, args[3].val[0]);

                /* evaluate last 3 arguments */
                } else {
                    for (iarg = 5; iarg <= 7; iarg++) {
                        if (iarg == 5) strcpy(thisArg, MODL->brch[ibrch].arg5);
                        if (iarg == 6) strcpy(thisArg, MODL->brch[ibrch].arg6);
                        if (iarg == 7) strcpy(thisArg, MODL->brch[ibrch].arg7);

                        status = str2vals(thisArg, MODL, &(args[iarg].nrow), &(args[iarg].ncol), &values, &dots, str);
                        if (status < SUCCESS) {
                            SPRINT4(0, "ERROR:: problem evaluating argument %d (%s) for Branch %d (%s)",
                                    iarg, thisArg, ibrch, ocsmGetText(MODL->brch[ibrch].type));
                            CATCH_STATUS(str2vals);
                        }

                        if (STRLEN(str) > 0) {
                            FREE(  args[iarg].str);
                            MALLOC(args[iarg].str, char, MAX_STRVAL_LEN);

                            args[iarg].nval = 0;
                            STRNCPY(args[iarg].str, str, MAX_STRVAL_LEN);
                        } else {
                            args[iarg].nval = (args[iarg].nrow) * (args[iarg].ncol);

                            FREE(  args[iarg].val);   /* also free's .str since they are unioned */
                            MALLOC(args[iarg].val, double, args[iarg].nval);

                            FREE(  args[iarg].dot);
                            MALLOC(args[iarg].dot, double, args[iarg].nval);

                            SPLINT_CHECK_FOR_NULL(values);
                            SPLINT_CHECK_FOR_NULL(dots  );

                            for (i = 0; i < args[iarg].nval; i++) {
                                args[iarg].val[i] = values[i];
                                args[iarg].dot[i] = dots[  i];
                            }
                        }

                        FREE(values);
                        FREE(dots  );
                    }

                    SPRINT8(1, "    executing [%4d] elseif:         %11.5f  %s  %11.5f  %s  %11.5f  %s  %11.5f",
                            ibrch, args[1].val[0], args[2].str, args[3].val[0], args[4].str,
                            args[5].val[0], args[6].str, args[7].val[0]);

                    /* evaluate val3 $op3 val4 */
                    bool2 = 0;
                    if        ((strcmp(args[4].str, "or") == 0 ||
                                strcmp(args[4].str, "OR") == 0   ) && bool1 == 1) {
                        bool2 = 1;
                    } else if ((strcmp(args[4].str, "and") == 0 ||
                                strcmp(args[4].str, "AND") == 0   ) && bool1 == 0) {
                        bool2 = 0;
                    } else if (strcmp(args[6].str, "lt") == 0 ||
                               strcmp(args[6].str, "LT") == 0   ) {
                        if (args[5].val[0] <  args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "le") == 0 ||
                               strcmp(args[6].str, "LE") == 0   ) {
                        if (args[5].val[0] <= args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "eq") == 0 ||
                               strcmp(args[6].str, "EQ") == 0   ) {
                        if (args[5].val[0] == args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "ge") == 0 ||
                               strcmp(args[6].str, "GE") == 0   ) {
                        if (args[5].val[0] >= args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "gt") == 0 ||
                               strcmp(args[6].str, "GT") == 0   ) {
                        if (args[5].val[0] >  args[7].val[0]) bool2 = 1;
                    } else if (strcmp(args[6].str, "ne") == 0 ||
                               strcmp(args[6].str, "NE") == 0   ) {
                        if (args[5].val[0] != args[7].val[0]) bool2 = 1;
                    }
                }

                /* evaluate (val1 $op1 val2) $op2 (val3 $op3 val4) */
                bool3 = 0;
                if        (strcmp(args[4].str, "or") == 0 ||
                           strcmp(args[4].str, "OR") == 0   ) {
                    bool3 = (bool1 ==1) || (bool2 == 1);
                } else if (strcmp(args[4].str, "and") == 0 ||
                           strcmp(args[4].str, "AND") == 0   ) {
                    bool3 = (bool1 == 1) && (bool2 == 1);
                } else if (strcmp(args[4].str, "xor") == 0 ||
                           strcmp(args[4].str, "XOR") == 0   ) {
                    bool3 = (bool1 == 1) != (bool2 == 1);
                }

                patn[npatn-1].ncopy = bool3;

                /* if expression evaluated to false, skip to next matching
                   elseif, else, or endif */
                if (bool3 == 0) {
                    ibrch++;
                    icount = 0;
                    while (ibrch <= MODL->nbrch) {
                        if        (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                            icount++;
                        } else if (MODL->brch[ibrch].type == OCSM_ELSEIF ||
                                   MODL->brch[ibrch].type == OCSM_ELSE     ) {
                            if (icount == 0) {
                                ibrch--;
                                break;
                            }
                        } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
                            if (icount == 0) {
                                ibrch--;
                                break;
                            } else {
                                icount--;
                            }
                        }
                        ibrch++;
                    }
                }
            }

        /* execute: "else" */
        } else if (type == OCSM_ELSE) {

            /* if we got here by executing the previous ifthen block, skip to
               just before the next matching endif Branch */
            if (patn[npatn-1].ncopy == 1) {
                icount = 0;   /* tells number of IFTHEN blocks that are within
                                 the one that evaluated to false */
                while (ibrch <= MODL->nbrch) {
                    if        (MODL->brch[ibrch].type == OCSM_IFTHEN) {
                        icount++;
                    } else if (MODL->brch[ibrch].type == OCSM_ENDIF) {
                        if (icount == 0) {
                            ibrch--;
                            break;
                        } else {
                            icount--;
                        }
                    }
                    ibrch++;
                }
            } else {
                SPRINT1(1, "    executing [%4d] else:",
                        ibrch);
            }

        /* execute: "endif" */
        } else if (type == OCSM_ENDIF) {

            /* remove the patn associated with the ifthen statement */
            npatn--;

        /* execute: "throw sigCode" */
        } else if (type == OCSM_THROW) {
            SPRINT2(1, "    executing [%4d] throw:          %11.5f",
                    ibrch, args[1].val[0]);

            /* set the signal */
            signalError(MODL, NINT(args[1].val[0]),
                        "signal %d thrown by user", NINT(args[1].val[0]));
            goto next_branch;

        /* execute: "catbeg sigCode" */
        } else if (type == OCSM_CATBEG) {
            SPRINT2(1, "    executing [%4d] catbeg:         %s",
                    ibrch, MODL->brch[ibrch].arg1);

            icatch = 0;
            if (MODL->brch[ibrch].arg1[0] != '$') {
                icatch = NINT(args[1].val[0]);
            } else if (strcmp(MODL->brch[ibrch].arg1, "$all"                        ) == 0) {
                icatch = 0;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$body_not_found"             ) == 0) {
                icatch = OCSM_BODY_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$colinear_sketch_points"     ) == 0) {
                icatch = OCSM_COLINEAR_SKETCH_POINTS;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$created_too_many_bodys"     ) == 0) {
                icatch = OCSM_CREATED_TOO_MANY_BODYS;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$did_not_create_body"        ) == 0) {
                icatch = OCSM_DID_NOT_CREATE_BODY;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$edge_not_found"             ) == 0) {
                icatch = OCSM_EDGE_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$error_in_bodys_on_stack"    ) == 0) {
                icatch = OCSM_ERROR_IN_BODYS_ON_STACK;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$face_not_found"             ) == 0) {
                icatch = OCSM_FACE_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$file_not_found"             ) == 0) {
                icatch = OCSM_FILE_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$func_arg_out_of_bounds"     ) == 0) {
                icatch = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_argument"           ) == 0) {
                icatch = OCSM_ILLEGAL_ARGUMENT;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_attribute"          ) == 0) {
                icatch = OCSM_ILLEGAL_ATTRIBUTE;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_csystem"            ) == 0) {
                icatch = OCSM_ILLEGAL_CSYSTEM;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_pmtr_index"         ) == 0) {
                icatch = OCSM_ILLEGAL_PMTR_INDEX;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_pmtr_name"          ) == 0) {
                icatch = OCSM_ILLEGAL_PMTR_NAME;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$illegal_value"              ) == 0) {
                icatch = OCSM_ILLEGAL_VALUE;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$insufficient_bodys_on_stack") == 0) {
                icatch = OCSM_INSUFFICIENT_BODYS_ON_STACK;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$name_not_found"             ) == 0) {
                icatch = OCSM_NAME_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$node_not_found"             ) == 0) {
                icatch = OCSM_NODE_NOT_FOUND;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$non_coplanar_sketch_points" ) == 0) {
                icatch = OCSM_NON_COPLANAR_SKETCH_POINTS;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$no_selection"               ) == 0) {
                icatch = OCSM_NO_SELECTION;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$underconstrained"           ) == 0) {
                icatch = OCSM_UNDERCONSTRAINED;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$overconstrained"            ) == 0) {
                icatch = OCSM_OVERCONSTRAINED;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$not_converged"              ) == 0) {
                icatch = OCSM_NOT_CONVERGED;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$self_intersecting"          ) == 0) {
                icatch = OCSM_SELF_INTERSECTING;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$wrong_types_on_stack"       ) == 0) {
                icatch = OCSM_WRONG_TYPES_ON_STACK;
            } else if (strcmp(MODL->brch[ibrch].arg1, "$assert_failed"              ) == 0) {
                icatch = OCSM_ASSERT_FAILED;
            } else {
                status = OCSM_ILLEGAL_VALUE;
                signalError(MODL, status,
                            "unknown signal type (%s)", MODL->brch[ibrch].arg1);
                CATCH_STATUS(OCSM_NAME_NOT_FOUND);
            }

            /* if we are catching any signal and one is set, catch it and reset the signal */
            if (icatch == 0 && MODL->sigCode != 0) {
                SPRINT2(0, "    --> catching signal %d (%s)", MODL->sigCode, ocsmGetText(MODL->sigCode));

                status = ocsmFindPmtr(MODL, "@signal", OCSM_LOCALVAR, 1, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                status = ocsmSetValuD(MODL, ipmtr, 1, 1, (double)(MODL->sigCode));
                CHECK_STATUS(ocsmSetValuD);

                MODL->sigCode    = 0;
                MODL->sigMesg[0] = '\0';
                npatn_sig        = -1;

            /* if there is no uncaught signal, or the uncaught signal
               does not match this catbeg, skip to the matching catend */
            } else if (icatch == 0 || MODL->sigCode == 0 || MODL->sigCode != icatch) {
                icount = 1;
                while (ibrch < MODL->nbrch) {
                    ibrch++;

                    if        (MODL->brch[ibrch].type == OCSM_CATBEG) {
                        icount++;
                    } else if (MODL->brch[ibrch].type == OCSM_CATEND) {
                        icount--;

                        if (icount == 0) {
                            break;
                        }
                    }
                }

            /* otherwise catch this signal by resetting the signal */
            } else {
                SPRINT2(0, "    --> catching signal %d (%s)", MODL->sigCode, ocsmGetText(MODL->sigCode));
                MODL->sigCode    = 0;
                MODL->sigMesg[0] = '\0';
                npatn_sig        = -1;
            }

        /* execute: "catend" */
        } else if (type == OCSM_CATEND) {

        /* execute: "mark" */
        } else if (type == OCSM_MARK) {
            SPRINT1(1, "    executing [%4d] mark:",
                    ibrch);

            /* push a Mark onto the stack */
            stack[nstack++] = 0;

            SPRINT0(1, "                          Mark        created");

        /* execute: "group nbody=0" */
        } else if (type == OCSM_GROUP) {
            SPRINT2(1, "    executing [%4d] group:         %11.5f",
                    ibrch, args[1].val[0]);

            /* make sure that there is a Body on the stack */
            if (nstack < 1) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "GROUP expects a Body on the stack");
                goto next_branch;
            } else if (stack[nstack-1] <= 0) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "GROUP expects a Body on the stack");
                goto next_branch;
            }

            /* the number of Bodys specified */
            ngroup = NINT(args[1].val[0]);

            /* if nbody is negative, break up the current group */
            if (ngroup < 0) {

                /* change the group number for all Bodys on stack which are in the same group
                   as teh Body on te top of the stack */
                for (istack = nstack-2; istack >= 0; istack--) {
                    if (stack[istack] > 0) {
                        if (MODL->body[stack[istack]].igroup == MODL->body[stack[nstack-1]].igroup) {
                            (MODL->ngroup)++;
                            MODL->body[stack[istack]].igroup = MODL->ngroup;
                        }
                    }
                }

            } else {
                istack = nstack - 1;
                igroup = MODL->body[stack[istack]].igroup;


                /* if ngroup is not given, potentially group all Bodys */
                if (ngroup == 0) {
                    ngroup = MODL->nbody;
                }

                /* loop back through the stack */
                while (istack > 0) {
                    istack--;

                    /* Sketch found -- error */
                    if (stack[istack] < 0) {
                        status = OCSM_WRONG_TYPES_ON_STACK;
                        signalError(MODL, status,
                                    "GROUP expects Bodys on the stack");
                        goto next_branch;

                        /* Body found, so change its Group */
                    } else if (stack[istack] > 0) {
                        MODL->body[stack[istack]].igroup = igroup;
                        SPRINT2(1, "                          Body   %4d added to Group %4d",
                                stack[istack], igroup);

                        /* if ngroup was given and we already have grouped
                           them, we are done */
                        ngroup--;
                        if (ngroup < 0) break;

                        /* Mark found, so remove it from the stack */
                    } else {
                        while (istack < nstack) {
                            stack[istack] = stack[istack+1];
                            istack++;
                        }

                        nstack--;
                        break;
                    }
                }
            }

            /* if the group statement has Attributes, apply to all Bodys in the Group */
            if (stack[nstack-1] > 0 && MODL->brch[ibrch].nattr > 0) {
                for (ibody = 1; ibody <= MODL->nbody; ibody++) {
                    if (MODL->body[ibody].igroup != MODL->body[stack[nstack-1]].igroup) continue;
                    ebody = MODL->body[ibody].ebody;

                    status = setEgoAttribute(MODL, ibrch, ebody);
                    CATCH_STATUS(setEgoAttribute);
                }
            }

        /* execute: "dump $filename remove=0 toMark=0 withTess=0" */
        } else if (type == OCSM_DUMP) {
            SPRINT5(1, "    executing [%4d] dump:       %s  %11.5f  %11.5f  %11.5f",
                    ibrch, args[1].str, args[2].val[0], args[3].val[0], args[4].val[0]);

            /* make sure that there is a Body on the stack */
            if (nstack < 1) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "DUMP expects a Body on the stack");
                goto next_branch;
            }

            /* check that an extension (filetype) was given */
            extension = NULL;
            for (i = STRLEN(args[1].str)-1; i > 1; i--) {
                if (args[1].str[i] == '.') {
                    extension = &(args[1].str[i]);
                    break;
                }
            }
            if (extension == NULL) {
                status = OCSM_FILE_NOT_FOUND;
                signalError(MODL, status,
                            "no filetype specified");
                goto next_branch;

            /* if the filetype is .stl or .STL, write a stereo-lithography file */
            } else if (strcmp(extension, ".stl") == 0 || strcmp(extension, ".STL") == 0) {

                if (NINT(args[3].val[0]) == 1) {
                    status = writeAsciiStl(MODL, nstack, stack, args[1].str);
                    CHECK_STATUS(writeAsciiStl);

                    SPRINT0(1, "WARNING:: multiple Bodys in STL file is non-standard");
                    (MODL->nwarn)++;

                    for (istack = 0; istack < nstack; istack++) {
                        if (stack[istack] > 0) {
                            SPRINT1(1, "                          Body   %4d dumped", stack[istack]);
                        }
                    }
                } else {
                    status = writeAsciiStl(MODL, 1, &(stack[nstack-1]), args[1].str);
                    CHECK_STATUS(writeAsciiStl);

                    SPRINT1(1, "                          Body   %4d dumped", stack[nstack-1]);

                    if (NINT(args[2].val[0]) == 1) {
                        SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack-1]);
                        nstack--;
                    }
                }

            /* if the filetype is .bstl or .BSTL, write a binary stereo-lithography file */
            } else if (strcmp(extension, ".bstl") == 0 || strcmp(extension, ".BSTL") == 0) {

                if (NINT(args[3].val[0]) == 1) {
                    status = writeBinaryStl(MODL, nstack, stack, args[1].str);
                    CHECK_STATUS(writeBinaryStl);

                    SPRINT0(1, "WARNING:: multiple Bodys in STL file is non-standard");
                    (MODL->nwarn)++;

                    for (istack = 0; istack < nstack; istack++) {
                        if (stack[istack] > 0) {
                            SPRINT1(1, "                          Body   %4d dumped", stack[istack]);
                        }
                    }
                } else {
                    status = writeBinaryStl(MODL, 1, &(stack[nstack-1]), args[1].str);
                    CHECK_STATUS(writeBinaryStl);

                    SPRINT1(1, "                          Body   %4d dumped", stack[nstack-1]);

                    if (NINT(args[2].val[0]) == 1) {
                        SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack-1]);
                        nstack--;
                    }
                }

            /* if the filetype is .ugrid or .UGRID, write a AFLR3 input file */
            } else if (strcmp(extension, ".ugrid") == 0 || strcmp(extension, ".UGRID") == 0) {

                if (NINT(args[3].val[0]) == 1) {
                    status = OCSM_FILE_NOT_FOUND;
                    signalError(MODL, status,
                                "only one Body can be written to .ugrid file");
                    goto next_branch;
                }

                SPRINT1(1, "                          Body   %4d dumped", stack[nstack-1]);
                if (NINT(args[2].val[0]) == 1) {
                    SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack-1]);
                    nstack--;
                }

                /* write the file */
                status = writeAsciiUgrid(MODL, stack[nstack-1], args[1].str);
                CHECK_STATUS(writeAsciiUgrid);

            /* if the filetype is .plot, write points into plotfile */
            } else if (strcmp(extension, ".plot") == 0 || strcmp(extension, ".PLOT") == 0) {
                ibody = stack[nstack-1];

                if (MODL->body[ibody].etess == NULL) {
                    status = ocsmTessellate(MODL, ibody);
                    CHECK_STATUS(ocsmTessellate);
                }

                status = writePlotFile(MODL, ibody, args[1].str);
                CHECK_STATUS(writePlotFile);

            /* if the filetype is .tess, write tessellation file */
            } else if (strcmp(extension, ".tess") == 0 || strcmp(extension, ".TESS") == 0) {
                ibody = stack[nstack-1];

                if (MODL->body[ibody].etess == NULL) {
                    status = ocsmTessellate(MODL, ibody);
                    CHECK_STATUS(ocsmTessellate);
                }

                status = writeTessFile(MODL, ibody, args[1].str);
                CHECK_STATUS(writeTessFile);

            /* if the filetype is .sens, write sensitivity file */
            } else if (strcmp(extension, ".sens") == 0 || strcmp(extension, ".SENS") == 0) {
                ibody = stack[nstack-1];

                /* only dump a .sens file if not in process of computing sensitivities
                   via finite differences, since trying to dump the .sens file will
                   result in an infinite loop of recursive calls */
                if (MODL->basemodl == NULL) {

                    if (NINT(args[3].val[0]) != 0) {
                        SPRINT0(1, "WARNING:: only last Body on stack dumped into .sens file");
                        (MODL->nwarn)++;
                    }

                    if (MODL->body[ibody].etess == NULL) {
                        status = ocsmTessellate(MODL, ibody);
                        CHECK_STATUS(ocsmTessellate);
                    }

                    status = writeSensFile(MODL, ibody, args[1].str);
                    CHECK_STATUS(writeSensFile);
                }

            /* if the filetype is .egg, write a EGG restart file */
            } else if (strcmp(extension, ".egg") == 0 || strcmp(extension, ".EGG") == 0) {
                ibody = stack[nstack-1];

                if (MODL->eggDump == NULL) {
                    SPRINT0(1, "WARNING:: eggDump does not exist.  File not dumped");
                    (MODL->nwarn)++;
                } else {
                    SPRINT1(1, "                          Body   %4d dumped", ibody);
                    if (NINT(args[2].val[0]) == 1) {
                        SPRINT1(1, "                          Body   %4d removed from stack", ibody);
                        nstack--;
                    }

                    /* write the file */
                    fp = fopen(args[1].str, "w");

                    if (fp != NULL) {
                        fprintf(fp, "%8d %8d %8d\n",
                                MODL->body[ibody].nnode,
                                MODL->body[ibody].nedge,
                                MODL->body[ibody].nface);

                        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
                            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                                    &npnt, &xyz, &uv);
                            CHECK_STATUS(EG_getTessEdge);

                            fprintf(fp, "%8d\n", npnt);
                        }

                        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                            status = MODL->eggDump(MODL->body[ibody].face[iface].eggdata, fp);
                            CHECK_STATUS(eggDump);
                        }

                        fclose(fp);
                    }
                }

            /* otherwise assume it is a type that EGADS knows how to handle */
            } else {
                nego1 = 0;
                nego2 = 0;

                /* make a model from the Body (and Tessellation) on the top of the stack */
                if (NINT(args[3].val[0]) != 1) {
                    MALLOC(etemp, ego, 2);

                    status = EG_copyObject(MODL->body[stack[nstack-1]].ebody, NULL, &(etemp[nego1]));
                    CATCH_STATUS(EG_copyObject);
                    nego1++;
                    nego2++;

                    if (NINT(args[4].val[0]) != 0 && (strcmp(extension, ".egads") == 0 || strcmp(extension, ".EGADS") == 0)) {
                        if (MODL->body[stack[nstack-1]].etess == NULL) {
                            status = ocsmTessellate(MODL, stack[nstack-1]);
                            CATCH_STATUS(ocsmTessellate);
                        }

                        status = EG_copyObject(MODL->body[stack[nstack-1]].etess,
                                               etemp[0], &(etemp[nego2]));
                        CATCH_STATUS(EG_copyObject);

                        nego2++;
                    }

                    SPRINT1(1, "                          Body   %4d dumped", stack[nstack-1]);
                    if (NINT(args[2].val[0]) == 1) {
                        SPRINT1(1, "                          Body   %4d removed from stack", stack[nstack-1]);
                        nstack--;
                    }

                /* make a model from all the Bodys (and Tessellations) back to the Mark */
                } else {
                    MALLOC(etemp, ego, 2*(nstack+1));

                    for (jstack = nstack-1; jstack >= 0; jstack--) {
                        if (stack[jstack] == 0) {
                            break;
                        } else if (stack[jstack] > 0) {
                            status = EG_copyObject(MODL->body[stack[jstack]].ebody, NULL, &(etemp[nego1]));
                            CATCH_STATUS(EG_copyObject);
                            nego1++;
                            nego2++;

                            SPRINT1(1, "                          Body   %4d dumped", stack[jstack]);
                        }
                    }

                    if (NINT(args[4].val[0]) != 0 && (strcmp(extension, ".egads") == 0 || strcmp(extension, ".EGADS") == 0)) {
                        for (jstack = nstack-1; jstack >= 0; jstack--) {
                            if (stack[jstack] == 0) {
                                break;
                            } else if (stack[jstack] > 0) {
                                if (MODL->body[stack[jstack]].etess == NULL) {
                                    status = ocsmTessellate(MODL, stack[jstack]);
                                    CATCH_STATUS(ocsmTessellate);
                                }

                                status = EG_copyObject(MODL->body[stack[jstack]].etess,
                                                       etemp[nstack-1-jstack], &(etemp[nego2]));
                                CATCH_STATUS(EG_copyObject);
                                nego2++;
                            }
                        }
                    }

                    for (jstack = nstack-1; jstack >= 0; jstack--) {
                        if (stack[jstack] == 0) {
                            if (NINT(args[2].val[0]) == 1) {
                                SPRINT0(1, "                          Mark        removed from stack");
                                nstack--;
                            }
                            break;
                        } else if (stack[jstack] > 0) {
                            if (NINT(args[2].val[0]) == 1) {
                                SPRINT1(1, "                          Body   %4d removed from stack", stack[jstack]);
                                nstack--;
                            }
                        }
                    }
                }

                status = EG_makeTopology(MODL->context, NULL, MODEL, nego2,
                                         NULL, nego1, etemp, NULL, &emodel);
                CATCH_STATUS(EG_makeTopology);

                FREE(etemp);

                /* add the global Attributes to the Model */
                for (iattr = 0; iattr < MODL->nattr; iattr++) {
                    status = EG_attributeAdd(emodel, MODL->attr[iattr].name, ATTRSTRING,
                                             STRLEN(MODL->attr[iattr].defn), NULL, NULL, MODL->attr[iattr].defn);
                    CATCH_STATUS(EG_attributeAdd);
                }

                /* add the DESPMTRs, CFGPMTRs, and OUTPMTRs as Attributes on the Model */
                for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                    if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR)  {
                        snprintf(pmtrName, MAX_EXPR_LEN, "_despmtr_%s", MODL->pmtr[ipmtr].name);

                        status = EG_attributeAdd(emodel, pmtrName, ATTRREAL,
                                                 MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                                 NULL, MODL->pmtr[ipmtr].value, NULL);
                        CATCH_STATUS(EG_attributeAdd);
                    } else if (MODL->pmtr[ipmtr].type == OCSM_CFGPMTR)  {
                        snprintf(pmtrName, MAX_EXPR_LEN, "_cfgpmtr_%s", MODL->pmtr[ipmtr].name);

                        status = EG_attributeAdd(emodel, pmtrName, ATTRREAL,
                                                 MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                                 NULL, MODL->pmtr[ipmtr].value, NULL);
                        CATCH_STATUS(EG_attributeAdd);
                    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {
                        snprintf(pmtrName, MAX_EXPR_LEN, "_outpmtr_%s", MODL->pmtr[ipmtr].name);

                        if (MODL->pmtr[ipmtr].value != NULL) {
                            status = EG_attributeAdd(emodel, pmtrName, ATTRREAL,
                                                     MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                                     NULL, MODL->pmtr[ipmtr].value, NULL);
                        } else {
                            status = EG_attributeAdd(emodel, pmtrName, ATTRSTRING,
                                                     MODL->pmtr[ipmtr].nrow,
                                                     NULL, NULL, MODL->pmtr[ipmtr].str);
                        }
                        CATCH_STATUS(EG_attributeAdd);
                    }
                }

                if (outLevel >= 3) {
                    SPRINT0(3, "emodel\n");
                    ocsmPrintEgo(emodel);
                }

                /* strip the dollarsign off the filename */
                STRNCPY(dumpfile, args[1].str, MAX_EXPR_LEN);

                /* if file exists, delete it now */
                status = remove(dumpfile);
                if (status == 0) {
                    SPRINT1(1, "WARNING:: file \"%s\" is being overwritten", dumpfile);
                    (MODL->nwarn)++;
                }

                status = EG_saveModel(emodel, dumpfile);
                CATCH_STATUS(EG_saveModel);

                status = EG_deleteObject(emodel);
                CATCH_STATUS(EG_deleteObject);
            }

        /* execute: "end" */
        } else if (type == OCSM_END) {
            SPRINT1(1, "    executing [%4d] end:", ibrch);

            /* do nothing if we are at the top level */
            if (MODL->level <= 0) break;

            /* remove from the pattern list */
            npatn--;

            /* find the UDPRIM Branch associated with this END */
            for (jbrch = ibrch-1; jbrch > 0; jbrch--) {
                if (MODL->brch[jbrch].indent == MODL->brch[ibrch].indent) {
                    if (MODL->brch[jbrch].type == OCSM_UDPRIM) {
                        break;
                    } else {
                        status = OCSM_INTERNAL_ERROR;
                        signalError(MODL, status,
                                    "expecting UDPRIM, but got %s", ocsmGetText(MODL->brch[jbrch].type));
                        CATCH_STATUS(end);
                    }
                }
            }

            /* jbrch is first Branch after the UDPRIM statement that called this .udc */
            jbrch++;
            while (jbrch < ibrch) {
                if (MODL->brch[jbrch].type != OCSM_INTERFACE) break;

                if (strcmp(MODL->brch[jbrch].arg2, "$out") == 0 ||
                    strcmp(MODL->brch[jbrch].arg2, "$OUT") == 0   ) {

                    /* get the value of the local variable */
                    status = str2vals(&(MODL->brch[jbrch].arg1[1]), MODL, &nrow, &ncol, &values, &dots, str);
                    CATCH_STATUS(str2vals);

                    /* find or create an @@-parameter up one level and store the value/dot */
                    (MODL->level)--;
                    snprintf(pmtrName, MAX_EXPR_LEN, "@@%s", &(MODL->brch[jbrch].arg1[1]));

                    if (STRLEN(str) == 0) {
                        SPLINT_CHECK_FOR_NULL(values);
                        SPLINT_CHECK_FOR_NULL(dots  );

                        status = ocsmFindPmtr(MODL, pmtrName, OCSM_LOCALVAR, nrow, ncol, &ipmtr);

                        /* we may need to increase the size of this @@-parameter */
                        if (status == OCSM_NAME_ALREADY_DEFINED) {
                            status = ocsmDelPmtr(MODL, ipmtr);
                            CHECK_STATUS(ocsmDelPmtr);

                            status = ocsmFindPmtr(MODL, pmtrName, OCSM_LOCALVAR, nrow, ncol, &ipmtr);
                        }
                        CATCH_STATUS(ocsmFindPmtr);

                        i = 0;
                        for (irow = 1; irow <= nrow; irow++) {
                            for (icol = 1; icol <= ncol; icol++) {
                                status = ocsmSetValuD(MODL, ipmtr, irow, icol, values[i]);
                                CATCH_STATUS(ocsmSetValuD);

                                status = ocsmSetVelD(MODL, ipmtr, irow, icol, dots[i]);
                                CATCH_STATUS(ocsmSetVelD);

                                i++;
                            }
                        }
                    } else {
                        status = ocsmFindPmtr(MODL, pmtrName, OCSM_LOCALVAR, 0, 0, &ipmtr);
                        CATCH_STATUS(ocsmFindPmtr);

                        STRNCPY(temp, "$", MAX_STRVAL_LEN  );
                        strncat(temp, str, MAX_STRVAL_LEN-1);
                        status = ocsmSetValu(MODL, ipmtr, 1, 1, temp);
                        CATCH_STATUS(ocsmSetValu);
                    }


                    FREE(values);
                    FREE(dots  );

                    (MODL->level)++;
                }

                jbrch++;
            }

            /* remove all the Parameters at MODL->scope if a new scope */
            if (MODL->scope[MODL->level] > MODL->scope[MODL->level-1]) {
                for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                    if (MODL->pmtr[ipmtr].scope >= MODL->scope[MODL->level]) {
                        FREE(MODL->pmtr[ipmtr].name );
                        FREE(MODL->pmtr[ipmtr].value);
                        FREE(MODL->pmtr[ipmtr].dot  );
                        FREE(MODL->pmtr[ipmtr].lbnd );
                        FREE(MODL->pmtr[ipmtr].ubnd );
                        FREE(MODL->pmtr[ipmtr].str  );

                        for (jpmtr = ipmtr+1; jpmtr <= MODL->npmtr; jpmtr++) {

                            /* copy jpmtr over jpmtr-1 */
                            MODL->pmtr[jpmtr-1].name  = MODL->pmtr[jpmtr].name;
                            MODL->pmtr[jpmtr-1].type  = MODL->pmtr[jpmtr].type;
                            MODL->pmtr[jpmtr-1].scope = MODL->pmtr[jpmtr].scope;
                            MODL->pmtr[jpmtr-1].mprop = MODL->pmtr[jpmtr].mprop;
                            MODL->pmtr[jpmtr-1].nrow  = MODL->pmtr[jpmtr].nrow;
                            MODL->pmtr[jpmtr-1].ncol  = MODL->pmtr[jpmtr].ncol;
                            MODL->pmtr[jpmtr-1].value = MODL->pmtr[jpmtr].value;
                            MODL->pmtr[jpmtr-1].dot   = MODL->pmtr[jpmtr].dot;
                            MODL->pmtr[jpmtr-1].lbnd  = MODL->pmtr[jpmtr].lbnd;
                            MODL->pmtr[jpmtr-1].ubnd  = MODL->pmtr[jpmtr].ubnd;
                            MODL->pmtr[jpmtr-1].str   = MODL->pmtr[jpmtr].str;
                        }

                        ipmtr--;            /* revisit imptr in next trip through loop */

                        MODL->pmtr[MODL->npmtr].name  = NULL;
                        MODL->pmtr[MODL->npmtr].value = NULL;
                        MODL->pmtr[MODL->npmtr].dot   = NULL;
                        MODL->pmtr[MODL->npmtr].lbnd  = NULL;
                        MODL->pmtr[MODL->npmtr].ubnd  = NULL;
                        MODL->pmtr[MODL->npmtr].str   = NULL;
                        (MODL->npmtr)--;
                    }
                }

            }

            /* decrement the level */
            (MODL->level)--;

        /* execute: "assert arg1 arg2 toler=0 verify=0" */
        } else if (type == OCSM_ASSERT) {
            /* determine if verification is required */
            verify = NINT(args[4].val[0]);

            if (verify <= MODL->verify) {
                SPRINT5(1, "    executing [%4d] assert:     %s  %s  %s  %s",
                        ibrch, MODL->brch[ibrch].arg1,
                               MODL->brch[ibrch].arg2,
                               MODL->brch[ibrch].arg3,
                               MODL->brch[ibrch].arg4);

                /* set up tolerance */
                if (args[3].val[0] == 0) {
                    toler = 1.0e-6;
                } else if (args[3].val[0] < 0) {
                    toler = fabs(args[1].val[0] * args[3].val[0]);
                } else {
                    toler = args[3].val[0];
                }

                /* return error if arg1 != arg2 */
                if (fabs(args[1].val[0]-args[2].val[0]) > toler) {
                    SPRINT1(0, "    arg1 = %20.8f", args[1].val[0]);
                    SPRINT1(0, "    arg2 = %20.8f", args[2].val[0]);
                    if (args[3].val[0] < 0) {
                        SPRINT1(0, " pct err = %20.8f", 100*(args[1].val[0]-args[2].val[0])/args[1].val[0]);
                    } else {
                        SPRINT1(0, " abs err = %20.8f",     (args[1].val[0]-args[2].val[0])               );
                    }
                    status = OCSM_ASSERT_FAILED;
                    signalError(MODL, status,
                                "ASSERT failed (%12.5e disagrees with %12.5e)", args[1].val[0], args[2].val[0]);
                    CATCH_STATUS(assert);
                }
            } else {
                SPRINT5(1, "    ignoring  [%4d] assert:     %s  %s  %s  %s",
                        ibrch, MODL->brch[ibrch].arg1,
                               MODL->brch[ibrch].arg2,
                               MODL->brch[ibrch].arg3,
                               MODL->brch[ibrch].arg4);
            }

        /* execute: "message $text $schar=_" */
        } else if (type == OCSM_MESSAGE) {
            SPRINT3(1, "    executing [%4d] message:    %s  %s",
                    ibrch, &(MODL->brch[ibrch].arg1[1]),
                           &(MODL->brch[ibrch].arg2[1]));

            if (args[1].nval != 0) {
                status = OCSM_ILLEGAL_ARGUMENT;
                signalError(MODL, status,
                            "MESSAGE text is expected to be a string");
            } else if (args[2].nval != 0) {
                status = OCSM_ILLEGAL_ARGUMENT;
                signalError(MODL, status,
                            "MESSAGE schar is expected to be a single character");
            } else if (strlen(args[2].str) != 1) {
                status = OCSM_ILLEGAL_ARGUMENT;
                signalError(MODL, status,
                            "MESSAGE schar is expected to be a single character");
            }

            /* reuse the previous string */
            STRNCPY(thisArg, args[1].str, MAX_LINE_LEN);

            for (i = 0; i < strlen(thisArg); i++) {
                if (thisArg[i] == args[2].str[0]) {
                    thisArg[i] = ' ';
                }
            }

            SPRINT1(0, "\nMESSAGE:: %s\n", thisArg);

            /* send this message to the message callback routine (if defined) */
            if (MODL->mesgCB != NULL) {
                MODL->mesgCB(thisArg);
            }

        /* execute: "special arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9" */
        } else if (type == OCSM_SPECIAL) {
            SPRINT10(1, "    executing [%4d] special:    %s  %s  %s  %s  %s  %s  %s  %s  %s",
                    ibrch, MODL->brch[ibrch].arg1,
                           MODL->brch[ibrch].arg2,
                           MODL->brch[ibrch].arg3,
                           MODL->brch[ibrch].arg4,
                           MODL->brch[ibrch].arg5,
                           MODL->brch[ibrch].arg6,
                           MODL->brch[ibrch].arg7,
                           MODL->brch[ibrch].arg8,
                           MODL->brch[ibrch].arg9);

            /* pop a Body from the stack */
            if (nstack < 1) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "SPECIAL expects a Body on the stack");
                goto next_branch;
            } else if (stack[nstack-1] <= 0) {
                status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
                signalError(MODL, status,
                            "SPECIAL expects a Body on the stack");
                goto next_branch;
            } else {
                ibodyl = stack[--nstack];
            }

            hasdots = 0;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[nstack++] = MODL->nbody;
                status = SUCCESS;
                goto next_branch;
            }

            ebodyl = MODL->body[ibodyl].ebody;

            /* create a Body */
            status = newBody(MODL, ibrch, type, ibodyl, -1,
                             args, hasdots, MODL->body[ibodyl].botype, &ibody);
            CHECK_STATUS(newBody);

            /* default behavior is to ignore the arguments and simply copy the Body */
            status = EG_copyObject(ebodyl, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters and finish Body (SPECIAL) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[nstack++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);
        }

        /* keep track of profile info */
        new_time = clock();

        if (type >= OCSM_DIMENSION && type <= OCSM_MESSAGE) {
            MODL->profile[type-100].ncall += 1;
            MODL->profile[type-100].time  += (new_time - old_time);
        }

        /* record the required CPU time to create this Body */
        if (MODL->nbody > nbodySave) {
            MODL->body[MODL->nbody].CPU = (double)(new_time - old_time) / (double)(CLOCKS_PER_SEC);
        }

        /* record that we successfully executed this Branch */
        *builtTo = ibrch;

next_branch:
        /* restore the stack if there is an error */
        if (MODL->sigCode == OCSM_UNDERCONSTRAINED ||
            MODL->sigCode == OCSM_OVERCONSTRAINED  ||
            MODL->sigCode == OCSM_NOT_CONVERGED      ) {
            // do nothing
        } else if (MODL->sigCode != 0) {
            nstack      = nstackSave;
            MODL->nbody = nbodySave;
        }

        /* clean up all unattached egos */
        if (MODL->loadEgads < 0 || (MODL->loadEgads == 0 && MODL->nbody >= MODL->recycle)) {
            (MODL->cleanup)--;
            if (MODL->cleanup <= 0) {
                MODL->cleanup = 25;

                (void) EG_setOutLevel(MODL->context, 0);
                status = EG_deleteObject(MODL->context);
                (void) EG_setOutLevel(MODL->context, outLevel);
                CHECK_STATUS(EG_deleteObject);
            }
        }

        /* set up @stack */
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, "@stack") == 0      &&
                MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                if (nstack < 1) {
                    MODL->pmtr[ipmtr].value[0] = -1;
                    MODL->pmtr[ipmtr].ncol     = 1;
                } else {
                    for (i = 0; i < nstack; i++) {
                        MODL->pmtr[ipmtr].value[i] = stack[i];
                    }
                    MODL->pmtr[ipmtr].ncol = nstack;
                }
            }
        }

        /* print the current stack */
        if (MODL->printStack != 0) {
            SPRINT1(1, "Stack at end of \"%s\" statement:", ocsmGetText(type));
            for (i = 0; i < nstack; i++) {
                ibodyl = stack[i];

                if (ibodyl == 0) {
                    SPRINT1(1, "    stack[%3d] = Mark", i);
                } else if (ibodyl < 0) {
                    SPRINT2(1, "    stack[%3d] = Sketch %d", i, ibodyl);
                } else {
                    SPRINT8(1, "    stack[%3d] = Body %5d %-20s %-20s ileft=%3d, irite = %3d, ichld=%3d, igroup=%3d",
                            i, ibodyl,
                            ocsmGetText(MODL->body[ibodyl].brtype),
                            ocsmGetText(MODL->body[ibodyl].botype),
                            MODL->body[ibodyl].ileft,
                            MODL->body[ibodyl].irite,
                            MODL->body[ibodyl].ichld,
                            MODL->body[ibodyl].igroup);
                }
            }
        }

        if (PRINT_BODYS == 1) {
            int    nnode, nedge, nface;
            char   onstack;

            SPRINT1(1, "Bodys at end of \"%s\" statement:", ocsmGetText(type));
            SPRINT0(1, "   ibody                                     igroup ileft irite nnode nedge nface");
            for (ibodyl = 1; ibodyl <= MODL->nbody; ibodyl++) {
                if (MODL->body[ibodyl].ebody == NULL) {
                    nnode  = -1;
                    nedge  = -1;
                    nface  = -1;
                    oclass = -1;
                    mtype  = -1;
                } else {
                    EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, NODE, &nnode, NULL);
                    EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, EDGE, &nedge, NULL);
                    EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, FACE, &nface, NULL);
                    EG_getTopology( MODL->body[ibodyl].ebody, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
                }

                onstack = ' ';
                for (jstack = 0; jstack < nstack; jstack++) {
                    if (stack[jstack] == ibodyl) {
                        onstack = '*';
                        break;
                    }
                }

                SPRINT10(1, "   %5d%c %-20s %-14s %5d %5d %5d %5d %5d %5d",
                         ibodyl, onstack,
                         ocsmGetText(MODL->body[ibodyl].brtype),
                         ocsmGetText(MODL->body[ibodyl].botype),
                         MODL->body[ibodyl].igroup,
                         MODL->body[ibodyl].ileft,
                         MODL->body[ibodyl].irite,
                         nnode, nedge, nface);
            }
        }
    }

finalize:
    SPRINT0(1, "    finalizing:");

    /* mark all Branches up to builtTo as as not dirty and those after
       builtTo as dirty */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        if (ibrch <= *builtTo) {
            MODL->brch[ibrch].dirty = 0;
        } else {
            MODL->brch[ibrch].dirty = 1;
        }
    }

    /* verify that the level is back to 0 */
    if (MODL->scope[MODL->level] != 0) {
        status = OCSM_INTERNAL_ERROR;
        signalError(MODL, status,
                    "MODL->scope=%d (but should be 0)", MODL->level);
    }

    /* special processing if there was an uncaught error signal */
    if (MODL->sigCode < 0) {

        /* close the Sketch */
        sket->type   = 0;
        sket->size   = 0;
        sket->solved = 1;
        sket->nseg   = 0;
        sket->nvar   = 0;
        sket->ncon   = 0;

        /* return negative of builtTo */
        (*builtTo) *= -1;

    /* special processing if there was an uncaught user-thrown signal */
    } else if (MODL->sigCode > 0) {
        SPRINT1(1, "WARNING:: there was an uncaught user-thrown signal %d",
                MODL->sigCode);
        (MODL->nwarn)++;

        /* close the Sketch */
        sket->type   = 0;
        sket->size   = 0;
        sket->solved = 1;
        sket->nseg   = 0;
        sket->nvar   = 0;
        sket->ncon   = 0;

        /* return negative of builtTo */
        (*builtTo) *= -1;
    }

    /* make sure the Sketch is not open */
    if (sket->nseg > 0) {
        SET_STATUS(OCSM_SKETCH_IS_OPEN, end);
    }

    /* free up the storage associated with the arguments */
    for (iarg = 1; iarg < 10; iarg++) {
        FREE(args[iarg].val);   /* also free's .str since they are unioned */
        FREE(args[iarg].dot);
    }

    /* make sure that user-supplied body[] is big enough */
    if (body != NULL && nstack > nbodyMax) {
        status = OCSM_TOO_MANY_BODYS_ON_STACK;
        goto cleanup;
    }

    /* pre-mark all the Bodys as not being on the stack (fixed below) */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        MODL->body[ibody].onstack = 0;
    }

    /* report a warning if there is a mark on the stack */
    for (i = 0; i < nstack; i++) {
        ibody = stack[i];
        if (ibody == 0) {
            SPRINT0(1, "WARNING:: mark being removed from the stack");
            (MODL->nwarn)++;

            for (j = i+1; j < nstack; j++) {
                stack[j-1] = stack[j];
            }
            nstack--;

            i--;  /* repeat in case first moved stack entry was also a mark */
        }
    }

    /* mark and (optionally) tessellate the stack's Bodys */
    for (i = 0; i < nstack; i++) {
        ibody = stack[i];
        MODL->body[ibody].onstack = 1;

        if (MODL->tessAtEnd == 1) {
            status = ocsmTessellate(MODL, ibody);
            CHECK_STATUS(ocsmTessellate);
        }
    }

    /* if any Body on the stack has _erepAttr and _erepAngle Attributes, create the EBody */
    if (MODL->tessAtEnd == 1 && MODL->erepAtEnd == 1) {
        for (ibody = 1; ibody <= MODL->nbody; ibody++) {
            if (MODL->body[ibody].onstack != 1) continue;

            status = EG_attributeRet(MODL->body[ibody].ebody, "_erepAngle", &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status != SUCCESS || attrType != ATTRREAL) continue;
            SPLINT_CHECK_FOR_NULL(tempRlist);
            dihedral = tempRlist[0];

            status = EG_attributeRet(MODL->body[ibody].ebody, "_erepAttr", &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS) {
                if (attrType == ATTRSTRING) {
                    status = EG_initEBody(MODL->body[ibody].etess, dihedral, &(MODL->body[ibody].eebody));
                    CHECK_STATUS(EG_initEBody);

                    status = EG_makeAttrEFaces(MODL->body[ibody].eebody, tempClist, &nefaces, NULL);
                    if (status != SUCCESS) {
                        status = EG_deleteObject(MODL->body[ibody].eebody);
                        CHECK_STATUS(EG_deleteObject);

                        MODL->body[ibody].eebody = NULL;

                        SPRINT1(1, "WARNING:: could not make an EBody of ibody=%d", ibody);
                        (MODL->nwarn)++;

                        continue;
                    }

                    status = EG_finishEBody(MODL->body[ibody].eebody);
                    CHECK_STATUS(EG_finishEBody);

                    /* tessellate the EBody */
                    status = EG_attributeRet(MODL->body[ibody].ebody, "__hasTess__", &attrType, &attrLen,
                                             &tempIlist, &tempRlist, &tempClist);
                    if (status != EGADS_SUCCESS || attrType != ATTRINT || attrLen != 1) {
                        status = EG_attributeRet(MODL->body[ibody].ebody, "_tParams", &attrType, &attrLen,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        status = EG_makeTessBody(MODL->body[ibody].eebody, (double*)tempRlist, &(MODL->body[ibody].eetess));
                        CHECK_STATUS(EG_makeTessBody);

                        status = EG_attributeAdd(MODL->body[ibody].eetess, ".tessType", ATTRSTRING, 4, NULL, NULL, "Tris");
                        CHECK_STATUS(EG_attributeAdd);
                    }
                }
            }
        }
    }

    /* return Bodys on the stack (LIFO) */
    if (body != NULL) {
        *nbody = nstack;
    }

    nbodyMax = nstack;
    for (i = 0; i < nbodyMax; i++) {
        if (body != NULL) {
            body[i] = stack[--nstack];

            if (MODL->body[body[i]].botype != OCSM_NODE_BODY) {
                status = getBodyTolerance(MODL->body[body[i]].ebody, &toler);
                CHECK_STATUS(getBodyTolerance);

                SPRINT5(1, "    Body %5d   nnode=%-6d   nedge=%-6d   nface=%-6d   toler=%11.4e", body[i],
                        MODL->body[body[i]].nnode,
                        MODL->body[body[i]].nedge,
                        MODL->body[body[i]].nface, toler);

                if (outLevel >= 3) {
                    status = printAttrs(MODL->body[i].ebody);
                    CHECK_STATUS(printAttrs);
                }
            } else {
                SPRINT5(1, "    Body %5d   nnode=%-6d   nedge=%-6d   nface=%-6d   toler=%11.4e", body[i],
                        1, 0, 0, 0.0);
            }
        }
    }

    /* print info for all Bodys in stack */
    if (PRINT_BODY_INFO == 1) {
        for (ibody = 1; ibody <= MODL->nbody; ibody++) {
            if (MODL->body[ibody].onstack > 0) {
                SPRINT1(1, "ibody=%d", ibody);
                status = printBodyInfo(&(MODL->body[ibody]));
                CHECK_STATUS(printBodyInfo);
            }
        }
    }

    /* since we do not know what goes on inside a UDP/UDF, set .hassens=1 on all
       Bodys associated with UDPRIMs if numdots>0 (to make sure that their cache's are removed) */
    if (MODL->numdots > 0) {
        for (ibody = 1; ibody <= MODL->nbody; ibody++) {
            if (MODL->body[ibody].brtype == OCSM_UDPRIM) {
                MODL->body[ibody].hassens = 1;
            }
        }
    }

    /* propagate the .hasdots to all children -- take care of internal Xsects, such as a RULE or BLEND */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        if (MODL->body[ibody].ichld > 0 && MODL->body[ibody].hasdots > 0) {
            MODL->body[MODL->body[ibody].ichld].hasdots = MODL->body[ibody].hasdots;
        }
    }

    /* propagate the hasdots to all children -- take care of multiple RESTOREs */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        ileft = MODL->body[ibody].ileft;
        irite = MODL->body[ibody].irite;

        if (ileft > 0) {
            if (MODL->body[ileft].hasdots > 0) {
                MODL->body[ibody].hasdots = 1;
            }
        }
        if (irite > 0) {
            if (MODL->body[irite].hasdots > 0) {
                MODL->body[ibody].hasdots = 1;
            }
        }
    }

    /* plot arc-length distribution for all Edges in all Bodys on stack */
#ifdef GRAFIC
    if (PLOT_ARCLENGTHS == 1) {
        int    periodic, iedge, ipnt;
        int    io_kbd=5, io_scr=6, ilin[3], isym[3], nper[3], nline, indgr;
        float  tplot[101], splot[101];
        double trange[4], tt, data[18], xlast, ylast, zlast;
        char   pltitl[80];

        SPRINT0(0, "plotting arc-length distributions using GRAFIC");

        sprintf(pltitl, "arc-length distribution");
        grinit_(&io_kbd, &io_scr, pltitl, STRLEN(pltitl));

        for (ibody = 1; ibody <= MODL->nbody; ibody++) {
            if (MODL->body[ibody].onstack == 0) continue;

            for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
                if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) continue;

                EG_getRange(MODL->body[ibody].edge[iedge].eedge, trange, &periodic);

                EG_evaluate(MODL->body[ibody].edge[iedge].eedge, trange, data);

                tplot[0] = trange[0];
                splot[0] = 0;

                for (ipnt = 1; ipnt < 101; ipnt++) {
                    xlast = data[0];
                    ylast = data[1];
                    zlast = data[2];

                    tt = trange[0] + (trange[1] - trange[0]) * (double)(ipnt) / 101.;

                    EG_evaluate(MODL->body[ibody].edge[iedge].eedge, &tt, data);

                    tplot[ipnt] = tt;
                    splot[ipnt] = splot[ipnt-1] + sqrt(SQR(data[0]-xlast) + SQR(data[1]-ylast) + SQR(data[2]-zlast));
                }

                indgr   = 1  + 4 + 8 + 16 + 64;
                ilin[0] = +GR_SOLID;
                isym[0] = -GR_STAR;
                nper[0] = 101;
                nline   = 1;

                sprintf(pltitl, "~t~s~Body %d, Edge %d", ibody, iedge);
                grline_(ilin, isym, &nline, pltitl,
                        &indgr, tplot, splot, nper, STRLEN(pltitl));
            }
        }
    }
#endif // GRAFIC

    /* plot trim curves for all Faces all Bodys on stack */
#ifdef GRAFIC
    if (PLOT_TRIMCURVES == 1) {
        int     ibody, iface, oclass, mtype, nloop, *senses, nedge, iedge, periodic, i;
        double  data[18], trange[4], t;
        int     io_kbd=5, io_scr=6, indgr=1+4+16+64;
        int     ndata, nline, *nper=NULL, *ilin=NULL, *isym=NULL;
        float   *uplot=NULL, *vplot=NULL;
        char    pltitl[80];
        ego     eref, *eloops, *eedges, topref, prev, next;

        SPRINT0(0, "Plotting trim curves using GRAFIC");

        grinit_(&io_kbd, &io_scr, "Trim curves", STRLEN("Trim curves"));

        for (ibody = 1; ibody <= MODL->nbody; ibody++) {
            if (MODL->body[ibody].onstack == 0) continue;

            for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                status = EG_getTopology(MODL->body[ibody].face[iface].eface,
                                        &eref, &oclass, &mtype, data, &nloop, &eloops, &senses);
                CHECK_STATUS(EG_getTopology);

                status = EG_getInfo(eref, &oclass, &mtype, &topref, &prev, &next);
                CHECK_STATUS(EG_getInfo);

                if (mtype == PLANE) continue;

                status = EG_getTopology(eloops[0], &eref, &oclass, &mtype, data, &nedge, &eedges, &senses);
                CHECK_STATUS(EG_getTopology);

                MALLOC(uplot, float, 101*nedge);
                MALLOC(vplot, float, 101*nedge);
                MALLOC(nper,  int,       nedge);
                MALLOC(ilin,  int,       nedge);
                MALLOC(isym,  int,       nedge);

                sprintf(pltitl, "~u~v~ ibody=%d, iface=%d", ibody, iface);
                ndata = 0;
                nline = 0;

                for (iedge = 0; iedge < nedge; iedge++) {
                    status = EG_getRange(eedges[iedge], trange, &periodic);
                    CHECK_STATUS(EG_getRange);

                    for (i = 0; i < 101; i++) {
                        t = trange[0] + (trange[1] - trange[0]) * i * 0.01;

                        status = EG_evaluate(eedges[iedge+nedge], &t, data);
                        CHECK_STATUS(EG_evaluate);

                        uplot[ndata] = data[0];
                        vplot[ndata] = data[1];
                        ndata++;
                    }

                    nper[nline] = 101;
                    ilin[nline] = GR_SOLID;
                    isym[nline] = -GR_SQUARE;
                    nline++;
                }

                grline_(ilin, isym, &nline, pltitl, &indgr, uplot, vplot, nper, STRLEN(pltitl));

                FREE(uplot);
                FREE(vplot);
                FREE(nper );
                FREE(ilin );
                FREE(isym );
            }
        }
    }
#endif // GRAFIC

    /* compute distance between Face evaluations and tessellation points at boundaries of Faces */
    if (0) {
        double xyz_out[18], dist, tol=1e-2;

        SPRINT0(0, "Checking distances at boundaries of Faces");

        for (ibody = 1; ibody <= MODL->nbody; ibody++) {
            if (MODL->body[ibody].onstack != 1) continue;

            for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
                status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                        &npnt, &xyz, &uv, &ptype, &pindx,
                                        &ntri, &tris, &tric);
                CHECK_STATUS(EG_getTessFace);

                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    if (ptype[ipnt] >= 0) {
                        status = EG_evaluate(MODL->body[ibody].face[iface].eface, &(uv[2*ipnt]), xyz_out);
                        CHECK_STATUS(EG_evaluate);

                        dist = sqrt((xyz[3*ipnt  ]-xyz_out[0]) * (xyz[3*ipnt  ]-xyz_out[0])
                                   +(xyz[3*ipnt+1]-xyz_out[1]) * (xyz[3*ipnt+1]-xyz_out[1])
                                   +(xyz[3*ipnt+2]-xyz_out[2]) * (xyz[3*ipnt+2]-xyz_out[2]));
                        if (dist > tol) {
                            SPRINT7(0, "ibody=%2d, iface=%3d, ipnt=%4d, dist=%12.4e (%12.5f %12.5f %12.5f)",
                                   ibody, iface, ipnt, dist, xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
                        }
                    }
                }
            }
        }
    }

cleanup:
    if (modl != NULL) {
        (void) EG_setOutLevel(MODL->context, 0);
        status2 = EG_deleteObject(MODL->context);
        (void) EG_setOutLevel(MODL->context, outLevel);
        if (status2 < EGADS_SUCCESS) {
            printf( "ERROR:: BAD STATUS = %d from %s (called from %s:%d)\n", status2, "EG_deleteObject", routine, __LINE__);
        }
    }

    for (iarg = 1; iarg < 10; iarg++) {
        FREE(args[iarg].val);   /* also free's .str since they are unioned */
        FREE(args[iarg].dot);
    }

    fflush(0);

    FREE(props  );
    FREE(sket   );
    FREE(solcons);
    FREE(solvars);
    FREE(patn   );
    FREE(macros );
    FREE(stack  );
    FREE(iblist );
    FREE(values );
    FREE(dots   );

#undef CATCH_STATUS
    /* if MODL->sigCode is not success, return it */
    if (modl != NULL) {
        if (MODL->sigCode != SUCCESS) {
            status = MODL->sigCode;
        }
    }

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintProfile - print profile from last ocsmBuild()             *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintProfile(void   *modl,          /* (in)  pointer to MODL */
                 char   filename[])     /* (in)  file to which output is appended (or "" for stdout) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       i, total_call;
    FILE      *fp=NULL;
    clock_t   total_time;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmPrintProfile);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    if (strlen(filename) == 0) {
        fp = stdout;
    } else {
        fp = fopen(filename, "a");
        if (fp == NULL) {
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }
    }

    /* print the profile info */
    fprintf(fp, "==> Profile information\n");
    total_time = 0;
    total_call = 0;
    for (i = 0; i < 101; i++) {
        total_call += MODL->profile[i].ncall;
        total_time += MODL->profile[i].time;
    }
    fprintf(fp, "    Branch type           ncall  time (sec)    pct\n");
    for (i = 0; i < 101; i++) {
        if (MODL->profile[i].ncall > 0) {
            fprintf(fp, "    %-20s  %5d  %10.3f  %5.1f\n", ocsmGetText(i+100), MODL->profile[i].ncall,
                    (double)(MODL->profile[i].time) / (double)(CLOCKS_PER_SEC),
                    (double)(MODL->profile[i].time) / (double)(total_time) * 100);
        }
    }
    fprintf(fp, "    Total                 %5d  %10.3f\n", total_call, (double)(total_time)/(double)(CLOCKS_PER_SEC));

cleanup:
    if (fp != NULL && strlen(filename) > 0) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmTessellate - tessellate one or more Bodys                      *
 *                                                                      *
 ************************************************************************
 */

int
ocsmTessellate(void   *modl,            /* (in)  pointer to MODL */
               int    ibody)            /* (in)  Body index (1:nbody) or 0 for all on stack */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jbody, attrType, attrLen, iface, iedge, oclass, mtype, mtype_face, nlup, ilup;
    int       npnt_edge, npnt_face, ntri_face, nedg, ii, ipnt, itri, nchild;
    int       npnt_egg, nbnd_egg, ntri_egg, nquad, state, npts, count;
    int       nbnd, lup[20], *senses, *tris_new=NULL;
    CINT      *tempIlist, *pindx, *ptype, *tris, *tric, *p_egg, *tris_egg;
    double    params[3], bbox[6], size, uvlims[4], data[18];
    double    *uv_new=NULL, *xyz_new=NULL;
    CDOUBLE   *tempRlist, *xyz_edge, *t_edge, *xyz_face, *uv_face, *uv_egg;
    CCHAR     *tempClist;
    void      *eggdata, *eggdata_new;
    modl_T    *BASE;
    ego       eref, *elups, *eedgs, *echilds, ebody, newBody, newTess;

    ROUTINE(ocsmTessellate);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check for valid Body */
    if (ibody < 0 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    BASE = MODL->basemodl;

    /* loop through all Bodys */
    for (jbody = 1; jbody <= MODL->nbody; jbody++) {

        /* if ibody is specified and not this Body, skip jbody */
        if (ibody > 0 && jbody != ibody) {
            continue;

        /* if no Bodys specified but jbody is not on the stack, skip jbody */
        } else if (ibody == 0 && MODL->body[jbody].onstack == 0) {
            continue;
        }

        /* if the Body is a Node, return now */
        if (MODL->body[jbody].botype == OCSM_NODE_BODY) {
            continue;
        }

        /* if there is already a tessellation, return now */
        if (MODL->body[jbody].etess != NULL) {
            continue;
        }

        /* keep track of the number of Faces that are quadded */
        nquad = 0;

        /* set up the tessellation parameters.  if there are .tParams
           on this Body, use them */
        status = EG_attributeRet(MODL->body[jbody].ebody,
                                 ".tParams", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrLen == 3) {
            params[0] = tempRlist[0];
            params[1] = tempRlist[1];
            params[2] = tempRlist[2];

            /* otherwise, use the defaults based upon the size of the bounding box */
        } else {
            status = EG_getBoundingBox(MODL->body[jbody].ebody, bbox);
            CHECK_STATUS(EG_getBoundingBox);

            size = sqrt(SQR(bbox[3]-bbox[0]) + SQR(bbox[4]-bbox[1]) + SQR(bbox[5]-bbox[2]));

            params[0] = TESS_PARAM_0 * size;
            params[1] = TESS_PARAM_1 * size;
            params[2] = TESS_PARAM_2;
        }

        /* print tessellation parameters */
        SPRINT4(1, "--> Tessellating Body %6d     (%12.5e %12.5e %7.3f)",
                jbody, params[0], params[1], params[2]);

        /* this is a base (not perturbed) MODL */
        if (BASE == NULL) {

            /* start by using EGADS' tessellator so that the Node and Edges
               get properly tessellated */
            status = EG_makeTessBody(MODL->body[jbody].ebody, params,
                                     &(MODL->body[jbody].etess));
            CHECK_STATUS(EG_makeTessBody);

            status = EG_attributeAdd(MODL->body[jbody].etess, ".tessType", ATTRSTRING, 4, NULL, NULL, "Tris");
            CHECK_STATUS(EG_attributeAdd);

            /* overwrite the _tParams Attribute so that we know how the Body
               was tessellated */
            status = EG_attributeAdd(MODL->body[jbody].ebody, "_tParams", ATTRREAL,
                                     3, NULL, params, NULL);
            CHECK_STATUS(EG_attributeAdd);

            /* .tessType=="Mixed" indicates that templates were used and there
               is at least one Face that is all quads.   in this case, .mixed will be set
               (for all Faces) */

            /* make new-style Quads (whole Body) if Attribute is set on the Body */
            status = EG_attributeRet(MODL->body[jbody].ebody,
                                     "_makeQuads", &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS) {

                /* new-style quadding, where .tessType=="Quad" and .mixed is created */
                status = EG_quadTess(MODL->body[jbody].etess, &newTess);
                if (status == SUCCESS) {
                    EG_deleteObject(MODL->body[jbody].etess);

                    MODL->body[jbody].etess = newTess;
                } else {
                    status = SUCCESS;
                }

             /* make old-style Quads (on a Face) if Attribute is set on the Face.
                this does not have a .tessType and cannot be dumped to an .egads file */
            } else {
                params[0] = 0;
                params[1] = 0;
                params[2] = 0;
                for (iface = 1; iface <= MODL->body[jbody].nface; iface++) {
                    status = EG_attributeRet(MODL->body[jbody].face[iface].eface,
                                             "_makeQuads", &attrType, &attrLen,
                                             &tempIlist, &tempRlist, &tempClist);
                    if (status == SUCCESS) {
                        status = EG_makeQuads(MODL->body[jbody].etess, params, iface);
                        if (status == SUCCESS) {
                            nquad++;
                        }
                    } else {
                        status = SUCCESS;
                    }
                }
                if (nquad > 0 && nquad < MODL->body[jbody].nface) {
                    SPRINT3(1, "WARNING:: only %d of %d Faces were quadded for Body %d",
                            nquad, MODL->body[jbody].nface, jbody);
                    (MODL->nwarn)++;
                }
            }

            /* find the minimum number of points in any Face tessellation */
            count = 0;
            for (iface = 1; iface <= MODL->body[jbody].nface; iface++) {
                status = EG_getTessFace(MODL->body[jbody].etess, iface,
                                        &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                        &ntri_face, &tris, &tric);
                CHECK_STATUS(EG_getTessface);

                if (npnt_face <= 0) count++;
            }

            /* there is an external grid generator */
            if (STRLEN(MODL->eggname) > 0 && count > 0) {
                SPRINT3(1, "WARNING:: external tessellator skipped for Body %d because %d of %d Faces were not tessellated",
                        jbody, count, MODL->body[jbody].nface);
                (MODL->nwarn)++;

            } else if (STRLEN(MODL->eggname) > 0) {

                /* open the current tessellation for editing */
                status = EG_openTessBody(MODL->body[jbody].etess);
                CHECK_STATUS(EG_openTessBody);

                /* loop through each face and make an alternative tessellation */
                for (iface = 1; iface <= MODL->body[jbody].nface; iface++) {

                    /* get the EGADS tessellation */
                    status = EG_getTessFace(MODL->body[jbody].etess, iface,
                                            &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                            &ntri_face, &tris, &tric);
                    CHECK_STATUS(EG_getTessface);

                    /* set up the Loop information */
                    status = EG_getTopology(MODL->body[jbody].face[iface].eface, &eref,
                                            &oclass, &mtype_face, uvlims, &nlup, &elups, &senses);
                    CHECK_STATUS(EG_getTopology);

                    nbnd = 0;
                    for (ilup = 0; ilup < nlup; ilup++) {
                        lup[ilup] = 0;

                        status = EG_getTopology(elups[ilup], &eref,
                                                &oclass, &mtype, uvlims, &nedg, &eedgs, &senses);
                        CHECK_STATUS(EG_getTopology);

                        for (ii = 0; ii < nedg; ii++) {
                            iedge = EG_indexBodyTopo(MODL->body[jbody].ebody, eedgs[ii]);

                            status = EG_getTopology(eedgs[ii], &eref, &oclass, &mtype,
                                                    data, &nchild, &echilds, &senses);
                            CHECK_STATUS(EG_getTopology);

                            /* degenerate Edge has 2 Points, but only one of them
                               is in the Loop */
                            if (mtype == DEGENERATE) continue;

                            status = EG_getTessEdge(MODL->body[jbody].etess, iedge,
                                                    &npnt_edge, &xyz_edge, &t_edge);
                            CHECK_STATUS(eg_getTessEdge);

                            lup[ilup] += (npnt_edge - 1);
                        }
                        nbnd += lup[ilup];
                    }

                    lup[nlup] = 0;

                    /* if all the points are Boundary Nodes, there are no Nodes
                       that are internal to the Face that need to be generated */
                    if (nbnd == npnt_face) continue;

                    /* get enough space to hold the Boundary points */
                    MALLOC(uv_new, double, 2*npnt_face);

                    /* set up boundary points */
                    for (ipnt = 0; ipnt < nbnd; ipnt++) {
                        uv_new[2*ipnt  ] = uv_face[2*ipnt  ];
                        uv_new[2*ipnt+1] = uv_face[2*ipnt+1];
                    }

                    /* generate the new grid */
                    status = MODL->eggGenerate(uv_new, lup, &eggdata);
                    /* CHECK_STATUS below */

                    FREE(uv_new);

                    /* if a successful tessellation, put the tessellation info into
                       EGADS etess object */
                    if (status == SUCCESS) {
                        status = MODL->eggInfo(eggdata, &npnt_egg, &nbnd_egg, &uv_egg, &p_egg,
                                               &ntri_egg, &tris_egg);
                        CHECK_STATUS(eggInfo);

                        SPRINT5(1, "WARNING:: using eggGenerate for Face %3d:%-5d  (npnt=%5d, nbnd=%5d, ntri=%5d)",
                                jbody, iface, npnt_egg, nbnd_egg, ntri_egg);
                        (MODL->nwarn)++;

                        MALLOC(uv_new,   double, 2*npnt_egg);
                        MALLOC(xyz_new,  double, 3*npnt_egg);
                        MALLOC(tris_new, int,    3*ntri_egg);

                        for (ipnt = 0; ipnt < nbnd_egg; ipnt++) {
                            uv_new[ 2*ipnt  ] = uv_face[ 2*ipnt  ];
                            uv_new[ 2*ipnt+1] = uv_face[ 2*ipnt+1];
                            xyz_new[3*ipnt  ] = xyz_face[3*ipnt  ];
                            xyz_new[3*ipnt+1] = xyz_face[3*ipnt+1];
                            xyz_new[3*ipnt+2] = xyz_face[3*ipnt+2];
                        }

                        for (ipnt = nbnd_egg; ipnt < npnt_egg; ipnt++) {
                            uv_new[2*ipnt  ] = uv_egg[2*ipnt  ];
                            uv_new[2*ipnt+1] = uv_egg[2*ipnt+1];

                            status = EG_evaluate(MODL->body[jbody].face[iface].eface,
                                                 &(uv_new[2*ipnt]), data);
                            CHECK_STATUS(EG_evaluate);

                            xyz_new[3*ipnt  ] = data[0];
                            xyz_new[3*ipnt+1] = data[1];
                            xyz_new[3*ipnt+2] = data[2];
                        }

                        if (mtype_face == SFORWARD) {
                            for (itri = 0; itri < ntri_egg; itri++) {
                                tris_new[3*itri  ] = tris_egg[3*itri  ] + 1;
                                tris_new[3*itri+1] = tris_egg[3*itri+1] + 1;
                                tris_new[3*itri+2] = tris_egg[3*itri+2] + 1;
                            }
                        } else {
                            for (itri = 0; itri < ntri_egg; itri++) {
                                tris_new[3*itri  ] = tris_egg[3*itri+2] + 1;
                                tris_new[3*itri+1] = tris_egg[3*itri+1] + 1;
                                tris_new[3*itri+2] = tris_egg[3*itri  ] + 1;
                            }
                        }

                        status = EG_setTessFace(MODL->body[jbody].etess, iface,
                                                npnt_egg, xyz_new, uv_new,
                                                ntri_egg, tris_new);
                        CHECK_STATUS(EG_setTessFace);

                        FREE(tris_new);
                        FREE(uv_new  );
                        FREE(xyz_new );

                        /* remember the new egg data */
                        MODL->body[jbody].face[iface].eggdata = (void*) eggdata;

                        /* unsuccessful external tessellator */
                    } else {
                        SPRINT2(1, "WARNING:: external tessellator skipped for Face %d:%d", jbody, iface);
                        SPRINT0(1, "          reverting to EGADS");
                        (MODL->nwarn)++;

                        status = MODL->eggFree(eggdata);
                        CHECK_STATUS(eggFree);
                    }
                }

                /* cheking the status of the etess closes it */
                status = EG_statusTessBody(MODL->body[jbody].etess, &ebody, &state, &npts);
                CHECK_STATUS(EG_statusTessBody);
            }

            /* print out bounding box info if a Face contains no Triangles */
            for (iface = 1; iface <= MODL->body[jbody].nface; iface++) {
                status = EG_getTessFace(MODL->body[jbody].etess, iface,
                                        &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                        &ntri_face, &tris, &tric);
                CHECK_STATUS(EG_getTessFace);

                if (ntri_face <= 0) {
                    status = EG_getBoundingBox(MODL->body[jbody].face[iface].eface, bbox);
                    CHECK_STATUS(EG_getBoundingBox);

                    SPRINT4(1, "WARNING:: Face %3d:%-4d has no triangles,  %12.4f <= x <= %12.4f", jbody, iface, bbox[0], bbox[3]);
                    SPRINT2(1, "                                           %12.4f <= y <= %12.4f",               bbox[1], bbox[4]);
                    SPRINT2(1, "                                           %12.4f <= z <= %12.4f",               bbox[2], bbox[5]);
                    (MODL->nwarn)++;

#ifdef GRAFIC
                    {
                        int io_kbd=5, io_scr=6, indgr=1+2+4+16+64, isymb=0;
                        char  pltitl[80];

                        grinit_(&io_kbd, &io_scr, "plotTile", STRLEN("plotTile"));

                        snprintf(pltitl, 80, "~u~v~Face %d:%d", jbody, iface);
                        grctrl_(plotFace, &indgr, pltitl,
                                (void*)(MODL),
                                (void*)(&jbody),
                                (void*)(&iface),
                                (void*)(&isymb),
                                (void*)NULL,
                                (void*)NULL,
                                (void*)NULL,
                                (void*)NULL,
                                (void*)NULL,
                                (void*)NULL,
                                STRLEN(pltitl));
                    }
#endif
                }
            }

        /* this is a perturbed MODL */
        } else {

            /* map BASE jbody's tessellation onto the current MODL jbody */
            if (BASE->body[jbody].etess != NULL) {
                if (MODL->body[jbody].etess == NULL) {

                    /* check if the body needs to be mapped */
                    status = EG_attributeRet(MODL->body[jbody].ebody,
                                             "__mapBody__", &attrType, &attrLen,
                                             &tempIlist, &tempRlist, &tempClist);
                    if (status != EGADS_SUCCESS) {
                        status = EG_mapBody(BASE->body[jbody].ebody, MODL->body[jbody].ebody,
                                            "_faceID", &newBody);
                        if (status == SUCCESS && newBody != NULL) {

//$$$                        // &&&&& do we need to clean up udp cache here?

                            EG_deleteObject(MODL->body[jbody].ebody);
                            MODL->body[jbody].ebody = newBody;

                            status = finishBody(MODL,jbody);
                            CHECK_STATUS(finishBody);
                        }

                        /* tag that the body has been mapped */
                        status = EG_attributeAdd(MODL->body[jbody].ebody, "__mapBody__", ATTRINT,
                                                 1, &jbody, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);
                    }

                    status = EG_mapTessBody(BASE->body[jbody].etess, MODL->body[jbody].ebody,
                                            &(MODL->body[jbody].etess));
                    CHECK_STATUS(EG_mapTessBody);
                }
            }

            /* if there is a registered external grid generator, edit the tessellation
               that was made above */
            if (STRLEN(BASE->eggname) > 0 && MORPH_GRID == 1) {

                /* open the current tessellation for editing */
                status = EG_openTessBody(MODL->body[jbody].etess);
                CHECK_STATUS(EG_openTessBody);

                for (iface = 1; iface <= MODL->body[jbody].nface; iface++) {
                    eggdata = BASE->body[jbody].face[iface].eggdata;

                    /* call the external grid generator to put the
                       morphed tessellation onto the Faces of the ptrb Body */
                    if (eggdata != NULL) {
                        status = BASE->eggInfo(eggdata, &npnt_egg, &nbnd_egg, &uv_egg, &p_egg,
                                               &ntri_egg, &tris_egg);
                        CHECK_STATUS(eggInfo);

                        SPRINT5(1, "WARNING:: using eggMorph for Face %3d:%-5d  (npnt=%5d, nbnd=%5d, ntri=%5d)",
                                jbody, iface, npnt_egg, nbnd_egg, ntri_egg);
                        (MODL->nwarn)++;

                        status = EG_getTessFace(MODL->body[jbody].etess, iface,
                                                &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                                &ntri_face, &tris, &tric);
                        CHECK_STATUS(EG_getTessFace);

                        MALLOC(xyz_new, double, 3*npnt_egg);
                        MALLOC(uv_new,  double, 2*npnt_egg);

                        for (ipnt = 0; ipnt < nbnd_egg; ipnt++) {
                            uv_new[ 2*ipnt  ] = uv_face[ 2*ipnt ];
                            uv_new[ 2*ipnt+1] = uv_face[ 2*ipnt+1];
                            xyz_new[3*ipnt  ] = xyz_face[3*ipnt  ];
                            xyz_new[3*ipnt+1] = xyz_face[3*ipnt+1];
                            xyz_new[3*ipnt+2] = xyz_face[3*ipnt+2];
                        }

                        status = BASE->eggMorph(eggdata, uv_new, &eggdata_new);
                        CHECK_STATUS(eggMorph);

                        status = BASE->eggFree(eggdata_new);
                        CHECK_STATUS(eggFree);

                        for (ipnt = nbnd_egg; ipnt < npnt_egg; ipnt++) {
                            status = EG_evaluate(MODL->body[jbody].face[iface].eface,
                                                 &(uv_new[2*ipnt]), data);
                            CHECK_STATUS(EG_evaluate);

                            xyz_new[3*ipnt  ] = data[0];
                            xyz_new[3*ipnt+1] = data[1];
                            xyz_new[3*ipnt+2] = data[2];
                        }

                        status = EG_setTessFace(MODL->body[jbody].etess, iface,
                                                npnt_face, xyz_new, uv_new,
                                                ntri_face, tris);
                        CHECK_STATUS(EG_setTessFace);

                        FREE(xyz_new);
                        FREE(uv_new);
                    }
                }

                /* cheking the status of the etess closes it */
                status = EG_statusTessBody(MODL->body[jbody].etess, &ebody, &state, &npts);
                CHECK_STATUS(EG_statusTessBody);

                SPRINT1(1, "--> EG_statusTessBody -> status=%d", status);
            }
        }

        /* if there were no quads, create the global IDs */
        if (nquad == 0) {
            MODL->body[jbody].npnts = MODL->body[jbody].nnode;
            MODL->body[jbody].ntris = 0;

            for (iedge = 1; iedge <= MODL->body[jbody].nedge; iedge++) {
                MODL->body[jbody].edge[iedge].globid = MODL->body[jbody].npnts - 1;

                status = EG_getTessEdge(MODL->body[jbody].etess, iedge,
                                        &npnt_edge, &xyz_edge, &t_edge);
                CHECK_STATUS(EG_getTessEdge);

                MODL->body[jbody].npnts += (npnt_edge-2);
            }

            for (iface = 1; iface <= MODL->body[jbody].nface; iface++) {
                status = EG_getTessFace(MODL->body[jbody].etess, iface,
                                        &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                        &ntri_face, &tris, &tric);
                CHECK_STATUS(EG_getTessFace);

                for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                    if (ptype[ipnt] < 0) {
                        MODL->body[jbody].face[iface].globid = MODL->body[jbody].npnts - ipnt + 1;
                        MODL->body[jbody].npnts += (npnt_face - ipnt);
                        break;
                    }
                }

                MODL->body[jbody].ntris += ntri_face;
            }

            /* otherwise (there are quads), so initialize global IDs to zero */
        } else {
            MODL->body[jbody].npnts = 0;
            MODL->body[jbody].ntris = 0;

            for (iedge = 1; iedge <= MODL->body[jbody].nedge; iedge++) {
                MODL->body[jbody].edge[iedge].globid = 0;
            }
            for (iface = 1; iface <= MODL->body[jbody].nface; iface++) {
                MODL->body[jbody].face[iface].globid = 0;
            }
        }
    }

cleanup:
    FREE(uv_new);
    FREE(xyz_new);
    FREE(tris_new);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmBodyDetails - get information about one Body                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmBodyDetails(void   *modl,           /* (in)  pointer to MODL */
                char   filename[],      /* (in)  name of fiole from which Body was created */
                int    linenum,         /* (in)  line in filename from which Body was created */
                char   *info[])         /* (out) info about the Body (freeable) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ibody, jbody, ibrch, istor, i, attrType, attrLen, mchar;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    char      line[MAX_LINE_LEN], onstack, name[MAX_NAME_LEN];
    CCHAR     *tempClist;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmBodyDetails);

    /* --------------------------------------------------------------- */

    /* initialize output buffer */
    mchar = 1000;
    MALLOC(*info, char, mchar);
    *info[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* find the Body that matches filename:linenum */
    ibody = 0;
    for (jbody = 1; jbody <= MODL->nbody; jbody++) {
        ibrch = MODL->body[jbody].ibrch;

        if (strcmp(MODL->brch[ibrch].filename, filename) == 0      &&
                   MODL->brch[ibrch].linenum             == linenum  ) {
            ibody = jbody;
            break;
        }
    }

    /* if no Body created by given line, list all Bodys */
    if (ibody == 0) {
        snprintf(line, MAX_LINE_LEN, "Listing of all Bodys (* if on stack):\n");

        if (strlen(*info)+strlen(line) >= mchar) {
            mchar += 1000;
            RALLOC(*info, char, mchar);
        }
        strcat(*info, line);

        for (ibody = 1; ibody <= MODL->nbody; ibody++) {
            if (MODL->body[ibody].onstack == 0) {
                onstack = ' ';
            } else {
                onstack = '*';
            }

            status = EG_attributeRet(MODL->body[ibody].ebody, "_name", &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == EGADS_SUCCESS && attrType == ATTRSTRING) {
                snprintf(name, 19, "%s", tempClist);
            } else {
                status = SUCCESS;
                snprintf(name, 19, "Body %d", ibody);
            }

            ibrch = MODL->body[ibody].ibrch;

            snprintf(line, MAX_LINE_LEN, "%c %-20s %-10s (%-10s @ [[%s:%d]])\n", onstack,
                     name, ocsmGetText(MODL->body[ibody].botype), ocsmGetText(MODL->body[ibody].brtype),
                     MODL->brch[ibrch].filename, MODL->brch[ibrch].linenum);

            if (strlen(*info)+strlen(line) >= mchar) {
                mchar += 1000;
                RALLOC(*info, char, mchar);
            }
            strcat(*info, line);

            /* add storage info if it exists */
            for (istor = 0; istor < MODL->nstor; istor++) {
                for (i = 0; i < MODL->stor[istor].nbody; i++) {
                    if (ibody == MODL->stor[istor].ibody[i]) {
                        snprintf(line, MAX_LINE_LEN, "        stored in %-20s %d\n",
                                 MODL->stor[istor].name, MODL->stor[istor].index);

                        if (strlen(*info)+strlen(line) >= mchar) {
                            mchar += 1000;
                            RALLOC(*info, char, mchar);
                        }
                        strcat(*info, line);
                    }
                }
            }
        }

    /* otherwise, return info for a specific Body */
    } else {
        status = EG_attributeRet(MODL->body[ibody].ebody, "_name", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == EGADS_SUCCESS && attrType == ATTRSTRING) {
            snprintf(name, 19, "%s", tempClist);
        } else {
            status = SUCCESS;
            snprintf(name, 19, "Body %d", ibody);
        }

        snprintf(line, MAX_LINE_LEN, "%-20s          (%-10s @ [[%s:%d]])\n", name,
                 ocsmGetText(MODL->body[ibody].brtype), filename, linenum);

        if (strlen(*info)+strlen(line) >= mchar) {
            mchar += 1000;
            RALLOC(*info, char, mchar);
        }
        strcat(*info, line);

        /* find all the Bodys that are used by this Body */
        for (jbody = 1; jbody <= MODL->nbody; jbody++) {
            if (jbody == ibody) continue;

            if (MODL->body[ibody].ileft == jbody ||
                MODL->body[ibody].irite == jbody ||
                MODL->body[jbody].ichld == ibody   ) {
                status = EG_attributeRet(MODL->body[jbody].ebody, "_name", &attrType, &attrLen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_SUCCESS && attrType == ATTRSTRING) {
                    snprintf(name, 19, "%s", tempClist);
                } else {
                    status = SUCCESS;
                    snprintf(name, 19, "Body %d", jbody);
                }

                ibrch = MODL->body[jbody].ibrch;

                snprintf(line, MAX_LINE_LEN, "uses:    %-20s (%-10s @ [[%s:%d]])\n", name,
                         ocsmGetText(MODL->brch[ibrch].type),
                         MODL->brch[ibrch].filename, MODL->brch[ibrch].linenum);

                if (strlen(*info)+strlen(line) >= mchar) {
                    mchar += 1000;
                    RALLOC(*info, char, mchar);
                }
                strcat(*info, line);
            }
        }

        /* find all the Bodys that us this Body */
        for (jbody = 1; jbody <= MODL->nbody; jbody++) {
            if (jbody == ibody) continue;

            if (MODL->body[jbody].ileft == ibody ||
                MODL->body[jbody].irite == ibody ||
                MODL->body[ibody].ichld == jbody   ) {
                status = EG_attributeRet(MODL->body[jbody].ebody, "_name", &attrType, &attrLen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_SUCCESS && attrType == ATTRSTRING) {
                    snprintf(name, 19, "%s", tempClist);
                } else {
                    status = SUCCESS;
                    snprintf(name, 19, "Body %d", jbody);
                }

                ibrch = MODL->body[jbody].ibrch;

                snprintf(line, MAX_LINE_LEN, "used by: %-20s (%-10s @ [[%s:%d]])\n", name,
                         ocsmGetText(MODL->brch[ibrch].type),
                         MODL->brch[ibrch].filename, MODL->brch[ibrch].linenum);

                if (strlen(*info)+strlen(line) >= mchar) {
                    mchar += 1000;
                    RALLOC(*info, char, mchar);
                }
                strcat(*info, line);
            }
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPerturb - create a perturbed MODL                              *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPerturb(void   *modl,               /* (in)  pointer to MODL */
            int    npmtrs,              /* (in)  number of perturbed Parameters (or 0 to remove)*/
  /*@null@*/int    ipmtrs[],            /* (in)  array of Parameter indices (1:npmtr) */
  /*@null@*/int    irows[],             /* (in)  array of row       indices (1:nrow) */
  /*@null@*/int    icols[],             /* (in)  array of column    indices (1:ncol) */
  /*@null@*/double values[])            /* (in)  array of perturbed values */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ii, ibody, builtTo, nbody_ptrb;
    modl_T    *MODL = (modl_T*)modl;
    modl_T    *PTRB = NULL;
    ego       newBody;

    void      *modl_ptrb=NULL;

    ROUTINE(ocsmPerturb);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if npmtrs is non-positive, remove the perturbation */
    if (npmtrs <= 0) {
        status = removePerturbation(MODL);
        CHECK_STATUS(removePerturbation);
        goto cleanup;
    }

    /* if there is no tessellation for any Body on the stack, return error */
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        if (MODL->body[ibody].onstack == 0) continue;

        if (MODL->body[ibody].etess == NULL && MODL->body[ibody].botype != OCSM_NODE_BODY) {
            status = OCSM_NEED_TESSELLATION;
            goto cleanup;
        }
    }

    /* make a copy and set its driving parameters to "base + dtime * dot" */
    status = ocsmCopy(MODL, &modl_ptrb);
    CHECK_STATUS(ocsmCopy);

    PTRB = modl_ptrb;

    SPLINT_CHECK_FOR_NULL(PTRB);

    MODL->perturb  = PTRB;
    PTRB->basemodl = MODL;

    /* update the Parameters */
    if (npmtrs > 0) {
        SPLINT_CHECK_FOR_NULL(ipmtrs);
        SPLINT_CHECK_FOR_NULL(irows );
        SPLINT_CHECK_FOR_NULL(icols );
        SPLINT_CHECK_FOR_NULL(values);

        for (ii = 0; ii < npmtrs; ii++) {
            status = ocsmSetValuD(PTRB, ipmtrs[ii], irows[ii], icols[ii], values[ii]);
            CHECK_STATUS(ocsmSetValuD);
        }
    }

    /* recheck (this is needed to make sure that the indentation is updated) */
    status = ocsmCheck(PTRB);
    CHECK_STATUS(ocsmCheck);

    /* rebuild the perturbed copy */
    nbody_ptrb = 0;
    SPRINT0(1, ">>> building perturbation");
    status = ocsmBuild(PTRB, 0, &builtTo, &nbody_ptrb, NULL);
    CHECK_STATUS(ocsmBuild);

    /* check that base and ptrb have same number of Bodys */
    if (MODL->nbody > PTRB->nbody) {
        SPRINT0(1, "WARNING:: Base and perturbed models have different nbody");
        SPRINT1(1, "          MODL->nbody = %d", MODL->nbody);
        SPRINT1(1, "          PTRB->nbody = %d", PTRB->nbody);
        (MODL->nwarn)++;
    }

    /* check that base and ptrb Bodys match topologically */
    for (ibody = 1; ibody <= PTRB->nbody; ibody++) {
        if (MODL->body[ibody].onstack != 1) continue;

//$$$        for now, assume that WireBodys map without checking
        if (MODL->body[ibody].botype == OCSM_WIRE_BODY &&
            PTRB->body[ibody].botype == OCSM_WIRE_BODY   ) {
            status  = SUCCESS;
            newBody = NULL;

        /* do actual check for SolidBodys */
        } else {
            status = EG_mapBody(MODL->body[ibody].ebody, PTRB->body[ibody].ebody,
                                "_faceID", &newBody);
        }

        /* if topologies match, we can proceed */
        if (status == SUCCESS) {
            if (newBody != NULL) {

//$$$                // &&&&& do we need to clean up udp cache here?

                EG_deleteObject(PTRB->body[ibody].ebody);
                PTRB->body[ibody].ebody = newBody;

                status = finishBody(PTRB, ibody);
                CHECK_STATUS(finishBody);
            }

        /* otherwise we have an error */
        } else {
            SPRINT2(0, "WARNING:: EG_mapBody(ibody=%d) -> status=%d\n", ibody, status);
            (MODL->nwarn)++;
            status = OCSM_DID_NOT_CREATE_BODY;
            goto cleanup;
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmUpdateTess - update a tessellation from a file                 *
 *                                                                      *
 ************************************************************************
 */

int
ocsmUpdateTess(void   *modl,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (1:nbody) */
               char   filename[])       /* (in)  name of .tess file */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nnode, inode, nedge, iedge, nface, iface, npnt, ipnt, ntri, itri;
    int       ptype, pindx, state, npts;
    int       *tris=NULL, tric0, tric1, tric2;
    double    x, y, z, *xyz=NULL, *t=NULL, *uv=NULL;
    ego       newTess;
    FILE      *fp=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmUpdateTess);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid Body index was given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_BODY_NOT_FOUND;
        goto cleanup;
    }

    /* check that filename can be opened */
    fp = fopen(filename, "r");
    if (fp == NULL) {
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* make sure that the number of Nodes, Edges, and Faces in file
       match the Body */
    fscanf(fp, "%d %d %d", &nnode, &nedge, &nface);

    if        (nnode != MODL->body[ibody].nnode) {
        SPRINT0(0, "ERROR:: nnode mismatch");
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    } else if (nedge != MODL->body[ibody].nedge) {
        SPRINT0(0, "ERROR:: nedge mismatch");
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    } else if (nface != MODL->body[ibody].nface) {
        SPRINT0(0, "ERROR:: nface mismatch");
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* make sure there is a tessellation object */
    if (MODL->body[ibody].etess == NULL) {
        status = OCSM_NEED_TESSELLATION;
        goto cleanup;
    }

    /* open the tessellation object for editing */
    status = EG_initTessBody(MODL->body[ibody].ebody, &newTess);
    CHECK_STATUS(EG_initTessBody);


    /* make sure that the Node locations match */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        fscanf(fp, "%lf %lf %lf", &x, &y, &z);

        if (fabs(MODL->body[ibody].node[inode].x-x) > EPS06 ||
            fabs(MODL->body[ibody].node[inode].y-y) > EPS06 ||
            fabs(MODL->body[ibody].node[inode].z-z) > EPS06   ) {
            SPRINT1(0, "ERROR:: Node %d mismatch", inode);
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        }
    }

    /* read and update the tessellation associated with each Edge */
    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        fscanf(fp, "%d", &npnt);

        MALLOC(xyz, double, 3*npnt);
        MALLOC(t,   double,   npnt);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            fscanf(fp, "%lf %lf %lf %lf",
                   &xyz[3*ipnt], &xyz[3*ipnt+1], &xyz[3*ipnt+2], &t[ipnt]);
        }

        status = EG_setTessEdge(newTess, iedge, npnt, xyz, t);
        CHECK_STATUS(EG_setTessEdge);

        FREE(xyz);
        FREE(t  );
    }

    /* read and update the tessellation associated with each Face */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        fscanf(fp, "%d %d", &npnt, &ntri);

        MALLOC(xyz,  double, 3*npnt);
        MALLOC(uv,   double, 2*npnt);
        MALLOC(tris, int,    3*ntri);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            fscanf(fp, "%lf %lf %lf %lf %lf %d %d",
                   &xyz[3*ipnt], &xyz[3*ipnt+1], &xyz[3*ipnt+2],
                   &uv[ 2*ipnt], &uv[ 2*ipnt+1], &ptype, &pindx);
        }

        for (itri = 0; itri < ntri; itri++) {
            fscanf(fp, "%d %d %d %d %d %d",
                   &tris[3*itri], &tris[3*itri+1], &tris[3*itri+2],
                   &tric0, &tric1, &tric2);
        }

        status = EG_setTessFace(newTess, iface, npnt, xyz, uv, ntri, tris);
        CHECK_STATUS(EG_setTessFace);

        FREE(xyz );
        FREE(uv  );
        FREE(tris);
    }

    /* checking the status closes the tessellation */
    status = EG_statusTessBody(newTess, &MODL->body[ibody].ebody, &state, &npts);
    CHECK_STATUS(EG_statusTessBody);

    /* get rid of old tessellation and attach new tessellation */
    status = EG_deleteObject(MODL->body[ibody].etess);
    CHECK_STATUS(EG_deleteObject);

    MODL->body[ibody].etess = newTess;

cleanup:
    FREE(xyz );
    FREE(t   );
    FREE(uv  );
    FREE(tris);

    if (fp != NULL) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmNewBrch - create a new Branch                                  *
 *                                                                      *
 ************************************************************************
 */

int
ocsmNewBrch(void   *modl,               /* (in)  pointer to MODL */
            int    iafter,              /* (in)  Branch index (0-nbrch) after which to add */
            int    type,                /* (in)  Branch type (see below) */
            char   filename[],          /* (in)  filename where Branch is defined */
            int    linenum,             /* (in)  linenumber where Branch is defined (bias-1) */
  /*@null@*/char   arg1[],              /* (in)  Argument 1 (or NULL) */
  /*@null@*/char   arg2[],              /* (in)  Argument 2 (or NULL) */
  /*@null@*/char   arg3[],              /* (in)  Argument 3 (or NULL) */
  /*@null@*/char   arg4[],              /* (in)  Argument 4 (or NULL) */
  /*@null@*/char   arg5[],              /* (in)  Argument 5 (or NULL) */
  /*@null@*/char   arg6[],              /* (in)  Argument 6 (or NULL) */
  /*@null@*/char   arg7[],              /* (in)  Argument 7 (or NULL) */
  /*@null@*/char   arg8[],              /* (in)  Argument 8 (or NULL) */
  /*@null@*/char   arg9[])              /* (in)  Argument 9 (or NULL) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       bclass, narg, ibrch, jbrch, impstr, i;
    char      temparg[MAX_LINE_LEN], *esp_root;
    char      udcfilename[MAX_EXPR_LEN], pathname[MAX_EXPR_LEN];
    void      *dum;

    ROUTINE(ocsmNewBrch);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* make sure valid ibrch was given */
    if (iafter < 0 || iafter > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* check that valid type is given (and determine bclass) */
    if        (type == OCSM_APPLYCSYS) {     // $csysName ibody=0
        bclass = OCSM_TRANSFORM;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_ARC) {           // xend yend zend dist $plane=xy
        bclass = OCSM_SKETCH;
        narg   = 5;
        impstr = 0x010;
    } else if (type == OCSM_ASSERT) {        // arg1 arg2 toler=0 verify=0
        bclass = OCSM_UTILITY;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_BEZIER) {        // x y z
        bclass = OCSM_SKETCH;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_BLEND) {         // begList=0 endList=0 reorder=0 oneFace=0 periodic=0
        bclass = OCSM_GROWN;
        narg   = 5;
        impstr = 0x000;
    } else if (type == OCSM_BOX) {           // xbase ybase zbase dx dy dz
        bclass = OCSM_PRIMITIVE;
        narg   = 6;
        impstr = 0x000;
    } else if (type == OCSM_CATBEG) {        // sigCode
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_CATEND) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_CHAMFER) {       // radius edgeList=0
        bclass = OCSM_APPLIED;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_CIRARC) {        // xon yon zon xend yend zend
        bclass = OCSM_SKETCH;
        narg   = 6;
        impstr = 0x000;
    } else if (type == OCSM_COMBINE) {       // toler=0
        bclass = OCSM_BOOLEAN;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_CONE) {          // xvrtx yvrtx zvrtx xbase ybase zbase radius
        bclass = OCSM_PRIMITIVE;
        narg   = 7;
        impstr = 0x000;
    } else if (type == OCSM_CONNECT) {       // faceList1 faceList2 edgelist1=0 edgelist2=0 toler=0
        bclass = OCSM_BOOLEAN;
        narg   = 5;
        impstr = 0x000;
    } else if (type == OCSM_CYLINDER) {      // xbeg ybeg zbeg xend yend zend radius
        bclass = OCSM_PRIMITIVE;
        narg   = 7;
        impstr = 0x000;
    } else if (type == OCSM_DIMENSION) {     // $pmtrName nrow ncol
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_DUMP) {          // $filename remove=0 toMark=0
        bclass = OCSM_UTILITY;
        narg   = 4;
        impstr = 0x100;
    } else if (type == OCSM_ELSE) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_ELSEIF) {        // val1 $op1 val2 $op2 val3 $op3 val4
        bclass = OCSM_UTILITY;
        narg   = 7;
        impstr = 0x0aa;
    } else if (type == OCSM_END) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_ENDIF) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_EVALUATE) {      // $type arg1 ...
        bclass = OCSM_UTILITY;
        if        (arg1 == NULL) {
        } else if (strcmp(arg1, "$node"   ) == 0 || strcmp(arg1, "$NODE"   ) == 0) {
            narg = 3;
        } else if (strcmp(arg1, "$edge"   ) == 0 || strcmp(arg1, "$EDGE"   ) == 0) {
            narg = 4;
        } else if (strcmp(arg1, "$edgerng") == 0 || strcmp(arg1, "$EDGERNG") == 0) {
            narg = 3;
        } else if (strcmp(arg1, "$edgeinv") == 0 || strcmp(arg1, "$EDGEINV") == 0) {
            narg = 6;
        } else if (strcmp(arg1, "$face"   ) == 0 || strcmp(arg1, "$FACE"   ) == 0) {
            narg = 5;
        } else if (strcmp(arg1, "$facerng") == 0 || strcmp(arg1, "$FACERNG") == 0) {
            narg = 3;
        } else if (strcmp(arg1, "$faceinv") == 0 || strcmp(arg1, "$FACEINV") == 0) {
            narg = 6;
        } else {
            narg = 1;
        }
        impstr = 0x100;
    } else if (type == OCSM_EXTRACT) {       // index
        bclass = OCSM_BOOLEAN;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_EXTRUDE) {       // dx dy dz
        bclass = OCSM_GROWN;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_FILLET) {        // radius edgeList=0 listStyle=0
        bclass = OCSM_APPLIED;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_GETATTR) {       // $pmtrName attrID global=0
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_GROUP) {         // nbody=0
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_HOLLOW) {        // thick=0 entList=0 listStyle=0
        bclass = OCSM_APPLIED;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_IFTHEN) {        // val1 $op1 val2 $op2 val3 $op3 val4
        bclass = OCSM_UTILITY;
        narg   = 7;
        impstr = 0x0aa;
    } else if (type == OCSM_IMPORT) {        // $filename bodynumber=1
        bclass = OCSM_PRIMITIVE;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_INTERFACE) {     // $argName $argType default=0
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x180;
    } else if (type == OCSM_INTERSECT) {     // $order=none index=1 maxtol=0
        bclass = OCSM_BOOLEAN;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_JOIN) {          // toler=0 toMark=0
        bclass = OCSM_BOOLEAN;
        narg   = 2;
        impstr = 0x000;
    } else if (type == OCSM_LINSEG) {        // x y z
        bclass = OCSM_SKETCH;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_LOFT) {          // smooth
        bclass = OCSM_GROWN;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_MACBEG) {        // imacro
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_MACEND) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_MARK) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_MESSAGE) {       // $text $schar=
        bclass = OCSM_UTILITY;
        narg   = 2;
        impstr = 0x180;
    } else if (type == OCSM_MIRROR) {        // nx ny nz dist=0
        bclass = OCSM_TRANSFORM;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_PATBEG) {        // $pmtrName ncopy
        bclass = OCSM_UTILITY;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_PATBREAK) {      // expr
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_PATEND) {
        bclass = OCSM_UTILITY;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_POINT) {         // xloc yloc zloc
        bclass = OCSM_PRIMITIVE;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_PROJECT) {       // x y z dx dy dz useEdges=0
        bclass = OCSM_UTILITY;
        narg   = 7;
        impstr = 0x000;
    } else if (type == OCSM_RECALL) {        // imacro
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_REORDER) {       // ishift iflip=0
        bclass = OCSM_TRANSFORM;
        narg   = 2;
        impstr = 0x000;
    } else if (type == OCSM_RESTORE) {       // $name index=0
        bclass = OCSM_PRIMITIVE;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_REVOLVE) {       // xorig yorig zorig dxaxis dyaxis dzaxis angDeg
        bclass = OCSM_GROWN;
        narg   = 7;
        impstr = 0x000;
    } else if (type == OCSM_ROTATEX) {       // angDeg yaxis zaxis
        bclass = OCSM_TRANSFORM;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_ROTATEY) {       // angDeg zaxis xaxis
        bclass = OCSM_TRANSFORM;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_ROTATEZ) {       // angDeg xaxis yaxis
        bclass = OCSM_TRANSFORM;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_RULE) {          // reorder=0 periodic=0
        bclass = OCSM_GROWN;
        narg   = 2;
        impstr = 0x000;
    } else if (type == OCSM_SCALE) {         // fact xcent=0 ycent=0 zcent=0
        bclass = OCSM_TRANSFORM;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_SELECT) {        // $type arg1 ...
        bclass = OCSM_UTILITY;
        narg   = 1;
        if (arg2 != NULL && arg2[0] != '\0') narg = 2;
        if (arg3 != NULL && arg3[0] != '\0') narg = 3;
        if (arg4 != NULL && arg4[0] != '\0') narg = 4;
        if (arg5 != NULL && arg5[0] != '\0') narg = 5;
        if (arg6 != NULL && arg6[0] != '\0') narg = 6;
        if (arg7 != NULL && arg7[0] != '\0') narg = 7;
        if (arg8 != NULL && arg8[0] != '\0') narg = 8;
        impstr = 0x100;
    } else if (type == OCSM_SET) {           // $pmtrName exprs
        bclass = OCSM_UTILITY;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_SKBEG) {         // x y z relative=0
        bclass = OCSM_SKETCH;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_SKCON) {         // $type index1 index2=1 $value=0
        bclass = OCSM_SKETCH;
        narg   = 4;
        impstr = 0x120;
    } else if (type == OCSM_SKEND) {         // wireonly=0
        bclass = OCSM_SKETCH;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_SKVAR) {         // $type valList
        bclass = OCSM_SKETCH;
        narg   = 2;
        impstr = 0x100;
    } else if (type == OCSM_SOLBEG) {        // $varList
        bclass = OCSM_SOLVER;
        narg   = 1;
        impstr = 0x100;
    } else if (type == OCSM_SOLCON) {        // $expr
        bclass = OCSM_SOLVER;
        narg   = 1;
        impstr = 0x100;
    } else if (type == OCSM_SOLEND) {
        bclass = OCSM_SOLVER;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_SPECIAL) {
        bclass = OCSM_UTILITY;
        narg   = 9;
        impstr = 0x000;
    } else if (type == OCSM_SPHERE) {        // xcent ycent zcent radius
        bclass = OCSM_PRIMITIVE;
        narg   = 4;
        impstr = 0x000;
    } else if (type == OCSM_SPLINE) {        // x y z
        bclass = OCSM_SKETCH;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_SSLOPE) {        // dx dy dz
        bclass = OCSM_SKETCH;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_STORE) {         // $name index=0 keep=0
        bclass = OCSM_UTILITY;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_SUBTRACT) {      // $order=none index=1 maxtol=0
        bclass = OCSM_BOOLEAN;
        narg   = 3;
        impstr = 0x100;
    } else if (type == OCSM_SWEEP) {
        bclass = OCSM_GROWN;
        narg   = 0;
        impstr = 0x000;
    } else if (type == OCSM_THROW) {         // sigCode
        bclass = OCSM_UTILITY;
        narg   = 1;
        impstr = 0x000;
    } else if (type == OCSM_TORUS) {         // xcent ycent zcent dxaxis dyaxis dzaxis majorRad minorRad
        bclass = OCSM_PRIMITIVE;
        narg   = 8;
        impstr = 0x000;
    } else if (type == OCSM_TRANSLATE) {     // dx dy dz
        bclass = OCSM_TRANSFORM;
        narg   = 3;
        impstr = 0x000;
    } else if (type == OCSM_UDPARG) {        // $primtype $argName1 argvalue1 $argName2 argvalue2 $argName3 argvalue3 $argName4 argvalue4
        bclass = OCSM_UTILITY;
        narg   = 1;
        if (arg2 != NULL && arg2[0] != '\0' &&
            arg3 != NULL && arg3[0] != '\0'   ) narg = 3;
        if (arg4 != NULL && arg4[0] != '\0' &&
            arg5 != NULL && arg5[0] != '\0'   ) narg = 5;
        if (arg6 != NULL && arg6[0] != '\0' &&
            arg7 != NULL && arg7[0] != '\0'   ) narg = 7;
        if (arg8 != NULL && arg8[0] != '\0' &&
            arg9 != NULL && arg9[0] != '\0'   ) narg = 9;
        impstr = 0x1aa;
    } else if (type == OCSM_UDPRIM) {        // $primtype $argName1 argvalue1 $argName2 argvalue2 $argName3 argvalue3 $argName4 argvalue4
        bclass = OCSM_PRIMITIVE;
        narg  = 1;
        if (arg2 != NULL && arg2[0] != '\0' &&
            arg3 != NULL && arg3[0] != '\0'   ) narg = 3;
        if (arg4 != NULL && arg4[0] != '\0' &&
            arg5 != NULL && arg5[0] != '\0'   ) narg = 5;
        if (arg6 != NULL && arg6[0] != '\0' &&
            arg7 != NULL && arg7[0] != '\0'   ) narg = 7;
        if (arg8 != NULL && arg8[0] != '\0' &&
            arg9 != NULL && arg9[0] != '\0'   ) narg = 9;
        impstr = 0x1aa;
    } else if (type == OCSM_UNION) {         // toMark=0 trimList=0 maxtol=0
        bclass = OCSM_BOOLEAN;
        narg   = 3;
        impstr = 0x000;
    } else {
        status = OCSM_ILLEGAL_TYPE;
        goto cleanup;
    }

    /* mark MODL as not being checked */
    MODL->checked = 0;

    /* increment the number of Branches */
    (MODL->nbrch)++;
    ibrch = iafter + 1;

    MODL->ibrch = iafter + 1;

    /* extend the Branch list (if needed) */
    if (MODL->nbrch > MODL->mbrch) {
        MODL->mbrch += 25;
        RALLOC(MODL->brch, brch_T, MODL->mbrch+1);
    }

    /* copy the Branches up to make room for the new Branch */
#ifndef __clang_analyzer__
    if (ibrch < MODL->nbrch) {
        for (jbrch = MODL->nbrch; jbrch > ibrch; jbrch--) {
            MODL->brch[jbrch].name     = MODL->brch[jbrch-1].name;
            MODL->brch[jbrch].type     = MODL->brch[jbrch-1].type;
            MODL->brch[jbrch].bclass   = MODL->brch[jbrch-1].bclass;
            MODL->brch[jbrch].level    = MODL->brch[jbrch-1].level;
            MODL->brch[jbrch].indent   = MODL->brch[jbrch-1].indent;
            MODL->brch[jbrch].filename = MODL->brch[jbrch-1].filename;
            MODL->brch[jbrch].linenum  = MODL->brch[jbrch-1].linenum;
            MODL->brch[jbrch].actv     = MODL->brch[jbrch-1].actv;
            MODL->brch[jbrch].dirty    = 1;
            MODL->brch[jbrch].nattr    = MODL->brch[jbrch-1].nattr;
            MODL->brch[jbrch].attr     = MODL->brch[jbrch-1].attr;
            MODL->brch[jbrch].ileft    = MODL->brch[jbrch-1].ileft;
            MODL->brch[jbrch].irite    = MODL->brch[jbrch-1].irite;
            MODL->brch[jbrch].ichld    = MODL->brch[jbrch-1].ichld;
            MODL->brch[jbrch].nmprp    = MODL->brch[jbrch-1].nmprp;
            MODL->brch[jbrch].mprp     = MODL->brch[jbrch-1].mprp;
            MODL->brch[jbrch].narg     = MODL->brch[jbrch-1].narg;
            MODL->brch[jbrch].arg1     = MODL->brch[jbrch-1].arg1;
            MODL->brch[jbrch].arg2     = MODL->brch[jbrch-1].arg2;
            MODL->brch[jbrch].arg3     = MODL->brch[jbrch-1].arg3;
            MODL->brch[jbrch].arg4     = MODL->brch[jbrch-1].arg4;
            MODL->brch[jbrch].arg5     = MODL->brch[jbrch-1].arg5;
            MODL->brch[jbrch].arg6     = MODL->brch[jbrch-1].arg6;
            MODL->brch[jbrch].arg7     = MODL->brch[jbrch-1].arg7;
            MODL->brch[jbrch].arg8     = MODL->brch[jbrch-1].arg8;
            MODL->brch[jbrch].arg9     = MODL->brch[jbrch-1].arg9;
        }
    }
#endif

    /* initialize the new Branch */
    MODL->brch[ibrch].name     = NULL;
    MODL->brch[ibrch].type     = type;
    MODL->brch[ibrch].bclass   = bclass;
    MODL->brch[ibrch].level    = MODL->level;
    MODL->brch[ibrch].indent   = 0;
    MODL->brch[ibrch].filename = NULL;
    MODL->brch[ibrch].linenum  = linenum;
    MODL->brch[ibrch].actv     =  OCSM_ACTIVE;
    MODL->brch[ibrch].dirty    = 1;
    MODL->brch[ibrch].nattr    = 0;
    MODL->brch[ibrch].attr     = NULL;
    MODL->brch[ibrch].ileft    = -2;
    MODL->brch[ibrch].irite    = -2;
    MODL->brch[ibrch].ichld    = -2;
    MODL->brch[ibrch].nmprp    =  0;
    MODL->brch[ibrch].mprp     =  NULL;
    MODL->brch[ibrch].narg     =  narg;
    MODL->brch[ibrch].arg1     =  NULL;
    MODL->brch[ibrch].arg2     =  NULL;
    MODL->brch[ibrch].arg3     =  NULL;
    MODL->brch[ibrch].arg4     =  NULL;
    MODL->brch[ibrch].arg5     =  NULL;
    MODL->brch[ibrch].arg6     =  NULL;
    MODL->brch[ibrch].arg7     =  NULL;
    MODL->brch[ibrch].arg8     =  NULL;
    MODL->brch[ibrch].arg9     =  NULL;

    /* default name for the Branch */
    MALLOC(  MODL->brch[ibrch].name, char, 12);
    snprintf(MODL->brch[ibrch].name,       12, "Brch_%06d", MODL->nextseq);
    (MODL->nextseq)++;

    /* save the filename */
    MALLOC(MODL->brch[ibrch].filename, char, MAX_FILENAME_LEN);
    strcpy(MODL->brch[ibrch].filename, filename);

    /* save the Arguments */
    if (narg >= 1) {
        if (arg1 != NULL && STRLEN(arg1) > 0) {
            if ((impstr & 0x100) != 0 && arg1[0] != '$' && arg1[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg1 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg1);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg1);
            }

            MALLOC(MODL->brch[ibrch].arg1, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg1,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 2) {
        if (arg2 != NULL && STRLEN(arg2) > 0) {
            if ((impstr & 0x080) != 0 && arg2[0] != '$' && arg2[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg2 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg2);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg2);
            }

            MALLOC(MODL->brch[ibrch].arg2, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg2,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 3) {
        if (arg3 != NULL && STRLEN(arg3) > 0) {
            if ((impstr & 0x040) != 0 && arg3[0] != '$' && arg3[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg3 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg3);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg3);
            }

            MALLOC(MODL->brch[ibrch].arg3, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg3,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 4) {
        if (arg4 != NULL && STRLEN(arg4) > 0) {
            if ((impstr & 0x020) != 0 && arg4[0] != '$' && arg4[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg4 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg4);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg4);
            }

            MALLOC(MODL->brch[ibrch].arg4, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg4,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 5) {
        if (arg5 != NULL && STRLEN(arg5) > 0) {
            if ((impstr & 0x010) != 0 && arg5[0] != '$' && arg5[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg5 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg5);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg5);
            }

            MALLOC(MODL->brch[ibrch].arg5, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg5,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 6) {
        if (arg6 != NULL && STRLEN(arg6) > 0) {
            if ((impstr & 0x008) != 0 && arg6[0] != '$' && arg6[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg6 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg6);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg6);
            }

            MALLOC(MODL->brch[ibrch].arg6, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg6,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 7) {
        if (arg7 != NULL && STRLEN(arg7) > 0) {
            if ((impstr & 0x004) != 0 && arg7[0] != '$' && arg7[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg7 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg7);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg7);
            }

            MALLOC(MODL->brch[ibrch].arg7, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg7,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 8) {
        if (arg8 != NULL && STRLEN(arg8) > 0) {
            if ((impstr & 0x002) != 0 && arg8[0] != '$' && arg8[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg8 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg8);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg8);
            }

            MALLOC(MODL->brch[ibrch].arg8, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg8,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    if (narg >= 9) {
        if (arg9 != NULL && STRLEN(arg9) > 0) {
            if ((impstr & 0x001) != 0 && arg9[0] != '$' && arg9[0] != '!') {
                SPRINT0(1, "WARNING:: converting arg9 to an implicit string");
                snprintf(temparg, MAX_LINE_LEN, "$%s", arg9);
            } else {
                snprintf(temparg, MAX_LINE_LEN,  "%s", arg9);
            }

            MALLOC(MODL->brch[ibrch].arg9, char, (int)(STRLEN(temparg)+1));
            strcpy(MODL->brch[ibrch].arg9,                    temparg    );
        } else {
            status = OCSM_ILLEGAL_NARG;
        }
    }

    /* recursively add Branches in an UDC, but not in a .cpc */
    if (strstr(filename, ".cpc") != NULL) {
        /* do not divert since .cpc file contains all Branches */
    } else if (MODL->brch[ibrch].arg1 == NULL) {
        /* nothing.  needed to avoid clang warning */
    } else if (type == OCSM_UDPRIM                                 &&
               (strncmp(MODL->brch[ibrch].arg1, "$/",   2) == 0 ||
                strncmp(MODL->brch[ibrch].arg1, "$$/",  3) == 0 ||
                strncmp(MODL->brch[ibrch].arg1, "$$$/", 4) == 0   )  ) {

        if (MODL->level < 10) {
            (MODL->level)++;
            MODL->scope[MODL->level] = MODL->scope[MODL->level-1] + 1;

            /* if primtype starts with "/", look in current directory */
            if        (strncmp(MODL->brch[ibrch].arg1, "$/",  2) == 0) {
                snprintf(udcfilename, MAX_EXPR_LEN, "%s.udc", &(MODL->brch[ibrch].arg1[2]));

            /* if primtype starts with "$/", look in same directory as .csm file */
            } else if (strncmp(MODL->brch[ibrch].arg1, "$$/", 3) == 0) {
                STRNCPY(pathname, filename, MAX_EXPR_LEN);
                i = STRLEN(pathname) - 1;
                while (pathname[i] != SLASH) {
                    pathname[i] = '\0';
                    i--;
                    if (i < 0) break;
                }
                snprintf(udcfilename, MAX_EXPR_LEN, "%s%s.udc", pathname, &(MODL->brch[ibrch].arg1[3]));

            /* if primtype starts with "$$/", look in ESP_ROOT directory */
            } else {
                esp_root = getenv("ESP_ROOT");
                if (esp_root != NULL) {
                    snprintf(udcfilename, MAX_EXPR_LEN, "%s%cudc%c%s.udc", esp_root, SLASH, SLASH, &(MODL->brch[ibrch].arg1[4]));
                } else {
                    status = OCSM_FILE_NOT_FOUND;
                    signalError2(MODL, status, filename, linenum,
                                 "esp_root is not set");
                    goto cleanup;
                }
            }

            SPRINT1(1, "\n>>> Diverting to file \"%s\"\n", udcfilename);

            /* recursively call ocsmLoad */
            dum = (void*)MODL;
            status = ocsmLoad(udcfilename, &dum);
            if (status < SUCCESS) {
                signalError2(MODL, status, filename, linenum,
                             "error when trying to process \"%s\"", udcfilename);
                goto cleanup;
            }
        } else {
            status = OCSM_NESTED_TOO_DEEPLY;
            signalError2(MODL, status, filename, linenum,
                         "maximum file depth reached");
            goto cleanup;
        }
    }

    /* increment number of groups if Branch will create a Body */
    if (bclass == OCSM_PRIMITIVE ||
        bclass == OCSM_GROWN     ||
        bclass == OCSM_APPLIED   ||
        bclass == OCSM_BOOLEAN   ||
        bclass == OCSM_TRANSFORM ||
        type   == OCSM_SKEND       ) {
        (MODL->ngroup)++;
    }

cleanup:
    if (status < SUCCESS && MODL != NULL) {
        MODL->nbrch--;
    }

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetBrch - get info about a Branch                              *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetBrch(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            int    *type,               /* (out) Branch type */
            int    *bclass,             /* (out) Branch class */
            int    *actv,               /* (out) Branch Activity */
            int    *ichld,              /* (out) ibrch of child (or 0 if root) */
            int    *ileft,              /* (out) ibrch of left parent (or 0) */
            int    *irite,              /* (out) ibrch of rite parent (or 0) */
            int    *narg,               /* (out) number of Arguments */
            int    *nattr)              /* (out) number of Attributes */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetBrch);

    /* --------------------------------------------------------------- */

    /* default return values */
    *type   = 0;
    *bclass = 0;
    *actv   = 0;
    *ichld  = 0;
    *ileft  = 0;
    *irite  = 0;
    *narg   = 0;
    *nattr  = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* return pertinent information */
    *type   = MODL->brch[ibrch].type;
    *bclass = MODL->brch[ibrch].bclass;
    *actv   = MODL->brch[ibrch].actv;
    *ichld  = MODL->brch[ibrch].ichld;
    *ileft  = MODL->brch[ibrch].ileft;
    *irite  = MODL->brch[ibrch].irite;
    *narg   = MODL->brch[ibrch].narg;
    *nattr  = MODL->brch[ibrch].nattr;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetBrch - set activity for a Branch                            *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetBrch(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            int    actv)                /* (in)  Branch activity */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetBrch);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that a valid activity was given */
    if (actv != OCSM_ACTIVE    &&
        actv != OCSM_SUPPRESSED  ) {
        status = OCSM_ILLEGAL_ACTIVITY;
        goto cleanup;
    }

    /* check that branch type can be suppressed */
    if (MODL->brch[ibrch].bclass != OCSM_PRIMITIVE &&
        MODL->brch[ibrch].bclass != OCSM_GROWN     &&
        MODL->brch[ibrch].bclass != OCSM_APPLIED   &&
        MODL->brch[ibrch].bclass != OCSM_TRANSFORM   ) {
        status = OCSM_CANNOT_BE_SUPPRESSED;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* save the activity */
    MODL->brch[ibrch].actv = actv;

    /* mark the Branch as dirty */
    MODL->brch[ibrch].dirty = 1;

    /* mark MODL as not being checked */
    MODL->checked = 0;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmDelBrch - delete a Branch (or whole Sketch if SKBEG)           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmDelBrch(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch)               /* (in)  Branch index (1:nbrch) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       itype, jbrch, iattr;

    ROUTINE(ocsmDelBrch);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check for valid Branch index */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* mark MODL as not being checked */
    MODL->checked = 0;

    /* remember the type if ibrch */
    itype = MODL->brch[ibrch].type;

    if (itype == OCSM_SKBEG) {
        SPRINT0(1, "WARNING:: deleting entire Sketch");
        (MODL->nwarn)++;
    }

    /* delete the Branch(es) */
    while (ibrch <= MODL->nbrch) {

        /* free up the storage associated with ibrch */
        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            FREE(MODL->brch[ibrch].attr[iattr].name);
            FREE(MODL->brch[ibrch].attr[iattr].defn);
        }

        FREE(MODL->brch[ibrch].name    );
        FREE(MODL->brch[ibrch].filename);
        FREE(MODL->brch[ibrch].attr    );
        FREE(MODL->brch[ibrch].mprp    );
        FREE(MODL->brch[ibrch].arg1    );
        FREE(MODL->brch[ibrch].arg2    );
        FREE(MODL->brch[ibrch].arg3    );
        FREE(MODL->brch[ibrch].arg4    );
        FREE(MODL->brch[ibrch].arg5    );
        FREE(MODL->brch[ibrch].arg6    );
        FREE(MODL->brch[ibrch].arg7    );
        FREE(MODL->brch[ibrch].arg8    );
        FREE(MODL->brch[ibrch].arg9    );

        /* move all Branches up to write over deleted Branch */
        for (jbrch = ibrch; jbrch < MODL->nbrch; jbrch++) {
            MODL->brch[jbrch].name     = MODL->brch[jbrch+1].name;
            MODL->brch[jbrch].type     = MODL->brch[jbrch+1].type;
            MODL->brch[jbrch].bclass   = MODL->brch[jbrch+1].bclass;
            MODL->brch[jbrch].level    = MODL->brch[jbrch-1].level;
            MODL->brch[jbrch].indent   = MODL->brch[jbrch+1].indent;
            MODL->brch[jbrch].filename = MODL->brch[jbrch+1].filename;
            MODL->brch[jbrch].linenum  = MODL->brch[jbrch+1].linenum;
            MODL->brch[jbrch].actv     = MODL->brch[jbrch+1].actv;
            MODL->brch[jbrch].dirty    = 1;
            MODL->brch[jbrch].nattr    = MODL->brch[jbrch+1].nattr;
            MODL->brch[jbrch].attr     = MODL->brch[jbrch+1].attr;
            MODL->brch[jbrch].ileft    = MODL->brch[jbrch+1].ileft;
            MODL->brch[jbrch].irite    = MODL->brch[jbrch+1].irite;
            MODL->brch[jbrch].ichld    = MODL->brch[jbrch+1].ichld;
            MODL->brch[jbrch].nmprp    = MODL->brch[jbrch+1].nmprp;
            MODL->brch[jbrch].mprp     = MODL->brch[jbrch+1].mprp;
            MODL->brch[jbrch].narg     = MODL->brch[jbrch+1].narg;
            MODL->brch[jbrch].arg1     = MODL->brch[jbrch+1].arg1;
            MODL->brch[jbrch].arg2     = MODL->brch[jbrch+1].arg2;
            MODL->brch[jbrch].arg3     = MODL->brch[jbrch+1].arg3;
            MODL->brch[jbrch].arg4     = MODL->brch[jbrch+1].arg4;
            MODL->brch[jbrch].arg5     = MODL->brch[jbrch+1].arg5;
            MODL->brch[jbrch].arg6     = MODL->brch[jbrch+1].arg6;
            MODL->brch[jbrch].arg7     = MODL->brch[jbrch+1].arg7;
            MODL->brch[jbrch].arg8     = MODL->brch[jbrch+1].arg8;
            MODL->brch[jbrch].arg9     = MODL->brch[jbrch+1].arg9;
        }

        /* null pointers associated with the last Branch (since they were
           copied down) */
        MODL->brch[MODL->nbrch].name     = NULL;
        MODL->brch[MODL->nbrch].filename = NULL;
        MODL->brch[MODL->nbrch].attr     = NULL;
        MODL->brch[MODL->nbrch].mprp     = NULL;
        MODL->brch[MODL->nbrch].arg1     = NULL;
        MODL->brch[MODL->nbrch].arg2     = NULL;
        MODL->brch[MODL->nbrch].arg3     = NULL;
        MODL->brch[MODL->nbrch].arg4     = NULL;
        MODL->brch[MODL->nbrch].arg5     = NULL;
        MODL->brch[MODL->nbrch].arg6     = NULL;
        MODL->brch[MODL->nbrch].arg7     = NULL;
        MODL->brch[MODL->nbrch].arg8     = NULL;
        MODL->brch[MODL->nbrch].arg9     = NULL;

        /* decrement the number of Branches */
        (MODL->nbrch)--;

        /* if the remembered type is not SKBEG, we are done */
        if (itype != OCSM_SKBEG) break;

        /* otherwise keep deleting Branches that were in the Sketch */
        if (MODL->brch[ibrch].type   != OCSM_SKEND &&
            MODL->brch[ibrch].bclass != OCSM_SKETCH  ) break;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintBrchs - print Branches to file                            *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintBrchs(void   *modl,            /* (in)  pointer to MODL */
               char   filename[])       /* (in)  file to which output is appended (or "" for stdout) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ibrch, i, nindent, iattr, imprp;
    FILE      *fp=NULL;

    ROUTINE(ocsmPrintBrchs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    if (strlen(filename) == 0) {
        fp = stdout;
    } else {
        fp = fopen(filename, "a");
        if (fp == NULL) {
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }
    }

    /* run ocsmCheck to set up necessary linkages amongst Branches */
    status = ocsmCheck(MODL);
    CHECK_STATUS(ocsmCheck);

    /* print header */
    fprintf(fp, "    ibrch                    type             ileft irite ichld args...\n");

    /* print global Attributes */
    for (iattr = 0; iattr < MODL->nattr; iattr++) {
        if (MODL->attr[iattr].type != ATTRCSYS) {
            fprintf(fp, "                                              attr: %-20s %-20s\n",
                    MODL->attr[iattr].name,
                    MODL->attr[iattr].defn);
        } else {
            fprintf(fp, "                                              csys: %-20s %-20s\n",
                    MODL->attr[iattr].name,
                    MODL->attr[iattr].defn);
            }
    }

    /* print each Branch */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {

        fprintf(fp, "    %5d", ibrch);

        if (MODL->brch[ibrch].ileft == -2 &&
            MODL->brch[ibrch].irite == -2 &&
            MODL->brch[ibrch].ichld == -2   ) {
            fprintf(fp, " [-] ");
        } else if (MODL->brch[ibrch].dirty > 0) {
            if (MODL->brch[ibrch].actv == OCSM_ACTIVE    ) fprintf(fp, " [a] ");
            if (MODL->brch[ibrch].actv == OCSM_SUPPRESSED) fprintf(fp, " [s] ");
            if (MODL->brch[ibrch].actv == OCSM_INACTIVE  ) fprintf(fp, " [i] ");
            if (MODL->brch[ibrch].actv == OCSM_DEFERRED  ) fprintf(fp, " [d] ");
        } else {
            if (MODL->brch[ibrch].actv == OCSM_ACTIVE    ) fprintf(fp, " (a) ");
            if (MODL->brch[ibrch].actv == OCSM_SUPPRESSED) fprintf(fp, " (s) ");
            if (MODL->brch[ibrch].actv == OCSM_INACTIVE  ) fprintf(fp, " (i) ");
            if (MODL->brch[ibrch].actv == OCSM_DEFERRED  ) fprintf(fp, " (d) ");
        }

        fprintf(fp, " %-14s", MODL->brch[ibrch].name);

        nindent = MODL->brch[ibrch].indent;
        for (i = 0; i < nindent; i++) {
            fprintf(fp, ".");
        }

        fprintf(fp, "%-9s", ocsmGetText(MODL->brch[ibrch].type));

        for (i = nindent; i < 8; i++) {
            fprintf(fp, " ");
        }

        fprintf(fp, "%5d %5d %5d", MODL->brch[ibrch].ileft,
                                   MODL->brch[ibrch].irite,
                                   MODL->brch[ibrch].ichld);

        if (MODL->brch[ibrch].narg >= 1) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg1    );
        }
        if (MODL->brch[ibrch].narg >= 2) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg2    );
        }
        if (MODL->brch[ibrch].narg >= 3) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg3    );
        }
        if (MODL->brch[ibrch].narg >= 4) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg4    );
        }
        if (MODL->brch[ibrch].narg >= 5) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg5    );
        }
        if (MODL->brch[ibrch].narg >= 6) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg6    );
        }
        if (MODL->brch[ibrch].narg >= 7) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg7    );
        }
        if (MODL->brch[ibrch].narg >= 8) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg8    );
        }
        if (MODL->brch[ibrch].narg >= 9) {
            fprintf(fp, " {%s}",   MODL->brch[ibrch].arg9    );
        }

        fprintf(fp, "\n");

        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            if (MODL->brch[ibrch].attr[iattr].type != ATTRCSYS) {
                fprintf(fp, "                                              attr: %-20s %-20s\n",
                        MODL->brch[ibrch].attr[iattr].name,
                        MODL->brch[ibrch].attr[iattr].defn);
            } else {
                fprintf(fp, "                                              csys: %-20s %-20s\n",
                        MODL->brch[ibrch].attr[iattr].name,
                        MODL->brch[ibrch].attr[iattr].defn);
            }
        }

        for (imprp = 0; imprp < MODL->brch[ibrch].nmprp; imprp++) {
            fprintf(fp, "                                              mprp: %-20s %10.5f\n",
                    MODL->brch[ibrch].mprp[imprp].name,
                    MODL->brch[ibrch].mprp[imprp].val);
        }
    }

cleanup:
    if (fp != NULL && strlen(filename) > 0) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetArg - get an Argument for a Branch                          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetArg(void   *modl,                /* (in)  pointer to MODL */
           int    ibrch,                /* (in)  Branch index (1:nbrch) */
           int    iarg,                 /* (in)  Argument index (1:narg) */
           char   defn[],               /* (out) Argument definition (at least MAX_STRVAL_LEN long) */
           double *value,               /* (out) Argument value */
           double *dot)                 /* (out) Argument velocity */
{
    int       status = SUCCESS;         /* (out) return status */

    char      str[MAX_STRVAL_LEN];
    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetArg);

    /* --------------------------------------------------------------- */

    /* default return values */
    defn[0] = '\0';
    *value  = 0;
    str[0]  = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that valid iarg is given */
    if (iarg < 1 || iarg > MODL->brch[ibrch].narg) {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

    /* return the definition and current value */
    if (iarg == 1) {
        STRNCPY(defn, MODL->brch[ibrch].arg1, MAX_STRVAL_LEN);
    }
    if (iarg == 2) {
        STRNCPY(defn, MODL->brch[ibrch].arg2, MAX_STRVAL_LEN);
    }
    if (iarg == 3) {
        STRNCPY(defn, MODL->brch[ibrch].arg3, MAX_STRVAL_LEN);
    }
    if (iarg == 4) {
        STRNCPY(defn, MODL->brch[ibrch].arg4, MAX_STRVAL_LEN);
    }
    if (iarg == 5) {
        STRNCPY(defn, MODL->brch[ibrch].arg5, MAX_STRVAL_LEN);
    }
    if (iarg == 6) {
        STRNCPY(defn, MODL->brch[ibrch].arg6, MAX_STRVAL_LEN);
    }
    if (iarg == 7) {
        STRNCPY(defn, MODL->brch[ibrch].arg7, MAX_STRVAL_LEN);
    }
    if (iarg == 8) {
        STRNCPY(defn, MODL->brch[ibrch].arg8, MAX_STRVAL_LEN);
    }
    if (iarg == 9) {
        STRNCPY(defn, MODL->brch[ibrch].arg9, MAX_STRVAL_LEN);
    }

    status = str2val(defn, MODL, value, dot, str);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetArg - set an Argument for a Branch                          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetArg(void   *modl,                /* (in)  pointer to MODL */
           int    ibrch,                /* (in)  Branch index (1:nbrch) */
           int    iarg,                 /* (in)  Argument index (1:narg) */
           char   defn[])               /* (in)  Argument definition */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetArg);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that valid iarg is given */
    if (iarg < 1 || iarg > MODL->brch[ibrch].narg) {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* save the definition */
    if        (iarg == 1) {
        if (strcmp(defn, MODL->brch[ibrch].arg1) != 0) {
            FREE(  MODL->brch[ibrch].arg1);
            MALLOC(MODL->brch[ibrch].arg1, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg1,                    defn    );
        }
    } else if (iarg == 2) {
        if (strcmp(defn, MODL->brch[ibrch].arg2) != 0) {
            FREE(  MODL->brch[ibrch].arg2);
            MALLOC(MODL->brch[ibrch].arg2, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg2,                    defn    );
        }
    } else if (iarg == 3) {
        if (strcmp(defn, MODL->brch[ibrch].arg3) != 0) {
            FREE(  MODL->brch[ibrch].arg3);
            MALLOC(MODL->brch[ibrch].arg3, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg3,                    defn    );
        }
    } else if (iarg == 4) {
        if (strcmp(defn, MODL->brch[ibrch].arg4) != 0) {
            FREE(  MODL->brch[ibrch].arg4);
            MALLOC(MODL->brch[ibrch].arg4, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg4,                    defn    );
        }
    } else if (iarg == 5) {
        if (strcmp(defn, MODL->brch[ibrch].arg5) != 0) {
            FREE(  MODL->brch[ibrch].arg5);
            MALLOC(MODL->brch[ibrch].arg5, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg5,                    defn    );
        }
    } else if (iarg == 6) {
        if (strcmp(defn, MODL->brch[ibrch].arg6) != 0) {
            FREE(  MODL->brch[ibrch].arg6);
            MALLOC(MODL->brch[ibrch].arg6, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg6,                    defn    );
        }
    } else if (iarg == 7) {
        if (strcmp(defn, MODL->brch[ibrch].arg7) != 0) {
            FREE(  MODL->brch[ibrch].arg7);
            MALLOC(MODL->brch[ibrch].arg7, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg7,                    defn    );
        }
    } else if (iarg == 8) {
        if (strcmp(defn, MODL->brch[ibrch].arg8) != 0) {
            FREE(  MODL->brch[ibrch].arg8);
            MALLOC(MODL->brch[ibrch].arg8, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg8,                    defn    );
        }
    } else if (iarg == 9) {
        if (strcmp(defn, MODL->brch[ibrch].arg9) != 0) {
            FREE(  MODL->brch[ibrch].arg9);
            MALLOC(MODL->brch[ibrch].arg9, char, (int)(STRLEN(defn)+1));
            strcpy(MODL->brch[ibrch].arg9,                    defn    );
        }
    }

    /* mark the Branch as dirty */
    MODL->brch[ibrch].dirty = 1;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmRetAttr - return an Attribute for a Branch by index            *
 *                                                                      *
 ************************************************************************
 */

int
ocsmRetAttr(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            int    iattr,               /* (in)  Attribute index (1:nattr) */
            char   aname[],             /* (out) Attribute name  (at least MAX_STRVAL_LEN long) */
            char   avalue[])            /* (out) Attribute value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmRetAttr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that value iattr is given */
    if (iattr < 1 || iattr > MODL->brch[ibrch].nattr) {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

    /* return the name and value */
    if (MODL->brch[ibrch].attr[iattr-1].type != ATTRCSYS) {
        STRNCPY(aname,  MODL->brch[ibrch].attr[iattr-1].name, MAX_STRVAL_LEN);
        STRNCPY(avalue, MODL->brch[ibrch].attr[iattr-1].defn, MAX_STRVAL_LEN);
    } else {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetAttr - get an Attribute for a Branch by name                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetAttr(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            char   aname[],             /* (in)  Attribute name */
            char   avalue[])            /* (out) Attribute value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iattr, jattr;

    ROUTINE(ocsmGetAttr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 0 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* global Attribute */
    if (ibrch == 0) {

        /* determine the Attribute index (if any) */
        iattr = -1;
        for (jattr = 0; jattr < MODL->nattr; jattr++) {
            if (strcmp(MODL->attr[jattr].name, aname) == 0) {
                iattr = jattr;
                break;
            }
        }

        /* error if Attribute name is not found */
        if (iattr < 0) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        }

        /* return the value */
        STRNCPY(avalue, MODL->attr[iattr].defn, MAX_STRVAL_LEN);

    /* Attribute for Branch */
    } else {

        /* determine the Attribute index (if any) */
        iattr = -1;
        for (jattr = 0; jattr < MODL->brch[ibrch].nattr; jattr++) {
            if (strcmp(MODL->brch[ibrch].attr[jattr].name, aname) == 0 &&
                       MODL->brch[ibrch].attr[jattr].type != ATTRCSYS    ) {
                iattr = jattr;
                break;
            }
        }

        /* error if Attribute name is not found */
        if (iattr < 0) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        }

        /* return the value */
        STRNCPY(avalue, MODL->brch[ibrch].attr[iattr].defn, MAX_STRVAL_LEN);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetAttr - set an Attribute for a Branch                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetAttr(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            char   aname[],             /* (in)  Attribute name */
            char   avalue[])            /* (in)  Attribute value (or blank to delete) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iattr, jattr, jbrch;

    ROUTINE(ocsmSetAttr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 0 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* if aname is a NULL, return now */
    if (STRLEN(aname) == 0) {
        SPRINT0(1, "WARNING:: NULL name given for Attribute");
        (MODL->nwarn)++;
        goto cleanup;

    /* if avalue is a NULL string, return now */
    } else if (strcmp(avalue, "$") == 0) {
        SPRINT1(1, "WARNING:: NULL value given for Attribute \"%s\"", aname);
        (MODL->nwarn)++;
        goto cleanup;
    }

    /* global Attribute */
    if (ibrch == 0) {

        /* determine the Attribute index (if any) */
        iattr = -1;
        for (jattr = 0; jattr < MODL->nattr; jattr++) {
            if (strcmp(MODL->attr[jattr].name, aname) == 0) {
                iattr = jattr;
                break;
            }
        }

        /* adding or modifying an Attribute */
        if (STRLEN(avalue) > 0) {
            /* if Attribute is not found already, create a new one */
            if (iattr < 0) {
                MODL->nattr++;

                RALLOC(MODL->attr, attr_T, MODL->nattr);

                iattr = MODL->nattr - 1;
                MODL->attr[iattr].name = NULL;
                MODL->attr[iattr].defn = NULL;
                MODL->attr[iattr].type = ATTRREAL;
            }

            /* set the Attribute's name and value */
            FREE(  MODL->attr[iattr].name);
            MALLOC(MODL->attr[iattr].name,  char, (int)(STRLEN(aname)+1));
            strcpy(MODL->attr[iattr].name,                     aname    );

            FREE(  MODL->attr[iattr].defn);
            MALLOC(MODL->attr[iattr].defn, char, (int)(STRLEN(avalue)+1));
            strcpy(MODL->attr[iattr].defn,                    avalue    );

        /* deleting an Attribute */
        } else {
            if (iattr < 0) {
                status = OCSM_NAME_NOT_FOUND;
                goto cleanup;
            }

            MODL->nattr--;

            for (jattr = iattr; jattr < MODL->nattr; jattr++) {
                MODL->attr[jattr].name = MODL->attr[jattr+1].name;
                MODL->attr[jattr].defn = MODL->attr[jattr+1].defn;
                MODL->attr[jattr].type = MODL->attr[jattr+1].type;
            }

            FREE(MODL->attr[MODL->nattr].name);
            FREE(MODL->attr[MODL->nattr].defn);
        }

        /* mark all the Branches as dirty */
        for (jbrch = 1; jbrch <= MODL->nbrch; jbrch++) {
            MODL->brch[jbrch].dirty = 1;
        }

    /* Attribute for Branch */
    } else {

        /* determine the Attribute index (if any) */
        iattr = -1;
        for (jattr = 0; jattr < MODL->brch[ibrch].nattr; jattr++) {
            if (strcmp(MODL->brch[ibrch].attr[jattr].name, aname) == 0) {
                iattr = jattr;
                break;
            }
        }

        /* adding or modifying an Attribute */
        if (STRLEN(avalue) > 0) {
            /* if Attribute is not found already, create a new one */
            if (iattr < 0) {
                MODL->brch[ibrch].nattr++;

                RALLOC(MODL->brch[ibrch].attr, attr_T, MODL->brch[ibrch].nattr);

                iattr = MODL->brch[ibrch].nattr - 1;
                MODL->brch[ibrch].attr[iattr].name = NULL;
                MODL->brch[ibrch].attr[iattr].defn = NULL;
                MODL->brch[ibrch].attr[iattr].type = ATTRREAL;
            } else if (MODL->brch[ibrch].attr[iattr].type == ATTRCSYS) {
                status = OCSM_NAME_NOT_UNIQUE;
                goto cleanup;
            }

            /* set the Attribute's name and value */
            FREE(  MODL->brch[ibrch].attr[iattr].name);
            MALLOC(MODL->brch[ibrch].attr[iattr].name,  char, (int)(STRLEN(aname)+1));
            strcpy(MODL->brch[ibrch].attr[iattr].name,                     aname    );

            FREE(  MODL->brch[ibrch].attr[iattr].defn);
            MALLOC(MODL->brch[ibrch].attr[iattr].defn, char, (int)(STRLEN(avalue)+1));
            strcpy(MODL->brch[ibrch].attr[iattr].defn,                    avalue    );

        /* deleting an Attribute */
        } else {
            if (iattr < 0) {
                status = OCSM_NAME_NOT_FOUND;
                goto cleanup;
            } else if (MODL->brch[ibrch].attr[iattr].type == ATTRCSYS) {
                status = OCSM_NAME_NOT_FOUND;
                goto cleanup;
            }

            MODL->brch[ibrch].nattr--;

            for (jattr = iattr; jattr < MODL->brch[ibrch].nattr; jattr++) {
                MODL->brch[ibrch].attr[jattr].name = MODL->brch[ibrch].attr[jattr+1].name;
                MODL->brch[ibrch].attr[jattr].defn = MODL->brch[ibrch].attr[jattr+1].defn;
                MODL->brch[ibrch].attr[jattr].type = MODL->brch[ibrch].attr[jattr+1].type;
            }

            FREE(MODL->brch[ibrch].attr[MODL->brch[ibrch].nattr].name);
            FREE(MODL->brch[ibrch].attr[MODL->brch[ibrch].nattr].defn);
        }

        /* mark the Branch as dirty */
        MODL->brch[ibrch].dirty = 1;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmRetCsys - return a Csystem for a Branch by index               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmRetCsys(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            int    icsys,               /* (in)  Csystem index (1:nattr) */
            char   cname[],             /* (out) Csystem name  (at least MAX_STRVAL_LEN long) */
            char   cvalue[])            /* (out) Csystem value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmRetCsys);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* check that value icsys is given */
    if (icsys < 1 || icsys > MODL->brch[ibrch].nattr) {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

    /* return the name and value */
    if (MODL->brch[ibrch].attr[icsys-1].type == ATTRCSYS) {
        STRNCPY(cname,  MODL->brch[ibrch].attr[icsys-1].name, MAX_STRVAL_LEN);
        STRNCPY(cvalue, MODL->brch[ibrch].attr[icsys-1].defn, MAX_STRVAL_LEN);
    } else {
        status = OCSM_ILLEGAL_ARG_INDEX;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetCsys - get a Csystem for a Branch by name                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetCsys(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            char   cname[],             /* (in)  Csystem name */
            char   cvalue[])            /* (out) Csystem value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       icsys, jcsys;

    ROUTINE(ocsmGetCsys);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* determine the Csystem index (if any) */
    icsys = -1;
    for (jcsys = 0; jcsys < MODL->brch[ibrch].nattr; jcsys++) {
        if (strcmp(MODL->brch[ibrch].attr[jcsys].name, cname) == 0 &&
                   MODL->brch[ibrch].attr[jcsys].type == ATTRCSYS    ) {
            icsys = jcsys;
            break;
        }
    }

    /* error if Csystem name is not found */
    if (icsys < 0) {
        status = OCSM_NAME_NOT_FOUND;
        goto cleanup;
    }

    /* return the value */
    STRNCPY(cvalue, MODL->brch[ibrch].attr[icsys].defn, MAX_STRVAL_LEN);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetCsys - set a Csystem for a Branch                           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetCsys(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            char   cname[],             /* (in)  Csystem name */
            char   cvalue[])            /* (in)  Csystem value (or blank to delete) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       icsys, jcsys;

    ROUTINE(ocsmSetCsys);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* determine the Csystem index (if any) */
    icsys = -1;
    for (jcsys = 0; jcsys < MODL->brch[ibrch].nattr; jcsys++) {
        if (strcmp(MODL->brch[ibrch].attr[jcsys].name, cname) == 0) {
            icsys = jcsys;
            break;
        }
    }

    /* adding or modifying a Csystem */
    if (STRLEN(cvalue) > 0) {
        /* if Csystem is not found already, create a new one */
        if (icsys < 0) {
            MODL->brch[ibrch].nattr++;

            RALLOC(MODL->brch[ibrch].attr, attr_T, MODL->brch[ibrch].nattr);

            icsys = MODL->brch[ibrch].nattr - 1;
            MODL->brch[ibrch].attr[icsys].name = NULL;
            MODL->brch[ibrch].attr[icsys].defn = NULL;
            MODL->brch[ibrch].attr[icsys].type = ATTRCSYS;
        } else if (MODL->brch[ibrch].attr[icsys].type != ATTRCSYS) {
            status = OCSM_NAME_NOT_UNIQUE;
            goto cleanup;
        }

        /* set the Csystem's name and value */
        FREE(  MODL->brch[ibrch].attr[icsys].name);
        MALLOC(MODL->brch[ibrch].attr[icsys].name,  char, (int)(STRLEN(cname )+1));
        strcpy(MODL->brch[ibrch].attr[icsys].name,                     cname     );

        FREE(  MODL->brch[ibrch].attr[icsys].defn);
        MALLOC(MODL->brch[ibrch].attr[icsys].defn, char, (int)(STRLEN(cvalue)+1));
        strcpy(MODL->brch[ibrch].attr[icsys].defn,                    cvalue    );

    /* deleting a Csystem */
    } else {
        if (icsys < 0) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        } else if (MODL->brch[ibrch].attr[icsys].type != ATTRCSYS) {
            status = OCSM_NAME_NOT_FOUND;
            goto cleanup;
        }

        MODL->brch[ibrch].nattr--;

        for (jcsys = icsys; jcsys < MODL->brch[ibrch].nattr; jcsys++) {
            MODL->brch[ibrch].attr[jcsys].name = MODL->brch[ibrch].attr[jcsys+1].name;
            MODL->brch[ibrch].attr[jcsys].defn = MODL->brch[ibrch].attr[jcsys+1].defn;
            MODL->brch[ibrch].attr[jcsys].type = MODL->brch[ibrch].attr[jcsys+1].type;
        }

        FREE(MODL->brch[ibrch].attr[MODL->brch[ibrch].nattr].name);
        FREE(MODL->brch[ibrch].attr[MODL->brch[ibrch].nattr].defn);
    }

    /* mark the Branch as dirty */
    MODL->brch[ibrch].dirty = 1;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintAttrs - print global Attributes to file                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintAttrs(void   *modl,            /* (in)  pointer to MODL */
               char   filename[])       /* (in)  file to which output is appended (or "" for stdout) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iattr;
    FILE      *fp=NULL;

    ROUTINE(ocsmPrintAttrs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    if (strlen(filename) == 0) {
        fp = stdout;
    } else {
        fp = fopen(filename, "a");
        if (fp == NULL) {
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }
    }

    for (iattr = 0; iattr < MODL->nattr; iattr++) {
        fprintf(fp, "    %-24s -> %24s\n",
                MODL->attr[iattr].name,
                MODL->attr[iattr].defn);
    }

cleanup:
    if (fp != NULL && strlen(filename) > 0) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetName - get the name of a Branch                             *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetName(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            char   name[])              /* (out) Branch name (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetName);

    /* --------------------------------------------------------------- */

    /* default return values */
    name[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* return the name */
    STRNCPY(name, MODL->brch[ibrch].name, MAX_STRVAL_LEN);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetName - set the name for a Branch                            *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetName(void   *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            char   name[])              /* (in)  Branch name */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jbrch;

    ROUTINE(ocsmSetName);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (name == NULL) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* check that valid ibrch is given */
    if (ibrch < 1 || ibrch > MODL->nbrch) {
        status = OCSM_ILLEGAL_BRCH_INDEX;
        goto cleanup;
    }

    /* make sure that the new name is unique */
    for (jbrch = 1; jbrch <= MODL->nbrch; jbrch++) {
        if (strcmp(name, MODL->brch[jbrch].name) == 0) {
            status = OCSM_NAME_NOT_UNIQUE;
            goto cleanup;
        } else if (strncmp(name, "Brch_", 5) == 0) {
            status = OCSM_NAME_NOT_UNIQUE;
            goto cleanup;
        }
    }

    /* name cannot contain ">" */
    if (strstr(name, ">") != NULL) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* set the name */
    FREE(MODL->brch[ibrch].name);

    MALLOC(MODL->brch[ibrch].name, char, (int)(STRLEN(name)+1));
    strcpy(MODL->brch[ibrch].name,                    name    );

    /* mark the Branch as dirty */
    MODL->brch[ibrch].dirty = 1;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetSketch - get string data associated with a Sketch           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetSketch(void   *modl,             /* (in)  pointer to MODL */
              int    ibrch,             /* (in)  Branch index (1:nbrch) within Sketch */
              int    maxlen,            /* (in)  length of begs, vars, cons, and segs */
              char   begs[],            /* (out) string with SKBEG variables */
              char   vars[],            /* (out) string with Sketch variables */
              char   cons[],            /* (out) string with Sketch constraints */
              char   segs[])            /* (out) string with Sketch segments */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jbrch, iskbeg, iskend, index1, index2, ibeg, iend;
    double    value, xval, yval, zval, rel, dot;
    char      *token=NULL, str[MAX_STRVAL_LEN];

    ROUTINE(ocsmGetSketch);

    /* --------------------------------------------------------------- */

    MODL->sigCode    = 0;
    MODL->sigMesg[0] = '\0';

    /* default returns */
    begs[0] = '\0';
    vars[0] = '\0';
    cons[0] = '\0';
    segs[0] = '\0';

    if        (MODL->brch[ibrch].type == OCSM_SKBEG) {
        iskbeg = ibrch;
        iskend = ibrch + 1;
    } else if (MODL->brch[ibrch].type == OCSM_SKEND) {
        iskbeg = ibrch - 1;
        iskend = ibrch;
    } else {
        iskbeg = ibrch;
        iskend = ibrch;
    }

    /* find SKBEG at or before ibrch */
    while (iskbeg > 0 && MODL->brch[iskbeg].type != OCSM_SKBEG) {
        if (MODL->brch[iskbeg].type == OCSM_SKEND) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (SKEND found first)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
        iskbeg--;
        if (iskbeg <= 0) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (at beginning)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
    }

    /* find SKEND at or after ibrch */
    while (iskend <= MODL->nbrch && MODL->brch[iskend].type != OCSM_SKEND) {
        if (MODL->brch[iskend].type == OCSM_SKBEG) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (SKBEG found first)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
        iskend++;
        if (iskend <= 0) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (at end)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
    }

    MALLOC(token, char, maxlen+1);

    /* build the begs string */
    status = str2val(MODL->brch[iskbeg].arg1, MODL, &xval, &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "xval cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    status = str2val(MODL->brch[iskbeg].arg2, MODL, &yval, &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "yval cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    status = str2val(MODL->brch[iskbeg].arg3, MODL, &zval, &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "zval cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    status = str2val(MODL->brch[iskbeg].arg3, MODL, &rel,  &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "rel cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    snprintf(begs, maxlen, "%s;%f;%s;%f;%s;%f;%s;%f;",
             MODL->brch[iskbeg].arg1, xval,
             MODL->brch[iskbeg].arg2, yval,
             MODL->brch[iskbeg].arg3, zval,
             MODL->brch[iskbeg].arg4, rel );

    /* if there are no statements within the Sketch, return an empty Sketch */
    if (iskend == iskbeg+1) {
        goto cleanup;
    }

    /* make sure that there there are only valid statements in the Sketch */
    for (jbrch = iskbeg+1; jbrch < iskend; jbrch++) {
        if (MODL->brch[jbrch].type != OCSM_SKVAR  &&
            MODL->brch[jbrch].type != OCSM_SKCON  &&
            MODL->brch[jbrch].type != OCSM_LINSEG &&
            MODL->brch[jbrch].type != OCSM_ARC    &&
            MODL->brch[jbrch].type != OCSM_SPLINE &&
            MODL->brch[jbrch].type != OCSM_SSLOPE &&
            MODL->brch[jbrch].type != OCSM_BEZIER   ) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "wrong type (%s) in Sketch", ocsmGetText(MODL->brch[jbrch].type));
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
        }
    }

    /* make sure that a SKVAR follows the SKBEG */
    if (MODL->brch[iskbeg+1].type != OCSM_SKVAR) {
        signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                    "SKVAR does not follow SKBEG");
        SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
    }

    /* create the Sketch variables from the SKVAR statement */
    if (STRLEN(MODL->brch[iskbeg+1].arg2) < maxlen-1) {
        STRNCPY(vars, MODL->brch[iskbeg+1].arg2, maxlen);
    } else {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "buffer overflow writing Sketch variables");
        SET_STATUS(OCSM_INTERNAL_ERROR, ocsmGetSketch);
    }

    /* create the Sketch constraints from the SKCON statements */
    jbrch = iskbeg + 2;
    while (jbrch < iskend && MODL->brch[jbrch].type == OCSM_SKCON) {
        status = str2val(MODL->brch[jbrch].arg2, MODL, &value, &dot, str);
        CHECK_STATUS(str2val);
        if (STRLEN(str) > 0) {
            signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                        "stretch constraint value cannot be a string (%s)", ibrch, str);
            SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
        }
        index1 = NINT(value);

        status = str2val(MODL->brch[jbrch].arg3, MODL, &value, &dot, str);
        CHECK_STATUS(str2val);
        if (STRLEN(str) > 0) {
            signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                        "stretch constraint value cannot be a string (%s)", ibrch, str);
            SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
        }
        index2 = NINT(value);

        snprintf(token, maxlen, "%s;%d;%d;%s;",
                 &(MODL->brch[jbrch].arg1[1]), index1, index2, &(MODL->brch[jbrch].arg4[1]));

        if (STRLEN(cons)+STRLEN(token) < maxlen-1) {
            strncat(cons, token, maxlen);
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "buffer overflow writing Sketch constraints");
            SET_STATUS(OCSM_INTERNAL_ERROR, ocsmGetSketch);
        }

        jbrch++;
    }

    /* create the Sketch segments from the LINSEG, ARC, SPLINE, and BEZIER statements */
    ibeg = 1;
    while (jbrch < iskend) {
        if (strncmp(MODL->brch[jbrch].arg1, "::x[", 4) != 0) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "statement does not use ::x[] for x-argument");
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
        }
        if (strncmp(MODL->brch[jbrch].arg2, "::y[", 4) != 0) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "statement does not use ::y[] for y-argument");
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
        }
        if (strncmp(MODL->brch[jbrch].arg3, "::z[", 4) != 0 &&
            strcmp( MODL->brch[jbrch].arg3, "0"      ) != 0   ) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "statement does not use ::z[] or 0 for z-argument");
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, ocsmGetSketch);
        }

        if (strcmp(MODL->brch[jbrch].arg1, "::x[1]") == 0) {
            iend = 1;
        } else {
            iend = ibeg + 1;
        }

        if        (MODL->brch[jbrch].type == OCSM_LINSEG) {
            snprintf(token, maxlen, "L;%d;%d;", ibeg, iend);
        } else if (MODL->brch[jbrch].type == OCSM_ARC) {
            snprintf(token, maxlen, "C;%d;%d;", ibeg, iend);
        } else if (MODL->brch[jbrch].type == OCSM_SPLINE) {
            snprintf(token, maxlen, "S;%d;%d;", ibeg, iend);
        } else if (MODL->brch[jbrch].type == OCSM_BEZIER) {
            snprintf(token, maxlen, "B;%d;%d;", ibeg, iend);
        }

        strncat(segs, token, maxlen);

        ibeg = iend;
        jbrch++;
    }

cleanup:
    FREE(token);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSolveSketch - solve for new Sketch variables                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSolveSketch(void   *modl,           /* (in)  pointer to MODL */
                char   vars_in[],       /* (in)  string with Sketch variables */
                char   cons[],          /* (in)  string with Sketch constraints */
                                        /* (out) string with Sketch constraint changes */
                char   vars_out[])      /* (out) string (1024 long) with new Sketch variables
                                                 or suggested modified constraints
                                                 (if starts with "*") */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;
    sket_T    *sket=NULL;

    int       i, im1, ip1, icount, lentok, index1, index2, ivar, nvar, jpmtr, jndex;
    int       ii, jj, ibeg, iend;
    double    val;
    char      token[MAX_EXPR_LEN], type[MAX_EXPR_LEN], value[MAX_EXPR_LEN];
    char      prefix[MAX_EXPR_LEN], suffix[MAX_EXPR_LEN];
    char      cons_mod[MAX_EXPR_LEN];

    ROUTINE(ocsmSolveSketch);

    /* --------------------------------------------------------------- */

    MALLOC(sket, sket_T, 1);

    /* default (empty) return */
    vars_out[0]      = '\0';
    MODL->sigMesg[0] = '\0';

    /* initialize the Sketch */
    sket->type   = 0;
    sket->size   = 0;
    sket->solved = 0;
    sket->signal = 0;
    sket->nseg   = 0;
    sket->nvar   = 0;
    sket->ncon   = 0;

    /* count the semicolons in vars_in to detemine number of variables */
    nvar = 0;
    for (i = 0; i < STRLEN(vars_in); i++) {
        if (vars_in[i] == ';') nvar++;
    }

    if (nvar%3 == 0) {
        nvar /= 3;
        sket->size = nvar;
    } else {
        signalError(MODL, OCSM_ILLEGAL_VALUE,
                    "vars_in contains %d semicolons (which is not evenly divisible by 3)", nvar);
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* remove internal Parameters that may be left over from a failure
          in a Sketch that was being solved */
    status = delPmtrByName(MODL, "::d");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::z");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::y");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    status = delPmtrByName(MODL, "::x");
    if (status != OCSM_NAME_NOT_FOUND) {
        CHECK_STATUS(delPmtrByName);
    }

    /* make the new Sketch variables */
    status = ocsmNewPmtr(MODL, "::x", OCSM_LOCALVAR, 1, sket->size);
    CHECK_STATUS(ocsmNewPmtr);
    sket->ix = MODL->npmtr;

    status = ocsmNewPmtr(MODL, "::y", OCSM_LOCALVAR, 1, sket->size);
    CHECK_STATUS(ocsmNewPmtr);
    sket->iy = MODL->npmtr;

    status = ocsmNewPmtr(MODL, "::z", OCSM_LOCALVAR, 1, sket->size);
    CHECK_STATUS(ocsmNewPmtr);
    sket->iz = MODL->npmtr;

    status = ocsmNewPmtr(MODL, "::d", OCSM_LOCALVAR, 1, sket->size);
    CHECK_STATUS(ocsmNewPmtr);
    sket->id = MODL->npmtr;

    /* pull the variables out of vars_in */
    icount = 0;
    lentok = 0;
    for (i = 0; i < STRLEN(vars_in); i++) {
        if (vars_in[i] != ';') {
            token[lentok++] = vars_in[i];
            token[lentok  ] = '\0';
        } else {
            val = strtod(token, NULL);
            if        (icount%3 == 0) {
                MODL->pmtr[sket->ix].value[icount/3] = val;
                MODL->pmtr[sket->ix].dot[  icount/3] = 0;
            } else if (icount%3 == 1) {
                MODL->pmtr[sket->iy].value[icount/3] = val;
                MODL->pmtr[sket->iy].dot[  icount/3] = 0;
            } else {
                MODL->pmtr[sket->id].value[icount/3] = val;
                MODL->pmtr[sket->id].dot[  icount/3] = 0;
            }

            icount++;
            lentok = 0;
        }
    }

    /* make a list of the Sketch variables */
    sket->nvar = 0;
    for (i = 1; i <= sket->size; i++) {
        sket->ipmtr[sket->nvar] = sket->ix;
        sket->index[sket->nvar] = i-1;
        sket->nvar++;

        sket->ipmtr[sket->nvar] = sket->iy;
        sket->index[sket->nvar] = i-1;
        sket->nvar++;

        if (fabs(MODL->pmtr[sket->id].value[i-1]) > EPS06) {
            sket->ipmtr[sket->nvar] = sket->id;
            sket->index[sket->nvar] = i-1;
            sket->nvar++;
        }
    }

    for (ivar = 0; ivar < sket->nvar; ivar++) {
        jpmtr = sket->ipmtr[ivar];
        jndex = sket->index[ivar];

        SPRINT3(1, "    -> creating  %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                MODL->pmtr[jpmtr].value[jndex]);
    }

    /* make the constraints */
    icount = 0;
    lentok = 0;
    index1 = 0;
    index2 = 0;
    for (i = 0; i < STRLEN(cons); i++) {
        if (cons[i] != ';') {
            token[lentok++] = cons[i];
            token[lentok  ] = '\0';
        } else {
            if        (icount%4 == 0) {
                strcpy(type, token);
            } else if (icount%4 == 1) {
                index1 = strtol(token, NULL, 10);
            } else if (icount%4 == 2) {
                index2 = strtol(token, NULL, 10);
            } else {
                strcpy(value, token);

                /* (recursivly) modify value if it contains "::L[", "::I[", "::R[", or "::S[" */
                while (strstr(value, "::L[") != NULL || strstr(value, "::I[") != NULL ||
                       strstr(value, "::R[") != NULL || strstr(value, "::S[") != NULL   ){

                    /* pull out the prefix */
                    prefix[0] = '\0';
                    ibeg      =   0 ;
                    for (ii = 0; ii < STRLEN(value); ii++) {
                        if (value[ii] == ':' && value[ii+1] == ':' && value[ii+3] == '[') {
                            if (value[ii+2] == 'L' || value[ii+2] == 'I' ||
                                value[ii+2] == 'R' || value[ii+2] == 'S'   ) {
                                if (ii > 0) {
                                    STRNCPY(prefix, value, ii);
                                    prefix[ii] = '\0';
                                }
                                ibeg = strtol(&(value[ii+4]), NULL, 10);
                                break;
                            }
                        }
                    }

                    /* check that argument was okay */
                    if (ibeg < 1 || ibeg > sket->size) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "::%c[%d] is not defined", value[ii+2], ibeg);
                        status = OCSM_ILLEGAL_VALUE;
                        goto cleanup;
                    } else if (ibeg < sket->size) {
                        iend = ibeg + 1;
                    } else {
                        iend = 1;
                    }

                    /* pull out the suffix */
                    suffix[0] = '\0';
                    for (jj = ii+3; jj < STRLEN(value); jj++) {
                        if (value[jj] == ']') {
                            strcpy(suffix, &(value[jj+1]));
                            break;
                        }
                    }

                    /* create the replacement text */
                    if        (value[ii+2] == 'L') {
                        snprintf(value, MAX_EXPR_LEN, "%shypot(::y[%d]-::y[%d],::x[%d]-::x[%d])%s",
                                 prefix, iend, ibeg, iend, ibeg, suffix);
                    } else if (value[ii+2] == 'I') {
                        snprintf(value, MAX_EXPR_LEN, "%satan2d(::y[%d]-::y[%d],::x[%d]-::x[%d])%s",
                                 prefix, iend, ibeg, iend, ibeg, suffix);
                    } else if (value[ii+2] == 'R') {
                        snprintf(value, MAX_EXPR_LEN, "%sradius(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])%s",
                                 prefix, ibeg, ibeg, iend, iend, iend, suffix);
                    } else if (value[ii+2] == 'S') {
                        snprintf(value, MAX_EXPR_LEN, "%ssweep(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])%s",
                                 prefix, ibeg, ibeg, iend, iend, iend, suffix);
                    }
                }

                if        (strcmp(type, "X") == 0 && index2 <= 0) {
                    sket->ctype[sket->ncon] = 'X';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::x[%d]-(%s)",
                             index1, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "X") == 0) {
                    sket->ctype[sket->ncon] = 'X';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "Xcent(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                             index1, index1, index2, index2, index2, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "Y") == 0 && index2 <= 0) {
                    sket->ctype[sket->ncon] = 'Y';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::y[%d]-(%s)",
                             index1, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "Y") == 0) {
                    sket->ctype[sket->ncon] = 'Y';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "Ycent(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                             index1, index1, index2, index2, index2, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "P") == 0) {
                    sket->ctype[sket->ncon] = 'P';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                    ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "(abs(turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d]))-90)/57.3",
                             im1, im1, index1, index1, index1, ip1, ip1, ip1);
                } else if (strcmp(type, "T") == 0) {
                    sket->ctype[sket->ncon] = 'T';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                    ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])/57.3",
                             im1, im1, index1, index1, index1, ip1, ip1, ip1);
                } else if (strcmp(type, "A") == 0) {
                    sket->ctype[sket->ncon] = 'A';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                    ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "(turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-smallang(%s))/57.3",
                             im1, im1, index1, index1, index1, ip1, ip1, ip1, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "Z") == 0) {
                    sket->ctype[sket->ncon] = 'Z';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    if        (index2 == -2) {
                        snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                                 "::x[%d]-::x[%d]",
                                 index1, index1+1);
                    } else if (index2 == -3) {
                        snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                                 "::y[%d]-::y[%d]",
                                 index1-1, index1);
                    }
                } else if (strcmp(type, "W") == 0) {
                    sket->ctype[sket->ncon] = 'W';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::x[%d]-::x[%d]-(%s)",
                             index2, index1, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "D") == 0) {
                    sket->ctype[sket->ncon] = 'D';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::y[%d]-::y[%d]-(%s)",
                             index2, index1, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "H") == 0) {
                    sket->ctype[sket->ncon] = 'H';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::y[%d]-::y[%d]",
                             index1, index2);
                } else if (strcmp(type, "V") == 0) {
                    sket->ctype[sket->ncon] = 'V';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::x[%d]-::x[%d]",
                             index1, index2);
                } else if (strcmp(type, "I") == 0) {
                    sket->ctype[sket->ncon] = 'I';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "smallang(atan2d(::y[%d]-::y[%d],::x[%d]-::x[%d])-(%s))/57.3",
                             index2, index1, index2, index1, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "L") == 0) {
                    sket->ctype[sket->ncon] = 'L';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "hypot(::y[%d]-::y[%d],::x[%d]-::x[%d])-(%s)",
                             index1, index2, index1, index2, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "R") == 0) {
                    sket->ctype[sket->ncon] = 'R';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "radius(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                             index1, index1, index2, index2, index2, /*@ignore@*/value/*@end@*/);
                } else if (strcmp(type, "S") == 0) {
                    sket->ctype[sket->ncon] = 'S';
                    sket->ipnt[ sket->ncon] = index1;
                    sket->ip1[  sket->ncon] = index2;

                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "(sweep(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s))/57.3",
                             index1, index1, index2, index2, index2, /*@ignore@*/value/*@end@*/);
                }
            }

            icount++;
            lentok = 0;
        }
    }

    /* check that number of constraints matches number of variables */
    if        (sket->nvar > sket->ncon) {
        status = fixSketch(sket, vars_in, cons_mod);
        CHECK_STATUS(fixSketch);

        if (STRLEN(cons_mod) > 0) {
            strcpy(vars_out, cons_mod);
        } else {
            signalError(MODL, OCSM_SINGULAR_MATRIX,
                        "under-constrained since nvar=%d but ncon=%d", sket->nvar, sket->ncon);
        }
        goto removeTemps;
    } else if (sket->nvar < sket->ncon) {
        status = fixSketch(sket, vars_in, cons_mod);
        CHECK_STATUS(fixSketch);

        if (STRLEN(cons_mod) > 0) {
            strcpy(vars_out, cons_mod);
        } else {
            signalError(MODL, OCSM_SINGULAR_MATRIX,
                        "over-constrained since nvar=%d but ncon=%d", sket->nvar, sket->ncon);
        }
        goto removeTemps;
    }

    /* try to solve the sketch */
    status = solveSketch(MODL, sket);

    /* if solver fails, simply return nvar=0 */
    if (status == OCSM_SINGULAR_MATRIX) {
        status = fixSketch(sket, vars_in, cons_mod);
        CHECK_STATUS(fixSketch);

        if (STRLEN(cons_mod) > 0) {
            strcpy(vars_out, cons_mod);
        } else {
            signalError(MODL, OCSM_SINGULAR_MATRIX,
                        "constraints are not independent");
        }
        goto removeTemps;
    } else if (status < SUCCESS) {
        goto removeTemps;
    }

    /* solver succeeded, so write the new variables */
    for (ivar = 0; ivar < nvar; ivar++) {
        snprintf(token, MAX_EXPR_LEN, "%.6lf;%.6lf;%.6lf;",
                 MODL->pmtr[sket->ix].value[ivar],
                 MODL->pmtr[sket->iy].value[ivar],
                 MODL->pmtr[sket->id].value[ivar]);
        strcat(vars_out, token);
    }

removeTemps:
    /* remove ::x[], ::y[], ::z[], and ::d[] if they were generated by a skvar statement */
    if (sket->nvar > 0) {
        status = delPmtrByName(MODL, "::d");
        if (status != OCSM_NAME_NOT_FOUND) {
            CHECK_STATUS(delPmtrByName);
        }

        status = delPmtrByName(MODL, "::z");
        if (status != OCSM_NAME_NOT_FOUND) {
            CHECK_STATUS(delPmtrByName);
        }

        status = delPmtrByName(MODL, "::y");
        if (status != OCSM_NAME_NOT_FOUND) {
            CHECK_STATUS(delPmtrByName);
        }

        status = delPmtrByName(MODL, "::x");
        if (status != OCSM_NAME_NOT_FOUND) {
            CHECK_STATUS(delPmtrByName);
        }
    }

cleanup:
    FREE(sket);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSaveSketch - overwrite Branches associated with a Sketch       *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSaveSketch(void   *modl,            /* (in)  pointer to MODL */
               int    ibrch,            /* (in)  Branch index (1:nbrch) within Sketch */
               char   vars[],           /* (in)  string with Sketch variables */
               char   cons[],           /* (in)  string with Sketch constraints */
               char   segs[])           /* (in)  string with Sketch segments */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iskbeg, iskend, jbrch, iafter, icon, ncon, iseg, nseg, i, irel;
    double    value, dot;
    char      *arg1=NULL, *arg2=NULL, *arg3=NULL, *arg4=NULL, *arg5=NULL, *arg6=NULL;
    char      str[MAX_STRVAL_LEN];

    ROUTINE(ocsmSaveSketch);

    /* --------------------------------------------------------------- */

    if (outLevel >= 2) {
        SPRINT0(2, "ocsmSaveSketch: at beginning");
        status = ocsmPrintBrchs(MODL, "");
        CHECK_STATUS(ocsmPrintBrchs);
    }

    MALLOC(arg1, char, MAX_EXPR_LEN);
    MALLOC(arg2, char, MAX_EXPR_LEN);
    MALLOC(arg3, char, MAX_EXPR_LEN);
    MALLOC(arg4, char, MAX_EXPR_LEN);
    MALLOC(arg5, char, MAX_EXPR_LEN);
    MALLOC(arg6, char, MAX_EXPR_LEN);

    if        (MODL->brch[ibrch].type == OCSM_SKBEG) {
        iskbeg = ibrch;
        iskend = ibrch + 1;
    } else if (MODL->brch[ibrch].type == OCSM_SKEND) {
        iskbeg = ibrch - 1;
        iskend = ibrch;
    } else {
        iskbeg = ibrch;
        iskend = ibrch;
    }

    /* find SKBEG at or before ibrch */
    while (iskbeg > 0 && MODL->brch[iskbeg].type != OCSM_SKBEG) {
        if (MODL->brch[iskbeg].type == OCSM_SKEND) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (SKEND found first)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
        iskbeg--;
        if (iskbeg <= 0) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (at beginning)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
    }

    /* find SKEND at or after ibrch */
    while (iskend <= MODL->nbrch && MODL->brch[iskend].type != OCSM_SKEND) {
        if (MODL->brch[iskend].type == OCSM_SKBEG) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (SKBEG found first)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
        iskend++;
        if (iskend <= 0) {
            signalError(MODL, OCSM_ILLEGAL_BRCH_INDEX,
                        "ibrch=%d is not within a Sketch (at end)", ibrch);
            SET_STATUS(OCSM_ILLEGAL_BRCH_INDEX, ocsmGetSketch);
        }
    }

    iafter = iskbeg;

    /* determine the number of constraints */
    ncon = 0;
    for (i = 0; i < STRLEN(cons); i++) {
        if (cons[i] == ';') ncon++;
    }
    ncon /= 4;

    /* determine the number of segments */
    nseg = 0;
    for (i = 0; i < STRLEN(segs); i++) {
        if (segs[i] == ';') nseg++;
    }
    nseg /= 3;

    /* delete the Branches between the SKBEG and the SKEND */
    for (jbrch = iskend-1; jbrch > iskbeg; jbrch--) {
        status = ocsmDelBrch(MODL, jbrch);
        CHECK_STATUS(ocsmDelBrch);
    }

    /* determine if Sketch is absolute or relative */
    value = 0;
    dot   = 0;
    status = str2val(MODL->brch[iskbeg].arg4, MODL, &value, &dot, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                    "sketch type cannot have string value (%s)", ibrch, str);
        SET_STATUS(OCSM_WRONG_PMTR_TYPE, ocsmGetSketch);
    }

    irel = NINT(value);

    /* add the SKVAR Branch */
    status = ocsmNewBrch(MODL, iafter++, OCSM_SKVAR, "", -1,
                         "$xy", vars, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    CHECK_STATUS(ocsmNewBrch);

    /* add the SKCON Branches */
    for (icon = 0; icon < ncon; icon++) {
        arg1[0] = '$';
        arg4[0] = '$';
        getToken(cons, 4*icon  , ';', MAX_EXPR_LEN, &(arg1[1]));
        getToken(cons, 4*icon+1, ';', MAX_EXPR_LEN,  arg2    );
        getToken(cons, 4*icon+2, ';', MAX_EXPR_LEN,  arg3    );
        getToken(cons, 4*icon+3, ';', MAX_EXPR_LEN, &(arg4[1]));

        status = ocsmNewBrch(MODL, iafter++, OCSM_SKCON, "", -1,
                             arg1, arg2, arg3, arg4, NULL, NULL, NULL, NULL, NULL);
        CHECK_STATUS(ocsmNewBrch);
    }

    /* add the LINSEG, ARC, SPLINE, and BEZIER Branches */
    for (iseg = 0; iseg < nseg; iseg++) {
        getToken(segs, 3*iseg,   ';', MAX_EXPR_LEN, arg1);
        getToken(segs, 3*iseg+2, ';', MAX_EXPR_LEN, arg6);

        if (irel == 0) {
            snprintf(arg2, MAX_EXPR_LEN, "::x[%s]", arg6);
            snprintf(arg3, MAX_EXPR_LEN, "::y[%s]", arg6);
            snprintf(arg4, MAX_EXPR_LEN, "::z[%s]", arg6);
            snprintf(arg5, MAX_EXPR_LEN, "::d[%s]", arg6);
        } else {
            snprintf(arg2, MAX_EXPR_LEN, "::x[%s]", arg6);
            snprintf(arg3, MAX_EXPR_LEN, "::y[%s]", arg6);
            snprintf(arg4, MAX_EXPR_LEN, "0"            );
            snprintf(arg5, MAX_EXPR_LEN, "::d[%s]", arg6);
        }

        if        (arg1[0] == 'L') {
            status = ocsmNewBrch(MODL, iafter++, OCSM_LINSEG, "", -1,
                                 arg2, arg3, arg4, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);
        } else if (arg1[0] == 'C') {
            strcpy(arg6, "$xy");
            status = ocsmNewBrch(MODL, iafter++, OCSM_ARC, "", -1,
                                 arg2, arg3, arg4, arg5, arg6, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);
        } else if (arg1[0] == 'S') {
            status = ocsmNewBrch(MODL, iafter++, OCSM_SPLINE, "", -1,
                                 arg2, arg3, arg4, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);
        } else if (arg1[0] == 'B') {
            status = ocsmNewBrch(MODL, iafter++, OCSM_BEZIER, "", -1,
                                 arg2, arg3, arg4, NULL, NULL, NULL, NULL, NULL, NULL);
            CHECK_STATUS(ocsmNewBrch);
        }
    }

    if (outLevel >= 2) {
        SPRINT0(2, "ocsmSaveSketch: after additions");
        status = ocsmPrintBrchs(MODL, "");
        CHECK_STATUS(ocsmPrintBrchs);
    }

cleanup:
    FREE(arg6);
    FREE(arg5);
    FREE(arg4);
    FREE(arg3);
    FREE(arg2);
    FREE(arg1);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmMakeEBody - make an EBody from a given Body                    *
 *                                                                      *
 ************************************************************************
 */

int
ocsmMakeEBody(void   *modl,             /* (in)  pointer to MODL */
              int    ibody,             /* (in)  Body index (1:nbody) */
              double dihedral,          /* (in)  dihedral angle (deg) for implicit .Keeps */
    /*@null@*/char   entList[])         /* (in)  entities to use in EBody (or NULL to delete) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       nnode, inode, nedge, iedge, nface, iface, nkeep, ikeep, ngroup, igroup;
    double    bbox[6], size, params[3];
    char      *pEnd;
    ego       *enodes=NULL, *eedges=NULL, *efaces=NULL;
    ego       newBody, newTess, newEBody, newEFace, *group=NULL;

    ROUTINE(ocsmMakeEBody);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* if attrName is NULL,  then we should delete the EBody (if it exists) */
    if (entList == NULL) {
        if (MODL->body[ibody].eetess != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eetess);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].eetess = NULL;
        }

        if (MODL->body[ibody].eebody != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eebody);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].eebody = NULL;
        }

    } else {

        /* make a copy of the Body */
        status = EG_copyObject(MODL->body[ibody].ebody, NULL, &newBody);
        CHECK_STATUS(EG_copyObject);

        status = EG_getBodyTopos(newBody, NULL, NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_getBodyTopos(newBody, NULL, EDGE, &nedge, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_getBodyTopos(newBody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        /* initialize our place in the entList */
        pEnd = entList - 1;

        /* mark the Nodes to be kept */
        nkeep  = strtol(pEnd+1, &pEnd, 10);
        for (ikeep = 0; ikeep < nkeep; ikeep++) {
            SPLINT_CHECK_FOR_NULL(enodes);

            inode  = strtol(pEnd+1, &pEnd, 10);
            status = EG_attributeAdd(enodes[inode-1], ".Keep", ATTRINT, 1, &inode, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);
        }

        /* mark the Edges to be kept */
        nkeep  = strtol(pEnd+1, &pEnd, 10);
        for (ikeep = 0; ikeep < nkeep; ikeep++) {
            SPLINT_CHECK_FOR_NULL(eedges);

            iedge  = strtol(pEnd+1, &pEnd, 10);
            status = EG_attributeAdd(eedges[iedge-1], ".Keep", ATTRINT, 1, &iedge, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);
        }

        /* copy the Tessellation onto the newBody */
        status = EG_copyObject(MODL->body[ibody].etess, newBody, &newTess);
        CHECK_STATUS(EG_copyObject);

        /* initialize the EBody */
        status = EG_initEBody(newTess, dihedral, &newEBody);
        CHECK_STATUS(EG_initEBody);

        /* make the EFaces */
        ngroup = strtol(pEnd+1, &pEnd, 10);
        while (ngroup > 0) {
            SPLINT_CHECK_FOR_NULL(efaces);

            MALLOC(group, ego, ngroup);
            for (igroup = 0; igroup < ngroup; igroup++) {
                iface  = strtol(pEnd+1, &pEnd, 10);
                group[igroup] = efaces[iface-1];
            }

            status = EG_makeEFace(newEBody, ngroup, group, &newEFace);
            CHECK_STATUS(EG_makeEFace);

            FREE(group);

            /* get ready for next group */
            ngroup = strtol(pEnd+1, &pEnd, 10);
        }

        /* close the EBody */
        status = EG_finishEBody(newEBody);
        CHECK_STATUS(EG_finishEBody);

        /* tessellate the EBody */
        status = EG_getBoundingBox(newEBody, bbox);
        CHECK_STATUS(EG_getBoundingBox);

        size = sqrt(SQR(bbox[3]-bbox[0]) + SQR(bbox[4]-bbox[1]) + SQR(bbox[5]-bbox[2]));

        params[0] = TESS_PARAM_0 * size;
        params[1] = TESS_PARAM_1 * size;
        params[2] = TESS_PARAM_2;

        status = EG_makeTessBody(newEBody, params, &(MODL->body[ibody].eetess));
        CHECK_STATUS(EG_makeTessBody);

        status = EG_attributeAdd(MODL->body[ibody].eetess, ".tessType", ATTRSTRING, 4, NULL, NULL, "Tris");
        CHECK_STATUS(EG_attributeAdd);

        /* remember this EBody */
        MODL->body[ibody].eebody = newEBody;
    }

cleanup:
    if (enodes != NULL) EG_free(enodes);
    if (eedges != NULL) EG_free(eedges);
    if (efaces != NULL) EG_free(efaces);

    FREE(group);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmNewPmtr - create a new Parameter                               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmNewPmtr(void   *modl,               /* (in)  pointer to MODL */
            char   name[],              /* (in)  Parameter name */
            int    type,                /* (in)  Parameter type */
            int    nrow,                /* (in)  number of rows */
            int    ncol)                /* (in)  number of columns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ipmtr, i, old_nrow, old_ncol;
    int       resize=0;

    ROUTINE(ocsmNewPmtr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if an UNKNOWN and Parameter is already a DESPMTR, CFGPMTR, or UNKNOWN, just return */
    if (type == OCSM_UNKNOWN) {
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, name) == 0) {
                if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR ||
                    MODL->pmtr[ipmtr].type == OCSM_CFGPMTR ||
                    MODL->pmtr[ipmtr].type == OCSM_UNKNOWN   ) {
                    goto cleanup;
                }
            }
        }
    }

    /* if an UNKNOWN and Parameter is already a OUTPMTR or LOCALVAR, update
       the input type */
    if (type == OCSM_UNKNOWN) {
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, name) == 0) {
                if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR ||
                    MODL->pmtr[ipmtr].type == OCSM_LOCALVAR   ) {
                    type = MODL->pmtr[ipmtr].type;
                    break;
                }
            }
        }
    }

    /* if a CONPMTR, DESPMTR, or CFGPMTR remove any INTERNAL Parameters
       that might already exist (from a previous ocsmBuild) */
    if (type == OCSM_CONPMTR || type == OCSM_DESPMTR || type == OCSM_CFGPMTR) {
        for (ipmtr = MODL->npmtr; ipmtr > 0; ipmtr--) {
            if (MODL->pmtr[ipmtr].type == OCSM_LOCALVAR) {
                status = ocsmDelPmtr(MODL, ipmtr);
                CHECK_STATUS(ocsmDelPmtr);
            }
        }
    }

    /* if an OUTPMTR Parameter already exists, mark it as needing to be resized */
    resize = 0;
    if (type == OCSM_OUTPMTR) {
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, name) == 0) {
                if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {
                    resize = ipmtr;
                    break;
                }
            }
        }

    /* check if pmtrName is already defined at this scope */
    } else {
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (strcmp(MODL->pmtr[ipmtr].name, name) == 0                 &&
                MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                if (type == OCSM_LOCALVAR && MODL->pmtr[ipmtr].nrow == nrow
                                          && MODL->pmtr[ipmtr].ncol == ncol) {
                    status = SUCCESS;
                } else if (type == OCSM_LOCALVAR) {
                    resize = ipmtr;
                    break;
                } else {
                    status = OCSM_NAME_ALREADY_DEFINED;
                }
                goto cleanup;
            }
        }
    }

    /* check that pmtrName is a valid name */
    if (STRLEN(name) == 0 || STRLEN(name) >= MAX_NAME_LEN) {
        status = OCSM_ILLEGAL_PMTR_NAME;
        goto cleanup;
    } else if (name[0] == '@') {
    } else if (isalpha(name[0]) == 0 && name[0] != ':') {
        status = OCSM_ILLEGAL_PMTR_NAME;
        goto cleanup;
    } else {
        for (i = 1; i < STRLEN(name); i++) {
            if        (isalpha(name[i]) != 0) {
            } else if (isdigit(name[i]) != 0) {
            } else if (name[i] == '_') {
            } else if (name[i] == '@') {
            } else if (name[i] == ':') {
            } else {
                status = OCSM_ILLEGAL_PMTR_NAME;
                goto cleanup;
            }
        }
    }

    /* check for a valid Parameter type */
    if (type != OCSM_DESPMTR  && type != OCSM_CFGPMTR && type != OCSM_OUTPMTR &&
        type != OCSM_LOCALVAR && type != OCSM_CONPMTR && type != OCSM_UNKNOWN   ) {
        status = OCSM_ILLEGAL_TYPE;
        goto cleanup;
    }

    /* extend the Parameter list (if needed) */
#ifndef __clang_analyzer__
    if (MODL->npmtr >= MODL->mpmtr) {
        MODL->mpmtr += 25;
        RALLOC(MODL->pmtr, pmtr_T, MODL->mpmtr+1);

        for (ipmtr = MODL->npmtr+1; ipmtr <= MODL->mpmtr; ipmtr++) {
            MODL->pmtr[ipmtr].name  = NULL;
            MODL->pmtr[ipmtr].mprop = 0;
            MODL->pmtr[ipmtr].value = NULL;
            MODL->pmtr[ipmtr].dot   = NULL;
            MODL->pmtr[ipmtr].lbnd  = NULL;
            MODL->pmtr[ipmtr].ubnd  = NULL;
            MODL->pmtr[ipmtr].str   = NULL;
        }
    }
#endif

    /* create the new Parameter */
    if (resize == 0) {
        MODL->npmtr += 1;
        ipmtr = MODL->npmtr;

    /* or resize existing Parameter */
    } else {
        ipmtr = resize;
    }

    /* store its name and defn */
    FREE(   MODL->pmtr[ipmtr].name);
    MALLOC( MODL->pmtr[ipmtr].name, char, (int)(STRLEN(name)+1));
    STRNCPY(MODL->pmtr[ipmtr].name, name,       STRLEN(name)+1 );

    if (nrow <= 0 || ncol <= 0) {
        FREE(MODL->pmtr[ipmtr].value);
        FREE(MODL->pmtr[ipmtr].dot  );
        FREE(MODL->pmtr[ipmtr].lbnd );
        FREE(MODL->pmtr[ipmtr].ubnd );
        FREE(MODL->pmtr[ipmtr].str  );

        MALLOC( MODL->pmtr[ipmtr].str,   char,   MAX_STRVAL_LEN);

        nrow = 0;
        ncol = 0;

    } else if (resize == 0) {
        FREE(MODL->pmtr[ipmtr].value);
        FREE(MODL->pmtr[ipmtr].dot  );
        FREE(MODL->pmtr[ipmtr].lbnd );
        FREE(MODL->pmtr[ipmtr].ubnd );
        FREE(MODL->pmtr[ipmtr].str  );

        MALLOC(MODL->pmtr[ipmtr].value, double, nrow*ncol);
        MALLOC(MODL->pmtr[ipmtr].dot,   double, nrow*ncol);

        if (type == OCSM_DESPMTR || type == OCSM_CFGPMTR || type == OCSM_UNKNOWN) {
            MALLOC(MODL->pmtr[ipmtr].lbnd,  double, nrow*ncol);
            MALLOC(MODL->pmtr[ipmtr].ubnd,  double, nrow*ncol);
        }

        /* initialize to large values */
        for (i = 0; i < nrow*ncol; i++) {
            MODL->pmtr[ipmtr].value[i] = -HUGEQ;
            MODL->pmtr[ipmtr].dot[  i] = 0;

            if (type == OCSM_DESPMTR || type == OCSM_CFGPMTR || type == OCSM_UNKNOWN) {
                MODL->pmtr[ipmtr].lbnd[i] = -HUGEQ;
                MODL->pmtr[ipmtr].ubnd[i] = +HUGEQ;
            }
        }

    } else {
        FREE(MODL->pmtr[ipmtr].str);

        old_nrow = MODL->pmtr[ipmtr].nrow;
        old_ncol = MODL->pmtr[ipmtr].ncol;

        RALLOC(MODL->pmtr[ipmtr].value, double, nrow*ncol);
        RALLOC(MODL->pmtr[ipmtr].dot,   double, nrow*ncol);
        if (type == OCSM_DESPMTR || type == OCSM_CFGPMTR || type == OCSM_UNKNOWN) {
            RALLOC(MODL->pmtr[ipmtr].lbnd,  double, nrow*ncol);
            RALLOC(MODL->pmtr[ipmtr].ubnd,  double, nrow*ncol);
        }

        /* if not previously an array, initialize to large values */
        if (old_nrow == 0 || old_ncol == 0) {
            for (i = 0; i < nrow*ncol; i++) {
                MODL->pmtr[ipmtr].value[i] = -HUGEQ;
                MODL->pmtr[ipmtr].dot[  i] = 0;
                if (type == OCSM_DESPMTR || type == OCSM_CFGPMTR || type == OCSM_UNKNOWN) {
                    MODL->pmtr[ipmtr].lbnd[i] = -HUGEQ;
                    MODL->pmtr[ipmtr].ubnd[i] = +HUGEQ;
                }
            }

        /* propagate last value if new array is larger */
        } else {
            for (i = old_nrow*old_ncol; i < nrow*ncol; i++) {
                MODL->pmtr[ipmtr].value[i] = MODL->pmtr[ipmtr].value[i-1];
                MODL->pmtr[ipmtr].dot[  i] = MODL->pmtr[ipmtr].dot[  i-1];
                if (type == OCSM_DESPMTR || type == OCSM_CFGPMTR || type == OCSM_UNKNOWN) {
                    MODL->pmtr[ipmtr].lbnd[i] = MODL->pmtr[ipmtr].lbnd[i-1];
                    MODL->pmtr[ipmtr].ubnd[i] = MODL->pmtr[ipmtr].ubnd[i-1];
                }
            }
        }
    }

    if (type == OCSM_DESPMTR || type == OCSM_CFGPMTR || type == OCSM_CONPMTR) {
        MODL->pmtr[ipmtr].scope = 0;
    } else {
        MODL->pmtr[ipmtr].scope = MODL->scope[MODL->level];
    }

    MODL->pmtr[ipmtr].type  = type;
    MODL->pmtr[ipmtr].nrow  = nrow;
    MODL->pmtr[ipmtr].ncol  = ncol;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmDelPmtr - delete a Parameter                                   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmDelPmtr(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr)               /* (in)  Parameter index (1:npmtr) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jpmtr;

    ROUTINE(ocsmDelPmtr);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr is given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    /* remove data associated with this Parameter */
    FREE(MODL->pmtr[ipmtr].name );
    FREE(MODL->pmtr[ipmtr].value);
    FREE(MODL->pmtr[ipmtr].dot  );
    FREE(MODL->pmtr[ipmtr].lbnd );
    FREE(MODL->pmtr[ipmtr].ubnd );
    FREE(MODL->pmtr[ipmtr].str  );

    /* move all Parameters up to write over deleted Parameter */
    for (jpmtr = ipmtr; jpmtr < MODL->npmtr; jpmtr++) {
        MODL->pmtr[jpmtr].name  = MODL->pmtr[jpmtr+1].name;
        MODL->pmtr[jpmtr].type  = MODL->pmtr[jpmtr+1].type;
        MODL->pmtr[jpmtr].scope = MODL->pmtr[jpmtr+1].scope;
        MODL->pmtr[jpmtr].mprop = MODL->pmtr[jpmtr+1].mprop;
        MODL->pmtr[jpmtr].nrow  = MODL->pmtr[jpmtr+1].nrow;
        MODL->pmtr[jpmtr].ncol  = MODL->pmtr[jpmtr+1].ncol;
        MODL->pmtr[jpmtr].value = MODL->pmtr[jpmtr+1].value;
        MODL->pmtr[jpmtr].dot   = MODL->pmtr[jpmtr+1].dot;
        MODL->pmtr[jpmtr].lbnd  = MODL->pmtr[jpmtr+1].lbnd;
        MODL->pmtr[jpmtr].ubnd  = MODL->pmtr[jpmtr+1].ubnd;
        MODL->pmtr[jpmtr].str   = MODL->pmtr[jpmtr+1].str;
    }

    /* null pointers associated with last Parameter (since they were
       copied down) */
    MODL->pmtr[MODL->npmtr].name  = NULL;
    MODL->pmtr[MODL->npmtr].value = NULL;
    MODL->pmtr[MODL->npmtr].dot   = NULL;
    MODL->pmtr[MODL->npmtr].lbnd  = NULL;
    MODL->pmtr[MODL->npmtr].ubnd  = NULL;
    MODL->pmtr[MODL->npmtr].str   = NULL;

    /* decrement the number of Parameters */
    (MODL->npmtr)--;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmFindPmtr - find (or create) a Parameter                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmFindPmtr(void   *modl,              /* (in)  pointer to MODL */
             char   name[],             /* (in)  Parameter name */
             int    type,               /* (in)  Parameter type    (or 0 to not create) */
             int    nrow,               /* (in)  number of rows */
             int    ncol,               /* (in)  number of columns */
             int    *ipmtr)             /* (out) Parameter index (1:npmtr) (or 0 if not found) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jpmtr;

    ROUTINE(ocsmFindPmtr);

    /* --------------------------------------------------------------- */

    *ipmtr = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if type is zero, just look for the name */
    if (type == 0) {
        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            if (strcmp(MODL->pmtr[jpmtr].name, name) == 0 &&
                MODL->pmtr[jpmtr].scope == 0                ) {
                *ipmtr = jpmtr;
                break;
            }
        }
        goto cleanup;
    }

    /* check if name is already defined at this level */
    for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
        if (strcmp(MODL->pmtr[jpmtr].name, name) == 0                 &&
                   MODL->pmtr[jpmtr].scope == MODL->scope[MODL->level]  ) {

            if (type == MODL->pmtr[jpmtr].type &&
                nrow <= MODL->pmtr[jpmtr].nrow &&
                ncol <= MODL->pmtr[jpmtr].ncol   ) {
                *ipmtr = jpmtr;
                goto cleanup;
            } else {
                *ipmtr = jpmtr;
                status = OCSM_NAME_ALREADY_DEFINED;
                goto cleanup;
            }
        }
    }

    /* if we got here, create a new Parameter */
    status = ocsmNewPmtr(MODL, name, type, nrow, ncol);
    CHECK_STATUS(ocsmNewPmtr);

    *ipmtr = MODL->npmtr;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetPmtr - get info about a Parameter                           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetPmtr(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1:npmtr) */
            int    *type,               /* (out) Parameter type */
            int    *nrow,               /* (out) number of rows */
            int    *ncol,               /* (out) number of columns */
            char   name[])              /* (out) Parameter name (at least MAX_NAME_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetPmtr);

    /* --------------------------------------------------------------- */

    /* default return values */
    name[0] = '\0';
    *type   = 0;
    *nrow   = 0;
    *ncol   = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr is given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    /* return the name, type, and size */
    STRNCPY(name, MODL->pmtr[ipmtr].name, MAX_NAME_LEN);
    *type  =      MODL->pmtr[ipmtr].type;
    *nrow  =      MODL->pmtr[ipmtr].nrow;
    *ncol  =      MODL->pmtr[ipmtr].ncol;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintPmtrs - print despmtrs and outpmtrs to file               *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintPmtrs(void   *modl,            /* (in)  pointer to MODL */
               char   filename[])       /* (in)  file to which output is appended (or "" for stdout) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ipmtr, maxlen, irow, icol, index, count;
    char      typeChar;
    FILE      *fp=NULL;

    ROUTINE(ocsmPrintPmtrs);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    if (strlen(filename) == 0) {
        fp = stdout;
    } else {
        fp = fopen(filename, "a");
        if (fp == NULL) {
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }
    }

    /* find maximum name length */
    maxlen = 0;
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (STRLEN(MODL->pmtr[ipmtr].name) > maxlen) {
            maxlen = STRLEN(MODL->pmtr[ipmtr].name);
        }
    }

    fprintf(fp, "    ipmtr\n");

    /* loop through all constant Parameters and print its name and values */
    count = 0;
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  == OCSM_CONPMTR) {
            fprintf(fp, "    %5d [c]  %-*s            %11.5f",
                    ipmtr, maxlen, MODL->pmtr[ipmtr].name, MODL->pmtr[ipmtr].value[0]);
            for (index = 1; index < MODL->pmtr[ipmtr].ncol; index++) {
                fprintf(fp, "   %11.5f", MODL->pmtr[ipmtr].value[index]);
            }
            fprintf(fp, "\n");
            count++;
        }
    }

    /* loop through all DESPMTR and CFGPMTR Parameters and print its name, value, and defn */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR ||
            MODL->pmtr[ipmtr].type == OCSM_CFGPMTR   ) {

            if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR) {
                typeChar = 'd';
            } else {
                typeChar = 'f';
            }

            index = 0;
            for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    fprintf(fp, "    %5d [%c]  %-*s  [%3d,%3d] %11.5f %11.5f    >>",
                            ipmtr, typeChar, maxlen, MODL->pmtr[ipmtr].name,
                            irow, icol, MODL->pmtr[ipmtr].value[index],
                                        MODL->pmtr[ipmtr].dot[  index]);

                    if (MODL->pmtr[ipmtr].lbnd[index] <= -HUGEQ) {
                        fprintf(fp, " unbounded  << ");
                    } else {
                        fprintf(fp, "%11.5f << ", MODL->pmtr[ipmtr].lbnd[ index]);
                    }

                    if (MODL->pmtr[ipmtr].ubnd[index] >= +HUGEQ) {
                        fprintf(fp, " unbounded \n");
                    } else {
                        fprintf(fp, "%11.5f\n",   MODL->pmtr[ipmtr].ubnd[ index]);
                    }

                    index++;
                }
            }
            count++;
        }
    }

    /* loop through all OUTPMTR Parameters and print its name, value, and defn */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {

            index = 0;
            for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    fprintf(fp, "    %5d [o]  %-*s  [%3d,%3d] %11.5f %11.5f\n",
                            ipmtr, maxlen, MODL->pmtr[ipmtr].name,
                            irow, icol, MODL->pmtr[ipmtr].value[index],
                                        MODL->pmtr[ipmtr].dot[  index]);
                    index++;
                }
            }
            count++;
        }
    }

    /* return message if no Paramaters */
    if (count <= 0) {
        fprintf(fp, "    --none--\n");
        goto cleanup;
    }

cleanup:
    if (fp != NULL && strlen(filename) > 0) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetValu - get the Value of a Parameter                         *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetValu(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1:npmtr) */
            int    irow,                /* (in)  row    index (1:nrow) */
            int    icol,                /* (in)  column index (1:ncol) */
            double *value,              /* (out) Parameter value */
            double *dot)                /* (out) Parameter velocity */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index;

    ROUTINE(ocsmGetValu);

    /* --------------------------------------------------------------- */

    /* default return values */
    *value = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_CONPMTR) {

    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {

    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].str != NULL) {
        status = OCSM_WRONG_PMTR_TYPE;
        goto cleanup;
    }

    /* if an OUTPMTR was requested and we have some dots, set up perturbed MODL */
    if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR && MODL->numdots > 0) {
        status = setupForFiniteDifferences(MODL);
        CHECK_STATUS(setupForFiniteDifferences);
    }

    /* if a mass property, make sure mass properties are set up */
    if (MODL->pmtr[ipmtr].mprop == 1) {
        status = computeMassProps(MODL);
        CHECK_STATUS(computeMassProps);
    }

    /* get the values/dots */
    if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* return pertinent information */
    *value = MODL->pmtr[ipmtr].value[index];
    *dot   = MODL->pmtr[ipmtr].dot[  index];

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetValuS - get the Value of a string Parameter                 *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetValuS(void   *modl,              /* (in)  pointer to MODL */
             int    ipmtr,              /* (in)  Parameter index (1:npmtr) */
             char   str[])              /* (out) Parameter value (at least MAX_STRVAL_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetValuS);

    /* --------------------------------------------------------------- */

    /* default return values */
    str[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr is given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_CONPMTR) {

    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    /* return pertinent information */
    STRNCPY(str, MODL->pmtr[ipmtr].str, MAX_STRVAL_LEN);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetValu - set a Value for a Parameter                          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetValu(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1:npmtr) */
            int    irow,                /* (in)  row    index (1:nrow) */
            int    icol,                /* (in)  column index (1:nrow) or 0 for index */
            char   defn[])              /* (in)  definition of Value */
{
    int       status = SUCCESS;         /* (out) return status */

    int       index, ibrch, jpmtr, nrow, ncol, ibeg, ichange;
    double    val, dot;
    char      str[MAX_STRVAL_LEN];

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetValu);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {

    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    status = str2val(defn, MODL, &val, &dot, str);
    CHECK_STATUS(str2val);

    /* special treatment for string values */
    if (STRLEN(str) > 0) {

        /* make sure row and column are both zero */
        if (irow != 1 || icol != 1) {
            status = OCSM_WRONG_PMTR_TYPE;
            goto cleanup;
        }

        /* if not a string, make it so now */
        if (MODL->pmtr[ipmtr].str == NULL) {
            FREE(MODL->pmtr[ipmtr].value);
            FREE(MODL->pmtr[ipmtr].dot  );
            FREE(MODL->pmtr[ipmtr].lbnd );
            FREE(MODL->pmtr[ipmtr].ubnd );
        }

        FREE(   MODL->pmtr[ipmtr].str);
        MALLOC( MODL->pmtr[ipmtr].str, char, MAX_STRVAL_LEN);
        STRNCPY(MODL->pmtr[ipmtr].str, str,  MAX_STRVAL_LEN);

        MODL->pmtr[ipmtr].nrow = 0;
        MODL->pmtr[ipmtr].ncol = 0;

        goto cleanup;

    /* treatment for numbers */
    } else if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR ||
        MODL->pmtr[ipmtr].type == OCSM_CFGPMTR ||
        MODL->pmtr[ipmtr].type == OCSM_CONPMTR   ) {
        status = ocsmSetVelD(MODL, 0, 0, 0, 0);
        CHECK_STATUS(ocsmSetVelD);
    }

    /* evaluate the definition */
    if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR ||
        MODL->pmtr[ipmtr].type == OCSM_CFGPMTR ||
        MODL->pmtr[ipmtr].type == OCSM_CONPMTR   ) {
        status = str2val(defn, NULL, &val, &dot, str);
        CHECK_STATUS(str2val);
    } else {
        status = str2val(defn, MODL, &val, &dot, str);
        CHECK_STATUS(str2val);
    }

    /* make sure new value is in bounds */
    if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR ||
        MODL->pmtr[ipmtr].type == OCSM_CFGPMTR   ) {
        if (val < MODL->pmtr[ipmtr].lbnd[index] ||
            val > MODL->pmtr[ipmtr].ubnd[index]   ) {
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        }
    }

    /* set pertinent information */
    MODL->pmtr[ipmtr].value[index] = val;
    MODL->pmtr[ipmtr].dot[  index] = 0;

    if (MODL->pmtr[ipmtr].type != OCSM_CFGPMTR &&
        MODL->pmtr[ipmtr].type != OCSM_DESPMTR   ) goto cleanup;

    /* loop through all DIMENSION statements associated with either
       a DESPMTR or CFGPMTR */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        if (MODL->brch[ibrch].type != OCSM_DIMENSION) continue;

        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            if (MODL->pmtr[jpmtr].type != OCSM_DESPMTR &&
                MODL->pmtr[jpmtr].type != OCSM_CFGPMTR   ) continue;

            if (strcmp(MODL->pmtr[jpmtr].name, &(MODL->brch[ibrch].arg1[1])) != 0) continue;

            /* determine the number of row and columns based
               upon the current values */
            status = str2val(MODL->brch[ibrch].arg2, MODL, &val, &dot, str);
            CHECK_STATUS(str2val);
            nrow = NINT(val);

            status = str2val(MODL->brch[ibrch].arg3, MODL, &val, &dot, str);
            CHECK_STATUS(str2val);
            ncol = NINT(val);

            /* if the new size is different, reallocate the arrays */
            if (nrow*ncol != MODL->pmtr[jpmtr].nrow*MODL->pmtr[jpmtr].ncol) {
                RALLOC(MODL->pmtr[jpmtr].value, double, nrow*ncol);
                RALLOC(MODL->pmtr[jpmtr].dot,   double, nrow*ncol);
                RALLOC(MODL->pmtr[jpmtr].lbnd,  double, nrow*ncol);
                RALLOC(MODL->pmtr[jpmtr].ubnd,  double, nrow*ncol);
                ichange = 1;
            } else {
                ichange = 0;
            }

            /* if there now more entries, repeat the last value */
            ibeg = MODL->pmtr[jpmtr].nrow * MODL->pmtr[jpmtr].ncol;
            for (index = ibeg; index < nrow*ncol; index++) {
                MODL->pmtr[jpmtr].value[index] = MODL->pmtr[jpmtr].value[ibeg-1];
                MODL->pmtr[jpmtr].dot[  index] = MODL->pmtr[jpmtr].dot[  ibeg-1];
                MODL->pmtr[jpmtr].lbnd[ index] = MODL->pmtr[jpmtr].lbnd[ ibeg-1];
                MODL->pmtr[jpmtr].ubnd[ index] = MODL->pmtr[jpmtr].ubnd[ ibeg-1];
            }

            /* finish the change */
            MODL->pmtr[jpmtr].nrow = nrow;
            MODL->pmtr[jpmtr].ncol = ncol;

            /* make the callback if it exists and size has changed */
            if (ichange > 0 && MODL->sizeCB != NULL) {
                MODL->sizeCB(MODL, jpmtr, nrow, ncol);
            }
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetValuD - set a (double) Value for a Parameter                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetValuD(void   *modl,              /* (in)  pointer to MODL */
             int    ipmtr,              /* (in)  Parameter index (1:npmtr) */
             int    irow,               /* (in)  row    index (1:nrow) */
             int    icol,               /* (in)  column index (1:nrow) or 0 for index */
             double value)              /* (in)  value to set */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index, ibrch, jpmtr, nrow, ncol, ibeg, ichange;
    double    val, dot;
    char      str[MAX_STRVAL_LEN];

    ROUTINE(ocsmSetValuD);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type  == OCSM_OUTPMTR) {

    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_CONSTANT) {
        status = OCSM_PMTR_IS_CONSTANT;
        goto cleanup;
    }

    if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR ||
        MODL->pmtr[ipmtr].type == OCSM_CFGPMTR ||
        MODL->pmtr[ipmtr].type == OCSM_CONPMTR   ) {
        status = ocsmSetVelD(MODL, 0, 0, 0, 0);
        CHECK_STATUS(ocsmSetVelD);
    }

    /* make sure new value is in bounds */
    if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR ||
        MODL->pmtr[ipmtr].type == OCSM_CFGPMTR   ) {
        if (value < MODL->pmtr[ipmtr].lbnd[index] ||
            value > MODL->pmtr[ipmtr].ubnd[index]   ) {
            status = OCSM_ILLEGAL_VALUE;
            goto cleanup;
        }
    }

    /* set pertinent information */
    MODL->pmtr[ipmtr].value[index] = value;
    MODL->pmtr[ipmtr].dot[  index] = 0;

    if (MODL->pmtr[ipmtr].type != OCSM_CFGPMTR &&
        MODL->pmtr[ipmtr].type != OCSM_DESPMTR   ) goto cleanup;

    /* loop through all DIMENSION statements associated with either
       a DESPMTR or CFGPMTR */
    for (ibrch = 1; ibrch <= MODL->nbrch; ibrch++) {
        if (MODL->brch[ibrch].type != OCSM_DIMENSION) continue;

        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            if (MODL->pmtr[jpmtr].type != OCSM_DESPMTR &&
                MODL->pmtr[jpmtr].type != OCSM_CFGPMTR   ) continue;

            if (strcmp(MODL->pmtr[jpmtr].name, &(MODL->brch[ibrch].arg1[1])) != 0) continue;

            /* determine the number of row and columns based
               upon the current values */
            status = str2val(MODL->brch[ibrch].arg2, MODL, &val, &dot, str);
            CHECK_STATUS(str2val);
            nrow = NINT(val);

            status = str2val(MODL->brch[ibrch].arg3, MODL, &val, &dot, str);
            CHECK_STATUS(str2val);
            ncol = NINT(val);

            /* if the new size is different, reallocate the arrays */
            if (nrow*ncol != MODL->pmtr[jpmtr].nrow*MODL->pmtr[jpmtr].ncol) {
                RALLOC(MODL->pmtr[jpmtr].value, double, nrow*ncol);
                RALLOC(MODL->pmtr[jpmtr].dot,   double, nrow*ncol);
                RALLOC(MODL->pmtr[jpmtr].lbnd,  double, nrow*ncol);
                RALLOC(MODL->pmtr[jpmtr].ubnd,  double, nrow*ncol);
                ichange = 1;
            } else {
                ichange = 0;
            }

            /* if there now more entries, repeat the last value */
            ibeg = MODL->pmtr[jpmtr].nrow * MODL->pmtr[jpmtr].ncol;
            for (index = ibeg; index < nrow*ncol; index++) {
                MODL->pmtr[jpmtr].value[index] = MODL->pmtr[jpmtr].value[ibeg-1];
                MODL->pmtr[jpmtr].dot[  index] = MODL->pmtr[jpmtr].dot[  ibeg-1];
                MODL->pmtr[jpmtr].lbnd[ index] = MODL->pmtr[jpmtr].lbnd[ ibeg-1];
                MODL->pmtr[jpmtr].ubnd[ index] = MODL->pmtr[jpmtr].ubnd[ ibeg-1];
            }

            /* finish the change */
            MODL->pmtr[jpmtr].nrow = nrow;
            MODL->pmtr[jpmtr].ncol = ncol;

            /* make the callback if it exists and size has changed */
            if (ichange > 0 && MODL->sizeCB != NULL) {
                MODL->sizeCB(MODL, jpmtr, nrow, ncol);
            }
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetBnds - get the Bounds of a Parameter                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetBnds(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1:npmtr) */
            int    irow,                /* (in)  row    index (1:nrow) */
            int    icol,                /* (in)  column index (1:ncol) */
            double *lbound,             /* (out) lower Bound */
            double *ubound)             /* (out) upper Bound */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index;

    ROUTINE(ocsmGetBnds);

    /* --------------------------------------------------------------- */

    /* default return values */
    *lbound = -HUGEQ;
    *ubound = +HUGEQ;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_CONSTANT) {
        status = OCSM_PMTR_IS_CONSTANT;
        goto cleanup;
    } else if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* return pertinent information */
    *lbound = MODL->pmtr[ipmtr].lbnd[index];
    *ubound = MODL->pmtr[ipmtr].ubnd[index];

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetBnds - set the Bounds of a Parameter                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetBnds(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1:npmtr) */
            int    irow,                /* (in)  row    index (1:nrow) */
            int    icol,                /* (in)  column index (1:ncol) */
            double lbound,              /* (in)  lower Bound to set */
            double ubound)              /* (in)  upper Bound to set */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index;

    ROUTINE(ocsmSetBnds);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that lower bound is not greater than upper bound */
    if (lbound > ubound) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (icol == 0) {
        if (irow < 1 || irow > (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol)) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = irow - 1;
    } else {
        if (irow < 1 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }

        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
    }

    /* check that ipmtr is an DESPMTR parameter */
    if (MODL->pmtr[ipmtr].type != OCSM_DESPMTR) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    /* check that current value will be in proposed bounds */
    if (MODL->pmtr[ipmtr].value[index] < lbound ||
        MODL->pmtr[ipmtr].value[index] > ubound   ) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* set the bounds */
    MODL->pmtr[ipmtr].lbnd[index] = lbound;
    MODL->pmtr[ipmtr].ubnd[index] = ubound;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetDtime - set sensitivity FD time step (or select analytic)   *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetDtime(void   *modl,              /* (in)  pointer to MODL */
             double dtime)              /* (in)  time step (or 0 to choose analytic) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetDtime);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* store the initial dtime */
    MODL->dtime = dtime;

    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* if dtime!=0, then make a perturbation, starting at the givem dtime */
    if (dtime != 0) {
        status = createPerturbation(MODL);
        CHECK_STATUS(createPerturbation);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetVel - set a velocity for a Parameter                        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetVel(void   *modl,                /* (in)  pointer to MODL */
           int    ipmtr,                /* (in)  Parameter index (1:npmtr) or 0 for all */
           int    irow,                 /* (in)  row    index (1:nrow)     or 0 for all */
           int    icol,                 /* (in)  column index (1:nrow)     or 0 for all */
           char   defn[])               /* (in)  definition of Velocity */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index, jpmtr, nchange;
    double    dot, dum;
    char      str[MAX_STRVAL_LEN];

    ROUTINE(ocsmSetVel);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr == 0) {
        if (irow != 0 || icol != 0) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }
    } else if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {

    } else if (MODL->pmtr[ipmtr].type == OCSM_CFGPMTR) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    if (ipmtr > 0) {
        if (icol == 0) {
            if (irow < 0 || irow > MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol) {
                status = OCSM_ILLEGAL_PMTR_INDEX;
                goto cleanup;
            }
        } else if (irow < 0 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }
    }

    /* if this has a perturbed Body, free it first */
    status = removePerturbation(MODL);
    CHECK_STATUS(removePerturbation);

    /* remove any velocity information */
    status = removeVels(MODL, 0);
    CHECK_STATUS(removeVels);

    /* reset dtime so we try analytical derivative next time
       (unless the user calls ocsmSetDtime) */
    MODL->dtime = 0;

    /* evaluate the definition */
    dot = 0;

    status = str2val(defn, NULL, &dot, &dum, str);
    CHECK_STATUS(str2val);
    if (STRLEN(str) > 0) {
        status = OCSM_WRONG_PMTR_TYPE;
        goto cleanup;
    }

    /* set velocities on the Parameters */
    nchange = 0;

    if (ipmtr == 0) {
        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            for (index = 0; index < MODL->pmtr[jpmtr].nrow*MODL->pmtr[jpmtr].ncol; index++) {
                if (fabs(MODL->pmtr[jpmtr].dot[index]-dot) > EPS06) {
                    MODL->pmtr[jpmtr].dot[index] = dot;
                    nchange++;
                }
            }
        }
    } else if (irow == 0 && icol == 0) {
        for (index = 0; index < MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol; index++) {
            if (fabs(MODL->pmtr[ipmtr].dot[index]-dot) > EPS06) {
                MODL->pmtr[ipmtr].dot[index] = dot;
                nchange++;
            }
        }
    } else if (icol == 0) {
        index = irow - 1;
        if (fabs(MODL->pmtr[ipmtr].dot[index]-dot) > EPS06) {
            MODL->pmtr[ipmtr].dot[index] = dot;
            nchange++;
        }
    } else {
        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
        if (fabs(MODL->pmtr[ipmtr].dot[index]-dot) > EPS06) {
            MODL->pmtr[ipmtr].dot[index] = dot;
            nchange++;
        }
    }

    /* if this has a perturbed Body, free it first */
    if (nchange > 0) {
        status = removePerturbation(MODL);
        CHECK_STATUS(removePerturbation);

        /* remove any velocity information */
        status = removeVels(MODL, 0);
        CHECK_STATUS(removeVels);

        /* reset dtime so we try analytical derivative next time
           (unless the user calls ocsmSetDtime) */
        MODL->dtime = 0;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetVelD - set a double velocity for a Parameter                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetVelD(void   *modl,               /* (in)  pointer to MODL */
            int    ipmtr,               /* (in)  Parameter index (1:npmtr) or 0 for all */
            int    irow,                /* (in)  row    index (1:nrow)     or 0 for all */
            int    icol,                /* (in)  column index (1:nrow)     or 0 for all */
            double dot)                 /* (in)  velocity to set */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       index, jpmtr, nchange;

    ROUTINE(ocsmSetVelD);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ipmtr, irow, and icol are given */
    if (ipmtr == 0) {
        if (irow != 0 || icol != 0) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }
    } else if (ipmtr < 1 || ipmtr > MODL->npmtr) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].type == OCSM_OUTPMTR) {

    } else if (MODL->pmtr[ipmtr].type == OCSM_CFGPMTR) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    } else if (MODL->pmtr[ipmtr].scope != MODL->scope[MODL->level]) {
        status = OCSM_ILLEGAL_PMTR_INDEX;
        goto cleanup;
    }

    if (ipmtr > 0) {
        if (icol == 0) {
            if (irow < 0 || irow > MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol) {
                status = OCSM_ILLEGAL_PMTR_INDEX;
                goto cleanup;
            }
        } else if (irow < 0 || irow > MODL->pmtr[ipmtr].nrow) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        } else if (icol < 1 || icol > MODL->pmtr[ipmtr].ncol) {
            status = OCSM_ILLEGAL_PMTR_INDEX;
            goto cleanup;
        }
    }

    /* set velocities on the Parameters */
    nchange = 0;

    if (ipmtr == 0) {
        for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
            for (index = 0; index < MODL->pmtr[jpmtr].nrow*MODL->pmtr[jpmtr].ncol; index++) {
                if (fabs(MODL->pmtr[jpmtr].dot[index]-dot) > EPS06) {
                    MODL->pmtr[jpmtr].dot[index] = dot;
                    nchange++;
                }
            }
        }
    } else if (irow == 0 && icol == 0) {
        for (index = 0; index < MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol; index++) {
            if (fabs(MODL->pmtr[ipmtr].dot[index]-dot) > EPS06) {
                MODL->pmtr[ipmtr].dot[index] = dot;
                nchange++;
            }
        }
    } else if (icol == 0) {
        index = irow - 1;
        if (fabs(MODL->pmtr[ipmtr].dot[index]-dot) > EPS06) {
            MODL->pmtr[ipmtr].dot[index] = dot;
            nchange++;
        }
    } else {
        index = (icol-1) + (irow-1) * (MODL->pmtr[ipmtr].ncol);
        if (fabs(MODL->pmtr[ipmtr].dot[index]-dot) > EPS06) {
            MODL->pmtr[ipmtr].dot[index] = dot;
            nchange++;
        }
    }

    /* if this has a perturbed Body, free it first */
    if (nchange > 0) {
        status = removePerturbation(MODL);
        CHECK_STATUS(removePerturbation);

        /* remove any velocity information */
        status = removeVels(MODL, 0);
        CHECK_STATUS(removeVels);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetUV - get the parametric coordinates on an Edge or Face      *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetUV(void   *modl,                 /* (in)  pointer to MODL */
          int    ibody,                 /* (in)  Body index (1:nbody) */
          int    seltype,               /* (in)  OCSM_EDGE or OCSM_FACE */
          int    iselect,               /* (in)  Edge of Face index (1:nent) */
          int    npnt,                  /* (in)  number of points */
/*@null@*/double xyz[],                 /* (in)  coordinates (NULL or 3*npnt in length) */
          double uv[])                  /* (out) para coords (1*npnt or 2*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iedge, iface, ipnt, npnt_tess, ntri_tess;
    CINT      *ptype, *pindx, *tris, *tric;
    double    pos[3], data[2], result[3];
    CDOUBLE   *xyz_tess, *uv_tess;

    ROUTINE(ocsmGetUV);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* OCSM_EDGE was prescribed */
    if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 0 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        if (xyz == NULL) {
            status = EG_getTessEdge(MODL->body[ibody].edge[iedge].eedge, iedge,
                                    &npnt_tess, &xyz_tess, &uv_tess);
            CHECK_STATUS(EG_getTessEdge);

            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                uv[ipnt] = uv_tess[ipnt];
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                pos[0] = xyz[3*ipnt  ];
                pos[1] = xyz[3*ipnt+1];
                pos[2] = xyz[3*ipnt+2];

                status = EG_invEvaluate(MODL->body[ibody].edge[iedge].eedge,
                                        pos, data, result);
                CHECK_STATUS(EG_invEvaluate);

                uv[ipnt] = data[0];
            }
        }

    /* OCSM_FACE was prescribed */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 0 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        if (xyz == NULL) {
            status = EG_getTessFace(MODL->body[ibody].face[iface].eface, iface,
                                    &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                    &ntri_tess, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                uv[2*ipnt  ] = uv_tess[2*ipnt  ];
                uv[2*ipnt+1] = uv_tess[2*ipnt+1];
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                pos[0] = xyz[3*ipnt  ];
                pos[1] = xyz[3*ipnt+1];
                pos[2] = xyz[3*ipnt+2];

                status = EG_invEvaluate(MODL->body[ibody].face[iface].eface,
                                        pos, data, result);
                CHECK_STATUS(EG_invEvaluate);

                uv[2*ipnt  ] = data[0];
                uv[2*ipnt+1] = data[1];
            }
        }

    /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetEgo - get the EGO associated with a Body or its parts       *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetEgo(void   *modl,                /* (in)  pointer to MODL */
           int    ibody,                /* (in)  Body index (1:nbody) */
           int    seltype,              /* (in)  OCSM_BODY, OCSM_NODE, OCSM_EDGE, or OCSM_FACE */
           int    iselect,              /* (in)  if OCSM_BODY, 0 for Body, 1 for Tessellation, 2 for context
                                                 3 for EBody, 4 for Tessellation on EBody */
                                        /*       if OCSM_NODE, Node index (1:nnode) */
                                        /*       if OCSM_EDGE, Edge index (1:nedge) */
                                        /*       if OCSM_FACE, Face index (1:nface) */
           ego    *theEgo)              /* (out) context or associated EGO */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       inode, iedge, iface;

    ROUTINE(ocsmGetEgo);

    /* --------------------------------------------------------------- */

    /* default return */
    *theEgo = NULL;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (seltype != OCSM_BODY || iselect != 2) {
        if (ibody < 1 || ibody > MODL->nbody) {
            status = OCSM_BODY_NOT_FOUND;
            goto cleanup;
        }
    }

    /* OCSM_BODY was prescribed */
    if        (seltype == OCSM_BODY) {
        if        (iselect == 0) {
            *theEgo = MODL->body[ibody].ebody;
        } else if (iselect == 1) {
            *theEgo = MODL->body[ibody].etess;
        } else if (iselect == 2) {
            *theEgo = MODL->context;
        } else if (iselect == 3) {
            *theEgo = MODL->body[ibody].eebody;
        } else if (iselect == 4) {
            *theEgo = MODL->body[ibody].eetess;
        } else {
            status = OCSM_ILLEGAL_ARGUMENT;
        }

    /* OCSM_NODE was prescribed */
    } else if (seltype == OCSM_NODE) {
        inode = iselect;

        if (inode < 1  || inode > MODL->body[ibody].nnode) {
            status = OCSM_NODE_NOT_FOUND;
        } else {
            *theEgo = MODL->body[ibody].node[inode].enode;
        }

    /* OCSM_EDGE was prescribed */
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 1  || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
        } else {
            *theEgo = MODL->body[ibody].edge[iedge].eedge;
        }

    /* OCSM_FACE was prescribed */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 1  || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
        } else {
            *theEgo = MODL->body[ibody].face[iface].eface;
        }

    /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
    }

cleanup:

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetEgo - set a tessellation or EBody for a Body                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetEgo(void   *modl,                /* (in)  pointer to MODL */
           int    ibody,                /* (in)  Body index (1:nbody) */
           int    iselect,              /* (in)  1 for Tessellation,
                                                 3 for EBody, 4 for Tessellation on EBody */
           ego    theEgo)               /* (in)  associated EGO */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetEgo);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_BODY_NOT_FOUND;
        goto cleanup;
    }

    /* tessellation */
    if (iselect == 1) {
        status = removeVels(MODL, ibody);
        CHECK_STATUS(removeVels);

        if (MODL->body[ibody].etess != NULL) {
            status = EG_deleteObject(MODL->body[ibody].etess);
            CHECK_STATUS(EG_deleteObject);
        }

        MODL->body[ibody].etess = theEgo;

    /* EBody */
    } else if (iselect == 3) {
        if (MODL->body[ibody].eetess != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eetess);
            CHECK_STATUS(EG_deleteObject);
        }

        if (MODL->body[ibody].eebody != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eebody);
            CHECK_STATUS(EG_deleteObject);
        }

        MODL->body[ibody].eebody = theEgo;

    /* tessellation on EBody */
    } else if (iselect == 4) {
        status = removeVels(MODL, ibody);
        CHECK_STATUS(removeVels);

        if (MODL->body[ibody].eetess != NULL) {
            status = EG_deleteObject(MODL->body[ibody].eetess);
            CHECK_STATUS(EG_deleteObject);
        }

        MODL->body[ibody].eetess = theEgo;

    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
    }
cleanup:

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmFindEnt - find the entity number given FaceID or edgeID        *
 *                                                                      *
 ************************************************************************
 */

int
ocsmFindEnt(void   *modl,               /* (in)  pointer to MODL */
            int    ibody,               /* (in)  Body index (1:nbody) */
            int    seltype,             /* (in)  OCSM_EDGE or OCSM_FACE */
            int    entID[],             /* (in)  edgeID or faceID */
            int    *ient)               /* (out) entity number */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iedge, iface, itype, nlist;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;

    ROUTINE(ocsmFindEnt);

    /* --------------------------------------------------------------- */

    /* default return */
    *ient = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* OCSM_EDGE was prescribed */
    if (seltype == OCSM_EDGE) {
        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge,
                                     "_edgeID", &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == EGADS_SUCCESS && itype == ATTRINT && nlist == 5) {
                if (entID[0] == tempIlist[0] &&
                    entID[1] == tempIlist[1] &&
                    entID[2] == tempIlist[2] &&
                    entID[3] == tempIlist[3] &&
                    entID[4] == tempIlist[4]   ) {
                    *ient = iedge;
                    goto cleanup;
                }
            }
        }

        status = OCSM_EDGE_NOT_FOUND;

    /* OCSM_FACE was prescribed */
    } else if (seltype == OCSM_FACE) {
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_attributeRet(MODL->body[ibody].face[iface].eface,
                                     "_faceID", &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == EGADS_SUCCESS && itype == ATTRINT && nlist == 3) {
                if (entID[0] == tempIlist[0] &&
                    entID[1] == tempIlist[1] &&
                    entID[2] == tempIlist[2]   ) {
                    *ient = iface;
                    goto cleanup;
                }
            }
        }

        status = OCSM_FACE_NOT_FOUND;

    /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetXYZ - get the coordinates on a Node, Edge, or Face          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetXYZ(void   *modl,                /* (in)  pointer to MODL */
           int    ibody,                /* (in)  Body index (1:nbody) */
           int    seltype,              /* (in)  OCSM_NODE, OCSM_EDGE, or OCSM_FACE */
           int    iselect,              /* (in)  Node, Edge, or Face index (1:nent) */
           int    npnt,                 /* (in)  number of points */
 /*@null@*/double uv[],                 /* (in)  para coords (NULL, 1*npnt, or 2*npnt in length) */
           double xyz[])                /* (out) coordinates (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       inode, iedge, iface, ipnt, npnt_tess, ntri_tess;
    CINT      *ptype, *pindx, *tris, *tric;
    double    params[2], data[18];
    CDOUBLE   *xyz_tess, *uv_tess;

    ROUTINE(ocsmGetXYZ);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* OCSM_NODE was prescribed */
    if (seltype == OCSM_NODE) {
        inode = iselect;

        if (inode < 1 || inode > MODL->body[ibody].nnode) {
            status = OCSM_NODE_NOT_FOUND;
            goto cleanup;
        }

        xyz[0] = MODL->body[ibody].node[inode].x;
        xyz[1] = MODL->body[ibody].node[inode].y;
        xyz[2] = MODL->body[ibody].node[inode].z;

    /* OCSM_EDGE was prescribed */
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        if (uv == NULL) {
            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt_tess, &xyz_tess, &uv_tess);
            CHECK_STATUS(EG_getTessEdge);

            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                params[0] = uv_tess[ipnt];

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                     params, data);
                CHECK_STATUS(EG_evaluate);

                xyz[3*ipnt  ] = data[0];
                xyz[3*ipnt+1] = data[1];
                xyz[3*ipnt+2] = data[2];
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                params[0] = uv[ipnt];

                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                     params, data);
                CHECK_STATUS(EG_evaluate);

                xyz[3*ipnt  ] = data[0];
                xyz[3*ipnt+1] = data[1];
                xyz[3*ipnt+2] = data[2];
            }
        }

    /* OCSM_FACE was prescribed */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 1 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        if (uv == NULL) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                    &ntri_tess, &tris, &tric);
            CHECK_STATUS(EG_getFaceTess);

            for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
                params[0] = uv_tess[2*ipnt  ];
                params[1] = uv_tess[2*ipnt+1];

                status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                     params, data);
                CHECK_STATUS(EG_evaluate);

                xyz[3*ipnt  ] = data[0];
                xyz[3*ipnt+1] = data[1];
                xyz[3*ipnt+2] = data[2];
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                params[0] = uv[2*ipnt  ];
                params[1] = uv[2*ipnt+1];

                status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                     params, data);
                CHECK_STATUS(EG_evaluate);

                xyz[3*ipnt  ] = data[0];
                xyz[3*ipnt+1] = data[1];
                xyz[3*ipnt+2] = data[2];
            }
        }

    /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetNorm - get the unit normals for a Face                      *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetNorm(void   *modl,               /* (in)  pointer to MODL */
            int    ibody,               /* (in)  Body index (1:nbody) */
            int    iface,               /* (in)  Face index (1:nface) */
            int    npnt,                /* (in)  number of points */
  /*@null@*/double uv[],                /* (in)  para coords (NULL or 2*npnt in length) */
            double norm[])              /* (out) normals (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ipnt, oclass, mtype, nchild, *senses, npnt_tess, ntri_tess;
    CINT      *ptype, *pindx, *tris, *tric;
    double    uvlims[4], data[18], anorm[4];
    CDOUBLE   *uv_tess, *xyz_tess;
    ego       eref, *echilds;

    ROUTINE(ocsmGetNorm);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* check for valid Face */
    if (iface < 1 || iface > MODL->body[ibody].nface) {
        status = OCSM_FACE_NOT_FOUND;
        goto cleanup;
    }

    /* get info about eface */
    status = EG_getTopology(MODL->body[ibody].face[iface].eface, &eref,
                            &oclass, &mtype, uvlims, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    /* return normals at tessellation points */
    if (uv == NULL) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                &ntri_tess, &tris, &tric);
        CHECK_STATUS(EG_getFaceTess);

        for (ipnt = 0; ipnt < npnt_tess; ipnt++) {
            status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                 &(uv_tess[2*ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            anorm[0] = data[4] * data[8] - data[5] * data[7];
            anorm[1] = data[5] * data[6] - data[3] * data[8];
            anorm[2] = data[3] * data[7] - data[4] * data[6];
            anorm[3] = mtype * sqrt(anorm[0]*anorm[0] + anorm[1]*anorm[1] + anorm[2]*anorm[2]);

            norm[3*ipnt  ] = anorm[0] / anorm[3];
            norm[3*ipnt+1] = anorm[1] / anorm[3];
            norm[3*ipnt+2] = anorm[2] / anorm[3];
        }

    /* return normals at specified points */
    } else {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                 &(uv[2*ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            anorm[0] = data[4] * data[8] - data[5] * data[7];
            anorm[1] = data[5] * data[6] - data[3] * data[8];
            anorm[2] = data[3] * data[7] - data[4] * data[6];
            anorm[3] = mtype * sqrt(anorm[0]*anorm[0] + anorm[1]*anorm[1] + anorm[2]*anorm[2]);

            norm[3*ipnt  ] = anorm[0] / anorm[3];
            norm[3*ipnt+1] = anorm[1] / anorm[3];
            norm[3*ipnt+2] = anorm[2] / anorm[3];
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetVel - get the velocities of coordinates on a Node, Edge, or Face *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetVel(void   *modl,                /* (in)  pointer to MODL */
           int    ibody,                /* (in)  Body index (1:nbody) */
           int    seltype,              /* (in)  OCSM_NODE, OCSM_EDGE, or OCSM_FACE */
           int    iselect,              /* (in)  Node, Edge, or Face index (1:nent) */
           int    npnt,                 /* (in)  number of points */
 /*@null@*/double uv[],                 /* (in)  para coords
                                                    NULL           for OCSM_NODE
                                                    NULL or 1*npnt for OCSM_EDGE
                                                    NULL or 2*npnt for OCSM_FACE */
           double vel[])                /* (out) velocities (in pre-allocated array)
                                                    3      for OCSM_NODE
                                                    3*npnt for OCSM_EDGE
                                                    3*npnt for OCSM_FACE */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface, ipnt, npnt_tess, ntri_tess;
    CINT      *ptype, *pindx, *tris, *tric;
    double    *dxyz=NULL;
    double    params[2], data[18], TdotT, VdotT, normx, normy, normz, norm, dotp;
    CDOUBLE   *xyz_tess, *uv_tess;

    int       needge, ieedge, neface, ieface, oclass, mtype;
    double    t_edge, t_eedge, vel_edge[3], uv_face[2], uv_eface[2], vel_face[3];
    ego       *eeedges=NULL, eedge, *eefaces=NULL, eface, topRef, prev, next;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetVel);

    /* --------------------------------------------------------------- */

#if PRINT_CALLHISTORY > 0
    for (i_callHistory = 0; i_callHistory < indent_callHistory; i_callHistory++) fprintf(fp_callHistory, ".  ");
    fprintf(fp_callHistory, "ocsmGetVel(ibody=%2d, seltype=%3d, iselect=%3d\n", ibody, seltype, iselect);
    indent_callHistory++;
#endif

    SPRINT3(2, "ocsmGetVel(ibody=%d, seltype=%s, iselect=%d)", ibody, ocsmGetText(seltype), iselect);

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* default return */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        vel[3*ipnt  ] = 0;
        vel[3*ipnt+1] = 0;
        vel[3*ipnt+2] = 0;
    }

    /* a tessellation is needed if an Edge or Face and uv is not given */
    if ((seltype == OCSM_EDGE || seltype == OCSM_FACE) &&
        uv == NULL && MODL->body[ibody].etess == NULL    ) {
        status = ocsmTessellate(MODL, ibody);
        CHECK_STATUS(ocsmTessellate);
    }

    if ((seltype == OCSM_EEDGE || seltype == OCSM_EFACE) &&
        uv==NULL && MODL->body[ibody].eetess == NULL        ) {
        printf("WE SHOULD NOT GET HERE 6\n");
        exit(0);
    }

    status = setupForFiniteDifferences(MODL);
    CHECK_STATUS(setupForFiniteDifferences);

    /* if there was a problem with the previous attempt to create
       a perturbation, then return vel=0 */
    if (MODL->dtime == -2) {
        SPRINT0(2, "    returning vel=0 because there was a problem creating the perturbation");

        if        (seltype == OCSM_NODE) {
            vel[0] = 0;
            vel[1] = 0;
            vel[2] = 0;
        } else if (seltype == OCSM_EDGE) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                vel[3*ipnt  ] = 0;
                vel[3*ipnt+1] = 0;
                vel[3*ipnt+2] = 0;
            }
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                vel[ipnt] = 0;
            }
        }
        goto cleanup;
    }

    /* OCSM_NODE was prescribed */
    if (seltype == OCSM_NODE) {
        inode = iselect;

        if (inode < 1 || inode > MODL->body[ibody].nnode) {
            status = OCSM_NODE_NOT_FOUND;
            goto cleanup;
        }

        if (npnt != 1) {
            status = OCSM_ILLEGAL_ARGUMENT;
            goto cleanup;
        }

        status = velocityOfNode(MODL, ibody, inode, vel);
        CHECK_STATUS(velocityOfNode);

    /* OCSM_EDGE was prescribed */
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        /* check for degenerate Edge */
        if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                vel[3*ipnt  ] = 0;
                vel[3*ipnt+1] = 0;
                vel[3*ipnt+2] = 0;
            }

            goto cleanup;
        }

        MALLOC(dxyz, double, 3*npnt);

        status = velocityOfEdge(MODL, ibody, iedge, npnt, uv, dxyz);
        CHECK_STATUS(velocityOfEdge);

        /* return normal component */
        if (uv != NULL) {
            uv_tess = uv;
        } else {
            if (MODL->body[ibody].etess == NULL) {
                status = OCSM_NEED_TESSELLATION;
                goto cleanup;
            }

            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt_tess, &xyz_tess, &uv_tess);
            CHECK_STATUS(EG_getTessEdge);

            if (npnt_tess != npnt) {
                status = OCSM_ILLEGAL_ARGUMENT;
                goto cleanup;
            }
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            params[0] = uv_tess[ipnt];
            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                 params, data);
            CHECK_STATUS(EG_evaluate);

            TdotT = data[       3] * data[3] + data[       4] * data[4] + data[       5] * data[5];
            VdotT = dxyz[3*ipnt  ] * data[3] + dxyz[3*ipnt+1] * data[4] + dxyz[3*ipnt+2] * data[5];

            if (fabs(TdotT) > EPS12) {
                vel[3*ipnt  ] = dxyz[3*ipnt  ] - VdotT * data[3] / TdotT;
                vel[3*ipnt+1] = dxyz[3*ipnt+1] - VdotT * data[4] / TdotT;
                vel[3*ipnt+2] = dxyz[3*ipnt+2] - VdotT * data[5] / TdotT;
            } else {
                vel[3*ipnt  ] = dxyz[3*ipnt  ];
                vel[3*ipnt+1] = dxyz[3*ipnt+1];
                vel[3*ipnt+2] = dxyz[3*ipnt+2];
            }
        }

    /* OCSM_FACE was prescribed */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 1 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        status = velocityOfFace(MODL, ibody, iface, npnt, uv, vel);
        CHECK_STATUS(velocityOfFace);

        /* return normal component */
        if (uv != NULL) {
            uv_tess = uv;
        } else {
            if (MODL->body[ibody].etess == NULL) {
                status = OCSM_NEED_TESSELLATION;
                goto cleanup;
            }

            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                    &ntri_tess, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            if (npnt_tess != npnt) {
                status = OCSM_ILLEGAL_ARGUMENT;
                goto cleanup;
            }
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            params[0] = uv_tess[2*ipnt  ];
            params[1] = uv_tess[2*ipnt+1];
            status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                 params, data);
            CHECK_STATUS(EG_evaluate);

            normx = data[4] * data[8] - data[5] * data[7];
            normy = data[5] * data[6] - data[3] * data[8];
            normz = data[3] * data[7] - data[4] * data[6];
            norm  = normx * normx         + normy * normy         + normz * normz;
            dotp  = normx * vel[3*ipnt  ] + normy * vel[3*ipnt+1] + normz * vel[3*ipnt+2];

            if (fabs(norm) > EPS12) {
                vel[3*ipnt  ] = normx / norm * dotp;
                vel[3*ipnt+1] = normy / norm * dotp;
                vel[3*ipnt+2] = normz / norm * dotp;
            }
        }

    /* OCSM_EEDGE was prescribed */
    } else if (seltype == OCSM_EEDGE) {
        ieedge = iselect;

        if (MODL->body[ibody].eebody == NULL) {
            status = OCSM_EBODY_NOT_FOUND;
            goto cleanup;
        }

        status = EG_getBodyTopos(MODL->body[ibody].eebody, NULL, EEDGE, &needge, &eeedges);
        CHECK_STATUS(EG_getBodyTopos);

        if (ieedge < 1 || ieedge > needge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        SPLINT_CHECK_FOR_NULL(eeedges);

        status = EG_getTessEdge(MODL->body[ibody].eetess, ieedge,
                                &npnt_tess, &xyz_tess, &uv_tess);
        CHECK_STATUS(EG_getTessEdge);

        /* check for degenerate Edge */
        status = EG_getInfo(eeedges[ieedge-1], &oclass, &mtype, &topRef, &prev, &next);
        CHECK_STATUS(EG_getInfo);

        if (mtype == DEGENERATE) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                vel[3*ipnt  ] = 0;
                vel[3*ipnt+1] = 0;
                vel[3*ipnt+2] = 0;
            }

            goto cleanup;
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {

            /* get the t in the EEdge */
            if (uv != NULL) {
                t_eedge = uv[ipnt];
            } else {
                t_eedge = uv_tess[ipnt];
            }

            /* map to the t in the underlying Edge */
            status = EG_effectiveMap(eeedges[ieedge-1], &t_eedge, &eedge, &t_edge);
            CHECK_STATUS(EG_effectiveMap);

            iedge = status = EG_indexBodyTopo(MODL->body[ibody].ebody, eedge);
            CHECK_STATUS(EG_indexBodyTopo);

            /* get the velocity in the underlying Edge */
            status = velocityOfEdge(MODL, ibody, iedge, 1, &t_edge, vel_edge);
            CHECK_STATUS(velocityOfEdge);

            /* return normal component */
            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, &t_edge, data);
            CHECK_STATUS(EG_evaluate);

            TdotT = data[    3] * data[3] + data[    4] * data[4] + data[    5] * data[5];
            VdotT = vel_edge[0] * data[3] + vel_edge[1] * data[4] + vel_edge[2] * data[5];

            if (fabs(TdotT) > EPS12) {
                vel[3*ipnt  ] = vel_edge[0] - VdotT * data[3] / TdotT;
                vel[3*ipnt+1] = vel_edge[1] - VdotT * data[4] / TdotT;
                vel[3*ipnt+2] = vel_edge[2] - VdotT * data[5] / TdotT;
            } else {
                vel[3*ipnt  ] = vel_edge[0];
                vel[3*ipnt+1] = vel_edge[1];
                vel[3*ipnt+2] = vel_edge[2];
            }
        }

    /* OCSM_EFACE was prescribed */
    } else if (seltype == OCSM_EFACE) {
        ieface = iselect;

        if (MODL->body[ibody].eebody == NULL) {
            status = OCSM_EBODY_NOT_FOUND;
            goto cleanup;
        }

        status = EG_getBodyTopos(MODL->body[ibody].eebody, NULL, EFACE, &neface, &eefaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (ieface < 1 || ieface > neface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        SPLINT_CHECK_FOR_NULL(eefaces);

        status = EG_getTessFace(MODL->body[ibody].eetess, ieface,
                                &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                &ntri_tess, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (ipnt = 0; ipnt < npnt; ipnt++) {

            /* get the uv in the EFace */
            if (uv != NULL) {
                uv_eface[0] = uv[2*ipnt  ];
                uv_eface[1] = uv[2*ipnt+1];
            } else {
                uv_eface[0] = uv_tess[2*ipnt  ];
                uv_eface[1] = uv_tess[2*ipnt+1];
            }

            /* map to the uv in the underlying Face */
            status = EG_effectiveMap(eefaces[ieface-1], uv_eface, &eface, uv_face);
            CHECK_STATUS(EG_effectiveMap);

            iface = status = EG_indexBodyTopo(MODL->body[ibody].ebody, eface);
            CHECK_STATUS(EG_indexBodyTopo);

            /* get the velocity in the underlying Face */
            status = velocityOfFace(MODL, ibody, iface, 1, uv_face, vel_face);
            CHECK_STATUS(velocityOfFace);

            /* return normal component */
            status = EG_evaluate(MODL->body[ibody].face[iface].eface, uv_face, data);
            CHECK_STATUS(EG_evaluate);

            normx = data[4] * data[8] - data[5] * data[7];
            normy = data[5] * data[6] - data[3] * data[8];
            normz = data[3] * data[7] - data[4] * data[6];
            norm  = normx * normx       + normy * normy       + normz * normz;
            dotp  = normx * vel_face[0] + normy * vel_face[1] + normz * vel_face[2];

            if (fabs(norm) > EPS12) {
                vel[3*ipnt  ] = normx / norm * dotp;
                vel[3*ipnt+1] = normy / norm * dotp;
                vel[3*ipnt+2] = normz / norm * dotp;
            }
        }

    /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
#if PRINT_CALLHISTORY > 0
    indent_callHistory--;
#endif

    if (eeedges != NULL) EG_free(eeedges);
    if (eefaces != NULL) EG_free(eefaces);

    FREE(dxyz);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmSetEgg - set up alternative tessellation by external generator *
 *                                                                      *
 ************************************************************************
 */

int
ocsmSetEgg(void   *modl,                /* (in)  pointer to MODL */
           char   *eggname)             /* (in)  name of dynamically-loadable file */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nlen;
    char      *fullname=NULL;
    DLL       dll;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmSetEgg);

    /* --------------------------------------------------------------- */

    /* return immediately if not egg was specified */
    if (STRLEN(eggname) == 0) {
        goto cleanup;
    }

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* store the external grid genertor name */
    /*@ignore@*/
    STRNCPY(MODL->eggname, eggname, MAX_FILENAME_LEN);
    /*@end@*/

    /* open the dynamically loaded library */
    nlen = STRLEN(eggname) + 5;
    MALLOC(fullname, char, nlen);

    strcpy(fullname, eggname);

    /*@ignore@*/
#ifdef WIN32
    strcat(fullname, ".DLL");
    dll = LoadLibrary(fullname);
#else
    strcat(fullname, ".so");
    dll = dlopen(fullname, RTLD_NOW /* RTLD_LAZY */);
#endif
    /*@end@*/

    if (!dll) {
        signalError(MODL, OCSM_FILE_NOT_FOUND,
                    "DLL \"%s\" not found", fullname);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* get the symbols from the library */
#ifdef WIN32
    MODL->eggGenerate = (eggGenerate_H) GetProcAddress(dll, "eggGenerate");
    MODL->eggMorph    = (eggMorph_H   ) GetProcAddress(dll, "eggMorph"   );
    MODL->eggInfo     = (eggInfo_H    ) GetProcAddress(dll, "eggInfo"    );
    MODL->eggDump     = (eggDump_H    ) GetProcAddress(dll, "eggDump"    );
    MODL->eggLoad     = (eggLoad_H    ) GetProcAddress(dll, "eggLoad"    );
    MODL->eggFree     = (eggFree_H    ) GetProcAddress(dll, "eggFree"    );
#else
    MODL->eggGenerate = dlsym(dll, "eggGenerate");
    MODL->eggMorph    = dlsym(dll, "eggMorph"   );
    MODL->eggInfo     = dlsym(dll, "eggInfo"    );
    MODL->eggDump     = dlsym(dll, "eggDump"    );
    MODL->eggLoad     = dlsym(dll, "eggLoad"    );
    MODL->eggFree     = dlsym(dll, "eggFree"    );
#endif

    if        (MODL->eggGenerate == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggGenerate not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggMorph    == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggMorph not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggInfo     == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggInfo not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggDump     == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggDump not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggLoad     == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggLoad not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    } else if (MODL->eggFree     == NULL) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "eggFree not found in %s", fullname);
        status = OCSM_INTERNAL_ERROR;
    }

cleanup:
    FREE(fullname);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetTessNpnt - get the number of tess points on an Edge or Face *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetTessNpnt(void   *modl,           /* (in)  pointer to MODL */
                int    ibody,           /* (in)  Body index (1:nbody) */
                int    seltype,         /* (in)  OCSM_EDGE or OCSM_FACE */
                int    iselect,         /* (in)  Edges or Face index (1:nent) */
                int    *npnt)           /* (out) number of points */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iedge, iface, ntri;
    CINT      *ptype, *pindx, *tris, *tric;
    CDOUBLE   *xyz, *t, *uv;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetTessNpnt);

    /* --------------------------------------------------------------- */

    /* default return */
    *npnt = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* OCSM_EDGE */
    if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                npnt, &xyz, &t);
        CHECK_STATUS(EG_getTessEdge);

    /* OCSM_FACE */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 1 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                npnt, &xyz, &uv, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace)

    /* bad seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetTessVel - get the tessellation velocities on Node, Edge, or Face *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetTessVel(void   *modl,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (1:nbody) */
               int    seltype,          /* (in)  OCSM_NODE, OCSM_EDGE, or OCSM_FACE */
               int    iselect,          /* (in)  Node, Edges, or Face index (1:nent) */
               CDOUBLE *dxyz[])         /* (out) pointer to storage containing velocities */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetTessVel);

    /* --------------------------------------------------------------- */

    SPRINT3(2, "enter ocsmGetTessVel(ibody=%d, seltype=%s, iselect=%d)",
            ibody, ocsmGetText(seltype), iselect);

    /* default return */
    *dxyz = NULL;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    status = setupForFiniteDifferences(MODL);
    CHECK_STATUS(setupForFiniteDifferences);

    /* get tessellation velocities if not already in memory */
    if (MODL->body[ibody].node[1].dxyz == NULL) {
        status = createTessVels(MODL, ibody);
        CHECK_STATUS(createTessVels);
    }

    /* OCSM_NODE */
    if (seltype == OCSM_NODE) {
        inode = iselect;

        if (inode < 1 || inode > MODL->body[ibody].nnode) {
            status = OCSM_NODE_NOT_FOUND;
            goto cleanup;
        }

        *dxyz = MODL->body[ibody].node[inode].dxyz;

    /* OCSM_EDGE */
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
            status = OCSM_EDGE_NOT_FOUND;
            goto cleanup;
        }

        *dxyz = MODL->body[ibody].edge[iedge].dxyz;

    /* OCSM_FACE */
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (iface < 1 || iface > MODL->body[ibody].nface) {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

        *dxyz = MODL->body[ibody].face[iface].dxyz;

    /* OCSM_EEDGE */
    } else if (seltype == OCSM_EEDGE) {
        iedge = iselect;

        if (MODL->body[ibody].eebody == NULL) {
            status = OCSM_EBODY_NOT_FOUND;
            goto cleanup;
        }

        *dxyz = MODL->body[ibody].edge[iedge].dxyz;

    /* OCSM_EFACE */
    } else if (seltype == OCSM_EFACE) {
        iface = iselect;

        if (MODL->body[ibody].eebody == NULL) {
            status = OCSM_EBODY_NOT_FOUND;
            goto cleanup;
        }

        *dxyz = MODL->body[ibody].face[iface].dxyz;

    /* bad seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetBody - get info about a Body                                *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetBody(void   *modl,               /* (in)  pointer to MODL */
            int    ibody,               /* (in)  Body index (1:nbody) */
            int    *type,               /* (out) Branch type */
            int    *ichld,              /* (out) ibody of child (or 0 if root) */
            int    *ileft,              /* (out) ibody of left parent (or 0) */
            int    *irite,              /* (out) ibody of rite parent (or 0) */
            double vals[],              /* (out) array  of Arguments (at least 10 long) */
            int    *nnode,              /* (out) number of Nodes */
            int    *nedge,              /* (out) number of Edges */
            int    *nface)              /* (out) number of Faces */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ibrch, iarg;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmGetBody);

    /* --------------------------------------------------------------- */

    /* default return values */
    *type  = 0;
    *ichld = 0;
    *ileft = 0;
    *irite = 0;
    *nnode = 0;
    *nedge = 0;
    *nface = 0;

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    ibrch = MODL->body[ibody].ibrch;

    /* return pertinent information */
    *type   = MODL->body[ibody].brtype;
    *ichld  = MODL->body[ibody].ichld;
    *ileft  = MODL->body[ibody].ileft;
    *irite  = MODL->body[ibody].irite;

    vals[0] = 0;
    for (iarg = 1; iarg < 10; iarg++) {
        if (iarg <= MODL->brch[ibrch].narg) {
            vals[iarg] = MODL->body[ibody].arg[iarg].val[0];
        } else {
            vals[iarg] = 0;
        }
    }

    *nnode  = MODL->body[ibody].nnode;
    *nedge  = MODL->body[ibody].nedge;
    *nface  = MODL->body[ibody].nface;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintBodys - print all Bodys to file                           *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintBodys(void   *modl,            /* (in)  pointer to MODL */
               char   filename[])       /* (in)  file to which output is appended (or "" for stdout) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ibody, iarg, oclass, mtype, nchild, *senses;
    double    data[4], CPU=0;
    ego       eref, *echilds;
    FILE      *fp=NULL;

    ROUTINE(ocsmPrintBodys);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    if (strlen(filename) == 0) {
        fp = stdout;
    } else {
        fp = fopen(filename, "a");
        if (fp == NULL) {
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }
    }

    /* return message if no Bodys */
    if (MODL->nbody <= 0) {
        fprintf(fp, "    --none--\n");
        goto cleanup;
    }

    /* print Body table */
    fprintf(fp, "    ibody  ibrch brchType  ileft irite ichld group      CPU nnode nedge nface   bodyType     args ...\n");
    for (ibody = 1; ibody <= MODL->nbody; ibody++) {
        if (MODL->body[ibody].onstack == 1) {
            fprintf(fp, "    %5d*", ibody);
        } else {
            fprintf(fp, "    %5d ", ibody);
        }

        fprintf(fp, " %5d %-9s %5d %5d %5d %5d %8.3f %5d %5d %5d %10s ",
                MODL->body[ibody].ibrch,
                ocsmGetText(MODL->body[ibody].brtype),
                MODL->body[ibody].ileft,
                MODL->body[ibody].irite,
                MODL->body[ibody].ichld,
                MODL->body[ibody].igroup,
                MODL->body[ibody].CPU,
                MODL->body[ibody].nnode,
                MODL->body[ibody].nedge,
                MODL->body[ibody].nface,
                ocsmGetText(MODL->body[ibody].botype));

        for (iarg = 1; iarg < 10; iarg++) {
            if        (MODL->body[ibody].arg[iarg].nval == 0) {
                fprintf(fp, "%8.8s ", MODL->body[ibody].arg[iarg].str);
            } else if (MODL->body[ibody].arg[iarg].nval == 1) {
                fprintf(fp, "%8.3f ", MODL->body[ibody].arg[iarg].val[0]);
            } else if (MODL->body[ibody].arg[iarg].nval >  1) {
                fprintf(fp, " [%3d*1] ", MODL->body[ibody].arg[iarg].nval);
            } else {
                break;
            }
        }

        fprintf(fp, "\n");

        CPU += MODL->body[ibody].CPU;

        /* check that to Bodys are actually the right type */
        if        (MODL->body[ibody].botype == OCSM_WIRE_BODY) {
            status = EG_getTopology(MODL->body[ibody].ebody, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (oclass != BODY || mtype != WIREBODY) {
                status = OCSM_INTERNAL_ERROR;
                signalError(MODL, status,
                            "bodyType mismatch: oclass=%d, mtype=%d (expecting 25, 6)", oclass, mtype);
                goto cleanup;
            }
        } else if (MODL->body[ibody].botype == OCSM_SHEET_BODY) {
            status = EG_getTopology(MODL->body[ibody].ebody, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (oclass != BODY || (mtype != FACEBODY && mtype != SHEETBODY)) {
                status = OCSM_INTERNAL_ERROR;
                signalError(MODL, status,
                            "bodyType mismatch: oclass=%d, mtype=%d (expecting 25, 7/8)", oclass, mtype);
                goto cleanup;
            }
        } else if (MODL->body[ibody].botype == OCSM_SOLID_BODY) {
            status = EG_getTopology(MODL->body[ibody].ebody, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (oclass != BODY || mtype != SOLIDBODY) {
                status = OCSM_INTERNAL_ERROR;
                signalError(MODL, status,
                            "bodyType mismatch: oclass=%d, mtype=%d (expecting 25, 9)", oclass, mtype);
                goto cleanup;
            }
        }
    }

    fprintf(fp, "                                             total %8.3f\n", CPU);

cleanup:
    if (fp != NULL && strlen(filename) > 0) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintBrep - print BRep associated with a Body to file          *
 *                                                                      *
 ************************************************************************
 */

int
ocsmPrintBrep(void   *modl,             /* (in)  pointer to MODL */
              int    ibody,             /* (in)  Body index (1:nbody) */
              char   filename[])        /* (in)  file to which output is appended (or "" for stdout) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface, nattr, iattr, itype, nlist, i;
    int       nnode, nedge, nface, periodic;
    CINT      *tempIlist;
    double    range[4];
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist, *attrName;
    ego       *enodes, *eedges, *efaces;
    FILE      *fp=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmPrintBrep);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    if (strlen(filename) == 0) {
        fp = stdout;
    } else {
        fp = fopen(filename, "a");
        if (fp == NULL) {
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }
    }

    /* print Body info */
    fprintf(fp, "Body %4d\n", ibody);

    status = EG_attributeNum(MODL->body[ibody].ebody, &nattr);
    CHECK_STATUS(EG_attributeNum);

    for (iattr = 1; iattr <= nattr; iattr++) {
        status = EG_attributeGet(MODL->body[ibody].ebody, iattr,
                                 &attrName, &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeGet);

        fprintf(fp, "            %-20s =", attrName);
        if        (itype == ATTRINT) {
            for (i = 0; i < nlist; i++) {
                fprintf(fp, "%5d ", tempIlist[i]);
            }
        } else if (itype == ATTRREAL) {
            for (i = 0; i < nlist; i++) {
                fprintf(fp, "%11.5f ", tempRlist[i]);
            }
        } else if (itype == ATTRCSYS) {
            for (i = 0; i < nlist; i++) {
                fprintf(fp, "%11.5f ", tempRlist[i]);
            }
            fprintf(fp, "\n                                 =");
            for (i = nlist; i < nlist+12; i++) {
                fprintf(fp, "%11.5f ", tempRlist[i]);
            }
        } else if (itype == ATTRSTRING) {
            fprintf(fp, "%s", tempClist);
        }
        fprintf(fp, "\n");
    }

    /* loop through all Nodes */
    fprintf(fp, "    inode nedge ibody     x             y             z\n");
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        fprintf(fp, "    %5d %5d %5d %12.5f %12.5f %12.5f\n", inode,
                MODL->body[ibody].node[inode].nedge,
                MODL->body[ibody].node[inode].ibody,
                MODL->body[ibody].node[inode].x,
                MODL->body[ibody].node[inode].y,
                MODL->body[ibody].node[inode].z);

        fprintf(fp, "             Edges ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].node[inode].enode,
                                 EDGE, &nedge, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        if (eedges != NULL) {
            for (iedge = 0; iedge < nedge; iedge++) {
                fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, eedges[iedge]));
            }
            fprintf(fp, "\n");
            EG_free(eedges);
        }

        fprintf(fp, "             Faces ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].node[inode].enode,
                                 FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (efaces != NULL) {
            for (iface = 0; iface < nface; iface++) {
                fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, efaces[iface]));
            }
            fprintf(fp, "\n");
            EG_free(efaces);
        }

        status = EG_attributeNum(MODL->body[ibody].node[inode].enode, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(MODL->body[ibody].node[inode].enode, iattr,
                                     &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            fprintf(fp, "            %-20s =", attrName);
            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
                fprintf(fp, "\n                                 =");
                for (i = nlist; i < nlist+12; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                fprintf(fp, "%s", tempClist);
            }
            fprintf(fp, "\n");
        }
    }

    /* loop through all Edges */
    fprintf(fp, "    iedge  ibeg  iend ileft irite nface ibody iford imark trange\n");
    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, range, &periodic);
        CHECK_STATUS(EG_getRange);

        fprintf(fp, "    %5d %5d %5d %5d %5d %5d %5d %5d %5d %12.5f %12.5f\n", iedge,
                MODL->body[ibody].edge[iedge].ibeg,
                MODL->body[ibody].edge[iedge].iend,
                MODL->body[ibody].edge[iedge].ileft,
                MODL->body[ibody].edge[iedge].irite,
                MODL->body[ibody].edge[iedge].nface,
                MODL->body[ibody].edge[iedge].ibody,
                MODL->body[ibody].edge[iedge].iford,
                MODL->body[ibody].edge[iedge].imark, range[0], range[1]);

        fprintf(fp, "             Nodes ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].edge[iedge].eedge,
                                 NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);

        if (enodes != NULL) {
            for (inode = 0; inode < nnode; inode++) {
                fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, enodes[inode]));
            }
            fprintf(fp, "\n");
            EG_free(enodes);
        }

        fprintf(fp, "             Faces ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].edge[iedge].eedge,
                                 FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (efaces != NULL) {
            for (iface = 0; iface < nface; iface++) {
                fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, efaces[iface]));
            }
            fprintf(fp, "\n");
            EG_free(efaces);
        }

        status = EG_attributeNum(MODL->body[ibody].edge[iedge].eedge, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(MODL->body[ibody].edge[iedge].eedge, iattr,
                                     &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            fprintf(fp, "            %-20s =", attrName);
            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
                fprintf(fp, "\n                                 =");
                for (i = nlist; i < nlist+12; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                fprintf(fp, "%s", tempClist);
            }
            fprintf(fp, "\n");
        }
    }

    /* loop through all Faces */
    fprintf(fp, "    iface ibody iford imark uvrange\n");
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getRange(MODL->body[ibody].face[iface].eface, range, &periodic);
        CHECK_STATUS(EG_getRange);

        fprintf(fp, "    %5d %5d %5d %5d %12.5f %12.5f %12.5f %12.5f\n", iface,
                MODL->body[ibody].face[iface].ibody,
                MODL->body[ibody].face[iface].iford,
                MODL->body[ibody].face[iface].imark, range[0], range[1], range[2], range[3]);

        fprintf(fp, "             Nodes ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].face[iface].eface,
                                 NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);

        if (enodes != NULL) {
            for (inode = 0; inode < nnode; inode++) {
                fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, enodes[inode]));
            }
            fprintf(fp, "\n");
            EG_free(enodes);
        }

        fprintf(fp, "             Edges ->");
        status = EG_getBodyTopos(MODL->body[ibody].ebody, MODL->body[ibody].face[iface].eface,
                                 EDGE, &nedge, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        if (eedges != NULL) {
            for (iedge = 0; iedge < nedge; iedge++) {
                fprintf(fp, " %5d", EG_indexBodyTopo(MODL->body[ibody].ebody, eedges[iedge]));
            }
            fprintf(fp, "\n");
            EG_free(eedges);
        }

        status = EG_attributeNum(MODL->body[ibody].face[iface].eface, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = 1; iattr <= nattr; iattr++) {
            status = EG_attributeGet(MODL->body[ibody].face[iface].eface, iattr,
                                     &attrName, &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            fprintf(fp, "            %-20s =", attrName);
            if        (itype == ATTRINT) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%5d ", tempIlist[i]);
                }
            } else if (itype == ATTRREAL) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRCSYS) {
                for (i = 0; i < nlist; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
                fprintf(fp, "                                 =");
                for (i = nlist; i < nlist+12; i++) {
                    fprintf(fp, "%11.5f ", tempRlist[i]);
                }
            } else if (itype == ATTRSTRING) {
                fprintf(fp, "%s", tempClist);
            }
            fprintf(fp, "\n");
        }
    }

cleanup:
    if (fp != NULL && strlen(filename) > 0) fclose(fp);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmEvalExpr - evaluate an expression                              *
 *                                                                      *
 ************************************************************************
 */

int
ocsmEvalExpr(void   *modl,              /* (in)  pointer to MODL */
             char   expr[],             /* (in)  expression */
             double *value,             /* (out) value */
             double *dot,               /* (out) velocity */
             char   str[])              /* (out) value if string-valued (w/o leading $) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(ocsmEvalExpr);

    /* --------------------------------------------------------------- */

    /* default return */
    *value = 0;
    *dot   = 0;
    str[0] = '\0';

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* evaluate the expression */
    status = str2val(expr, MODL, value, dot, str);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmPrintEgo - print contents of an EGADS ego                      *
 *                                                                      *
 ************************************************************************
 */

void
ocsmPrintEgo(
   /*@null@*/ego    obj)                    /* (in)  ego to start */
{
    ego    eref0,    eref1,    eref2,    eref3,    eref4,   eref5,   eref6;
    int    oclass0,  oclass1,  oclass2,  oclass3,  oclass4, oclass5, oclass6;
    int    mtype0,   mtype1,   mtype2,   mtype3,   mtype4,  mtype5,  mtype6;
    int    nchild0,  nchild1,  nchild2,  nchild3,  nchild4, nchild5, nchild6;
    int    ichild0,  ichild1,  ichild2,  ichild3,  ichild4, ichild5;
    int    i, nheader, ndata;
    int    *header;
    double *data;
    double data0[4], data1[4], data2[4], data3[4], data4[4], data5[4], data6[4];
    ego    *ebodys0, *ebodys1, *ebodys2, *ebodys3, *ebodys4, *ebodys5, *ebodys6;
    int    *senses0, *senses1, *senses2, *senses3, *senses4, *senses5, *senses6;

    int    status, count=0, oclass, mtype;
    ego    topref, prev, next, refobj, context, prev1, next1, ergeom;

    int     nattr, iattr, itype, nlist, ilist;
    CINT    *tempIlist;
    CDOUBLE *tempRlist;
    CCHAR   *tempClist, *aname;

    /* names take from egadsTypes.h */
    char *classname[36] = {"contxt",       "transform",  "tessellation",  "nil",
                           "empty",        "reference",  "ERROR 6",       "ERROR 7",
                           "ERROR 8",      "ERROR 9",    "pcurve",        "curve",
                           "surface",      "ERROR 13",   "ERROR 14",      "ERROR 15",
                           "ERROR 16",     "ERROR 17",   "ERROR 18",      "ERROR 19",
                           "node",         "edge",       "loop",          "face",
                           "shell",        "body",       "model",         "ERROR 27",
                           "ERROR 28",     "ERROR 29",   "ERROR 30",      "eedge",
                           "eloopx",       "eface",      "eshell",        "ebody"};

    /* pcurves and curves */
    char *mtypename1[10] = {"ERROR 0",     "line",       "circle",        "ellipse",
                            "parabola",    "hyperbola",  "trimmed",       "bezier",
                            "bspline",     "offset"};

    /* surfaces */
    char *mtypename2[12] = {"ERROR 0",     "plane",      "spherical",     "cylindrical",
                            "revolution",  "toroidal",   "trimmed",       "bezier",
                            "bspline",     "offest",     "conical",       "extrusion"};

    /* faces */
    char *mtypename3[ 3] = {"sreverse",    "nomtype",    "sforward"};

    /* other topology */
    char *mtypename4[10] = {"nomtype",     "onenode",    "twonode",       "open",
                            "closed",      "degenerate", "wirebody",      "facebody",
                            "sheetbody",   "solidbody"};

    char mtypename[32];


    /* --------------------------------------------------------------- */

    if (obj == NULL) {
        SPRINT0(0, "NULL");
        return;
    }

    status = EG_getContext(obj, &context);
    if (status < 0) {
        SPRINT1(0, "EG_getContext -> status=%d", status);
    }

    status = EG_getInfo(obj, &oclass0, &mtype0, &topref, &prev, &next);
    if (status != EGADS_SUCCESS) {
        return;
    } else if (oclass0 == CURVE) {
        SPRINT2(0, "oclass=%s, mtype=%s", classname[oclass0], mtypename1[mtype0]);

        EG_getGeometry(obj, &oclass0, &mtype0, &eref0, &header, &data);

        if (mtype0 == LINE) {
            nheader = 0;
            ndata   = 6;
        } else if (mtype0 == CIRCLE) {
            nheader = 0;
            ndata   = 10;
        } else if (mtype0 == ELLIPSE) {
            nheader = 0;
            ndata   = 11;
        } else if (mtype0 == PARABOLA) {
            nheader = 0;
            ndata   = 10;
        } else if (mtype0 == HYPERBOLA) {
            nheader = 0;
            ndata   = 11;
        } else if (mtype0 == TRIMMED) {
            nheader = 0;
            ndata   = 2;
        } else if (mtype0 == OFFSET) {
            nheader = 0;
            ndata   = 4;
        } else if (mtype0 == BEZIER) {
            nheader = 3;
            ndata   = 3 * header[2];
            if (header[0]%4 == 0 || header[0]%4 == 2) ndata += header[2];
        } else if (mtype0 == BSPLINE) {
            nheader = 4;
            ndata   = header[3] + 3 * header[2];
            if (header[0]%4 == 2) ndata += header[2];
        } else {
            nheader = 0;
            ndata   = 0;
        }

        for (i = 0; i < nheader; i++) {
            SPRINT2(1, "         header[%2d] = %d", i, header[i]);
        }
        for (i = 0; i < ndata; i++) {
            SPRINT2(1, "           data[%2d] = %12.6f", i, data[i]);
        }

        if (header != NULL) EG_free(header);
        if (data   != NULL) EG_free(data  );

        return;
    } else if (oclass0 == PCURVE) {
        SPRINT2(0, "oclass=%s, mtype=%s", classname[oclass0], mtypename1[mtype0]);

        EG_getGeometry(obj, &oclass0, &mtype0, &eref0, &header, &data);

        if (mtype0 == LINE) {
            nheader = 0;
            ndata   = 4;
        } else if (mtype0 == CIRCLE) {
            nheader = 0;
            ndata   = 7;
        } else if (mtype0 == ELLIPSE) {
            nheader = 0;
            ndata   = 8;
        } else if (mtype0 == PARABOLA) {
            nheader = 0;
            ndata   = 7;
        } else if (mtype0 == HYPERBOLA) {
            nheader = 0;
            ndata   = 8;
        } else if (mtype0 == TRIMMED) {
            nheader = 0;
            ndata   = 2;
        } else if (mtype0 == OFFSET) {
            nheader = 0;
            ndata   = 1;
        } else if (mtype0 == BEZIER) {
            nheader = 3;
            ndata   = 2 * header[2];
            if (header[0]%4 == 0 || header[0]%4 == 2) ndata += header[2];
        } else if (mtype0 == BSPLINE) {
            nheader = 4;
            ndata   = header[3] + 2 * header[2];
            if (header[0]%4 == 0 || header[0]%4 == 2) ndata += header[3];
        } else {
            nheader = 0;
            ndata   = 0;
        }

        for (i = 0; i < nheader; i++) {
            SPRINT2(1, "         header[%2d] = %d", i, header[i]);
        }
        for (i = 0; i < ndata; i++) {
            SPRINT2(1, "           data[%2d] = %12.6f", i, data[i]);
        }

        if (header != NULL) EG_free(header);
        if (data   != NULL) EG_free(data  );

        return;
    } else if (oclass0 == SURFACE) {
        SPRINT2(0, "oclass=%s, mtype=%s", classname[oclass0], mtypename2[mtype0]);

        EG_getGeometry(obj, &oclass0, &mtype0, &eref0, &header, &data);

        if (mtype0 == PLANE) {
            nheader = 0;
            ndata   = 9;
        } else if (mtype0 == SPHERICAL) {
            nheader = 0;
            ndata   = 10;
        } else if (mtype0 == CONICAL) {
            nheader = 0;
            ndata   = 14;
        } else if (mtype0 == CYLINDRICAL) {
            nheader = 0;
            ndata   = 13;
        } else if (mtype0 == EXTRUSION) {
            nheader = 0;
            ndata   = 3;
        } else if (mtype0 == TOROIDAL) {
            nheader = 0;
            ndata   = 14;
        } else if (mtype0 == REVOLUTION) {
            nheader = 0;
            ndata   = 6;
        } else if (mtype0 == TRIMMED) {
            nheader = 0;
            ndata   = 4;
        } else if (mtype0 == OFFSET) {
            nheader = 0;
            ndata   = 1;
        } else if (mtype0 == BEZIER) {
            nheader = 5;
            ndata   = 3 * header[2] * header[4];
            if (header[0]%4 == 0 || header[0]%4 == 2) ndata += header[2] * header[4];
        } else if (mtype0 == BSPLINE) {
            nheader = 7;
            ndata   = header[3] + header[6] + 3 * header[2] * header[5];
            if (header[0]%8 == 2) ndata += header[2] * header[5];
        } else {
            nheader = 0;
            ndata   = 0;
        }

        for (i = 0; i < nheader; i++) {
            SPRINT2(1, "         header[%2d] = %d", i, header[i]);
        }
        for (i = 0; i < ndata; i++) {
            SPRINT2(1, "           data[%2d] = %12.6f", i, data[i]);
        }

        if (header != NULL) EG_free(header);
        if (data   != NULL) EG_free(data  );

        return;
    }

    status = EG_getTopology(obj, &eref0, &oclass0, &mtype0,
                            data0, &nchild0, &ebodys0, &senses0);
    if (status != EGADS_SUCCESS && status != EGADS_OUTSIDE) {
        EG_getInfo(obj, &oclass0, &mtype0, &topref, &prev, &next);
        nchild0 = -1;
        eref0   = topref;
    }

    if (oclass0 != NODE) {
        if (oclass0 == PCURVE || oclass0 == CURVE) {
            strcpy(mtypename, mtypename1[mtype0]);
        } else if (oclass0 == SURFACE) {
            strcpy(mtypename, mtypename2[mtype0]);
        } else if (oclass0 == FACE  || oclass0 == EFACE) {
            strcpy(mtypename, mtypename3[mtype0+1]);
        } else if (oclass0 == EDGE  || oclass0 == EEDGE  ||
                   oclass0 == LOOP  || oclass0 == ELOOPX ||
                   oclass0 == SHELL || oclass0 == ESHELL ||
                   oclass0 == BODY  || oclass0 == EBODY  ||
                   oclass0 == MODEL                        ) {
            strcpy(mtypename, mtypename4[mtype0]);
        } else {
            strcpy(mtypename, "");
        }

        if (oclass0 == EDGE || oclass0 == FACE) {
            status = EG_getGeometry(eref0, &oclass, &mtype, &ergeom, NULL, NULL);
            if (status != EGADS_SUCCESS) {
                oclass = 0;
                mtype  = 0;
            }
        } else {
            oclass = 0;
            mtype  = 0;
        }
        SPRINT8(0, "oclass0=%3d (%s)  mtype0=%3d (%s)  obj=%llx,  eref0=%llx (%d:%d)",
                oclass0, classname[oclass0], mtype0, mtypename, (long long)obj, (long long)eref0, oclass, mtype);

        if (oclass0 == EDGE || oclass0 == EEDGE) {
            SPRINT2(0, "< trange=%10.5f %10.5f", data0[0], data0[1]);
        } else if (oclass0 == LOOP || oclass0 == ELOOPX ||
                   oclass0 == FACE || oclass0 == EFACE    ) {
            SPRINT0x(0, "< senses=");
            for (i = 0; i < nchild0; i++) {
                SPRINT1x(0, "%2d ", senses0[i]);
            }
            SPRINT0(0, " ");
        }
    } else {
        SPRINT7(0, "oclass0=%3d (%s)  mtype0=%3d,  obj=%llx,  data0=%20.10e %20.10e %20.10e",
                oclass0, classname[oclass0], mtype0, (long long)obj, data0[0], data0[1], data0[2]);
    }

    if (outLevel >= 2) {
        (void) EG_attributeNum(obj, &nattr);
        for (iattr = 1; iattr <= nattr; iattr++) {
            (void) EG_attributeGet(obj, iattr, &aname, &itype, &nlist,
                                   &tempIlist, &tempRlist, &tempClist);
            SPRINT1x(2, "          %-20s :", aname);
            if (itype == ATTRINT) {
                for (ilist = 0; ilist < nlist; ilist++) {
                SPRINT1x(2, " %5d", tempIlist[ilist]);
                }
                SPRINT0(2, " ");
            } else if (itype == ATTRREAL) {
                for (ilist = 0; ilist < nlist; ilist++) {
                    SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                }
                SPRINT0(2, " ");
            } else if (itype == ATTRSTRING) {
            SPRINT1(2, "%s", tempClist);
            } else {
                SPRINT0(2, " ");
            }
        }
    }

    next = obj->tref;
    prev = NULL;
    while (next != NULL) {
        refobj = next->attrs;
        if (refobj != context) {
            count++;
            EG_getInfo(refobj, &oclass1, &mtype1, &topref, &prev1, &next1);
            SPRINT5(0, "< refcount=%2d, refobj=%llx  (oclass=%2d (%s) mtype=%2d)",
                    count, (long long)refobj, oclass1, classname[oclass1], mtype1);
        }
        prev = next;
        next = prev->blind;
    }

    if (oclass0 == MODEL) {                  // get possible TESSELLATION or EBODY in MODEL
        nchild0 = MAX(nchild0, mtype0);
    }

    for (ichild0 = 0; ichild0 < nchild0; ichild0++) {
        status = EG_getTopology(ebodys0[ichild0], &eref1, &oclass1, &mtype1,
                                data1, &nchild1, &ebodys1, &senses1);
        if (status != EGADS_SUCCESS) {
            EG_getInfo(ebodys0[ichild0], &oclass1, &mtype1, &topref, &prev, &next);
            nchild1 = -1;
            eref1   = topref;
        }

        if (oclass1 != NODE) {
            if (oclass1 == PCURVE || oclass1 == CURVE) {
                strcpy(mtypename, mtypename1[mtype1]);
            } else if (oclass1 == SURFACE) {
                strcpy(mtypename, mtypename2[mtype1]);
            } else if (oclass1 == FACE  || oclass1 == EFACE) {
                strcpy(mtypename, mtypename3[mtype1+1]);
            } else if (oclass1 == EDGE  || oclass1 == EEDGE  ||
                       oclass1 == LOOP  || oclass1 == ELOOPX ||
                       oclass1 == SHELL || oclass1 == ESHELL ||
                       oclass1 == BODY  || oclass1 == EBODY  ||
                       oclass1 == MODEL                        ) {
                strcpy(mtypename, mtypename4[mtype1]);
            } else if (oclass1 == TESSELLATION) {
                snprintf(mtypename, 31, "%d", mtype1);
            } else {
                strcpy(mtypename, "");
            }

            if (oclass1 == EDGE || oclass1 == FACE) {
                status = EG_getGeometry(eref1, &oclass, &mtype, &ergeom, NULL, NULL);
                if (status != EGADS_SUCCESS) {
                    oclass = 0;
                    mtype  = 0;
                }
            } else {
                oclass = 0;
                mtype  = 0;
            }
            SPRINT8(0, ". oclass1=%3d (%s)  mtype1=%3d (%s)  obj=%llx,  eref1=%llx (%d:%d)",
                    oclass1, classname[oclass1], mtype1, mtypename, (long long)(ebodys0[ichild0]), (long long)eref1, oclass, mtype);

            if (oclass1 == EDGE || oclass1 == EEDGE) {
                SPRINT2(0, ". < trange=%10.5f %10.5f", data1[0], data1[1]);
            } else if (oclass1 == LOOP || oclass1 == ELOOPX ||
                       oclass1 == FACE || oclass1 == EFACE    ) {
                SPRINT0x(0, ". < senses=");
                for (i = 0; i < nchild1; i++) {
                    SPRINT1x(0, "%2d ", senses1[i]);
                }
                SPRINT0(0, " ");
            }
        } else {
            SPRINT7(0, ". oclass1=%3d (%s)  mtype1=%3d,  obj=%llx,  data1=%20.10e %20.10e %20.10e",
                    oclass1, classname[oclass1], mtype1, (long long)(ebodys0[ichild0]), data1[0], data1[1], data1[2]);
        }

        if (outLevel >= 2) {
            (void) EG_attributeNum(ebodys0[ichild0], &nattr);
            for (iattr = 1; iattr <= nattr; iattr++) {
                (void) EG_attributeGet(ebodys0[ichild0], iattr, &aname, &itype, &nlist,
                                       &tempIlist, &tempRlist, &tempClist);
                SPRINT1x(2, "          %-20s :", aname);
                if (itype == ATTRINT) {
                    for (ilist = 0; ilist < nlist; ilist++) {
                        SPRINT1x(2, " %5d", tempIlist[ilist]);
                    }
                    SPRINT0(2, " ");
                } else if (itype == ATTRREAL) {
                    for (ilist = 0; ilist < nlist; ilist++) {
                        SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                    }
                    SPRINT0(2, " ");
                } else if (itype == ATTRSTRING) {
                    SPRINT1(2, "%s", tempClist);
                } else {
                    SPRINT0(2, " ");
                }
            }
        }

        for (ichild1 = 0; ichild1 < nchild1; ichild1++) {
            status = EG_getTopology(ebodys1[ichild1], &eref2, &oclass2, &mtype2,
                                    data2, &nchild2, &ebodys2, &senses2);
            if (status != EGADS_SUCCESS) {
                EG_getInfo(ebodys1[ichild1], &oclass2, &mtype2, &topref, &prev, &next);
                nchild2 = -1;
                eref2   = topref;
            }

            if (oclass2 != NODE) {
                if (oclass2 == PCURVE || oclass2 == CURVE) {
                    strcpy(mtypename, mtypename1[mtype2]);
                } else if (oclass2 == SURFACE) {
                    strcpy(mtypename, mtypename2[mtype2]);
                } else if (oclass2 == FACE  || oclass2 == EFACE) {
                    strcpy(mtypename, mtypename3[mtype2+1]);
                } else if (oclass2 == EDGE  || oclass2 == EEDGE  ||
                           oclass2 == LOOP  || oclass2 == ELOOPX ||
                           oclass2 == SHELL || oclass2 == ESHELL ||
                           oclass2 == BODY  || oclass2 == EBODY  ||
                           oclass2 == MODEL                        ) {
                    strcpy(mtypename, mtypename4[mtype2]);
                } else {
                    strcpy(mtypename, "");
                }

                if (oclass2 == EDGE || oclass2 == FACE) {
                    status = EG_getGeometry(eref2, &oclass, &mtype, &ergeom, NULL, NULL);
                    if (status != EGADS_SUCCESS) {
                        oclass = 0;
                        mtype  = 0;
                    }
                } else {
                    oclass = 0;
                    mtype  = 0;
                }
                SPRINT8(0, ". . oclass2=%3d (%s)  mtype2=%3d (%s)  obj=%llx,  eref2=%llx (%d:%d)",
                        oclass2, classname[oclass2], mtype2, mtypename, (long long)(ebodys1[ichild1]), (long long)eref2, oclass, mtype);

                if (oclass2 == EDGE || oclass2 == EEDGE) {
                    SPRINT2(0, ". . < trange=%10.5f %10.5f", data2[0], data2[1]);
                } else if (oclass2 == LOOP || oclass2 == ELOOPX ||
                           oclass2 == FACE || oclass2 == EFACE    ) {
                    SPRINT0x(0, ". . < senses=");
                    for (i=0; i < nchild2; i++) {
                        SPRINT1x(0, "%2d ", senses2[i]);
                    }
                    SPRINT0(0, " ");
                }
            } else {
                SPRINT7(0, ". . oclass2=%3d (%s)  mtype2=%3d,  obj=%llx,  data2=%20.10e %20.10e %20.10e",
                        oclass2, classname[oclass2], mtype2, (long long)(ebodys1[ichild1]), data2[0], data2[1], data2[2]);
            }

            if (outLevel >= 2) {
                (void) EG_attributeNum(ebodys1[ichild1], &nattr);
                for (iattr = 1; iattr <= nattr; iattr++) {
                    (void) EG_attributeGet(ebodys1[ichild1], iattr, &aname, &itype, &nlist,
                                           &tempIlist, &tempRlist, &tempClist);
                    SPRINT1x(2, "          %-20s :", aname);
                    if (itype == ATTRINT) {
                        for (ilist = 0; ilist < nlist; ilist++) {
                            SPRINT1x(2, " %5d", tempIlist[ilist]);
                    }
                        SPRINT0(2, " ");
                    } else if (itype == ATTRREAL) {
                        for (ilist = 0; ilist < nlist; ilist++) {
                            SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                        }
                        SPRINT0(2, " ");
                    } else if (itype == ATTRSTRING) {
                        SPRINT1(2, "%s", tempClist);
                } else {
                        SPRINT0(2, " ");
                    }
                }
            }

            for (ichild2 = 0; ichild2 < nchild2; ichild2++) {
                status = EG_getTopology(ebodys2[ichild2], &eref3, &oclass3, &mtype3,
                               data3, &nchild3, &ebodys3, &senses3);
                if (status != EGADS_SUCCESS) {
                    EG_getInfo(ebodys2[ichild2], &oclass3, &mtype3, &topref, &prev, &next);
                    nchild3 = -1;
                    eref3   = topref;
                }

                if (oclass3 != NODE) {
                    if (oclass3 == PCURVE || oclass3 == CURVE) {
                        strcpy(mtypename, mtypename1[mtype3]);
                    } else if (oclass3 == SURFACE) {
                        strcpy(mtypename, mtypename2[mtype3]);
                    } else if (oclass3 == FACE  || oclass3 == EFACE) {
                        strcpy(mtypename, mtypename3[mtype3+1]);
                    } else if (oclass3 == EDGE  || oclass3 == EEDGE  ||
                               oclass3 == LOOP  || oclass3 == ELOOPX ||
                               oclass3 == SHELL || oclass3 == ESHELL ||
                               oclass3 == BODY  || oclass3 == EBODY  ||
                               oclass3 == MODEL                        ) {
                        strcpy(mtypename, mtypename4[mtype3]);
                    } else {
                        strcpy(mtypename, "");
                    }

                    if (oclass3 == EDGE || oclass3 == FACE) {
                        status = EG_getGeometry(eref3, &oclass, &mtype, &ergeom, NULL, NULL);
                        if (status != EGADS_SUCCESS) {
                            oclass = 0;
                            mtype  = 0;
                        }
                    } else {
                        oclass = 0;
                        mtype  = 0;
                    }
                    SPRINT8(0, ". . . oclass3=%3d (%s)  mtype3=%3d (%s)  obj=%llx,  eref3=%llx (%d:%d)",
                            oclass3, classname[oclass3], mtype3, mtypename, (long long)(ebodys2[ichild2]), (long long)eref3, oclass, mtype);

                    if (oclass3 == EDGE || oclass3 == EEDGE) {
                        SPRINT2(0, ". . . < trange=%10.5f %10.5f", data3[0], data3[1]);
                    } else if (oclass3 == LOOP || oclass3 == ELOOPX ||
                               oclass3 == FACE || oclass3 == EFACE    ) {
                        SPRINT0x(0, ". . . < senses=");
                        for (i=0; i < nchild3; i++) {
                            SPRINT1x(0, "%2d ", senses3[i]);
                        }
                        SPRINT0(0, " ");
                    }
                } else {
                    SPRINT7(0, ". . . oclass3=%3d (%s)  mtype3=%3d,  obj=%llx,  data3=%20.10e %20.10e %20.10e",
                            oclass3, classname[oclass3], mtype3, (long long)(ebodys2[ichild2]), data3[0], data3[1], data3[2]);
                }

                if (outLevel >= 2) {
                    (void) EG_attributeNum(ebodys2[ichild2], &nattr);
                    for (iattr = 1; iattr <= nattr; iattr++) {
                        (void) EG_attributeGet(ebodys2[ichild2], iattr, &aname, &itype, &nlist,
                                               &tempIlist, &tempRlist, &tempClist);
                        SPRINT1x(2, "          %-20s :", aname);
                        if (itype == ATTRINT) {
                            for (ilist = 0; ilist < nlist; ilist++) {
                                SPRINT1x(2, " %5d", tempIlist[ilist]);
                            }
                            SPRINT0(2, " ");
                        } else if (itype == ATTRREAL) {
                            for (ilist = 0; ilist < nlist; ilist++) {
                                SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                            }
                            SPRINT0(2, " ");
                        } else if (itype == ATTRSTRING) {
                            SPRINT1(2, "%s", tempClist);
                    } else {
                            SPRINT0(2, " ");
                        }
                    }
                }

                for (ichild3 = 0; ichild3 < nchild3; ichild3++) {
                    status = EG_getTopology(ebodys3[ichild3], &eref4, &oclass4, &mtype4,
                                   data4, &nchild4, &ebodys4, &senses4);
                    if (status != EGADS_SUCCESS) {
                        EG_getInfo(ebodys3[ichild3], &oclass4, &mtype4, &topref, &prev, &next);
                        nchild4 = -1;
                        eref4   = topref;
                    }

                    if (oclass4 != NODE) {
                        if (oclass4 == PCURVE || oclass4 == CURVE) {
                            strcpy(mtypename, mtypename1[mtype4]);
                        } else if (oclass4 == SURFACE) {
                            strcpy(mtypename, mtypename2[mtype4]);
                        } else if (oclass4 == FACE  || oclass4 == EFACE) {
                            strcpy(mtypename, mtypename3[mtype4+1]);
                        } else if (oclass4 == EDGE  || oclass4 == EEDGE  ||
                                   oclass4 == LOOP  || oclass4 == ELOOPX ||
                                   oclass4 == SHELL || oclass4 == ESHELL ||
                                   oclass4 == BODY  || oclass4 == EBODY  ||
                                   oclass4 == MODEL                        ) {
                            strcpy(mtypename, mtypename4[mtype4]);
                        } else {
                            strcpy(mtypename, "");
                        }

                        if (oclass4 == EDGE || oclass4 == FACE) {
                            status = EG_getGeometry(eref4, &oclass, &mtype, &ergeom, NULL, NULL);
                            if (status != EGADS_SUCCESS) {
                                oclass = 0;
                                mtype  = 0;
                            }
                        } else {
                            oclass = 0;
                            mtype  = 0;
                        }
                        SPRINT8(0, ". . . . oclass4=%3d (%s)  mtype4=%3d (%s)  obj=%llx,  eref4=%llx (%d:%d)",
                                oclass4, classname[oclass4], mtype4, mtypename, (long long)(ebodys3[ichild3]), (long long)eref4, oclass, mtype);

                        if (oclass4 == EDGE || oclass4 == EEDGE) {
                            SPRINT2(0, ". . . . < trange=%10.5f %10.5f", data4[0], data4[1]);
                        } else if (oclass4 == LOOP || oclass4 == ELOOPX ||
                                   oclass4 == FACE || oclass4 == EFACE    ) {
                            SPRINT0x(0, ". . . . < senses=");
                            for (i=0; i < nchild4; i++) {
                                SPRINT1x(0, "%2d ", senses4[i]);
                            }
                            SPRINT0(0, " ");
                        }
                    } else {
                        SPRINT7(0, ". . . . oclass4=%3d (%s)  mtype4=%3d,  obj=%llx,  data4=%20.10e %20.10e %20.10e",
                                oclass4, classname[oclass4], mtype4, (long long)(ebodys3[ichild3]), data4[0], data4[1], data4[2]);
                    }

                    if (outLevel >= 2) {
                        (void) EG_attributeNum(ebodys3[ichild3], &nattr);
                        for (iattr = 1; iattr <= nattr; iattr++) {
                            (void) EG_attributeGet(ebodys3[ichild3], iattr, &aname, &itype, &nlist,
                                                   &tempIlist, &tempRlist, &tempClist);
                            SPRINT1x(2, "          %-20s :", aname);
                            if (itype == ATTRINT) {
                                for (ilist = 0; ilist < nlist; ilist++) {
                                    SPRINT1x(2, " %5d", tempIlist[ilist]);
                                }
                                SPRINT0(2, " ");
                            } else if (itype == ATTRREAL) {
                                for (ilist = 0; ilist < nlist; ilist++) {
                                    SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                                }
                                SPRINT0(2, " ");
                            } else if (itype == ATTRSTRING) {
                                SPRINT1(2, "%s", tempClist);
                            } else {
                                SPRINT0(2, " ");
                            }
                        }
                    }

                    for (ichild4 = 0; ichild4 < nchild4; ichild4++) {
                        status = EG_getTopology(ebodys4[ichild4], &eref5, &oclass5, &mtype5,
                                                data5, &nchild5, &ebodys5, &senses5);
                        if (status != EGADS_SUCCESS) {
                            EG_getInfo(ebodys4[ichild4], &oclass5, &mtype5, &topref, &prev, &next);
                            nchild5 = -1;
                            eref5   = topref;
                        }

                        if (oclass5 != NODE) {
                            if (oclass5 == PCURVE || oclass5 == CURVE) {
                                strcpy(mtypename, mtypename1[mtype5]);
                            } else if (oclass5 == SURFACE) {
                                strcpy(mtypename, mtypename2[mtype5]);
                            } else if (oclass5 == FACE  || oclass5 == EFACE) {
                                strcpy(mtypename, mtypename3[mtype5+1]);
                            } else if (oclass5 == EDGE  || oclass5 == EEDGE  ||
                                       oclass5 == LOOP  || oclass5 == ELOOPX ||
                                       oclass5 == SHELL || oclass5 == ESHELL ||
                                       oclass5 == BODY  || oclass5 == EBODY  ||
                                       oclass5 == MODEL                        ) {
                                strcpy(mtypename, mtypename4[mtype5]);
                            } else {
                                strcpy(mtypename, "");
                            }

                            if (oclass5 == EDGE || oclass5 == FACE) {
                                status = EG_getGeometry(eref5, &oclass, &mtype, &ergeom, NULL, NULL);
                                if (status != EGADS_SUCCESS) {
                                    oclass = 0;
                                    mtype  = 0;
                                }
                            } else {
                                oclass = 0;
                                mtype  = 0;
                            }
                            SPRINT8(0, ". . . . . oclass5=%3d (%s)  mtype5=%3d (%s)  obj=%llx,  eref5=%llx (%d:%d)",
                                    oclass5, classname[oclass5], mtype5, mtypename, (long long)(ebodys4[ichild4]), (long long)eref5, oclass, mtype);

                            if (oclass5 == EDGE || oclass5 == EEDGE) {
                                SPRINT2(0, ". . . . . < trange=%10.5f %10.5f", data5[0], data5[1]);
                            } else if (oclass5 == LOOP || oclass5 == ELOOPX ||
                                       oclass5 == FACE || oclass5 == EFACE    ) {
                                SPRINT0x(0, ". . . . . < senses=");
                                for (i=0; i < nchild5; i++) {
                                    SPRINT1x(0, "%2d ", senses5[i]);
                                }
                                SPRINT0(0, " ");
                            }
                        } else {
                            SPRINT7(0, ". . . . . oclass5=%3d (%s)  mtype5=%3d,  obj=%llx,  data5=%20.10e %20.10e %20.10e",
                                    oclass5, classname[oclass5], mtype5, (long long)(ebodys4[ichild4]), data5[0], data5[1], data5[2]);
                        }

                        if (outLevel >= 2) {
                            (void) EG_attributeNum(ebodys4[ichild4], &nattr);
                            for (iattr = 1; iattr <= nattr; iattr++) {
                                (void) EG_attributeGet(ebodys4[ichild4], iattr, &aname, &itype, &nlist,
                                                       &tempIlist, &tempRlist, &tempClist);
                                SPRINT1x(2, "          %-20s :", aname);
                                if (itype == ATTRINT) {
                                    for (ilist = 0; ilist < nlist; ilist++) {
                                        SPRINT1x(2, " %5d", tempIlist[ilist]);
                                    }
                                    SPRINT0(2, " ");
                            } else if (itype == ATTRREAL) {
                                    for (ilist = 0; ilist < nlist; ilist++) {
                                        SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                                    }
                                    SPRINT0(2, " ");
                                } else if (itype == ATTRSTRING) {
                                    SPRINT1(2, "%s", tempClist);
                            } else {
                                    SPRINT0(2, " ");
                                }
                            }
                        }

                        for (ichild5 = 0; ichild5 < nchild5; ichild5++) {
                            status = EG_getTopology(ebodys5[ichild5], &eref6, &oclass6, &mtype6,
                                                    data6, &nchild6, &ebodys6, &senses6);
                            if (status != EGADS_SUCCESS) {
                                EG_getInfo(ebodys5[ichild5], &oclass6, &mtype6, &topref, &prev, &next);
                                nchild5 = -1;
                                eref6   = topref;
                            }

                            if (oclass6 != NODE) {
                                if (oclass6 == PCURVE || oclass6 == CURVE) {
                                    strcpy(mtypename, mtypename1[mtype6]);
                                } else if (oclass6 == SURFACE) {
                                    strcpy(mtypename, mtypename2[mtype6]);
                                } else if (oclass6 == FACE  || oclass6 == EFACE) {
                                    strcpy(mtypename, mtypename3[mtype6+1]);
                                } else if (oclass6 == EDGE  || oclass6 == EEDGE  ||
                                           oclass6 == LOOP  || oclass6 == ELOOPX ||
                                           oclass6 == SHELL || oclass6 == ESHELL ||
                                           oclass6 == BODY  || oclass6 == EBODY  ||
                                           oclass6 == MODEL                        ) {
                                    strcpy(mtypename, mtypename4[mtype6]);
                                } else {
                                    strcpy(mtypename, "");
                                }

                                if (oclass6 == EDGE || oclass6 == FACE) {
                                    status = EG_getGeometry(eref6, &oclass, &mtype, &ergeom, NULL, NULL);
                                    if (status != EGADS_SUCCESS) {
                                        oclass = 0;
                                        mtype  = 0;
                                    }
                                } else {
                                    oclass = 0;
                                    mtype  = 0;
                                }
                                SPRINT8(0, ". . . . . . oclass6=%3d (%s)  mtype6=%3d (%s)  obj=%llx,  eref6=%llx (%d:%d)",
                                        oclass6, classname[oclass6], mtype6, mtypename, (long long)(ebodys5[ichild5]), (long long)eref6, oclass, mtype);

                                if (oclass6 == EDGE || oclass6 == EEDGE) {
                                    SPRINT2(0, ". . . . . . < trange=%10.5f %10.5f", data6[0], data6[1]);
                                } else if (oclass6 == LOOP || oclass6 == ELOOPX ||
                                           oclass6 == FACE || oclass6 == EFACE    ) {
                                    SPRINT0x(0, ". . . . . . < senses=");
                                    for (i=0; i < nchild6; i++) {
                                        SPRINT1x(0, "%2d ", senses6[i]);
                                    }
                                    SPRINT0(0, " ");
                                }
                            } else {
                                SPRINT7(0, ". . . . . . oclass6=%3d (%s)  mtype6=%3d,  obj=%llx,  data6=%20.10e %20.10e %20.10e",
                                        oclass6, classname[oclass6], mtype6, (long long)(ebodys5[ichild5]), data6[0], data6[1], data6[2]);
                            }

                            if (outLevel >= 2) {
                                (void) EG_attributeNum(ebodys5[ichild5], &nattr);
                                for (iattr = 1; iattr <= nattr; iattr++) {
                                    (void) EG_attributeGet(ebodys5[ichild5], iattr, &aname, &itype, &nlist,
                                                           &tempIlist, &tempRlist, &tempClist);
                                    SPRINT1x(2, "          %-20s :", aname);
                                    if (itype == ATTRINT) {
                                        for (ilist = 0; ilist < nlist; ilist++) {
                                            SPRINT1x(2, " %5d", tempIlist[ilist]);
                                        }
                                        SPRINT0(2, " ");
                                    } else if (itype == ATTRREAL) {
                                        for (ilist = 0; ilist < nlist; ilist++) {
                                            SPRINT1x(2, " %11.5f", tempRlist[ilist]);
                                        }
                                        SPRINT0(2, " ");
                                    } else if (itype == ATTRSTRING) {
                                    SPRINT1(2, "%s", tempClist);
                                    } else {
                                        SPRINT0(2, " ");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetText - convert an OCSM code to text                         *
 *                                                                      *
 ************************************************************************
 */

char *
ocsmGetText(int    icode)               /* (in)  code to look up */
{

    static char    unknown[]                          = "UNKNOWN";
    static char    success[]                          = "success";

    static char    ocsm_dimension[]                   = "dimension";
    static char    ocsm_lbound[]                      = "lbound";
    static char    ocsm_ubound[]                      = "ubound";
    static char    ocsm_name[]                        = "name";
    static char    ocsm_attribute[]                   = "attribute";
    static char    ocsm_csystem[]                     = "csystem";

    static char    ocsm_point[]                       = "point";
    static char    ocsm_box[]                         = "box";
    static char    ocsm_sphere[]                      = "sphere";
    static char    ocsm_cone[]                        = "cone";
    static char    ocsm_cylinder[]                    = "cylinder";
    static char    ocsm_torus[]                       = "torus";
    static char    ocsm_import[]                      = "import";
    static char    ocsm_udprim[]                      = "udprim";
    static char    ocsm_restore[]                     = "restore";

    static char    ocsm_extrude[]                     = "extrude";
    static char    ocsm_rule[]                        = "rule";
    static char    ocsm_loft[]                        = "loft";
    static char    ocsm_blend[]                       = "blend";
    static char    ocsm_revolve[]                     = "revolve";
    static char    ocsm_sweep[]                       = "sweep";

    static char    ocsm_fillet[]                      = "fillet";
    static char    ocsm_chamfer[]                     = "chamfer";
    static char    ocsm_hollow[]                      = "hollow";
    static char    ocsm_connect[]                     = "connect";

    static char    ocsm_intersect[]                   = "intersect";
    static char    ocsm_subtract[]                    = "subtract";
    static char    ocsm_union[]                       = "union";
    static char    ocsm_join[]                        = "join";
    static char    ocsm_extract[]                     = "extract";
    static char    ocsm_combine[]                     = "combine";

    static char    ocsm_translate[]                   = "translate";
    static char    ocsm_rotatex[]                     = "rotatex";
    static char    ocsm_rotatey[]                     = "rotatey";
    static char    ocsm_rotatez[]                     = "rotatez";
    static char    ocsm_scale[]                       = "scale";
    static char    ocsm_mirror[]                      = "mirror";
    static char    ocsm_applycsys[]                   = "applycsys";
    static char    ocsm_reorder[]                     = "reorder";

    static char    ocsm_skbeg[]                       = "skbeg";
    static char    ocsm_skcon[]                       = "skcon";
    static char    ocsm_skvar[]                       = "skvar";
    static char    ocsm_linseg[]                      = "linseg";
    static char    ocsm_cirarc[]                      = "cirarc";
    static char    ocsm_arc[]                         = "arc";
    static char    ocsm_spline[]                      = "spline";
    static char    ocsm_sslope[]                      = "sslope";
    static char    ocsm_bezier[]                      = "bezier";
    static char    ocsm_skend[]                       = "skend";

    static char    ocsm_solbeg[]                      = "solbeg";
    static char    ocsm_solcon[]                      = "solcon";
    static char    ocsm_solend[]                      = "solend";

    static char    ocsm_interface[]                   = "interface";
    static char    ocsm_end[]                         = "end";
    static char    ocsm_set[]                         = "set";
    static char    ocsm_evaluate[]                    = "evaluate";
    static char    ocsm_getattr[]                     = "getattr";
    static char    ocsm_udparg[]                      = "udparg";
    static char    ocsm_select[]                      = "select";
    static char    ocsm_project[]                     = "project";
    static char    ocsm_macbeg[]                      = "macbeg";
    static char    ocsm_macend[]                      = "macend";
    static char    ocsm_recall[]                      = "recall";
    static char    ocsm_store[]                       = "store";
    static char    ocsm_patbeg[]                      = "patbeg";
    static char    ocsm_patbreak[]                    = "patbreak";
    static char    ocsm_patend[]                      = "patend";
    static char    ocsm_ifthen[]                      = "ifthen";
    static char    ocsm_elseif[]                      = "elseif";
    static char    ocsm_else[]                        = "else";
    static char    ocsm_endif[]                       = "endif";
    static char    ocsm_throw[]                       = "throw";
    static char    ocsm_catbeg[]                      = "catbeg";
    static char    ocsm_catend[]                      = "catend";
    static char    ocsm_mark[]                        = "mark";
    static char    ocsm_group[]                       = "group";
    static char    ocsm_dump[]                        = "dump";
    static char    ocsm_assert[]                      = "assert";
    static char    ocsm_message[]                     = "message";
    static char    ocsm_special[]                     = "special";

    static char    ocsm_primitive[]                   = "primitive";
    static char    ocsm_grown[]                       = "grown";
    static char    ocsm_applied[]                     = "applied";
    static char    ocsm_boolean[]                     = "boolean";
    static char    ocsm_transform[]                   = "transform";
    static char    ocsm_sketch[]                      = "sketch";
    static char    ocsm_solver[]                      = "solver";
    static char    ocsm_utility[]                     = "utility";

    static char    ocsm_active[]                      = "active";
    static char    ocsm_suppressed[]                  = "suppressed";
    static char    ocsm_inactive[]                    = "inactive";
    static char    ocsm_deferred[]                    = "deferred";

    static char    ocsm_solid_body[]                  = "solid_body";
    static char    ocsm_sheet_body[]                  = "sheet_body";
    static char    ocsm_wire_body[]                   = "wire_body";
    static char    ocsm_node_body[]                   = "node_body";
    static char    ocsm_null_body[]                   = "null_body";

    static char    ocsm_despmtr[]                     = "despmtr";
    static char    ocsm_cfgpmtr[]                     = "cfgpmtr";
    static char    ocsm_conpmtr[]                     = "conpmtr";
    static char    ocsm_localvar[]                    = "localvar";
    static char    ocsm_outpmtr[]                     = "outpmtr";
    static char    ocsm_unknown[]                     = "unknown";

    static char    ocsm_node[]                        = "node";
    static char    ocsm_edge[]                        = "edge";
    static char    ocsm_face[]                        = "face";
    static char    ocsm_body[]                        = "body";
    static char    ocsm_eedge[]                       = "eedge";
    static char    ocsm_eface[]                       = "eface";
    static char    ocsm_ebody[]                       = "ebody";

    static char    ocsm_file_not_found[]              = "file_not_found";
    static char    ocsm_illegal_statement[]           = "illegal_statement";
    static char    ocsm_not_enough_args[]             = "not_enough_args";
    static char    ocsm_name_already_defined[]        = "name_already_defined";
    static char    ocsm_nested_too_deeply[]           = "nested_too_deeply";
    static char    ocsm_improper_nesting[]            = "improper_nesting";
    static char    ocsm_nesting_not_closed[]          = "nesting_not_closed";
    static char    ocsm_not_modl_structure[]          = "not_modl_structure";
    static char    ocsm_problem_creating_perturb[]    = "problem_creating_perturb";
    static char    ocsm_ebody_not_found[]             = "ebody_not_found";

    static char    ocsm_missing_mark[]                = "missing_mark";
    static char    ocsm_insufficient_bodys_on_stack[] = "insufficient_bodys_on_stack";
    static char    ocsm_wrong_types_on_stack[]        = "wrong_types_on_stack";
    static char    ocsm_did_not_create_body[]         = "did_not_create_body";
    static char    ocsm_created_too_many_bodys[]      = "created_too_many_bodys";
    static char    ocsm_too_many_bodys_on_stack[]     = "too_many_bodys_on_stack";
    static char    ocsm_error_in_bodys_on_stack[]     = "errors_in_bodys_on_stack";

    static char    ocsm_modl_not_checked[]            = "modl_not_checked";
    static char    ocsm_need_tessellation[]           = "need_tessellation";

    static char    ocsm_body_not_found[]              = "body_not_found";
    static char    ocsm_face_not_found[]              = "face_not_found";
    static char    ocsm_edge_not_found[]              = "edge_not_found";
    static char    ocsm_node_not_found[]              = "node_not_found";
    static char    ocsm_illegal_value[]               = "illegal_value";
    static char    ocsm_illegal_attribute[]           = "illegal_attribute";
    static char    ocsm_illegal_csystem[]             = "illegal_csystem";
    static char    ocsm_no_selection[]                = "no_selection";

    static char    ocsm_sketch_is_open[]              = "sketch_is_open";
    static char    ocsm_sketch_is_not_open[]          = "sketch_is_not_open";
    static char    ocsm_colinear_sketch_points[]      = "colinear_sketch_points";
    static char    ocsm_non_coplanar_sketch_points[]  = "non_coplanar_sketch_points";
    static char    ocsm_too_many_sketch_points[]      = "too_many_sketch_points";
    static char    ocsm_too_few_spline_points[]       = "too_few_spline_points";
    static char    ocsm_sketch_does_not_close[]       = "sketch_does_not_close";
    static char    ocsm_self_intersecting[]           = "self_intersecting";
    static char    ocsm_assert_failed[]               = "assert_failed";

    static char    ocsm_illegal_char_in_expr[]        = "illegal_char_in_expr";
    static char    ocsm_close_before_open[]           = "close_before_open";
    static char    ocsm_missing_close[]               = "missing_close";
    static char    ocsm_illegal_token_sequence[]      = "illegal_token_sequence";
    static char    ocsm_illegal_number[]              = "illegal_number";
    static char    ocsm_illegal_pmtr_name[]           = "illegal_pmtr_name";
    static char    ocsm_illegal_func_name[]           = "illegal_func_name";
    static char    ocsm_illegal_type[]                = "illegal_type";
    static char    ocsm_illegal_narg[]                = "illegal_narg";

    static char    ocsm_name_not_found[]              = "name_not_found";
    static char    ocsm_name_not_unique[]             = "name_not_unique";
    static char    ocsm_pmtr_is_despmtr[]             = "pmtr_is_despmtr";
    static char    ocsm_pmtr_is_localvar[]            = "pmtr_is_localvar";
    static char    ocsm_pmtr_is_outpmtr[]             = "pmtr_is_outpmtr";
    static char    ocsm_pmtr_is_conpmtr[]             = "pmtr_is_conpmtr";
    static char    ocsm_wrong_pmtr_type[]             = "wrong_pmtr_type";
    static char    ocsm_func_arg_out_of_bounds[]      = "func_arg_out_of_bounds";
    static char    ocsm_val_stack_underflow[]         = "val_stack_underflow";
    static char    ocsm_val_stack_overflow[]          = "val_stack_overflow";

    static char    ocsm_illegal_brch_index[]          = "illegal_brch_index";
    static char    ocsm_illegal_pmtr_index[]          = "illegal_pmtr_index";
    static char    ocsm_illegal_body_index[]          = "illegal_body_index";
    static char    ocsm_illegal_arg_index[]           = "illegal_arg_index";
    static char    ocsm_illegal_activity[]            = "illegal_activity";
    static char    ocsm_illegal_macro_index[]         = "illegal_macro_index";
    static char    ocsm_illegal_argument[]            = "illegal_argument";
    static char    ocsm_cannot_be_suppressed[]        = "cannot_be_suppressed";
    static char    ocsm_storage_already_used[]        = "storage_already_used";
    static char    ocsm_nothing_previously_stored[]   = "nothing_previously_stored";

    static char    ocsm_solver_is_open[]              = "solver_is_open";
    static char    ocsm_solver_is_not_open[]          = "solver_is_not_open";
    static char    ocsm_too_many_solver_vars[]        = "too_many_solver_vars";
    static char    ocsm_underconstrained[]            = "underconstrained";
    static char    ocsm_overconstrained[]             = "overconstrained";
    static char    ocsm_singular_matrix[]             = "singular_matrix";
    static char    ocsm_not_converged[]               = "not_converged";

    static char    ocsm_udp_error1[]                  = "udp_error1";
    static char    ocsm_udp_error2[]                  = "udp_error2";
    static char    ocsm_udp_error3[]                  = "udp_error3";
    static char    ocsm_udp_error4[]                  = "udp_error4";
    static char    ocsm_udp_error5[]                  = "udp_error5";
    static char    ocsm_udp_error6[]                  = "udp_error6";
    static char    ocsm_udp_error7[]                  = "udp_error7";
    static char    ocsm_udp_error8[]                  = "udp_error8";
    static char    ocsm_udp_error9[]                  = "udp_error9";

    static char    ocsm_op_stack_underflow[]          = "op_stack_underflow";
    static char    ocsm_op_stack_overflow[]           = "op_stack_overflow";
    static char    ocsm_rpn_stack_underflow[]         = "rpn_stack_underflow";
    static char    ocsm_rpn_stack_overflow[]          = "rpn_stack_overflow";
    static char    ocsm_token_stack_underflow[]       = "token_stack_underflow";
    static char    ocsm_token_stack_overflow[]        = "token_stack_overflow";
    static char    ocsm_unsupported[]                 = "unsupported";
    static char    ocsm_internal_error[]              = "internal_error";

    static char    egads_notfound[]                   = "egads_notfound";
    static char    egads_nullobj[]                    = "egads_nullobj";
    static char    egads_notobj[]                     = "egads_notobj";
    static char    egads_malloc[]                     = "egads_malloc";
    static char    egads_indexerr[]                   = "egads_indexerr";
    static char    egads_noname[]                     = "egads_noname";
    static char    egads_nodata[]                     = "egads_nodata";
    static char    egads_mixcntx[]                    = "egads_mixcntx";
    static char    egads_notcntx[]                    = "egads_notcntx";
    static char    egads_notxform[]                   = "egads_notxform";
    static char    egads_referce[]                    = "egads_referce";
    static char    egads_nottopo[]                    = "egads_nottopo";
    static char    egads_empty[]                      = "egads_empty";
    static char    egads_nottess[]                    = "egads_nottess";
    static char    egads_notgeom[]                    = "egads_notgeom";
    static char    egads_rangerr[]                    = "egads_rangerr";
    static char    egads_noload[]                     = "egads_noload";
    static char    egads_notmodel[]                   = "egads_notmodel";
    static char    egads_writerr[]                    = "egads_writerr";
    static char    egads_notbody[]                    = "egads_notbody";
    static char    egads_geomerr[]                    = "egads_geomerr";
    static char    egads_topoerr[]                    = "egads_topoerr";
    static char    egads_consterr[]                   = "egads_consterr";
    static char    egads_degen[]                      = "egads_degen";
    static char    egads_notortho[]                   = "egads_notortho";
    static char    egads_badscale[]                   = "egads_badscale";
    static char    egads_ocsegflt[]                   = "egads_ocsegflt";
    static char    egads_topocnt[]                    = "egads_topocnt";
    static char    egads_attrerr[]                    = "egads_attrerr";
    static char    egads_exists[]                     = "egads_exists";

    /* --------------------------------------------------------------- */

    /* OCSM_SUCCESS */
    if (icode == SUCCESS                         ) return success;

    /* not branches */
    if (icode == OCSM_DIMENSION                  ) return ocsm_dimension;
    if (icode == OCSM_LBOUND                     ) return ocsm_lbound;
    if (icode == OCSM_UBOUND                     ) return ocsm_ubound;
    if (icode == OCSM_NAME                       ) return ocsm_name;
    if (icode == OCSM_ATTRIBUTE                  ) return ocsm_attribute;
    if (icode == OCSM_CSYSTEM                    ) return ocsm_csystem;

    /* OCSM_PRIMITIVE */
    if (icode == OCSM_POINT                      ) return ocsm_point;
    if (icode == OCSM_BOX                        ) return ocsm_box;
    if (icode == OCSM_SPHERE                     ) return ocsm_sphere;
    if (icode == OCSM_CONE                       ) return ocsm_cone;
    if (icode == OCSM_CYLINDER                   ) return ocsm_cylinder;
    if (icode == OCSM_TORUS                      ) return ocsm_torus;
    if (icode == OCSM_IMPORT                     ) return ocsm_import;
    if (icode == OCSM_UDPRIM                     ) return ocsm_udprim;
    if (icode == OCSM_RESTORE                    ) return ocsm_restore;

    /* OCSM_GROWN */
    if (icode == OCSM_EXTRUDE                    ) return ocsm_extrude;
    if (icode == OCSM_RULE                       ) return ocsm_rule;
    if (icode == OCSM_LOFT                       ) return ocsm_loft;
    if (icode == OCSM_BLEND                      ) return ocsm_blend;
    if (icode == OCSM_REVOLVE                    ) return ocsm_revolve;
    if (icode == OCSM_SWEEP                      ) return ocsm_sweep;

    /* OCSM_APPLIED */
    if (icode == OCSM_FILLET                     ) return ocsm_fillet;
    if (icode == OCSM_CHAMFER                    ) return ocsm_chamfer;
    if (icode == OCSM_HOLLOW                     ) return ocsm_hollow;
    if (icode == OCSM_CONNECT                    ) return ocsm_connect;

    /* OCSM_BOOLEAN */
    if (icode == OCSM_INTERSECT                  ) return ocsm_intersect;
    if (icode == OCSM_SUBTRACT                   ) return ocsm_subtract;
    if (icode == OCSM_UNION                      ) return ocsm_union;
    if (icode == OCSM_JOIN                       ) return ocsm_join;
    if (icode == OCSM_EXTRACT                    ) return ocsm_extract;
    if (icode == OCSM_COMBINE                    ) return ocsm_combine;

    /* OCSM_TRANSFORM */
    if (icode == OCSM_TRANSLATE                  ) return ocsm_translate;
    if (icode == OCSM_ROTATEX                    ) return ocsm_rotatex;
    if (icode == OCSM_ROTATEY                    ) return ocsm_rotatey;
    if (icode == OCSM_ROTATEZ                    ) return ocsm_rotatez;
    if (icode == OCSM_SCALE                      ) return ocsm_scale;
    if (icode == OCSM_MIRROR                     ) return ocsm_mirror;
    if (icode == OCSM_APPLYCSYS                  ) return ocsm_applycsys;
    if (icode == OCSM_REORDER                    ) return ocsm_reorder;

    /* OCSM_SKETCH */
    if (icode == OCSM_SKBEG                      ) return ocsm_skbeg;
    if (icode == OCSM_SKCON                      ) return ocsm_skcon;
    if (icode == OCSM_SKVAR                      ) return ocsm_skvar;
    if (icode == OCSM_LINSEG                     ) return ocsm_linseg;
    if (icode == OCSM_CIRARC                     ) return ocsm_cirarc;
    if (icode == OCSM_ARC                        ) return ocsm_arc;
    if (icode == OCSM_SPLINE                     ) return ocsm_spline;
    if (icode == OCSM_SSLOPE                     ) return ocsm_sslope;
    if (icode == OCSM_BEZIER                     ) return ocsm_bezier;
    if (icode == OCSM_SKEND                      ) return ocsm_skend;

    /* OCSM_SOLVER */
    if (icode == OCSM_SOLBEG                     ) return ocsm_solbeg;
    if (icode == OCSM_SOLCON                     ) return ocsm_solcon;
    if (icode == OCSM_SOLEND                     ) return ocsm_solend;

    /* OCSM_UTILITY */
    if (icode == OCSM_INTERFACE                  ) return ocsm_interface;
    if (icode == OCSM_END                        ) return ocsm_end;
    if (icode == OCSM_SET                        ) return ocsm_set;
    if (icode == OCSM_EVALUATE                   ) return ocsm_evaluate;
    if (icode == OCSM_GETATTR                    ) return ocsm_getattr;
    if (icode == OCSM_UDPARG                     ) return ocsm_udparg;
    if (icode == OCSM_SELECT                     ) return ocsm_select;
    if (icode == OCSM_PROJECT                    ) return ocsm_project;
    if (icode == OCSM_MACBEG                     ) return ocsm_macbeg;
    if (icode == OCSM_MACEND                     ) return ocsm_macend;
    if (icode == OCSM_RECALL                     ) return ocsm_recall;
    if (icode == OCSM_STORE                      ) return ocsm_store;
    if (icode == OCSM_PATBEG                     ) return ocsm_patbeg;
    if (icode == OCSM_PATBREAK                   ) return ocsm_patbreak;
    if (icode == OCSM_PATEND                     ) return ocsm_patend;
    if (icode == OCSM_IFTHEN                     ) return ocsm_ifthen;
    if (icode == OCSM_ELSEIF                     ) return ocsm_elseif;
    if (icode == OCSM_ELSE                       ) return ocsm_else;
    if (icode == OCSM_ENDIF                      ) return ocsm_endif;
    if (icode == OCSM_THROW                      ) return ocsm_throw;
    if (icode == OCSM_CATBEG                     ) return ocsm_catbeg;
    if (icode == OCSM_CATEND                     ) return ocsm_catend;
    if (icode == OCSM_MARK                       ) return ocsm_mark;
    if (icode == OCSM_GROUP                      ) return ocsm_group;
    if (icode == OCSM_DUMP                       ) return ocsm_dump;
    if (icode == OCSM_ASSERT                     ) return ocsm_assert;
    if (icode == OCSM_MESSAGE                    ) return ocsm_message;
    if (icode == OCSM_SPECIAL                    ) return ocsm_special;

    /* Branch classes */
    if (icode == OCSM_PRIMITIVE                  ) return ocsm_primitive;
    if (icode == OCSM_GROWN                      ) return ocsm_grown;
    if (icode == OCSM_APPLIED                    ) return ocsm_applied;
    if (icode == OCSM_BOOLEAN                    ) return ocsm_boolean;
    if (icode == OCSM_TRANSFORM                  ) return ocsm_transform;
    if (icode == OCSM_SKETCH                     ) return ocsm_sketch;
    if (icode == OCSM_SOLVER                     ) return ocsm_solver;
    if (icode == OCSM_UTILITY                    ) return ocsm_utility;

    /* Branch activities */
    if (icode == OCSM_ACTIVE                     ) return ocsm_active;
    if (icode == OCSM_SUPPRESSED                 ) return ocsm_suppressed;
    if (icode == OCSM_INACTIVE                   ) return ocsm_inactive;
    if (icode == OCSM_DEFERRED                   ) return ocsm_deferred;

    /* Body types */
    if (icode == OCSM_SOLID_BODY                 ) return ocsm_solid_body;
    if (icode == OCSM_SHEET_BODY                 ) return ocsm_sheet_body;
    if (icode == OCSM_WIRE_BODY                  ) return ocsm_wire_body;
    if (icode == OCSM_NODE_BODY                  ) return ocsm_node_body;
    if (icode == OCSM_NULL_BODY                  ) return ocsm_null_body;

    /* Parameter types */
    if (icode == OCSM_DESPMTR                    ) return ocsm_despmtr;
    if (icode == OCSM_CFGPMTR                    ) return ocsm_cfgpmtr;
    if (icode == OCSM_CONPMTR                    ) return ocsm_conpmtr;
    if (icode == OCSM_LOCALVAR                   ) return ocsm_localvar;
    if (icode == OCSM_OUTPMTR                    ) return ocsm_outpmtr;
    if (icode == OCSM_UNKNOWN                    ) return ocsm_unknown;

    /* Selector types */
    if (icode == OCSM_NODE                       ) return ocsm_node;
    if (icode == OCSM_EDGE                       ) return ocsm_edge;
    if (icode == OCSM_FACE                       ) return ocsm_face;
    if (icode == OCSM_BODY                       ) return ocsm_body;
    if (icode == OCSM_EEDGE                      ) return ocsm_eedge;
    if (icode == OCSM_EFACE                      ) return ocsm_eface;
    if (icode == OCSM_EBODY                      ) return ocsm_ebody;

     /* Error codes */
    if (icode == OCSM_FILE_NOT_FOUND             ) return ocsm_file_not_found;
    if (icode == OCSM_ILLEGAL_STATEMENT          ) return ocsm_illegal_statement;
    if (icode == OCSM_NOT_ENOUGH_ARGS            ) return ocsm_not_enough_args;
    if (icode == OCSM_NAME_ALREADY_DEFINED       ) return ocsm_name_already_defined;
    if (icode == OCSM_NESTED_TOO_DEEPLY          ) return ocsm_nested_too_deeply;
    if (icode == OCSM_IMPROPER_NESTING           ) return ocsm_improper_nesting;
    if (icode == OCSM_NESTING_NOT_CLOSED         ) return ocsm_nesting_not_closed;
    if (icode == OCSM_NOT_MODL_STRUCTURE         ) return ocsm_not_modl_structure;
    if (icode == OCSM_PROBLEM_CREATING_PERTURB   ) return ocsm_problem_creating_perturb;
    if (icode == OCSM_EBODY_NOT_FOUND            ) return ocsm_ebody_not_found;

    if (icode == OCSM_MISSING_MARK               ) return ocsm_missing_mark;
    if (icode == OCSM_INSUFFICIENT_BODYS_ON_STACK) return ocsm_insufficient_bodys_on_stack;
    if (icode == OCSM_WRONG_TYPES_ON_STACK       ) return ocsm_wrong_types_on_stack;
    if (icode == OCSM_DID_NOT_CREATE_BODY        ) return ocsm_did_not_create_body;
    if (icode == OCSM_CREATED_TOO_MANY_BODYS     ) return ocsm_created_too_many_bodys;
    if (icode == OCSM_TOO_MANY_BODYS_ON_STACK    ) return ocsm_too_many_bodys_on_stack;
    if (icode == OCSM_ERROR_IN_BODYS_ON_STACK    ) return ocsm_error_in_bodys_on_stack;
    if (icode == OCSM_MODL_NOT_CHECKED           ) return ocsm_modl_not_checked;
    if (icode == OCSM_NEED_TESSELLATION          ) return ocsm_need_tessellation;

    if (icode == OCSM_BODY_NOT_FOUND             ) return ocsm_body_not_found;
    if (icode == OCSM_FACE_NOT_FOUND             ) return ocsm_face_not_found;
    if (icode == OCSM_EDGE_NOT_FOUND             ) return ocsm_edge_not_found;
    if (icode == OCSM_NODE_NOT_FOUND             ) return ocsm_node_not_found;
    if (icode == OCSM_ILLEGAL_VALUE              ) return ocsm_illegal_value;
    if (icode == OCSM_ILLEGAL_ATTRIBUTE          ) return ocsm_illegal_attribute;
    if (icode == OCSM_ILLEGAL_CSYSTEM            ) return ocsm_illegal_csystem;
    if (icode == OCSM_NO_SELECTION               ) return ocsm_no_selection;

    if (icode == OCSM_SKETCH_IS_OPEN             ) return ocsm_sketch_is_open;
    if (icode == OCSM_SKETCH_IS_NOT_OPEN         ) return ocsm_sketch_is_not_open;
    if (icode == OCSM_COLINEAR_SKETCH_POINTS     ) return ocsm_colinear_sketch_points;
    if (icode == OCSM_NON_COPLANAR_SKETCH_POINTS ) return ocsm_non_coplanar_sketch_points;
    if (icode == OCSM_TOO_MANY_SKETCH_POINTS     ) return ocsm_too_many_sketch_points;
    if (icode == OCSM_TOO_FEW_SPLINE_POINTS      ) return ocsm_too_few_spline_points;
    if (icode == OCSM_SKETCH_DOES_NOT_CLOSE      ) return ocsm_sketch_does_not_close;
    if (icode == OCSM_SELF_INTERSECTING          ) return ocsm_self_intersecting;
    if (icode == OCSM_ASSERT_FAILED              ) return ocsm_assert_failed;

    if (icode == OCSM_ILLEGAL_CHAR_IN_EXPR       ) return ocsm_illegal_char_in_expr;
    if (icode == OCSM_CLOSE_BEFORE_OPEN          ) return ocsm_close_before_open;
    if (icode == OCSM_MISSING_CLOSE              ) return ocsm_missing_close;
    if (icode == OCSM_ILLEGAL_TOKEN_SEQUENCE     ) return ocsm_illegal_token_sequence;
    if (icode == OCSM_ILLEGAL_NUMBER             ) return ocsm_illegal_number;
    if (icode == OCSM_ILLEGAL_PMTR_NAME          ) return ocsm_illegal_pmtr_name;
    if (icode == OCSM_ILLEGAL_FUNC_NAME          ) return ocsm_illegal_func_name;
    if (icode == OCSM_ILLEGAL_TYPE               ) return ocsm_illegal_type;
    if (icode == OCSM_ILLEGAL_NARG               ) return ocsm_illegal_narg;

    if (icode == OCSM_NAME_NOT_FOUND             ) return ocsm_name_not_found;
    if (icode == OCSM_NAME_NOT_UNIQUE            ) return ocsm_name_not_unique;
    if (icode == OCSM_PMTR_IS_DESPMTR            ) return ocsm_pmtr_is_despmtr;
    if (icode == OCSM_PMTR_IS_LOCALVAR           ) return ocsm_pmtr_is_localvar;
    if (icode == OCSM_PMTR_IS_OUTPMTR            ) return ocsm_pmtr_is_outpmtr;
    if (icode == OCSM_PMTR_IS_CONPMTR            ) return ocsm_pmtr_is_conpmtr;
    if (icode == OCSM_WRONG_PMTR_TYPE            ) return ocsm_wrong_pmtr_type;
    if (icode == OCSM_FUNC_ARG_OUT_OF_BOUNDS     ) return ocsm_func_arg_out_of_bounds;
    if (icode == OCSM_VAL_STACK_UNDERFLOW        ) return ocsm_val_stack_underflow;
    if (icode == OCSM_VAL_STACK_OVERFLOW         ) return ocsm_val_stack_overflow;

    if (icode == OCSM_ILLEGAL_BRCH_INDEX         ) return ocsm_illegal_brch_index;
    if (icode == OCSM_ILLEGAL_PMTR_INDEX         ) return ocsm_illegal_pmtr_index;
    if (icode == OCSM_ILLEGAL_BODY_INDEX         ) return ocsm_illegal_body_index;
    if (icode == OCSM_ILLEGAL_ARG_INDEX          ) return ocsm_illegal_arg_index;
    if (icode == OCSM_ILLEGAL_ACTIVITY           ) return ocsm_illegal_activity;
    if (icode == OCSM_ILLEGAL_MACRO_INDEX        ) return ocsm_illegal_macro_index;
    if (icode == OCSM_ILLEGAL_ARGUMENT           ) return ocsm_illegal_argument;
    if (icode == OCSM_CANNOT_BE_SUPPRESSED       ) return ocsm_cannot_be_suppressed;
    if (icode == OCSM_STORAGE_ALREADY_USED       ) return ocsm_storage_already_used;
    if (icode == OCSM_NOTHING_PREVIOUSLY_STORED  ) return ocsm_nothing_previously_stored;

    if (icode == OCSM_SOLVER_IS_OPEN             ) return ocsm_solver_is_open;
    if (icode == OCSM_SOLVER_IS_NOT_OPEN         ) return ocsm_solver_is_not_open;
    if (icode == OCSM_TOO_MANY_SOLVER_VARS       ) return ocsm_too_many_solver_vars;
    if (icode == OCSM_UNDERCONSTRAINED           ) return ocsm_underconstrained;
    if (icode == OCSM_OVERCONSTRAINED            ) return ocsm_overconstrained;
    if (icode == OCSM_SINGULAR_MATRIX            ) return ocsm_singular_matrix;
    if (icode == OCSM_NOT_CONVERGED              ) return ocsm_not_converged;

    if (icode == OCSM_UDP_ERROR1                 ) return ocsm_udp_error1;
    if (icode == OCSM_UDP_ERROR2                 ) return ocsm_udp_error2;
    if (icode == OCSM_UDP_ERROR3                 ) return ocsm_udp_error3;
    if (icode == OCSM_UDP_ERROR4                 ) return ocsm_udp_error4;
    if (icode == OCSM_UDP_ERROR5                 ) return ocsm_udp_error5;
    if (icode == OCSM_UDP_ERROR6                 ) return ocsm_udp_error6;
    if (icode == OCSM_UDP_ERROR7                 ) return ocsm_udp_error7;
    if (icode == OCSM_UDP_ERROR8                 ) return ocsm_udp_error8;
    if (icode == OCSM_UDP_ERROR9                 ) return ocsm_udp_error9;

    if (icode == OCSM_OP_STACK_UNDERFLOW         ) return ocsm_op_stack_underflow;
    if (icode == OCSM_OP_STACK_OVERFLOW          ) return ocsm_op_stack_overflow;
    if (icode == OCSM_RPN_STACK_UNDERFLOW        ) return ocsm_rpn_stack_underflow;
    if (icode == OCSM_RPN_STACK_OVERFLOW         ) return ocsm_rpn_stack_overflow;
    if (icode == OCSM_TOKEN_STACK_UNDERFLOW      ) return ocsm_token_stack_underflow;
    if (icode == OCSM_TOKEN_STACK_OVERFLOW       ) return ocsm_token_stack_overflow;
    if (icode == OCSM_UNSUPPORTED                ) return ocsm_unsupported;
    if (icode == OCSM_INTERNAL_ERROR             ) return ocsm_internal_error;

    /* EGADS errors */
    if (icode == EGADS_NOTFOUND                  ) return egads_notfound;
    if (icode == EGADS_NULLOBJ                   ) return egads_nullobj;
    if (icode == EGADS_NOTOBJ                    ) return egads_notobj;
    if (icode == EGADS_MALLOC                    ) return egads_malloc;
    if (icode == EGADS_INDEXERR                  ) return egads_indexerr;
    if (icode == EGADS_NONAME                    ) return egads_noname;
    if (icode == EGADS_NODATA                    ) return egads_nodata;
    if (icode == EGADS_MIXCNTX                   ) return egads_mixcntx;
    if (icode == EGADS_NOTCNTX                   ) return egads_notcntx;
    if (icode == EGADS_NOTXFORM                  ) return egads_notxform;
    if (icode == EGADS_REFERCE                   ) return egads_referce;
    if (icode == EGADS_NOTTOPO                   ) return egads_nottopo;
    if (icode == EGADS_EMPTY                     ) return egads_empty;
    if (icode == EGADS_NOTTESS                   ) return egads_nottess;
    if (icode == EGADS_NOTGEOM                   ) return egads_notgeom;
    if (icode == EGADS_RANGERR                   ) return egads_rangerr;
    if (icode == EGADS_NOLOAD                    ) return egads_noload;
    if (icode == EGADS_NOTMODEL                  ) return egads_notmodel;
    if (icode == EGADS_WRITERR                   ) return egads_writerr;
    if (icode == EGADS_NOTBODY                   ) return egads_notbody;
    if (icode == EGADS_GEOMERR                   ) return egads_geomerr;
    if (icode == EGADS_TOPOERR                   ) return egads_topoerr;
    if (icode == EGADS_CONSTERR                  ) return egads_consterr;
    if (icode == EGADS_DEGEN                     ) return egads_degen;
    if (icode == EGADS_NOTORTHO                  ) return egads_notortho;
    if (icode == EGADS_BADSCALE                  ) return egads_badscale;
    if (icode == EGADS_OCSEGFLT                  ) return egads_ocsegflt;
    if (icode == EGADS_TOPOCNT                   ) return egads_topocnt;
    if (icode == EGADS_ATTRERR                   ) return egads_attrerr;
    if (icode == EGADS_EXISTS                    ) return egads_exists;

    /* default return */
    return unknown;
}


/*
 ************************************************************************
 *                                                                      *
 *   ocsmGetCode - convert text to an OCSM code                         *
 *                                                                      *
 ************************************************************************
 */

int
ocsmGetCode(char   *text)               /* (in)  text to look up */
{

    /* --------------------------------------------------------------- */

    /* OCSM_SUCCESS */
    if (strcmp(text, "success"   ) == 0) return SUCCESS;

    /* not a branch */
    if (strcmp(text, "dimension" ) == 0) return OCSM_DIMENSION;
    if (strcmp(text, "lbound"    ) == 0) return OCSM_LBOUND;
    if (strcmp(text, "ubound"    ) == 0) return OCSM_UBOUND;
    if (strcmp(text, "name"      ) == 0) return OCSM_NAME;
    if (strcmp(text, "attribute" ) == 0) return OCSM_ATTRIBUTE;
    if (strcmp(text, "csystem"   ) == 0) return OCSM_CSYSTEM;
    if (strcmp(text, "end"       ) == 0) return OCSM_END;

    /* OCSM_PRIMITIVE */
    if (strcmp(text, "point"     ) == 0) return OCSM_POINT;
    if (strcmp(text, "box"       ) == 0) return OCSM_BOX;
    if (strcmp(text, "sphere"    ) == 0) return OCSM_SPHERE;
    if (strcmp(text, "cone"      ) == 0) return OCSM_CONE;
    if (strcmp(text, "cylinder"  ) == 0) return OCSM_CYLINDER;
    if (strcmp(text, "torus"     ) == 0) return OCSM_TORUS;
    if (strcmp(text, "import"    ) == 0) return OCSM_IMPORT;
    if (strcmp(text, "udprim"    ) == 0) return OCSM_UDPRIM;
    if (strcmp(text, "restore"   ) == 0) return OCSM_RESTORE;

    /* OCSM_GROWN */
    if (strcmp(text, "extrude"   ) == 0) return OCSM_EXTRUDE;
    if (strcmp(text, "rule"      ) == 0) return OCSM_RULE;
    if (strcmp(text, "loft"      ) == 0) return OCSM_LOFT;
    if (strcmp(text, "blend"     ) == 0) return OCSM_BLEND;
    if (strcmp(text, "revolve"   ) == 0) return OCSM_REVOLVE;
    if (strcmp(text, "sweep"     ) == 0) return OCSM_SWEEP;

    /* OCSM_APPLIED */
    if (strcmp(text, "fillet"    ) == 0) return OCSM_FILLET;
    if (strcmp(text, "chamfer"   ) == 0) return OCSM_CHAMFER;
    if (strcmp(text, "hollow"    ) == 0) return OCSM_HOLLOW;
    if (strcmp(text, "connect"   ) == 0) return OCSM_CONNECT;

    /* OCSM_BOOLEAN */
    if (strcmp(text, "intersect" ) == 0) return OCSM_INTERSECT;
    if (strcmp(text, "subtract"  ) == 0) return OCSM_SUBTRACT;
    if (strcmp(text, "union"     ) == 0) return OCSM_UNION;
    if (strcmp(text, "join"      ) == 0) return OCSM_JOIN;
    if (strcmp(text, "extract"   ) == 0) return OCSM_EXTRACT;
    if (strcmp(text, "combine"   ) == 0) return OCSM_COMBINE;

    /* OCSM_TRANSFORM */
    if (strcmp(text, "translate" ) == 0) return OCSM_TRANSLATE;
    if (strcmp(text, "rotatex"   ) == 0) return OCSM_ROTATEX;
    if (strcmp(text, "rotatey"   ) == 0) return OCSM_ROTATEY;
    if (strcmp(text, "rotatez"   ) == 0) return OCSM_ROTATEZ;
    if (strcmp(text, "scale"     ) == 0) return OCSM_SCALE;
    if (strcmp(text, "mirror"    ) == 0) return OCSM_MIRROR;
    if (strcmp(text, "applycsys" ) == 0) return OCSM_APPLYCSYS;
    if (strcmp(text, "reorder"   ) == 0) return OCSM_REORDER;

    /* OCSM_SKETCH */
    if (strcmp(text, "skbeg"     ) == 0) return OCSM_SKBEG;
    if (strcmp(text, "skcon"     ) == 0) return OCSM_SKCON;
    if (strcmp(text, "skvar"     ) == 0) return OCSM_SKVAR;
    if (strcmp(text, "linseg"    ) == 0) return OCSM_LINSEG;
    if (strcmp(text, "cirarc"    ) == 0) return OCSM_CIRARC;
    if (strcmp(text, "arc"       ) == 0) return OCSM_ARC;
    if (strcmp(text, "spline"    ) == 0) return OCSM_SPLINE;
    if (strcmp(text, "sslope"    ) == 0) return OCSM_SSLOPE;
    if (strcmp(text, "bezier"    ) == 0) return OCSM_BEZIER;
    if (strcmp(text, "skend"     ) == 0) return OCSM_SKEND;

    /* OCSM_SOLVER */
    if (strcmp(text, "solbeg"    ) == 0) return OCSM_SOLBEG;
    if (strcmp(text, "solcon"    ) == 0) return OCSM_SOLCON;
    if (strcmp(text, "solend"    ) == 0) return OCSM_SOLEND;

    /* OCSM_UTILITY */
    if (strcmp(text, "interface" ) == 0) return OCSM_INTERFACE;
    if (strcmp(text, "end"       ) == 0) return OCSM_END;
    if (strcmp(text, "set"       ) == 0) return OCSM_SET;
    if (strcmp(text, "evaluate"  ) == 0) return OCSM_EVALUATE;
    if (strcmp(text, "getattr"   ) == 0) return OCSM_GETATTR;
    if (strcmp(text, "udparg"    ) == 0) return OCSM_UDPARG;
    if (strcmp(text, "select"    ) == 0) return OCSM_SELECT;
    if (strcmp(text, "project"   ) == 0) return OCSM_PROJECT;
    if (strcmp(text, "macbeg"    ) == 0) return OCSM_MACBEG;
    if (strcmp(text, "macend"    ) == 0) return OCSM_MACEND;
    if (strcmp(text, "recall"    ) == 0) return OCSM_RECALL;
    if (strcmp(text, "store"     ) == 0) return OCSM_STORE;
    if (strcmp(text, "patbeg"    ) == 0) return OCSM_PATBEG;
    if (strcmp(text, "patbreak"  ) == 0) return OCSM_PATBREAK;
    if (strcmp(text, "patend"    ) == 0) return OCSM_PATEND;
    if (strcmp(text, "ifthen"    ) == 0) return OCSM_IFTHEN;
    if (strcmp(text, "elseif"    ) == 0) return OCSM_ELSEIF;
    if (strcmp(text, "else"      ) == 0) return OCSM_ELSE;
    if (strcmp(text, "endif"     ) == 0) return OCSM_ENDIF;
    if (strcmp(text, "throw"     ) == 0) return OCSM_THROW;
    if (strcmp(text, "catbeg"    ) == 0) return OCSM_CATBEG;
    if (strcmp(text, "catend"    ) == 0) return OCSM_CATEND;
    if (strcmp(text, "mark"      ) == 0) return OCSM_MARK;
    if (strcmp(text, "group"     ) == 0) return OCSM_GROUP;
    if (strcmp(text, "dump"      ) == 0) return OCSM_DUMP;
    if (strcmp(text, "assert"    ) == 0) return OCSM_ASSERT;
    if (strcmp(text, "message"   ) == 0) return OCSM_MESSAGE;
    if (strcmp(text, "special"   ) == 0) return OCSM_SPECIAL;

    /* Branch classes */
    if (strcmp(text, "primitive" ) == 0) return OCSM_PRIMITIVE;
    if (strcmp(text, "grown"     ) == 0) return OCSM_GROWN;
    if (strcmp(text, "applied"   ) == 0) return OCSM_APPLIED;
    if (strcmp(text, "boolean"   ) == 0) return OCSM_BOOLEAN;
    if (strcmp(text, "transform" ) == 0) return OCSM_TRANSFORM;
    if (strcmp(text, "sketch"    ) == 0) return OCSM_SKETCH;
    if (strcmp(text, "solver"    ) == 0) return OCSM_SOLVER;
    if (strcmp(text, "utility"   ) == 0) return OCSM_UTILITY;

    /* Branch activities */
    if (strcmp(text, "active"    ) == 0) return OCSM_ACTIVE;
    if (strcmp(text, "suppressed") == 0) return OCSM_SUPPRESSED;
    if (strcmp(text, "inactive"  ) == 0) return OCSM_INACTIVE;
    if (strcmp(text, "deferred"  ) == 0) return OCSM_DEFERRED;

    /* Body types */
    if (strcmp(text, "solid_body") == 0) return OCSM_SOLID_BODY;
    if (strcmp(text, "sheet_body") == 0) return OCSM_SHEET_BODY;
    if (strcmp(text, "wire_body" ) == 0) return OCSM_WIRE_BODY;
    if (strcmp(text, "node_body" ) == 0) return OCSM_NODE_BODY;
    if (strcmp(text, "null_body" ) == 0) return OCSM_NULL_BODY;

    /* Parameter types */
    if (strcmp(text, "despmtr"   ) == 0) return OCSM_DESPMTR;
    if (strcmp(text, "cfgpmtr"   ) == 0) return OCSM_CFGPMTR;
    if (strcmp(text, "conpmtr"   ) == 0) return OCSM_CONPMTR;
    if (strcmp(text, "localvar"  ) == 0) return OCSM_LOCALVAR;
    if (strcmp(text, "outpmtr"   ) == 0) return OCSM_OUTPMTR;
    if (strcmp(text, "unknown"   ) == 0) return OCSM_UNKNOWN;

    /* Selector type */
    if (strcmp(text, "node"      ) == 0) return OCSM_NODE;
    if (strcmp(text, "edge"      ) == 0) return OCSM_EDGE;
    if (strcmp(text, "face"      ) == 0) return OCSM_FACE;
    if (strcmp(text, "body"      ) == 0) return OCSM_BODY;
    if (strcmp(text, "eedge"     ) == 0) return OCSM_EEDGE;
    if (strcmp(text, "eface"     ) == 0) return OCSM_EFACE;
    if (strcmp(text, "ebody"     ) == 0) return OCSM_EBODY;

    return 0;
}


/*
 ************************************************************************
 *                                                                      *
 *   addTraceToEdge - add __trace__ to Edge                             *
 *                                                                      *
 ************************************************************************
 */

static int
addTraceToEdge(modl_T *MODL,
              int    ibody,
              int    iedge)
{
    int   status = EGADS_SUCCESS;

    int     attrType, attrLen, i, *newList=NULL, ibody_old, iedge_old, one=1;
    CINT    *tempIlist;

    ROUTINE(addTraceToEdge);

    /* --------------------------------------------------------------- */

    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    if (status == EGADS_NOTFOUND) attrLen = 0;

    MALLOC(newList, int, attrLen+2);

    for (i = 0; i < attrLen; i++) {
        newList[i] = tempIlist[i];
    }
    newList[attrLen  ] = ibody;
    newList[attrLen+1] = iedge;

    status = EG_attributeAdd(MODL->body[ibody].edge[iedge].eedge, "__trace__",
                             ATTRINT, attrLen+2, newList, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    /* determine if this Edge is a trimmed version of its predecessor */
    if (attrLen > 0 && MODL->nbrch > 0) {
        if (MODL->brch[MODL->body[ibody].ibrch].bclass == OCSM_BOOLEAN) {
            ibody_old = newList[attrLen-2];
            iedge_old = newList[attrLen-1];

            status = EG_isEquivalent(MODL->body[ibody_old].edge[iedge_old].eedge,
                                     MODL->body[ibody    ].edge[iedge    ].eedge);
            CHECK_STATUS(EG_isEquivalent);

            if (status == EGADS_OUTSIDE) {
                status = EG_attributeAdd(MODL->body[ibody].edge[iedge].eedge, "__trimmed__",
                                         ATTRINT, 1, &one, NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);
            }
        }
    }

cleanup:
    FREE(newList);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   addTraceToFace - add __trace__ to Face                             *
 *                                                                      *
 ************************************************************************
 */

static int
addTraceToFace(modl_T *MODL,
              int    ibody,
              int    iface)
{
    int   status = EGADS_SUCCESS;

    int     attrType, attrLen, i, *newList=NULL, ibody_old, iface_old, one=1;
    CINT    *tempIlist;

    ROUTINE(addTraceToFace);

    /* --------------------------------------------------------------- */

    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    if (status == EGADS_NOTFOUND) attrLen = 0;

    MALLOC(newList, int, attrLen+2);

    for (i = 0; i < attrLen; i++) {
        newList[i] = tempIlist[i];
    }
    newList[attrLen  ] = ibody;
    newList[attrLen+1] = iface;

    status = EG_attributeAdd(MODL->body[ibody].face[iface].eface, "__trace__",
                             ATTRINT, attrLen+2, newList, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    /* raise an error if _hist and __trace__ do not agree */
    {
        int  attrType2, attrLen2;
        CINT *tempIlist2;
        status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_hist",
                                 &attrType2, &attrLen2, &tempIlist2, NULL, NULL);
        CHECK_STATUS(EG_attributeRet);

        for (i = 0; i <=attrLen; i+=2) {
            if (newList[i] != tempIlist2[i/2]) {
                printf("__trace__ mismatch: ibody=%d, iface=%d, __trace__=%d, hist=%d\n", ibody, iface, newList[i], tempIlist2[i/2]);
            }
        }
    }

    /* determine if this Face is a trimmed version of its predecessor */
    if (attrLen > 0 && MODL->nbrch > 0) {
        if (MODL->brch[MODL->body[ibody].ibrch].bclass == OCSM_BOOLEAN) {
            ibody_old = newList[attrLen-2];
            iface_old = newList[attrLen-1];

            status = EG_isEquivalent(MODL->body[ibody_old].face[iface_old].eface,
                                     MODL->body[ibody    ].face[iface    ].eface);
            CHECK_STATUS(EG_isEquivalent);

            if (status == EGADS_OUTSIDE) {
                status = EG_attributeAdd(MODL->body[ibody].face[iface].eface, "__trimmed__",
                                         ATTRINT, 1, &one, NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);
            }
        }
    }

cleanup:
    FREE(newList);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   addTraceToNode - add __trace__ to Node                             *
 *                                                                      *
 ************************************************************************
 */

static int
addTraceToNode(modl_T *MODL,
              int    ibody,
              int    inode)
{
    int   status = EGADS_SUCCESS;

    int     attrType, attrLen, i, *newList=NULL;
    CINT    *tempIlist;

    ROUTINE(addTraceToNode);

    /* --------------------------------------------------------------- */

    status = EG_attributeRet(MODL->body[ibody].node[inode].enode, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    if (status == EGADS_NOTFOUND) attrLen = 0;

    MALLOC(newList, int, attrLen+2);

    for (i = 0; i < attrLen; i++) {
        newList[i] = tempIlist[i];
    }
    newList[attrLen  ] = ibody;
    newList[attrLen+1] = inode;

    status = EG_attributeAdd(MODL->body[ibody].node[inode].enode, "__trace__",
                             ATTRINT, attrLen+2, newList, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

cleanup:
    FREE(newList);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildApplied - implement OCSM_APPLIEDs for ocsmBuild               *
 *                                                                      *
 ************************************************************************
 */

static int
buildApplied(modl_T *modl,              /* (in)  pointer to MODL */
             int    ibrch,              /* (in)  Branch index (1:nbrch) */
             varg_T args[],             /* (in)  array of arguments */
             int    *nstack,            /* (both) number of Bodys on stack */
             int    stack[],            /* (both) array  of Bodys on stack */
             int    npatn,              /* (in)   number of patterns */
             patn_T patn[])             /* (both) array  of patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        nelist, *ielist=NULL, *iford1=NULL, *iford2=NULL;
    int        itype, nlist, type, hasdots, i, j, iedge, iface, nface, nedge, nloop;
    int        jford1, jford2, ibody, ibodyl, iprnt, jbrch, ipair, npair;
    CINT       *tempIlist;
    double     toler;
    CDOUBLE    *tempRlist;
    CCHAR      *tempClist;

    int        iford, nremove=0, nf, oclass, mtype, nchild, *senses, imatch, ilist;
    int        nfacemap, *facemap1=NULL, *facemap2=NULL, iswap;
    double     data[4];
    ego        ebody, ebodyl, *eedges, *efaces, emodel, eref, *echilds;
    ego        *eelist=NULL, *eflist=NULL, eshell, *eloops, eloop, eface;

    ROUTINE(buildApplied);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "fillet radius edgeList=0 listStyle=0" */
    if (type == OCSM_FILLET) {
        SPRINT4(1, "    executing [%4d] fillet:     %11.5f  %s  %11.5f",
                ibrch, args[1].val[0], MODL->brch[ibrch].arg2, args[3].val[0]);
        if (args[1].dot[0] != 0) {
            hasdots = 1;

            SPRINT1(1, "                                 %11.5f",
                       args[1].dot[0]);
        }

        /* require finite differences */
        MODL->needFDs = 1;

        /* check for a positive radius */
        if (args[1].val[0] <= 0) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius (%f) must be positive", args[1].val[0]);
            goto cleanup;
        }

        /* pop a Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "FILLET expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that ibodyl is not a Sketch */
        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "FILLET does not expect a Sketch on the stack");
            goto cleanup;
        }

        /* cycle back from ibodyl to find the closest left parent Body that
           was either a PRIMITIVE, GROWN, or BOOLEAN */
        iprnt = ibodyl;
        while (iprnt != 0) {
            jbrch = MODL->body[iprnt].ibrch;
            if (MODL->brch[jbrch].bclass == OCSM_PRIMITIVE ||
                MODL->brch[jbrch].bclass == OCSM_GROWN     ||
                MODL->brch[jbrch].bclass == OCSM_BOOLEAN     ) break;
            iprnt = MODL->body[iprnt].ileft;
        }

        /* initialize the list of Edges to which fillets should be applied */
        nelist = 0;
        MALLOC(ielist, int, MODL->body[ibodyl].nedge);

        /* apply fillet to all Edges if edgeList=0 AND parent is a RESTORE */
        if (args[2].nval == 1 && args[2].val[0] == 0  &&
            MODL->body[ibodyl].brtype == OCSM_RESTORE  ) {

            for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {
                ielist[nelist++] = iedge;
            }

        /* apply fillet to all Edges in edgeList if listStyle=1 */
        } else if (args[3].val[0] != 0) {
            nelist = args[2].nval;
            if (nelist < 1) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "edgeList must contain at least one Edge");
                goto cleanup;
            }

            for (i = 0; i < nelist; i++) {
                ielist[i] = NINT(args[2].val[i]);
            }

        /* apply fillet to all Edges if edgeList=0 OR iprnt is a Boolean */
        } else if ((args[2].nval == 1 && args[2].val[0] == 0) ||
                   MODL->body[iprnt].brtype == OCSM_INTERSECT ||
                   MODL->body[iprnt].brtype == OCSM_SUBTRACT  ||
                   MODL->body[iprnt].brtype == OCSM_UNION     ||
                   MODL->body[iprnt].brtype == OCSM_JOIN        ) {

            ebodyl = MODL->body[ibodyl].ebody;

            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            if (eedges != NULL) {
                for (iedge = 1; iedge <= nedge; iedge++) {
                    status = EG_attributeRet(eedges[iedge-1], "_body",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeRet);

                    if (tempIlist[0] == iprnt) {
                        ielist[nelist++] = iedge;
                    }
                }

                EG_free(eedges);
            }

        /* otherwise, process the edgeList (in order) */
        } else {

            if (args[2].nval%2 != 0) {
                signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                            "not an even number of entries in edgeList");
                goto cleanup;
            }

            npair = args[2].nval / 2;
            MALLOC(iford1, int, npair);
            MALLOC(iford2, int, npair);

            for (ipair = 0; ipair < npair; ipair++) {
                iford1[ipair] = NINT(args[2].val[2*ipair  ]);
                iford2[ipair] = NINT(args[2].val[2*ipair+1]);
            }

            /* make sure that we have at least one pair */
            if (npair <= 0) {
                SET_STATUS(OCSM_ILLEGAL_PMTR_NAME, fillet);
            }

            /* process the pairs */
            for (ipair = 0; ipair < npair; ipair++) {

                /* add all Edges to ielist */
                if (iford1[ipair] == 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            if (tempIlist[0] == iprnt) {
                                ielist[nelist++] = iedge;
                            }
                        }

                        EG_free(eedges);
                    }

                /* add Edges adjacent to +iford1[ipair] */
                } else if (iford1[ipair] > 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            jford1 = tempIlist[1] % 10000;
                            jford2 = tempIlist[1] / 10000;

                            if (tempIlist[0] == iprnt) {
                                if (jford1 == iford1[ipair] || jford2 == iford1[ipair]) {
                                    ielist[nelist++] = iedge;
                                }
                            }
                        }

                        EG_free(eedges);
                    }

                /* remove all Edges adjacent to -iford1[ipair] */
                } else if (iford1[ipair] < 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            jford1 = tempIlist[1] % 10000;
                            jford2 = tempIlist[1] / 10000;

                            if (tempIlist[0] == iprnt) {
                                if (jford1 == -iford1[ipair] || jford2 == -iford1[ipair]) {
                                    for (j = 0; j < nelist; j++) {
                                        if (ielist[j] == iedge) {
                                            ielist[j] = 0;
                                    }
                                    }
                                }
                            }
                        }

                        EG_free(eedges);
                    }

                /* add Edges adjacent to +iford1[ipair] and +iford2[ipair] */
                } else if (iford1[ipair] > 0 && iford2[ipair] > 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            jford1 = tempIlist[1] % 10000;
                            jford2 = tempIlist[1] / 10000;

                            if (tempIlist[0] == iprnt) {
                                if        (jford1 == iford1[ipair] && jford2 == iford2[ipair]) {
                                    ielist[nelist++] = iedge;
                                } else if (jford1 == iford2[ipair] && jford2 == iford1[ipair]) {
                                    ielist[nelist++] = iedge;
                            }
                            }
                        }

                        EG_free(eedges);
                    }

                /* remove Edges adjacent to -iford1[ipair] and -iford2[ipair] */
                } else if (iford1[ipair] < 0 && iford2[ipair] < 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            jford1 = tempIlist[1] % 10000;
                            jford2 = tempIlist[1] / 10000;

                            if (tempIlist[0] == iprnt) {
                                if ((jford1 == -iford1[ipair] && jford2 == -iford2[ipair]) ||
                                    (jford1 == -iford2[ipair] && jford2 == -iford1[ipair])   ) {
                                    for (j = 0; j < nelist; j++) {
                                        if (ielist[j] == iedge) {
                                            ielist[j] = 0;
                                        }
                                    }
                                }
                            }
                        }

                        EG_free(eedges);
                    }
                }
            }
        }

        /* remove deleted entries from the ielist */
        for (j = 0; j < nelist; j++) {
            if (ielist[j] == 0) {
                ielist[j] = ielist[nelist-1];
                nelist--;
                j--;
            }
        }

        /* create the fillets */
        if (nelist > 0) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_FILLET, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            MALLOC(eelist, ego, nelist);

            if (eedges != NULL) {
                for (i = 0; i < nelist; i++) {
                    if (ielist[i] < 1 || ielist[i] > nedge) {
                        signalError(MODL, OCSM_EDGE_NOT_FOUND,
                                    "%d is not a valid Edge number", ielist[i]);
                        FREE(eelist);
                        EG_free(eedges);
                        goto cleanup;
                    }

                    SPRINT1(2, "        fillet with iedge=%d", ielist[i]);
                    eelist[i] = eedges[ielist[i]-1];
                }

                EG_free(eedges);
            }

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_filletBody: ebodyl");
                ocsmPrintEgo(ebodyl);
            }
            status = EG_filletBody(ebodyl, nelist, eelist, args[1].val[0], &ebody, NULL);
            if (status < SUCCESS) {
                signalError(MODL, status,
                            "FILLET failed");
                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

            FREE(ielist);
            FREE(eelist);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (FILLET) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces with the current Body */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (efaces != NULL) {
                for (iface = 1; iface <= nface; iface++) {
                    status = EG_attributeRet(efaces[iface-1], "_body",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    if (status == EGADS_NOTFOUND) {
                        status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                        CHECK_STATUS(setFaceAttribute);
                    } else {
                        CHECK_STATUS(EG_attributeRet);
                    }
                }

                EG_free(efaces);
            }

            /* finish the Body (FILLET) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);
        } else {
            SPRINT0(1, "WARNING:: no edges for fillet");
            (MODL->nwarn)++;
            ibody = ibodyl;
        }

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "chamfer radius edgeList=0 listStyle=0" */
    } else if (type == OCSM_CHAMFER) {
        SPRINT4(1, "    executing [%4d] chamfer:    %11.5f  %s  %11.5f",
                ibrch, args[1].val[0], MODL->brch[ibrch].arg2, args[3].val[0]);
        if (args[1].dot[0] != 0) {
            hasdots = 1;

            SPRINT1(1, "                                 %11.5f",
                       args[1].dot[0]);
        }

        /* require finite differences */
        MODL->needFDs = 1;

        /* check for a positive radius */
        if (args[1].val[0] <= 0) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius (%f) must be positive", args[1].val[0]);
            goto cleanup;
        }

        /* pop a Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "CHAMFER expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that ibodyl is not a Sketch */
        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "CHAMFER does not expect a Sketch on the stack");
            goto cleanup;
        }

        /* cycle back from ibodyl to find the closest left parent Body that
           was either a PRIMITIVE, GROWN, or BOOLEAN */
        iprnt = ibodyl;
        while (iprnt != 0) {
            jbrch = MODL->body[iprnt].ibrch;
            if (MODL->brch[jbrch].bclass == OCSM_PRIMITIVE ||
                MODL->brch[jbrch].bclass == OCSM_GROWN     ||
                MODL->brch[jbrch].bclass == OCSM_BOOLEAN     ) break;
            iprnt = MODL->body[iprnt].ileft;
        }

        /* initialize the list of Edges to which chamfers should be applied */
        nelist = 0;
        MALLOC(ielist, int, MODL->body[ibodyl].nedge);

        /* apply chamfer to all Edges if edgeList=0 AND parent is a RESTORE */
        if (args[2].nval == 1 && args[2].val[0] == 0  &&
            MODL->body[ibodyl].brtype == OCSM_RESTORE  ) {

            for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {
                ielist[nelist++] = iedge;
            }

        /* apply chamfer to all Edges in edgeList if listStyle=1 */
        } else if (args[3].val[0] != 0) {
            nelist = args[2].nval;
            if (nelist < 1) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "edgeList must contain at least one Edge");
                goto cleanup;
            }

            for (i = 0; i < nelist; i++) {
                ielist[i] = NINT(args[2].val[i]);
            }

        /* apply chamfer to all Edges if edgeList=0 OR iprnt is a Boolean */
        } else if ((args[2].nval == 1 && args[2].val[0] == 0) ||
                   MODL->body[iprnt].brtype == OCSM_INTERSECT ||
                   MODL->body[iprnt].brtype == OCSM_SUBTRACT  ||
                   MODL->body[iprnt].brtype == OCSM_UNION     ||
                   MODL->body[iprnt].brtype == OCSM_JOIN        ) {

            ebodyl = MODL->body[ibodyl].ebody;

            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            if (eedges != NULL) {
                for (iedge = 1; iedge <= nedge; iedge++) {
                    status = EG_attributeRet(eedges[iedge-1], "_body",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeRet);

                    if (tempIlist[0] == iprnt) {
                        ielist[nelist++] = iedge;
                    }
                }

                EG_free(eedges);
            }

        /* otherwise, process the edgeList (in order) */
        } else {

            if (args[2].nval%2 != 0) {
                signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                            "not an even number of entries in edgeList");
                goto cleanup;
            }

            npair = args[2].nval / 2;
            MALLOC(iford1, int, npair);
            MALLOC(iford2, int, npair);

            for (ipair = 0; ipair < npair; ipair++) {
                iford1[ipair] = NINT(args[2].val[2*ipair  ]);
                iford2[ipair] = NINT(args[2].val[2*ipair+1]);
            }

            /* make sure that we have at least one pair */
            if (npair <= 0) {
                SET_STATUS(OCSM_ILLEGAL_PMTR_NAME, chamfer);
            }

            /* process the pairs */
            for (ipair = 0; ipair < npair; ipair++) {

                /* add all Edges to ielist */
                if (iford1[ipair] == 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            if (tempIlist[0] == iprnt) {
                                ielist[nelist++] = iedge;
                            }
                        }

                        EG_free(eedges);
                    }

                /* add Edges adjacent to +iford1[ipair] */
                } else if (iford1[ipair] > 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            jford1 = tempIlist[1] % 10000;
                            jford2 = tempIlist[1] / 10000;

                            if (tempIlist[0] == iprnt) {
                                if (jford1 == iford1[ipair] || jford2 == iford1[ipair]) {
                                    ielist[nelist++] = iedge;
                                }
                            }
                        }

                        EG_free(eedges);
                    }

                /* remove all Edges adjacent to -iford1[ipair] */
                } else if (iford1[ipair] < 0 && iford2[ipair] == 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            jford1 = tempIlist[1] % 10000;
                            jford2 = tempIlist[1] / 10000;

                            if (tempIlist[0] == iprnt) {
                                if (jford1 == -iford1[ipair] || jford2 == -iford1[ipair]) {
                                    for (j = 0; j < nelist; j++) {
                                        if (ielist[j] == iedge) {
                                            ielist[j] = 0;
                                        }
                                    }
                                }
                            }
                        }

                        EG_free(eedges);
                    }

                /* add Edges adjacent to +iford1[ipair] and +iford2[ipair] */
                } else if (iford1[ipair] > 0 && iford2[ipair] > 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            jford1 = tempIlist[1] % 10000;
                            jford2 = tempIlist[1] / 10000;

                            if (tempIlist[0] == iprnt) {
                                if        (jford1 == iford1[ipair] && jford2 == iford2[ipair]) {
                                    ielist[nelist++] = iedge;
                                } else if (jford1 == iford2[ipair] && jford2 == iford1[ipair]) {
                                    ielist[nelist++] = iedge;
                            }
                            }
                        }

                        EG_free(eedges);
                    }

                /* remove Edges adjacent to -iford1[ipair] and -iford2[ipair] */
                } else if (iford1[ipair] < 0 && iford2[ipair] < 0) {
                    ebodyl = MODL->body[ibodyl].ebody;

                    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            status = EG_attributeRet(eedges[iedge-1], "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            jford1 = tempIlist[1] % 10000;
                            jford2 = tempIlist[1] / 10000;

                            if (tempIlist[0] == iprnt) {
                                if ((jford1 == -iford1[ipair] && jford2 == -iford2[ipair]) ||
                                    (jford1 == -iford2[ipair] && jford2 == -iford1[ipair])   ) {
                                    for (j = 0; j < nelist; j++) {
                                        if (ielist[j] == iedge) {
                                            ielist[j] = 0;
                                        }
                                    }
                                }
                            }
                        }

                        EG_free(eedges);
                    }
                }
            }
        }

        /* remove deleted entries from the ielist */
        for (j = 0; j < nelist; j++) {
            if (ielist[j] == 0) {
                ielist[j] = ielist[nelist-1];
                nelist--;
                j--;
            }
        }

        /* create the chamfers */
        if (nelist > 0) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_CHAMFER, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            MALLOC(eelist, ego, nelist);
            MALLOC(eflist, ego, nelist);

            if (eedges != NULL) {
                for (i = 0; i < nelist; i++) {
                    if (ielist[i] < 1 || ielist[i] > nedge) {
                        signalError(MODL, OCSM_EDGE_NOT_FOUND,
                                    "%d is not a valid Edge number", ielist[i]);
                        FREE(eelist);
                        EG_free(eedges);
                        goto cleanup;
                    }

                    SPRINT1(2, "        chamfer with iedge=%d", ielist[i]);
                    eelist[i] = eedges[ielist[i]-1];

                    status = EG_getBodyTopos(ebodyl, eelist[i], FACE, &nf, &efaces);
                    CHECK_STATUS(EG_getBodyTopos);

                    eflist[i] = efaces[0];
                    EG_free(efaces);
                }

                EG_free(eedges);
            }

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_chamferBody: ebodyl");
                ocsmPrintEgo(ebodyl);
            }
            status = EG_chamferBody(ebodyl, nelist, eelist, eflist, args[1].val[0], args[1].val[0], &ebody, NULL);
            if (status < SUCCESS) {
                signalError(MODL, status,
                            "CHAMFER failed");
                goto cleanup;
            }

            FREE(eelist);
            FREE(eflist);
            FREE(ielist);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (CHAMFER) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces with the current Body */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (efaces != NULL) {
                for (iface = 1; iface <= nface; iface++) {
                    status = EG_attributeRet(efaces[iface-1], "_body",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    if (status == EGADS_NOTFOUND) {
                        status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                        CHECK_STATUS(setFaceAttribute);
                    } else {
                        CHECK_STATUS(EG_attributeRet);
                    }
                }

                EG_free(efaces);
            }

            /* finish the Body (CHAMFER) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);
        } else {
            SPRINT0(1, "WARNING:: no edges for chamfer");
            (MODL->nwarn)++;
            ibody = ibodyl;
        }

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "hollow thick=0 entList=0 listStyle=0" */
    } else if (type == OCSM_HOLLOW) {
        SPRINT4(1, "    executing [%4d] hollow:     %11.5f  %s  %s",
                ibrch, args[1].val[0], MODL->brch[ibrch].arg2, MODL->brch[ibrch].arg3);
        if (args[1].dot[0] != 0) {
            hasdots = 1;

            SPRINT1(1, "                                 %11.5f",
                    args[1].dot[0]);
        }

        /* require finite differences */
        MODL->needFDs = 1;

        /* pop an Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "HOLLOW expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* normal hollow command of a SolidBody (with possible Face(s) removed)*/
        if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY && args[1].val[0] != 0) {

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            /* generate offset Body */
            if (args[2].nval == 1 && args[2].val[0] == 0) {
                SPRINT0(2, "HOLLOW cases C (larger SolidBody) & D (smaller SolidBody)");

                nremove = 0;

            /* make list of Faces that will be partially removed (iface given) */
            } else if (args[3].val[0] != 0) {
                SPRINT0(2, "HOLLOW cases E (smaller SolidBody with iface cut) & F (larger SolidBody with iface cut)");

                MALLOC(eflist, ego, args[2].nval);

                nremove = 0;
                for (i = 0; i < args[2].nval; i++) {
                    iface = NINT(args[2].val[i]);

                    eflist[nremove++] = MODL->body[ibodyl].face[iface].eface;
                }

            /* make list of Faces that will be partially removed (ibody/iford given) */
            } else {
                SPRINT0(2, "HOLLOW cases E (smaller SolidBody with ibody/iford cut) & F (larger SolidBody with ibody/iford cut)");

                if (args[2].nval%2 != 0) {
                    signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                                "not an even number of entries in faceList");
                    (*nstack)++;
                    goto cleanup;
                }

                npair = args[2].nval / 2;
                MALLOC(iford1, int, npair);
                MALLOC(iford2, int, npair);

                for (i = 0; i < npair; i++) {
                    iford1[i] = NINT(args[2].val[2*i  ]);
                    iford2[i] = NINT(args[2].val[2*i+1]);
                }

                nremove = 0;
                MALLOC(eflist, ego, MODL->body[ibodyl].nface);

                status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                if (efaces != NULL) {
                    for (iface = 1; iface <= nface; iface++) {
                        status = EG_attributeRet(efaces[iface-1], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        for (ipair = 0; ipair < npair; ipair++) {
                            if (tempIlist[0] == iford1[ipair] &&
                                tempIlist[1] == iford2[ipair]   ) {
                                eflist[nremove++] = efaces[iface-1];
                            }
                        }
                    }

                    EG_free(efaces);
                }
            }

            /* generate the hollow */
            if (outLevel >= 3) {
                SPRINT0(3, "before EG_hollowBody: ebodyl");
                ocsmPrintEgo(ebodyl);

                if (eflist != NULL) {
                    for (i = 0; i < nremove; i++) {
                        SPRINT1(3, "    Face %d to remove", i);
                        ocsmPrintEgo(eflist[i]);
                    }
                }

                SPRINT2(3, "off=%f, join=%d", args[1].val[0], 1);
            }

            /* note: facemap1 freed below */
            status = EG_hollowBody(ebodyl, nremove, eflist, args[1].val[0], 1, &ebody, &facemap1);
            if (status != EGADS_SUCCESS) {
                (void) freeBody(MODL, ibody);
                MODL->nbody--;

                status = OCSM_DID_NOT_CREATE_BODY;
                signalError(MODL, status,
                            "HOLLOW failed to produce a Body");
                (*nstack)++;
                goto cleanup;
            }

            MODL->body[ibody].ebody = ebody;

        /* convert SolidBody to SheetBody (with possible Face(s) removed) */
        } else if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY) {
            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_copyObject);

            status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(efaces);

            /* extract the Shell (if no Faces are to be removed) */
            if (args[2].nval == 1 && args[2].val[0] == 0) {
                SPRINT0(2, "HOLLOW case A (convert SolidBody to SheetBody)");

                status = EG_makeTopology(MODL->context, NULL, SHELL, CLOSED,
                                         NULL, nface, efaces, NULL, &eshell);
                CHECK_STATUS(EG_makeTopology);

            /* make a new Shell and remove Faces that were listed in entList (iface given) */
            } else if (args[3].val[0] != 0) {
                SPRINT0(2, "HOLLOW case B (convert SolidBody to SheetBody with iface removed)");

                for (i = 0; i < args[2].nval; i++) {
                    iface = NINT(args[2].val[i]);
                    efaces[iface-1] = efaces[nface-1];
                    nface--;
                }

                if (outLevel >= 3) {
                    for (iface = 0; iface < nface; iface++) {
                        SPRINT1(3, "efaces[%d]:", iface);
                        ocsmPrintEgo(efaces[iface]);
                    }
                }

                status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                         NULL, nface, efaces, NULL, &eshell);
                CHECK_STATUS(EG_makeTopology);

            /* make a new Shell and remove Faces that were listed in faceList (ibody/iford given) */
            } else {
                SPRINT0(2, "HOLLOW case B (convert SolidBody to SheetBody with ibody/iford removed)");

                if (args[2].nval%2 != 0) {
                    signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                                "not an even number of entries in faceList");
                    (*nstack)++;
                    goto cleanup;
                }

                for (ipair = 0; ipair < args[2].nval/2; ipair++) {
                    for (iface = nface-1; iface >= 0; iface--) {
                        status = EG_attributeRet(efaces[iface], "_body",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        if (tempIlist[0] == NINT(args[2].val[2*ipair  ]) &&
                            tempIlist[1] == NINT(args[2].val[2*ipair+1])   ) {
                            efaces[iface] = efaces[nface-1];
                            nface--;
                        }
                    }
                }

                if (outLevel >= 3) {
                    for (iface = 0; iface < nface; iface++) {
                        SPRINT1(3, "efaces[%d]:", iface);
                        ocsmPrintEgo(efaces[iface]);
                    }
                }

                status=EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                       NULL, nface, efaces, NULL, &eshell);
                CHECK_STATUS(EG_makeTopology);
            }

            /* make the new SheetBody */
            status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            EG_free(efaces);

            MODL->body[ibody].ebody = ebody;

        /* normal hollow command of a single-Face SheetBody (with possible Edge(s) removed) */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyl].nface  == 1               &&
                   args[1].val[0] != 0                            ) {
            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (nface != 1) {
                signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                            "Body must only have one Face");
                (*nstack)++;
                goto cleanup;
            }
            SPLINT_CHECK_FOR_NULL(efaces);

            ebodyl = efaces[0];

            /* generate offset Body */
            if (args[2].nval == 1 && args[2].val[0] == 0) {
                SPRINT0(2, "HOLLOW cases I (smaller SheetBody) & J (larger SheetBody");

                nremove = 0;

            /* make a list of Edges that will be partially removed (iedge given) */
            } else {
                SPRINT0(2, "HOLLOW cases K (smaller SheetBody with iedge cut) & L (larger SheetBody with iedge cut");

                MALLOC(eelist, ego, args[2].nval);

                nremove = 0;
                for (i = 0; i < args[2].nval; i++) {
                    iedge = NINT(args[2].val[i]);

                    eelist[nremove++] = MODL->body[ibodyl].edge[iedge].eedge;
                }
            }

            /* generate the hollow */
            if (outLevel >= 3) {
                SPRINT0(3, "before EG_hollowBody: ebodyl");
                ocsmPrintEgo(ebodyl);

                if (eelist != NULL) {
                    for (i = 0; i < nremove; i++) {
                        SPRINT1(3, "    Edge %d to remove", i);
                        ocsmPrintEgo(eelist[i]);
                    }
                }

                SPRINT2(3, "off=%f, join=%d", args[1].val[0], 1);
            }

            /* try using EG_hollowBody, and if it fails, try EG_makeFace */
            status = EG_hollowBody(ebodyl, nremove, eelist, args[1].val[0], 1, &eface, NULL);
            if (status != EGADS_SUCCESS) {
                FREE(eelist);

                status = OCSM_DID_NOT_CREATE_BODY;
                signalError(MODL, status,
                            "HOLLOW failed to produce a Body");
                (*nstack)++;
                goto cleanup;
            }

            FREE(eelist);

            status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
                                     NULL, 1, &eface, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            EG_free(efaces);

        /* convert single-Face SheetBody to WireBody (with possible Edge(s) removed) */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyl].nface  == 1                 ) {
            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_copyObject);

            /* extract the Loop (if no Edges are to be removed) */
            if (args[2].nval == 1 && args[2].val[0] == 0) {
                SPRINT0(2, "HOLLOW case G (convert SheetBody to WireBody)");

                status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloop, &eloops);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(eloops);

                eloop = eloops[0];

                EG_free(eloops);

            /* make a new Loop and remove Edges that were listed in entList (iedge given) */
            } else {
                SPRINT0(2, "HOLLOW case H (convert SheetBody to WireBody with iedge removed)");

                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(eedges);

                for (i = 0; i < args[2].nval; i++) {
                    iedge = NINT(args[2].val[i]);
                    eedges[iedge-1] = eedges[nedge-1];
                    nedge--;
                }

                if (outLevel >= 3) {
                    for (iedge = 0; iedge < nedge; iedge++) {
                        SPRINT1(3, "eedges[%d]:", iedge);
                        ocsmPrintEgo(eedges[iedge]);
                    }
                }

                status = EG_makeLoop(nedge, eedges, NULL, 0, &eloop);
                CHECK_STATUS(EG_makeLoop);

                EG_free(eedges);
            }

            /* make the new WireBody */
            status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                     NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

        /* handle multi-Face SheetBody */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            /* remove Faces (if they are connected) */
            if (args[1].val[0] == 0 && args[2].val[0] != 0) {

                /* recycle old Body if not dirty */
                status = recycleBody(MODL, ibrch, type, args, hasdots);
                CHECK_STATUS(recycleBody);

                if (status == 1) {
                    stack[(*nstack)++] = MODL->nbody;
                    status = SUCCESS;
                    goto cleanup;
                }

                status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
                CHECK_STATUS(EG_copyObject);

                status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(efaces);

                /* if Face is not skipped, put it into efaces2 */
                for (iface = nface; iface >= 1; iface--) {
                    imatch = 0;

                    if (args[2].val[0] > 0) {
                        if (args[3].val[0] != 0) {
                            SPRINT0(2, "HOLLOW case M (SheetBody with iface removed)");

                            for (ilist = 0; ilist < args[2].nval; ilist++) {
                                if (iface == NINT(args[2].val[ilist])) {
                                    imatch = 1;
                                    break;
                                }
                            }
                        } else if (args[2].nval%2 == 0) {
                            SPRINT0(2, "HOLLOW case M (SheetBody with ibody/iford removed)");

                            status = EG_attributeRet(MODL->body[ibodyl].face[iface].eface, "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            for (ilist = 0; ilist < args[2].nval; ilist+=2) {
                                if (tempIlist[0] == NINT(args[2].val[ilist  ]) &&
                                    tempIlist[1] == NINT(args[2].val[ilist+1])   ) {
                                    imatch = 1;
                                    break;
                                }
                            }
                        } else {
                            signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                                        "not an even number of entries in entList");
                            (*nstack)++;
                            goto cleanup;
                        }
                    }

                    /* skip this Face */
                    if (imatch == 1) {
                        efaces[iface-1] = efaces[nface-1];
                        nface--;
                    }
                }

                /* sew the Faces together into a SheetBody */
                if (nface == 0) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "no Faces left");
                    (*nstack)++;
                    goto cleanup;
                } else if (nface == 1) {
                    status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                             NULL, 1, efaces, NULL, &eshell);
                    CHECK_STATUS(EG_makeTopology);

                    status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                             NULL, 1, &eshell, NULL, &ebody);
                    CHECK_STATUS(EG_makeTopology);
                } else {
                    status = EG_sewFaces(nface, efaces, 0, 1, &emodel);
                    CHECK_STATUS(EG_sewFaces);

                    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                            data, &nchild, &echilds, &senses);
                    CHECK_STATUS(EG_getTopology);

                    ebody = echilds[0];
                }

                /* make the new SheetBody */
                status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);

                MODL->body[ibody].ebody = ebody;

                EG_free(efaces);

            /* hollow all Faces or those in entList */
            } else if (args[1].val[0] > 0) {

                /* recycle old Body if not dirty */
                status = recycleBody(MODL, ibrch, type, args, hasdots);
                CHECK_STATUS(recycleBody);

                if (status == 1) {
                    stack[(*nstack)++] = MODL->nbody;
                    status = SUCCESS;
                    goto cleanup;
                }

                status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
                CHECK_STATUS(EG_copyObject);

                status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(efaces);

                /* pull each Face out, hollow it, and put result bask into efaces */
                for (iface = 0; iface < nface; iface++) {
                    imatch = 0;

                    /* skip face if not in entList */
                    if (args[2].val[0] > 0) {

                        if (args[3].val[0] != 0) {
                            SPRINT0(2, "HOLLOW case P (SheetBody with iface cut)");

                            for (ilist = 0; ilist < args[2].nval; ilist++) {
                                if (iface+1 == NINT(args[2].val[ilist])) {
                                    imatch = 1;
                                    break;
                                }
                            }
                        } else if (args[2].nval%2 == 0) {
                            SPRINT0(2, "HOLLOW case P (SheetBody with ibody/iford cut)");

                            status = EG_attributeRet(MODL->body[ibodyl].face[iface+1].eface, "_body",
                                                     &itype, &nlist,
                                                     &tempIlist, &tempRlist, &tempClist);
                            CHECK_STATUS(EG_attributeRet);

                            for (ilist = 0; ilist < args[2].nval; ilist+=2) {
                                if (tempIlist[0] == NINT(args[2].val[ilist  ]) &&
                                    tempIlist[1] == NINT(args[2].val[ilist+1])   ) {
                                    imatch = 1;
                                    break;
                                }
                            }
                        } else {
                            signalError(MODL, OCSM_ILLEGAL_ARGUMENT,
                                        "not an even number of entries in entList");
                            (*nstack)++;
                            goto cleanup;
                        }
                    } else {
                        SPRINT0(2, "HOLLOW case N (SheetBody with all Faces cut)");

                        imatch = 1;
                    }

                    if (imatch == 1) {

                        if (outLevel >= 3) {
                            SPRINT1(3, "before EG_hollowBody: efaces[%d]", iface);
                            ocsmPrintEgo(efaces[iface]);

                            SPRINT2(3, "off=%f, join=%d", args[1].val[0], 1);
                        }

                        status = EG_hollowBody(efaces[iface], 0, NULL, args[1].val[0], 1, &eface, NULL);
                        if (status != EGADS_SUCCESS) {
                            status = OCSM_DID_NOT_CREATE_BODY;

                            signalError(MODL, status,
                                        "HOLLOW failed to produce a Body");
                            (*nstack)++;
                            goto cleanup;
                        }

                        efaces[iface] = eface;
                    }
                }

                /* sew the Faces together into a SheetBody */
                status = EG_sewFaces(nface, efaces, 0, 1, &emodel);
                CHECK_STATUS(EG_sewFaces);

                status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebody = echilds[0];

                /* make the new SheetBody */
                status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);

                MODL->body[ibody].ebody = ebody;

                EG_free(efaces);

            /* illegal operation */
            } else {
                SET_STATUS(OCSM_ILLEGAL_VALUE, hollow);
            }

        /* otherwise an error */
        } else {
            SET_STATUS(OCSM_ILLEGAL_VALUE, hollow);
        }

        /* update @-parameters (HOLLOW) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (facemap1 == NULL) {
            iford = 0;
            for (iface = 1; iface <= nface; iface++) {
                SPLINT_CHECK_FOR_NULL(efaces);

                status = EG_attributeRet(efaces[iface-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);

                if (status == EGADS_NOTFOUND) {
                    iford++;
                    status = setFaceAttribute(MODL, ibody, iface, 0, iford, npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                } else {
                    CHECK_STATUS(EG_attributeRet);
                }
            }
        } else {
            MALLOC(facemap2, int, 4*nface);

            /* make a list of the faceID of the Face from which new Faces are offset */
            nfacemap = 0;
            for (iface = 1; iface <= nface; iface++) {
                SPLINT_CHECK_FOR_NULL(efaces);

                status = EG_attributeRet(efaces[iface-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);

                if (status == EGADS_NOTFOUND) {
                    if (facemap1[2*iface-2] != FACEOFF) {
                        signalError(MODL, OCSM_INTERNAL_ERROR,
                                    "facemap1[iface=%d]=%d %d", iface, facemap1[2*iface-2], facemap1[2*iface-1]);
                        EG_free(efaces);
                        SET_STATUS(OCSM_INTERNAL_ERROR, hollow);
                    } else {
                        i = facemap1[2*iface-1];

                        status = EG_attributeRet(MODL->body[ibodyl].face[i].eface, "_faceID",
                                                 &itype, &nlist,
                                                 &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeRet);

                        facemap2[4*nfacemap  ] = iface;
                        facemap2[4*nfacemap+1] = tempIlist[0];
                        facemap2[4*nfacemap+2] = tempIlist[1];
                        facemap2[4*nfacemap+3] = tempIlist[2];
                        nfacemap++;
                    }
                }
            }

            /* sort the facemap2 in faceID order */
            for (i = 0; i < nfacemap; i++) {
                for (j = i+1; j < nfacemap; j++) {
                    iswap = 0;

                    if (facemap2[4*j+1] < facemap2[4*i+1]) {
                        iswap = 1;
                    } else if (facemap2[4*j+1] == facemap2[4*i+1]) {
                        if (facemap2[4*j+2] < facemap2[4*i+2]) {
                            iswap = 1;
                        } else if (facemap2[4*j+2] == facemap2[4*i+2]) {
                            if (facemap2[4*j+3] < facemap2[4*i+3]) {
                                iswap = 1;
                            }
                        }
                    }

                    if (iswap > 0) {
                        iswap           = facemap2[4*i  ];
                        facemap2[4*i  ] = facemap2[4*j  ];
                        facemap2[4*j  ] = iswap;

                        iswap           = facemap2[4*i+1];
                        facemap2[4*i+1] = facemap2[4*j+1];
                        facemap2[4*j+1] = iswap;

                        iswap           = facemap2[4*i+2];
                        facemap2[4*i+2] = facemap2[4*j+2];
                        facemap2[4*j+2] = iswap;

                        iswap           = facemap2[4*i+3];
                        facemap2[4*i+3] = facemap2[4*j+3];
                        facemap2[4*j+3] = iswap;
                    }
                }
            }

            /* apply the faceID to the Faces in facemap2 */
            for (i = 0; i < nfacemap; i++) {
                iface = facemap2[4*i  ];

                status = setFaceAttribute(MODL, ibody, iface, 0, i+1, npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }
            FREE(   facemap2);
            EG_free(facemap1);
            facemap1 = NULL;
        }

        EG_free(efaces);

        /* finish the Body (HOLLOW) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);
    }

cleanup:
    FREE(eelist);
    FREE(eflist);
    FREE(facemap2);
    if (facemap1 != NULL) EG_free(facemap1);

    FREE(iford1);
    FREE(iford2);
    FREE(ielist);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildBoolean - implement OCSM_BOOLEANs for ocsmBuild               *
 *                                                                      *
 ************************************************************************
 */

static int
buildBoolean(modl_T *modl,              /* (in)  pointer to MODL */
             int    ibrch,              /* (in)  Branch index (1:nbrch) */
             varg_T args[],             /* (in)  array of arguments */
             int    *nstack,            /* (both) number of Bodys on stack */
             int    stack[],            /* (both) array  of Bodys on stack */
             int    npatn,              /* (in)   number of patterns */
             patn_T patn[])             /* (both) array  of patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        type, hasdots, toMark;
    int        ibody, ibodyl, ibodyr, index, nnewedges, attrType, attrLen;
    int        i, j, k, keep, nchild, nchange, numBodys, bodyList[999];
    int        numRemaining, count, match;
    double     toler, maxtol;
    char       order[MAX_EXPR_LEN];

    int         oclass, mtype, *senses, nface, nedge, nshell, ntemp;
    int         iedge, iface, senses1[1], nedges, bodyType, inode, iedgel, iedger;
    int         nfacedg, inbodyl, inbodyr, ichild, botype, ibegl, ibegr, iendl, iendr;
    int         fillstyle=0, itype, nlist, *indx=NULL, ii, swap;
    int         nnn, nEdgeList, nEdgeListl, nEdgeListr, iii, jjj, iadd;
    int         *sensesl, *sensesr, *sensesc=NULL, nFaceList, *newSenses=NULL, nchild2, *senses2;

    int         isub, nloopl, nloopr, *idatal, *idatar;
    CINT        *tempIlist;
    double      data[20], xyz[3], dirn[4], matrix[12], areal, arear, bbox1[6], bbox2[6], dot;
    double      xyz0[3], xyz1[3], xyz2[3], xyz3[3], dist02, dist03, dist12, dist13;
    double      *datal, *datar, norml[4], normr[4], uv[2], fswap, *xyzbeg=NULL, *xyzend=NULL;
    CDOUBLE     *tempRlist;
    CCHAR       *tempClist;
    ego         ebody, ebodyl, ebodyr, emodel, eref, *ebodys, *echilds=NULL, *etemp=NULL;
    ego         *eshells=NULL, *efaces=NULL, *eedges, *elist=NULL;
    ego         eface, eloop, *efacedgs;
    ego         etemp1, etemp2, exform, etopref, eprev, enext;
    ego         *enewEdges=NULL, *enewFaces=NULL;
    ego         *nnnList, *edgeList=NULL, *edgeListl, *edgeListr, *faceList=NULL, eloops[2];
    ego         enodes[2], eedges2[8], eshell, *enewedges;
    ego         *eloopsl, *eloopsr, *eloopsc=NULL, esurfl, esurfr;
    ego         *newEdges=NULL, *echilds2, ebeg, eend, eswap;

    ROUTINE(buildBoolean);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "intersect $order=none index=1 maxtol=0" */
    if (type == OCSM_INTERSECT) {
        SPRINT4(1, "    executing [%4d] intersect:  %s  %11.5f  %11.4e",
                ibrch, args[1].str, args[2].val[0], args[3].val[0]);

        /* make sure valid $order was given */
        if (strcmp(args[1].str, "none") != 0 && strcmp(args[1].str, "0"   ) != 0 &&
            strcmp(args[1].str, "xmin") != 0 && strcmp(args[1].str, "xmax") != 0 &&
            strcmp(args[1].str, "ymin") != 0 && strcmp(args[1].str, "ymax") != 0 &&
            strcmp(args[1].str, "zmin") != 0 && strcmp(args[1].str, "zmax") != 0 &&
            strcmp(args[1].str, "amin") != 0 && strcmp(args[1].str, "amax") != 0 &&
            strcmp(args[1].str, "vmin") != 0 && strcmp(args[1].str, "vmax") != 0   ) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "$order (%s) is not a valid value", args[1].str);
            goto cleanup;
        }

        /* pop 2 Bodys from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "INTERSECT expects 2 Bodys on the stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that at least one Body is a SolidBody */
        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY &&
            MODL->body[ibodyr].botype != OCSM_SOLID_BODY   ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "INTERSECT expects at least one SolidBody");
            goto cleanup;
        }

        /* extract the arguments */
        STRNCPY(order, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);
        index  = NINT(args[2].val[0]);
        maxtol =      args[3].val[0];

        /* create the new Body */
        if        (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {
            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            botype = OCSM_SOLID_BODY;
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            ebodyr = MODL->body[ibodyr].ebody;

            botype = OCSM_SHEET_BODY;
        } else if (MODL->body[ibodyr].botype == OCSM_SHEET_BODY) {
            status = EG_copyObject(MODL->body[ibodyr].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            ebodyr = MODL->body[ibodyl].ebody;

            botype = OCSM_SHEET_BODY;
        } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {
            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            ebodyr = MODL->body[ibodyr].ebody;

            botype = OCSM_WIRE_BODY;
        } else if (MODL->body[ibodyr].botype == OCSM_WIRE_BODY) {
            status = EG_copyObject(MODL->body[ibodyr].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &ebody, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            ebodyr = MODL->body[ibodyl].ebody;

            botype = OCSM_WIRE_BODY;
        } else {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "INTERSECT ran into an unexpected condition");
            goto cleanup;
        }

        status = newBody(MODL, ibrch, OCSM_INTERSECT, ibodyl, ibodyr,
                         args, hasdots, botype, &ibody);
        CHECK_STATUS(newBody);

        status = solidBoolean(MODL, ebodyl, ebodyr, INTERSECTION, maxtol, &emodel);
        if (status < 0) {
            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                        "INTERSECT did not create a Body");

            (void) freeBody(MODL, ibody);
            MODL->nbody--;
            goto cleanup;
        }
        CHECK_STATUS(solidBoolean);

        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY ||
            MODL->body[ibodyr].botype != OCSM_SOLID_BODY   ) {
            status = EG_deleteObject(ebodyl);
            CHECK_STATUS(EG_deleteObject);
        }

        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                data, &nchild, &ebodys, &senses);
        CHECK_STATUS(EG_getTopology);

        if (nchild < 1) {
            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                        "INTERSECT did not create a Body");
            (void) freeBody(MODL, ibody);
            MODL->nbody--;
            goto cleanup;
        } else if (index > nchild) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "INTERSECT only created %d Bodys but index=%d", nchild, index);

            (void) freeBody(MODL, ibody);
            MODL->nbody--;
            goto cleanup;
        }

        if (index >= 0) {
            i = selectBody(emodel, order, index);
        } else {
            i = selectBody(emodel, order, 1);
        }

        status = EG_copyObject(ebodys[i], NULL, &ebody);
        CHECK_STATUS(EG_copyObject);

        MODL->body[ibody].ebody = ebody;

        if (nchild > 1) {
            if (index == -1) {

                for (j = 2; j <= nchild; j++) {

                    /* keep track of number of Bodys remaining from this command */
                    numRemaining = nchild + 1 - j;
                    status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                             1, &numRemaining, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    /* update @-parameters (SUBTRACT) and finish Body */
                    status = setupAtPmtrs(MODL, 0);
                    CHECK_STATUS(setupAtPmtrs);

                    status = finishBody(MODL, ibody);
                    if (MODL->sigCode != SUCCESS) goto cleanup;
                    CHECK_STATUS(finishBody);

                    /* push the Body onto the stack */
                    stack[(*nstack)++] = ibody;

                    status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                    CHECK_STATUS(getBodyTolerance);

                    SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                            ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

                    /* create the new Body */
                    status = newBody(MODL, ibrch, OCSM_INTERSECT, ibodyl, ibodyr,
                                     args, hasdots, botype, &ibody);
                    CHECK_STATUS(newBody);

                    i = selectBody(emodel, order, j);

                    status = EG_copyObject(ebodys[i], NULL, &ebody);
                    CHECK_STATUS(EG_copyObject);

                    /*@ignore@*/
                    MODL->body[ibody].ebody = ebody;
                    /*@end@*/
                }
            } else {
                SPRINT1(1, "WARNING:: %d Bodys are being lost", nchild-1);
                (MODL->nwarn)++;
            }
        }

        status = EG_deleteObject(emodel);
        CHECK_STATUS(EG_deleteObject);

        /* update @-parameters (INTERSECT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "subtract $order=none index=1 maxtol=0" */
    } else if (type == OCSM_SUBTRACT) {
        SPRINT4(1, "    executing [%4d] subtract:   %s  %11.5f  %11.4e",
                ibrch, args[1].str, args[2].val[0], args[3].val[0]);

        /* make sure valid $order was given */
        if (strcmp(args[1].str, "none") != 0 && strcmp(args[1].str, "0"   ) != 0 &&
            strcmp(args[1].str, "xmin") != 0 && strcmp(args[1].str, "xmax") != 0 &&
            strcmp(args[1].str, "ymin") != 0 && strcmp(args[1].str, "ymax") != 0 &&
            strcmp(args[1].str, "zmin") != 0 && strcmp(args[1].str, "zmax") != 0 &&
            strcmp(args[1].str, "amin") != 0 && strcmp(args[1].str, "amax") != 0 &&
            strcmp(args[1].str, "vmin") != 0 && strcmp(args[1].str, "vmax") != 0   ) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "$order (%s) is not a valid value", args[1].str);
            goto cleanup;
        }

        /* pop 2 Bodys from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "SUBTRACT expects 2 Bodys on stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* extract the arguments */
        STRNCPY(order, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);
        index  = NINT(args[2].val[0]);
        maxtol =      args[3].val[0];

        /* if ibodyl is not a NodeBody but ibodyr is a NodeBody,
           split any Edges at the NodeBody */
        if (MODL->body[ibodyl].botype != OCSM_NODE_BODY &&
            MODL->body[ibodyr].botype == OCSM_NODE_BODY   ) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, MODL->body[ibodyl].botype, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = NULL;

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            SPLINT_CHECK_FOR_NULL(ebodyl);
            SPLINT_CHECK_FOR_NULL(ebodyr);

            status = EG_generalBoolean(ebodyl, ebodyr, SPLITTER, maxtol, &emodel);
            if (status < 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }
            CHECK_STATUS(EG_generalBoolean);

            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &ebodys, &senses);
            CHECK_STATUS(EG_getTopology);

            if (nchild < 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

            status = EG_copyObject(ebodys[0], NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].ebody = ebody;

        /* if both ibodyl and ibodyr are SolidBodys, perform Boolean
           opertion */
        } else if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = NULL;

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            SPLINT_CHECK_FOR_NULL(ebodyl);
            SPLINT_CHECK_FOR_NULL(ebodyr);

            status = solidBoolean(MODL, ebodyl, ebodyr, SUBTRACTION, maxtol, &emodel);
            if (status < 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }
            CHECK_STATUS(solidBoolean);

            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &ebodys, &senses);
            CHECK_STATUS(EG_getTopology);

            if (nchild < 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            } else if (index > nchild) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "SUBTRACT only created %d Bodys but index=%d", nchild, index);

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

            if (index >= 0) {
                i = selectBody(emodel, order, index);
            } else {
                i = selectBody(emodel, order, 1);
            }

            if (i < SUCCESS) {
                status = i;
                CHECK_STATUS(selectBody);
            }

            status = EG_copyObject(ebodys[i], NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            /*@ignore@*/
            MODL->body[ibody].ebody = ebody;
            /*@end@*/

            if (nchild > 1) {
                if (index == -1) {

                    for (j = 2; j <= nchild; j++) {

                        /* keep track of number of Bodys remaining from this command */
                        numRemaining = nchild + 1 - j;
                        status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                                 1, &numRemaining, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* update @-parameters (SUBTRACT) and finish Body */
                        status = setupAtPmtrs(MODL, 0);
                        CHECK_STATUS(setupAtPmtrs);

                        status = finishBody(MODL, ibody);
                        if (MODL->sigCode != SUCCESS) goto cleanup;
                        CHECK_STATUS(finishBody);

                        /* push the Body onto the stack */
                        stack[(*nstack)++] = ibody;

                        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                        CHECK_STATUS(getBodyTolerance);

                        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

                        /* create the new Body */
                        status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                                         args, hasdots, OCSM_SOLID_BODY, &ibody);
                        CHECK_STATUS(newBody);

                        i = selectBody(emodel, order, j);

                        status = EG_copyObject(ebodys[i], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        /*@ignore@*/
                        MODL->body[ibody].ebody = ebody;
                        /*@end@*/
                    }
                } else {
                    SPRINT1(1, "WARNING:: %d Bodys are being lost", nchild-1);
                    (MODL->nwarn)++;
                }
            }

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

        /* ibodyl is a SolidBody and ibodyr is a SheetBody, so scribe ibodyl */
        } else if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            if (outLevel >= 3) {
                SPRINT0(1, "before EG_intersection: ebodyl");
                ocsmPrintEgo(ebodyl);
                SPRINT0(1, "before EG_intersection: ebodyr");
                ocsmPrintEgo(ebodyr);
            }

            efacedgs = NULL;
            status = EG_intersection(ebodyl, ebodyr, &nfacedg, &efacedgs, &emodel);
            if (status < 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "INTERSECTION did not create a Body");
                goto cleanup;
            }
            CHECK_STATUS(EG_intersection);
            SPLINT_CHECK_FOR_NULL(efacedgs);

            if (outLevel >= 3) {
                SPRINT0(1, "after EG_intersection\nemodel");
                ocsmPrintEgo(emodel);
                for (i = 0; i <  2*nfacedg; i++) {
                    SPRINT1(1, "efacedgs[%d]", i);
                    ocsmPrintEgo(efacedgs[i]);
                }
            }

            status = EG_imprintBody(ebodyl, nfacedg, efacedgs, &ebody);
            if (status < 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "IMPRINT failed");
                goto cleanup;
            }
            CHECK_STATUS(EG_imprintBody);

            /* try to transfer _faceID info from the Edges that got returned
               from EG_intersection onto the Edges that were created in
               EG_imprintBody (but with the name __scribeID__) */
            status = EG_getBodyTopos(ebody, NULL, EDGE,
                                     &nnewedges, &enewedges);
            CHECK_STATUS(EG_getBodyTopos);

            if (enewedges != NULL) {
                for (i = 1; i < 2*nfacedg; i+=2) {
                    status = EG_attributeRet(efacedgs[i], "_faceID", &attrType, &attrLen,
                                             &tempIlist, &tempRlist, &tempClist);
                    if (status == EGADS_SUCCESS) {
                        status = EG_getBoundingBox(efacedgs[i], bbox1);
                        CHECK_STATUS(EG_getBoundingBox);

                        for (j = 0; j < nnewedges; j++) {
                            status = EG_getBoundingBox(enewedges[j], bbox2);
                            CHECK_STATUS(EG_getBoundingBox);

                            if (fabs(bbox1[0]-bbox2[0]) < EPS03 &&
                                fabs(bbox1[1]-bbox2[1]) < EPS03 &&
                                fabs(bbox1[2]-bbox2[2]) < EPS03 &&
                                fabs(bbox1[3]-bbox2[3]) < EPS03 &&
                                fabs(bbox1[4]-bbox2[4]) < EPS03 &&
                                fabs(bbox1[5]-bbox2[5]) < EPS03   ) {
                                status = EG_attributeAdd(enewedges[j], "__scribeID__", ATTRINT,
                                                         attrLen, tempIlist, NULL, NULL);
                                CHECK_STATUS(EG_attributeAdd);

                                break;
                            }
                        }
                    }
                }

                EG_free(enewedges);
            }

            if (emodel != NULL) {
                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);
            }

            EG_free(efacedgs);
            efacedgs = NULL;

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a SheetBody and ibodyr is a SheetBody */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            /* check to see if we should perform subtraction (rather than scribing) */
            isub = 1;

            /* for subtraction, both SheetBodys must have a single Face */
            if (MODL->body[ibodyl].nface != 1) isub = 0;
            if (MODL->body[ibodyr].nface != 1) isub = 0;

            /* for subtraction,  both surfaces must be PLANEs */
            status = EG_getTopology(MODL->body[ibodyl].face[1].eface, &esurfl,
                                    &oclass, &mtype, data, &nloopl, &eloopsl, &sensesl);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(esurfl, &oclass, &mtype, &eref, &idatal, &datal);
            CHECK_STATUS(EG_getGeometry);

            if (oclass != SURFACE || mtype != PLANE) {
                isub     = 0;
                norml[0] = 0;
                norml[1] = 0;
                norml[2] = 1;
            } else {
                norml[0]  = datal[4] * datal[8] - datal[5] * datal[7];
                norml[1]  = datal[5] * datal[6] - datal[3] * datal[8];
                norml[2]  = datal[3] * datal[7] - datal[4] * datal[6];
                norml[3]  = sqrt(norml[0]*norml[0] + norml[1]*norml[1] + norml[2]*norml[2]);
                norml[0] /= norml[3];
                norml[1] /= norml[3];
                norml[2] /= norml[3];
            }

            status = EG_getTopology(MODL->body[ibodyr].face[1].eface, &esurfr,
                                    &oclass, &mtype, data, &nloopr, &eloopsr, &sensesr);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(esurfr, &oclass, &mtype, &eref, &idatar, &datar);
            CHECK_STATUS(EG_getGeometry);

            if (oclass != SURFACE || mtype != PLANE) {
                isub     = 0;
                normr[0] = 0;
                normr[1] = 0;
                normr[2] = 1;
            } else {
                normr[0]  = datar[4] * datar[8] - datar[5] * datar[7];
                normr[1]  = datar[5] * datar[6] - datar[3] * datar[8];
                normr[2]  = datar[3] * datar[7] - datar[4] * datar[6];
                normr[3]  = sqrt(normr[0]*normr[0] + normr[1]*normr[1] + normr[2]*normr[2]);
                normr[0] /= normr[3];
                normr[1] /= normr[3];
                normr[2] /= normr[3];
            }

            /* for subtraction, ibodyr must contain only one Loop */
            if (nloopr != 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "Body2 must contain 1 Loop when SUBTRACTing coplanar SheetBodys");
                goto cleanup;
            }

            /* for subtraction, the surfaces must be coplanar */
            if (isub == 1) {
                dot = norml[0] * normr[0] + norml[1] * normr[1] + norml[2] * normr[2];
                if (fabs(fabs(dot)-1) > EPS06) isub = 0;
            }

            if (isub == 1) {
                status = EG_invEvaluate(esurfr, datal, uv, xyz);
                CHECK_STATUS(EG_invEvaluate);

                if (fabs(datal[0] - xyz[0]) > EPS06 ||
                    fabs(datal[1] - xyz[1]) > EPS06 ||
                    fabs(datal[2] - xyz[2]) > EPS06   ) isub = 0;
            }

            if (idatal != NULL) EG_free(idatal);
            if (idatar != NULL) EG_free(idatar);

            EG_free(datal);
            EG_free(datar);

            /* for subtraction, the left Loop must be larger than the rite Loop */
            if (isub == 1) {
                status = EG_getArea(eloopsl[0], NULL, &areal);
                CHECK_STATUS(EG_getArea);

                status = EG_getArea(eloopsr[0], NULL, &arear);
                CHECK_STATUS(EG_getArea);

                if (fabs(arear) > fabs(areal)) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "Body2 must be smaller than Body1 when SUBTRACTing coplanar SheetBodys");
                    goto cleanup;
                }
            }

            /* subtract one SheetBody from the other by by combining their Loops */
            if (isub == 1) {

                /* make an array of the combined Loops */
                MALLOC(eloopsc, ego, nloopl+1);
                MALLOC(sensesc, int, nloopl+1);

                /* existing Loops in ibodyl first (including the outer Loop) */
                for (i = 0; i < nloopl; i++) {
                    eloopsc[i] = eloopsl[i];
                    sensesc[i] = sensesl[i];
                }

                /* add rge Loop associated with ibodyr as an inner Loop */
                eloopsc[nloopl] = eloopsr[0];
                sensesc[nloopl] = SINNER;

                /* make the Face (with same orientation as ibodyl), Shell,
                   and then new SheetBody */
                status = EG_getTopology(MODL->body[ibodyl].face[1].eface, &esurfl,
                                        &oclass, &mtype, data, &nloopl, &eloopsl, &sensesl);
                CHECK_STATUS(EG_getTopology);

                status = EG_makeTopology(MODL->context, esurfl, FACE, mtype, NULL,
                                         nloopl+1, eloopsc, sensesc, &eface);
                if (status != SUCCESS) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "in-plane SUBTRACTION of SheetBodys failed");
                    goto cleanup;
                }

                /* copy Attributues from ibodyl */
                status = EG_attributeDup(MODL->body[ibodyl].face[1].eface, eface);
                CHECK_STATUS(EG_attributeDup);

                status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN, NULL,
                                         1, &eface, NULL, &eshell);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY, NULL,
                                         1, &eshell, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);

                /* make sure that the Attributes on the inner Body are not deleted */
                status = EG_attributeAdd(ebody, "__keepEdgeAttr__", ATTRSTRING,
                                         STRLEN("yes"), NULL, NULL, "yes");
                CHECK_STATUS(EG_attributeAdd);

            /* subtraction not possible, so scribe ibodyl with ibodyr */
            } else {
                if (outLevel >= 3) {
                    SPRINT0(3, "before EG_intersection: ebodyl");
                    ocsmPrintEgo(ebodyl);
                    SPRINT0(3, "before EG_intersection: ebodyr");
                    ocsmPrintEgo(ebodyr);
                }

                /* note that this code fails for several cases, and therefore
                   will not be used */
//$$$                emodel = NULL;
//$$$                status = EG_generalBoolean(ebodyl, ebodyr, SPLITTER, maxtol, &emodel);
//$$$                if (status < 0) {
//$$$                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
//$$$                                "EG_generalBoolean(SPLITTER) failed (status=%d)", status);
//$$$                    status = OCSM_DID_NOT_CREATE_BODY;
//$$$                    goto cleanup;
//$$$                }
//$$$
//$$$                status = EG_getTopology(emodel, &eref, &oclass, &mtype,
//$$$                                        data, &nchild, &echilds, &senses);
//$$$                CHECK_STATUS(EG_getTopology);
//$$$
//$$$                if (nchild == 1) {
//$$$                    SPLINT_CHECK_FOR_NULL(echilds);
//$$$
//$$$                    status = EG_copyObject(echilds[0], NULL, &ebody);
//$$$                    CHECK_STATUS(EG_copyObject);
//$$$                } else {
//$$$                    status = OCSM_DID_NOT_CREATE_BODY;
//$$$                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
//$$$                                "EG_generalBoolean returned %d Bodys (not 1)", nchild);
//$$$                    goto cleanup;
//$$$                }
//$$$
//$$$                if (emodel != NULL) {
//$$$                    status = EG_deleteObject(emodel);
//$$$                    CHECK_STATUS(EG_deleteObject);
//$$$                }

                /* find intersections and then imprint */
                efacedgs = NULL;
                status = EG_intersection(ebodyl, ebodyr, &nfacedg, &efacedgs, &emodel);
                if (status < 0) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "INTERSECTION did not create a Body");
                    goto cleanup;
                }
                CHECK_STATUS(EG_intersection);
                SPLINT_CHECK_FOR_NULL(efacedgs);

                if (outLevel >= 3) {
                    SPRINT0(3, "before EG_imprintBody: ebodyl");
                    ocsmPrintEgo(ebodyl);
                    for (i = 0; i < nfacedg; i++) {
                        SPRINT1(3, "eface[%d]", i);
                        ocsmPrintEgo(efacedgs[2*i]);
                        SPRINT1(3, "eedge[%d]", i);
                        ocsmPrintEgo(efacedgs[2*i+1]);
                    }
                }

                status = EG_imprintBody(ebodyl, nfacedg, efacedgs, &ebody);
                CHECK_STATUS(EG_imprintBody);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                EG_free(efacedgs);
                efacedgs = NULL;
            }

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a SheetBody and ibodyr is a SolidBody, so perform
           Boolean operation */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            status = EG_copyObject(ebodyl, NULL, &etemp1);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 1, &etemp1, NULL, &etemp2);
            CHECK_STATUS(EG_makeTopology);

            status = solidBoolean(MODL, etemp2, ebodyr, SUBTRACTION, maxtol, &emodel);
            if (status < 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }
            CHECK_STATUS(solidBoolean);

            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &ebodys, &senses);
            CHECK_STATUS(EG_getTopology);

            if (nchild < 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "SUBTRACT did not create a Body");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            } else if (index > nchild) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "SUBTRACT only created %d Bodys but index=%d", nchild, index);

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

            if (index >= 0) {
                i = selectBody(emodel, order, index);
            } else {
                i = selectBody(emodel, order, 1);
            }

            status = EG_copyObject(ebodys[i], NULL, &ebody);
            CHECK_STATUS(EG_copyObject);
            SPLINT_CHECK_FOR_NULL(ebody);

            MODL->body[ibody].ebody = ebody;

            if (nchild > 1) {
                if (index == -1) {

                    for (j = 2; j <= nchild; j++) {

                        /* keep track of number of Bodys remaining from this command */
                        numRemaining = nchild + 1 - j;
                        status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                                 1, &numRemaining, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* update @-parameters (SUBTRACT) and finish Body */
                        status = setupAtPmtrs(MODL, 0);
                        CHECK_STATUS(setupAtPmtrs);

                        status = finishBody(MODL, ibody);
                        if (MODL->sigCode != SUCCESS) goto cleanup;
                        CHECK_STATUS(finishBody);

                        /* push the Body onto the stack */
                        stack[(*nstack)++] = ibody;

                        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                        CHECK_STATUS(getBodyTolerance);

                        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

                        /* create the new Body */
                        status = newBody(MODL, ibrch, OCSM_SUBTRACT, ibodyl, ibodyr,
                                         args, hasdots, OCSM_SHEET_BODY, &ibody);
                        CHECK_STATUS(newBody);

                        i = selectBody(emodel, order, j);

                        status = EG_copyObject(ebodys[i], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        /*@ignore@*/
                        MODL->body[ibody].ebody = ebody;
                        /*@end@*/
                    }
                } else {
                    SPRINT1(1, "WARNING:: %d Bodys are being lost", nchild-1);
                    (MODL->nwarn)++;
                }
            }

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            status = EG_deleteObject(etemp2);
            CHECK_STATUS(EG_deleteObject);

        /* unsupported combination of Body types */
        } else {
            if (outLevel >= 3) {
                SPRINT0(0, "ebodyl");
                ocsmPrintEgo(MODL->body[ibodyl].ebody);
                SPRINT0(0, "ebodyr");
                ocsmPrintEgo(MODL->body[ibodyr].ebody);
            }

            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "unsupported combination of Body types to SUBTRACT");
            goto cleanup;
        }

        /* update @-parameters (SUBTRACT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "union toMark=0 trimList=0 maxtol=0" */
    } else if (type == OCSM_UNION) {
        SPRINT4(1, "    executing [%4d] union:      %11.5f  %s  %11.4e",
                ibrch, args[1].val[0], MODL->brch[ibrch].arg2, args[3].val[0]);

        /* extract the argument */
        toMark = NINT(args[1].val[0]);
        maxtol =      args[3].val[0];
        ibody  = 0;

        /* union top two Bodys on the stack */
        if (toMark == 0) {
            /* pop 2 Bodys from the stack */
            if ((*nstack) < 2) {
                signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                            "UNION expects 2 Bodys on stack");
                goto cleanup;
            } else {
                ibodyr = stack[--(*nstack)];
                ibodyl = stack[--(*nstack)];
            }

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            ebodyl = MODL->body[ibodyl].ebody;
            ebodyr = MODL->body[ibodyr].ebody;

            SPRINT0(2, "ebodyl");
            if (outLevel >= 2) ocsmPrintEgo(ebodyl);

            SPRINT0(2, "ebodyr");
            if (outLevel >= 2) ocsmPrintEgo(ebodyr);

            /* union of 2 SolidBodys */
            if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
                MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {

                /* create the new Body */
                status = newBody(MODL, ibrch, OCSM_UNION, ibodyl, ibodyr,
                                 args, hasdots, OCSM_SOLID_BODY, &ibody);
                CHECK_STATUS(newBody);

                MODL->body[ibody].ebody = NULL;

                /* normal (untrimmed) union of 2 SolidBodys */
                if (args[2].nval < 6) {
                    status = solidBoolean(MODL, ebodyl, ebodyr, FUSION, maxtol, &emodel);
                    if (status < 0) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION did not create a Body");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }
                    CHECK_STATUS(solidBoolean);

                    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                            data, &nchild, &ebodys, &senses);
                    CHECK_STATUS(EG_getTopology);

                    if (nchild == 1) {
                        status = EG_copyObject(ebodys[0], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        MODL->body[ibody].ebody = ebody;
                    } else {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "UNION created %d Bodys", nchild);

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                /* trimmed union of 2 SolidBodys */
                } else {

                    /* determine if given point is in ebodyl or ebodyr */
                    xyz[0] = args[2].val[0];
                    xyz[1] = args[2].val[1];
                    xyz[2] = args[2].val[2];

                    inbodyl = EG_inTopology(ebodyl, xyz);
                    inbodyr = EG_inTopology(ebodyr, xyz);
                    SPRINT2(2, "inbodyl=%d, inbodyr=%d", inbodyl, inbodyr);

                    if        (inbodyl == EGADS_SUCCESS && inbodyr == EGADS_OUTSIDE) {
                    } else if (inbodyl == EGADS_OUTSIDE && inbodyr == EGADS_SUCCESS) {
                        etemp1 = ebodyl;
                        ebodyl = ebodyr;
                        ebodyr = etemp1;
                    } else if (inbodyl == EGADS_SUCCESS && inbodyl == EGADS_SUCCESS) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "trim point is inside both Bodys");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    } else {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "trim point is inside neither Body");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }

                    /* move ebodyl a little opposite the direction given */
                    dirn[0] = args[2].val[3];
                    dirn[1] = args[2].val[4];
                    dirn[2] = args[2].val[5];

                    matrix[ 0] = 1; matrix[ 1] = 0; matrix[ 2] = 0; matrix[ 3] = -dirn[0];
                    matrix[ 4] = 0; matrix[ 5] = 1; matrix[ 6] = 0; matrix[ 7] = -dirn[1];
                    matrix[ 8] = 0; matrix[ 9] = 0; matrix[10] = 1; matrix[11] = -dirn[2];

                    SPRINT4(2, "matrix: %10.5f %10.5f %10.5f %10.5f", matrix[ 0], matrix[ 1], matrix[ 2], matrix[ 3]);
                    SPRINT4(2, "        %10.5f %10.5f %10.5f %10.5f", matrix[ 4], matrix[ 5], matrix[ 6], matrix[ 7]);
                    SPRINT4(2, "        %10.5f %10.5f %10.5f %10.5f", matrix[ 8], matrix[ 9], matrix[10], matrix[11]);

                    status = EG_makeTransform(MODL->context, matrix, &exform);
                    CHECK_STATUS(EG_makeTransform);

                    status = EG_copyObject(ebodyl, exform, &etemp1);
                    CHECK_STATUS(EG_copyObject);

                    status = EG_deleteObject(exform);
                    CHECK_STATUS(EG_deleteObject);

                    /* subtract ebodyr from etemp1 (the moved copy of ebodyl) */
                    if (outLevel >= 2) {
                        SPRINT0(2, "etemp1");
                        ocsmPrintEgo(etemp1);
                        SPRINT0(2, "ebodyr");
                        ocsmPrintEgo(ebodyr);
                    }

                    status = solidBoolean(MODL, etemp1, ebodyr, SUBTRACTION, maxtol, &emodel);

                    if (status < 0) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "trimming SUBTRACTION failed");

                        (void) freeBody(MODL, ibody);
                        MODL->nbody--;
                        goto cleanup;
                    }
                    CHECK_STATUS(solidBoolean);

                    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                            data, &nchild, &ebodys, &senses);
                    CHECK_STATUS(EG_getTopology);

                    SPRINT1(2, "nchild=%d", nchild);

                    /* if more than one Body was created, keep the body that contains the trim point */
                    if (nchild > 1) {
                        etemp2 = NULL;
                        for (ichild = 0; ichild < nchild; ichild++) {
                            inbodyl = EG_inTopology(ebodys[ichild], xyz);
                            if (inbodyl == EGADS_SUCCESS) {

                                /* move the kept Body back to its original position */
                                matrix[ 3] *= -1;
                                matrix[ 7] *= -1;
                                matrix[11] *= -1;

                                status = EG_makeTransform(MODL->context, matrix, &exform);
                                CHECK_STATUS(EG_makeTransform);

                                status = EG_copyObject(ebodys[ichild], exform, &etemp2);
                                CHECK_STATUS(EG_copyObject);

                                status = EG_deleteObject(exform);
                                CHECK_STATUS(EG_deleteObject);
                            }
                        }

                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        if (etemp2 == NULL) {
                            signalError(MODL, OCSM_INTERNAL_ERROR,
                                        "none of the Bodys from the subtraction contain the trim point");

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }

                        if (outLevel >= 2) {
                            SPRINT0(2, "etemp2");
                            ocsmPrintEgo(etemp2);
                            SPRINT0(2, "ebodyr");
                            ocsmPrintEgo(ebodyr);
                        }

                        /* union the kept Body and ibodyr */
                        status = solidBoolean(MODL, etemp2, ebodyr, FUSION, maxtol, &emodel);
                        if (status < 0) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION (with trimmed Body) did not create a Body");

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }
                        CHECK_STATUS(solidBoolean);

                        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                                data, &nchild, &ebodys, &senses);
                        CHECK_STATUS(EG_getTopology);

                        SPRINT1(2, "nchild=%d", nchild);

                        if (nchild != 1) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION (with trimmed Body) created %d Bodys", nchild);

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }

                        status = EG_copyObject(ebodys[0], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        MODL->body[ibody].ebody = ebody;

                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        status = EG_deleteObject(etemp1);
                        CHECK_STATUS(EG_deleteObject);

                        status = EG_deleteObject(etemp2);
                        CHECK_STATUS(EG_deleteObject);

                    /* since subtraction only created one Body, do a simple
                       union of the two original Bodys (after deleting the emodel) */
                    } else {
                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        status = solidBoolean(MODL, ebodyl, ebodyr, FUSION, maxtol, &emodel);
                        if (status < 0) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION did not create a Body");
                            goto cleanup;
                        }
                        CHECK_STATUS(solidBoolean);

                        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                                data, &nchild, &ebodys, &senses);
                        CHECK_STATUS(EG_getTopology);

                        if (nchild != 1) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                        "UNION failed");

                            (void) freeBody(MODL, ibody);
                            MODL->nbody--;
                            goto cleanup;
                        }

                        status = EG_copyObject(ebodys[0], NULL, &ebody);
                        CHECK_STATUS(EG_copyObject);

                        MODL->body[ibody].ebody = ebody;

                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);
                    }
                }

                /* update @-parameters (UNION) and finish Body */
                status = setupAtPmtrs(MODL, 0);
                CHECK_STATUS(setupAtPmtrs);

                status = finishBody(MODL, ibody);
                if (MODL->sigCode != SUCCESS) goto cleanup;
                CHECK_STATUS(finishBody);

            /* union of 2 SheetBodys */
            } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                       MODL->body[ibodyr].botype == OCSM_SHEET_BODY    ) {

                status = EG_fuseSheets(ebodyl, ebodyr, &ebody);
                if (status < 0) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "UNION of two SheetBodys failed");
                    goto cleanup;
                }
                CHECK_STATUS(EG_fuseSheets);

                /* create the new Body */
                status = newBody(MODL, ibrch, OCSM_UNION, ibodyl, ibodyr,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);

                MODL->body[ibody].ebody = ebody;

                /* update @-parameters (UNION) and finish Body */
                status = setupAtPmtrs(MODL, 0);
                CHECK_STATUS(setupAtPmtrs);

                status = finishBody(MODL, ibody);
                if (MODL->sigCode != SUCCESS) goto cleanup;
                CHECK_STATUS(finishBody);
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "UNION expects two SolidBodys or two SheetBodys on stack");
                goto cleanup;
            }

        /* union all SolidBodys back to the mark */
        } else if (toMark == 1) {

            /* make a list of the SolidBodys back to mark */
            numBodys = 0;
            while ((*nstack) > 0) {
                ibodyl = stack[--(*nstack)];

                if (ibodyl == 0) {           /* mark is found */
                    break;
                } else if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "UNION 1 expects SolidBody on stack");

                    (void) freeBody(MODL, ibody);
                    MODL->nbody--;
                    goto cleanup;
                } else {
                    bodyList[numBodys++] = ibodyl;
                }
            }

            numRemaining = numBodys - 1;

            if (numBodys < 2) {
                signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                            "UNION toMark=1 expects 2 or more Bodys since mark");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

            /* recycle old Body if not dirty (note: special treatment to skip
               to last Body that matches this Branch) */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* loop through all pairs of Bodys until finished */
            nchange = 1;
            while (nchange > 0) {
                nchange = 0;

                for (i = numBodys-1; i >= 0; i--) {
                    if (bodyList[i] <= 0) continue;

                    for (j = numBodys-1; j >= 0; j--) {
                        if (bodyList[j] <= 0) continue;
                        if (j           == i) continue;

                        ibodyl = bodyList[i];
                        ibodyr = bodyList[j];

                        ebodyl = MODL->body[ibodyl].ebody;
                        ebodyr = MODL->body[ibodyr].ebody;

                        status = solidBoolean(MODL, ebodyl, ebodyr, FUSION, maxtol, &emodel);
                        if (status == EGADS_SUCCESS) {
                            MODL->sigCode = 0;

                            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                                    data, &nchild, &ebodys, &senses);
                            CHECK_STATUS(EG_getTopology);

                            if (nchild != 1) {
                                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                            "UNION produced %d Bodys", nchild);
                                goto cleanup;
                            }

                            status = newBody(MODL, ibrch, OCSM_UNION, ibodyl, ibodyr,
                                             args, hasdots, OCSM_SOLID_BODY, &ibody);
                            CHECK_STATUS(newBody);

                            SPRINT3(1, "                          ... unioning Bodys %4d and %4d to create Body %4d",
                                    ibodyl, ibodyr, ibody);

                            status = EG_copyObject(ebodys[0], NULL, &ebody);
                            CHECK_STATUS(EG_copyObject);

                            MODL->body[ibody].ebody = ebody;

                            numRemaining--;
                            status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                                     1, &numRemaining, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            /* update @-parameters (UNION) and finish Body */
                            status = setupAtPmtrs(MODL, 0);
                            CHECK_STATUS(setupAtPmtrs);

                            status = finishBody(MODL, ibody);
                            CHECK_STATUS(finishBody);

                            bodyList[i] = ibody;
                            bodyList[j] = 0;
                            nchange++;

                            status = EG_deleteObject(emodel);
                            CHECK_STATUS(EG_deleteObject);
                        }
                    }
                }
            }

            nchange = 0;
            for (i = 0; i < numBodys; i++) {
                if (bodyList[i] > 0) {
                    nchange++;
                }
            }

            if (nchange > 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "no changes in last pass");

                (void) freeBody(MODL, ibody);
                MODL->nbody--;
                goto cleanup;
            }

        /* union all FaceBodys back to mark (into a SolidBody) */
        } else if (toMark == 2) {
            signalError(MODL, OCSM_UNSUPPORTED,
                        "UNION toMark=2 no longer supported. use COMBINE instead.");
            SET_STATUS(OCSM_UNSUPPORTED, union_2);

        /* bad value for toMark */
        } else {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "bad value for toMark (%d)", toMark);
            goto cleanup;
        }

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "join toler=0 toMark=0" */
    } else if (type == OCSM_JOIN) {
        SPRINT3(1, "    executing [%4d] join:       %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0]);

        /* extract the argument */
        toler  =      args[1].val[0];
        toMark = NINT(args[2].val[0]);

        /* toMark is set */
        if (toMark != 0) {
            if ((*nstack) < 2) {
                signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                            "JOIN expects 2 Bodys on stack");
                goto cleanup;
            } else if (stack[*nstack-2] <= 0) {
                signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                            "JOIN expects 2 Bodys on stack");
                goto cleanup;
            }

            itype    = MODL->body[stack[*nstack-1]].botype;
            numBodys = 1;

            if (itype != OCSM_WIRE_BODY && itype != OCSM_SHEET_BODY) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "JOIN with toMark only works on WireBodys or SheetBodys (and have %s)",
                            ocsmGetText(itype));
                goto cleanup;
            }

            /* count the Bodys back to Mark and make sure they are
               all the same type */
            for (i = (*nstack-1)-2; i >= 0; i--) {
                if        (stack[i] == 0) {
                    break;    /* found Mark */
                } else if (MODL->body[stack[i]].botype == itype) {
                    numBodys++;
                } else {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "JOIN with toMark must have same types (expecting %s but have %s at nstack=%d)",
                                ocsmGetText(itype), ocsmGetText(MODL->body[stack[i]].botype), i);
                    goto cleanup;
                }
            }

            numRemaining = numBodys;

            /* recycle old Body if not dirty (note: special treatment to skip
               to last Body that matches this Branch) */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                while ((*nstack) > 0) {
                    ibodyl = stack[--(*nstack)];
                    if (ibodyl == 0) break;       /* mark is found */
                }

                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* join the Bodys in pairs */
            for (i = 0; i < numBodys; i++) {
                ibodyl = stack[*nstack-1-i];
                for (j = i+1; j <= numBodys; j++) {
                    ibodyr = stack[*nstack-1-j];

                    if (outLevel > 1) {
                        SPRINT2(2, "\nbody[ibodyl=%d]: (%s)", ibodyl, ocsmGetText(MODL->body[ibodyl].botype));
                        ocsmPrintEgo(MODL->body[ibodyl].ebody);
                        SPRINT2(2,   "body[ibodyr=%d]: (%s)", ibodyr, ocsmGetText(MODL->body[ibodyr].botype));
                        ocsmPrintEgo(MODL->body[ibodyr].ebody);
                    }

                    (void) EG_setOutLevel(MODL->context, 0);
                    if (itype == OCSM_WIRE_BODY) {
                        status = joinWireBodys(MODL, ibodyl, ibodyr,     toler, &ebody);
                    } else if (itype == OCSM_SHEET_BODY) {
                        status = joinSheetBodys(MODL, ibodyl, ibodyr, 1, toler, &ebody);
                    } else {
                        status = joinSheetBodys(MODL, ibodyl, ibodyr, 2, toler, &ebody);
                    }
                    (void) EG_setOutLevel(MODL->context, ocsmSetOutLevel(-1));
                    SPRINT1(2, "join...Bodys -> status=%d", status);
                    if (status == SUCCESS) {
                        /* swap j and i-1 */
                        if (j != i-1) {
                            swap               = stack[*nstack-j-1];
                            stack[*nstack-j-1] = stack[*nstack-i-2];
                            stack[*nstack-i-2] = swap;
                        }

                        /* pop two entries from the stack */
                        (*nstack) -= 2;

                        /* create the new Body */
                        status = newBody(MODL, ibrch, OCSM_JOIN, ibodyl, ibodyr,
                                         args, hasdots, itype, &ibody);
                        CHECK_STATUS(newBody);

                        MODL->body[ibody].ebody = ebody;

                        numRemaining--;
                        status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                                 1, &numRemaining, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* update @-parameters (JOIN) and finish Body */
                        status = setupAtPmtrs(MODL, 0);
                        CHECK_STATUS(setupAtPmtrs);

                        status = finishBody(MODL, ibody);
                        if (MODL->sigCode != SUCCESS) goto cleanup;
                        CHECK_STATUS(finishBody);

                        /* push the Body onto the stack */
                        stack[(*nstack)++] = ibody;

                        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                        CHECK_STATUS(getBodyTolerance);

                        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

                        /* there is now one fewer Bodys since Mark.  Also, reprocess
                           stack entry i */
                        numBodys--;
                        i--;
                        break;
                    }
                }
            }

            /* remove the mark (if it exists) */
            if (*nstack > 1) {
                if (stack[*nstack-2] == 0) {
                    stack[*nstack-2] = stack[*nstack-1];
                    (*nstack)--;
                }
            }

            goto cleanup;
        }

        /* pop 2 Bodys from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "JOIN expects 2 Bodys on stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* join two SolidBodys */
        if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
            MODL->body[ibodyr].botype == OCSM_SOLID_BODY   ) {

            status = joinSheetBodys(MODL, ibodyl, ibodyr, 2, toler, &ebody);
            if (status < 0) goto cleanup;

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_JOIN, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        /* join two SheetBodys */
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {

            status = joinSheetBodys(MODL, ibodyl, ibodyr, 1, toler, &ebody);
            if (status < 0) goto cleanup;

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_JOIN, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        /* join two WireBodys */
        } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY &&
                   MODL->body[ibodyr].botype == OCSM_WIRE_BODY   ) {

            status = joinWireBodys(MODL, ibodyl, ibodyr, toler, &ebody);
            if (status == OCSM_DID_NOT_CREATE_BODY) {

                signalError(MODL, status,
                            "WireBodys to JOIN are not contiguous");
                goto cleanup;
            }
            CHECK_STATUS(joinWireBodys);

            /* create the new Body */
            status = newBody(MODL, ibrch, OCSM_JOIN, ibodyl, ibodyr,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

        } else {
            status = OCSM_WRONG_TYPES_ON_STACK;
            signalError(MODL, status,
                        "JOIN expects 2 SolidBodys, SheetBodys, or WireBodys on stack");
            goto cleanup;
        }

        /* update @-parameters (JOIN) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "extract entList" */
    } else if (type == OCSM_EXTRACT) {
        SPRINT2(1, "    executing [%4d] extract:    %s",
                ibrch, MODL->brch[ibrch].arg1);

        /* make sure that the signs of all entList entries are the same */
        if (args[1].nval > 1) {
            for (i = 1; i < args[1].nval; i++) {
                if (args[1].val[0]*args[1].val[i] <= 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "all entries in entList must have same sign");
                    goto cleanup;
                }
            }
        }

        /* pop a Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "EXTRACT expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* make sure the Body is a SolidBody or SheetBody */
        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY &&
            MODL->body[ibodyl].botype != OCSM_SHEET_BODY   ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "EXTRACT expects a SheetBody or a SolidBody");
            goto cleanup;
        }

        /* check for valid Face or Edge index */
        for (i = 0; i < args[1].nval; i++) {
            if        (+NINT(args[1].val[i]) > MODL->body[ibodyl].nface) {
                signalError(MODL, OCSM_FACE_NOT_FOUND,
                            "Face index (%d) is out of range", NINT(args[1].val[i]));
                goto cleanup;
            } else if (-NINT(args[1].val[i]) > MODL->body[ibodyl].nedge) {
                signalError(MODL, OCSM_EDGE_NOT_FOUND,
                            "Edge index (%d) is out of range", NINT(args[1].val[i]));
                goto cleanup;
            }
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        ebodyl = MODL->body[ibodyl].ebody;

        /* convert a SolidBody into a SheetBody (extract shell) */
        if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY &&
            NINT(args[1].val[0])      == 0                 ) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRACT, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_getTopology(ebodyl, &eref, &oclass, &mtype,
                                    data, &nshell, &eshells, &senses);
            CHECK_STATUS(EG_getTopology);

            SPLINT_CHECK_FOR_NULL(eshells);

            for (i = 0; i < nshell; i++) {
                if (senses[i] == SFORWARD) {
                    status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                             NULL, 1, &(eshells[i]), NULL, &ebody);
                    CHECK_STATUS(EG_makeTopology);

                    MODL->body[ibody].ebody = ebody;

                    break;
                }
            }

        /* extract Edges surrounding a SheetBody into a WireBody */
        } else if (NINT(args[1].val[0]) == 0) {

            MALLOC(elist, ego, MODL->body[ibodyl].nedge);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRACT, ibodyl, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            i = 0;
            for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {
                if (MODL->body[ibodyl].edge[iedge].nface == 1) {
                    elist[i++] = MODL->body[ibodyl].edge[iedge].eedge;
                }
            }

            status = EG_makeLoop(i, elist, NULL, 0, &eloop);
            CHECK_STATUS(EG_makeLoop);

            FREE(elist);

            if (status > 0) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "exposed Edges do not make a single loop");
                goto cleanup;
            }

            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL,
                                     1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            status = EG_deleteObject(eloop);
            CHECK_STATUS(EG_deleteObject);

            MODL->body[ibody].ebody = ebody;

        /* extract selected Faces from a SolidBody or SheetBody to create a SheetBody */
        } else if (NINT(args[1].val[0]) > 0) {
            status = EG_getBodyTopos(ebodyl, NULL, SHELL, &nshell, NULL);
            CHECK_STATUS(EG_getBodyTopos);

            status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(efaces);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRACT, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            if (args[1].nval == 1) {
                senses1[0] = SFORWARD;
                status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                         NULL, 1, &(efaces[NINT(args[1].val[0])-1]), senses1, &eshell);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                         NULL, 1, &eshell, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);

                status = EG_deleteObject(eshell);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[ibody].ebody = ebody;
            } else {
                MALLOC(elist, ego, 2*(nface-args[1].nval));

                k = 0;
                for (i = 0; i < nface; i++) {
                    keep = 0;
                    for (j = 0; j < args[1].nval; j++) {
                        if (args[1].val[j]-1 == i) {
                            keep = 1;
                            break;
                        }
                    }
                    if (keep == 0) {
                        elist[2*k  ] = efaces[i];
                        elist[2*k+1] = NULL;
                        k++;
                    }
                }

                status = EG_replaceFaces(ebodyl, k, elist, &ebody);

                FREE(elist);

                if (status < EGADS_SUCCESS) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "Faces in EXTRACT are not contiguous");

                    (void) freeBody(MODL, ibody);
                    MODL->nbody--;
                    EG_free(efaces);
                    goto cleanup;
                }

                MODL->body[ibody].ebody = ebody;
            }

            EG_free(efaces);

        /* extract selected Edges from a SolidBody or SheetBody to create a WireBody */
        } else {
            status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(eedges);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRACT, ibodyl, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            if (args[1].nval == 1) {
                senses1[0] = SFORWARD;

                status = EG_getTopology(eedges[-NINT(args[1].val[0])-1], &eref, &oclass, &mtype,
                                        data, &ntemp, &etemp, &senses);
                CHECK_STATUS(EG_getTopology);
                if (mtype == DEGENERATE) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "cannot EXTRACT a degenerate Edge");
                    goto cleanup;
                }

                status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN, NULL,
                                         1, &(eedges[-NINT(args[1].val[0])-1]), senses1, &eloop);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                         NULL, 1, &eloop, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);

                status = EG_deleteObject(eloop);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[ibody].ebody = ebody;
            } else {
                MALLOC(elist, ego, args[1].nval);

                for (i = 0; i < args[1].nval; i++) {
                    status = EG_getTopology(eedges[-NINT(args[1].val[i])-1], &eref, &oclass, &mtype,
                                            data, &ntemp, &etemp, &senses);
                    CHECK_STATUS(EG_getTopology);
                    if (mtype == DEGENERATE) {
                        signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                    "cannot EXTRACT a degenerate Edge");
                        goto cleanup;
                    }

                    elist[i] = eedges[-NINT(args[1].val[i])-1];
                }

                status = EG_makeLoop(args[1].nval, elist, NULL, 0, &eloop);
                CHECK_STATUS(EG_makeLoop);

                FREE(elist);

                if (status > 0) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "Edges in EXTRACT are not contiguous");

                    (void) freeBody(MODL, ibody);
                    MODL->nbody--;
                    EG_free(eedges);
                    goto cleanup;
                }

                status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL,
                                         1, &eloop, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);

                status = EG_deleteObject(eloop);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[ibody].ebody = ebody;
            }

            EG_free(eedges);
        }

        /* update @-parameters (EXTRACT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "combine toler=0" */
    } else if (type == OCSM_COMBINE) {
        SPRINT2(1, "    executing [%4d] combine:    %11.5f",
                ibrch, args[1].val[0]);

        /* extract the argument */
        toler = args[1].val[0];

        /* make a list of the Bodys back to mark */
        numBodys = 0;
        nedges   = 0;
        while ((*nstack) > 0) {
            ibodyl = stack[--(*nstack)];

            if (ibodyl == 0) {               /* mark is found */
                break;
            } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY ||
                       MODL->body[ibodyl].botype == OCSM_SHEET_BODY  ) {
                bodyList[numBodys++] = ibodyl;
                nedges += MODL->body[ibodyl].nedge;
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "COMBINE expects WireBody or SheetBody on stack");
                goto cleanup;
            }
        }

        if (numBodys < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "COMBINE expects one or more Bodys since mark");
            goto cleanup;
        }

        bodyType = MODL->body[bodyList[0]].botype;
        for (i = 1; i < numBodys; i++) {
            if (MODL->body[bodyList[i]].botype != bodyType) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "COMBINE found mixed Body types on stack");
                goto cleanup;
            }
        }

        ibodyl = bodyList[numBodys-1];
        ibodyr = bodyList[0         ];

        /* recycle old Body if not dirty (note: special treatment to skip
           to last Body that matches this Branch) */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* combine single WireBody into a SheetBody */
        if (bodyType == OCSM_WIRE_BODY && numBodys == 1) {
            status = EG_getBodyTopos(MODL->body[bodyList[0]].ebody, NULL, LOOP, &nchild, &echilds);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(echilds);

            status = EG_getInfo(echilds[0], &oclass, &mtype, &etopref, &eprev, &enext);
            CHECK_STATUS(EG_getInfo);

            /* if Loop is open, make a new Loop with a line at the end
               to close it */
            if (mtype == CLOSED) {
                eloop = echilds[0];
            } else {
                status = EG_copyObject(echilds[0], NULL, &eloop);
                CHECK_STATUS(EG_copyObject);

                status = EG_getTopology(eloop, &eref, &oclass, &mtype,
                                        data, &nedges, &eedges, &senses);
                CHECK_STATUS(EG_getTopology);

                MALLOC(newEdges,  ego, nedges+1);
                MALLOC(newSenses, int, nedges+1);

                for (iedge = 0; iedge < nedges; iedge++) {
                    newEdges[ iedge] = eedges[iedge];
                    newSenses[iedge] = senses[iedge];
                }

                status = EG_getTopology(newEdges[0], &eref, &oclass, &mtype,
                                        data, &nchild2, &echilds2, &senses2);
                CHECK_STATUS(EG_getTopology);

                if (senses[0] == SFORWARD) {
                    ebeg = echilds2[0];
                } else {
                    ebeg = echilds2[1];
                }
                status = EG_getTopology(newEdges[nedges-1], &eref, &oclass, &mtype,
                                        data, &nchild2, &echilds2, &senses2);
                CHECK_STATUS(EG_getTopology);

                if (senses[nedges-1] == SFORWARD) {
                    eend = echilds2[1];
                } else {
                    eend = echilds2[0];
                }

                status = makeEdge(MODL, eend, ebeg, &newEdges[nedges]);
                CHECK_STATUS(makeEdge);

                newSenses[nedges] = SFORWARD;

                status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED, NULL,
                                         nedges+1, newEdges, newSenses, &eloop);
                CHECK_STATUS(EG_makeTopology);

                FREE(newEdges );
                FREE(newSenses);
            }

            status = EG_makeFace(eloop, SFORWARD, NULL, &eface);
            if (status == EGADS_GEOMERR) {
                status = OCSM_DID_NOT_CREATE_BODY;
                signalError(MODL, status,
                            "a SheetBody could not be made from the given WireBody (maybe not planar?)");
                EG_free(echilds);
                goto cleanup;
            }
            CHECK_STATUS(EG_makeFace);

            EG_free(echilds);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN, NULL,
                                     1, &eface, NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY, NULL,
                                     1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, 0,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

            /* update @-parameters (COMBINE) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

        /* combine WireBodys into a SheetBody */
        } else if (bodyType == OCSM_WIRE_BODY) {
            /* make list of Edges in the WireBodys */
            MALLOC(elist, ego, nedges);

            k = 0;
            for (i = numBodys-1; i >= 0; i--) {
                ebody = MODL->body[bodyList[i]].ebody;

                status = EG_getTopology(ebody, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);
                SPLINT_CHECK_FOR_NULL(echilds);

                eloop = echilds[0];

                status = EG_getTopology(eloop, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);
                SPLINT_CHECK_FOR_NULL(echilds);

                for (j = 0; j < nchild; j++) {
                    status = EG_copyObject(echilds[j], NULL, &(elist[k++]));
                    CHECK_STATUS(EG_copyObject);

                    if (outLevel >= 2) {
                        SPRINT1(2, "before makeLoop: elist[%d]", k-1);
                        ocsmPrintEgo(elist[k-1]);
                    }
                }
            }

            /* try to make a single Loop */
            (void) EG_setOutLevel(MODL->context, 0);
            status = EG_makeLoop(nedges, elist, NULL, toler, &eloop);
            (void) EG_setOutLevel(MODL->context, outLevel);
            if (status == EGADS_CONSTERR) {
                count = -1;
            } else {
                CHECK_STATUS(EG_makeLoop);

                if (outLevel >= 2) {
                    SPRINT0(2, "eloop");
                    ocsmPrintEgo(eloop);
                }

                /* count the number of non-NULL entries in elist */
                count = 0;
                for (i = 0; i < nedges; i++) {
                    if (elist[i] != NULL) {
                        count++;
                    }
                }
            }

            /* there are no non-NULL entries, so all Edges fit into one Loop */
            if (count == 0) {

                /* try to make a Face (and then a FaceBody) */
                status = EG_makeFace(eloop, SFORWARD, NULL, &eface);
                if (status == EGADS_SUCCESS) {
                    status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
                                             NULL, 1, &eface, NULL, &ebody);
                    CHECK_STATUS(EG_makeTopology);

                    /* create the Body */
                    status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, ibodyr,
                                     args, hasdots, OCSM_SHEET_BODY, &ibody);
                    CHECK_STATUS(newBody);

                    MODL->body[ibody].ebody = ebody;

                    /* attach the Body to its children */
                    for (i = 0; i < numBodys; i++) {
                        MODL->body[bodyList[i]].ichld = ibody;
                    }

                    /* mark the new Faces with the current Branch */
                    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (efaces != NULL) {
                        for (iface = 1; iface <= nface; iface++) {
                            status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                            CHECK_STATUS(setFaceAttribute);
                        }

                        EG_free(efaces);
                    }

                /* if we got a GEOMERR, then Loop is non-planar, so make a WireBody instead */
                } else if (status == EGADS_GEOMERR) {
                    status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                             NULL, 1, &eloop, NULL, &ebody);
                    CHECK_STATUS(EG_makeTopology);

                    /* create the Body */
                    status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, ibodyr,
                                     args, hasdots, OCSM_WIRE_BODY, &ibody);
                    CHECK_STATUS(newBody);

                    MODL->body[ibody].ebody = ebody;

                    /* attach the Body to its children */
                    for (i = 0; i < numBodys; i++) {
                        MODL->body[bodyList[i]].ichld = ibody;
                    }

                /* other errors are not expected */
                } else {
                    CHECK_STATUS(EG_makeFace);
                }

            /* if there were Edges left over when making the Loop, it means that we should
               try to combine the original WireBodys into a non-mainfold WireBody */
            } else {
                if (count > 0) {
                    status = EG_deleteObject(eloop);
                    CHECK_STATUS(EG_deleteObject);
                }

                if (toler == 0) {
                    toler = EPS06;
                }

                /* make new list of the Edges in the WireBodys on the stack */
                FREE(elist);

                nlist = 0;
                for (i = 0; i < numBodys; i++) {
                    status = EG_getBodyTopos(MODL->body[bodyList[i]].ebody, NULL, EDGE, &nedge, NULL);
                    nlist += nedge;
                }

                MALLOC(elist,  ego,      nlist);
                MALLOC(xyzbeg, double, 3*nlist);
                MALLOC(xyzend, double, 3*nlist);

                /* remember the beg and end coordinates */
                nlist = 0;
                for (i = 0; i < numBodys; i++) {
                    status = EG_getBodyTopos(MODL->body[bodyList[i]].ebody, NULL, EDGE, &nedge, &eedges);
                    for (j = 0; j < nedge; j++) {
                        elist[nlist] = eedges[j];

                        status = EG_getTopology(elist[nlist], &eref, &oclass, &mtype,
                                                data, &nchild, &echilds, &senses);
                        CHECK_STATUS(EG_getTopology);

                        SPLINT_CHECK_FOR_NULL(echilds);

                        status = EG_getTopology(echilds[0], &eref, &oclass, &mtype,
                                                &(xyzbeg[3*nlist]), &nchild, &echilds2, &senses2);
                        CHECK_STATUS(EG_getTopology);

                        status = EG_getTopology(echilds[1], &eref, &oclass, &mtype,
                                                &(xyzend[3*nlist]), &nchild, &echilds2, &senses2);
                        CHECK_STATUS(EG_getTopology);

                        nlist++;
                    }
                    EG_free(eedges);
                }

                /* sort the list so that every Edge (after the first) has at least one
                   Node in common with the previous Edges in the list */
                for (i = 1; i < nlist; i++) {
                    match = 0;

                    /* see if either Node of elist[i] matches either the beg or end of any
                       previous Nodes */
                    for (j = 0; j < i; j++) {
                        if        (fabs(xyzbeg[3*i  ]-xyzbeg[3*j  ]) < EPS06 &&
                                   fabs(xyzbeg[3*i+1]-xyzbeg[3*j+1]) < EPS06 &&
                                   fabs(xyzbeg[3*i+2]-xyzbeg[3*j+2]) < EPS06   ) {
                            match = 1;
                            break;
                        } else if (fabs(xyzend[3*i  ]-xyzbeg[3*j  ]) < EPS06 &&
                                   fabs(xyzend[3*i+1]-xyzbeg[3*j+1]) < EPS06 &&
                                   fabs(xyzend[3*i+2]-xyzbeg[3*j+2]) < EPS06   ) {
                            match = 1;
                            break;
                        } else if (fabs(xyzbeg[3*i  ]-xyzend[3*j  ]) < EPS06 &&
                                   fabs(xyzbeg[3*i+1]-xyzend[3*j+1]) < EPS06 &&
                                   fabs(xyzbeg[3*i+2]-xyzend[3*j+2]) < EPS06   ) {
                            match = 1;
                            break;
                        } else if (fabs(xyzend[3*i  ]-xyzend[3*j  ]) < EPS06 &&
                                   fabs(xyzend[3*i+1]-xyzend[3*j+1]) < EPS06 &&
                                   fabs(xyzend[3*i+2]-xyzend[3*j+2]) < EPS06   ) {
                            match = 1;
                            break;
                        }
                    }
                    if (match == 1) continue;

                    /* we do not have a match, so look at all the remaining Edges
                       to see if they match */
                    for (k = i+1; k < nlist; k++) {
                        for (j = 0; j < i; j++) {
                            if        (fabs(xyzbeg[3*k  ]-xyzbeg[3*j  ]) < EPS06 &&
                                       fabs(xyzbeg[3*k+1]-xyzbeg[3*j+1]) < EPS06 &&
                                       fabs(xyzbeg[3*k+2]-xyzbeg[3*j+2]) < EPS06   ) {
                                match = 1;
                                break;
                            } else if (fabs(xyzend[3*k  ]-xyzbeg[3*j  ]) < EPS06 &&
                                       fabs(xyzend[3*k+1]-xyzbeg[3*j+1]) < EPS06 &&
                                       fabs(xyzend[3*k+2]-xyzbeg[3*j+2]) < EPS06   ) {
                                match = 1;
                                break;
                            } else if (fabs(xyzbeg[3*k  ]-xyzend[3*j  ]) < EPS06 &&
                                       fabs(xyzbeg[3*k+1]-xyzend[3*j+1]) < EPS06 &&
                                       fabs(xyzbeg[3*k+2]-xyzend[3*j+2]) < EPS06   ) {
                                match = 1;
                                break;
                            } else if (fabs(xyzend[3*k  ]-xyzend[3*j  ]) < EPS06 &&
                                       fabs(xyzend[3*k+1]-xyzend[3*j+1]) < EPS06 &&
                                       fabs(xyzend[3*k+2]-xyzend[3*j+2]) < EPS06   ) {
                                match = 1;
                                break;
                            }
                        }

                        /* if we have a match, swap entries i and k */
                        if (match == 1) {
                            eswap    = elist[i];
                            elist[i] = elist[k];
                            elist[k] = eswap;

                            fswap         = xyzbeg[3*i  ];
                            xyzbeg[3*i  ] = xyzbeg[3*k  ];
                            xyzbeg[3*k  ] = fswap;

                            fswap         = xyzbeg[3*i+1];
                            xyzbeg[3*i+1] = xyzbeg[3*k+1];
                            xyzbeg[3*k+1] = fswap;

                            fswap         = xyzbeg[3*i+2];
                            xyzbeg[3*i+2] = xyzbeg[3*k+2];
                            xyzbeg[3*k+2] = fswap;

                            fswap         = xyzend[3*i  ];
                            xyzend[3*i  ] = xyzend[3*k  ];
                            xyzend[3*k  ] = fswap;

                            fswap         = xyzend[3*i+1];
                            xyzend[3*i+1] = xyzend[3*k+1];
                            xyzend[3*k+1] = fswap;

                            fswap         = xyzend[3*i+2];
                            xyzend[3*i+2] = xyzend[3*k+2];
                            xyzend[3*k+2] = fswap;

                            break;
                        }
                    }

                    /* if there were no matches, then we have non-contiguous Edges */
                    if (match == 0) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "COMBINE failed because WireBodys are not contiguous");
                        goto cleanup;
                    }
                }

                /* sorted list of Edges */
                if (outLevel >= 2) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1(2, "elist[%d]:", i);
                        ocsmPrintEgo(elist[i]);
                    }
                }

                status = EG_makeNmWireBody(nlist, elist, toler, &ebody);
                if (status < EGADS_SUCCESS) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "COMBINE failed because WireBodys are not contiguous");
                    goto cleanup;
                }

                if (outLevel >= 2) {
                    SPRINT0(2, "ebody:");
                    ocsmPrintEgo(ebody);
                }

                /* create the Body */
                status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, ibodyr,
                                 args, hasdots, OCSM_WIRE_BODY, &ibody);
                CHECK_STATUS(newBody);

                MODL->body[ibody].ebody = ebody;

                /* attach the Body to its children */
                for (i = 0; i < numBodys; i++) {
                    MODL->body[bodyList[i]].ichld = ibody;
                }

                /* make sure we keep the Attributes from the original Edges */
                status = EG_attributeAdd(ebody, "__keepEdgeAttr__", ATTRSTRING,
                                         STRLEN("yes"), NULL, NULL, "yes");
                CHECK_STATUS(EG_attributeAdd);
            }

            /* update @-parameters (COMBINE) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

        /* convert single SheetBody into a SolidBody */
        } else if (bodyType == OCSM_SHEET_BODY && numBodys == 1) {
            status = EG_getBodyTopos(MODL->body[bodyList[0]].ebody, NULL, SHELL, &nchild, &echilds);
            CHECK_STATUS(EG_getBodyTopos);

            if (nchild != 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "COMBINE with single SheetBody must have one Shell");
                goto cleanup;
            }

            SPLINT_CHECK_FOR_NULL(echilds);
            status = EG_getInfo(echilds[0], &oclass, &mtype, &etopref, &eprev, &enext);
            CHECK_STATUS(EG_getInfo);

            if (mtype != CLOSED) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "COMBINE with single SheetBody must be closed");
                goto cleanup;
            }

            status = EG_copyObject(echilds[0], NULL, &eshell);
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, BODY, SOLIDBODY, NULL,
                                     1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            EG_free(echilds);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, 0,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (COMBINE) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

        /* combine SheetBodys into a SheetBody or SolidBody */
        } else if (bodyType == OCSM_SHEET_BODY) {

            /* make a list of the Faces in the Bodys */
            nlist = 0;
            for (i = 0; i < numBodys; i++) {
                status = EG_getBodyTopos(MODL->body[bodyList[i]].ebody, NULL, FACE,
                                         &nface, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                nlist += nface;
            }

            MALLOC(elist, ego, nlist);

            nlist = 0;
            for (i = 0; i < numBodys; i++) {
                status = EG_getBodyTopos(MODL->body[bodyList[i]].ebody, NULL, FACE,
                                         &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                if (efaces != NULL) {
                    for (j = 0; j < nface; j++) {
                        elist[nlist] = efaces[j];

                        if (outLevel > 1) {
                            SPRINT1(2, "elist[%d]:", nlist);
                            (void) ocsmPrintEgo(elist[nlist]);
                        }

                        nlist++;
                    }

                    EG_free(efaces);
                }
            }

            /* sew them together into a Model using default tolerance */
            status = EG_sewFaces(nlist, elist, toler, 0, &emodel);
            CHECK_STATUS(EG_sewfaces);

            /* if the Model contains a single SolidBody, extract it */
            status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &ebodys, &senses);
            CHECK_STATUS(EG_getTopology);

            if (nchild < 1) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "COMBINE was expecting that a SolidBody would be produced");
                goto cleanup;
            } else {
                status = EG_getTopology(ebodys[0], &eref, &oclass, &mtype,
                                        data, &nface, &efaces, &senses);
                CHECK_STATUS(EG_getTopology);

                if (oclass != BODY) {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "COMBINE was expecting that a SolidBody would be produced");
                    goto cleanup;
                } else if (mtype != SOLIDBODY) {
                    SPRINT0(1, "WARNING:: COMBINE produced an (open) SheetBody");
                    (MODL->nwarn)++;

                    itype = OCSM_SHEET_BODY;
                } else {
                    itype = OCSM_SOLID_BODY;
                }

                status = EG_copyObject(ebodys[0], NULL, &ebody);
                CHECK_STATUS(EG_copyObject);

                if (nchild > 1) {
                    SPRINT1(1, "WARNING:: %d Bodys are being lost", nchild-1);
                    (MODL->nwarn)++;
                }
            }

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_COMBINE, ibodyl, ibodyr,
                             args, hasdots, itype, &ibody);
            CHECK_STATUS(newBody);

            MODL->body[ibody].ebody = ebody;

            /* attach the Body to its children */
            for (i = 0; i < numBodys; i++) {
                MODL->body[bodyList[i]].ichld = ibody;
            }

            /* update @-parameters (COMBINE) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);
        }

    /* execute: "connect faceList1 faceList2 edgeList1=0 edgeList2=0 toler=0" */
    } else if (type == OCSM_CONNECT) {
        SPRINT5(1, "    executing [%4d] connect:    %s  %s  %s  %s",
                ibrch, MODL->brch[ibrch].arg1, MODL->brch[ibrch].arg2,
                       MODL->brch[ibrch].arg3, MODL->brch[ibrch].arg4);

        /* require finite differences */
        MODL->needFDs = 1;

        /* extract the argument */
        toler = args[5].val[0];

        /* pop up to two Bodys from the stack */
        if ((*nstack) == 1) {
            ibodyr = stack[--(*nstack)];          // only one Body on stack
            ibodyl = ibodyr;

            ebodyr = MODL->body[ibodyr].ebody;
            ebodyl = ebodyr;
        } else if ((*nstack) >= 2) {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
            if (ibodyl == 0) {                    // one Body and Mark on stack
                ibodyl = ibodyr;
            }

            ebodyr = MODL->body[ibodyr].ebody;
            ebodyl = MODL->body[ibodyl].ebody;
        } else {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "CONNECT expects two Bodys on the stack");
            goto cleanup;
        }

        /* make sure that we have the correct Body types */
        if (MODL->body[ibodyl].botype != MODL->body[ibodyr].botype) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "CONNECT expects Bodys to be same type");
            goto cleanup;
        } else if (MODL->body[ibodyl].botype != OCSM_WIRE_BODY  &&
                   MODL->body[ibodyl].botype != OCSM_SOLID_BODY &&
                   MODL->body[ibodyl].botype != OCSM_SHEET_BODY   ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "CONNECT expects SolidBodys or SheetBodys");
            goto cleanup;
        }

        /* if there are WireBodys on the Stack, make sure that they have
           the same number of Edges and that all Edges are mentioned
           in edgeList1 and edgeList2 */
        if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {
            if (ibodyl == ibodyr) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "WireBodys must be unique in CONNECT");
                goto cleanup;
            } else if (MODL->body[ibodyl].nedge != MODL->body[ibodyr].nedge) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "WireBodys must have same number of Edges");
                goto cleanup;
            } else if (args[3].nval != MODL->body[ibodyl].nedge) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "edgeList1 has fewer values than number of Edges in WireBody");
                goto cleanup;
            }
        }

        for (i = 0; i < args[1].nval; i++) {
            SPRINT2(2, "   args[1].val[%2d]=%d", i, NINT(args[1].val[i]));
        }
        for (i = 0; i < args[2].nval; i++) {
            SPRINT2(2, "   args[2].val[%2d]=%d", i, NINT(args[2].val[i]));
        }
        for (i = 0; i < args[3].nval; i++) {
            SPRINT2(2, "   args[3].val[%2d]=%d", i, NINT(args[3].val[i]));
        }
        for (i = 0; i < args[4].nval; i++) {
            SPRINT2(2, "   args[4].val[%2d]=%d", i, NINT(args[4].val[i]));
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* make sure that the number of values in args[1] and args[2] are the same */
        if (args[1].nval != args[2].nval) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "faceList1 and faceList2 must contain same number of Faces");
            goto cleanup;
        }

        /* make sure that the number of values in args[3] and args[4] are the same */
        if (args[3].nval != args[4].nval) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "edgeList1 and edgeList2 must contain same number of Edges");
            goto cleanup;
        }

        /* only faceLists are given */
        if (NINT(args[3].val[0]) == 0 && NINT(args[4].val[0]) == 0) {

            /* make sure both Bodys are SolidBodys */
            if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY ||
                MODL->body[ibodyr].botype != OCSM_SOLID_BODY   ) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "CONNECT only works with SolidBodys");
                goto cleanup;
            }

            nEdgeList = MODL->body[ibodyl].nedge + MODL->body[ibodyr].nedge;
            nFaceList = MODL->body[ibodyl].nface + MODL->body[ibodyr].nface + 2 * nEdgeList;
            MALLOC(edgeList, ego, nEdgeList);
            MALLOC(faceList, ego, nFaceList);

            /* make a list of the Edges that surround the Faces in
               ebodyl and remove duplicates along the way */
            nEdgeList = 0;
            for (ii = 0; ii < args[1].nval; ii++) {
                iface = NINT(args[1].val[ii]);
                if (iface < 1 || iface > MODL->body[ibodyl].nface) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "faceList1 contains illegal Face number (%d) %d", iface, MODL->body[ibodyl].nface);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, MODL->body[ibodyl].face[iface].eface, EDGE,
                                         &nnn, &nnnList);
                CHECK_STATUS(EG_getBodyTopos);

                if (nnnList != NULL) {
                    for (iii = 0; iii < nnn; iii++) {
                        status = EG_getInfo(nnnList[iii], &oclass, &mtype, &etopref, &eprev, &enext);
                        CHECK_STATUS(EG_getInfo);

                        if (mtype == DEGENERATE) continue;

                        /* if a duplicate, remove its partner from list */
                        iadd = 1;
                        for (jjj = 0; jjj < nEdgeList; jjj++) {
                            if (nnnList[iii] == edgeList[jjj]) {
                                edgeList[jjj] = edgeList[nEdgeList-1];
                                nEdgeList--;
                                iadd = 0;
                                break;
                            }
                        }

                        /* if not found, add to list */
                        if (iadd == 1) {
                            edgeList[nEdgeList] = nnnList[iii];
                            nEdgeList++;
                        }
                    }

                    EG_free(nnnList);
                }
            }

            /* make a Loop out of edgeList so that we get the Edges in order and
               know the senses */
            status = EG_makeLoop(nEdgeList, edgeList, NULL, 0, &eloops[0]);
            CHECK_STATUS(EG_makeLoop);

            if (status > 0) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "Faces in faceList1 are not contiguous and edgeLists are not given");
                goto cleanup;
            }

            status = EG_getTopology(eloops[0], &eref, &oclass, &mtype, data,
                                    &nEdgeListl, &edgeListl, &sensesl);
            CHECK_STATUS(EG_getTopology);

            /* make a list of the Edges that surround the Faces in ebodyr and
               remove duplicates along the way */
            nEdgeList = 0;
            for (ii = 0; ii < args[2].nval; ii++) {
                iface = NINT(args[2].val[ii]);
                if (iface < 1 || iface > MODL->body[ibodyr].nface) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "faceList2 contains illegal Face number (%d) %d", iface, MODL->body[ibodyr].nface);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyr, MODL->body[ibodyr].face[iface].eface, EDGE,
                                         &nnn, &nnnList);
                CHECK_STATUS(EG_getBodyTopos);

                if (nnnList != NULL) {
                    for (iii = 0; iii < nnn; iii++) {
                        status = EG_getInfo(nnnList[iii], &oclass, &mtype, &etopref, &eprev, &enext);
                        CHECK_STATUS(EG_getInfo);

                        if (mtype == DEGENERATE) continue;

                        /* if a duplicate, remove its partner from list */
                        iadd = 1;
                        for (jjj = 0; jjj < nEdgeList; jjj++) {
                            if (nnnList[iii] == edgeList[jjj]) {
                                edgeList[jjj] = edgeList[nEdgeList-1];
                                nEdgeList--;
                                iadd = 0;
                                break;
                            }
                        }

                        /* if not found, add to list */
                        if (iadd == 1) {
                            edgeList[nEdgeList] = nnnList[iii];
                            nEdgeList++;
                        }
                    }

                    EG_free(nnnList);
                }
            }

            /* make a Loop out of edgeList so that we get the Edges in order and
               know the senses */
            status = EG_makeLoop(nEdgeList, edgeList, NULL, 0, &eloops[1]);
            CHECK_STATUS(EG_makeLoop);

            if (status > 0) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "Faces in faceList2 are not contiguous are edgeLists are not given");
                goto cleanup;
            }

            /* match eloops[1] so that it matches eloops[0] */
            status = matchLoop(eloops);
            CHECK_STATUS(matchLoop);

            status = EG_getTopology(eloops[1], &eref, &oclass, &mtype, data,
                                    &nEdgeListr, &edgeListr, &sensesr);
            CHECK_STATUS(EG_getTopology);
            SPLINT_CHECK_FOR_NULL(edgeListr);

            /* make Edges between the Nodes in the two Loops */
            for (ii = 0; ii < nEdgeListl; ii++) {
                status = EG_getTopology(edgeListl[ii], &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);
                SPLINT_CHECK_FOR_NULL(echilds);

                if (sensesl[ii] == SFORWARD) {
                    enodes[0] = echilds[0];
                } else {
                    enodes[0] = echilds[1];
                }

                status = EG_getTopology(edgeListr[ii], &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);
                SPLINT_CHECK_FOR_NULL(echilds);

                if (sensesr[ii] == SFORWARD) {
                    enodes[1] = echilds[0];
                } else {
                    enodes[1] = echilds[1];
                }

                status = makeEdge(MODL, enodes[0], enodes[1], &(edgeList[ii]));
                CHECK_STATUS(makeEdge);
            }

            /* make Faces between the Edges in the two Loops */
            nFaceList = 0;
            for (ii = 0; ii < nEdgeListl; ii++) {
                eedges2[0] = edgeListl[ii];
                eedges2[1] = edgeList[ ii];
                eedges2[2] = edgeListr[ii];
                eedges2[3] = edgeList[(ii+1)%nEdgeListl];

                status = makeFace(MODL, eedges2, fillstyle, SFORWARD, toler, &(faceList[nFaceList]));
                CHECK_STATUS(makeFace);

                nFaceList++;
            }

        /* edgeLists are given, so create bridging Faces between the two SheetBodys
           or SolidBodys */
        } else {
            nEdgeList = MODL->body[ibodyl].nedge + MODL->body[ibodyr].nedge + 2;
            nFaceList = MODL->body[ibodyl].nface + MODL->body[ibodyr].nface + 2 * nEdgeList;
            MALLOC(edgeList, ego, nEdgeList);
            MALLOC(faceList, ego, nFaceList);

            nFaceList = 0;

            for (ii = 0; ii < args[3].nval; ii++) {
                iedgel = NINT(args[3].val[ii]);
                iedger = NINT(args[4].val[ii]);

                if (iedgel == 0 && iedger == 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "CONNECT cannot have 0 at same position in edgeList1 and edgeList2");
                    goto cleanup;

                } else if (iedgel == 0) {
                    if (ii == 0 || ii == args[3].nval-1) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "CONNECT cannot have 0 entry at beg or end of edgeList1");
                        goto cleanup;
                    } else if (NINT(args[3].val[ii-1]) == 0 || NINT(args[3].val[ii+1]) == 0) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "CONNECT can not have consecutive 0s in edgeList1");
                        goto cleanup;
                    }
                    if        (MODL->body[ibodyl].edge[NINT(args[3].val[ii-1])].ibeg ==
                               MODL->body[ibodyl].edge[NINT(args[3].val[ii+1])].ibeg    ) {
                        iedgel    = NINT(args[3].val[ii-1]);
                        inode     = MODL->body[ibodyl].edge[iedgel].ibeg;
                        enodes[0] = MODL->body[ibodyl].node[inode ].enode;
                    } else if (MODL->body[ibodyl].edge[NINT(args[3].val[ii-1])].ibeg ==
                               MODL->body[ibodyl].edge[NINT(args[3].val[ii+1])].iend    ) {
                        iedgel    = NINT(args[3].val[ii-1]);
                        inode     = MODL->body[ibodyl].edge[iedgel].ibeg;
                        enodes[0] = MODL->body[ibodyl].node[inode ].enode;
                    } else if (MODL->body[ibodyl].edge[NINT(args[3].val[ii-1])].iend ==
                               MODL->body[ibodyl].edge[NINT(args[3].val[ii+1])].ibeg    ) {
                        iedgel    = NINT(args[3].val[ii-1]);
                        inode     = MODL->body[ibodyl].edge[iedgel].iend;
                        enodes[0] = MODL->body[ibodyl].node[inode ].enode;
                    } else if (MODL->body[ibodyl].edge[NINT(args[3].val[ii-1])].iend ==
                               MODL->body[ibodyl].edge[NINT(args[3].val[ii+1])].iend    ) {
                        iedgel    = NINT(args[3].val[ii-1]);
                        inode     = MODL->body[ibodyl].edge[iedgel].iend;
                        enodes[0] = MODL->body[ibodyl].node[inode ].enode;
                    } else {
                        signalError(MODL, OCSM_NODE_NOT_FOUND,
                                    "CONNECT could not find Node for degenerate Face");
                        goto cleanup;
                    }

                    iendl  = MODL->body[ibodyr].edge[iedger].iend;
                    status = makeEdge(MODL, enodes[0], MODL->body[ibodyr].node[iendl].enode, &(edgeList[0]));
                    CHECK_STATUS(makeEdge);

                    edgeList[1] = MODL->body[ibodyr].edge[iedger].eedge;

                    ibegr  = MODL->body[ibodyr].edge[iedger].ibeg;
                    status = makeEdge(MODL, enodes[0], MODL->body[ibodyr].node[ibegr].enode, &(edgeList[2]));
                    CHECK_STATUS(makeEdge);

                    edgeList[3] = NULL;

                    status = makeFace(MODL, edgeList, fillstyle, SFORWARD, toler, &(faceList[nFaceList]));
                    CHECK_STATUS(makeFace);

                    nFaceList++;
                } else if (iedger == 0) {
                    if (ii == 0 || ii == args[4].nval-1) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "CONNECT cannot have 0 entry at beg or end of edgeList2");
                        goto cleanup;
                    } else if (NINT(args[4].val[ii-1]) == 0 || NINT(args[4].val[ii+1]) == 0) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "CONNECT can not have consecutive 0s in edgeList2");
                        goto cleanup;
                    }
                    if        (MODL->body[ibodyr].edge[NINT(args[4].val[ii-1])].ibeg ==
                               MODL->body[ibodyr].edge[NINT(args[4].val[ii+1])].ibeg    ) {
                        iedger    = NINT(args[4].val[ii-1]);
                        inode     = MODL->body[ibodyr].edge[iedger].ibeg;
                        enodes[1] = MODL->body[ibodyr].node[inode ].enode;
                    } else if (MODL->body[ibodyr].edge[NINT(args[4].val[ii-1])].ibeg ==
                               MODL->body[ibodyr].edge[NINT(args[4].val[ii+1])].iend    ) {
                        iedger    = NINT(args[4].val[ii-1]);
                        inode     = MODL->body[ibodyr].edge[iedger].ibeg;
                        enodes[1] = MODL->body[ibodyr].node[inode ].enode;
                    } else if (MODL->body[ibodyr].edge[NINT(args[4].val[ii-1])].iend ==
                               MODL->body[ibodyr].edge[NINT(args[4].val[ii+1])].ibeg    ) {
                        iedger    = NINT(args[4].val[ii-1]);
                        inode     = MODL->body[ibodyr].edge[iedger].iend;
                        enodes[1] = MODL->body[ibodyr].node[inode ].enode;
                    } else if (MODL->body[ibodyr].edge[NINT(args[4].val[ii-1])].iend ==
                               MODL->body[ibodyr].edge[NINT(args[4].val[ii+1])].iend    ) {
                        iedger    = NINT(args[4].val[ii-1]);
                        inode     = MODL->body[ibodyr].edge[iedger].iend;
                        enodes[1] = MODL->body[ibodyr].node[inode ].enode;
                    } else {
                        signalError(MODL, OCSM_NODE_NOT_FOUND,
                                    "CONNECT could not find Node for degenerate Face");
                        goto cleanup;
                    }

                    ibegl  = MODL->body[ibodyl].edge[iedgel].ibeg;
                    status = makeEdge(MODL, MODL->body[ibodyl].node[ibegl].enode, enodes[1], &(edgeList[0]));
                    CHECK_STATUS(makeEdge);

                    edgeList[1] = MODL->body[ibodyl].edge[iedgel].eedge;

                    iendl  = MODL->body[ibodyl].edge[iedgel].iend;
                    status = makeEdge(MODL, MODL->body[ibodyl].node[iendl].enode, enodes[1], &(edgeList[2]));
                    CHECK_STATUS(makeEdge);

                    edgeList[3] = NULL;

                    status = makeFace(MODL, edgeList, fillstyle, SREVERSE, toler, &(faceList[nFaceList]));
                    CHECK_STATUS(makeFace);

                    nFaceList++;
                } else {
                    xyz0[0] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].x;
                    xyz0[1] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].y;
                    xyz0[2] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].ibeg].z;

                    xyz1[0] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].x;
                    xyz1[1] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].y;
                    xyz1[2] = MODL->body[ibodyl].node[MODL->body[ibodyl].edge[iedgel].iend].z;

                    xyz2[0] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].x;
                    xyz2[1] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].y;
                    xyz2[2] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].ibeg].z;

                    xyz3[0] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].x;
                    xyz3[1] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].y;
                    xyz3[2] = MODL->body[ibodyr].node[MODL->body[ibodyr].edge[iedger].iend].z;

                    dist02 = (xyz0[0]-xyz2[0])*(xyz0[0]-xyz2[0])
                           + (xyz0[1]-xyz2[1])*(xyz0[1]-xyz2[1])
                           + (xyz0[2]-xyz2[2])*(xyz0[2]-xyz2[2]);
                    dist03 = (xyz0[0]-xyz3[0])*(xyz0[0]-xyz3[0])
                           + (xyz0[1]-xyz3[1])*(xyz0[1]-xyz3[1])
                           + (xyz0[2]-xyz3[2])*(xyz0[2]-xyz3[2]);
                    dist12 = (xyz1[0]-xyz2[0])*(xyz1[0]-xyz2[0])
                           + (xyz1[1]-xyz2[1])*(xyz1[1]-xyz2[1])
                           + (xyz1[2]-xyz2[2])*(xyz1[2]-xyz2[2]);
                    dist13 = (xyz1[0]-xyz3[0])*(xyz1[0]-xyz3[0])
                           + (xyz1[1]-xyz3[1])*(xyz1[1]-xyz3[1])
                           + (xyz1[2]-xyz3[2])*(xyz1[2]-xyz3[2]);

                    if (dist02+dist13 < dist03+dist12) {
                        edgeList[0] = MODL->body[ibodyl].edge[iedgel].eedge;
                        senses1[ 0] = SFORWARD;

                        iendl  = MODL->body[ibodyl].edge[iedgel].iend;
                        iendr  = MODL->body[ibodyr].edge[iedger].iend;
                        status = makeEdge(MODL, MODL->body[ibodyl].node[iendl].enode,
                                                MODL->body[ibodyr].node[iendr].enode, &(edgeList[1]));
                        CHECK_STATUS(makeEdge);

                        edgeList[2] = MODL->body[ibodyr].edge[iedger].eedge;

                        ibegl  = MODL->body[ibodyl].edge[iedgel].ibeg;
                        ibegr  = MODL->body[ibodyr].edge[iedger].ibeg;
                        status = makeEdge(MODL, MODL->body[ibodyl].node[ibegl].enode,
                                                MODL->body[ibodyr].node[ibegr].enode, &(edgeList[3]));
                        CHECK_STATUS(makeEdge);
                    } else {
                        edgeList[0] = MODL->body[ibodyl].edge[iedgel].eedge;

                        iendl  = MODL->body[ibodyl].edge[iedgel].iend;
                        ibegr  = MODL->body[ibodyr].edge[iedger].ibeg;
                        status = makeEdge(MODL, MODL->body[ibodyl].node[iendl].enode,
                                                MODL->body[ibodyr].node[ibegr].enode, &(edgeList[1]));
                        CHECK_STATUS(makeEdge);

                        edgeList[2] = MODL->body[ibodyr].edge[iedger].eedge;

                        ibegl  = MODL->body[ibodyl].edge[iedgel].ibeg;
                        iendr  = MODL->body[ibodyr].edge[iedger].iend;
                        status = makeEdge(MODL, MODL->body[ibodyl].node[ibegl].enode,
                                                MODL->body[ibodyr].node[iendr].enode, &(edgeList[3]));
                        CHECK_STATUS(makeEdge);
                    }

                    status = makeFace(MODL, edgeList, fillstyle, SFORWARD, toler, &(faceList[nFaceList]));
                    CHECK_STATUS(makeFace);

                    nFaceList++;
                }
            }
        }

        /* add to faceList those Faces in ebodyl and ebodyr that are
           not one of the Faces that we are removing */
        status = EG_getBodyTopos(ebodyl, NULL, FACE, &nnn, &nnnList);
        CHECK_STATUS(EG_getBodyTopos);

        if (nnnList != NULL) {
            for (iii = 0; iii < nnn; iii++) {
                iadd = 1;

                for (jjj = 0; jjj < args[1].nval; jjj++) {
                    if (NINT(args[1].val[jjj]) == iii+1) {
                        iadd = 0;
                        break;
                    }
                }

                if (ibodyl == ibodyr) {
                    for (jjj = 0; jjj < args[2].nval; jjj++) {
                        if (NINT(args[2].val[jjj]) == iii+1) {
                            iadd = 0;
                            break;
                        }
                    }
                }

                if (iadd == 1) {
                    faceList[nFaceList] = nnnList[iii];
                    nFaceList++;
                }
            }

            EG_free(nnnList);
        }

        if (ibodyl != ibodyr) {
            status = EG_getBodyTopos(ebodyr, NULL, FACE, &nnn, &nnnList);
            CHECK_STATUS(EG_getBodyTopos);

            if (nnnList != NULL) {
                for (iii = 0; iii < nnn; iii++) {
                    iadd = 1;

                    for (jjj = 0; jjj < args[2].nval; jjj++) {
                        if (NINT(args[2].val[jjj]) == iii+1) {
                            iadd = 0;
                            break;
                        }
                    }

                    if (iadd == 1) {
                        faceList[nFaceList] = nnnList[iii];
                        nFaceList++;
                    }
                }

                EG_free(nnnList);
            }
        }

        /* make the (closed) Shell and the SolidBody */
        if (MODL->body[ibodyl].botype == OCSM_SOLID_BODY) {
            status = EG_makeTopology(MODL->context, NULL, SHELL, CLOSED, NULL,
                                     nFaceList, faceList, NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SOLIDBODY, NULL,
                                     1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_CONNECT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

        /* make the (open) Shell and the SheetBody */
        } else {
            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN, NULL,
                                     nFaceList, faceList, NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY, NULL,
                                     1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_CONNECT, ibodyl, ibodyr,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);
        }

        MODL->body[ibody].ebody = ebody;

        /* mark the new Faces with the current Body */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (efaces != NULL) {
            for (iface = 1; iface <= nface; iface++) {
                status = EG_attributeRet(efaces[iface-1], "_body",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_NOTFOUND) {
                    status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                } else {
                    CHECK_STATUS(EG_attributeRet);
                }
            }

            EG_free(efaces);
        }

        /* update @-parameters (CONNECT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);
    }

cleanup:
    FREE(edgeList );
    FREE(faceList );
    FREE(elist    );
    FREE(xyzbeg   );
    FREE(xyzend   );
    FREE(enewFaces);
    FREE(enewEdges);
    FREE(indx     );
    FREE(eloopsc  );
    FREE(sensesc  );
    FREE(newEdges );
    FREE(newSenses);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildGrown - implement OCSM_GROWNs for ocsmBuild                   *
 *                                                                      *
 ************************************************************************
 */

static int
buildGrown(modl_T *modl,                /* (in)  pointer to MODL */
           int    ibrch,                /* (in)  Branch index (1:nbrch) */
           varg_T args[],               /* (in)  array of arguments */
           int    *nstack,              /* (both) number of Bodys on stack */
           int    stack[],              /* (both) array  of Bodys on stack */
           int    npatn,                /* (in)   number of patterns */
           patn_T patn[])               /* (both) array  of patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        type, hasdots, allNodes, iface, nface, nloops, loftOpts, itypebeg, itypeend, i, ii, ival;
    int        sense, inode, iedge, newEbodyl=0;
    int        nsketch, nstrip, ibody, ibodyl, ibodyr, npart, attrType, attrLen;
    int        *isketch=NULL, *jsketch=NULL, *kstrip=NULL, ileft, irite;
    int        oclass, mtype, *senses, *senses2=NULL, iford1, nedges, nfaces, nchild, oneFace, nnode;
    int        j, begPmtr, endPmtr, mode, nsew, *pinfo=NULL, periodic;
    CINT       *tempIlist;
    double     data[9], trange[2], Rbeg[8], Rend[8], matrix[12];
    double     dx, dy, dz, cosx, sinx, cosy, siny, cosz, sinz;
    double     *prv, bbox[6], vals[7];
    double     toler, dirn[3], alen, bbox0[6], bbox1[6], *vmin=NULL, uvlimits[4];
    CDOUBLE    *tempRlist;
    CCHAR      *tempClist;
    ego        ebody, ebodyl, ebodyr, *enodes, *efaces, *echildren, *esketch=NULL;
    ego        eref, exform, etemp, *echilds, *esew=NULL, emodel;
    ego        *enodes2=NULL, ecurve, *eedges2=NULL, eloop, topref, prev, next;

    ROUTINE(buildGrown);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "extrude dx dy dz" */
    if (type == OCSM_EXTRUDE) {
        SPRINT4(1, "    executing [%4d] extrude:    %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* check to be sure that the extrude distance is not zero */
        if (fabs(args[1].val[0]) < EPS06 &&
            fabs(args[2].val[0]) < EPS06 &&
            fabs(args[3].val[0]) < EPS06   ) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "EXTRUDE distance must be non-zero");
            goto cleanup;
        }

        /* pop a Xsect from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "EXTRUDE expects a Body on the stack");
            goto cleanup;
        } else {
                ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        alen = sqrt(args[1].val[0]*args[1].val[0] + args[2].val[0]*args[2].val[0] + args[3].val[0]*args[3].val[0]);
        dirn[0] = args[1].val[0] / alen;
        dirn[1] = args[2].val[0] / alen;
        dirn[2] = args[3].val[0] / alen;

        /* ibodyl is a SheetBody, so create a SolidBody */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRUDE, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_getTopology(MODL->body[ibodyl].ebody, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if        (oclass == BODY && mtype == FACEBODY) {
                status = EG_getTopology(MODL->body[ibodyl].ebody, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebodyl = echilds[0];

            } else if (oclass == BODY && mtype == SHEETBODY) {
                if (nchild != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "found %d Shells in SheetBody but was expecting 1", nchild);
                    goto cleanup;
                }

                etemp = echilds[0];
                status = EG_getTopology(etemp, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (nchild != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "found %d Faces in SheetBody but was expecting 1", nchild);
                    goto cleanup;
                }

                ebodyl = echilds[0];
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "ebody is neither FaceBody nor SheetBody\n");
                goto cleanup;
            }

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_extrude: ebodyl");
                ocsmPrintEgo(ebodyl);
            }

            status = EG_extrude(ebodyl, alen, dirn, &ebody);
            CHECK_STATUS(EG_extrude);

            /* remove Attributes from Faces that start with period and underscore */
            status = removeFaceAttributes(ebody);
            CHECK_STATUS(removeFaceAttributes);

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a WireBody, so create a SheetBody */
        } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRUDE, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_extrude: ebodyl");
                ocsmPrintEgo(ebodyl);
            }

            status = EG_extrude(ebodyl, alen, dirn, &ebody);
            CHECK_STATUS(EG_extrude);

            /* remove Attributes from Faces that start with period and underscore */
            status = removeFaceAttributes(ebody);
            CHECK_STATUS(removeFaceAttributes)

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a NodeBody, so create a WireBody */
        } else if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_EXTRUDE, ibodyl, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_extrude: ebodyl");
                ocsmPrintEgo(ebodyl);
            }

            data[0] = MODL->body[ibodyl].node[1].x;
            data[1] = MODL->body[ibodyl].node[1].y;
            data[2] = MODL->body[ibodyl].node[1].z;
            data[3] = alen * dirn[0];
            data[4] = alen * dirn[1];
            data[5] = alen * dirn[2];
            data[6] = data[0] + data[3];
            data[7] = data[1] + data[4];
            data[8] = data[2] + data[5];

            MALLOC(enodes2, ego, 2);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0, &data[0],
                                     0, NULL, NULL, &enodes2[0]);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0, &data[6],
                                     0, NULL, NULL, &enodes2[1]);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, data, &ecurve);
            CHECK_STATUS(EG_makeGeometry);

            trange[0] = 0;
            trange[1] = alen;
            sense     = SFORWARD;

            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE, trange,
                                     2, enodes2, &sense, &etemp);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN, NULL,
                                     1, &etemp, &sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL,
                                     1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            FREE(enodes2);

            MODL->body[ibody].ebody = ebody;

        } else {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "EXTRUDE expects a SheetBody, WireBody, or NodeBody");
            goto cleanup;
        }

        /* update @-parameters (EXTRUDE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        /* transfer Attributes from Xsect to beginning and ending Faces */
        if (efaces != NULL) {
            if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
                status = EG_attributeDup(ebodyl, efaces[nface-2]);
                CHECK_STATUS(EG_attributeDup);

                status = EG_attributeDup(ebodyl, efaces[nface-1]);
                CHECK_STATUS(EG_attributeDup);
            }

            EG_free(efaces);
        }

        /* mark the new Faces with the current Branch */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            nedges = nface - 2;
        } else {
            nedges = nface;
        }
        for (iface = 1; iface <= nedges; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nedges+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

            status = setFaceAttribute(MODL, ibody, nedges+2, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* finish the Body (EXTRUDE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "revolve xorig yorig zorig dxaxis dyaxis dzaxis angDeg" */
    } else if (type == OCSM_REVOLVE) {
        SPRINT8(1, "    executing [%4d] revolve:    %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0], args[7].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0 || args[7].dot[0] != 0                   ) {
            hasdots = 1;

            SPRINT7(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0], args[7].dot[0]);
        }

        /* require finite differences */
        MODL->needFDs = 1;

        /* check to be sure that the axis is not zero */
        if (fabs(args[4].val[0]) < EPS06 &&
            fabs(args[5].val[0]) < EPS06 &&
            fabs(args[6].val[0]) < EPS06   ) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "axis length must be non-zero");
            goto cleanup;
        }

        /* check to be sure that the angDeg is non-zero */
        if        (fabs(args[7].val[0]) < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "angDeg=%f cannot be zero", args[7].val[0]);
            goto cleanup;
        }

        /* pop a Xsect from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "REVOLVE expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* check that ibodyl is either a WireBody or a SheetBody */
        if (MODL->body[ibodyl].botype != OCSM_SHEET_BODY &&
            MODL->body[ibodyl].botype != OCSM_WIRE_BODY    ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "REVOLVE is expecting a SheetBody or WireBody");
            goto cleanup;
        }

        /* check that a valid angle is given */
        if (args[7].val[0] < -360.0 || args[7].val[0] > 360) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "angle (%f) is not between -360 and +360", args[7].val[0]);
            goto cleanup;
        }

        /* ibodyl is a SheetBody, so create a SolidBody */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_REVOLVE, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            status = EG_getTopology(MODL->body[ibodyl].ebody, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if        (oclass == BODY && mtype == FACEBODY) {
                status = EG_getTopology(MODL->body[ibodyl].ebody, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebodyl = echilds[0];

            } else if (oclass == BODY && mtype == SHEETBODY) {
                if (nchild != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "found %d Shells in SheetBody but was expecting 1", nchild);
                    goto cleanup;
                }

                etemp = echilds[0];
                status = EG_getTopology(etemp, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (nchild != 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "found %d Faces in SheetBody but was expecting 1", nchild);
                    goto cleanup;
                }

                ebodyl = echilds[0];
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "ebody is neither FaceBody nor SheetBody\n");
                goto cleanup;
            }

            /* check if projection of axis of revolution does intersect the Face */
            status = EG_getTopology(ebodyl, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(eref, &oclass, &mtype, &etemp, &pinfo, &prv);
            CHECK_STATUS(EG_getGeometry);

            SPLINT_CHECK_FOR_NULL(prv);

            if (oclass != SURFACE || mtype != PLANE) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "expecting PLANE, but found oclass=%d, mtype=%d", oclass, mtype);
                goto cleanup;
            } else if (fabs(prv[3]) < EPS06 && fabs(prv[6]) < EPS06) {
                status = EG_getBoundingBox(ebodyl, bbox);
                CHECK_STATUS(EG_getBoundingBox);

                if        (args[2].val[0]-bbox[1] <= +EPS06 && args[5].val[0] <= 0) {
                } else if (args[2].val[0]-bbox[4] >= -EPS06 && args[5].val[0] >= 0) {
                } else if (args[3].val[0]-bbox[2] <= +EPS06 && args[6].val[0] <= 0) {
                } else if (args[3].val[0]-bbox[5] >= -EPS06 && args[6].val[0] >= 0) {
                } else {
                    SPRINT0(1, "WARNING:: axis may intersect Face and result may be invalid");
                    SPRINT2(1, "          bbox: ymin=%12.5f   ymax=%12.5f", bbox[1],        bbox[4]       );
                    SPRINT2(1, "          bbox: zmin=%12.5f   zmax=%12.5f", bbox[2],        bbox[5]       );
                    SPRINT2(1, "          base: ybeg=%12.5f   zbeg=%12.5f", args[2].val[0], args[3].val[0]);
                    SPRINT2(1, "          dirn: dy  =%12.5f   dz  =%12.5f", args[5].val[0], args[6].val[0]);
                    (MODL->nwarn)++;
                }
            } else if (fabs(prv[4]) < EPS06 && fabs(prv[7]) < EPS06) {
                status = EG_getBoundingBox(ebodyl, bbox);
                CHECK_STATUS(EG_getBoundingBox);

                if        (args[3].val[0]-bbox[2] <= +EPS06 && args[6].val[0] <= 0) {
                } else if (args[3].val[0]-bbox[5] >= -EPS06 && args[6].val[0] >= 0) {
                } else if (args[1].val[0]-bbox[0] <= +EPS06 && args[4].val[0] <= 0) {
                } else if (args[1].val[0]-bbox[3] >= -EPS06 && args[4].val[0] >= 0) {
                } else {
                    SPRINT0(1, "WARNING:: axis may intersect Face and result may be invalid");
                    SPRINT2(1, "          bbox: zmin=%12.5f   zmax=%12.5f", bbox[2],        bbox[5]       );
                    SPRINT2(1, "          bbox: xmin=%12.5f   xmax=%12.5f", bbox[0],        bbox[3]       );
                    SPRINT2(1, "          base: zbeg=%12.5f   ybeg=%12.5f", args[3].val[0], args[1].val[0]);
                    SPRINT2(1, "          dirn: dz  =%12.5f   dy  =%12.5f", args[6].val[0], args[4].val[0]);
                    (MODL->nwarn)++;
                }
            } else if (fabs(prv[5]) < EPS06 && fabs(prv[8]) < EPS06) {
                status = EG_getBoundingBox(ebodyl, bbox);
                CHECK_STATUS(EG_getBoundingBox);

                if        (args[1].val[0]-bbox[0] <= +EPS06 && args[4].val[0] <= 0) {
                } else if (args[1].val[0]-bbox[3] >= -EPS06 && args[4].val[0] >= 0) {
                } else if (args[2].val[0]-bbox[1] <= +EPS06 && args[5].val[0] <= 0) {
                } else if (args[2].val[0]-bbox[4] >= -EPS06 && args[5].val[0] >= 0) {
                } else {
                    SPRINT0(1, "WARNING:: axis may intersect Face and result may be invalid");
                    SPRINT2(1, "          bbox: xmin=%12.5f   xmax=%12.5f", bbox[0],        bbox[3]       );
                    SPRINT2(1, "          bbox: ymin=%12.5f   ymax=%12.5f", bbox[1],        bbox[4]       );
                    SPRINT2(1, "          base: xbeg=%12.5f   ybeg=%12.5f", args[1].val[0], args[2].val[0]);
                    SPRINT2(1, "          dirn: dx  =%12.5f   dy  =%12.5f", args[4].val[0], args[5].val[0]);
                    (MODL->nwarn)++;
                }
            } else {
                SPRINT0(1, "WARNING:: Face is not aligned with coordinate axes and thus cannot be checked");
                SPRINT3(1, "Point: %12.5f %12.5f %12.5f", prv[0], prv[1], prv[2]);
                SPRINT3(1, "Xaxis: %12.5f %12.5f %12.5f", prv[3], prv[4], prv[5]);
                SPRINT3(1, "Yaxis: %12.5f %12.5f %12.5f", prv[6], prv[7], prv[8]);
                (MODL->nwarn)++;
            }

            if (args[7].val[0] > 0) {
                if (outLevel >= 3) {
                    SPRINT0(3, "before EG_rotate: ebodyl");
                    ocsmPrintEgo(ebodyl);
                }

                vals[0] = args[1].val[0];
                vals[1] = args[2].val[0];
                vals[2] = args[3].val[0];
                vals[3] = args[4].val[0];
                vals[4] = args[5].val[0];
                vals[5] = args[6].val[0];

                status = EG_rotate(ebodyl, args[7].val[0], vals, &ebody);
                CHECK_STATUS(EG_rotate);

                /* remove Attributes from Faces that start with period and underscore */
                status = removeFaceAttributes(ebody);
                CHECK_STATUS(removeFaceAttributes)
            } else {
                if (outLevel >= 3) {
                    SPRINT0(3, "before EG_rotate: ebodyl");
                    ocsmPrintEgo(ebodyl);
                }

                vals[0] = args[1].val[0];
                vals[1] = args[2].val[0];
                vals[2] = args[3].val[0];
                vals[3] = args[4].val[0];
                vals[4] = args[5].val[0];
                vals[5] = args[6].val[0];

                status = EG_rotate(ebodyl, fabs(args[7].val[0]), vals, &etemp);
                CHECK_STATUS(EG_rotate);

                /* remove Attributes from Faces that start with period and underscore */
                status = removeFaceAttributes(etemp);
                CHECK_STATUS(removeFaceAttributes)

                if        (fabs(args[5].val[0]) < EPS06 && fabs(args[6].val[0]) < EPS06) {
                    cosx = cos(args[7].val[0] * PIo180);
                    sinx = sin(args[7].val[0] * PIo180);
                    dy   =     args[2].val[0];
                    dz   =     args[3].val[0];

                    matrix[ 0] = 1; matrix[ 1] = 0;    matrix[ 2] = 0;    matrix[ 3] = 0;
                    matrix[ 4] = 0; matrix[ 5] = cosx; matrix[ 6] =-sinx; matrix[ 7] = dy - dy * cosx + dz * sinx;
                    matrix[ 8] = 0; matrix[ 9] = sinx; matrix[10] = cosx; matrix[11] = dz - dy * sinx - dz * cosx;
                } else if (fabs(args[4].val[0]) < EPS06 && fabs(args[6].val[0]) < EPS06) {
                    cosy = cos(args[7].val[0] * PIo180);
                    siny = sin(args[7].val[0] * PIo180);
                    dz   =     args[3].val[0];
                    dx   =     args[1].val[0];

                    matrix[ 0] = cosy; matrix[ 1] = 0; matrix[ 2] = siny; matrix[ 3] = dx - dz * siny - dx * cosy;
                    matrix[ 4] = 0;    matrix[ 5] = 1; matrix[ 6] = 0;    matrix[ 7] = 0;
                    matrix[ 8] =-siny; matrix[ 9] = 0; matrix[10] = cosy; matrix[11] = dz - dz * cosy + dx * siny;
                } else if (fabs(args[4].val[0]) < EPS06 && fabs(args[5].val[0]) < EPS06) {
                    cosz = cos(args[7].val[0] * PIo180);
                    sinz = sin(args[7].val[0] * PIo180);
                    dx   =     args[1].val[0];
                    dy   =     args[2].val[0];

                    matrix[ 0] = cosz; matrix[ 1] =-sinz; matrix[ 2] = 0; matrix[ 3] = dx - dx * cosz + dy * sinz;
                    matrix[ 4] = sinz; matrix[ 5] = cosz; matrix[ 6] = 0; matrix[ 7] = dy - dx * sinz - dy * cosz;
                    matrix[ 8] = 0;    matrix[ 9] = 0;    matrix[10] = 1; matrix[11] = 0;
                } else {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "not aligned with axis (%f, %f, %f)", args[4].val[0], args[5].val[0], args[6].val[0]);
                    goto cleanup;
                }

                status = EG_makeTransform(MODL->context, matrix, &exform);
                CHECK_STATUS(EG_makeTransform);

                status = EG_copyObject(etemp, exform, &ebody);
                CHECK_STATUS(EG_copyObject);

                status = EG_deleteObject(exform);
                CHECK_STATUS(EG_deleteObject);
            }

            if (pinfo != NULL) EG_free(pinfo);
            if (prv   != NULL) EG_free(prv  );

            MODL->body[ibody].ebody = ebody;

        /* ibodyl is a WireBody, so create a SheetBody */
        } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_REVOLVE, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            if (outLevel >= 3) {
                SPRINT0(3, "before EG_rotate: ebodyl");
                ocsmPrintEgo(ebodyl);
            }

            vals[0] = args[1].val[0];
            vals[1] = args[2].val[0];
            vals[2] = args[3].val[0];
            vals[3] = args[4].val[0];
            vals[4] = args[5].val[0];
            vals[5] = args[6].val[0];

            status = EG_rotate(ebodyl, args[7].val[0], vals, &ebody);
            CHECK_STATUS(EG_rotate);

            /* remove Attributes from Faces that start with period and underscore */
            status = removeFaceAttributes(ebody);
            CHECK_STATUS(removeFaceAttributes)

            MODL->body[ibody].ebody = ebody;

        } else {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "REVOLVE expects a SheetBody or WireBody");
            goto cleanup;
        }

        /* update @-parameters (REVOLVE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        /* transfer Attributes from Xsect to beginning and ending Faces */
        if (efaces != NULL) {
            if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
                fabs(args[7].val[0]-360) > EPS06               ) {
                status = EG_attributeDup(ebodyl, efaces[nface-2]);
                CHECK_STATUS(EG_attributeDup);

                status = EG_attributeDup(ebodyl, efaces[nface-1]);
                CHECK_STATUS(EG_attributeDup);
            }

            EG_free(efaces);
        }

        /* mark the new Faces with the current Branch */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
            fabs(fabs(args[7].val[0])-360) > EPS06         ) {
            nedges = nface - 2;
        } else {
            nedges = nface;
        }
        for (iface = 1; iface <= nedges; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY &&
            fabs(fabs(args[7].val[0])-360) > EPS06         ) {
            status = setFaceAttribute(MODL, ibody, nedges+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

            status = setFaceAttribute(MODL, ibody, nedges+2, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* finish the Body (REVOLVE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "rule reorder=0 periodic=0" */
    } else if (type == OCSM_RULE) {
        SPRINT3(1, "    executing [%4d] rule:       %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0]);

        periodic = NINT(args[2].val[0]);

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            while ((*nstack) > 0) {
                ibodyl = stack[--(*nstack)];
                if (ibodyl == 0) break;      /* mark is found */
            }

            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* pop Xsects from the stack (until the Mark) and put them
           into isketch from first to last */
        MALLOC(isketch, int, (*nstack+1));
        MALLOC(esketch, ego, (*nstack+1));

        nsketch  =  0;
        nstrip   = -1;
        itypebeg = -1;
        itypeend = -1;
        ibodyl   = -1;
        while ((*nstack) > 0) {
            ibodyl = stack[--(*nstack)];

            if (ibodyl == 0) break;          /* mark is found */

            if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {
                if (nsketch == 0) {
                    itypeend = MODL->body[ibodyl].botype;
                }

                itypebeg = MODL->body[ibodyl].botype;

                for (j = nsketch; j > 0; j--) {
                    isketch[j] = isketch[j-1];
                    esketch[j] = esketch[j-1];
                }

                status = EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, NODE, &nnode, &enodes);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(enodes);

                isketch[0] = ibodyl;
                esketch[0] = enodes[0];
                nsketch++;

                EG_free(enodes);

            } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY ||
                       MODL->body[ibodyl].botype == OCSM_SHEET_BODY  ) {
                ebodyl = MODL->body[ibodyl].ebody;

                if (MODL->body[ibodyl].botype  == OCSM_WIRE_BODY &&
                    MODL->body[ibodyl].nonmani == 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "RULE cannot be applied to non-manifold WireBodys (%d)", ibodyl);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloops, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nloops != 1) {
                    signalError(MODL, OCSM_ERROR_IN_BODYS_ON_STACK,
                                "expecting 1 Loop but found %d", nloops);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedges, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nsketch == 0) {
                    itypeend = MODL->body[ibodyl].botype;
                }

                itypebeg = MODL->body[ibodyl].botype;

                if (nstrip < 0) {
                    nstrip = nedges;
                } else if (nstrip != nedges) {
                    signalError(MODL, OCSM_ERROR_IN_BODYS_ON_STACK,
                                "expecting %d Edges but found %d", nstrip, nedges);
                    goto cleanup;
                }

                for (j = nsketch; j > 0; j--) {
                    isketch[j] = isketch[j-1];
                    esketch[j] = esketch[j-1];
                }
                isketch[0] = ibodyl;
                esketch[0] = ebodyl;
                nsketch++;
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "Body %d is neither NodeBody, WireBody, nor SheetBody", ibodyl);
                goto cleanup;
            }
        }

        if (nsketch < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "RULE expects 2 or more Bodys since mark");
            goto cleanup;
        } else {
            SPRINT2(1, "                          ruling  %d Xsects with %d Strips each...",
                    nsketch, nstrip);
        }

        /* special case for RULE of all NodeBodys */
        allNodes = 1;
        for (i = 0; i < nsketch; i++) {
            if (MODL->body[isketch[i]].botype != OCSM_NODE_BODY) {
                allNodes = 0;
                break;
            }
        }

        if (allNodes == 1) {

            /* check for multiplicity>1 at first and last Nodes */
            if        (fabs(MODL->body[isketch[0]].node[1].x-MODL->body[isketch[1]].node[1].x) < EPS06 &&
                       fabs(MODL->body[isketch[0]].node[1].y-MODL->body[isketch[1]].node[1].y) < EPS06 &&
                       fabs(MODL->body[isketch[0]].node[1].z-MODL->body[isketch[1]].node[1].z) < EPS06   ) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "First Node cannot be repeated");
                goto cleanup;
            } else if (fabs(MODL->body[isketch[nsketch-1]].node[1].x-MODL->body[isketch[nsketch-2]].node[1].x) < EPS06 &&
                       fabs(MODL->body[isketch[nsketch-1]].node[1].y-MODL->body[isketch[nsketch-2]].node[1].y) < EPS06 &&
                       fabs(MODL->body[isketch[nsketch-1]].node[1].z-MODL->body[isketch[nsketch-2]].node[1].z) < EPS06   ) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "Last Node cannot be repeated");
                goto cleanup;
            }

            status = EG_ruled(nsketch, esketch, &ebody);
            CHECK_STATUS(EG_ruled);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_RULE, ibodyl, ibodyl,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* link this new Body with its children */
            for (i = 0; i < nsketch; i++) {
                if (isketch[i] != 0) {
                    MODL->body[isketch[i]].ichld = ibody;
                }
            }

            MODL->body[ibody].ebody = ebody;
            MODL->body[ibody].ileft = isketch[0];
            MODL->body[ibody].irite = isketch[nsketch-1];

            /* remember the Bodys used to create this RULE */
            status = EG_attributeAdd(ebody, "__usedBodys__", ATTRINT, nsketch, isketch, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);

            /* update @-parameters (RULE) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* finish the Body (RULE) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

            goto cleanup;
        }

        /* check for multiplicity>1 */
        for (i = 1; i < nsketch; i++) {
            if (MODL->body[isketch[i-1]].botype == OCSM_SHEET_BODY &&
                MODL->body[isketch[i  ]].botype == OCSM_SHEET_BODY   ) {

                status = EG_getBoundingBox(MODL->body[isketch[i-1]].ebody, bbox0);
                CHECK_STATUS(EG_getBoundingBox);

                status = EG_getBoundingBox(MODL->body[isketch[i  ]].ebody, bbox1);
                CHECK_STATUS(EG_getBoundingBox);

                if (fabs(bbox0[0]-bbox1[0]) < EPS06 &&
                    fabs(bbox0[1]-bbox1[1]) < EPS06 &&
                    fabs(bbox0[2]-bbox1[2]) < EPS06 &&
                    fabs(bbox0[3]-bbox1[3]) < EPS06 &&
                    fabs(bbox0[4]-bbox1[4]) < EPS06 &&
                    fabs(bbox0[5]-bbox1[5]) < EPS06   ) {
                    if (i == 1 || i == nsketch-1) {
                        signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "First and last Xsects cannot be repeated");
                        goto cleanup;
                    } else {
                        SPRINT1(0, "WARNING:: repeated section in RULE (%d) ignored",
                                isketch[i]);
                        (MODL->nwarn)++;
                    }
                }
            }
        }

        /* if the periodicity flag is set, connect the last and first
           sections (as long as they are not NodeBodys) */
        if (periodic == 1) {
            if (MODL->body[isketch[0        ]].botype == OCSM_NODE_BODY ||
                MODL->body[isketch[nsketch-1]].botype == OCSM_NODE_BODY   ) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "First and last Sections cannot be NodeBodys if periodic");
                goto cleanup;
            }

            isketch[nsketch] = isketch[0];
            esketch[nsketch] = esketch[0];
            nsketch++;
        }

        /* create the Body (assume for now it is a SolidBody --- to be fixed below) */
        status = newBody(MODL, ibrch, OCSM_RULE, ibodyl, ibodyl,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        /* link this new Body with its children */
        for (i = 0; i < nsketch; i++) {
            if (isketch[i] != 0) {
                MODL->body[isketch[i]].ichld = ibody;
            }
        }

        MODL->body[ibody].ileft = isketch[0];
        MODL->body[ibody].irite = isketch[nsketch-1];

        /* first Xsect should be a NODE, WIREBODY, or FACE */
        if (periodic == 0) {
            if (itypebeg == OCSM_SHEET_BODY) {
                status = EG_getBodyTopos(esketch[0], NULL, FACE, &nfaces, &echildren);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(echildren);

                esketch[0] = echildren[0];

                EG_free(echildren);
            }

            /* last Xsect should be a NODE, WIREBODY, or FACE */
            if (itypeend == OCSM_SHEET_BODY) {
                status = EG_getBodyTopos(esketch[nsketch-1], NULL, FACE, &nfaces, &echildren);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(echildren);

                esketch[nsketch-1] = echildren[0];

                EG_free(echildren);
            }

        /* convert first and last Xsects to Loops if periodic */
        } else {
            status = EG_getBodyTopos(esketch[0], NULL, LOOP, &nloops, &echildren);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(echildren);

            esketch[0        ] = echildren[0];
            esketch[nsketch-1] = echildren[0];

            EG_free(echildren);
        }

        /* convert all the intermediate Xsects to LOOPs */
        for (i = 1; i < nsketch-1; i++) {
            status = EG_getBodyTopos(esketch[i], NULL, LOOP, &nloops, &echildren);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(echildren);

            esketch[i] = echildren[0];

            EG_free(echildren);
        }

        /* reorder Loops to eliminate twisting */
        status = reorderLoops(MODL, nsketch, esketch, NINT(args[1].val[0]));
        CHECK_STATUS(reorderLoops);

        /* create the Body */
        if (outLevel >= 3) {
            for (ii = 0; ii < nsketch; ii++) {
                SPRINT1(3, "before EG_ruled: esketch[%d]", ii);
                ocsmPrintEgo(esketch[ii]);
            }
        }

        status = EG_ruled(nsketch, esketch, &ebody);

        if (status < SUCCESS) {
            signalError(MODL, status,
                        "EG_ruled returned an unexpected error");
            goto cleanup;
        }

        MODL->body[ibody].ebody = ebody;

        /* update the Body type if a SheetBody was produced */
        status = EG_getTopology(ebody, &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        if (oclass == BODY) {
            if (mtype == SHEETBODY || mtype == FACEBODY) {
                SPRINT0(1, "WARNING:: rule produced a SheetBody");
                (MODL->nwarn)++;
                MODL->body[ibody].botype = OCSM_SHEET_BODY;
            } else if (mtype != SOLIDBODY) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "Body produced is neither SheetBody or SolidBody");
                goto cleanup;
            }
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "EGO produced is not a Body");
            SET_STATUS(OCSM_INTERNAL_ERROR, rule);
        }

        /* update the Body type if periodic and the first and last
           sections were both WireBodys */
        if (periodic == 1) {
            if (MODL->body[isketch[0        ]].botype == OCSM_WIRE_BODY &&
                MODL->body[isketch[nsketch-2]].botype == OCSM_WIRE_BODY   ) {
                status = EG_getTopology(ebody, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (oclass == BODY || mtype == SOLIDBODY) {
                    status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                             data, 1, echilds, senses, &emodel);
                    CHECK_STATUS(EG_makeTopology);

                    status = EG_deleteObject(ebody);
                    CHECK_STATUS(EG_deleteBody);

                    ebody = emodel;

                    MODL->body[ibody].botype = OCSM_SHEET_BODY;
                    MODL->body[ibody].ebody  = ebody;
                }
            }
        }

        /* remember the Bodys used to create this RULE */
        status = EG_attributeAdd(ebody, "__usedBodys__", ATTRINT, nsketch, isketch, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);

        /* update @-parameters (RULE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, NULL);
        CHECK_STATUS(EG_getBodyTopos);

        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) nface--;
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) nface--;

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
            nface++;
        }
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* finish the Body (RULE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "loft smooth" */
    } else if (type == OCSM_LOFT) {
        SPRINT2(1, "    executing [%4d] loft:       %11.5f",
                ibrch, args[1].val[0]);

        /* require finite differences */
        MODL->needFDs = 1;

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            while ((*nstack) > 0) {
                ibodyl = stack[--(*nstack)];
                if (ibodyl == 0) break;      /* mark is found */
            }

            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* pop Xsects from the stack (until the Mark) and put them
           into isketch from last to first */
        MALLOC(isketch, int, (*nstack));
        MALLOC(esketch, ego, (*nstack));

        nsketch  = 0;
        loftOpts = -1;
        ibodyl   = -1;
        ibodyr   = -1;
        while ((*nstack) > 0) {
            ibodyl = stack[--(*nstack)];

            if (ibodyl == 0) break;          /* mark is found */

            if (nsketch == 0) {
                if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {
                    loftOpts = 0;
                } else {
                    loftOpts = 1;
                }
            }

            ebodyl = MODL->body[ibodyl].ebody;

            if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {
                status = EG_getBodyTopos(ebodyl, NULL, NODE, &nnode, &enodes);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(enodes);

                isketch[nsketch] = ibodyl;
                esketch[nsketch] = enodes[0];

                EG_free(enodes);
                nsketch++;
            } else {
                if (MODL->body[ibodyl].botype  == OCSM_WIRE_BODY &&
                    MODL->body[ibodyl].nonmani == 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "LOFT cannot be applied to non-manifold WireBodys (%d)", ibodyl);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloops, &echildren);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(echildren);

                isketch[nsketch] = ibodyl;
                esketch[nsketch] = echildren[0];
                nsketch++;

                EG_free(echildren);
            }

            ibodyr = ibodyl;
        }

        if (nsketch < 2 || ibodyl < 0) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "UNION expects 2 or more Bodys since mark");
            goto cleanup;
        } else {
            SPRINT1(1, "                          lofting %d Xsects...", nsketch);
        }
        ibodyl = isketch[0];

        /* determine if SheetBody or SolidBody should be created */
        if (MODL->body[ibodyr].botype == OCSM_WIRE_BODY) {
            loftOpts = 0;
        }

        /* create the new Body */
        if (loftOpts == 0) {
            status = newBody(MODL, ibrch, OCSM_LOFT, ibodyr, ibodyl,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);
        } else {
            status = newBody(MODL, ibrch, OCSM_LOFT, ibodyr, ibodyl,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);
        }

        /* all Bodys in Loft should point to new Body */
        for (i = 0; i < nsketch; i++) {
            if (isketch[i] != 0) {
                MODL->body[isketch[i]].ichld = ibody;
            }
        }

        if (NINT(args[1].val[0]) != 1) {
            loftOpts += 2;
        }

        if (outLevel >= 3) {
            for (ii = 0; ii < nsketch; ii++) {
                SPRINT1(3, "before EG_loft: esketch[%d]", ii);
                ocsmPrintEgo(esketch[ii]);
            }
        }
        status = EG_loft(nsketch, esketch, loftOpts, &ebody);
        CHECK_STATUS(EG_loft);

        /* if a SheetBody and ibodyl is SheetBody, sew them together */
        if (MODL->body[ibody ].botype == OCSM_SHEET_BODY &&
            MODL->body[ibodyl].botype == OCSM_SHEET_BODY   ) {

            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (efaces != NULL) {
                nsew = nface + 1;
                MALLOC(esew, ego, nsew);
                for (i = 0; i < nsew-1; i++) {
                    esew[i] = efaces[i];
                }

                EG_free(efaces);

                status = EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(efaces);

                esew[nsew-1] = efaces[0];

                EG_free(efaces);

                status = EG_sewFaces(nsew, esew, 0.0, 1, &emodel);
                CHECK_STATUS(EG_sewFaces);

                FREE(esew);

                status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebody = echilds[0];
            }

        /* if a SheetBody and ibodyr is SheetBody, sew them together */
        } else if (MODL->body[ibody ].botype == OCSM_SHEET_BODY &&
                   MODL->body[ibodyr].botype == OCSM_SHEET_BODY   ) {

            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (efaces != NULL) {
                nsew = nface + 1;
                MALLOC(esew, ego, nsew);
                for (i = 0; i < nsew-1; i++) {
                    esew[i] = efaces[i];
                }

                EG_free(efaces);

                status = EG_getBodyTopos(MODL->body[ibodyr].ebody, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(efaces);

                esew[nsew-1] = efaces[0];

                EG_free(efaces);

                status = EG_sewFaces(nsew, esew, 0.0, 1, &emodel);
                CHECK_STATUS(EG_sewFaces);

                FREE(esew);

                status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                ebody = echilds[0];
            }
        }

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (LOFT) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, NULL);
        CHECK_STATUS(EG_getBodyTopos);

        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) nface--;
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) nface--;

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
            nface++;
        }
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* finish the Body (LOFT) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "blend begList=0 endList=0 reorder=0 oneFace=0 periodic=0" */
    } else if (type == OCSM_BLEND) {
        SPRINT6(1, "    executing [%4d] blend:      %s  %s  %11.5f  %11.5f  %11.5f",
                ibrch, MODL->brch[ibrch].arg1, MODL->brch[ibrch].arg2, args[3].val[0], args[4].val[0], args[5].val[0]);

        for (ival = 0; ival < args[1].nval; ival++) {
            if (args[1].dot[ival] != 0) hasdots = 1;
        }

        for (ival = 0; ival < args[2].nval; ival++) {
            if (args[2].dot[ival] != 0) hasdots = 1;
        }

        oneFace  = NINT(args[4].val[0]);
        periodic = NINT(args[5].val[0]);

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            while ((*nstack) > 0) {
                ibodyl = stack[--(*nstack)];
                if (ibodyl == 0) break;      /* mark is found */
            }

            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* pop Xsects from the stack (until the Mark) and put them
           into isketch from first to last */
        MALLOC(isketch, int, (*nstack)+1);
        MALLOC(jsketch, int, (*nstack)+1);
        MALLOC(esketch, ego, (*nstack)+1);

        nsketch  =  0;
        nstrip   = -1;
        itypebeg = -1;
        itypeend = -1;
        ibodyl   = -1;
        while ((*nstack) > 0) {
            ibodyl = stack[--(*nstack)];

            if (ibodyl == 0) break;          /* mark is found */
            if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {
                if (nsketch == 0) {
                    itypeend = MODL->body[ibodyl].botype;
                }

                itypebeg = MODL->body[ibodyl].botype;

                for (j = nsketch; j > 0; j--) {
                    isketch[j] = isketch[j-1];
                    jsketch[j] = jsketch[j-1];
                    esketch[j] = esketch[j-1];
                }

                status = EG_getBodyTopos(MODL->body[ibodyl].ebody, NULL, NODE, &nnode, &enodes);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(enodes);

                isketch[0] = ibodyl;
                jsketch[0] = 0;
                esketch[0] = enodes[0];

                EG_free(enodes);
                nsketch++;

            } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY ||
                       MODL->body[ibodyl].botype == OCSM_SHEET_BODY  ) {
                ebodyl = MODL->body[ibodyl].ebody;

                if (MODL->body[ibodyl].botype  == OCSM_WIRE_BODY &&
                    MODL->body[ibodyl].nonmani == 1) {
                    signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                                "BLEND cannot be applied to non-manifold WireBodys (%d)", ibodyl);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloops, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nloops != 1) {
                    signalError(MODL, OCSM_ERROR_IN_BODYS_ON_STACK,
                                "expecting 1 Loop but found %d", nloops);
                    goto cleanup;
                }

                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedges, NULL);
                CHECK_STATUS(EG_getBodyTopos);

                if (nsketch == 0) {
                    itypeend = MODL->body[ibodyl].botype;
                }

                itypebeg = MODL->body[ibodyl].botype;

                if (nstrip < 0) {
                    nstrip = nedges;
                } else if (nstrip != nedges) {
                    signalError(MODL, OCSM_ERROR_IN_BODYS_ON_STACK,
                                "expecting %d Edges but found %d", nstrip, nedges);
                    goto cleanup;
                }

                for (j = nsketch; j > 0; j--) {
                    isketch[j] = isketch[j-1];
                    jsketch[j] = jsketch[j-1];
                    esketch[j] = esketch[j-1];
                }
                isketch[0] = ibodyl;
                jsketch[0] = 1;
                esketch[0] = ebodyl;
                nsketch++;
            } else {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "Body %d is neither NODE, WireBody, nor SheetBody", ibodyl);
                goto cleanup;
            }
        }

        /* special case for BLEND of all NodeBodys */
        allNodes = 1;
        for (i = 0; i < nsketch; i++) {
            if (MODL->body[isketch[i]].botype != OCSM_NODE_BODY) {
                allNodes = 0;
                break;
            }
        }

        if (allNodes == 1) {

            /* check for multiplicity>1 at first and last Nodes */
            if        (fabs(MODL->body[isketch[0]].node[1].x-MODL->body[isketch[1]].node[1].x) < EPS06 &&
                       fabs(MODL->body[isketch[0]].node[1].y-MODL->body[isketch[1]].node[1].y) < EPS06 &&
                       fabs(MODL->body[isketch[0]].node[1].z-MODL->body[isketch[1]].node[1].z) < EPS06   ) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "First Node cannot be repeated");
                goto cleanup;
            } else if (fabs(MODL->body[isketch[nsketch-1]].node[1].x-MODL->body[isketch[nsketch-2]].node[1].x) < EPS06 &&
                       fabs(MODL->body[isketch[nsketch-1]].node[1].y-MODL->body[isketch[nsketch-2]].node[1].y) < EPS06 &&
                       fabs(MODL->body[isketch[nsketch-1]].node[1].z-MODL->body[isketch[nsketch-2]].node[1].z) < EPS06   ) {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "Last Node cannot be repeated");
                goto cleanup;
            }

            status = EG_blend(nsketch, esketch, NULL, NULL, &ebody);
            CHECK_STATUS(EG_blend);

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_BLEND, ibodyl, ibodyl,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* link this new Body with its children */
            for (i = 0; i < nsketch; i++) {
                if (isketch[i] != 0) {
                    MODL->body[isketch[i]].ichld = ibody;
                }
            }

            MODL->body[ibody].ebody = ebody;
            MODL->body[ibody].ileft = isketch[0];
            MODL->body[ibody].irite = isketch[nsketch-1];

            /* remember the Bodys used to create this BLEND */
            status = EG_attributeAdd(ebody, "__usedBodys__", ATTRINT, nsketch, isketch, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);

            /* update @-parameters (BLEND) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* finish the Body (BLEND) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

            goto cleanup;
        }

        /* determine the type/multiplicity of the Xsects */
        for (i = 0; i < nsketch-3; i++) {
            if (jsketch[i] != 1 || jsketch[i+1] != 1 || jsketch[i+2] != 1) continue;

            status = EG_getBoundingBox(MODL->body[isketch[i  ]].ebody, bbox0);
            CHECK_STATUS(EG_getBoundingBox);

            status = EG_getBoundingBox(MODL->body[isketch[i+2]].ebody, bbox1);
            CHECK_STATUS(EG_getBoundingBox);

            if (fabs(bbox0[0]-bbox1[0]) < EPS06 &&
                fabs(bbox0[1]-bbox1[1]) < EPS06 &&
                fabs(bbox0[2]-bbox1[2]) < EPS06 &&
                fabs(bbox0[3]-bbox1[3]) < EPS06 &&
                fabs(bbox0[4]-bbox1[4]) < EPS06 &&
                fabs(bbox0[5]-bbox1[5]) < EPS06   ) {
                jsketch[i  ] = 3;
                jsketch[i+1] = 3;
                jsketch[i+2] = 3;
                i += 2;
            }
        }

        for (i = 0; i < nsketch-2; i++) {
            if (jsketch[i] != 1 || jsketch[i+1] != 1) continue;

            status = EG_getBoundingBox(MODL->body[isketch[i  ]].ebody, bbox0);
            CHECK_STATUS(EG_getBoundingBox);

            status = EG_getBoundingBox(MODL->body[isketch[i+1]].ebody, bbox1);
            CHECK_STATUS(EG_getBoundingBox);

            if (fabs(bbox0[0]-bbox1[0]) < EPS06 &&
                fabs(bbox0[1]-bbox1[1]) < EPS06 &&
                fabs(bbox0[2]-bbox1[2]) < EPS06 &&
                fabs(bbox0[3]-bbox1[3]) < EPS06 &&
                fabs(bbox0[4]-bbox1[4]) < EPS06 &&
                fabs(bbox0[5]-bbox1[5]) < EPS06   ) {
                jsketch[i  ] = 2;
                jsketch[i+1] = 2;
                i += 1;
            }
        }

        for (i = 0; i < nsketch; i++) {
            SPRINT4(3, "    isketch[%2d]=%3d   jsketch[%2d]=%d",
                    i, isketch[i], i, jsketch[i]);
        }

        /* we need at least two non-Node Xsects */
        if (nsketch < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "BLEND expects 2 or more Bodys since mark");
            goto cleanup;
        }

        /* there must be three or more Xsects between rounded begs and ends */
        if (itypebeg == OCSM_NODE_BODY && args[1].nval >= 8 &&
            itypeend == OCSM_NODE_BODY && args[2].nval >= 8 && nsketch < 5) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "BLEND expects 3 or more Xsects between rounded beg and end");
            goto cleanup;
        }

        /* there cannot be three or more consecutive C1 (multiplicity=2) Xsects */
        for (i = 1; i < nsketch-5; i++) {
            if (jsketch[i  ] == 2 && jsketch[i+1] == 2 &&
                jsketch[i+2] == 2 && jsketch[i+3] == 2 &&
                jsketch[i+4] == 2 && jsketch[i+5] == 2   ) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "BLEND cannot have three or more consecutive C1 sections");
                goto cleanup;
            }
        }

        /* these cannot be multiplicity>1 for first/last Xsects */
        if (jsketch[0] > 1 || jsketch[nsketch-1] > 1) {
            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                        "First and last Sections cannot have multiplicity>1");
            goto cleanup;
        }

        SPRINT2(1, "                          blending  %d Xsects with %d Strips each...",
                nsketch, nstrip);

        /* if the periodicity flag is set, connect the last and first
           sections (as long as they are not NodeBodys) */
        if (periodic == 1) {
            if (MODL->body[isketch[0        ]].botype == OCSM_NODE_BODY ||
                MODL->body[isketch[nsketch-1]].botype == OCSM_NODE_BODY   ) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "First and last Xsects cannot be NodeBodys if periodic");
                goto cleanup;
            }

            isketch[nsketch] = isketch[0];
            jsketch[nsketch] = jsketch[0];
            esketch[nsketch] = esketch[0];
            nsketch++;
        }

        /* create the Body (assume for now it is a SolidBody --- to be fixed below) */
        status = newBody(MODL, ibrch, OCSM_BLEND, ibodyl, ibodyl,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        /* link this new Body with its children */
        for (i = 0; i < nsketch; i++) {
            if (isketch[i] != 0) {
                MODL->body[isketch[i]].ichld = ibody;
            }
        }

        MODL->body[ibody].ileft = isketch[0];
        MODL->body[ibody].irite = isketch[nsketch-1];

        /* first Xsect should be a NODE, WIREBODY, or FACE */
        if (periodic == 0) {
            if (itypebeg == OCSM_SHEET_BODY) {
                status = EG_getBodyTopos(esketch[0], NULL, FACE, &nfaces, &echildren);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(echildren);

                esketch[0] = echildren[0];

                EG_free(echildren);
            }

            /* last Xsect should be a NODE, WIREBODY, or FACE */
            if (itypeend == OCSM_SHEET_BODY) {
                status = EG_getBodyTopos(esketch[nsketch-1], NULL, FACE, &nfaces, &echildren);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(echildren);

                esketch[nsketch-1] = echildren[0];

                EG_free(echildren);
            }

        /* convert first and last Xsects to Loops if periodic */
        } else {
            status = EG_getBodyTopos(esketch[0], NULL, LOOP, &nloops, &echildren);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(echildren);

            esketch[0        ] = echildren[0];
            esketch[nsketch-1] = echildren[0];

            EG_free(echildren);
        }

        /* convert all the intermediate Xsects to LOOPs */
        for (i = 1; i < nsketch-1; i++) {
            status = EG_getBodyTopos(esketch[i], NULL, LOOP, &nloops, &echildren);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(echildren);

            esketch[i] = echildren[0];

            EG_free(echildren);
        }

        /* store info from begList into Rbeg */
        if (itypebeg == OCSM_NODE_BODY) {

            /* rounded beg */
            if (args[1].nval == 8) {
                begPmtr = 8;
                for (i = 0; i < begPmtr; i++) {
                    Rbeg[i] = args[1].val[i];
                }

            /* sharp beg (because begList=0) */
            } else if (args[1].val[0] == 0) {
                begPmtr = 0;

            /* sharp beg (because begList did not contain enough values) */
            } else {
                begPmtr = 0;
                SPRINT1(1, "WARNING:: begList only has %d values", args[1].nval);
                SPRINT0(1, "          reverting to sharp beg");
                (MODL->nwarn)++;
            }
        } else {

            /* rounded tip at beg */
            if (args[1].nval == 2 && args[1].val[0] < 0) {
                begPmtr = 2;
                Rbeg[0] = 0;
                Rbeg[1] = args[1].val[1];

            /* tangency */
            } else if (args[1].nval == 3) {
                begPmtr = 4;
                Rbeg[0] = 1;
                Rbeg[1] = args[1].val[0];
                Rbeg[2] = args[1].val[1];
                Rbeg[3] = args[1].val[2];

            /* blunt beg */
            } else {
                begPmtr = 0;
            }
        }

        /* store info from endList into Rend */
        if (itypeend == OCSM_NODE_BODY) {

            /* rounded end */
            if (args[2].nval == 8) {
                endPmtr = 8;
                for (i = 0; i < endPmtr; i++) {
                    Rend[i] = args[2].val[i];
                }

            /* sharp end (because endList=0) */
            } else if (args[2].val[0] == 0) {
                endPmtr = 0;

            /* sharp end (because endList did not contain enough values) */
            } else {
                endPmtr = 0;
                SPRINT1(1, "WARNING:: endList only has %d values", args[2].nval);
                SPRINT0(1, "          reverting to sharp end");
                (MODL->nwarn)++;
            }
        } else {

            /* rounded tip at end */
            if (args[2].nval == 2 && args[2].val[0] < 0) {
                endPmtr = 2;
                Rend[0] = 0;
                Rend[1] = args[2].val[1];

            /* tangency */
            } else if (args[2].nval == 3) {
                endPmtr = 4;
                Rend[0] = 1;
                Rend[1] = args[2].val[0];
                Rend[2] = args[2].val[1];
                Rend[3] = args[2].val[2];

            /* blend end */
            } else {
                endPmtr = 0;
            }
        }

        /* reorder Loops to eliminate twisting */
        status = reorderLoops(MODL, nsketch, esketch, NINT(args[3].val[0]));
        CHECK_STATUS(reorderLoops);

        /* create the Body */
        if (begPmtr == 0 && endPmtr == 0) {
            SPRINT1(2, "call EG_blend(nsketch=%d, NULL, NULL)", nsketch);
            if (outLevel >= 3) {
                for (ii = 0; ii < nsketch; ii++) {
                    SPRINT1(3, "before EG_blend: esketch[%d]", ii);
                    ocsmPrintEgo(esketch[ii]);
                }
            }
            if (oneFace == 0) {
                status = EG_blend(+nsketch, esketch, NULL,  NULL,  &ebody);
            } else {
                status = EG_blend(-nsketch, esketch, NULL,  NULL,  &ebody);
            }
            if (status < SUCCESS) {
                signalError(MODL, status,
                            "EG_blend returned an error");
                goto cleanup;
            }
        } else if (begPmtr == 0) {
            SPRINT1(2, "call EG_blend(nsketch=%d, NULL, Rend)", nsketch);
            SPRINT0x(2, "Rend= ");
            for (ii = 0; ii < endPmtr; ii++) {
                SPRINT1x(2, "%f ", Rend[ii]);
            }
            SPRINT0(2, " ");

            if (outLevel >= 3) {
                for (ii = 0; ii < nsketch; ii++) {
                    SPRINT1(3, "before EG_blend: esketch[%d]", ii);
                    ocsmPrintEgo(esketch[ii]);
                }
            }
            if(oneFace == 0) {
                status = EG_blend(+nsketch, esketch, NULL,  Rend, &ebody);
            } else {
                status = EG_blend(-nsketch, esketch, NULL,  Rend, &ebody);
            }
            if (status == EGADS_DEGEN) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "sketch with multiplicity-2 adjacent to rounded beg");
                goto cleanup;
            } else if (status < SUCCESS) {
                signalError(MODL, status,
                            "EG_blend returned an error");
                goto cleanup;
            }
        } else if (endPmtr == 0) {
            SPRINT1(2, "call EG_blend(nsketch=%d, Rbeg, NULL)", nsketch);
            SPRINT0x(2, "Rbeg= ");
            for (ii = 0; ii < begPmtr; ii++) {
                SPRINT1x(2, "%f ", Rbeg[ii]);
            }
            SPRINT0(2, " ");

            if (outLevel >= 3) {
                for (ii = 0; ii < nsketch; ii++) {
                    SPRINT1(3, "before EG_blend: esketch[%d]", ii);
                    ocsmPrintEgo(esketch[ii]);
                }
            }
            if (oneFace == 0) {
                status = EG_blend(+nsketch, esketch, Rbeg, NULL,  &ebody);
            } else {
                status = EG_blend(-nsketch, esketch, Rbeg, NULL,  &ebody);
            }
            if (status == EGADS_DEGEN) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "sketch with multiplicity-2 adjacent to rounded end");
                goto cleanup;
            } else if (status < SUCCESS) {
                signalError(MODL, status,
                            "EG_blend returned an error");
                goto cleanup;
            }
        } else {
            SPRINT1(2, "call EG_blend(nsketch=%d, Rbeg, Rend)", nsketch);
            SPRINT0x(2, "Rbeg= ");
            for (ii = 0; ii < begPmtr; ii++) {
                SPRINT1x(2, "%f ", Rbeg[ii]);
            }
            SPRINT0(2, " ");
            SPRINT0x(2, "Rend= ");
            for (ii = 0; ii < endPmtr; ii++) {
                SPRINT1x(2, "%f ", Rend[ii]);
            }
            SPRINT0(2, " ");

            if (outLevel >= 3) {
                for (ii = 0; ii < nsketch; ii++) {
                    SPRINT1(3, "before EG_blend: esketch[%d]", ii);
                    ocsmPrintEgo(esketch[ii]);
                }
            }
            if (oneFace == 0) {
                status = EG_blend(+nsketch, esketch, Rbeg, Rend, &ebody);
            } else{
                status = EG_blend(-nsketch, esketch, Rbeg, Rend, &ebody);
            }
            if (status == EGADS_DEGEN) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "sketch with multiplicity-2 adjacent to rounded beg or end");
                goto cleanup;
            } else if (status < SUCCESS) {
                signalError(MODL, status,
                            "EG_blend returned an error");
                goto cleanup;
            }
        }

        MODL->body[ibody].ebody = ebody;

        /* update the Body type if a SheetBody was produced */
        status = EG_getTopology(ebody, &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        if (oclass == BODY) {
            if (mtype == SHEETBODY || mtype == FACEBODY) {
                SPRINT0(1, "WARNING:: blend produced a SheetBody");
                (MODL->nwarn)++;
                MODL->body[ibody].botype = OCSM_SHEET_BODY;
            } else if (mtype != SOLIDBODY) {
                signalError(MODL, OCSM_INTERNAL_ERROR,
                            "Body produced is neither SheetBody or SolidBody");
                SET_STATUS(OCSM_INTERNAL_ERROR, blend);
            }
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "EGO produced is not a Body");
            SET_STATUS(OCSM_INTERNAL_ERROR, blend);
        }

        /* update the Body type if periodic and the first and last
           sections were both WireBodys */
        if (periodic == 1) {
            if (MODL->body[isketch[0        ]].botype == OCSM_WIRE_BODY &&
                MODL->body[isketch[nsketch-2]].botype == OCSM_WIRE_BODY   ) {
                status = EG_getTopology(ebody, &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (oclass == BODY || mtype == SOLIDBODY) {
                    status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                             data, 1, echilds, senses, &emodel);
                    CHECK_STATUS(EG_makeTopology);

                    status = EG_deleteObject(ebody);
                    CHECK_STATUS(EG_deleteBody);

                    ebody = emodel;

                    MODL->body[ibody].botype = OCSM_SHEET_BODY;
                    MODL->body[ibody].ebody  = ebody;
                }
            }
        }

        /* remember the Bodys used to create this BLEND */
        status = EG_attributeAdd(ebody, "__usedBodys__", ATTRINT, nsketch, isketch, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);

        /* update @-parameters (BLEND) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* loop through the Faces to keep track of strip number
           and minimum-v (which is used to determine the iford) */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);
        SPLINT_CHECK_FOR_NULL(efaces);

        MALLOC(kstrip, int,    nface+1);
        MALLOC(vmin,   double, nface+1);

        npart = 0;
        for (iface = 1; iface <= nface; iface++) {
            status = EG_attributeRet(efaces[iface-1], ".blendStrip",
                                     &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);
            kstrip[iface] = tempIlist[0];

            if (kstrip[iface] == 1) npart++;

            status = EG_getTopology(efaces[iface-1], &eref, &oclass, &mtype,
                                    uvlimits, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);
            vmin[iface] = uvlimits[2];

            /* rounded tips are new Faces (they do not map back to the input Xsec),
               but the tip Face preserve the attributes from the input Xsec Face.
               hence, _hist and __trace__ attributes must be removed from rounded tip Faces.
             */
            if (kstrip[iface] == -1 || kstrip[iface] == -2) {
                (void) EG_attributeDel(efaces[iface-1], "_hist");
                (void) EG_attributeDel(efaces[iface-1], "__trace__");
            }
        }

        FREE(kstrip);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, NULL);
        CHECK_STATUS(EG_getBodyTopos);

        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) nface--;
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) nface--;

        for (iface = 1; iface <= nface; iface++) {
            status = setFaceAttribute(MODL, ibody, iface, 0, iface+2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }
        if (MODL->body[isketch[        0]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
            nface++;
        }
        if (MODL->body[isketch[nsketch-1]].botype == OCSM_SHEET_BODY) {
            status = setFaceAttribute(MODL, ibody, nface+1, 0, 2, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        /* make sure all Faces have an Attribute */
        for (iface = 1; iface <= nface; iface++) {
            status = EG_attributeRet(efaces[iface-1], "_body", &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);
        }

        EG_free(efaces);

        /* finish the Body (BLEND) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* put a __C0blend__ attribute on any Edge that has a valence
           of 2, with both Faces having the same .blendStrip attribute.
           also increment count on associated Nodes */
        MALLOC(kstrip, int, MODL->body[ibody].nnode+1);

        for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
            kstrip[inode] = 0;
        }

        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
//$$$            status = EG_getInfo(MODL->body[ibody].edge[iedge].eedge,
//$$$                                &oclass, &mtype, &topref, &prev, &next);
//$$$            CHECK_STATUS(EG_getInfo);
//$$$            if (mtype == DEGENERATE) continue;
            if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) continue;

            ileft = MODL->body[ibody].edge[iedge].ileft;
            if (ileft > 0) {
                status = EG_attributeRet(MODL->body[ibody].face[ileft].eface, ".blendStrip",
                                         &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                ileft = tempIlist[0];
            } else {
                ileft = 0;
            }

            irite = MODL->body[ibody].edge[iedge].irite;
            if (irite > 0) {
                status = EG_attributeRet(MODL->body[ibody].face[irite].eface, ".blendStrip",
                                         &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                irite = tempIlist[0];
            } else {
                irite = 0;
            }

            if (ileft == irite) {
                status = EG_attributeAdd(MODL->body[ibody].edge[iedge].eedge, "__C0blend__",
                                         ATTRINT, 1, &ileft, NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);

                kstrip[MODL->body[ibody].edge[iedge].ibeg] ++;
                kstrip[MODL->body[ibody].edge[iedge].iend] ++;
            }
        }

        /* put a __C0blend__ attribute on any Node with a count of 2 */
        for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
            if (kstrip[inode] == 2) {
                status = EG_attributeAdd(MODL->body[ibody].node[inode].enode, "__C0blend__",
                                         ATTRINT, 1, &inode, NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);
            }
        }

        FREE(kstrip);

        /* indicate all nodes and edges originate from the blend body */
        for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
            MODL->body[ibody].node[inode].ibody = ibody;
        }

        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            MODL->body[ibody].edge[iedge].ibody = ibody;
        }

        FREE(vmin  );

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "sweep" */
    } else if (type == OCSM_SWEEP) {
        SPRINT1(1, "    executing [%4d] sweep:",
                ibrch);

        /* require finite differences */
        MODL->needFDs = 1;

        /* pop two Xsects from the stack */
        if ((*nstack) < 2) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "SWEEP expects two Bodys on the stack");
            goto cleanup;
        } else {
            ibodyr = stack[--(*nstack)];
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        if (MODL->body[ibodyl].botype  == OCSM_WIRE_BODY &&
            MODL->body[ibodyl].nonmani == 1) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "SWEEP cannot be applied to non-manifold WireBodys (%d)", ibodyl);
            goto cleanup;
        } else if (MODL->body[ibodyr].botype  == OCSM_WIRE_BODY &&
                   MODL->body[ibodyr].nonmani == 1) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "SWEEP cannot be applied to non-manifold WireBodys (%d)", ibodyr);
            goto cleanup;
        }

        /* check that ibodyl is a WireBody or SheetBody */
        if (MODL->body[ibodyl].botype != OCSM_SHEET_BODY &&
            MODL->body[ibodyl].botype != OCSM_WIRE_BODY    ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "SWEEP expects a SheetBody or WireBody on the stack");
            goto cleanup;
        }

        /* check that ibodyr is a Xsect */
        if (MODL->body[ibodyr].botype != OCSM_WIRE_BODY) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "SWEEP expetcs a WireBody on the stack");
            goto cleanup;
        }

        /* create the Body */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            status = newBody(MODL, ibrch, OCSM_SWEEP, ibodyl, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);
        } else {
            status = newBody(MODL, ibrch, OCSM_SWEEP, ibodyl, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);
        }

        ebodyl = MODL->body[ibodyl].ebody;
        ebodyr = MODL->body[ibodyr].ebody;

        /* if ebodyl is actually an EGADS SheetBody (with one Face),
           convert it now to a FaceBody */
        status = EG_getTopology(ebodyl, &eref, &oclass, &mtype, data,
                                &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        if (mtype == SHEETBODY) {
            newEbodyl = 1;

            status = EG_getBodyTopos(ebodyl, NULL, FACE, &nchild, &efaces);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(efaces);

            status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
                                     NULL, 1, efaces, NULL, &ebodyl);
            CHECK_STATUS(EG_makeTopology);

            EG_free(efaces);
        }

        /* arbitrarily set the mode to 0 */
        mode = 0;

        if (outLevel >= 3) {
            SPRINT0(3, "before EG_sweep: ebodyl");
            ocsmPrintEgo(ebodyl);
            SPRINT0(3, "before EG_sweep: ebodyr");
            ocsmPrintEgo(ebodyr);
        }
        status = EG_sweep(ebodyl, ebodyr, mode, &ebody);
        CHECK_STATUS(EG_sweep);

        /* verify that sweep produced the expected result */
        status = EG_getInfo(ebody, &oclass, &mtype, &topref, &prev, &next);
        CHECK_STATUS(EG_getInfo);

        if (oclass != BODY) {
            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                        "SWEEP did not produce a Body");

            stack[(*nstack)++] = ibodyr;
            stack[(*nstack)++] = ibodyl;

            (void) freeBody(MODL,ibody);
            MODL->nbody--;
            goto cleanup;
        } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY && mtype != SOLIDBODY) {
            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                        "SWEEP did not produce a SolidBody");

            stack[(*nstack)++] = ibodyr;
            stack[(*nstack)++] = ibodyl;

            (void) freeBody(MODL,ibody);
            MODL->nbody--;
            goto cleanup;
        } else if (MODL->body[ibodyl].botype != OCSM_SHEET_BODY && mtype != SHEETBODY) {
            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                        "SWEEP did not produce a SheetBody");

            stack[(*nstack)++] = ibodyr;
            stack[(*nstack)++] = ibodyl;

            (void) freeBody(MODL,ibody);
            MODL->nbody--;
            goto cleanup;
        }

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (SWEEP) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);
        SPLINT_CHECK_FOR_NULL(efaces);

        /* transfer Attributes from Xsect to beginning Face */
        if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {
            status = EG_attributeDup(ebodyl, efaces[0]);
            CHECK_STATUS(EG_attributeDup);
        }

        /* mark the new Faces with the current Branch */
        for (iface = 1; iface <= nface; iface++) {
            if        (iface == 1    ) {
                iford1 = 1;
            } else if (iface == nface) {
                iford1 = 2;
            } else {
                iford1 = iface + 2;
            }
            status = setFaceAttribute(MODL, ibody, iface, 0, iford1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);
        }

        EG_free(efaces);

        /* finish the Body (SWEEP) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);
    }

cleanup:
    if (newEbodyl == 1) {
        status = EG_deleteObject(ebodyl);
        CHECK_STATUS(EG_deleteObject);
    }

    FREE(isketch);
    FREE(jsketch);
    FREE(esketch);

    FREE(enodes2);
    FREE(eedges2);
    FREE(senses2);

    FREE(vmin  );
    FREE(kstrip);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildPrimitive - implement OCSM_PRIMITIVEs for ocsmBuild           *
 *                                                                      *
 ************************************************************************
 */

static int
buildPrimitive(modl_T *modl,            /* (in)  pointer to MODL */
               int    ibrch,            /* (in)  Branch index (1:nbrch) */
               varg_T args[],           /* (in)  array of arguments */
               int    *nstack,          /* (both) number of Bodys on stack */
               int    stack[],          /* (both) array  of Bodys on stack */
               int    npatn,            /* (in)   number of patterns */
               patn_T patn[])           /* (both) array  of patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        type, hasdots, iface, nface, ibody, jbody, kbody, jbrch, jstack, ninline;
    int        istor, jstor, ibodyl, ibodyr, nparent, i, attrType, attrLen, markFaces, numRemaining;
    int        *newIlist=NULL, nattr, iattr, irc;
    CINT       *tempIlist;
    double     toler, value, dot, data[18], tdata[4], xyz_out[3], bbox[6];
    CDOUBLE    *tempRlist;
    char       newname[MAX_EXPR_LEN];
    CCHAR      *tempClist, *aname;
    ego        esurface, eface, eshell;

    int         oclass, mtype, iford1, iarg, ival, nedge, iedge;
    int         udp_num, *udp_types, *udp_idef, udp_nmesh;
    int         valInt, ipmtr, jpmtr, ij, sense;
    int         oclass1, nchild, *senses, ifirst, icount, nbody_save;
    int         *ibodys=NULL;
    double      valDouble, vals[8], dx, dy, dz, alen;
    double      *udp_ddef;
    char        **udp_names, *udp_errStr, primtype[MAX_EXPR_LEN], temp[MAX_EXPR_LEN];
    char        dumpfile[MAX_EXPR_LEN];
    ego         ebody, *eedges, *efaces, topRef, prev, next, emodel, *ebodys=NULL, eref, *echilds;
    ego         *newTess=NULL, eoutput;
    ego         enode, eedge, eloop, ecurve, enodes[2];
    char        atPmtr[MAX_NAME_LEN], str[MAX_STRVAL_LEN];

    int         ifmap[4];
    double      sinx, cosx, siny, cosy, sinz, cosz, mat[12];
    ego         etemp, exform;

    ROUTINE(buildPrimitive);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "point xloc yloc zloc" */
    if (type == OCSM_POINT) {
        SPRINT4(1, "    executing [%4d] point:      %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;
            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_POINT, -1, -1,
                         args, hasdots, OCSM_NODE_BODY, &ibody);
        CHECK_STATUS(newBody);

        vals[0] = args[1].val[0];
        vals[1] = args[2].val[0];
        vals[2] = args[3].val[0];

        /* OCSM_NODE_BODY is actually a degenerate WireBody */
        status = EG_makeTopology(MODL->context, NULL, NODE, 0, vals, 0, NULL, NULL, &enode);
        CHECK_STATUS(EG_makeTopology);

        tdata[0] = 0;
        tdata[1] = 1;
        sense    = SFORWARD;
        status = EG_makeTopology(MODL->context, NULL, EDGE, DEGENERATE, tdata, 1, &enode, &sense, &eedge);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED, NULL, 1, &eedge, &sense, &eloop);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL, 1, &eloop, NULL, &ebody);
        CHECK_STATUS(EG_makeTopology);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (POINT) and finish Body */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        SPRINT1(1, "                          Body   %4d created", ibody);

    /* execute: "box xbase ybase zbase dx dy dz" */
    } else if (type == OCSM_BOX) {
        SPRINT7(1, "    executing [%4d] box:        %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0                                                 ) {
            hasdots = 1;
            SPRINT6(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0]);
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* if dx, dy, and dz are all non-zero, make a SolidBody */
        if (fabs(args[4].val[0]) > EPS06 &&
            fabs(args[5].val[0]) > EPS06 &&
            fabs(args[6].val[0]) > EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            if (args[4].val[0] > 0) {
                vals[0] = args[1].val[0];
                vals[3] = args[4].val[0];
            } else {
                vals[0] = args[1].val[0] + args[4].val[0];
                vals[3] =                - args[4].val[0];
            }

            if (args[5].val[0] > 0) {
                vals[1] = args[2].val[0];
                vals[4] = args[5].val[0];
            } else {
                vals[1] = args[2].val[0] + args[5].val[0];
                vals[4] =                - args[5].val[0];
            }

            if (args[6].val[0] > 0) {
                vals[2] = args[3].val[0];
                vals[5] = args[6].val[0];
            } else {
                vals[2] = args[3].val[0] + args[6].val[0];
                vals[5] =                - args[6].val[0];
            }

            status = EG_makeSolidBody(MODL->context, BOX, vals, &ebody);
            CHECK_STATUS(EG_makeSolidBody);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces with the current Branch */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (efaces != NULL) {
                iford1 = 0;
                for (iface = 1; iface <= nface; iface++) {
                    if        (faceContains(efaces[iface-1], vals[0],           vals[1]+vals[4]/2, vals[2]+vals[5]/2)) {
                        iford1 = 1;
                    } else if (faceContains(efaces[iface-1], vals[0]+vals[3],   vals[1]+vals[4]/2, vals[2]+vals[5]/2)) {
                        iford1 = 2;
                    } else if (faceContains(efaces[iface-1], vals[0]+vals[3]/2, vals[1],           vals[2]+vals[5]/2)) {
                        iford1 = 3;
                    } else if (faceContains(efaces[iface-1], vals[0]+vals[3]/2, vals[1]+vals[4],   vals[2]+vals[5]/2)) {
                        iford1 = 4;
                    } else if (faceContains(efaces[iface-1], vals[0]+vals[3]/2, vals[1]+vals[4]/2, vals[2]          )) {
                        iford1 = 5;
                    } else if (faceContains(efaces[iface-1], vals[0]+vals[3]/2, vals[1]+vals[4]/2, vals[2]+vals[5]  )) {
                        iford1 = 6;
                    }

                    status = setFaceAttribute(MODL, ibody, iface, 0, iford1, npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                }

                EG_free(efaces);
            }

        /* SheetBody in y-z plane */
        } else if (fabs(args[4].val[0]) <  EPS06 &&
                   fabs(args[5].val[0]) >= EPS06 &&
                   fabs(args[6].val[0]) >= EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            data[0] = args[1].val[0];  data[1] = 0;   data[2] = 0;
            data[3] = 0;               data[4] = 1;   data[5] = 0;
            data[6] = 0;               data[7] = 0;   data[8] = 1;
            status = EG_makeGeometry(MODL->context, SURFACE, PLANE,
                                     NULL, NULL, data, &esurface);
            CHECK_STATUS(EG_makeGeometry);

            data[0] = args[2].val[0];   data[1] = args[2].val[0] + args[5].val[0];
            data[2] = args[3].val[0];   data[3] = args[3].val[0] + args[6].val[0];
            status = EG_makeFace(esurface, SFORWARD, data, &eface);
            CHECK_STATUS(EG_makeFace);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                     NULL, 1, &eface,  NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: y-z plane) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* SheetBody in x-z plane */
        } else if (fabs(args[4].val[0]) >= EPS06 &&
                   fabs(args[5].val[0]) <  EPS06 &&
                   fabs(args[6].val[0]) >= EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            data[0] = 0;  data[1] = args[2].val[0];  data[2] = 0;
            data[3] = 0;  data[4] = 0;               data[5] = 1;
            data[6] = 1;  data[7] = 0;               data[8] = 0;
            status = EG_makeGeometry(MODL->context, SURFACE, PLANE,
                                     NULL, NULL, data, &esurface);
            CHECK_STATUS(EG_makeGeometry);

            data[0] = args[3].val[0];   data[1] = args[3].val[0] + args[6].val[0];
            data[2] = args[1].val[0];   data[3] = args[1].val[0] + args[4].val[0];
            status = EG_makeFace(esurface, SFORWARD, data, &eface);
            CHECK_STATUS(EG_makeFace);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                     NULL, 1, &eface,  NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: x-z plane) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* SheetBody in x-y plane */
        } else if (fabs(args[4].val[0]) >= EPS06 &&
                   fabs(args[5].val[0]) >= EPS06 &&
                   fabs(args[6].val[0]) <  EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_SHEET_BODY, &ibody);
            CHECK_STATUS(newBody);

            data[0] = 0;  data[1] = 0;   data[2] = args[3].val[0];
            data[3] = 1;  data[4] = 0;   data[5] = 0;
            data[6] = 0;  data[7] = 1;   data[8] = 0;
            status = EG_makeGeometry(MODL->context, SURFACE, PLANE,
                                     NULL, NULL, data, &esurface);
            CHECK_STATUS(EG_makeGeometry);

            data[0] = args[1].val[0];   data[1] = args[1].val[0] + args[4].val[0];
            data[2] = args[2].val[0];   data[3] = args[2].val[0] + args[5].val[0];
            status = EG_makeFace(esurface, SFORWARD, data, &eface);
            CHECK_STATUS(EG_makeFace);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                     NULL, 1, &eface,  NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: x-y plane) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* WireBody in x direction */
        } else if (fabs(args[4].val[0]) >= EPS06 &&
                   fabs(args[5].val[0]) <  EPS06 &&
                   fabs(args[6].val[0]) <  EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* create the curve */
            data[0] = args[1].val[0];
            data[1] = args[2].val[0];
            data[2] = args[3].val[0];
            data[3] = args[4].val[0];
            data[4] = 0;
            data[5] = 0;

            status = EG_makeGeometry(MODL->context, CURVE, LINE,
                                     NULL, NULL, data, &ecurve);
            CHECK_STATUS(EG_makeGeometry);

            /* make the two Nodes */
            status = EG_invEvaluate(ecurve, data, &(data[4]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[0]);
            CHECK_STATUS(EG_makeTopology);

            data[0] = args[1].val[0] + args[4].val[0];
            status = EG_invEvaluate(ecurve, data, &(data[5]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[1]);
            CHECK_STATUS(EG_makeTopology);

            /* make the Edge, Loop, and WireBody */
            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                     &(data[4]), 2, enodes, NULL, &eedge);
            CHECK_STATUS(EG_makeTopology);

            sense = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                     NULL, 1, &eedge, &sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status =EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                    NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: x line) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* WireBody in y direction */
        } else if (fabs(args[4].val[0]) <  EPS06 &&
                   fabs(args[5].val[0]) >= EPS06 &&
                   fabs(args[6].val[0]) <  EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* create the curve */
            data[0] = args[1].val[0];
            data[1] = args[2].val[0];
            data[2] = args[3].val[0];
            data[3] = 0;
            data[4] = args[5].val[0];
            data[5] = 0;

            status = EG_makeGeometry(MODL->context, CURVE, LINE,
                                     NULL, NULL, data, &ecurve);
            CHECK_STATUS(EG_makeGeometry);

            /* make the two Nodes */
            status = EG_invEvaluate(ecurve, data, &(data[4]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[0]);
            CHECK_STATUS(EG_makeTopology);

            data[1] = args[2].val[0] + args[5].val[0];
            status = EG_invEvaluate(ecurve, data, &(data[5]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[1]);
            CHECK_STATUS(EG_makeTopology);

            /* make the Edge, Loop, and WireBody */
            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                     &(data[4]), 2, enodes, NULL, &eedge);
            CHECK_STATUS(EG_makeTopology);

            sense = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                     NULL, 1, &eedge, &sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status =EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                    NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: y line) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* WireBody in z direction */
        } else if (fabs(args[4].val[0]) <  EPS06 &&
                   fabs(args[5].val[0]) <  EPS06 &&
                   fabs(args[6].val[0]) >= EPS06   ) {

            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_WIRE_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* create the curve */
            data[0] = args[1].val[0];
            data[1] = args[2].val[0];
            data[2] = args[3].val[0];
            data[3] = 0;
            data[4] = 0;
            data[5] = args[6].val[0];

            status = EG_makeGeometry(MODL->context, CURVE, LINE,
                                     NULL, NULL, data, &ecurve);
            CHECK_STATUS(EG_makeGeometry);

            /* make the two Nodes */
            status = EG_invEvaluate(ecurve, data, &(data[4]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[0]);
            CHECK_STATUS(EG_makeTopology);

            data[2] = args[3].val[0] + args[6].val[0];
            status = EG_invEvaluate(ecurve, data, &(data[5]), xyz_out);
            CHECK_STATUS(EG_invEvaluate);

            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                      data, 0, NULL, NULL, &enodes[1]);
            CHECK_STATUS(EG_makeTopology);

            /* make the Edge, Loop, and WireBody */
            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                     &(data[4]), 2, enodes, NULL, &eedge);
            CHECK_STATUS(EG_makeTopology);

            sense = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                     NULL, 1, &eedge, &sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status =EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                    NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (BOX: z line) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Face with the current Branch */
            status = setFaceAttribute(MODL, ibody, 1, 0, 1, npatn, patn);
            CHECK_STATUS(setFaceAttribute);

        /* NodeBody */
        } else {
            status = newBody(MODL, ibrch, OCSM_BOX, -1, -1,
                             args, hasdots, OCSM_NODE_BODY, &ibody);
            CHECK_STATUS(newBody);

            vals[0] = args[1].val[0];
            vals[1] = args[2].val[0];
            vals[2] = args[3].val[0];

            /* OCSM_NODE_BODY is actually a degenerate WireBody */
            status = EG_makeTopology(MODL->context, NULL, NODE, 0, vals, 0, NULL, NULL, &enode);
            CHECK_STATUS(EG_makeTopology);

            tdata[0] = 0;
            tdata[1] = 1;
            sense    = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, EDGE, DEGENERATE, tdata, 1, &enode, &sense, &eedge);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED, NULL, 1, &eedge, &sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (POINT) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);
        }

        /* finish the Body (BOX) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "sphere xcent ycent zcent radius" */
    } else if (type == OCSM_SPHERE) {
        SPRINT5(1, "    executing [%4d] sphere:     %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0) {
            hasdots = 1;

            SPRINT4(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0]);
        }

        /* check to be sure that the radius is positive */
        if        (args[4].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius=%f must be positive", args[4].val[0]);
            goto cleanup;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_SPHERE, -1, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        vals[0] = args[1].val[0];
        vals[1] = args[2].val[0];
        vals[2] = args[3].val[0];
        vals[3] = args[4].val[0];

        status = EG_makeSolidBody(MODL->context, SPHERE, vals, &ebody);
        CHECK_STATUS(EG_makeSolidBody);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (SPHERE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (efaces != NULL) {
            iford1 = 0;
            for (iface = 1; iface <= nface; iface++) {
                if        (faceContains(efaces[iface-1], args[1].val[0],
                                                         args[2].val[0]-args[4].val[0]/2,
                                                        args[3].val[0]          )) {
                    iford1 = 1;
                } else if (faceContains(efaces[iface-1], args[1].val[0],
                                                         args[2].val[0]+args[4].val[0]/2,
                                                         args[3].val[0]          )) {
                    iford1 = 2;
                }

                status = setFaceAttribute(MODL, ibody, iface, 0, iford1, npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }

            EG_free(efaces);
        }

        /* finish the Body (SPHERE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "cone xvrtx yvrtx zvrtx xbase ybase zbase radius" */
    } else if (type == OCSM_CONE) {
        SPRINT8(1, "    executing [%4d] cone:       %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0], args[7].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0 || args[7].dot[0] != 0                   ) {
            hasdots = 1;

            SPRINT7(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0], args[7].dot[0]);
        }

        dx = args[4].val[0] - args[1].val[0];
        dy = args[5].val[0] - args[2].val[0];
        dz = args[6].val[0] - args[3].val[0];

        alen = sqrt(dx*dx + dy*dy + dz*dz);

        /* check to be sure that vertex and base are not the same */
        if (alen < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "vertex and base must be different");
            goto cleanup;
        }

        /* check to be sure that the radius is positive */
        if (args[7].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius=%f must be positive", args[7].val[0]);
            goto cleanup;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_CONE, -1, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        /* find coordinates for cone aligned with closest axis */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            if (dx > 0) {
                vals[0] = 0;     vals[1] = 0;  vals[2] = 0;
                vals[3] = alen;  vals[4] = 0;  vals[5] = 0;

                siny = -dz / alen;
                cosy = +sqrt(1 - siny*siny);

                sinz = +dy / alen / cosy;
                cosz = +sqrt(1 - sinz*sinz);

                mat[ 0] = cosz*cosy;  mat[ 1] = -sinz;  mat[ 2] = cosz*siny;  mat[ 3] = args[1].val[0];
                mat[ 4] = sinz*cosy;  mat[ 5] =  cosz;  mat[ 6] = sinz*siny;  mat[ 7] = args[2].val[0];
                mat[ 8] =     -siny;  mat[ 9] =     0;  mat[10] =      cosy;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            } else {
                vals[0] = alen;  vals[1] = 0;  vals[2] = 0;
                vals[3] =    0;  vals[4] = 0;  vals[5] = 0;

                siny = +dz / alen;
                cosy = +sqrt(1 - siny*siny);

                sinz = -dy / alen / cosy;
                cosz = +sqrt(1 - sinz*sinz);

                mat[ 0] = cosz*cosy;  mat[ 1] = -sinz;  mat[ 2] = cosz*siny;  mat[ 3] = args[4].val[0];
                mat[ 4] = sinz*cosy;  mat[ 5] =  cosz;  mat[ 6] = sinz*siny;  mat[ 7] = args[5].val[0];
                mat[ 8] =     -siny;  mat[ 9] =     0;  mat[10] =      cosy;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            }
        } else if (fabs(dy) >= fabs(dz)) {
            if (dy > 0) {
                vals[0] = 0;  vals[1] = 0;    vals[2] = 0;
                vals[3] = 0;  vals[4] = alen; vals[5] = 0;

                sinz = -dx / alen;
                cosz = +sqrt(1 - sinz*sinz);

                sinx = +dz / alen / cosz;
                cosx = +sqrt(1 - sinx*sinx);

                mat[ 0] =      cosz;  mat[ 1] =     -sinz;  mat[ 2] =     0;  mat[ 3] = args[1].val[0];
                mat[ 4] = cosx*sinz;  mat[ 5] = cosx*cosz;  mat[ 6] = -sinx;  mat[ 7] = args[2].val[0];
                mat[ 8] = sinx*sinz;  mat[ 9] = sinx*cosz;  mat[10] =  cosx;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            } else {
                vals[0] = 0;  vals[1] = alen; vals[2] = 0;
                vals[3] = 0;  vals[4] =    0; vals[5] = 0;

                sinz = +dx / alen;
                cosz = +sqrt(1 - sinz*sinz);

                sinx = -dz / alen / cosz;
                cosx = +sqrt(1 - sinx*sinx);

                mat[ 0] =      cosz;  mat[ 1] =     -sinz;  mat[ 2] =     0;  mat[ 3] = args[4].val[0];
                mat[ 4] = cosx*sinz;  mat[ 5] = cosx*cosz;  mat[ 6] = -sinx;  mat[ 7] = args[5].val[0];
                mat[ 8] = sinx*sinz;  mat[ 9] = sinx*cosz;  mat[10] =  cosx;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            }
        } else {
            if (dz > 0) {
                vals[0] = 0;  vals[1] = 0;  vals[2] = 0;
                vals[3] = 0;  vals[4] = 0;  vals[5] = alen;

                sinx = -dy / alen;
                cosx = +sqrt(1 - sinx*sinx);

                siny = +dx / alen / cosx;
                cosy = +sqrt(1 - siny*siny);

                mat[ 0] =  cosy;  mat[ 1] = siny*sinx;  mat[ 2] = siny*cosx;  mat[ 3] = args[1].val[0];
                mat[ 4] =     0;  mat[ 5] =      cosx;  mat[ 6] =     -sinx;  mat[ 7] = args[2].val[0];
                mat[ 8] = -siny;  mat[ 9] = cosy*sinx;  mat[10] = cosy*cosx;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            } else {
                vals[0] = 0;  vals[1] = 0;  vals[2] = alen;
                vals[3] = 0;  vals[4] = 0;  vals[5] =    0;

                sinx = +dy / alen;
                cosx = +sqrt(1 - sinx*sinx);

                siny = -dx / alen / cosx;
                cosy = +sqrt(1 - siny*siny);

                mat[ 0] =  cosy;  mat[ 1] = siny*sinx;  mat[ 2] = siny*cosx;  mat[ 3] = args[4].val[0];
                mat[ 4] =     0;  mat[ 5] =      cosx;  mat[ 6] =     -sinx;  mat[ 7] = args[5].val[0];
                mat[ 8] = -siny;  mat[ 9] = cosy*sinx;  mat[10] = cosy*cosx;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;
            }
        }
        vals[6] = args[7].val[0];

        /* create the cone along the axis */
        status = EG_makeSolidBody(MODL->context, CONE, vals, &etemp);
        CHECK_STATUS(EG_makeSolidBody);
        SPLINT_CHECK_FOR_NULL(etemp);

        /* transform the cone into its final position */
        status = EG_makeTransform(MODL->context, mat, &exform);
        CHECK_STATUS(EG_makeTransform);
        SPLINT_CHECK_FOR_NULL(exform);

        status = EG_copyObject(etemp, exform, &ebody);
        CHECK_STATUS(EG_copyObject);
        SPLINT_CHECK_FOR_NULL(ebody);

        status = EG_deleteObject(etemp);
        CHECK_STATUS(EG_deleteObject);

        status = EG_deleteObject(exform);
        CHECK_STATUS(EG_deleteObject);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (CONE) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (efaces != NULL && nface < 4) {
            for (iface = 1; iface <= nface; iface++) {
                status = setFaceAttribute(MODL, ibody, iface, 0, ifmap[iface-1], npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }

            EG_free(efaces);
        }

        /* finish the Body (CONE) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "cylinder xbeg ybeg zbeg xend yend zend radius" */
    } else if (type == OCSM_CYLINDER) {
        SPRINT8(1, "    executing [%4d] cylinder:   %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0], args[7].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0 || args[7].dot[0] != 0                   ) {
            hasdots = 1;

            SPRINT7(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0], args[7].dot[0]);
        }

        dx = args[4].val[0] - args[1].val[0];
        dy = args[5].val[0] - args[2].val[0];
        dz = args[6].val[0] - args[3].val[0];

        alen = sqrt(dx*dx + dy*dy + dz*dz);

        /* check to be sure that vertex and base are not the same */
        if (alen < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "vertex and base must be different");
            goto cleanup;
        }

        /* check to be sure that the radius is positive */
        if (args[7].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "radius=%f must be positive", args[7].val[0]);
            goto cleanup;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_CYLINDER, -1, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        /* find coordinates for cylinder aligned with closest axis */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            if (dx > 0) {
                vals[0] = 0;     vals[1] = 0;  vals[2] = 0;
                vals[3] = alen;  vals[4] = 0;  vals[5] = 0;

                siny = -dz / alen;
                cosy = +sqrt(1 - siny*siny);

                sinz = +dy / alen / cosy;
                cosz = +sqrt(1 - sinz*sinz);

                mat[ 0] = cosz*cosy;  mat[ 1] = -sinz;  mat[ 2] = cosz*siny;  mat[ 3] = args[1].val[0];
                mat[ 4] = sinz*cosy;  mat[ 5] =  cosz;  mat[ 6] = sinz*siny;  mat[ 7] = args[2].val[0];
                mat[ 8] =     -siny;  mat[ 9] =     0;  mat[10] =      cosy;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;  ifmap[3] = 1;
            } else {
                vals[0] = 0;     vals[1] = 0;  vals[2] = 0;
                vals[3] = alen;  vals[4] = 0;  vals[5] = 0;

                siny = +dz / alen;
                cosy = +sqrt(1 - siny*siny);

                sinz = -dy / alen / cosy;
                cosz = +sqrt(1 - sinz*sinz);

                mat[ 0] = cosz*cosy;  mat[ 1] = -sinz;  mat[ 2] = cosz*siny;  mat[ 3] = args[4].val[0];
                mat[ 4] = sinz*cosy;  mat[ 5] =  cosz;  mat[ 6] = sinz*siny;  mat[ 7] = args[5].val[0];
                mat[ 8] =     -siny;  mat[ 9] =     0;  mat[10] =      cosy;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 1;  ifmap[3] = 2;
            }
        } else if (fabs(dy) >= fabs(dz)) {
            if (dy > 0) {
                vals[0] = 0;  vals[1] = 0;    vals[2] = 0;
                vals[3] = 0;  vals[4] = alen; vals[5] = 0;

                sinz = -dx / alen;
                cosz = +sqrt(1 - sinz*sinz);

                sinx = +dz / alen / cosz;
                cosx = +sqrt(1 - sinx*sinx);

                mat[ 0] =      cosz;  mat[ 1] =     -sinz;  mat[ 2] =     0;  mat[ 3] = args[1].val[0];
                mat[ 4] = cosx*sinz;  mat[ 5] = cosx*cosz;  mat[ 6] = -sinx;  mat[ 7] = args[2].val[0];
                mat[ 8] = sinx*sinz;  mat[ 9] = sinx*cosz;  mat[10] =  cosx;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;  ifmap[3] = 1;
            } else {
                vals[0] = 0;  vals[1] = 0;    vals[2] = 0;
                vals[3] = 0;  vals[4] = alen; vals[5] = 0;

                sinz = +dx / alen;
                cosz = +sqrt(1 - sinz*sinz);

                sinx = -dz / alen / cosz;
                cosx = +sqrt(1 - sinx*sinx);

                mat[ 0] =      cosz;  mat[ 1] =     -sinz;  mat[ 2] =     0;  mat[ 3] = args[4].val[0];
                mat[ 4] = cosx*sinz;  mat[ 5] = cosx*cosz;  mat[ 6] = -sinx;  mat[ 7] = args[5].val[0];
                mat[ 8] = sinx*sinz;  mat[ 9] = sinx*cosz;  mat[10] =  cosx;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 1;  ifmap[3] = 2;
            }
        } else {
            if (dz > 0) {
                vals[0] = 0;  vals[1] = 0;  vals[2] = 0;
                vals[3] = 0;  vals[4] = 0;  vals[5] = alen;

                sinx = -dy / alen;
                cosx = +sqrt(1 - sinx*sinx);

                siny = +dx / alen / cosx;
                cosy = +sqrt(1 - siny*siny);

                mat[ 0] =  cosy;  mat[ 1] = siny*sinx;  mat[ 2] = siny*cosx;  mat[ 3] = args[1].val[0];
                mat[ 4] =     0;  mat[ 5] =      cosx;  mat[ 6] =     -sinx;  mat[ 7] = args[2].val[0];
                mat[ 8] = -siny;  mat[ 9] = cosy*sinx;  mat[10] = cosy*cosx;  mat[11] = args[3].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 2;  ifmap[3] = 1;
            } else {
                vals[0] = 0;  vals[1] = 0;  vals[2] = 0;
                vals[3] = 0;  vals[4] = 0;  vals[5] = alen;

                sinx = +dy / alen;
                cosx = +sqrt(1 - sinx*sinx);

                siny = -dx / alen / cosx;
                cosy = +sqrt(1 - siny*siny);

                mat[ 0] =  cosy;  mat[ 1] = siny*sinx;  mat[ 2] = siny*cosx;  mat[ 3] = args[4].val[0];
                mat[ 4] =     0;  mat[ 5] =      cosx;  mat[ 6] =     -sinx;  mat[ 7] = args[5].val[0];
                mat[ 8] = -siny;  mat[ 9] = cosy*sinx;  mat[10] = cosy*cosx;  mat[11] = args[6].val[0];

                ifmap[0] = 3;  ifmap[1] = 4;  ifmap[2] = 1;  ifmap[3] = 2;
            }
        }
        vals[6] = args[7].val[0];

        /* create the cylinder along the axis */
        status = EG_makeSolidBody(MODL->context, CYLINDER, vals, &etemp);
        CHECK_STATUS(EG_makeSolidBody);
        SPLINT_CHECK_FOR_NULL(etemp);

        /* transform the cylinder into its final position */
        status = EG_makeTransform(MODL->context, mat, &exform);
        CHECK_STATUS(EG_makeTransform);
        SPLINT_CHECK_FOR_NULL(exform);

        status = EG_copyObject(etemp, exform, &ebody);
        CHECK_STATUS(EG_copyObject);
        SPLINT_CHECK_FOR_NULL(ebody);

        status = EG_deleteObject(etemp);
        CHECK_STATUS(EG_deleteObject);

        status = EG_deleteObject(exform);
        CHECK_STATUS(EG_deleteObject);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (CYLINDER) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (efaces != NULL) {
            for (iface = 1; iface <= nface; iface++) {
                status = setFaceAttribute(MODL, ibody, iface, 0, ifmap[iface-1], npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }

            EG_free(efaces);
        }

        /* finish the Body (CYLINDER) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "torus xcent ycent zcent dxaxis dyaxis dzaxis majorRad minorRad" */
    } else if (type == OCSM_TORUS) {
        SPRINT9(1, "    executing [%4d] torus:      %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0], args[7].val[0], args[8].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0 || args[7].dot[0] != 0 || args[8].dot[0] != 0   ) {
            hasdots = 1;

            SPRINT8(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0], args[7].dot[0], args[8].dot[0]);
        }

        /* require finite differences */
        MODL->needFDs = 1;

        /* check to be sure that the axis is not zero */
        if (fabs(args[4].val[0]) < EPS06 &&
            fabs(args[5].val[0]) < EPS06 &&
            fabs(args[6].val[0]) < EPS06   ) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "axis length must be non-zero");
            goto cleanup;
        }

        /* check to be sure that the radii are non-zero */
        if        (args[7].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "majorRad=%f cannot be zero or negative", args[7].val[0]);
            goto cleanup;
        } else if (args[8].val[0] < EPS06) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "minorRad=%f cannot be zero or negative", args[8].val[0]);
            goto cleanup;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_TORUS, -1, -1,
                         args, hasdots, OCSM_SOLID_BODY, &ibody);
        CHECK_STATUS(newBody);

        vals[0] = args[1].val[0];
        vals[1] = args[2].val[0];
        vals[2] = args[3].val[0];
        vals[3] = args[4].val[0];
        vals[4] = args[5].val[0];
        vals[5] = args[6].val[0];
        vals[6] = args[7].val[0];
        vals[7] = args[8].val[0];

        status = EG_makeSolidBody(MODL->context, TORUS, vals, &ebody);
        CHECK_STATUS(EG_makeSolidBody);

        MODL->body[ibody].ebody = ebody;

        /* update @-parameters (TORUS) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        /* mark the new Faces with the current Branch */
        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);

        if (efaces != NULL) {
            for (iface = 1; iface <= nface; iface++) {
                status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                CHECK_STATUS(setFaceAttribute);
            }

            EG_free(efaces);
        }

        /* finish the Body (TORUS) */
        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

    /* execute: "import $filename bodynumber=1" */
    } else if (type == OCSM_IMPORT) {
        SPRINT3(1, "    executing [%4d] import:     %s  %11.5f",
                ibrch, args[1].str, args[2].val[0]);

        /* require finite differences */
        MODL->needFDs = 1;

        /* recycle old Body if not dirty */
        nbody_save = MODL->nbody;
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                if (*nstack < MAX_STACK_SIZE) {
                    stack[(*nstack)++] = ibodyl;
                } else {
                    status = OCSM_TOO_MANY_BODYS_ON_STACK;
                    signalError(MODL, status,
                                "Too many Bodys on Stack");
                    goto cleanup;
                }
            }
            status = SUCCESS;
            goto cleanup;
        }

        /* load and execute the user-defined primitive */
        STRNCPY(primtype, "import", MAX_EXPR_LEN);

        status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
        if (status == EGADS_NOLOAD) {
            status = EGADS_SUCCESS;
        }
        CHECK_STATUS(udp_initialize);

        status = udp_clrArguments(primtype);
        CHECK_STATUS(udp_clrArguments);

        /* strip the dollarsign off the filename */
        STRNCPY(dumpfile, args[1].str, MAX_EXPR_LEN);

        status = udp_setArgument(primtype, "filename", dumpfile, (int)(STRLEN(dumpfile)+1), NULL);
        CHECK_STATUS(udp_setArgument);

        /* set the Body number (in the import) */
        status = udp_setArgument(primtype, "bodynumber", &(args[2].val[0]), 1, NULL);
        CHECK_STATUS(udp_setArgument);

        /* execute udpImport */
        status = udp_executePrim(primtype, MODL->context, &emodel, &udp_nmesh, &udp_errStr);
        if (status < 0) {
            if (udp_errStr != NULL) {
                signalError(MODL, status,
                            udp_errStr);
                EG_free(udp_errStr);
            }  else {
                signalError(MODL, status,
                            "unspecified error");
            }
            goto cleanup;
        }

        /* remember first Body created by this statement */
        ifirst = MODL->nbody + 1;

        /* check the type of return */
        status = EG_getTopology(emodel, &eref, &oclass1, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        /* if a MODEL was returned, set up @@ parameters for all MODEL attributes */
        if (oclass1 == MODEL) {
            status = EG_attributeNum(emodel, &nattr);
            CHECK_STATUS(EG_attributeNum);

            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(emodel, iattr, &aname, &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeGet);

                if (STRLEN(aname) >= MAX_NAME_LEN-2) {
                    SPRINT1(1, "WARNING:: \"@@%s\"s name (from Models attributes) will be truncated", aname);
                }

                snprintf(newname, MAX_NAME_LEN, "@@%s", aname);

                status = ocsmFindPmtr(MODL, newname, OCSM_LOCALVAR, attrLen, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                if (attrType == ATTRINT) {
                    for (i = 0; i < attrLen; i++) {
                        status = ocsmSetValuD(MODL, ipmtr, i+1, 1, (double)(tempIlist[i]));
                        CHECK_STATUS(ocsmSetValuD);
                    }
                } else if (attrType == ATTRREAL) {
                    for (i = 0; i < attrLen; i++) {
                        status = ocsmSetValuD(MODL, ipmtr, i+1, 1, tempRlist[i]);
                        CHECK_STATUS(ocsmSetValuD);
                    }
                } else if (attrType == ATTRSTRING) {
                    status = str2valNoSignal((char *)tempClist, MODL, &value, &dot, temp);
                    if (status != SUCCESS) {
                        SPRINT2(1, "WARNING:: skipping attribute \"%s\" that has value \"%s\" (which cannot be evaluated)", aname, tempClist);
                        (MODL->nwarn)++;

                        status = ocsmDelPmtr(MODL, ipmtr);
                        CHECK_STATUS(ocsmDelPmtr);
                    } else {
                        status = ocsmSetValu(MODL, ipmtr, 1, 1, (char *)tempClist);
                        CHECK_STATUS(ocsmSetValu);
                    }
                }
            }
        }

        /* either process BODY that was returned, or a copy of each of the Bodys in the MODEL */
        for (i = 0; i < nchild; i++) {
            if        (oclass1 == MODEL) {
                status = EG_copyObject(echilds[i], NULL, &ebody);
                CHECK_STATUS(EG_copyObject);
            } else if (oclass1 == BODY) {
                ebody  = emodel;
                nchild = 1;
            } else {
                signalError(MODL, OCSM_BODY_NOT_FOUND,
                            "expecting a Model or Body");
                goto cleanup;
            }

            SPLINT_CHECK_FOR_NULL(ebody);

            status = EG_getInfo(ebody, &oclass, &mtype, &topRef, &prev, &next);
            CHECK_STATUS(EG_getInfo);

            /* create the Body */
            if        (oclass == BODY && mtype == SOLIDBODY) {
                status = newBody(MODL, ibrch, OCSM_IMPORT, -1, -1,
                                 args, hasdots, OCSM_SOLID_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else if (oclass == BODY && mtype == FACEBODY) {
                status = newBody(MODL, ibrch, OCSM_IMPORT, -1, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else if (oclass == BODY && mtype == SHEETBODY) {
                status = newBody(MODL, ibrch, OCSM_IMPORT, -1, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else if (oclass == BODY && mtype == WIREBODY) {
                status = newBody(MODL, ibrch, OCSM_IMPORT, -1, -1,
                                 args, hasdots, OCSM_WIRE_BODY, &ibody);
                CHECK_STATUS(newBody);
            } else {
                signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                            "IMPORT did not create a SolidBody, SheetBody, or WireBody");
                goto cleanup;
            }

            /* if MODEL was returned, if Body has a __hasTess__ attribute, attach
               the tessellation object to the Body */
            status = EG_attributeRet(echilds[i], "__hasTess__", &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == EGADS_SUCCESS && attrType == ATTRINT && attrLen == 1) {
                status = EG_copyObject(echilds[tempIlist[0]], MODL->body[MODL->nbody].ebody, &(MODL->body[MODL->nbody].etess));
                CHECK_STATUS(EG_copyObject);
            }

            /* check the tolerance and issue warning if a problem */
            status = getBodyTolerance(ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            if (toler > EPS06) {
                SPRINT1(1, "WARNING:: toler = %12.4e for import", toler);
                (MODL->nwarn)++;
            }

            /* set @@-parameters for any outputs from the udp */
            for (ij = 0; ij < udp_num; ij++) {
                if        (udp_types[ij] == -ATTRINT) {
                    char message[257];
                    status = udp_getOutput(primtype, emodel, udp_names[ij], (void*)&valInt, message);
                    if (strlen(message) > 0) {
                        signalError(MODL, status, message);
                        goto cleanup;
                    }
                    CHECK_STATUS(udp_getOutput);

                    snprintf(atPmtr, MAX_NAME_LEN, "@@%s", udp_names[ij]);

                    status = ocsmFindPmtr(MODL, atPmtr, OCSM_LOCALVAR, 1, 1, &ipmtr);
                    CHECK_STATUS(ocsmFindPmtr);

                    valDouble = valInt;
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, valDouble);
                    CHECK_STATUS(ocsmSetValuD);

                    snprintf(atPmtr, MAX_NAME_LEN, "__@@%s__", udp_names[ij]);

                    status = EG_attributeAdd(ebody, atPmtr, ATTRINT,
                                             1, &valInt, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                } else if (udp_types[ij] == -ATTRREAL) {
                    char message[257];
                    status = udp_getOutput(primtype, emodel, udp_names[ij], (void*)&valDouble, message);
                    if (strlen(message) > 0) {
                        signalError(MODL, status, message);
                        goto cleanup;
                    }
                    CHECK_STATUS(udp_getOutput);

                    snprintf(atPmtr, MAX_NAME_LEN, "@@%s", udp_names[ij]);

                    status = ocsmFindPmtr(MODL, atPmtr, OCSM_LOCALVAR, 1, 1, &ipmtr);
                    CHECK_STATUS(ocsmFindPmtr);

                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, valDouble);
                    CHECK_STATUS(ocsmSetValuD);

                    snprintf(atPmtr, MAX_NAME_LEN, "__@@%s__", udp_names[ij]);

                    status = EG_attributeAdd(ebody, atPmtr, ATTRREAL,
                                             1, NULL, &valDouble, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }
            }

            MODL->body[ibody].ebody = ebody;

            /* keep track of number of Bodys remaining from this command */
            numRemaining = nchild - 1 - i;
            if (numRemaining > 0) {
                status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                         1, &numRemaining, NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);
            }

            /* update @-parameters (IMPORT) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces with the current Branch */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (efaces != NULL) {
                if (nface > 0) {
                    for (iface = 1; iface <= nface; iface++) {
                        (void) EG_setOutLevel(MODL->context, 0);
                        status = EG_attributeDel(efaces[iface-1], "_body");
                        (void) EG_setOutLevel(MODL->context, outLevel);
                        if (status != EGADS_NOTFOUND) {
                            CHECK_STATUS(EG_attributeDel);
                        }

                        (void) EG_setOutLevel(MODL->context, 0);
                        status = EG_attributeDel(efaces[iface-1], "_brch");
                        (void) EG_setOutLevel(MODL->context, outLevel);
                        if (status != EGADS_NOTFOUND) {
                            CHECK_STATUS(EG_attributeDel);
                        }

                        status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                        CHECK_STATUS(setFaceAttribute);
                    }
                } else {
                    status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, &eedges);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (eedges != NULL) {
                        for (iedge = 1; iedge <= nedge; iedge++) {
                            (void) EG_setOutLevel(MODL->context, 0);
                            status = EG_attributeDel(eedges[iedge-1], "_body");
                            (void) EG_setOutLevel(MODL->context, outLevel);
                            if (status != EGADS_NOTFOUND) {
                                CHECK_STATUS(EG_attributeDel);
                            }

                            (void) EG_setOutLevel(MODL->context, 0);
                            status = EG_attributeDel(eedges[iedge-1], "_brch");
                            (void) EG_setOutLevel(MODL->context, outLevel);
                            if (status != EGADS_NOTFOUND) {
                                CHECK_STATUS(EG_attributeDel);
                        }
                        }

                        EG_free(eedges);
                    }
                }

                EG_free(efaces);
            }

            /* finish the Body (IMPORT) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body back onto the stack */
            if (*nstack < MAX_STACK_SIZE) {
                stack[(*nstack)++] = ibody;
            } else {
                status = OCSM_TOO_MANY_BODYS_ON_STACK;
                signalError(MODL, status,
                            "Too many Bodys on Stack");
                goto cleanup;
            }

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);
        }

        /* put all Bodys just created into same group */
        for (ibody = ifirst; ibody < MODL->nbody; ibody++) {
            MODL->body[ibody].igroup = MODL->body[MODL->nbody].igroup;
        }

    /* execute: "udprim $primtype $argName1 argValue1 $argName2 argValue2 $argName3 argValue3 $argName4 argValue4" */
    } else if (type == OCSM_UDPRIM) {

        /* primtype starts with a letter, so use a compiled UDPRIM named 'primtype.so' */
        if ((args[1].str[0] >= 'a' && args[1].str[0] <= 'z') ||
            (args[1].str[0] >= 'A' && args[1].str[0] <= 'Z')   ) {
            SPRINT2x(1, "    executing [%4d] udprim:     %s",
                    ibrch, args[1].str);

            hasdots = 0;
            for (iarg = 3; iarg <= MODL->brch[ibrch].narg; iarg+=2) {
                if (args[iarg].nval == 0) {
                    SPRINT2x(1, " %s %s",
                             args[iarg-1].str, args[iarg].str);
                } else {
                    SPRINT2x(1, " %s %11.5f",
                             args[iarg-1].str, args[iarg].val[0]);
                    for (ival = 0; ival < args[iarg].nval; ival++) {
                        if (args[iarg].dot[ival] != 0) hasdots = 1;
                    }
                }
            }
            SPRINT0(1, " (compiled code)");

            /* go back to first associated udparg statement whose primtype matches the
               UDPRIM's primtype */
            jbody = MODL->nbody;
            while (jbody > 0 && MODL->body[jbody].brtype == OCSM_UDPARG &&
                   strcmp(MODL->body[jbody].arg[1].str, args[1].str) == 0 ) {

                if (MODL->body[jbody].hasdots != 0) hasdots = MODL->body[jbody].hasdots;

                jbody--;
            }
            jbody++;

            /* initialize the user-defined primitive */
            STRNCPY(primtype, args[1].str, MAX_EXPR_LEN);

            status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
            if (status == EGADS_NOLOAD) {
                status = EGADS_SUCCESS;
            }
            if (status < SUCCESS) {
                signalError(MODL, OCSM_UDP_ERROR1,
                            "UDPRIM(%s) could not be found", primtype);
                goto cleanup;
            }

            status = udp_clrArguments(primtype);
            CHECK_STATUS(udp_clrArguments);

            /* determine links for the new Body if the UDPRIM has any parents */
            nparent = udp_numBodys(primtype);

            icount = 0;

            if (nparent == 1) {
                if ((*nstack) < 1) {
                    signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                                "UDPRIM(%s) expects a Body on the stack", primtype);
                    goto cleanup;
                } else {
                    MALLOC(newIlist, int, abs(nparent));
                    newIlist[icount++] = stack[--(*nstack)];
                }
            } else if (nparent == 2) {
                if ((*nstack) < 2) {
                    signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                                "UDPRIM(%s) expects two Bodys on the stack", primtype);
                    goto cleanup;
                } else {
                    MALLOC(newIlist, int, abs(nparent));
                    newIlist[icount++] = stack[--(*nstack)];
                    newIlist[icount++] = stack[--(*nstack)];
                }
            } else if (nparent < 0) {           // up to -nparent Bodys back to mark
                MALLOC(newIlist, int, abs(nparent));
                for (jstack = *nstack-1; jstack >= 0; jstack--) {
                    if (stack[jstack] == 0) break;
                    newIlist[icount++] = stack[--(*nstack)];
                }

                if (icount > -nparent) {
                    signalError(MODL, OCSM_TOO_MANY_BODYS_ON_STACK,
                                "UDPRIM(%s) requires 0 to %d Bodys before mark", primtype, -nparent);
                    goto cleanup;
                } else {
                    nparent = icount;
                }
            } else if (nparent != 0) {
                signalError(MODL, OCSM_INTERNAL_ERROR,
                            "nparent=%d\n", nparent);
                SET_STATUS(OCSM_INTERNAL_ERROR, udprim);
            }

            if (nparent == 0) {
                ibodyl = -1;
                ibodyr = -1;
            } else if (nparent == 1) {
                SPLINT_CHECK_FOR_NULL(newIlist);

                ibodyl = newIlist[0];
                ibodyr = -1;
            } else {
                SPLINT_CHECK_FOR_NULL(newIlist);

                ibodyl = newIlist[0];
                ibodyr = newIlist[icount-1];
            }

            /* recycle old Body if not dirty */
            nbody_save = MODL->nbody;
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                /* remove Mark from stack (if used because UDPRIM gets all Bodys back to Mark) */
                if (udp_numBodys(primtype) < 0 && *nstack > 0 && stack[*nstack-1] == 0) {
                    (*nstack)--;
                }

                for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                    if (*nstack < MAX_STACK_SIZE) {
                        stack[(*nstack)++] = ibodyl;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }

                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body (temporarily so that arguments can be processed) */
            status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                             args, hasdots, OCSM_SOLID_BODY, &ibody);
            CHECK_STATUS(newBody);

            /* go back to first associated udparg statement whose primtype matches the
               UDPRIM's primtype */
            jbody = MODL->nbody - 1;
            while (jbody > 0 && MODL->body[jbody].brtype == OCSM_UDPARG &&
                   strcmp(MODL->body[jbody].arg[1].str, args[1].str) == 0 ) {

                jbody--;
            }
            jbody++;

            while (jbody <= MODL->nbody) {
                for (iarg = 3; iarg < 10; iarg+=2) {
                    if (MODL->body[jbody].arg[iarg].nval < 0) break;

                    /* set the argument */
                    if (MODL->body[jbody].arg[iarg].nval == 0) {
                        char message[257];
                        if (strncmp(MODL->body[jbody].arg[iarg].str, "<<inline/", 9) != 0) {
                            status = udp_setArgument(MODL->body[jbody].arg[1].str,
                                                     MODL->body[jbody].arg[iarg-1].str,
                                                     MODL->body[jbody].arg[iarg  ].str,
                                              STRLEN(MODL->body[jbody].arg[iarg  ].str), message);
                        } else {
                            ninline = strtol(MODL->body[jbody].arg[iarg].str+9, NULL, 10);
                            status = udp_setArgument(MODL->body[jbody].arg[1].str,
                                                     MODL->body[jbody].arg[iarg-1].str,
                                                     &(MODL->sinline[ninline]),
                                              STRLEN(&(MODL->sinline[ninline])), message);
                        }
                        if (strlen(message) > 0) {
                            signalError(MODL, status, message);
                            goto cleanup;
                        } else if (status != EGADS_SUCCESS) {
                            signalError(MODL, status,
                                        "bad argument (%s) to %s", MODL->body[jbody].arg[iarg-1].str,
                                                                   MODL->body[jbody].arg[     1].str);
                            goto cleanup;
                        }

                    } else {
                        char message[257];
                        status = udp_setArgument(MODL->body[jbody].arg[1].str,
                                                 MODL->body[jbody].arg[iarg-1].str,
                                                 MODL->body[jbody].arg[iarg  ].val,
                                                 MODL->body[jbody].arg[iarg  ].nval, message);
                        if (strlen(message) > 0) {
                            signalError(MODL, status, message);
                            goto cleanup;
                        } else if (status != EGADS_SUCCESS) {
                            signalError(MODL, status,
                                        "bad argument (%s) to %s", MODL->body[jbody].arg[iarg-1].str,
                                                                   MODL->body[jbody].arg[     1].str);
                            goto cleanup;
                        }
                    }
                }

                jbody++;
            }

            /* remove temporary Body */
            status = freeBody(MODL, ibody);
            CHECK_STATUS(freeBody);

            (MODL->nbody)--;
            (MODL->ngroup)--;

            /* if the primitive needs inputs, make a Model of the Bodys and their
               Tessellation objects because a UDF may need the tessellation */
            MALLOC(ebodys,  ego, nparent);
            MALLOC(ibodys,  int, nparent);
            MALLOC(newTess, ego, nparent);

            for (i = 0; i < nparent; i++) {
                newTess[i] = NULL;
            }

            if  (nparent == 0) {
                emodel = MODL->context;
            } else {
                SPLINT_CHECK_FOR_NULL(newIlist);

                for (i = 0; i < nparent; i++) {
                    ibodys[i] = newIlist[nparent-1-i];
                    status = EG_copyObject(MODL->body[ibodys[i]].ebody, NULL, &(ebodys[i]));
                    CHECK_STATUS(EG_copyObject);

                    if (MODL->body[ibodyl].etess != NULL) {
                        status = EG_mapTessBody(MODL->body[ibodys[i]].etess, ebodys[i], &newTess[i]);
                        CHECK_STATUS(EG_mapTessBody);
                    }

                    MODL->body[ibodys[i]].ichld = MODL->nbody + 1;
                }

                /* remove Mark from stack (if used because UDPRIM gets all Bodys back to Mark) */
                if (udp_numBodys(primtype) < 0 && *nstack > 0 && stack[*nstack-1] == 0) {
                    (*nstack)--;
                }

                status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                         NULL, nparent, ebodys, NULL, &emodel);
                CHECK_STATUS(EG_makeTopology);

                status = EG_attributeAdd(emodel, "__bodyList__", ATTRINT, nparent,
                                         ibodys, NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);
            }

            FREE(newIlist);

            /* execute the primitive */
            status = udp_executePrim(primtype, emodel, &eoutput, &udp_nmesh, &udp_errStr);
            if (status < 0) {
                if (udp_errStr != NULL) {
                    signalError(MODL, status,
                                udp_errStr);
                    EG_free(udp_errStr);
                }  else {
                    signalError(MODL, status,
                                "unspecified error");
                }
                goto cleanup;
            }

            /* remember first Body created by this statement */
            ifirst = MODL->nbody + 1;

            /* check the type of return */
            status = EG_getTopology(eoutput, &eref, &oclass1, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            /* either process BODY that was returned, or a copy of each of the Bodys in the MODEL */
            for (i = 0; i < nchild; i++) {
                if        (oclass1 == MODEL) {
                    status = EG_copyObject(echilds[i], NULL, &ebody);
                    CHECK_STATUS(EG_copyObject);
                } else if (oclass1 == BODY) {
                    ebody  = eoutput;    /* cannot make copy since then
                                            the UDP could not match the ebody
                                            when computing sensitivities */
                    nchild = 1;
                } else {
                    signalError(MODL, OCSM_BODY_NOT_FOUND,
                                "expecting a Model or Body");
                    goto cleanup;
                }

                SPLINT_CHECK_FOR_NULL(ebody);

                status = EG_getInfo(ebody, &oclass, &mtype, &topRef, &prev, &next);
                CHECK_STATUS(EG_getInfo);

                /* create the Body */
                if        (oclass == BODY && mtype == SOLIDBODY) {
                    status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                     args, hasdots, OCSM_SOLID_BODY, &ibody);
                    CHECK_STATUS(newBody);
                } else if (oclass == BODY && mtype == FACEBODY) {
                    status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                     args, hasdots, OCSM_SHEET_BODY, &ibody);
                    CHECK_STATUS(newBody);
                } else if (oclass == BODY && mtype == SHEETBODY) {
                    status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                     args, hasdots, OCSM_SHEET_BODY, &ibody);
                    CHECK_STATUS(newBody);
                } else if (oclass == BODY && mtype == WIREBODY) {
                    status = EG_getBoundingBox(ebody, bbox);
                    CHECK_STATUS(EG_getBoundingBox);
                    if (fabs(bbox[3]-bbox[0]) > EPS06 ||
                        fabs(bbox[4]-bbox[1]) > EPS06 ||
                        fabs(bbox[5]-bbox[2]) > EPS06   ) {
                        status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                         args, hasdots, OCSM_WIRE_BODY, &ibody);
                        CHECK_STATUS(newBody);
                    } else {
                        status = newBody(MODL, ibrch, OCSM_UDPRIM, ibodyl, ibodyr,
                                         args, hasdots, OCSM_NODE_BODY, &ibody);
                        CHECK_STATUS(newBody);
                    }
                } else {
                    signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                "UDPRIM did not create a SolidBody, SheetBody, or WireBody");
                    goto cleanup;
                }

                /* if MODEL was returned, if Body has a __hasTess__ attribute, attach
                   the tessellation object to the Body */
                status = EG_attributeRet(echilds[i], "__hasTess__", &attrType, &attrLen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_SUCCESS && attrType == ATTRINT && attrLen == 1) {
                    status = EG_copyObject(echilds[tempIlist[0]], MODL->body[MODL->nbody].ebody, &(MODL->body[MODL->nbody].etess));
                    CHECK_STATUS(EG_copyObject);
                }

                /* check the tolerance and issue warning if a problem */
                status = getBodyTolerance(ebody, &toler);
                CHECK_STATUS(getBodyTolerance);

                if (toler > EPS06) {
                    SPRINT1(1, "WARNING:: toler = %12.4e for UDPRIM", toler);
                    (MODL->nwarn)++;
                }

                /* set @@-parameters for any outputs from the udp */
                for (ij = 0; ij < udp_num; ij++) {
                    if        (udp_types[ij] == -ATTRINT) {
                        char message[257];
                        status = udp_getOutput(primtype, eoutput, udp_names[ij], (void*)&valInt, message);
                        if (strlen(message) > 0) {
                            signalError(MODL, status, message);
                            goto cleanup;
                        }
                        CHECK_STATUS(udp_getOutput);

                        snprintf(atPmtr, MAX_NAME_LEN, "@@%s", udp_names[ij]);

                        status = ocsmFindPmtr(MODL, atPmtr, OCSM_LOCALVAR, 1, 1, &ipmtr);
                        CHECK_STATUS(ocsmFindPmtr);

                        valDouble = valInt;
                        status = ocsmSetValuD(MODL, ipmtr, 1, 1, valDouble);
                        CHECK_STATUS(ocsmSetValuD);

                        snprintf(atPmtr, MAX_NAME_LEN, "__@@%s__", udp_names[ij]);

                        status = EG_attributeAdd(ebody, atPmtr, ATTRINT,
                                                 1, &valInt, NULL, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                    /* store @@-parametr in body_T structure */
                    } else if (udp_types[ij] == -ATTRREAL) {
                        char message[257];
                        status = udp_getOutput(primtype, eoutput, udp_names[ij], (void*)&valDouble, message);
                        if (strlen(message) > 0) {
                            signalError(MODL, status, message);
                            goto cleanup;
                        }
                        CHECK_STATUS(udp_getOutput);

                        snprintf(atPmtr, MAX_NAME_LEN, "@@%s", udp_names[ij]);

                        status = ocsmFindPmtr(MODL, atPmtr, OCSM_LOCALVAR, 1, 1, &ipmtr);
                        CHECK_STATUS(ocsmFindPmtr);

                        status = ocsmSetValuD(MODL, ipmtr, 1, 1, valDouble);
                        CHECK_STATUS(ocsmSetValuD);

                        snprintf(atPmtr, MAX_NAME_LEN, "__@@%s__", udp_names[ij]);

                        status = EG_attributeAdd(ebody, atPmtr, ATTRREAL,
                                                 1, NULL, &valDouble, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        /* store @@-parameter in body_T structure */
                    }
                }

                MODL->body[ibody].ebody = ebody;

                /* keep track of number of Bodys remaining from this command */
                numRemaining = nchild - 1 - i;
                if (numRemaining > 0) {
                    status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                             1, &numRemaining, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }

                /* update @-parameters (UDPRIM udp/udf) */
                status = setupAtPmtrs(MODL, 0);
                CHECK_STATUS(setupAtPmtrs);

                /* mark the new Faces with the current Branch */
                status = EG_attributeRet(ebody, "__markFaces__", &attrType, &attrLen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == EGADS_SUCCESS) {
                    markFaces = 1;
                    status = EG_attributeDel(ebody, "__markFaces__");
                    CHECK_STATUS(EG_attributeDel);
                } else {
                    markFaces = 0;
                }

                if (nparent == 0 || markFaces == 1) {
                    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (efaces != NULL) {
                        for (iface = 1; iface <= nface; iface++) {
                            (void) EG_setOutLevel(MODL->context, 0);
                            status = EG_attributeDel(efaces[iface-1], "_body");
                            (void) EG_setOutLevel(MODL->context, outLevel);
                            if (status != EGADS_NOTFOUND) {
                                CHECK_STATUS(EG_attributeDel);
                            }

                            (void) EG_setOutLevel(MODL->context, 0);
                            status = EG_attributeDel(efaces[iface-1], "_brch");
                            (void) EG_setOutLevel(MODL->context, outLevel);
                            if (status != EGADS_NOTFOUND) {
                                CHECK_STATUS(EG_attributeDel);
                            }

                            status = setFaceAttribute(MODL, ibody, iface, 0, iface, npatn, patn);
                            CHECK_STATUS(setFaceAttribute);
                        }

                        EG_free(efaces);
                    }

                /* special case when a UDP/UDF returns a Body whose Faces are marked
                   with _ibrch[0] == -1 */
                } else if (markFaces == 0) {
                    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                    CHECK_STATUS(EG_getBodyTopos);

                    if (efaces != NULL) {
                        for (iface = 1; iface <= nface; iface++) {
                            status = EG_attributeRet(efaces[iface-1], "_brch", &attrType, &attrLen,
                                                     &tempIlist, &tempRlist, &tempClist);
                            if (status == EGADS_SUCCESS && attrType == ATTRINT && tempIlist[0] == -1) {
                                MALLOC(newIlist, int, attrLen);

                                newIlist[0] = ibrch;
                                for (i = 1; i < attrLen; i++) {
                                    newIlist[i] = tempIlist[i];
                                }

                                status = EG_attributeAdd(efaces[iface-1], "_brch", attrType, attrLen,
                                                         newIlist, NULL, NULL);
                                CHECK_STATUS(EG_attributeAdd);

                                FREE(newIlist);
                            }
                        }

                        EG_free(efaces);
                    }
                }

                /* finish the Body (UDPRIM udp/udf) */
                status = finishBody(MODL, ibody);
                if (MODL->sigCode != SUCCESS) goto cleanup;
                CHECK_STATUS(finishBody);

                /* push the Body back onto the stack */
                if (*nstack < MAX_STACK_SIZE) {
                    stack[(*nstack)++] = ibody;
                } else {
                    status = OCSM_TOO_MANY_BODYS_ON_STACK;
                    signalError(MODL, status,
                                "Too many Bodys on Stack");
                    goto cleanup;
                }

                status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                CHECK_STATUS(getBodyTolerance);

                SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                        ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);
            }

            /* put all Bodys just created into same group as the last Body */
            for (ibody = ifirst; ibody < MODL->nbody; ibody++) {
                MODL->body[ibody].igroup = MODL->body[MODL->nbody].igroup;
            }

            /* delete the emodel and any of its tessellations if made just for passing into UDP */
            for (i = 0; i < nparent; i++) {
                if (newTess[i] != NULL) {
                    status = EG_deleteObject(newTess[i]);
                    CHECK_STATUS(EG_deleteObject);
                }
            }

            if (nparent != 0) {
                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);
            }

        /* if primtype begins with /  $/ or $$/, then we have user-defined code */
        } else if (strncmp(args[1].str, "/",   1) == 0 ||
                   strncmp(args[1].str, "$/",  2) == 0 ||
                   strncmp(args[1].str, "$$/", 3) == 0   ) {
            SPRINT2x(1, "    executing [%4d] udprim:     %s",
                    ibrch, args[1].str);

            for (iarg = 3; iarg <= MODL->brch[ibrch].narg; iarg+=2) {
                if (args[iarg].nval == 0) {
                    SPRINT2x(1, " %s %s",
                             args[iarg-1].str, args[iarg].str);
                } else {
                    SPRINT2x(1, " %s %11.5f",
                             args[iarg-1].str, args[iarg].val[0]);
                }
            }
            SPRINT0(1, " (scripted code)");

            /* increment the level and create a new scope */
            (MODL->level)++;
            MODL->scope[MODL->level] = MODL->scope[MODL->level-1] + 1;

            SPRINT0(2, "Parameters before processing UDPARG/UDPRIM statements:");
            if (outLevel >= 2) {
                status = printPmtrs(MODL, stdout);
                CHECK_STATUS(printPmtrs);
            }

            /* note: we need to pre-process the INTERFACE statements in the
               UDC to set up storage and the default value before we actually
               pass in the values from the UDPARG and UDPRIM statements.  Later
               when we see the INTERFACE statements, nothing will actually
               get done */
            jbrch = ibrch + 1;
            while (MODL->brch[jbrch].type == OCSM_INTERFACE) {

                if (strcmp(MODL->brch[jbrch].arg2, "$all") == 0 ||
                    strcmp(MODL->brch[jbrch].arg2, "$ALL") == 0   ) {

                    /* use the same scope as the parent */
                    MODL->scope[MODL->level] = MODL->scope[MODL->level-1];
                    break;

                } else if (strcmp(MODL->brch[jbrch].arg2, "$in" ) == 0 ||
                           strcmp(MODL->brch[jbrch].arg2, "$IN" ) == 0 ||
                           strcmp(MODL->brch[jbrch].arg2, "$out") == 0 ||
                           strcmp(MODL->brch[jbrch].arg2, "$OUT") == 0   ) {

                    /* get default value */
                    status = str2val(MODL->brch[jbrch].arg3, MODL, &value, &dot, str);
                    CHECK_STATUS(str2val);

                    /* set default value (single value or string) */
                    if (STRLEN(str) == 0) {
                        status = ocsmNewPmtr(MODL, &(MODL->brch[jbrch].arg1[1]), OCSM_LOCALVAR, 1, 1);
                        CHECK_STATUS(ocsmNewPmtr);

                        status = ocsmSetValuD(MODL, MODL->npmtr, 1, 1, value);
                        CHECK_STATUS(ocsmSetValu);

                        status = ocsmSetVelD(MODL, MODL->npmtr, 1, 1, dot);
                        CHECK_STATUS(ocsmSetVelD);
                    } else {
                        status = ocsmNewPmtr(MODL, &(MODL->brch[jbrch].arg1[1]), OCSM_LOCALVAR, 1, 1);
                        CHECK_STATUS(ocsmNewPmtr);

                        status = ocsmSetValu(MODL, MODL->npmtr, 1, 1, MODL->brch[jbrch].arg3);
                        CHECK_STATUS(ocsmSetValu);
                    }
                } else if (strcmp(MODL->brch[jbrch].arg2, "$dim") == 0 ||
                           strcmp(MODL->brch[jbrch].arg2, "$DIM") == 0   ) {
                    status = str2val(MODL->brch[jbrch].arg3, MODL, &value, &dot, str);
                    CHECK_STATUS(str2val);
                    if (STRLEN(str) > 0) {
                        status = OCSM_WRONG_PMTR_TYPE;
                        goto cleanup;
                    }

                    status = ocsmFindPmtr(MODL, &(MODL->brch[jbrch].arg1[1]), OCSM_LOCALVAR, 1, NINT(value), &ipmtr);
                    CHECK_STATUS(ocsmNewPmtr);

                    for (irc = 1; irc <= NINT(value); irc++) {
                        status = ocsmSetValuD(MODL, ipmtr, 1, irc, 0);
                        CHECK_STATUS(ocsmSetValuD);
                    }
                }

                jbrch++;
            }

            SPRINT0(2, "Parameters after pre-processing INTERFACE statements:");
            if (outLevel >= 2) {
                status = printPmtrs(MODL, stdout);
                CHECK_STATUS(printPmtrs);
            }

            /* find the first udparg statement associated with this UDPRIM */
            jbody = MODL->nbody;
            while (jbody > 0 && MODL->body[jbody].brtype == OCSM_UDPARG &&
                   strcmp(MODL->body[jbody].arg[1].str, args[1].str) == 0 ) {
                jbody--;
            }
            kbody = jbody + 1;

            /* loop through all arguments in all udparg statements */
            for (jbody = kbody; jbody <= MODL->nbody; jbody++) {
                for (iarg = 3; iarg < 10; iarg+=2) {

                    if (MODL->body[jbody].arg[iarg].nval < 0) break;

                    ipmtr = -1;
                    for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                        if (strcmp(MODL->pmtr[jpmtr].name, MODL->body[jbody].arg[iarg-1].str) == 0 &&
                            MODL->pmtr[jpmtr].scope == MODL->scope[MODL->level]                      ) {
                            ipmtr = jpmtr;
                            break;
                        }
                    }

                    if (ipmtr < 0) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "argument \"%s\" in UDPARG/UDPRIM not in INTERFACE", MODL->body[jbody].arg[iarg-1].str);
                        SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                    }

                    if        (MODL->body[jbody].arg[iarg].nval == 0 && MODL->pmtr[ipmtr].str != NULL) {

                        STRNCPY(temp, "$",                             MAX_EXPR_LEN  );
                        strncat(temp, MODL->body[jbody].arg[iarg].str, MAX_EXPR_LEN-1);

                        status = ocsmSetValu(MODL, ipmtr, 1, 1, temp);
                        CHECK_STATUS(ocsmSetValu);

                    } else if (MODL->body[jbody].arg[iarg].nval >= 1 && MODL->pmtr[ipmtr].str == NULL) {

                        /* make Parameter bigger if multi-valued */
                            if (MODL->body[jbody].arg[iarg].nval > 1) {
                                FREE(  MODL->pmtr[ipmtr].value);
                                FREE(  MODL->pmtr[ipmtr].dot);
                                FREE(  MODL->pmtr[ipmtr].lbnd);
                                FREE(  MODL->pmtr[ipmtr].ubnd);

                                MALLOC(MODL->pmtr[ipmtr].value, double, MODL->body[jbody].arg[iarg].nval);
                                MALLOC(MODL->pmtr[ipmtr].dot,   double, MODL->body[jbody].arg[iarg].nval);

                                MODL->pmtr[ipmtr].nrow = MODL->body[jbody].arg[iarg].nrow;
                                MODL->pmtr[ipmtr].ncol = MODL->body[jbody].arg[iarg].ncol;
                            }

                            for (ival = 0; ival < MODL->body[jbody].arg[iarg].nval; ival++) {
                                MODL->pmtr[ipmtr].value[ival] = MODL->body[jbody].arg[iarg].val[ival];
                                MODL->pmtr[ipmtr].dot[  ival] = MODL->body[jbody].arg[iarg].dot[ival];
                            }
                    } else if (MODL->body[jbody].arg[iarg].nval > 0) {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "expecting string for \"%s\"", MODL->pmtr[ipmtr].name);
                        SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                    } else {
                        signalError(MODL, OCSM_ILLEGAL_VALUE,
                                    "expecting non-string for \"%s\"", MODL->pmtr[ipmtr].name);
                        SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                    }
                }
            }

            /* loop through all arguments in UDPRIM statement */
            for (iarg = 3; iarg <= 10; iarg+=2) {
                if (args[iarg].nval < 0) break;

                ipmtr = -1;
                for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                    if (strcmp(MODL->pmtr[jpmtr].name, args[iarg-1].str) == 0 &&
                        MODL->pmtr[jpmtr].scope == MODL->scope[MODL->level]     ) {
                        ipmtr = jpmtr;
                        break;
                    }
                }

                if (ipmtr < 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "bad argument \"%s\"", args[iarg-1].str);
                    SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                }

                if (args[iarg].nval == 0 && MODL->pmtr[ipmtr].str != NULL) {
                    STRNCPY(temp, "$",            MAX_EXPR_LEN  );
                    strncat(temp, args[iarg].str, MAX_EXPR_LEN-1);

                    status = ocsmSetValu(MODL,  ipmtr, 1, 1, temp);
                    CHECK_STATUS(ocsmSetValu);

                } else if (args[iarg].nval >= 1 && MODL->pmtr[ipmtr].str == NULL) {

                    /* make Parameter bigger if multi-valued */
                    if (args[iarg].nval > 1) {
                        FREE(MODL->pmtr[ipmtr].value);
                        FREE(MODL->pmtr[ipmtr].dot  );
                        FREE(MODL->pmtr[ipmtr].lbnd );
                        FREE(MODL->pmtr[ipmtr].ubnd );

                        MALLOC(MODL->pmtr[ipmtr].value, double, args[iarg].nval);
                        MALLOC(MODL->pmtr[ipmtr].dot,   double, args[iarg].nval);

                        MODL->pmtr[ipmtr].nrow = args[iarg].nrow;
                        MODL->pmtr[ipmtr].ncol = args[iarg].ncol;
                    }

                    for (ival = 0; ival < args[iarg].nval; ival++) {
                        MODL->pmtr[ipmtr].value[ival] = args[iarg].val[ival];
                        MODL->pmtr[ipmtr].dot[  ival] = args[iarg].dot[ival];
                    }
                } else if (args[iarg].nval > 0) {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "expecting string for \"%s\"", MODL->pmtr[ipmtr].name);
                    SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                } else {
                    signalError(MODL, OCSM_ILLEGAL_VALUE,
                                "expecting non-string for \"%s\"", MODL->pmtr[ipmtr].name);
                    SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
                }
            }

            SPRINT0(2, "Parameters after processing INTERFACE statements:");
            if (outLevel >= 2) {
                status = printPmtrs(MODL, stdout);
                CHECK_STATUS(printPmtrs);
            }

            /* update @-parameters (UDPRIM: udc) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

        /* bad primtype */
        } else {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "bad primtype");
            SET_STATUS(OCSM_ILLEGAL_VALUE, udprim);
        }

    /* execute" "restore $name index" */
    } else if (type == OCSM_RESTORE) {
        SPRINT3(1, "    executing [%4d] restore:    %s  %11.5f",
                ibrch, args[1].str, args[2].val[0]);

        /* if $name is . (dot), duplicate top Body (not whole Group) on stack */
        if (strcmp(args[1].str, ".") == 0) {

            if ((*nstack) < 1) {
                signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                            "RESTORE . expects a Body on the stack");
                goto cleanup;
            } else if (stack[*nstack-1] <= 0) {
                signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                            "RESTORE . expects a Body on the stack");
                goto cleanup;
            } else {
                ibodyl = stack[*nstack-1];
            }

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_RESTORE, ibodyl, -1,
                             args, MODL->body[ibodyl].hasdots, MODL->body[ibodyl].botype, &ibody);
            CHECK_STATUS(newBody);

            status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (RESTORE) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the Faces with the current Branch */
            if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY ||
                MODL->body[ibodyl].botype == OCSM_SOLID_BODY   ) {
                status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                if (efaces != NULL) {
                    for (iface = 1; iface <= nface; iface++) {
                        status = setFaceAttribute(MODL, ibody, iface, ibrch, ibodyl, npatn, patn);
                        CHECK_STATUS(setFaceAttribute);
                    }

                    EG_free(efaces);
                }
            }

            /* finish the Body (RESTORE) */
            status = finishCopy(MODL, ibodyl, NULL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            if (*nstack < MAX_STACK_SIZE) {
                stack[(*nstack)++] = ibody;
            } else {
                status = OCSM_TOO_MANY_BODYS_ON_STACK;
                signalError(MODL, status,
                            "Too many Bodys on Stack");
                goto cleanup;
            }

            if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY ||
                MODL->body[ibodyl].botype == OCSM_SOLID_BODY   ) {
                status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                CHECK_STATUS(getBodyTolerance);
            } else {
                toler = 0;
            }

            SPRINT5(1, "                          Body   %4d duplicated (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

            goto cleanup;
        }

        /* if index is negative, return all Bodys that match $name */
        if (args[2].val[0] < 0) {

            /* count how many Bodys to restore */
            ibodyl       =  0;
            numRemaining = -1;
            for (istor = MODL->nstor-1; istor >= 0; istor--) {
                if (strcmp(args[1].str, MODL->stor[istor].name) == 0) {
                    ibodyl = MODL->stor[istor].ibody[0];
                    numRemaining++;
                }
            }

            if (numRemaining < 0) {
                status = OCSM_NAME_NOT_FOUND;
                signalError(MODL, status,
                            "storage \"%s\" not found", args[1].str);
                goto cleanup;
            }

            /* recycle old Body if not dirty */
            nbody_save = MODL->nbody;
            status = recycleBody(MODL, ibrch, type, args, MODL->body[ibodyl].hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                    if (*nstack < MAX_STACK_SIZE) {
                        stack[(*nstack)++] = ibodyl;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }
                goto cleanup;
            }

            /* count how many Bodys to restore */
            numRemaining = -1;
            for (istor = 0; istor < MODL->nstor; istor++) {
                if (strcmp(args[1].str, MODL->stor[istor].name) == 0) {
                    numRemaining++;
                }
            }

            if (numRemaining < 0) {
                status = OCSM_NAME_NOT_FOUND;
                signalError(MODL, status,
                            "storage \"%s\" not found", args[1].str);
                goto cleanup;
            }

           for (istor = 0 ; istor < MODL->nstor; istor++) {
                if (strcmp(args[1].str, MODL->stor[istor].name) != 0) continue;

                for (i = MODL->stor[istor].nbody-1; i >= 0; i--) {
                    ibodyl = MODL->stor[istor].ibody[i];

                    /* create the Body */
                    status = newBody(MODL, ibrch, OCSM_RESTORE, ibodyl, -1,
                                     args, MODL->body[ibodyl].hasdots, MODL->body[ibodyl].botype, &ibody);
                    CHECK_STATUS(newBody);

                    status = EG_copyObject(MODL->stor[istor].ebody[i], NULL, &ebody);
                    CHECK_STATUS(EG_copyObject);

                    MODL->body[ibody].ebody = ebody;

                    status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                             1, &numRemaining, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    numRemaining--;

                    /* update @-parameters (RESTORE) */
                    status = setupAtPmtrs(MODL, 0);
                    CHECK_STATUS(setupAtPmtrs);

                    /* mark the Faces with the current Branch */
                    if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY ||
                        MODL->body[ibodyl].botype == OCSM_SOLID_BODY   ) {
                        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                        CHECK_STATUS(EG_getBodyTopos);

                        if (efaces != NULL) {
                            for (iface = 1; iface <= nface; iface++) {
                                status = setFaceAttribute(MODL, ibody, iface, ibrch, MODL->stor[istor].ibody[i], npatn, patn);
                                CHECK_STATUS(setFaceAttribute);
                            }

                            EG_free(efaces);
                        }
                    }

                    /* finish the Body (RESTORE) */
                    status = finishCopy(MODL, ibodyl, NULL, ibody);
                    if (MODL->sigCode != SUCCESS) goto cleanup;
                    CHECK_STATUS(finishBody);

                    /* push the Body onto the stack */
                    if (*nstack < MAX_STACK_SIZE) {
                        stack[(*nstack)++] = ibody;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }

                    if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY ||
                        MODL->body[ibodyl].botype == OCSM_SOLID_BODY   ) {
                        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                        CHECK_STATUS(getBodyTolerance);
                    } else {
                        toler = 0;
                    }

                    SPRINT5(1, "                          Body   %4d restored (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                            ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

                    /* decrement Group so that others that get made in the same restore
                       will have the same Group number */
                    (MODL->ngroup)--;
                }
            }

           /* increment the Group since we are finished with it */
           (MODL->ngroup)++;

            goto cleanup;
        }

        /* find name/index in storage */
        istor = -1;

        for (jstor = 0; jstor < MODL->nstor; jstor++) {
            if (strcmp(args[1].str, MODL->stor[jstor].name) == 0 &&
                NINT(args[2].val[0]) ==  MODL->stor[jstor].index   ) {
                istor = jstor;
                break;
            }
        }

        /* if storage does not exist, return an error */
        if (istor < 0) {
            signalError(MODL, OCSM_NAME_NOT_FOUND,
                        "storage \"%s\" %d not found", args[1].str, NINT(args[2].val[0]));
            SET_STATUS(OCSM_NAME_NOT_FOUND, restore);
        }

        for (i = MODL->stor[istor].nbody-1; i >= 0; i--) {
            ibodyl = MODL->stor[istor].ibody[i];

            /* recycle old Body if not dirty */
            nbody_save = MODL->nbody;
            status = recycleBody(MODL, ibrch, type, args, MODL->body[ibodyl].hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                    if (*nstack < MAX_STACK_SIZE) {
                        stack[(*nstack)++] = ibodyl;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }
                (MODL->ngroup)--;       /* this will get incremented below */

                status = SUCCESS;
                break;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_RESTORE, ibodyl, -1,
                             args, MODL->body[ibodyl].hasdots, MODL->body[ibodyl].botype, &ibody);
            CHECK_STATUS(newBody);

            status = EG_copyObject(MODL->stor[istor].ebody[i], NULL, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                     1, &i, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);

            /* update @-parameters (RESTORE) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the Faces with the current Branch */
            if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY ||
                MODL->body[ibodyl].botype == OCSM_SOLID_BODY   ) {
                status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
                CHECK_STATUS(EG_getBodyTopos);

                if (efaces != NULL) {
                    for (iface = 1; iface <= nface; iface++) {
                        status = setFaceAttribute(MODL, ibody, iface, ibrch, MODL->stor[istor].ibody[i], npatn, patn);
                        CHECK_STATUS(setFaceAttribute);
                    }

                    EG_free(efaces);
                }
            }

            /* finish the Body (RESTORE) */
            status = finishCopy(MODL, ibodyl, NULL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            if (*nstack < MAX_STACK_SIZE) {
                stack[(*nstack)++] = ibody;
            } else {
                status = OCSM_TOO_MANY_BODYS_ON_STACK;
                signalError(MODL, status,
                            "Too many Bodys on Stack");
                goto cleanup;
            }

            if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY ||
                MODL->body[ibodyl].botype == OCSM_SOLID_BODY   ) {
                status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
                CHECK_STATUS(getBodyTolerance);
            } else {
                toler = 0;
            }

            SPRINT5(1, "                          Body   %4d restored (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

            /* decrement Group so that others that get made in the same restore
               will have the same Group number */
            (MODL->ngroup)--;
        }

        /* increment the Group since we are finished with it */
        (MODL->ngroup)++;
    }

cleanup:
    FREE(ebodys );
    FREE(ibodys );
    FREE(newTess);
    FREE(newIlist);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildSketch - implement OCSM_SKETCHs for ocsmBuild                 *
 *                                                                      *
 ************************************************************************
 */

static int
buildSketch(modl_T *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            varg_T args[],              /* (in)  array of arguments */
            int    *nstack,             /* (both) number of Bodys on stack */
            int    stack[],             /* (both) array  of Bodys on stack */
            int    npatn,               /* (in)   number of patterns */
            patn_T patn[],              /* (both) array  of patterns */
            sket_T *sket)               /* (both) current Sketch info */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       type, hasdots, i, ii, jj, n, nspln=0, nbezr=0, ibody, iopen, iswap;
    int       ipmtr, index1, index2, im1, ip1, ibeg, iend, ivec[4], attrType, attrLen;
    CINT      *tempIlist;
    double    xlast, ylast, zlast, ulast=0, vlast=0, wlast=0, areax, areay, areaz, area;
    double    xmin, xmax, ymin, ymax, zmin, zmax;
    double    pts[3*MAX_SKETCH_SIZE], pts_dot[3*MAX_SKETCH_SIZE];
    double    dx1, dy1, dz1, ds1, dx2, dy2, dz2, ds2, dotp, swap, *rvec;
    double    matrix[12], matrix_dot[12], *begcond=NULL, begslope[3], *endcond=NULL, endslope[3];
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;

    int        iseg, jseg, sense[MAX_SKETCH_SIZE], header[4];
    int        iface, nface, nedge, periodic, wireonly;
    double     data[20], tdata[4], tdata_dot[4], result[3], dx, dy, dz, du, dv, dw, ds, ds3;
    double     scent, xcent, ycent, zcent, ucent, vcent, wcent;

    int        jpmtr, jndex, ivar;

    char       value[MAX_EXPR_LEN], prefix[MAX_EXPR_LEN], suffix[MAX_EXPR_LEN];

    double     range[4], eval[18], norm[3];
    ego        ebody, *efaces, ecurve, eflip, eloop, enew, etemp, exform;
    ego        Enodes[MAX_SKETCH_SIZE+1], Eedges[MAX_SKETCH_SIZE], Efaces[1];
    ego        enode, eedge;

    ROUTINE(buildSketch);

    /* --------------------------------------------------------------- */

#ifndef ANALYTIC_SKETCH
    tdata_dot[0] = 0;
    matrix_dot[0] = 0;
    pts_dot[0] = 0;
#endif

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "skbeg x y z relative=0" */
    if (type == OCSM_SKBEG) {
        SPRINT5(1, "    executing [%4d] skbeg:      %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* store the base variables for the Sketch */
        sket->xbase = args[1].val[0];
        sket->ybase = args[2].val[0];
        sket->zbase = args[3].val[0];
        sket->ubase = args[1].dot[0];
        sket->vbase = args[2].dot[0];
        sket->wbase = args[3].dot[0];

        /* determine if coordinates in LINSEG, CIRARC, ARC, SPLINE, and
           BEZIER are relative to those given in the SKBEG statement */
        if (NINT(args[4].val[0]) != 1) {
            sket->irel = 0;
        } else {
            sket->irel = 1;
        }

        /* add a segment to the Sketch */
        sket->itype[sket->nseg] = OCSM_SKBEG;
        sket->ibrch[sket->nseg] = ibrch;
        if (sket->irel == 0) {
            sket->x[sket->nseg] = args[1].val[0];
            sket->y[sket->nseg] = args[2].val[0];
            sket->z[sket->nseg] = args[3].val[0];
            sket->u[sket->nseg] = args[1].dot[0];
            sket->v[sket->nseg] = args[2].dot[0];
            sket->w[sket->nseg] = args[3].dot[0];
        } else {
            sket->x[sket->nseg] = 0;
            sket->y[sket->nseg] = 0;
            sket->z[sket->nseg] = 0;
            sket->u[sket->nseg] = 0;
            sket->v[sket->nseg] = 0;
            sket->w[sket->nseg] = 0;
        }
        sket->nseg++;

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_SKBEG, -1, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "skvar $type valList" */
    } else if (type == OCSM_SKVAR) {
        SPRINT5(1, "    executing [%4d] skvar:   %s  %11.5f  %11.5f  %11.5f ...",
                ibrch, args[1].str, args[2].val[0], args[2].val[1], args[2].val[2]);

        /* check that Sketch variables are not defined already */
        if (sket->nvar > 0) {
            signalError(MODL, OCSM_ILLEGAL_STATEMENT,
                        "Sketch varibles already exist");
            SET_STATUS(OCSM_ILLEGAL_STATEMENT, skvar);
        }

        /* check that sketech variables are not defined yet */
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if        (strcmp(MODL->pmtr[ipmtr].name, "::x") == 0) {
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "\"::x\" already exists");
                SET_STATUS(OCSM_NAME_ALREADY_DEFINED, skvar);
            } else if (strcmp(MODL->pmtr[ipmtr].name, "::y") == 0) {
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "\"::y\" already exists");
                SET_STATUS(OCSM_NAME_ALREADY_DEFINED, skvar);
            } else if (strcmp(MODL->pmtr[ipmtr].name, "::z") == 0) {
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "\"::z\" already exists");
                SET_STATUS(OCSM_NAME_ALREADY_DEFINED, skvar);
            } else if (strcmp(MODL->pmtr[ipmtr].name, "::d") == 0) {
                signalError(MODL, OCSM_NAME_ALREADY_DEFINED,
                            "\"::d\" already exists");
                SET_STATUS(OCSM_NAME_ALREADY_DEFINED, skvar);
            }
        }

        /* make the new Sketch variables */
        sket->size = args[2].nval / 3;

        status = ocsmNewPmtr(MODL, "::x", OCSM_LOCALVAR, 1, sket->size);
        CHECK_STATUS(ocsmNewPmtr);
        sket->ix = MODL->npmtr;

        status = ocsmNewPmtr(MODL, "::y", OCSM_LOCALVAR, 1, sket->size);
        CHECK_STATUS(ocsmNewPmtr);
        sket->iy = MODL->npmtr;

        status = ocsmNewPmtr(MODL, "::z", OCSM_LOCALVAR, 1, sket->size);
        CHECK_STATUS(ocsmNewPmtr);
        sket->iz = MODL->npmtr;

        status = ocsmNewPmtr(MODL, "::d", OCSM_LOCALVAR, 1, sket->size);
        CHECK_STATUS(ocsmNewPmtr);
        sket->id = MODL->npmtr;

        /* set the values for the Sketch variables */
        if        (strcmp(args[1].str, "xy") == 0) {
            sket->type = 1;

            for (i = 0; i < sket->size; i++) {
                MODL->pmtr[sket->ix].value[i] = args[2].val[3*i  ];
                MODL->pmtr[sket->iy].value[i] = args[2].val[3*i+1];
                MODL->pmtr[sket->iz].value[i] = sket->zbase;
                MODL->pmtr[sket->id].value[i] = args[2].val[3*i+2];

                MODL->pmtr[sket->ix].dot[i] = args[2].dot[3*i  ];
                MODL->pmtr[sket->iy].dot[i] = args[2].dot[3*i+1];
                MODL->pmtr[sket->iz].dot[i] = sket->wbase;
                MODL->pmtr[sket->id].dot[i] = args[2].dot[3*i+2];
            }
        } else if (strcmp(args[1].str, "yz") == 0) {
            sket->type = 2;

            for (i = 0; i < sket->size; i++) {
                MODL->pmtr[sket->ix].value[i] = sket->xbase;
                MODL->pmtr[sket->iy].value[i] = args[2].val[3*i  ];
                MODL->pmtr[sket->iz].value[i] = args[2].val[3*i+1];
                MODL->pmtr[sket->id].value[i] = args[2].val[3*i+2];

                MODL->pmtr[sket->ix].dot[i] = sket->ubase;
                MODL->pmtr[sket->iy].dot[i] = args[2].dot[3*i  ];
                MODL->pmtr[sket->iz].dot[i] = args[2].dot[3*i+1];
                MODL->pmtr[sket->id].dot[i] = args[2].dot[3*i+2];
            }
        } else if (strcmp(args[1].str, "zx") == 0) {
            sket->type = 3;

            for (i = 0; i < sket->size; i++) {
                MODL->pmtr[sket->ix].value[i] = args[2].val[3*i+1];
                MODL->pmtr[sket->iy].value[i] = sket->ybase;
                MODL->pmtr[sket->iz].value[i] = args[2].val[3*i  ];
                MODL->pmtr[sket->id].value[i] = args[2].val[3*i+2];

                MODL->pmtr[sket->ix].dot[i] = args[2].dot[3*i+1];
                MODL->pmtr[sket->iy].dot[i] = sket->vbase;
                MODL->pmtr[sket->iz].dot[i] = args[2].dot[3*i  ];
                MODL->pmtr[sket->id].dot[i] = args[2].dot[3*i+2];
            }
        }

        /* make a list of the Sketch variables */
        for (i = 1; i <= sket->size; i++) {
            if (sket->type == 1 || sket->type == 3) {
                sket->ipmtr[sket->nvar] = sket->ix;
                sket->index[sket->nvar] = i-1;
                sket->nvar++;
            }

            if (sket->type == 2 || sket->type == 1) {
                sket->ipmtr[sket->nvar] = sket->iy;
                sket->index[sket->nvar] = i-1;
                sket->nvar++;
            }

            if (sket->type == 3 || sket->type == 2) {
                sket->ipmtr[sket->nvar] = sket->iz;
                sket->index[sket->nvar] = i-1;
                sket->nvar++;
            }

            if (fabs(MODL->pmtr[sket->id].value[i-1]) > EPS06) {
                sket->ipmtr[sket->nvar] = sket->id;
                sket->index[sket->nvar] = i-1;
                sket->nvar++;
            }
        }

        for (ivar = 0; ivar < sket->nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            SPRINT3(1, "    -> creating  %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

        /* set the "constant" Sketch variables */
        for (i = 0; i < sket->size; i++) {
            if        (sket->type == 1) {
                MODL->pmtr[sket->iz].value[i] = sket->zbase;
                MODL->pmtr[sket->iz].dot[  i] = sket->wbase;
            } else if (sket->type == 2) {
                MODL->pmtr[sket->ix].value[i] = sket->xbase;
                MODL->pmtr[sket->ix].dot[  i] = sket->ubase;
            } else {
                MODL->pmtr[sket->iy].value[i] = sket->ybase;
                MODL->pmtr[sket->iy].dot[  i] = sket->vbase;
            }
        }

    /* execute: "skcon $type index1 index2=-1 $value=0" */
    } else if (type == OCSM_SKCON) {
        SPRINT5(1, "    executing [%4d] skcon:   %s  %3d  %3d  %s",
                ibrch, args[1].str, NINT(args[2].val[0]), NINT(args[3].val[0]), args[4].str);

        index1 = NINT(args[2].val[0]);
        index2 = NINT(args[3].val[0]);

        /* copy args[4].str to value so that it can be modified if needed below */
        strcpy(value, args[4].str);

        /* (recursivly) modify value if it contains "::L[", "::I[", "::R[", or "::S[" */
        while (strstr(value, "::L[") != NULL || strstr(value, "::I[") != NULL ||
               strstr(value, "::R[") != NULL || strstr(value, "::S[") != NULL   ) {

            /* pull out the prefix */
            prefix[0] = '\0';
            ibeg      =   0 ;
            for (ii = 0; ii < STRLEN(value); ii++) {
                if (value[ii] == ':' && value[ii+1] == ':' && value[ii+3] == '[') {
                    if (value[ii+2] == 'L' || value[ii+2] == 'I' ||
                        value[ii+2] == 'R' || value[ii+2] == 'S'   ) {
                        if (ii > 0) {
                            STRNCPY(prefix, value, ii+1);
                        }
                        ibeg = strtol(&(value[ii+4]), NULL, 10);
                        break;
                    }
                }
            }

            /* check that argument was okay */
            if (ibeg < 1 || ibeg > sket->size) {
                signalError(MODL, OCSM_ILLEGAL_VALUE,
                            "::%c[%d] is not defined", value[ii+2], ibeg);
                status = OCSM_ILLEGAL_VALUE;
                goto cleanup;
            } else if (ibeg < sket->size) {
                iend = ibeg + 1;
            } else {
                iend = 1;
            }

            /* pull out the suffix */
            suffix[0] = '\0';
            for (jj = ii+3; jj < STRLEN(value); jj++) {
                if (value[jj] == ']') {
                    strcpy(suffix, &(value[jj+1]));
                    break;
                }
            }

            /* create the replacement text */
            if        (value[ii+2] == 'L') {
                snprintf(value, MAX_EXPR_LEN, "%shypot(::y[%d]-::y[%d],::x[%d]-::x[%d])%s",
                         prefix, iend, ibeg, iend, ibeg, suffix);
            } else if (value[ii+2] == 'I') {
                snprintf(value, MAX_EXPR_LEN, "%satan2d(::y[%d]-::y[%d],::x[%d]-::x[%d])%s",
                         prefix, iend, ibeg, iend, ibeg, suffix);
            } else if (value[ii+2] == 'R') {
                snprintf(value, MAX_EXPR_LEN, "%sradius(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])%s",
                         prefix, ibeg, ibeg, iend, iend, iend, suffix);
            } else if (value[ii+2] == 'S') {
                snprintf(value, MAX_EXPR_LEN, "%ssweep(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])%s",
                         prefix, ibeg, ibeg, iend, iend, iend, suffix);
            }
        }

        /* constraints on XY plane */
        if (sket->type == 1) {
            if        (strcmp(args[1].str, "X") == 0 && index2 <= 0) {
                sket->ctype[sket->ncon] = 'X';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::x[%d]-(%s)",
                         index1, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "X") == 0) {
                sket->ctype[sket->ncon] = 'X';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "Xcent(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                         index1, index1, index2, index2, index2, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "Y") == 0 && index2 <= 0) {
                sket->ctype[sket->ncon] = 'Y';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::y[%d]-(%s)",
                         index1, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "Y") == 0) {
                sket->ctype[sket->ncon] = 'Y';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "Ycent(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                         index1, index1, index2, index2, index2, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "P") == 0) {
                sket->ctype[sket->ncon] = 'P';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "(abs(turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d]))-90)/57.3",
                         im1, im1, index1, index1, index1, ip1, ip1, ip1);
            } else if (strcmp(args[1].str, "T") == 0) {
                sket->ctype[sket->ncon] = 'T';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])/57.3",
                         im1, im1, index1, index1, index1, ip1, ip1, ip1);
            } else if (strcmp(args[1].str, "A") == 0) {
                sket->ctype[sket->ncon] = 'A';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                im1 = index1 - 1; if (im1 == 0           ) im1 = sket->size;
                ip1 = index1 + 1; if (ip1 == sket->size+1) ip1 = 1;
                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "(turnang(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-smallang(%s))/57.3",
                         im1, im1, index1, index1, index1, ip1, ip1, ip1, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "Z") == 0) {
                sket->ctype[sket->ncon] = 'Z';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                if        (index2 == -2) {
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::x[%d]-::x[%d]",
                             index1, index1+1);
                } else if (index2 == -3) {
                    snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                             "::y[%d]-::y[%d]",
                             index1-1, index1);
                }
            } else if (strcmp(args[1].str, "W") == 0) {
                sket->ctype[sket->ncon] = 'W';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::x[%d]-::x[%d]-(%s)",
                         index2, index1, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "D") == 0) {
                sket->ctype[sket->ncon] = 'D';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::y[%d]-::y[%d]-(%s)",
                         index2, index1, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "H") == 0) {
                sket->ctype[sket->ncon] = 'H';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::y[%d]-::y[%d]",
                         index1, index2);
            } else if (strcmp(args[1].str, "V") == 0) {
                sket->ctype[sket->ncon] = 'V';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "::x[%d]-::x[%d]",
                         index1, index2);
            } else if (strcmp(args[1].str, "I") == 0) {
                sket->ctype[sket->ncon] = 'I';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "smallang(atan2d(::y[%d]-::y[%d],::x[%d]-::x[%d])-(%s))/57.3",
                         index2, index1, index2, index1, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "L") == 0) {
                sket->ctype[sket->ncon] = 'L';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "hypot(::y[%d]-::y[%d],::x[%d]-::x[%d])-(%s)",
                         index1, index2, index1, index2, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "R") == 0) {
                sket->ctype[sket->ncon] = 'R';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "radius(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s)",
                         index1, index1, index2, index2, index2, /*@ignore@*/value/*@end@*/);
            } else if (strcmp(args[1].str, "S") == 0) {
                sket->ctype[sket->ncon] = 'S';
                sket->ipnt[ sket->ncon] = index1;
                sket->ip1[  sket->ncon] = index2;

                snprintf(sket->con[sket->ncon++], MAX_EXPR_LEN,
                         "(sweep(::x[%d],::y[%d],::d[%d],::x[%d],::y[%d])-(%s))/57.3",
                         index1, index1, index2, index2, index2, /*@ignore@*/value/*@end@*/);
            }
        }

        /* make a note that the Sketch needs to be solved */
        sket->solved = 0;

    /* execute: "linseg x y z" */
    } else if (type == OCSM_LINSEG) {
        SPRINT4(1, "    executing [%4d] linseg:     %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* add a segment to the Sketch */
        sket->itype[sket->nseg] = OCSM_LINSEG;
        sket->ibrch[sket->nseg] = ibrch;
        sket->x[    sket->nseg] = args[1].val[0];
        sket->y[    sket->nseg] = args[2].val[0];
        sket->z[    sket->nseg] = args[3].val[0];
        sket->u[    sket->nseg] = args[1].dot[0];
        sket->v[    sket->nseg] = args[2].dot[0];
        sket->w[    sket->nseg] = args[3].dot[0];
        sket->nseg++;

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_LINSEG, MODL->nbody, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "cirarc xon yon zon xend yend zend" */
    } else if (type == OCSM_CIRARC) {
        SPRINT7(1, "    executing [%4d] cirarc:     %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].val[0], args[6].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0 ||
            args[5].dot[0] != 0 || args[6].dot[0] != 0                                   ) {
            hasdots = 1;

            SPRINT6(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0],
                       args[5].dot[0], args[6].dot[0]);
        }

        /* check for the colinearity of the 3 points */
        dx1 = args[1].val[0] - sket->x[sket->nseg-1];
        dy1 = args[2].val[0] - sket->y[sket->nseg-1];
        dz1 = args[3].val[0] - sket->z[sket->nseg-1];
        ds1 = sqrt(dx1*dx1 + dy1*dy1 + dz1*dz1);

        dx2 = args[4].val[0] - args[1].val[0];
        dy2 = args[5].val[0] - args[2].val[0];
        dz2 = args[6].val[0] - args[3].val[0];
        ds2 = sqrt(dx2*dx2 + dy2*dy2 + dz2*dz2);

        dotp = (dx1*dx2 + dy1*dy2 + dz1*dz2) / ds1 / ds2;

        /* if points are co-linear, convert to a linseg */
        if (fabs(dotp) > 1-EPS06) {
            SPRINT0(1, "WARNING:: converting to linseg since points are colinear");
            (MODL->nwarn)++;

            sket->itype[sket->nseg] = OCSM_LINSEG;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[4].val[0];
            sket->y[    sket->nseg] = args[5].val[0];
            sket->z[    sket->nseg] = args[6].val[0];
            sket->u[    sket->nseg] = args[4].dot[0];
            sket->v[    sket->nseg] = args[5].dot[0];
            sket->w[    sket->nseg] = args[6].dot[0];
            sket->nseg++;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status != 1) {
                args[1].val[0] = args[4].val[0];
                args[2].val[0] = args[5].val[0];
                args[3].val[0] = args[6].val[0];

                args[1].dot[0] = args[4].dot[0];
                args[2].dot[0] = args[5].dot[0];
                args[3].dot[0] = args[6].dot[0];

                status = newBody(MODL, ibrch, OCSM_LINSEG, MODL->nbody, -1,
                                 args, hasdots, OCSM_SKETCH, &ibody);
                CHECK_STATUS(newBody);
            }

        /* add the cirarc to the Sketch (as two segments) */
        } else {
            sket->itype[sket->nseg] = OCSM_CIRARC;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[1].val[0];
            sket->y[    sket->nseg] = args[2].val[0];
            sket->z[    sket->nseg] = args[3].val[0];
            sket->u[    sket->nseg] = args[1].dot[0];
            sket->v[    sket->nseg] = args[2].dot[0];
            sket->w[    sket->nseg] = args[3].dot[0];
            sket->nseg++;

            sket->itype[sket->nseg] = OCSM_CIRARC;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[4].val[0];
            sket->y[    sket->nseg] = args[5].val[0];
            sket->z[    sket->nseg] = args[6].val[0];
            sket->u[    sket->nseg] = args[4].dot[0];
            sket->v[    sket->nseg] = args[5].dot[0];
            sket->w[    sket->nseg] = args[6].dot[0];
            sket->nseg++;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status != 1) {
                status = newBody(MODL, ibrch, OCSM_CIRARC, MODL->nbody, -1,
                                 args, hasdots, OCSM_SKETCH, &ibody);
                CHECK_STATUS(newBody);

                /* dump a copy of this Body */
                status = dumpEgadsFile(MODL, ibody);
                CHECK_STATUS(dumpEgadsFile);
            }
        }

    /* execute: "arc xend yend zend dist $plane=xy" */
    } else if (type == OCSM_ARC) {
        SPRINT6(1, "    executing [%4d] arc:        %11.5f  %11.5f  %11.5f  %11.5f  %s",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0],
                       args[5].str);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0) {
            hasdots = 1;

            SPRINT4(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0]);
        }

        /* if points are co-linear, convert to a linseg */
        if (fabs(args[4].val[0]) < EPS06) {
            SPRINT0(1, "WARNING:: converting to linseg since points are colinear");
            (MODL->nwarn)++;

            sket->itype[sket->nseg] = OCSM_LINSEG;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[1].val[0];
            sket->y[    sket->nseg] = args[2].val[0];
            sket->z[    sket->nseg] = args[3].val[0];
            sket->u[    sket->nseg] = args[1].dot[0];
            sket->v[    sket->nseg] = args[2].dot[0];
            sket->w[    sket->nseg] = args[3].dot[0];
            sket->nseg++;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status != 1) {
                status = newBody(MODL, ibrch, OCSM_LINSEG, MODL->nbody, -1,
                                 args, hasdots, OCSM_SKETCH, &ibody);
                CHECK_STATUS(newBody);
            }

        /* add the arc to the Sketch (as two segments) */
        } else {
            xcent = (args[1].val[0] + sket->x[sket->nseg-1]) / 2;
            ycent = (args[2].val[0] + sket->y[sket->nseg-1]) / 2;
            zcent = (args[3].val[0] + sket->z[sket->nseg-1]) / 2;
            ucent = (args[1].dot[0] + sket->u[sket->nseg-1]) / 2;
            vcent = (args[2].dot[0] + sket->v[sket->nseg-1]) / 2;
            wcent = (args[3].dot[0] + sket->w[sket->nseg-1]) / 2;

            dx    = (args[1].val[0] - sket->x[sket->nseg-1]);
            dy    = (args[2].val[0] - sket->y[sket->nseg-1]);
            dz    = (args[3].val[0] - sket->z[sket->nseg-1]);
            du    = (args[1].dot[0] - sket->u[sket->nseg-1]);
            dv    = (args[2].dot[0] - sket->v[sket->nseg-1]);
            dw    = (args[3].dot[0] - sket->w[sket->nseg-1]);

            if        (strcmp(args[5].str, "xy") == 0 ) {
                ds  = sqrt(dx * dx + dy * dy);
                ds3 = pow(ds, 3);

                sket->itype[sket->nseg] = OCSM_CIRARC;
                sket->ibrch[sket->nseg] = ibrch;
                sket->x[    sket->nseg] = xcent + args[4].val[0] * dy / ds;
                sket->y[    sket->nseg] = ycent - args[4].val[0] * dx / ds;
                sket->z[    sket->nseg] = zcent;
                sket->u[    sket->nseg] = ucent + args[4].dot[0] * dy / ds
                                                + args[4].val[0] * dv / ds
                                                - args[4].val[0] * dy / ds3 * dy * dv;
                sket->v[    sket->nseg] = vcent - args[4].dot[0] * dx / ds
                                                - args[4].val[0] * du / ds
                                                + args[4].val[0] * dx / ds3 * dx * du;
                sket->w[    sket->nseg] = wcent;
                sket->nseg++;
            } else if (strcmp(args[5].str, "yz") == 0) {
                ds  = sqrt(dy * dy + dz * dz);
                ds3 = pow(ds, 3);

                sket->itype[sket->nseg] = OCSM_CIRARC;
                sket->ibrch[sket->nseg] = ibrch;
                sket->y[    sket->nseg] = ycent + args[4].val[0] * dz / ds;
                sket->z[    sket->nseg] = zcent - args[4].val[0] * dy / ds;
                sket->x[    sket->nseg] = xcent;
                sket->v[    sket->nseg] = vcent + args[4].dot[0] * dz / ds
                                                + args[4].val[0] * dw / ds
                                                - args[4].val[0] * dz / ds3 * dz * dw;
                sket->w[    sket->nseg] = wcent - args[4].dot[0] * dy / ds
                                                - args[4].val[0] * dv / ds
                                                + args[4].val[0] * dy / ds3 * dy * dv;
                sket->u[    sket->nseg] = ucent;
                sket->nseg++;
            } else {
                ds  = sqrt(dz * dz + dx * dx);
                ds3 = pow(ds, 3);

                sket->itype[sket->nseg] = OCSM_CIRARC;
                sket->ibrch[sket->nseg] = ibrch;
                sket->z[    sket->nseg] = zcent + args[4].val[0] * dx / ds;
                sket->x[    sket->nseg] = xcent - args[4].val[0] * dz / ds;
                sket->y[    sket->nseg] = ycent;
                sket->w[    sket->nseg] = wcent + args[4].dot[0] * dx / ds
                                                + args[4].val[0] * du / ds
                                                - args[4].val[0] * dx / ds3 * dx * du;
                sket->u[    sket->nseg] = ucent - args[4].dot[0] * dz / ds
                                                - args[4].val[0] * dw / ds
                                                + args[4].val[0] * dz / ds3 * dz * dw;
                sket->v[    sket->nseg] = vcent;
                sket->nseg++;
            }

            sket->itype[sket->nseg] = OCSM_CIRARC;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[1].val[0];
            sket->y[    sket->nseg] = args[2].val[0];
            sket->z[    sket->nseg] = args[3].val[0];
            sket->u[    sket->nseg] = args[1].dot[0];
            sket->v[    sket->nseg] = args[2].dot[0];
            sket->w[    sket->nseg] = args[3].dot[0];
            sket->nseg++;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status != 1) {
                status = newBody(MODL, ibrch, OCSM_ARC, MODL->nbody, -1,
                                 args, hasdots, OCSM_SKETCH, &ibody);
                CHECK_STATUS(newBody);

                /* dump a copy of this Body */
                status = dumpEgadsFile(MODL, ibody);
                CHECK_STATUS(dumpEgadsFile);
            }
        }

    /* execute: "spline x y z" */
    } else if (type == OCSM_SPLINE) {
        SPRINT4(1, "    executing [%4d] spline:     %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* add the spline to the Sketch */
        sket->itype[sket->nseg] = OCSM_SPLINE;
        sket->ibrch[sket->nseg] = ibrch;
        sket->x[    sket->nseg] = args[1].val[0];
        sket->y[    sket->nseg] = args[2].val[0];
        sket->z[    sket->nseg] = args[3].val[0];
        sket->u[    sket->nseg] = args[1].dot[0];
        sket->v[    sket->nseg] = args[2].dot[0];
        sket->w[    sket->nseg] = args[3].dot[0];
        sket->nseg++;

        /* warning for repeated points */
        if (sket->nseg > 1) {
            if (fabs(sket->x[sket->nseg-1]-sket->x[sket->nseg-2]) < EPS06 &&
                fabs(sket->y[sket->nseg-1]-sket->y[sket->nseg-2]) < EPS06 &&
                fabs(sket->z[sket->nseg-1]-sket->z[sket->nseg-2]) < EPS06   ) {
                SPRINT0(1, "WARNING:: repeated point in spline being removed");
                (MODL->nwarn)++;
                sket->nseg--;
            }
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_SPLINE, MODL->nbody, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "sslope dx dy dz" */
    } else if (type == OCSM_SSLOPE) {
        SPRINT4(1, "    executing [%4d] sslope:     %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        if (fabs(args[1].val[0]) < EPS06 &&
            fabs(args[2].val[0]) < EPS06 &&
            fabs(args[3].val[0]) < EPS06   ) {
            status = OCSM_ILLEGAL_VALUE;
            signalError(MODL, status,
                        "SSLOPE requires non-zero direction");
            goto cleanup;
        }

        /* add the spline to the Sketch */
        sket->itype[sket->nseg] = OCSM_SSLOPE;
        sket->ibrch[sket->nseg] = ibrch;
        sket->x[    sket->nseg] = args[1].val[0];
        sket->y[    sket->nseg] = args[2].val[0];
        sket->z[    sket->nseg] = args[3].val[0];
        sket->u[    sket->nseg] = args[1].dot[0];
        sket->v[    sket->nseg] = args[2].dot[0];
        sket->w[    sket->nseg] = args[3].dot[0];
        sket->nseg++;

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_SSLOPE, MODL->nbody, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "bezier x y z" */
    } else if (type == OCSM_BEZIER) {
        SPRINT4(1, "    executing [%4d] bezier:     %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                       args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* check for a zero-length segment */
        if (fabs(sket->x[sket->nseg-1]-args[1].val[0]) < EPS06 &&
            fabs(sket->y[sket->nseg-1]-args[2].val[0]) < EPS06 &&
            fabs(sket->z[sket->nseg-1]-args[3].val[0]) < EPS06   ) {
            SPRINT0(1, "WARNING:: zero-length segment skipped");
            (MODL->nwarn)++;
        } else {

            /* add the bezier to the Sketch */
            sket->itype[sket->nseg] = OCSM_BEZIER;
            sket->ibrch[sket->nseg] = ibrch;
            sket->x[    sket->nseg] = args[1].val[0];
            sket->y[    sket->nseg] = args[2].val[0];
            sket->z[    sket->nseg] = args[3].val[0];
            sket->u[    sket->nseg] = args[1].dot[0];
            sket->v[    sket->nseg] = args[2].dot[0];
            sket->w[    sket->nseg] = args[3].dot[0];
            sket->nseg++;
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status != 1) {
            status = newBody(MODL, ibrch, OCSM_BEZIER, MODL->nbody, -1,
                             args, hasdots, OCSM_SKETCH, &ibody);
            CHECK_STATUS(newBody);

            /* dump a copy of this Body */
            status = dumpEgadsFile(MODL, ibody);
            CHECK_STATUS(dumpEgadsFile);
        }

    /* execute: "skend wireonly=0" */
    } else if (type == OCSM_SKEND) {
        SPRINT2(1, "    executing [%4d] skend:      %11.5f",
                ibrch, args[1].val[0]);

        /* require finite differences */
        MODL->needFDs = 1;

        wireonly = NINT(args[1].val[0]);

        /* make sure SSLOPE statements comes either before or after
           a SPLINE statement, but not both */
        for (iseg = 1; iseg < sket->nseg-1; iseg++) {
            if (sket->itype[iseg] == OCSM_SSLOPE) {
                if        (sket->itype[iseg-1] == OCSM_SPLINE &&
                           sket->itype[iseg+1] == OCSM_SPLINE   ) {
                    status = OCSM_ILLEGAL_STATEMENT;
                    signalError(MODL, status,
                                "SSLOPE cannot be between SPLINE statements");
                    goto cleanup;
                } else if (sket->itype[iseg-1] != OCSM_SPLINE &&
                           sket->itype[iseg+1] != OCSM_SPLINE   ) {
                    status = OCSM_ILLEGAL_STATEMENT;
                    signalError(MODL, status,
                                "SSLOPE must precede or follow a SPLINE statement");
                    goto cleanup;
                }
            }
        }

        /* add the skend to the Sketch */
        sket->itype[sket->nseg] = OCSM_SKEND;
        sket->ibrch[sket->nseg] = ibrch;
        sket->x[    sket->nseg] = sket->x[sket->nseg-1];   /* not used */
        sket->y[    sket->nseg] = sket->y[sket->nseg-1];
        sket->z[    sket->nseg] = sket->z[sket->nseg-1];
        sket->u[    sket->nseg] = sket->u[sket->nseg-1];   /* not used */
        sket->v[    sket->nseg] = sket->v[sket->nseg-1];
        sket->w[    sket->nseg] = sket->w[sket->nseg-1];
        sket->nseg++;

        /* determine if we need to create Sketch or its sensitivity */
        hasdots = 0;
        for (iseg = 0; iseg < sket->nseg; iseg++) {
            if (fabs(sket->u[iseg]) > EPS06 ||
                fabs(sket->v[iseg]) > EPS06 ||
                fabs(sket->w[iseg]) > EPS06   ) {
                hasdots = 1;
                break;
            }
        }

        /* print Sketch table */
#ifdef ANALYTIC_SKETCH
//$$$        printf("at SKEND: hasdots=%d\n", hasdots);
//$$$        printf("iseg    itype ibrch      x          y          z            u          v          w\n");
//$$$        printf("base                  %10.5f %10.5f %10.5f   %10.5f %10.5f %10.5f\n",
//$$$               sket->xbase, sket->ybase, sket->zbase,
//$$$               sket->ubase, sket->vbase, sket->wbase);
//$$$        for (iseg = 0; iseg < sket->nseg; iseg++) {
//$$$            printf("%5d   %5d %5d   %10.5f %10.5f %10.5f   %10.5f %10.5f %10.5f\n",
//$$$                   iseg, sket->itype[iseg], sket->ibrch[iseg],
//$$$                   sket->x[iseg], sket->y[iseg], sket->z[iseg],
//$$$                   sket->u[iseg], sket->v[iseg], sket->w[iseg]);
//$$$        }
#endif

        /* if we have only one Sketch segment, then we are creating a OCSM_NODE_BODY */
        if ((sket->nseg) == 2) {

            /* close the Sketch */
            sket->type   = 0;
            sket->size   = 0;
            sket->solved = 1;
            sket->nseg   = 0;
            sket->nvar   = 0;
            sket->ncon   = 0;

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                stack[(*nstack)++] = MODL->nbody;
                status = SUCCESS;
                goto cleanup;
            }

            /* create the Body */
            status = newBody(MODL, ibrch, OCSM_SKEND, -1, -1,
                             args, hasdots, OCSM_NODE_BODY, &ibody);
            CHECK_STATUS(newBody);

            if (sket->irel == 0) {
                pts[0] = sket->x[0];
                pts[1] = sket->y[0];
                pts[2] = sket->z[0];
            } else {
                pts[0] = sket->xbase;
                pts[1] = sket->ybase;
                pts[2] = sket->zbase;
            }

            /* OCSM_NODE_BODY is actually a degenerate WireBody */
            status = EG_makeTopology(MODL->context, NULL, NODE, 0, pts, 0, NULL, NULL, &enode);
            CHECK_STATUS(EG_makeTopology);

            tdata[0] = 0;
            tdata[1] = 1;
            sense[0] = SFORWARD;
            status = EG_makeTopology(MODL->context, NULL, EDGE, DEGENERATE, tdata, 1, &enode, sense, &eedge);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED, NULL, 1, &eedge, sense, &eloop);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);

            MODL->body[ibody].ebody = ebody;

            /* update @-parameters (SKEND: point) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            SPRINT1(1, "                          Body   %4d created", ibody);

        /* we have more than one Sketch segment */
        } else {

            /* recycle old Body if not dirty */
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                status = EG_attributeRet(MODL->body[MODL->nbody].ebody, "__sket:signal__",
                                         &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
                if (status == SUCCESS) {
                    sket->signal = tempIlist[0];

                    /* return a signal if underconstrained, overconstrained, or not_converged */
                    if        (sket->signal == OCSM_UNDERCONSTRAINED) {
                        signalError(MODL, sket->signal,
                                    "initial values used since sketch is underconstrained");
                    } else if (sket->signal == OCSM_OVERCONSTRAINED) {
                        signalError(MODL, sket->signal,
                                    "initial values used since sketch is overconstrained");
                    } else if (sket->signal == OCSM_NOT_CONVERGED) {
                        signalError(MODL, sket->signal,
                                    "initial values used since sketch did not converge");
                    }
                }

                stack[(*nstack)++] = MODL->nbody;

                /* remove ::x[], ::y[], ::z[], and ::d[] if they were generated by a skvar statement */
                if (sket->nvar > 0) {
                    status = delPmtrByName(MODL, "::d");
                    if (status != OCSM_NAME_NOT_FOUND) {
                        CHECK_STATUS(delPmtrByName);
                    }

                    status = delPmtrByName(MODL, "::z");
                    if (status != OCSM_NAME_NOT_FOUND) {
                        CHECK_STATUS(delPmtrByName);
                    }

                    status = delPmtrByName(MODL, "::y");
                    if (status != OCSM_NAME_NOT_FOUND) {
                        CHECK_STATUS(delPmtrByName);
                    }

                    status = delPmtrByName(MODL, "::x");
                    if (status != OCSM_NAME_NOT_FOUND) {
                        CHECK_STATUS(delPmtrByName);
                    }
                }

                /* close the Sketch */
                sket->type   = 0;
                sket->size   = 0;
                sket->solved = 1;
                sket->nseg   = 0;
                sket->nvar   = 0;
                sket->ncon   = 0;

                goto cleanup;
            }

            /* find the extrema of the Sketch points (but not SSLOPE statements) */
            xmin = sket->x[0];
            xmax = sket->x[0];
            ymin = sket->y[0];
            ymax = sket->y[0];
            zmin = sket->z[0];
            zmax = sket->z[0];
            SPRINT5(2, "skpnt[%3d] %10s %10.5f %10.5f %10.5f",
                    0, ocsmGetText(sket->itype[0]), sket->x[0], sket->y[0], sket->z[0]);

            for (iseg = 1; iseg < sket->nseg; iseg++) {
                if (sket->itype[iseg] != OCSM_SSLOPE) {
                    if (sket->x[iseg] < xmin) xmin = sket->x[iseg];
                    if (sket->x[iseg] > xmax) xmax = sket->x[iseg];
                    if (sket->y[iseg] < ymin) ymin = sket->y[iseg];
                    if (sket->y[iseg] > ymax) ymax = sket->y[iseg];
                    if (sket->z[iseg] < zmin) zmin = sket->z[iseg];
                    if (sket->z[iseg] > zmax) zmax = sket->z[iseg];
                }

                SPRINT5(2, "skpnt[%3d] %10s %10.5f %10.5f %10.5f",
                        iseg, ocsmGetText(sket->itype[iseg]), sket->x[iseg], sket->y[iseg], sket->z[iseg]);
            }
            SPRINT6(2, "xmin=%f, xmax=%f, ymin=%f, ymax=%f, zmin=%f, zmax=%f", xmin, xmax, ymin, ymax, zmin, zmax);

            /* determine if the Sketch is open or closed */
            if (sket->itype[sket->nseg-2] != OCSM_SSLOPE) {
                if (fabs(sket->x[sket->nseg-2]-sket->x[0]) < EPS06 &&
                    fabs(sket->y[sket->nseg-2]-sket->y[0]) < EPS06 &&
                    fabs(sket->z[sket->nseg-2]-sket->z[0]) < EPS06   ) {
                    iopen = 0;
                } else {
                    iopen = 1;
                }
            } else {
                if (fabs(sket->x[sket->nseg-3]-sket->x[0]) < EPS06 &&
                    fabs(sket->y[sket->nseg-3]-sket->y[0]) < EPS06 &&
                    fabs(sket->z[sket->nseg-3]-sket->z[0]) < EPS06   ) {
                    iopen = 0;
                } else {
                    iopen = 1;
                }
            }
            SPRINT1(2, "iopen=%d", iopen);

            /* find the approximate area of the Sketch to determine
               if it has been generated counter-clockwise or clockwise */
            areax = 0;
            areay = 0;
            areaz = 0;
            for (iseg = 2; iseg < sket->nseg; iseg++) {
                areax += ( (sket->y[iseg-1]-sket->y[0]) * (sket->z[iseg  ]-sket->z[0])
                         - (sket->y[iseg  ]-sket->y[0]) * (sket->z[iseg-1]-sket->z[0]));
                areay += ( (sket->z[iseg-1]-sket->z[0]) * (sket->x[iseg  ]-sket->x[0])
                         - (sket->z[iseg  ]-sket->z[0]) * (sket->x[iseg-1]-sket->x[0]));
                areaz += ( (sket->x[iseg-1]-sket->x[0]) * (sket->y[iseg  ]-sket->y[0])
                         - (sket->x[iseg  ]-sket->x[0]) * (sket->y[iseg-1]-sket->y[0]));
            }

            area = areax / MAX(xmax-xmin, EPS06)
                 + areay / MAX(ymax-ymin, EPS06)
                 + areaz / MAX(zmax-zmin, EPS06);

            if (iopen == 0 && area < 0) {
                SPRINT0(1,"WARNING:: Sketch is defined clockwise.  flipping direction");
                (MODL->nwarn)++;

                /* flip all the interior Branches (between SKBEG and SKEND) */
                jseg = sket->nseg - 2;
                for (iseg = 1; iseg < sket->nseg; iseg++) {
                    if (iseg >= jseg) break;

                    iswap             = sket->itype[iseg];
                    sket->itype[iseg] = sket->itype[jseg];
                    sket->itype[jseg] = iswap;

                    iswap             = sket->ibrch[iseg];
                    sket->ibrch[iseg] = sket->ibrch[jseg];
                    sket->ibrch[jseg] = iswap;

                    jseg--;
                }

                /* flip the coordinates (but shift by one since
                   coordinates are at the end of each segment */
                jseg = sket->nseg - 2;
                for (iseg = 0; iseg < sket->nseg; iseg++) {
                    if (iseg >= jseg) break;

                    swap          = sket->x[iseg];
                    sket->x[iseg] = sket->x[jseg];
                    sket->x[jseg] = swap;

                    swap          = sket->y[iseg];
                    sket->y[iseg] = sket->y[jseg];
                    sket->y[jseg] = swap;

                    swap          = sket->z[iseg];
                    sket->z[iseg] = sket->z[jseg];
                    sket->z[jseg] = swap;

                    swap          = sket->u[iseg];
                    sket->u[iseg] = sket->u[jseg];
                    sket->u[jseg] = swap;

                    swap          = sket->v[iseg];
                    sket->v[iseg] = sket->v[jseg];
                    sket->v[jseg] = swap;

                    swap          = sket->w[iseg];
                    sket->w[iseg] = sket->w[jseg];
                    sket->w[jseg] = swap;

                    jseg--;
                }

                for (iseg = 0; iseg < sket->nseg; iseg++) {
                    SPRINT5(2, "skpnt[%3d] %10s %10.5f %10.5f %10.5f",
                            iseg, ocsmGetText(sket->itype[iseg]), sket->x[iseg], sket->y[iseg], sket->z[iseg]);
                }

                /* swap the coorindates of any SSLOPE and the one before it
                   (since the SSLOPE comes before the first SPLINE and/or
                   after the Branch following the last SPLINE.  also
                   switch the direction of the SSLOPE arguments since
                   the Sketch now goes in the other direction */
                for (iseg = 1; iseg < sket->nseg; iseg++) {
                    if (sket->itype[iseg] == OCSM_SSLOPE) {
                        jseg = iseg - 1;

                        swap          = sket->x[jseg];
                        sket->x[jseg] = sket->x[iseg];
                        sket->x[iseg] = -swap;

                        swap          = sket->y[jseg];
                        sket->y[jseg] = sket->y[iseg];
                        sket->y[iseg] = -swap;

                        swap          = sket->z[jseg];
                        sket->z[jseg] = sket->z[iseg];
                        sket->z[iseg] = -swap;

                        swap          = sket->u[jseg];
                        sket->u[jseg] = sket->u[iseg];
                        sket->u[iseg] = -swap;

                        swap          = sket->v[jseg];
                        sket->v[jseg] = sket->v[iseg];
                        sket->v[iseg] = -swap;

                        swap          = sket->w[jseg];
                        sket->w[jseg] = sket->w[iseg];
                        sket->w[iseg] = -swap;
                    }
                }

                for (iseg = 0; iseg < sket->nseg; iseg++) {
                    SPRINT5(2, "skpnt[%3d] %10s %10.5f %10.5f %10.5f",
                            iseg, ocsmGetText(sket->itype[iseg]), sket->x[iseg], sket->y[iseg], sket->z[iseg]);
                }
            }

            /* start creating the Sketch */
            nedge  = 0;

            /* no points in spline or bezier so far */
            nspln =  0;
            nbezr =  0;

            /* no SSLOPE statements so far */
            begcond = NULL;
            endcond = NULL;

            /* create the beginning Node */
            pts[0] = sket->x[0];
            pts[1] = sket->y[0];
            pts[2] = sket->z[0];
            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                     pts, 0, NULL, NULL, &(Enodes[nedge]));
            CHECK_STATUS(EG_makeTopology);

#ifdef ANALYTIC_SKETCH
//$$$            if (hasdots > 0) {
//$$$                pts_dot[0] = sket->u[0];
//$$$                pts_dot[1] = sket->v[0];
//$$$                pts_dot[2] = sket->w[0];
//$$$
//$$$                status = EG_setGeometry_dot(Enodes[0], NODE, 0, NULL, pts, pts_dot);
//$$$                CHECK_STATUS(EG_setGeometry_dot);
//$$$            }
#endif

            /* save "last" point */
            xlast = sket->x[0];
            ylast = sket->y[0];
            zlast = sket->z[0];
            ulast = sket->u[0];
            vlast = sket->v[0];
            wlast = sket->w[0];

            /* add the lines, circular-arcs, splines, and beziers to the Sketch plane */
            for (iseg = 1; iseg < sket->nseg; iseg++) {

                /* if we are not defining a spline but the new segment is
                   a sslope, remember it now */
                if (nspln == 0 && sket->itype[iseg] == OCSM_SSLOPE) {
                    begslope[0] = sket->x[iseg];
                    begslope[1] = sket->y[iseg];
                    begslope[2] = sket->z[iseg];
                    begcond     = begslope;

                /* if we were defining a spline but the new segment is not
                   a spline, generate the spline now */
                } else if (nspln > 0 && sket->itype[iseg] != OCSM_SPLINE) {

                    /* if the new segment is a sslope, remember it now */
                    if (sket->itype[iseg] == OCSM_SSLOPE) {
                        endslope[0] = sket->x[iseg];
                        endslope[1] = sket->y[iseg];
                        endslope[2] = sket->z[iseg];
                        endcond     = endslope;
                    }

                    SPRINT1(2, "spline (w/%d points):", nspln);
                    if (begcond != NULL) {
                        SPRINT3(2, "  slp %11.5f %11.5f %11.5f", begcond[0], begcond[1], begcond[2]);
                    }
                    for (n = 0; n < nspln; n++) {
                        SPRINT4(2, "%5d %11.5f %11.5f %11.5f",   n, pts[3*n], pts[3*n+1], pts[3*n+2]);
                    }
                    if (endcond != NULL) {
                        SPRINT3(2, "  slp %11.5f %11.5f %11.5f", endcond[0], endcond[1], endcond[2]);
                    }

                    data[0] = pts[3*nspln-3];
                    data[1] = pts[3*nspln-2];
                    data[2] = pts[3*nspln-1];

                    /* create a new Node if not same as first */
                    if (fabs(data[0]-sket->x[0]) > EPS06 ||
                        fabs(data[1]-sket->y[0]) > EPS06 ||
                        fabs(data[2]-sket->z[0]) > EPS06   ) {
                        status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                                 data, 0, NULL, NULL, &(Enodes[nedge+1]));
                        CHECK_STATUS(EG_makeTopology);
                    } else {
                        Enodes[nedge+1] = Enodes[0];
                    }

                    header[0] = nspln;
                    header[1] = 0;

                    if (nspln > 2 || begcond != NULL || endcond != NULL)  {
                        status = EG_spline1dTan(header[0], begcond, pts, endcond, NULL, EPS06, ivec, &rvec);
                        if (status < EGADS_SUCCESS) {
                            signalError(MODL, OCSM_DID_NOT_CREATE_BODY,
                                    "problem generating SPLINE with SSLOPE");
                            SET_STATUS(OCSM_DID_NOT_CREATE_BODY, sslope);
                        }

                        status = EG_makeGeometry(MODL->context, CURVE, BSPLINE, NULL, ivec, rvec, &ecurve);
                        CHECK_STATUS(EG_makeGeometry);

                        EG_free(rvec);

                        tdata[0] = 0;
                        tdata[1] = 1;
                    } else {
                        pts[3] -= pts[0];
                        pts[4] -= pts[1];
                        pts[5] -= pts[2];

                        status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, pts, &ecurve);
                        CHECK_STATUS(EG_makeGeometry);

                        tdata[0] = 0;
                        tdata[1] = sqrt(pts[3]*pts[3] + pts[4]*pts[4] + pts[5]-pts[5]);
                    }

#if SHOW_SPLINES
                    if (1) {
                        int    io_kbd=5, io_scr=6, indgr=1+4+16+64;
                        int    nline=9, ilin[9], isym[9], nper[9];
                        float  xplot[9000], yplot[9000];
                        double uu, xyz3[9];

                        for (i = 0; i < nline; i++) {
                            ilin[i] = +i;
                            isym[i] = -i;
                            nper[i] = 1000;
                        }

                        for (i = 0; i < 1000; i++) {
                            uu = tdata[0] + (double)i/999 * (tdata[1] - tdata[0]);

                            EG_evaluate(ecurve, &uu, xyz3);

                            xplot[      i] = uu;   yplot[      i] = xyz3[0];   //   x
                            xplot[ 1000+i] = uu;   yplot[ 1000+i] = xyz3[1];   //   y
                            xplot[ 2000+i] = uu;   yplot[ 2000+i] = xyz3[2];   //   z
                            xplot[ 3000+i] = uu;   yplot[ 3000+i] = xyz3[3];   //  dx/du
                            xplot[ 4000+i] = uu;   yplot[ 4000+i] = xyz3[4];   //  dy/du
                            xplot[ 5000+i] = uu;   yplot[ 5000+i] = xyz3[5];   //  dz/du
                            xplot[ 6000+i] = uu;   yplot[ 6000+i] = xyz3[6];   // d2x/du2
                            xplot[ 7000+i] = uu;   yplot[ 7000+i] = xyz3[7];   // d2y/du2
                            xplot[ 8000+i] = uu;   yplot[ 8000+i] = xyz3[8];   // d2z/du2
                        }

                        grinit_(&io_kbd, &io_scr, "generation of spline in ocsmBuild",
                                           STRLEN("generation of spline in ocsmBuild"));
                        grline_(ilin, isym, &nline,                "~x~y~spline data",
                                &indgr, xplot, yplot, nper, STRLEN("~x~y~spline data"));
                    }
#endif

                    if (Enodes[nedge+1] == Enodes[nedge]) {
                        status = EG_makeTopology(MODL->context, ecurve, EDGE, ONENODE,
                                                 tdata, 1, &(Enodes[nedge]), NULL, &(Eedges[nedge]));
                        CHECK_STATUS(EG_makeTopology);
                    } else {
                        status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                                 tdata, 2, &(Enodes[nedge]), NULL, &(Eedges[nedge]));
                        CHECK_STATUS(EG_makeTopology);
                    }

                    /* add Branch attributes (spline and sslope) */
                    i = iseg - 1;    // iseg is not an OCSM_SSLOPE or OCSM_SPLINE
                    while (i >= 0) {
                        if (MODL->brch[sket->ibrch[i]].type == OCSM_SSLOPE ||
                            MODL->brch[sket->ibrch[i]].type == OCSM_SPLINE   ) {
                            i--;
                        } else {
                            i++;
                            break;
                        }
                    }

                    while (i <= iseg) {
                        if (i == iseg && MODL->brch[sket->ibrch[i]].type != OCSM_SSLOPE) break;

                        status = setEgoAttribute(MODL, sket->ibrch[i], Eedges[nedge]);
                        CHECK_STATUS(setEgoAttribute);
                        i++;
                    }

                    nedge++;

                    /* reset the spline */
                    nspln   = 0;
                    begcond = NULL;
                    endcond = NULL;

                    xlast = sket->x[iseg-1];
                    ylast = sket->y[iseg-1];
                    zlast = sket->z[iseg-1];
                    ulast = sket->u[iseg-1];
                    vlast = sket->v[iseg-1];
                    wlast = sket->w[iseg-1];

                    /* if not sslope, we need to go back so that we can
                       generate the new segment */
                    if (sket->itype[iseg] != OCSM_SSLOPE) {
                        iseg--;
                    }

                /* if we were defining a bezier but the new segment is not
                   a bezier, generate the bezier now */
                } else if (nbezr > 0 && sket->itype[iseg] != OCSM_BEZIER) {
                    if (nbezr < 2) {
                        signalError(MODL, OCSM_TOO_FEW_SPLINE_POINTS,
                                    "BEZIER requires at least 2 Sketch points");
                        SET_STATUS(OCSM_TOO_FEW_SPLINE_POINTS, skend);
                    }

                    SPRINT1(2, "bezier (w/%d points):", nbezr);
                    for (n = 0; n < nbezr; n++) {
                        SPRINT4(2, "%5d %11.5f %11.5f %11.5f",   n, pts[3*n], pts[3*n+1], pts[3*n+2]);
                    }

                    data[0] = pts[3*nbezr-3];
                    data[1] = pts[3*nbezr-2];
                    data[2] = pts[3*nbezr-1];

                    /* create a new Node if not same as first */
                    if (fabs(data[0]-sket->x[0]) > EPS06 ||
                        fabs(data[1]-sket->y[0]) > EPS06 ||
                        fabs(data[2]-sket->z[0]) > EPS06   ) {
                        status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                                 data, 0, NULL, NULL, &(Enodes[nedge+1]));
                        CHECK_STATUS(EG_makeTopology);
                    } else {
                        Enodes[nedge+1] = Enodes[0];
                    }

                    header[0] = 0;
                    header[1] = nbezr - 1;
                    header[2] = nbezr;

                    /* make the BEZIER */
                    status = EG_makeGeometry(MODL->context, CURVE, BEZIER, NULL, header, pts, &ecurve);
                    CHECK_STATUS(EG_makeGeometry);

                    status = EG_getRange(ecurve, tdata, &periodic);
                    CHECK_STATUS(EG_getRange);

                    if (Enodes[nedge+1] == Enodes[nedge]) {
                        status = EG_makeTopology(MODL->context, ecurve, EDGE, ONENODE,
                                                 tdata, 1, &(Enodes[nedge]), NULL, &(Eedges[nedge]));
                        CHECK_STATUS(EG_makeTopology);
                    } else {
                        status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                                 tdata, 2, &(Enodes[nedge]), NULL, &(Eedges[nedge]));
                        CHECK_STATUS(EG_makeTopology);
                    }

                    /* add Branch attributes (bezier) */
                    i = iseg - 1;       // iseg is not an OCSM_BEZIER
                    while (i >= 0) {
                        if (MODL->brch[sket->ibrch[i]].type == OCSM_BEZIER) {
                            i--;
                        } else {
                            i++;
                            break;
                        }
                    }

                    while (i < iseg) {
                        status = setEgoAttribute(MODL, sket->ibrch[i], Eedges[nedge]);
                        CHECK_STATUS(setEgoAttribute);
                        i++;
                    }

                    nedge++;

                    nbezr = 0;

                    xlast = sket->x[iseg-1];
                    ylast = sket->y[iseg-1];
                    zlast = sket->z[iseg-1];
                    ulast = sket->u[iseg-1];
                    vlast = sket->v[iseg-1];
                    wlast = sket->w[iseg-1];

                    iseg--;

                /* if the new segment is a skend, stop now */
                } else if (sket->itype[iseg] == OCSM_SKEND) {
                    break;

                /* add a linseg */
                } else if (sket->itype[iseg] == OCSM_LINSEG) {
                    if (fabs(xlast-sket->x[iseg]) < EPS06 &&
                        fabs(ylast-sket->y[iseg]) < EPS06 &&
                        fabs(zlast-sket->z[iseg]) < EPS06   ) {
                        SPRINT0(2, "skipped (zero length linseg)");
                    } else {
                        SPRINT0(2, "linseg:");
                        SPRINT4(2, "%5d %11.5f %11.5f %11.5f", 0,    xlast,         ylast,         zlast        );
                        SPRINT4(2, "%5d %11.5f %11.5f %11.5f", iseg, sket->x[iseg], sket->y[iseg], sket->z[iseg]);

                        pts[0] = sket->x[iseg];
                        pts[1] = sket->y[iseg];
                        pts[2] = sket->z[iseg];

                        if (fabs(pts[0]-sket->x[0]) > EPS06 ||
                            fabs(pts[1]-sket->y[0]) > EPS06 ||
                            fabs(pts[2]-sket->z[0]) > EPS06   ) {
                            status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                                     pts, 0, NULL, NULL, &(Enodes[nedge+1]));
                            CHECK_STATUS(EG_makeTopology);

#ifdef ANALYTIC_SKETCH
//$$$                            if (hasdots > 0) {
//$$$                                pts_dot[0] = sket->u[iseg];
//$$$                                pts_dot[1] = sket->v[iseg];
//$$$                                pts_dot[2] = sket->w[iseg];
//$$$
//$$$                                status = EG_setGeometry_dot(Enodes[nedge+1], NODE, 0, NULL, pts, pts_dot);
//$$$                                CHECK_STATUS(EG_setGeometry_dot);
//$$$                            }
#endif

                        } else {
                            Enodes[nedge+1] = Enodes[0];
                        }

                        pts[0] = xlast;
                        pts[1] = ylast;
                        pts[2] = zlast;
                        pts[3] = sket->x[iseg] - xlast;
                        pts[4] = sket->y[iseg] - ylast;
                        pts[5] = sket->z[iseg] - zlast;
                        status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, pts, &ecurve);
                        CHECK_STATUS(EG_makeGeometry);

#ifdef ANALYTIC_SKETCH
//$$$                        if (hasdots > 0) {
//$$$                            pts_dot[0] = ulast;
//$$$                            pts_dot[1] = vlast;
//$$$                            pts_dot[2] = wlast;
//$$$                            pts_dot[3] = sket->u[iseg] - ulast;
//$$$                            pts_dot[4] = sket->v[iseg] - vlast;
//$$$                            pts_dot[5] = sket->w[iseg] - wlast;
//$$$
//$$$                            status = EG_setGeometry_dot(ecurve, CURVE, LINE, NULL, pts, pts_dot);
//$$$                            CHECK_STATUS(EG_setGeometry_dot);
//$$$                        }
#endif

                        tdata[0] = 0;
                        tdata[1] = sqrt(pts[3]*pts[3] + pts[4]*pts[4] + pts[5]*pts[5]);

                        if (Enodes[nedge+1] == Enodes[nedge]) {
                            status = EG_makeTopology(MODL->context, ecurve, EDGE, ONENODE,
                                                     tdata, 1, &(Enodes[nedge]), NULL, &(Eedges[nedge]));
                            CHECK_STATUS(EG_makeTopology);
                        } else {
                            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                                     tdata, 2, &(Enodes[nedge]), NULL, &(Eedges[nedge]));
                            CHECK_STATUS(EG_makeTopology);
                        }

                        /* add Branch attributes (linseg) */
                        status = setEgoAttribute(MODL, sket->ibrch[iseg], Eedges[nedge]);
                        CHECK_STATUS(setEgoAttribute);

                        nedge++;

#ifdef ANALYTIC_SKETCH
//$$$                        if (hasdots > 0) {
//$$$                            tdata_dot[0] = 0;
//$$$                            tdata_dot[1] = (pts[3]*pts_dot[3] + pts[4]*pts_dot[4] + pts[5]*pts_dot[5]) / tdata[1];
//$$$
//$$$                            status = EG_setRange_dot(Eedges[nedge], EDGE, tdata, tdata_dot);
//$$$                            CHECK_STATUS(EG_setRange_dot);
//$$$                        }
#endif
                    }

                    xlast = sket->x[iseg];
                    ylast = sket->y[iseg];
                    zlast = sket->z[iseg];
                    ulast = sket->u[iseg];
                    vlast = sket->v[iseg];
                    wlast = sket->w[iseg];

                /* add a cirarc */
                } else if (sket->itype[iseg] == OCSM_CIRARC) {
                    SPRINT0(2, "cirarc:");
                    SPRINT4(2, "%5d %11.5f %11.5f %11.5f", 0,      xlast,           ylast,           zlast          );
                    SPRINT4(2, "%5d %11.5f %11.5f %11.5f", iseg,   sket->x[iseg  ], sket->y[iseg  ], sket->z[iseg  ]);
                    SPRINT4(2, "%5d %11.5f %11.5f %11.5f", iseg+1, sket->x[iseg+1], sket->y[iseg+1], sket->z[iseg+1]);

                    pts[0] = sket->x[iseg+1];
                    pts[1] = sket->y[iseg+1];
                    pts[2] = sket->z[iseg+1];

                    if (fabs(pts[0]-sket->x[0]) > EPS06 ||
                        fabs(pts[1]-sket->y[0]) > EPS06 ||
                        fabs(pts[2]-sket->z[0]) > EPS06   ) {
                        status = EG_makeTopology(MODL->context, NULL, NODE, 0,
                                                 pts, 0, NULL, NULL, &(Enodes[nedge+1]));
                        CHECK_STATUS(EG_makeTopology);
                    } else {
                        Enodes[nedge+1] = Enodes[0];
                    }

                    if (sket->itype[iseg] == OCSM_SSLOPE) {
                        scent = 0;
                    } else if (fabs(xlast-sket->x[iseg]) < EPS06 && fabs(xlast-sket->x[iseg+1]) < EPS06) {
                        scent = ((sket->y[iseg+1] - ylast        ) * (sket->y[iseg  ] - sket->y[iseg+1])
                                -(sket->z[iseg+1] - zlast        ) * (sket->z[iseg+1] - sket->z[iseg  ]))
                               /((zlast           - sket->z[iseg]) * (sket->y[iseg  ] - sket->y[iseg+1])
                               - (sket->y[iseg]   - ylast        ) * (sket->z[iseg+1] - sket->z[iseg  ]));
                        ycent = (ylast + sket->y[iseg] + scent * (zlast         - sket->z[iseg])) / 2;
                        zcent = (zlast + sket->z[iseg] + scent * (sket->y[iseg] - ylast        )) / 2;

                        data[0] = xlast;
                        data[1] = ycent;
                        data[2] = zcent;
                        data[3] = 0;
                        data[4] = ylast - ycent;
                        data[5] = zlast - zcent;
                        data[6] = 0;
                        data[7] = -data[5];
                        data[8] = +data[4];
                        data[9] = sqrt(SQR(ylast-ycent) + SQR(zlast-zcent));

                    } else if (fabs(ylast-sket->y[iseg]) < EPS06 && fabs(ylast-sket->y[iseg+1]) < EPS06) {
                        scent = ((sket->z[iseg+1] - zlast        ) * (sket->z[iseg  ] - sket->z[iseg+1])
                                -(sket->x[iseg+1] - xlast        ) * (sket->x[iseg+1] - sket->x[iseg  ]))
                               /((xlast           - sket->x[iseg]) * (sket->z[iseg  ] - sket->z[iseg+1])
                               - (sket->z[iseg]   - zlast        ) * (sket->x[iseg+1] - sket->x[iseg  ]));
                        zcent = (zlast + sket->z[iseg] + scent * (xlast         - sket->x[iseg])) / 2;
                        xcent = (xlast + sket->x[iseg] + scent * (sket->z[iseg] - zlast        )) / 2;

                        data[0] = xcent;
                        data[1] = ylast;
                        data[2] = zcent;
                        data[3] = xlast - xcent;
                        data[4] = 0;
                        data[5] = zlast - zcent;
                        data[6] = +data[5];
                        data[7] = 0;
                        data[8] = -data[3];
                        data[9] = sqrt(SQR(zlast-zcent) + SQR(xlast-xcent));

                    } else if (fabs(zlast-sket->z[iseg]) < EPS06 && fabs(zlast-sket->z[iseg+1]) < EPS06) {
                        scent = ((sket->x[iseg+1] - xlast        ) * (sket->x[iseg  ] - sket->x[iseg+1])
                                -(sket->y[iseg+1] - ylast        ) * (sket->y[iseg+1] - sket->y[iseg  ]))
                               /((ylast           - sket->y[iseg]) * (sket->x[iseg  ] - sket->x[iseg+1])
                               - (sket->x[iseg]   - xlast        ) * (sket->y[iseg+1] - sket->y[iseg  ]));
                        xcent = (xlast + sket->x[iseg] + scent * (ylast         - sket->y[iseg])) / 2;
                        ycent = (ylast + sket->y[iseg] + scent * (sket->x[iseg] - xlast        )) / 2;

                        data[0] = xcent;
                        data[1] = ycent;
                        data[2] = zlast;
                        data[3] = xlast - xcent;
                        data[4] = ylast - ycent;
                        data[5] = 0;
                        data[6] = -data[4];
                        data[7] = +data[3];
                        data[8] = 0;
                        data[9] = sqrt(SQR(xlast-xcent) + SQR(ylast-ycent));

                    } else {
                        signalError(MODL, OCSM_NON_COPLANAR_SKETCH_POINTS,
                                    "Sketch points must be coplanar");
                        SET_STATUS(OCSM_NON_COPLANAR_SKETCH_POINTS, skend);
                    }

                    if (scent > 0) {
                        status = EG_makeGeometry(MODL->context, CURVE, CIRCLE, NULL, NULL, data, &ecurve);
                        CHECK_STATUS(EG_makeGeometry);
                    } else {
                        status = EG_makeGeometry(MODL->context, CURVE, CIRCLE, NULL, NULL, data, &eflip);
                        CHECK_STATUS(EG_makeGeometry);

                        status = EG_flipObject(eflip, &ecurve);
                        CHECK_STATUS(EG_flipObject);
                    }

                    data[0] = xlast;
                    data[1] = ylast;
                    data[2] = zlast;

                    status = EG_invEvaluate(ecurve, data, &(tdata[0]), result);
                    CHECK_STATUS(EG_invEvaluate);

                    data[0] = sket->x[iseg+1];
                    data[1] = sket->y[iseg+1];
                    data[2] = sket->z[iseg+1];

                    status = EG_invEvaluate(ecurve, data, &(tdata[1]), result);
                    CHECK_STATUS(EG_invEvaluate);

                    while (tdata[1] < tdata[0]) {
                        tdata[1] += TWOPI;
                    }

                    status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                             tdata, 2, &(Enodes[nedge]), NULL, &(Eedges[nedge]));
                    CHECK_STATUS(EG_makeTopology);

                    /* add Branch attributes (cirarc and arc) */
                    status = setEgoAttribute(MODL, sket->ibrch[iseg], Eedges[nedge]);
                    CHECK_STATUS(setEgoAttribute);

                    nedge++;

                    iseg++;   /* this is because cirarc show up in pairs in iskpnt */

                    xlast = sket->x[iseg];
                    ylast = sket->y[iseg];
                    zlast = sket->z[iseg];
                    ulast = sket->u[iseg];
                    vlast = sket->v[iseg];
                    wlast = sket->w[iseg];

                /* initialize or add points to a spline (to be processed above in future
                   trip through this for loop) */
                } else if (sket->itype[iseg] == OCSM_SPLINE) {
                    if (nspln == 0) {
                        pts[0] = xlast;
                        pts[1] = ylast;
                        pts[2] = zlast;

                        nspln = 1;
                    }

                    pts[3*nspln  ] = sket->x[iseg];
                    pts[3*nspln+1] = sket->y[iseg];
                    pts[3*nspln+2] = sket->z[iseg];

                    nspln++;

                /* initialize or add points to a bezier (to be processed above in future
                   trip through this for loop) */
                } else if (sket->itype[iseg] == OCSM_BEZIER) {
                    if (nbezr == 0) {
                        pts[0] = xlast;
                        pts[1] = ylast;
                        pts[2] = zlast;

                        nbezr = 1;
                    }

                    pts[3*nbezr  ] = sket->x[iseg];
                    pts[3*nbezr+1] = sket->y[iseg];
                    pts[3*nbezr+2] = sket->z[iseg];

                    nbezr++;
                }
            }

            /* close the Sketch */
            for (iseg = 0; iseg < nedge; iseg++) {
                sense[iseg] = SFORWARD;
            }

            if (wireonly == 1 || iopen == 1) {
                if (iopen == 1) {
                    status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,
                                             NULL, nedge, Eedges, sense, &eloop);
                    CHECK_STATUS(EG_makeTopology);
                } else {
                    status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED,
                                             NULL, nedge, Eedges, sense, &eloop);
                    CHECK_STATUS(EG_makeTopology);
                }

                status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                         NULL, 1, &eloop, NULL, &ebody);
                CHECK_STATUS(EG_makeTopology);
            } else {
                status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED,
                                         NULL, nedge, Eedges, sense, &eloop);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeFace(eloop, SFORWARD, NULL, Efaces);

                /* if a geometry error, then either non-coplanar of self-intersecting */
                if (status == EGADS_GEOMERR) {
                    if (fabs(xmax-xmin) > EPS06 &&
                        fabs(ymax-ymin) > EPS06 &&
                        fabs(zmax-zmin) > EPS06   ) {
                        signalError(MODL, OCSM_NON_COPLANAR_SKETCH_POINTS,
                                    "Sketch points must be coplanar");
                        SET_STATUS(OCSM_NON_COPLANAR_SKETCH_POINTS, skend);
                    } else {
                        signalError(MODL, OCSM_SELF_INTERSECTING,
                                    "Self-intersection detected in Sketch");
                        SET_STATUS(OCSM_SELF_INTERSECTING, skend);
                    }
                }
                CHECK_STATUS(EG_makeFace);

                status = EG_getRange(Efaces[0], range, &periodic);
                CHECK_STATUS(EG_getRange);

                range[0] = (range[0] + range[1]) / 2;
                range[1] = (range[2] + range[3]) / 2;

                status = EG_evaluate(Efaces[0], range, eval);
                CHECK_STATUS(EG_evaluate);

                norm[0] = eval[4] * eval[8] - eval[5] * eval[7];
                norm[1] = eval[5] * eval[6] - eval[3] * eval[8];
                norm[2] = eval[3] * eval[7] - eval[4] * eval[6];

                if        (fabs(norm[0]) >= fabs(norm[1]) &&
                           fabs(norm[0]) >= fabs(norm[2])   ) {
                    if (norm[0] < 0) {
                        status = EG_flipObject(Efaces[0], &enew);
                        CHECK_STATUS(EG_flipObject);
                        Efaces[0] = enew;
                    }
                } else if (fabs(norm[1]) >= fabs(norm[2]) &&
                           fabs(norm[1]) >= fabs(norm[0])   ) {
                    if (norm[1] < 0) {
                        status = EG_flipObject(Efaces[0], &enew);
                        CHECK_STATUS(EG_flipObject);
                        Efaces[0] = enew;
                    }
                } else {
                    if (norm[2] < 0) {
                        status = EG_flipObject(Efaces[0], &enew);
                        CHECK_STATUS(EG_flipObject);
                        Efaces[0] = enew;
                    }
                }

#ifdef ANALYTIC_SKETCH
//$$$                if (hasdots == 0) {
#endif
                    status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
                                             NULL, 1, Efaces, NULL, &ebody);
                    CHECK_STATUS(EG_makeTopology);
#ifdef ANALYTIC_SKETCH
//$$$                } else {
//$$$                    status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,
//$$$                                             NULL, 1, Efaces, NULL, &etemp);
//$$$                    CHECK_STATUS(EG_makeTopology);
//$$$                }
#endif
            }

#if SHOW_SPLINES
            if (1) {
                #define NPER          251
                #define MAX_PLOT_PTS 9999

                int    nplot, nline, ilin[MAX_SKETCH_SIZE+1], isym[MAX_SKETCH_SIZE+1], nper[MAX_SKETCH_SIZE+1];
                int    io_kbd=5, io_scr=6, indgr=1+2+4+16+64;
                float  xplot[MAX_PLOT_PTS], yplot[MAX_PLOT_PTS];
                char   pltitl[30], title[] = "Spline  (skbeg=^, linseg=+, cirarc=o, spline=x)";

                int    j, oclass, mtype, nchild, *senses;
                double trange[4], tt;
                ego    eref, *ebodys;

                if        (xmin == xmax) {
                    snprintf(pltitl, 30, "~y~z~Sketch at x=%10.5f", xmin);
                } else if (ymin == ymax) {
                    snprintf(pltitl, 30, "~z~x~Sketch at y=%10.5f", ymin);
                } else {
                    snprintf(pltitl, 30, "~x~y~Sketch at z=%10.5f", zmin);
                }

                /* put Sketch points onto plot */
                nline = 0;
                nplot = 0;
                for (i = 0; i < sket->nseg; i++) {
                    ilin[nline] = 0;
                    nper[nline] = 1;

                    if        (sket->itype[i] == OCSM_SKBEG) {
                        isym[nline] = GR_TRIANGLE;
                    } else if (sket->itype[i] == OCSM_LINSEG) {
                        isym[nline] = GR_PLUS;
                    } else if (sket->itype[i] == OCSM_CIRARC) {
                        isym[nline] = GR_CIRCLE;
                    } else if (sket->itype[i] == OCSM_SPLINE) {
                        isym[nline] = GR_X;
                    } else if (sket->itype[i] == OCSM_BEZIER) {
                        isym[nline] = GR_X;
                    }
                    nline++;

                    if        (xmin == xmax) {
                        xplot[nplot] = sket->y[i];
                        yplot[nplot] = sket->z[i];
                        nplot++;
                    } else if (ymin == ymax) {
                        xplot[nplot] = sket->z[i];
                        yplot[nplot] = sket->x[i];
                        nplot++;
                    } else {
                        xplot[nplot] = sket->x[i];
                        yplot[nplot] = sket->y[i];
                        nplot++;
                    }
                }

                /* put Sketch evaluations onto plot */
                status = EG_getTopology(eloop, &eref, &oclass, &mtype,
                                        data, &nchild, &ebodys, &senses);
                CHECK_STATUS(EG_getTopology);

                if (nplot+nchild*NPER > MAX_PLOT_PTS) {
                    signalError(MODL, OCSM_INTERNAL_ERROR,
                                "nplot=%d, nchild=%d, NPER=%d, MAX_PLOT_PTS=%d", nplot, nchild, NPER, MAX_PLOT_PTS);
                    SET_STATUS(OCSM_INTERNAL_ERROR, ShowSketch);
                }

                for (j = 0; j < nchild; j++) {
                    status = EG_getRange(ebodys[j], trange, &periodic);
                    CHECK_STATUS(EG_getRange);

                    for (i = 0; i < NPER; i++) {
                        tt = trange[0] + (double)(i) / (double)(NPER-1) * (trange[1] - trange[0]);

                        status = EG_evaluate(ebodys[j], &tt, data);
                        CHECK_STATUS(EG_evaluate);

                        if        (xmin == xmax) {
                            xplot[nplot] = data[1];
                            yplot[nplot] = data[2];
                            nplot++;
                        } else if (ymin == ymax) {
                            xplot[nplot] = data[2];
                            yplot[nplot] = data[0];
                            nplot++;
                        } else {
                            xplot[nplot] = data[0];
                            yplot[nplot] = data[1];
                            nplot++;
                        }
                    }

                    ilin[nline] =  +1;
                    isym[nline] =  -1;
                    nper[nline] = NPER;
                    nline++;
                }

                /* plot */
                grinit_(&io_kbd, &io_scr, title, STRLEN(title));
                grline_(ilin, isym, &nline, pltitl, &indgr, xplot, yplot, nper, STRLEN(pltitl));
            }
#endif // SHOW_SPLINES

            /* remove ::x[], ::y[], ::z[], and ::d[] if they were generated by a skvar statement */
            if (sket->nvar > 0) {
                status = delPmtrByName(MODL, "::d");
                if (status != OCSM_NAME_NOT_FOUND) {
                    CHECK_STATUS(delPmtrByName);
                }

                status = delPmtrByName(MODL, "::z");
                if (status != OCSM_NAME_NOT_FOUND) {
                    CHECK_STATUS(delPmtrByName);
                }

                status = delPmtrByName(MODL, "::y");
                if (status != OCSM_NAME_NOT_FOUND) {
                    CHECK_STATUS(delPmtrByName);
                }

                status = delPmtrByName(MODL, "::x");
                if (status != OCSM_NAME_NOT_FOUND) {
                    CHECK_STATUS(delPmtrByName);
                }
            }

            /* close the Sketch */
            sket->type   = 0;
            sket->size   = 0;
            sket->solved = 1;
            sket->nseg   = 0;
            sket->nvar   = 0;
            sket->ncon   = 0;

            /* make a new WireBody */
            if (iopen == 1 || wireonly == 1) {
                status = newBody(MODL, ibrch, OCSM_SKEND, MODL->nbody, -1,
                                 args, hasdots, OCSM_WIRE_BODY, &ibody);
                CHECK_STATUS(newBody);

            /* make a new SheetBody */
            } else {
                status = newBody(MODL, ibrch, OCSM_SKEND, MODL->nbody, -1,
                                 args, hasdots, OCSM_SHEET_BODY, &ibody);
                CHECK_STATUS(newBody);
            }

#ifdef ANALYTIC_SKETCH
//$$$            if (hasdots > 0) {
//$$$                printf("etemp:\n");
//$$$                ocsmPrintEgo(etemp);
//$$$                int iii;
//$$$                for (iii = 1; iii <= MODL->nbody; iii++) {
//$$$                    printf("ebody[%d]:\n", iii);
//$$$                    ocsmPrintEgo(MODL->body[iii].ebody);
//$$$                }
//$$$
//$$$                status = EG_copyGeometry_dot(etemp, NULL, NULL, MODL->body[ibody].ebody);
//$$$                CHECK_STATUS(EG_copyGeometry_dot);
//$$$
//$$$                EG_deleteObject(etemp);
//$$$            }
#endif

            /* if relative, translate body now */
            if (sket->irel == 1) {
                etemp = ebody;

                matrix[ 0] = 1; matrix[ 1] = 0; matrix[ 2] = 0; matrix[ 3] = sket->xbase;
                matrix[ 4] = 0; matrix[ 5] = 1; matrix[ 6] = 0; matrix[ 7] = sket->ybase;
                matrix[ 8] = 0; matrix[ 9] = 0; matrix[10] = 1; matrix[11] = sket->zbase;

                status = EG_makeTransform(MODL->context, matrix, &exform);
                CHECK_STATUS(EG_makeTransform);

                status = EG_copyObject(etemp, exform, &ebody);
                CHECK_STATUS(EG_copyObject);

#ifdef ANALYTIC_SKETCH
//$$$                if (hasdots > 0) {
//$$$                    matrix_dot[ 0] = 0; matrix_dot[ 1] = 0; matrix_dot[ 2] = 0; matrix_dot[ 3] = sket->ubase;
//$$$                    matrix_dot[ 4] = 0; matrix_dot[ 5] = 0; matrix_dot[ 6] = 0; matrix_dot[ 7] = sket->vbase;
//$$$                    matrix_dot[ 8] = 0; matrix_dot[ 9] = 0; matrix_dot[10] = 0; matrix_dot[11] = sket->wbase;
//$$$
//$$$                    status = EG_copyGeometry_dot(etemp, matrix, matrix_dot, ebody);
//$$$                    CHECK_STATUS(EG_copyGeometry_dot);
//$$$                }
#endif

                status = EG_deleteObject(etemp);
                CHECK_STATUS(EG_deleteObject);

                status = EG_deleteObject(exform);
                CHECK_STATUS(EG_deleteObject);
            }

            MODL->body[ibody].ebody = ebody;

            /* if there was a signal, save it on the Body so that we re-raise it
               when we recycle */
            if (sket->signal != 0) {
                status = EG_attributeAdd(ebody, "__sket:signal__", ATTRINT, 1,
                                         &(sket->signal), NULL, NULL);
                CHECK_STATUS(EG_attributeAdd);
            }

            /* print points around the Body */
#ifdef ANALYTIC_SKETCH
//$$$            if (hasdots > 0) {
//$$$                int nedges, iedge, npnt=11, ipnt, periodic;
//$$$                double trange[4], trange_dot[4], tt, tt_dot, results[18], results_dot[18];
//$$$                ego    *eedges;
//$$$
//$$$
//$$$                status = EG_getBodyTopos(ebody, NULL, EDGE, &nedges, &eedges);
//$$$
//$$$                for (iedge = 0; iedge < nedges; iedge++) {
//$$$                    status = EG_getRange_dot(eedges[iedge], trange, trange_dot, &periodic);
//$$$
//$$$                    for (ipnt = 0; ipnt < npnt; ipnt++) {
//$$$                        tt     = trange[    0] + (double)(ipnt) / (double)(npnt-1) * (trange[    1] - trange[    0]);
//$$$                        tt_dot = trange_dot[0] + (double)(ipnt) / (double)(npnt-1) * (trange_dot[1] - trange_dot[0]);
//$$$
//$$$                        status = EG_evaluate_dot(eedges[iedge], &tt, &tt_dot, results, results_dot);
//$$$
//$$$                        printf("%3d %4d   %10.5f %10.5f %10.5f   %10.5f %10.5f %10.5f\n", iedge, ipnt,
//$$$                               results[    0], results[    1], results[    2],
//$$$                               results_dot[0], results_dot[1], results_dot[2]);
//$$$                    }
//$$$                }
//$$$
//$$$                EG_free(eedges);
//$$$            }
#endif

            /* make sure Edge attributes are not removed */
            status = EG_attributeAdd(ebody, "__keepEdgeAttr__", ATTRSTRING,
                                     STRLEN("yes"), NULL, NULL, "yes");
            CHECK_STATUS(EG_attributeAdd);

            /* update @-parameters (SKEND: wire or face) */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            /* mark the new Faces (if any) with the current Branch */
            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
            CHECK_STATUS(EG_getBodyTopos);

            if (efaces != NULL) {
                for (iface = 1; iface <= nface; iface++) {
                    status = setFaceAttribute(MODL, ibody, iface, 0, 0, npatn, patn);
                    CHECK_STATUS(setFaceAttribute);
                }

                EG_free(efaces);
            }

            status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, NULL);
            CHECK_STATUS(EG_getBodyTopos);

            /* finish the Body (SKEND) */
            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Sketch onto the stack */
            stack[(*nstack)++] = ibody;

            SPRINT2(1, "                          Sketch %4d created with %d Edges",
                    ibody, nedge);

            /* return a signal if underconstrained, overconstrained, or not_converged */
            if        (sket->signal == OCSM_UNDERCONSTRAINED) {
                signalError(MODL, sket->signal,
                            "initial values used since sketch is underconstrained");
            } else if (sket->signal == OCSM_OVERCONSTRAINED) {
                signalError(MODL, sket->signal,
                            "initial values used since sketch is overconstrained");
            } else if (sket->signal == OCSM_NOT_CONVERGED) {
                signalError(MODL, sket->signal,
                            "initial values used since sketch did not converge");
            }
        }
    }

cleanup:
#ifndef ANALYTIC_SKETCH
    if (ulast == 12345 || vlast == 12345 || wlast == 12345) {
        printf("WE SHOULD NOT GET HERE 1\n");
    } else if (tdata_dot[0] == 12345 || matrix_dot[0] == 12345 || pts_dot[0] == 12345) {
        printf("WE SHOULD NOT GET HERE 2\n");
    }
#endif
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildSolver - implement OCSM_SOLVERs for ocsmBuild                 *
 *                                                                      *
 ************************************************************************
 */

static int
buildSolver(modl_T *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
/*@unused@*/varg_T args[],              /* (in)  array of arguments */
            int    *nvar,               /* (both) number of Solver variables */
            int    solvars[],           /* (both) array  of Slover variables */
            int    *ncon,               /* (both) number of constraints */
            int    solcons[])           /* (both) array  of constraints */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       jbrch, type, iter, niter, ipmtr, jpmtr, i, j, k, ivar, icon;
    double    f0max, save_value, value, dot, lambda, rms, rmslast, omega, f0last;
    double    *val_init=NULL, *neg_f0=NULL, *neg_f0old=NULL, *delx=NULL, *dfdx=NULL, *JtJ=NULL, *JtQ=NULL;
    char      name[MAX_EXPR_LEN], str[MAX_STRVAL_LEN], str2[MAX_STRVAL_LEN];

    ROUTINE(buildSolver);

    /* --------------------------------------------------------------- */

    type = MODL->brch[ibrch].type;

    /* execute: "solbeg $varList" */
    if (type == OCSM_SOLBEG) {
        SPRINT2(1, "    executing [%4d] solbeg:         %s",
                ibrch, MODL->brch[ibrch].arg1);

        /* initialize the number of solver constraints and variables */
        *ncon = 0;
        *nvar = 0;

        /* make a list of the solver variables by parsing arg1 */
        j       = 0;
        name[j] = '\0';
        for (i = 1; i <= STRLEN(MODL->brch[ibrch].arg1); i++) {
            if (MODL->brch[ibrch].arg1[i] != ';' && i < STRLEN(MODL->brch[ibrch].arg1)) {
                name[j  ] = MODL->brch[ibrch].arg1[i];
                name[j+1] = '\0';
                j++;
            } else if (STRLEN(name) > 0) {
                ipmtr = 0;
                for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
                    if (strcmp(MODL->pmtr[jpmtr].name, name) == 0                         &&
                               MODL->pmtr[jpmtr].scope       == MODL->scope[MODL->level]  &&
                               MODL->pmtr[jpmtr].type        == OCSM_LOCALVAR               ) {
                        ipmtr = jpmtr;
                        break;
                    }
                }

                if (ipmtr == 0) {
                    signalError(MODL, OCSM_NAME_NOT_FOUND,
                                "name \"%s\" not an INTERNAL parameter", name);
                    SET_STATUS(OCSM_NAME_NOT_FOUND, solbeg);
                }

                solvars[(*nvar)++] = ipmtr;

                if (*nvar > MAX_SOLVER_SIZE) {
                    signalError(MODL, OCSM_TOO_MANY_SOLVER_VARS,
                                "too many Solver variables");
                    SET_STATUS(OCSM_TOO_MANY_SOLVER_VARS, solbeg);
                }

                j       = 0;
                name[j] = '\0';
            }
        }

    /* execute: "solcon expr" */
    } else if (type == OCSM_SOLCON) {
        SPRINT2(1, "    executing [%4d] solcon:         %s",
                ibrch, MODL->brch[ibrch].arg1);

        solcons[(*ncon)++] = ibrch;

        if (*ncon > MAX_SOLVER_SIZE) {
            signalError(MODL, OCSM_TOO_MANY_SOLVER_VARS,
                        "too many Solver variables");
            SET_STATUS(OCSM_TOO_MANY_SOLVER_VARS, solcon);
        }

    /* execute: "solend" */
    } else if (type == OCSM_SOLEND) {
        SPRINT1(1, "    executing [%4d] solend:",
                ibrch);

        for (ivar = 0; ivar < *nvar; ivar++) {
            jpmtr = solvars[ivar];
            SPRINT3(2, "        var[%2d] = %3d [%s]",
                    ivar, jpmtr, MODL->pmtr[jpmtr].name);
        }
        for (icon = 0; icon < *ncon; icon++) {
            jbrch = solcons[icon];
            SPRINT3(2, "        con[%2d] = %3d [%s]",
                    icon, jbrch, &(MODL->brch[jbrch].arg1[1]));
        }

        /* if the number of constraints does not match the number of
           degrees of freedom, return an error */
        if        (*ncon < *nvar) {
            signalError(MODL, OCSM_UNDERCONSTRAINED,
                        "only %d constraints but %d degrees of freedom", *ncon, *nvar);
            SET_STATUS(OCSM_UNDERCONSTRAINED, solend);
        } else if (*ncon > *nvar) {
            signalError(MODL, OCSM_OVERCONSTRAINED,
                        "there are %d constraints, yet only %d degrees of freedom", *ncon, *nvar);
            SET_STATUS(OCSM_OVERCONSTRAINED, solend);
        }

        /* if there were no constraints, simply return */
        if (*ncon == 0) {
            goto cleanup;
        }

        /* get needed arrays */
        MALLOC(val_init,  double, MAX_SOLVER_SIZE);
        MALLOC(neg_f0,    double, MAX_SOLVER_SIZE);
        MALLOC(neg_f0old, double, MAX_SOLVER_SIZE);
        MALLOC(delx,      double, MAX_SOLVER_SIZE);
        MALLOC(JtQ,       double, MAX_SOLVER_SIZE);
        MALLOC(dfdx,      double, MAX_SOLVER_SIZE*MAX_SOLVER_SIZE);
        MALLOC(JtJ,       double, MAX_SOLVER_SIZE*MAX_SOLVER_SIZE);

        /* store the initial values in case we need to revert because solver failed */
        for (ivar = 0; ivar < *nvar; ivar++) {
            jpmtr = solvars[ivar];
            val_init[ivar] = MODL->pmtr[jpmtr].value[0];

            delx[ivar] = 0;
        }

        /* first try Newton's method to change the solver variables until
           the constraints are satisfied */
        niter  = 100;
        omega  = 0.50;
        f0last = 0;
        for (iter = 0; iter < niter; iter++) {

            /* evaluate the constraints */
            f0max = 0;
            for (icon = 0; icon < *ncon; icon++) {
                jbrch  = solcons[icon];

                status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                CHECK_STATUS(str2val);

                if (STRLEN(str) > 0) {
                    status = str2val(str, MODL, &value, &dot, str2);
                    CHECK_STATUS(str2val);

                    if (STRLEN(str2) > 0) {
                        signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                                    "constraint cannot have a string value (%s)", str2);
                        SET_STATUS(OCSM_WRONG_PMTR_TYPE, solend);
                    }
                }

                neg_f0[icon] = -value;
                SPRINT2(2,"        f0[%4d] = %11.4e", jbrch, value);

                if (fabs(value) > f0max) {
                    f0max = fabs(value);
                }
            }
            SPRINT2(1, "    -> solving: iter = %3d,   f0max = %12.4e", iter, f0max);

            /* if we have converged, stop the Newton iterations */
            if (f0max < EPS06) {
                break;
            }

            /* f0max < f0last, we are converging, so increase omega */
            if (f0max < f0last) {
                omega = MIN(1.2*omega, 1);
            }
            f0last = f0max;

            /* build up the Jacobian matrix by perturbing the solver variables
               one at a time */
            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];

                save_value = MODL->pmtr[jpmtr].value[0];
                MODL->pmtr[jpmtr].value[0] += EPS06;

                for (icon = 0; icon < *ncon; icon++) {
                    jbrch = solcons[icon];
                    status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                    CHECK_STATUS(str2val);

                    if (STRLEN(str) > 0) {
                        status = str2val(str, MODL, &value, &dot, str2);
                        CHECK_STATUS(str2val);
                    }

                    dfdx[icon*(*ncon)+ivar] = (value + neg_f0[icon]) / EPS06;
                }

                MODL->pmtr[jpmtr].value[0] = save_value;
            }

            /* take the Newton step */
            status = matsol(dfdx, neg_f0, *ncon, delx);
            if (status < SUCCESS) {
                SPRINT1(1, "singular matrix detected for iter=%d", iter);
                break;
            }

            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];
                MODL->pmtr[jpmtr].value[0] += omega * delx[ivar];
            }
        }

        /* now that we have run out of iterations, check for convergence */
        if (f0max >= EPS06) {
            SPRINT0(1, "no convergence, so trying Levenberg-Marquardt");

            for (ivar = 0; ivar < *nvar; ivar++) {
                jpmtr = solvars[ivar];
                MODL->pmtr[jpmtr].value[0] = val_init[ivar];
            }

            /* if not converged, use Levenberg-Marquardt iteration to change
               the solver variables until the constraints are satisfied */
            niter   = 100;
            lambda  = 1;
            rmslast = 1e300;

            for (iter = 0; iter < niter; iter++) {

                /* evaluate the constraints */
                f0max = 0;
                rms   = 0;
                for (icon = 0; icon < *ncon; icon++) {
                    jbrch  = solcons[icon];

                    status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                    CHECK_STATUS(str2val);

                    if (STRLEN(str) > 0) {
                        status = str2val(str, MODL, &value, &dot, str2);
                        CHECK_STATUS(str2val);
                    }

                    if (iter != 0) {
                        neg_f0old[icon] = neg_f0[icon];
                    }

                    neg_f0[icon] = -value;
                    SPRINT2(2,"        f0[%4d] = %11.4e", jbrch, value);

                    if (iter == 0) {
                        neg_f0old[icon] = neg_f0[icon];
                    }

                    rms += value * value;

                    if (fabs(value) > f0max) {
                        f0max = fabs(value);
                    }
                }

                SPRINT2(1, "    -> solving   iter = %3d,   f0max = %12.4e", iter, f0max);

                /* if we satisfied all the constraints, stop the Levenberg-Marquardt iterations */
                if (f0max < EPS06) {
                    break;
                }

                /* rms <= rmslast, we are converging, so decrease lambda and accept step */
                if (rms <= rmslast) {
                    lambda = MAX(0.5*lambda, 1.0e-10);
                    rmslast = rms;
                    SPRINT1(2,"        converging: lambda = %11.4e", lambda);

                /* rms > rmslast, not converging, so increase lambda and revert to old step */
                } else {
                    lambda = MIN(2.0*lambda, 1.0e+10);
                    for (ivar = 0; ivar < *nvar; ivar++) {
                        jpmtr = solvars[ivar];
                        MODL->pmtr[jpmtr].value[0] -= delx[ivar];

                        for (icon = 0; icon < *ncon; icon++){
                            neg_f0[icon] = neg_f0old[icon];
                        }
                    }
                    SPRINT1(2,"        not converging: lambda = %11.4e", lambda);
                }

                /* build up the Jacobian matrix by perturbing the solver variables
                   one at a time */
                for (ivar = 0; ivar < *nvar; ivar++) {
                    jpmtr = solvars[ivar];

                    save_value = MODL->pmtr[jpmtr].value[0];
                    MODL->pmtr[jpmtr].value[0] += EPS06;

                    for (icon = 0; icon < *ncon; icon++) {
                        jbrch = solcons[icon];
                        status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                        CHECK_STATUS(str2val);

                        if (STRLEN(str) > 0) {
                            status = str2val(str, MODL, &value, &dot, str2);
                            CHECK_STATUS(str2val);
                        }

                        dfdx[icon*(*ncon)+ivar] = (value + neg_f0[icon]) / EPS06;
                    }
                    MODL->pmtr[jpmtr].value[0] = save_value;
                }

                /* find Jtranspose * J */
                for (ivar = 0; ivar < *nvar; ivar++) {
                    for (icon = 0; icon < *ncon; icon++) {
                        JtJ[icon*(*ncon)+ivar] = 0;
                        for (k = 0; k < *nvar; k++) {
                            JtJ[icon*(*ncon)+ivar] += dfdx[k*(*ncon)+ivar] * dfdx[k*(*ncon)+icon];
                        }
                        if (ivar == icon) {
                            JtJ[icon*(*ncon)+ivar] *= (1.0 + lambda);
                        }
                    }
                }

                /* find Jtranspose * Q */
                for (ivar = 0; ivar < *nvar; ivar ++) {
                    JtQ[ivar] = 0;
                    for (icon = 0; icon < *ncon; icon++) {
                        JtQ[ivar] += dfdx[icon*(*ncon)+ivar] * neg_f0[icon];
                    }
                }

                /* take the Levenberg-Marquardt step*/
                status = matsol(JtJ, JtQ, *ncon, delx);
                CHECK_STATUS(matsol);

                /* update the design variables */
                for (ivar = 0; ivar < *nvar; ivar++) {
                    jpmtr = solvars[ivar];
                    MODL->pmtr[jpmtr].value[0] += delx[ivar];
                }
            }

            /* now that we have run out of iterations, check for convergence */
            if (f0max > EPS06) {

                SPRINT0(1, "WARNING:: reverting to initial solution");

                /* did not converge, so revert to initial values */
                for (ivar = 0; ivar < *nvar; ivar++) {
                    jpmtr = solvars[ivar];
                    MODL->pmtr[jpmtr].value[0] = val_init[ivar];
                }

                signalError(MODL, OCSM_NOT_CONVERGED,
                            "maximum iterations exceeded in SOLEND");
                goto cleanup;
            }
        }

        /* now that we have a solution, compute its sensitivity,  start by
           setting the sensitivity of all the solver variables to zero */
        for (ivar = 0; ivar < *nvar; ivar++) {
            jpmtr = solvars[ivar];
            MODL->pmtr[jpmtr].dot[0] = 0;
        }

        /* initialize the jacobian and rhs matricies with the velocities
           of the residuals */
        for (icon = 0; icon < *ncon; icon++) {
            jbrch = solcons[icon];
            status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
            CHECK_STATUS(str2val);

            if (STRLEN(str) > 0) {
                status = str2val(str, MODL, &value, &dot, str2);
                CHECK_STATUS(str2val);
            }

            for (ivar = 0; ivar < *nvar; ivar++) {
                dfdx[icon*(*ncon)+ivar] = dot;
            }
            neg_f0[icon] = dot;
        }

        /* column-by-column, subtract out the residuals with the velocity of
           one of the solver variables set to one */
        for (ivar = 0; ivar < *nvar; ivar++) {
            jpmtr = solvars[ivar];
            MODL->pmtr[jpmtr].dot[0] = 1;

            for (icon = 0; icon < *ncon; icon++) {
                jbrch = solcons[icon];
                status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value, &dot, str);
                CHECK_STATUS(str2val);

                if (STRLEN(str) > 0) {
                    status = str2val(str, MODL, &value, &dot, str2);
                    CHECK_STATUS(str2val);
                }

                dfdx[icon*(*ncon)+ivar] -= dot;
            }

            MODL->pmtr[jpmtr].dot[0] = 0;
        }

        SPRINT0(2, "matrix");
        for (icon = 0; icon < *ncon; icon++) {
            for (ivar = 0; ivar < *nvar; ivar++) {
                SPRINT1x(2, " %12.6f", dfdx[icon*(*ncon)+ivar]);
            }
            SPRINT1(2, " | %12.6f", neg_f0[icon]);
        }

        /* solve the matrix */
        status = matsol(dfdx, neg_f0, *nvar, delx);
        CHECK_STATUS(matsol);

        SPRINT0(2, "sensitivities");
        for (ivar = 0; ivar < *nvar; ivar++) {
            SPRINT1(2, " %12.6f", delx[ivar]);
        }

        /* set the velocities of the solver variables */
        for (ivar = 0; ivar < *nvar; ivar++) {
            jpmtr = solvars[ivar];
            MODL->pmtr[jpmtr].dot[0] = delx[ivar];
        }

        /* initialize variables for next solver */
        *nvar = 0;
        *ncon = 0;
    }

cleanup:
    FREE(val_init );
    FREE(neg_f0   );
    FREE(neg_f0old);
    FREE(delx     );
    FREE(JtQ      );
    FREE(dfdx     );
    FREE(JtJ      );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   buildTransform - implemet OCSM_TRANSFORMs for ocsmBuild            *
 *                                                                      *
 ************************************************************************
 */

static int
buildTransform(modl_T *modl,            /* (in)  pointer to MODL */
               int    ibrch,            /* (in)  Branch index (1:nbrch) */
               varg_T args[],           /* (in)  array of arguments */
               int    *nstack,          /* (both) number of Bodys on stack */
               int    stack[])          /* (both) array  of Bodys on stack */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        type, hasdots, ibody, jbody, ibodyl, nloop, nface, nedge;
    int        oclass, mtype, *senses, ishift, iswap, i, j, nbody_save;
    int        *iblist=NULL, ilist, nblist, igroup, attrType, attrLen;
    CINT       *tempIlist;
    double     toler, matrix[12], data[4];
    double     cosx, cosy, cosz, sinx, siny, sinz, xcent, ycent, zcent, fact;
    double     dx, dy, dz, nx, ny, nz, dist;
    CDOUBLE    *tempRlist;
    CCHAR      *tempClist;

    ego        ebody, ebodyl, exform, *eloops, eloop, eref, eswap;
    ego        *eedges, eface, esurf, *efaces, eshell;

    ROUTINE(buildTransform);

    /* --------------------------------------------------------------- */

    type    = MODL->brch[ibrch].type;
    hasdots = 0;

    /* execute: "translate dx dy dz" */
    if (type == OCSM_TRANSLATE) {
        SPRINT4(1, "    executing [%4d] translate:  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* make the transformation */
        dx = args[1].val[0];
        dy = args[2].val[0];
        dz = args[3].val[0];

        matrix[ 0] = 1; matrix[ 1] = 0; matrix[ 2] = 0; matrix[ 3] = dx;
        matrix[ 4] = 0; matrix[ 5] = 1; matrix[ 6] = 0; matrix[ 7] = dy;
        matrix[ 8] = 0; matrix[ 9] = 0; matrix[10] = 1; matrix[11] = dz;

    /* execute: "rotatex angDeg yaxis=0 zaxis=0" */
    } else if (type == OCSM_ROTATEX) {
        SPRINT4(1, "    executing [%4d] rotatex:    %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* make the transformation */
        cosx = cos(args[1].val[0] * PIo180);
        sinx = sin(args[1].val[0] * PIo180);
        dy   =     args[2].val[0];
        dz   =     args[3].val[0];

        matrix[ 0] = 1; matrix[ 1] = 0;    matrix[ 2] = 0;    matrix[ 3] = 0;
        matrix[ 4] = 0; matrix[ 5] = cosx; matrix[ 6] =-sinx; matrix[ 7] = dy - dy * cosx + dz * sinx;
        matrix[ 8] = 0; matrix[ 9] = sinx; matrix[10] = cosx; matrix[11] = dz - dy * sinx - dz * cosx;

    /* execute: "rotatey angDeg yaxis=0 zaxis=0" */
    } else if (type == OCSM_ROTATEY) {
        SPRINT4(1, "    executing [%4d] rotatey:    %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* make the transformation */
        cosy = cos(args[1].val[0] * PIo180);
        siny = sin(args[1].val[0] * PIo180);
        dz   =     args[2].val[0];
        dx   =     args[3].val[0];

        matrix[ 0] = cosy; matrix[ 1] = 0; matrix[ 2] = siny; matrix[ 3] = dx - dz * siny - dx * cosy;
        matrix[ 4] = 0;    matrix[ 5] = 1; matrix[ 6] = 0;    matrix[ 7] = 0;
        matrix[ 8] =-siny; matrix[ 9] = 0; matrix[10] = cosy; matrix[11] = dz - dz * cosy + dx * siny;

    /* execute: "rotatez angDeg yaxis=0 zaxis=0" */
    } else if (type == OCSM_ROTATEZ) {
        SPRINT4(1, "    executing [%4d] rotatez:    %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0) {
            hasdots = 1;

            SPRINT3(1, "                                 %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0]);
        }

        /* make the transformation */
        cosz = cos(args[1].val[0] * PIo180);
        sinz = sin(args[1].val[0] * PIo180);
        dx   =     args[2].val[0];
        dy   =     args[3].val[0];

        matrix[ 0] = cosz; matrix[ 1] =-sinz; matrix[ 2] = 0; matrix[ 3] = dx - dx * cosz + dy * sinz;
        matrix[ 4] = sinz; matrix[ 5] = cosz; matrix[ 6] = 0; matrix[ 7] = dy - dx * sinz - dy * cosz;
        matrix[ 8] = 0;    matrix[ 9] = 0;    matrix[10] = 1; matrix[11] = 0;

    /* execute: "scale fact xcent=0 ycent=0 zcent=0" */
    } else if (type == OCSM_SCALE) {
        SPRINT5(1, "    executing [%4d] scale:      %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0) {
            hasdots = 1;

            SPRINT4(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0]);
        }

        if (args[1].val[0] <= 0) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "Scale factor must be positive");
            goto cleanup;
        }

        /* make the transformation */
        fact  = args[1].val[0];
        xcent = args[2].val[0];
        ycent = args[3].val[0];
        zcent = args[4].val[0];

        matrix[ 0] = fact; matrix[ 1] = 0;    matrix[ 2] = 0;    matrix[ 3] = xcent * (1 - fact);
        matrix[ 4] = 0;    matrix[ 5] = fact; matrix[ 6] = 0;    matrix[ 7] = ycent * (1 - fact);
        matrix[ 8] = 0;    matrix[ 9] = 0;    matrix[10] = fact; matrix[11] = zcent * (1 - fact);

    /* execute: "mirror nx ny nz dist=0" */
    } else if (type == OCSM_MIRROR) {
        SPRINT5(1, "    executing [%4d] mirror:     %11.5f  %11.5f  %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0], args[3].val[0], args[4].val[0]);
        if (args[1].dot[0] != 0 || args[2].dot[0] != 0 || args[3].dot[0] != 0 || args[4].dot[0] != 0) {
            hasdots = 1;

            SPRINT4(1, "                                 %11.5f  %11.5f  %11.5f  %11.5f",
                    args[1].dot[0], args[2].dot[0], args[3].dot[0], args[4].dot[0]);
        }

        /* make the transformation */
        nx   = args[1].val[0];
        ny   = args[2].val[0];
        nz   = args[3].val[0];
        dist = args[4].val[0];

        fact  = sqrt(nx*nx + ny*ny + nz*nz);

        if (fabs(fact) < EPS12) {
            signalError(MODL, OCSM_ILLEGAL_VALUE,
                        "nx, ny, and nz cannot all be 0");
            goto cleanup;
        }

        dx    = nx / fact;
        dy    = ny / fact;
        dz    = nz / fact;

        matrix[ 0] = 1-2*dx*dx;    matrix[ 1] =  -2*dy*dx;    matrix[ 2] =  -2*dz*dx;    matrix[ 3] = 2*dist*dx;
        matrix[ 4] =  -2*dx*dy;    matrix[ 5] = 1-2*dy*dy;    matrix[ 6] =  -2*dz*dy;    matrix[ 7] = 2*dist*dy;
        matrix[ 8] =  -2*dx*dz;    matrix[ 9] =  -2*dy*dz;    matrix[10] = 1-2*dz*dz;    matrix[11] = 2*dist*dz;

    /* execute: "applycsys $csysName ibody=0" */
    } else if (type == OCSM_APPLYCSYS) {
        SPRINT3(1, "    executing [%4d] applycsys:  %s  %11.5f",
                ibrch, args[1].str, args[2].val[0]);

        ibody = NINT(args[2].val[0]);

        /* if ibody>0, look for named Csystem on that Body */
        if (ibody > 0) {
            if (ibody > MODL->nbody) {
                signalError(MODL, OCSM_BODY_NOT_FOUND,
                            "Body %d not found", ibody);
                goto cleanup;
            } else if (MODL->body[ibody].igroup == MODL->body[MODL->nbody].igroup) {
                signalError(MODL, OCSM_BODY_NOT_FOUND,
                            "Body %d cannot be in Group on top of stack", ibody);
                goto cleanup;
            } else {
                if (MODL->body[ibody].ebody == NULL) {
                    signalError(MODL, OCSM_BODY_NOT_FOUND,
                                "Body %d is a NULL Body", ibody);
                    goto cleanup;
                }

                status = EG_attributeRet(MODL->body[ibody].ebody, args[1].str,
                                         &attrType, &attrLen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status != SUCCESS) {
                    signalError(MODL, OCSM_NAME_NOT_FOUND,
                                "Csystem \"%s\" not found in Body %d", args[1].str, ibody);
                    goto cleanup;
                }

                /* make the transformation */
                matrix[ 0] = tempRlist[attrLen+3];    matrix[ 1] = tempRlist[attrLen+6];    matrix[ 2] = tempRlist[attrLen+ 9];    matrix[ 3] = tempRlist[attrLen  ];
                matrix[ 4] = tempRlist[attrLen+4];    matrix[ 5] = tempRlist[attrLen+7];    matrix[ 6] = tempRlist[attrLen+10];    matrix[ 7] = tempRlist[attrLen+1];
                matrix[ 8] = tempRlist[attrLen+5];    matrix[ 9] = tempRlist[attrLen+8];    matrix[10] = tempRlist[attrLen+11];    matrix[11] = tempRlist[attrLen+2];
            }

        /* if ibody==-1, look for named Csystem on current Body */
        } else if (ibody == -1) {
            status = EG_attributeRet(MODL->body[MODL->nbody].ebody, args[1].str,
                                     &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status != SUCCESS) {
                signalError(MODL, OCSM_NAME_NOT_FOUND,
                            "Csystem \"%s\" not found in Body %d", args[1].str, MODL->nbody);
                goto cleanup;
            }

            fact = tempRlist[attrLen+ 3] * (tempRlist[attrLen+ 7] * tempRlist[attrLen+11] - tempRlist[attrLen+10] * tempRlist[attrLen+ 8])
                 + tempRlist[attrLen+ 6] * (tempRlist[attrLen+10] * tempRlist[attrLen+ 5] - tempRlist[attrLen+ 4] * tempRlist[attrLen+11])
                 + tempRlist[attrLen+ 9] * (tempRlist[attrLen+ 4] * tempRlist[attrLen+ 8] - tempRlist[attrLen+ 7] * tempRlist[attrLen+ 5]);

            matrix[ 0] = (tempRlist[attrLen+ 7] * tempRlist[attrLen+11] - tempRlist[attrLen+10] * tempRlist[attrLen+ 8]) / fact;
            matrix[ 1] = (tempRlist[attrLen+ 9] * tempRlist[attrLen+ 8] - tempRlist[attrLen+ 6] * tempRlist[attrLen+11]) / fact;
            matrix[ 2] = (tempRlist[attrLen+ 6] * tempRlist[attrLen+10] - tempRlist[attrLen+ 9] * tempRlist[attrLen+ 7]) / fact;

            matrix[ 4] = (tempRlist[attrLen+10] * tempRlist[attrLen+ 5] - tempRlist[attrLen+ 4] * tempRlist[attrLen+11]) / fact;
            matrix[ 5] = (tempRlist[attrLen+ 3] * tempRlist[attrLen+11] - tempRlist[attrLen+ 9] * tempRlist[attrLen+ 5]) / fact;
            matrix[ 6] = (tempRlist[attrLen+ 9] * tempRlist[attrLen+ 4] - tempRlist[attrLen+ 3] * tempRlist[attrLen+10]) / fact;

            matrix[ 8] = (tempRlist[attrLen+ 4] * tempRlist[attrLen+ 8] - tempRlist[attrLen+ 7] * tempRlist[attrLen+ 5]) / fact;
            matrix[ 9] = (tempRlist[attrLen+ 6] * tempRlist[attrLen+ 5] - tempRlist[attrLen+ 3] * tempRlist[attrLen+ 8]) / fact;
            matrix[10] = (tempRlist[attrLen+ 3] * tempRlist[attrLen+ 7] - tempRlist[attrLen+ 6] * tempRlist[attrLen+ 4]) / fact;

            matrix[ 3] = -(matrix[ 0] * tempRlist[attrLen] + matrix[ 1] * tempRlist[attrLen+1] + matrix[ 2] * tempRlist[attrLen+2]);
            matrix[ 7] = -(matrix[ 4] * tempRlist[attrLen] + matrix[ 5] * tempRlist[attrLen+1] + matrix[ 6] * tempRlist[attrLen+2]);
            matrix[11] = -(matrix[ 8] * tempRlist[attrLen] + matrix[ 9] * tempRlist[attrLen+1] + matrix[10] * tempRlist[attrLen+2]);

        /* otherwise search backward from last Body, looking for named Csystem */
        } else {
            for (jbody = MODL->nbody-1; jbody >= 1; jbody--) {
                if (MODL->body[jbody].ebody == NULL) continue;
                if (MODL->body[jbody].igroup == MODL->body[MODL->nbody].igroup) continue;

                status = EG_attributeRet(MODL->body[jbody].ebody, args[1].str,
                                         &attrType, &attrLen,
                                         &tempIlist, &tempRlist, &tempClist);
                if (status == SUCCESS) {
                    ibody  = jbody;
                    SPRINT1(2, "found Csystem in Body %d", ibody);

                    /* make the transformation */
                    matrix[ 0] = tempRlist[attrLen+3];    matrix[ 1] = tempRlist[attrLen+6];    matrix[ 2] = tempRlist[attrLen+ 9];    matrix[ 3] = tempRlist[attrLen  ];
                    matrix[ 4] = tempRlist[attrLen+4];    matrix[ 5] = tempRlist[attrLen+7];    matrix[ 6] = tempRlist[attrLen+10];    matrix[ 7] = tempRlist[attrLen+1];
                    matrix[ 8] = tempRlist[attrLen+5];    matrix[ 9] = tempRlist[attrLen+8];    matrix[10] = tempRlist[attrLen+11];    matrix[11] = tempRlist[attrLen+2];

                    break;
                }
            }

            if (ibody <= 0) {
                signalError(MODL, OCSM_NAME_NOT_FOUND,
                            "Csystem \"%s\" not found in any Body not in current Group", args[1].str);
                goto cleanup;
            }
        }
    } else {

        /* make a unit transformation */
        matrix[ 0] = 1;    matrix[ 1] = 0;    matrix[ 2] = 0;    matrix[ 3] = 0;
        matrix[ 4] = 0;    matrix[ 5] = 1;    matrix[ 6] = 0;    matrix[ 7] = 0;
        matrix[ 8] = 0;    matrix[ 9] = 0;    matrix[10] = 1;    matrix[11] = 0;
    }

    /* process translate, rotatex, rotatey, rotatez, scale, mirror, or applycsys */
    if (type == OCSM_TRANSLATE ||
        type == OCSM_ROTATEX   || type == OCSM_ROTATEY || type == OCSM_ROTATEZ  ||
        type == OCSM_SCALE     || type == OCSM_MIRROR  || type == OCSM_APPLYCSYS  ) {

        /* make sure that there is a Body on the top of the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "transformation expects a Body on the stack");
            goto cleanup;
        } else if (stack[(*nstack)-1] <= 0) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "transformation expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[(*nstack)-1];
            igroup = MODL->body[ibodyl].igroup;
        }

        /* make a list to potentially keep track of the Bodys
           that should be transformed */
        MALLOC(iblist, int, *nstack);

        nblist = 0;
        while (*nstack > 0) {
            ibodyl = stack[--(*nstack)];
            if (ibodyl <= 0) {
                (*nstack)++;
                break;
            }

            if (MODL->body[ibodyl].igroup != igroup) {
                (*nstack)++;
                break;
            }

            iblist[nblist++] = ibodyl;
        }

        /* make the transformation ego */
        status = EG_makeTransform(MODL->context, matrix, &exform);
        CHECK_STATUS(EG_makeTransform);

        /* process each Body in iblist[] */
        for (ilist = nblist-1; ilist >= 0; ilist--) {
            ibodyl = iblist[ilist];

            /* recycle old Body if not dirty */
            nbody_save = MODL->nbody;
            status = recycleBody(MODL, ibrch, type, args, hasdots);
            CHECK_STATUS(recycleBody);

            if (status == 1) {
                for (ibodyl = nbody_save+1; ibodyl <= MODL->nbody; ibodyl++) {
                    if (*nstack < MAX_STACK_SIZE) {
                        stack[(*nstack)++] = ibodyl;
                    } else {
                        status = OCSM_TOO_MANY_BODYS_ON_STACK;
                        signalError(MODL, status,
                                    "Too many Bodys on Stack");
                        goto cleanup;
                    }
                }
                (MODL->ngroup)--;       /* this will get incremented below */

                break;
            }

            /* create a Body */
            status = newBody(MODL, ibrch, type, ibodyl, -1,
                             args, hasdots, MODL->body[ibodyl].botype, &ibody);
            CHECK_STATUS(newBody);

            ebodyl = MODL->body[ibodyl].ebody;

            /* transform the Body */
            status = EG_copyObject(ebodyl, exform, &ebody);
            CHECK_STATUS(EG_copyObject);

            MODL->body[ibody].ebody = ebody;

            status = EG_attributeAdd(ebody, "__numRemaining__", ATTRINT,
                                     1, &ilist, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);

            /* update @-parameters (TRANSFORM) and finish Body */
            status = setupAtPmtrs(MODL, 0);
            CHECK_STATUS(setupAtPmtrs);

            status = finishBody(MODL, ibody);
            if (MODL->sigCode != SUCCESS) goto cleanup;
            CHECK_STATUS(finishBody);

            /* push the Body onto the stack */
            stack[(*nstack)++] = ibody;

            status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
            CHECK_STATUS(getBodyTolerance);

            SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                    ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);

            /* decrement Group so that others that get made in the same transform
               will have the same Group number */
            (MODL->ngroup)--;

            /* if this is a APPLYCSYS with ibody==-1, then it is the only Body
               that should be transformed */
            if (type == OCSM_APPLYCSYS && NINT(args[2].val[0]) == -1) break;
        }

        /* increment the Group since we are finished with it */
        (MODL->ngroup)++;

        /* clean up */
        status = EG_deleteObject(exform);
        CHECK_STATUS(EG_deleteObject);

        FREE(iblist);

    /* execute: "reorder ishift iflip=0" */
    } else if (type == OCSM_REORDER) {
        SPRINT3(1, "    executing [%4d] reorder:    %11.5f  %11.5f",
                ibrch, args[1].val[0], args[2].val[0]);

        /* pop a Body from the stack */
        if ((*nstack) < 1) {
            signalError(MODL, OCSM_INSUFFICIENT_BODYS_ON_STACK,
                        "REORDER expects a Body on the stack");
            goto cleanup;
        } else {
            ibodyl = stack[--(*nstack)];
        }

        /* recycle old Body if not dirty */
        status = recycleBody(MODL, ibrch, type, args, hasdots);
        CHECK_STATUS(recycleBody);

        if (status == 1) {
            stack[(*nstack)++] = MODL->nbody;
            status = SUCCESS;
            goto cleanup;
        }

        /* make sure that ibodyl is either a WireBody or SheetBody */
        if (MODL->body[ibodyl].botype != OCSM_WIRE_BODY &&
            MODL->body[ibodyl].botype != OCSM_SHEET_BODY  ) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "REORDER needs a WireBody or SheetBody");
            goto cleanup;
        }

        /* make a copy of the Body so that the original does not get changed */
        status = EG_copyObject(MODL->body[ibodyl].ebody, NULL, &ebodyl);
        CHECK_STATUS(EG_copyObject);

        /* make sure that the Body has a single Loop */
        status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);
        SPLINT_CHECK_FOR_NULL(eloops);

        eloop = eloops[0];
        EG_free(eloops);

        if (nloop != 1) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "REORDER requires one Loop");
            goto cleanup;
        }

        /* create the Body */
        status = newBody(MODL, ibrch, OCSM_REORDER, ibodyl, -1,
                         args, hasdots, MODL->body[ibodyl].botype, &ibody);
        CHECK_STATUS(newBody);

        /* get the Edges and senses in the Loop */
        status = EG_getTopology(eloop, &eref, &oclass, &mtype, data,
                                &nedge, &eedges, &senses);
        CHECK_STATUS(EG_getTopology);

        /* shift the Edges in the Loop */
        if (mtype != CLOSED && NINT(args[1].val[0]) != 0) {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "only closed Loops can be shifted");
            MODL->nbody--;
            goto cleanup;
        }

        if (args[1].val[0] > 0) {
            SPRINT1(2, "before positive reordering: %d", NINT(args[1].val[0]));
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }

            for (ishift = 0; ishift < NINT(args[1].val[0]); ishift++) {
                eswap = eedges[0];
                iswap = senses[0];
                for (i = 0; i < nedge-1; i++) {
                    eedges[i] = eedges[i+1];
                    senses[i] = senses[i+1];
                }
                eedges[nedge-1] = eswap;
                senses[nedge-1] = iswap;
            }

            SPRINT0(2, "after   positive reordering");
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }
        } else if (args[1].val[0] < 0) {
            SPRINT1(2, "before negative reordering: %d", NINT(args[1].val[0]));
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }

            for (ishift = 0; ishift < -NINT(args[1].val[0]); ishift++) {
                eswap = eedges[nedge-1];
                iswap = senses[nedge-1];
                for (i = nedge-1; i > 0; i--) {
                    eedges[i] = eedges[i-1];
                    senses[i] = senses[i-1];
                }
                eedges[0] = eswap;
                senses[0] = iswap;
            }

            SPRINT0(2, "before negative reordering");
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }
        }

        /* flip the Loop */
        if (NINT(args[2].val[0]) != 0) {
            SPRINT0(2, "before flipping");
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }

            for (i = 0, j = nedge-1; i < j; i++, j--) {
                eswap     = eedges[i];
                iswap     = senses[i];
                eedges[i] = eedges[j];
                senses[i] = senses[j];
                eedges[j] = eswap;
                senses[j] = iswap;
            }

            for (i = 0; i < nedge; i++) {
                senses[i] = -senses[i];
            }

            SPRINT0(2, "after  flipping");
            for (i = 0; i < nedge; i++) {
                SPRINT4(2, "   eedges[%2d]=%llx,  senses[%2d]=%d", i, (long long)eedges[i], i, senses[i]);
            }
        }

        status = EG_makeTopology(MODL->context, NULL, LOOP, mtype,
                                 NULL, nedge, eedges, senses, &eloop);
        CHECK_STATUS(EG_makeTopology);

        /* make either WireBody or SheetBody */
        if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {
            status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                                     NULL, 1, &eloop, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);
        } else {
            status = EG_getTopology(ebodyl, &esurf, &oclass, &mtype, data,
                                    &nface, &efaces, &senses);
            CHECK_STATUS(EG_getTopology);

            if (mtype == SHEETBODY) {
                eshell = efaces[0];

                status = EG_getTopology(eshell, &esurf, &oclass, &mtype, data,
                                        &nface, &efaces, &senses);
                CHECK_STATUS(EG_getTopology);
            }

            status = EG_getTopology(efaces[0], &esurf, &oclass, &mtype, data,
                                    &nloop, &eloops, &senses);
            CHECK_STATUS(EG_getTopology);

            if (NINT(args[2].val[0]) != 0) {
                mtype = -mtype;
            }

            status = EG_makeTopology(MODL->context, esurf, FACE, mtype,
                                     NULL, 1, &eloop, senses, &eface);
            CHECK_STATUS(EG_makeTopology);

            status = EG_attributeDup(efaces[0], eface);
            CHECK_STATUS(EG_attributeDup);

            status = EG_makeTopology(MODL->context, NULL, SHELL, OPEN,
                                     NULL, 1, &eface, NULL, &eshell);
            CHECK_STATUS(EG_makeTopology);

            status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY,
                                     NULL, 1, &eshell, NULL, &ebody);
            CHECK_STATUS(EG_makeTopology);
        }

        MODL->body[ibody].ebody = ebody;

        /* remove the copied Body */
        status = EG_deleteObject(ebodyl);
        CHECK_STATUS(EG_deleteObject);

        /* update @-parameters and finish the Body (REORDER) */
        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        if (MODL->sigCode != SUCCESS) goto cleanup;
        CHECK_STATUS(finishBody);

        /* push the Body onto the stack */
        stack[(*nstack)++] = ibody;

        status = getBodyTolerance(MODL->body[ibody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);

        SPRINT5(1, "                          Body   %4d created  (toler=%11.4e, nnode=%4d, nedge=%4d, nface=%4d)",
                ibody, toler, MODL->body[ibody].nnode, MODL->body[ibody].nedge, MODL->body[ibody].nface);
    }

cleanup:
    FREE(iblist);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   colorizeEdge - set Edge color if Attribute is present              *
 *                                                                      *
 ************************************************************************
 */

static int
colorizeEdge(modl_T   *MODL,            /* (in)  pointer to MODL */
             int      ibody,            /* (in)  Body index (1:nbody) */
             int      iedge)            /* (in)  Edge index (1:nedge) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       attrType, attrLen, ired, igreen, iblue;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;

    ROUTINE(colorizeEdge);

    /* --------------------------------------------------------------- */

    /* use color Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_color",
                             &attrType, &attrLen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (attrType == ATTRREAL && attrLen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].edge[iedge].gratt.color = 65536 * ired + 256 * igreen + iblue;
        } else if (attrType == ATTRSTRING) {
            if        (strcmp(tempClist, "red"    ) == 0 || strcmp(tempClist, "RED"    ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.color = 0x00ff0000;
            } else if (strcmp(tempClist, "green"  ) == 0 || strcmp(tempClist, "GREEN"  ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.color = 0x0000ff00;
            } else if (strcmp(tempClist, "blue"   ) == 0 || strcmp(tempClist, "BLUE"   ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.color = 0x000000ff;
            } else if (strcmp(tempClist, "yellow" ) == 0 || strcmp(tempClist, "YELLOW" ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.color = 0x00ffff00;
            } else if (strcmp(tempClist, "magenta") == 0 || strcmp(tempClist, "MAGENTA") == 0) {
                MODL->body[ibody].edge[iedge].gratt.color = 0x00ff00ff;
            } else if (strcmp(tempClist, "cyan"   ) == 0 || strcmp(tempClist, "CYAN"   ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.color = 0x0000ffff;
            } else if (strcmp(tempClist, "white"  ) == 0 || strcmp(tempClist, "WHITE"  ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.color = 0x00ffffff;
            } else if (strcmp(tempClist, "black"  ) == 0 || strcmp(tempClist, "BLACK"  ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.color = 0x00000000;
            }
        }
    }

    /* use gcolor Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "_gcolor",
                             &attrType, &attrLen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (attrType == ATTRREAL && attrLen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].edge[iedge].gratt.mcolor = 65536 * ired + 256 * igreen + iblue;
        } else if (attrType == ATTRSTRING) {
            if        (strcmp(tempClist, "red"    ) == 0 || strcmp(tempClist, "RED"    ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00ff0000;
            } else if (strcmp(tempClist, "green"  ) == 0 || strcmp(tempClist, "GREEN"  ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.mcolor = 0x0000ff00;
            } else if (strcmp(tempClist, "blue"   ) == 0 || strcmp(tempClist, "BLUE"   ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.mcolor = 0x000000ff;
            } else if (strcmp(tempClist, "yellow" ) == 0 || strcmp(tempClist, "YELLOW" ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00ffff00;
            } else if (strcmp(tempClist, "magenta") == 0 || strcmp(tempClist, "MAGENTA") == 0) {
                MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00ff00ff;
            } else if (strcmp(tempClist, "cyan"   ) == 0 || strcmp(tempClist, "CYAN"   ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.mcolor = 0x0000ffff;
            } else if (strcmp(tempClist, "white"  ) == 0 || strcmp(tempClist, "WHITE"  ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00ffffff;
            } else if (strcmp(tempClist, "black"  ) == 0 || strcmp(tempClist, "BLACK"  ) == 0) {
                MODL->body[ibody].edge[iedge].gratt.mcolor = 0x00000000;
            }
        }
    }

    status = SUCCESS;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   colorizeFace - set Face color if Attribute is present              *
 *                                                                      *
 ************************************************************************
 */

static int
colorizeFace(modl_T   *MODL,            /* (in)  pointer to MODL */
             int      ibody,            /* (in)  Body index (1:nbody) */
             int      iface)            /* (in)  Face index (1:nface) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       attrType, attrLen, ired, igreen, iblue;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;

    ROUTINE(colorizeFace);

    /* --------------------------------------------------------------- */

    /* use color Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_color",
                             &attrType, &attrLen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (attrType == ATTRREAL && attrLen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].face[iface].gratt.color = 65536 * ired + 256 * igreen + iblue;
        } else if (attrType == ATTRSTRING) {
            if        (strcmp(tempClist, "red"    ) == 0 || strcmp(tempClist, "RED"    ) == 0) {
                MODL->body[ibody].face[iface].gratt.color = 0x00ff0000;
            } else if (strcmp(tempClist, "green"  ) == 0 || strcmp(tempClist, "GREEN"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.color = 0x0000ff00;
            } else if (strcmp(tempClist, "blue"   ) == 0 || strcmp(tempClist, "BLUE"   ) == 0) {
                MODL->body[ibody].face[iface].gratt.color = 0x000000ff;
            } else if (strcmp(tempClist, "yellow" ) == 0 || strcmp(tempClist, "YELLOW" ) == 0) {
                MODL->body[ibody].face[iface].gratt.color = 0x00ffff00;
            } else if (strcmp(tempClist, "magenta") == 0 || strcmp(tempClist, "MAGENTA") == 0) {
                MODL->body[ibody].face[iface].gratt.color = 0x00ff00ff;
            } else if (strcmp(tempClist, "cyan"   ) == 0 || strcmp(tempClist, "CYAN"   ) == 0) {
                MODL->body[ibody].face[iface].gratt.color = 0x0000ffff;
            } else if (strcmp(tempClist, "white"  ) == 0 || strcmp(tempClist, "WHITE"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.color = 0x00ffffff;
            } else if (strcmp(tempClist, "black"  ) == 0 || strcmp(tempClist, "BLACK"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.color = 0x00000000;
            }
        }
    }

    /* use bcolor Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_bcolor",
                             &attrType, &attrLen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (attrType == ATTRREAL && attrLen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].face[iface].gratt.bcolor = 65536 * ired + 256 * igreen + iblue;
        } else if (attrType == ATTRSTRING) {
            if       (strcmp(tempClist, "red"    ) == 0 || strcmp(tempClist, "RED"    ) == 0) {
                MODL->body[ibody].face[iface].gratt.bcolor = 0x00ff0000;
            } else if (strcmp(tempClist, "green"  ) == 0 || strcmp(tempClist, "GREEN"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.bcolor = 0x0000ff00;
            } else if (strcmp(tempClist, "blue"   ) == 0 || strcmp(tempClist, "BLUE"   ) == 0) {
                MODL->body[ibody].face[iface].gratt.bcolor = 0x000000ff;
            } else if (strcmp(tempClist, "yellow" ) == 0 || strcmp(tempClist, "YELLOW" ) == 0) {
                MODL->body[ibody].face[iface].gratt.bcolor = 0x00ffff00;
            } else if (strcmp(tempClist, "magenta") == 0 || strcmp(tempClist, "MAGENTA") == 0) {
                MODL->body[ibody].face[iface].gratt.bcolor = 0x00ff00ff;
            } else if (strcmp(tempClist, "cyan"   ) == 0 || strcmp(tempClist, "CYAN"   ) == 0) {
                MODL->body[ibody].face[iface].gratt.bcolor = 0x0000ffff;
            } else if (strcmp(tempClist, "white"  ) == 0 || strcmp(tempClist, "WHITE"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.bcolor = 0x00ffffff;
            } else if (strcmp(tempClist, "black"  ) == 0 || strcmp(tempClist, "BLACK"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.bcolor = 0x00000000;
            }
        }
    }

    /* use gcolor Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_gcolor",
                             &attrType, &attrLen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (attrType == ATTRREAL && attrLen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].face[iface].gratt.mcolor = 65536 * ired + 256 * igreen + iblue;
        } else if (attrType == ATTRSTRING) {
            if        (strcmp(tempClist, "red"    ) == 0 || strcmp(tempClist, "RED"    ) == 0) {
                MODL->body[ibody].face[iface].gratt.mcolor = 0x00ff0000;
            } else if (strcmp(tempClist, "green"  ) == 0 || strcmp(tempClist, "GREEN"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.mcolor = 0x0000ff00;
            } else if (strcmp(tempClist, "blue"   ) == 0 || strcmp(tempClist, "BLUE"   ) == 0) {
                MODL->body[ibody].face[iface].gratt.mcolor = 0x000000ff;
            } else if (strcmp(tempClist, "yellow" ) == 0 || strcmp(tempClist, "YELLOW" ) == 0) {
                MODL->body[ibody].face[iface].gratt.mcolor = 0x00ffff00;
            } else if (strcmp(tempClist, "magenta") == 0 || strcmp(tempClist, "MAGENTA") == 0) {
                MODL->body[ibody].face[iface].gratt.mcolor = 0x00ff00ff;
            } else if (strcmp(tempClist, "cyan"   ) == 0 || strcmp(tempClist, "CYAN"   ) == 0) {
                MODL->body[ibody].face[iface].gratt.mcolor = 0x0000ffff;
            } else if (strcmp(tempClist, "white"  ) == 0 || strcmp(tempClist, "WHITE"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.mcolor = 0x00ffffff;
            } else if (strcmp(tempClist, "black"  ) == 0 || strcmp(tempClist, "BLACK"  ) == 0) {
                MODL->body[ibody].face[iface].gratt.mcolor = 0x00000000;
            }
        }
    }

    status = SUCCESS;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   colorizeNode - set Node color if Attribute is present              *
 *                                                                      *
 ************************************************************************
 */

static int
colorizeNode(modl_T   *MODL,            /* (in)  pointer to MODL */
             int      ibody,            /* (in)  Body index (1:nbody) */
             int      inode)            /* (in)  Node index (1:nnode) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       attrType, attrLen, ired, igreen, iblue;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;

    ROUTINE(colorizeNode);

    /* --------------------------------------------------------------- */

    /* use color Attribute if it exists */
    status = EG_attributeRet(MODL->body[ibody].node[inode].enode, "_color",
                             &attrType, &attrLen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        if (attrType == ATTRREAL && attrLen == 3) {
            ired   = MIN(MAX(0, (int)(255*tempRlist[0])),255);
            igreen = MIN(MAX(0, (int)(255*tempRlist[1])),255);
            iblue  = MIN(MAX(0, (int)(255*tempRlist[2])),255);

            MODL->body[ibody].node[inode].gratt.color = 65536 * ired + 256 * igreen + iblue;
        } else if (attrType == ATTRSTRING) {
            if        (strcmp(tempClist, "red"    ) == 0 || strcmp(tempClist, "RED"    ) == 0) {
                MODL->body[ibody].node[inode].gratt.color = 0x00ff0000;
            } else if (strcmp(tempClist, "green"  ) == 0 || strcmp(tempClist, "GREEN"  ) == 0) {
                MODL->body[ibody].node[inode].gratt.color = 0x0000ff00;
            } else if (strcmp(tempClist, "blue"   ) == 0 || strcmp(tempClist, "BLUE"   ) == 0) {
                MODL->body[ibody].node[inode].gratt.color = 0x000000ff;
            } else if (strcmp(tempClist, "yellow" ) == 0 || strcmp(tempClist, "YELLOW" ) == 0) {
                MODL->body[ibody].node[inode].gratt.color = 0x00ffff00;
            } else if (strcmp(tempClist, "magenta") == 0 || strcmp(tempClist, "MAGENTA") == 0) {
                MODL->body[ibody].node[inode].gratt.color = 0x00ff00ff;
            } else if (strcmp(tempClist, "cyan"   ) == 0 || strcmp(tempClist, "CYAN"   ) == 0) {
                MODL->body[ibody].node[inode].gratt.color = 0x0000ffff;
            } else if (strcmp(tempClist, "white"  ) == 0 || strcmp(tempClist, "WHITE"  ) == 0) {
                MODL->body[ibody].node[inode].gratt.color = 0x00ffffff;
            } else if (strcmp(tempClist, "black"  ) == 0 || strcmp(tempClist, "BLACK"  ) == 0) {
                MODL->body[ibody].node[inode].gratt.color = 0x00000000;
            }
        }
    }

    status = SUCCESS;

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   computeMassProps - sets up mass property Parameters                *
 *                                                                      *
 ************************************************************************
 */

static int
computeMassProps(modl_T *modl)          /* (in)  pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       AT_xmin=0,   AT_ymin=0, AT_zmin=0,  AT_xmax=0, AT_ymax=0, AT_zmax=0;
    int       AT_length=0, AT_area=0, AT_volume=0;
    int       AT_xcg=0,    AT_ycg=0,  AT_zcg=0;
    int       AT_Ixx=0,    AT_Ixy=0,  AT_Ixz=0;
    int       AT_Iyx=0,    AT_Iyy=0,  AT_Iyz=0;
    int       AT_Izx=0,    AT_Izy=0,  AT_Izz=0;
    int       AT_toler=0;
    double    box[6], bbox[6], massprop[14], mpdot;

    int       ipmtr, oclass, mtype, nchild, *sense, ilist, periodic;
    double    data[18], trange[4], toler, maxtoler;
    ego       eref, *echild, *enodes;
#if PRINT_PROGRESS
    time_t    cpu_beg, cpu_end;
#endif

    ROUTINE(computeMassProps);

    /* --------------------------------------------------------------- */

    PPRINT_INIT(enter computeMassProps);

    /* no need to compute if we already have mass properties */
    if (MODL->hasMPs > 0) {
        goto cleanup;

    /* otherwise make a note that we are computing the mass properties now */
    } else {
        SPRINT0(2, "    setting up mass properties");
        MODL->hasMPs = 1;
    }

    /* determine the value to set for the velocities of massprops based
       upon whether or not any of the DESPMTRs have non-zero dots */
    if (MODL->numdots == 0) {
        mpdot = 0;
    } else {
        mpdot = -HUGEQ;
    }

    /* get the Parameter indices for each of the variables (at this level) */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  == OCSM_LOCALVAR           &&
            MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
            if (strcmp(MODL->pmtr[ipmtr].name, "@xmin"  ) == 0) AT_xmin   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ymin"  ) == 0) AT_ymin   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zmin"  ) == 0) AT_zmin   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@xmax"  ) == 0) AT_xmax   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ymax"  ) == 0) AT_ymax   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zmax"  ) == 0) AT_zmax   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@length") == 0) AT_length = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@area"  ) == 0) AT_area   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@volume") == 0) AT_volume = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@xcg"   ) == 0) AT_xcg    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ycg"   ) == 0) AT_ycg    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zcg"   ) == 0) AT_zcg    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixx"   ) == 0) AT_Ixx    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixy"   ) == 0) AT_Ixy    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixz"   ) == 0) AT_Ixz    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyx"   ) == 0) AT_Iyx    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyy"   ) == 0) AT_Iyy    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyz"   ) == 0) AT_Iyz    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izx"   ) == 0) AT_Izx    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izy"   ) == 0) AT_Izy    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izz"   ) == 0) AT_Izz    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@toler" ) == 0) AT_toler  = ipmtr;
        }
    }

    /* find the bounding box of all the entities in the sellist */
    bbox[0] = +HUGEQ;          // xmin
    bbox[1] = +HUGEQ;          // ymin
    bbox[2] = +HUGEQ;          // zmin
    bbox[3] = -HUGEQ;          // xmax
    bbox[4] = -HUGEQ;          // ymax
    bbox[5] = -HUGEQ;          // zmax

    if (MODL->seltype == -1) {
        status = EG_getBoundingBox(MODL->body[MODL->selbody].ebody, bbox);
        CHECK_STATUS(EG_getBoundingBox);

        status = getBodyTolerance(MODL->body[MODL->selbody].ebody, &toler);
        CHECK_STATUS(getBodyTolerance);
    } else if (MODL->seltype == 1 && MODL->selsize == 1) {
        status = EG_getRange(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                             trange, &periodic);
        CHECK_STATUS(EG_getRange);

        status = EG_evaluate(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                             &(trange[0]), data);
        if (status == SUCCESS) {
            bbox[0] = data[0];
            bbox[1] = data[1];
            bbox[2] = data[2];

            status = EG_evaluate(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                                 &(trange[1]), data);
            CHECK_STATUS(EG_evaluate);
            bbox[3] = data[0];
            bbox[4] = data[1];
            bbox[5] = data[2];
        } else if (status == EGADS_DEGEN) {
            status = EG_getTopology(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                                    &eref, &oclass, &mtype, trange, &nchild, &enodes, &sense);
            CHECK_STATUS(EG_getTopology);

            status = EG_getTopology(enodes[0], &eref, &oclass, &mtype,
                                    bbox, &nchild, &echild, &sense);
            CHECK_STATUS(EG_getTopology);

            bbox[3] = bbox[0];
            bbox[4] = bbox[1];
            bbox[5] = bbox[2];
        } else {
            CHECK_STATUS(EG_evaluate);
        }
    } else {
        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            if        (MODL->seltype == 2) {
                status = EG_getBoundingBox(MODL->body[MODL->selbody].face[MODL->sellist[ilist]].eface, box);
                CHECK_STATUS(EG_getBoundingBox);
            } else if (MODL->seltype == 1) {
                status = EG_getBoundingBox(MODL->body[MODL->selbody].edge[MODL->sellist[ilist]].eedge, box);
                CHECK_STATUS(EG_getBoundingBox);
            } else if (MODL->seltype == 0) {
                status = EG_getTopology(MODL->body[MODL->selbody].node[MODL->sellist[ilist]].enode,
                                        &eref, &oclass, &mtype,
                                        box, &nchild, &echild, &sense);
                CHECK_STATUS(EG_getTopology);

                box[3] = box[0];
                box[4] = box[1];
                box[5] = box[2];
            } else {
                SPRINT1(0, "ERROR:: bad MODL->seltype=%d", MODL->seltype);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            bbox[0] = MIN(bbox[0], box[0]);
            bbox[1] = MIN(bbox[1], box[1]);
            bbox[2] = MIN(bbox[2], box[2]);
            bbox[3] = MAX(bbox[3], box[3]);
            bbox[4] = MAX(bbox[4], box[4]);
            bbox[5] = MAX(bbox[5], box[5]);
        }
    }

    /* set @xmin, @xmax, @ymin, @ymax, @zmin, and @zmax */
    MODL->pmtr[AT_xmin].value[0] = bbox[0];
    MODL->pmtr[AT_xmin].dot[  0] = mpdot;

    MODL->pmtr[AT_ymin].value[0] = bbox[1];
    MODL->pmtr[AT_ymin].dot[  0] = mpdot;

    MODL->pmtr[AT_zmin].value[0] = bbox[2];
    MODL->pmtr[AT_zmin].dot[  0] = mpdot;

    MODL->pmtr[AT_xmax].value[0] = bbox[3];
    MODL->pmtr[AT_xmax].dot[  0] = mpdot;

    MODL->pmtr[AT_ymax].value[0] = bbox[4];
    MODL->pmtr[AT_ymax].dot[  0] = mpdot;

    MODL->pmtr[AT_zmax].value[0] = bbox[5];
    MODL->pmtr[AT_zmax].dot[  0] = mpdot;

    PPRINT0(done setting up bounding box info);

    /* find the mass properties of all the entities in the sellist */
    if (MODL->seltype == -1) {
        status = EG_getMassProperties(MODL->body[MODL->selbody].ebody, massprop);
        CHECK_STATUS(EG_getMassProperties);

        status = getBodyTolerance(MODL->body[MODL->selbody].ebody, &maxtoler);
        CHECK_STATUS(getBodyTolerance);
    } else {
        massprop[ 0] = 0;         // area
        massprop[ 1] = 0;         // volume
        massprop[ 2] = 0;         // xcg
        massprop[ 3] = 0;         // ycg
        massprop[ 4] = 0;         // zcg
        massprop[ 5] = 0;         // Ixx
        massprop[ 6] = 0;         // Ixy
        massprop[ 7] = 0;         // Ixz
        massprop[ 8] = 0;         // Iyx
        massprop[ 9] = 0;         // Iyy
        massprop[10] = 0;         // Iyz
        massprop[11] = 0;         // Izx
        massprop[12] = 0;         // Izy
        massprop[13] = 0;         // Izz

        maxtoler     = 0;

        if        (MODL->seltype == 2) {
            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                status = EG_getMassProperties(MODL->body[MODL->selbody].face[MODL->sellist[ilist]].eface, data);
                CHECK_STATUS(EG_getMassProperties);

                massprop[ 0] += data[ 0];          // should be 0
                massprop[ 1] += data[ 1];
                massprop[ 2] += data[ 2] * data[1];
                massprop[ 3] += data[ 3] * data[1];
                massprop[ 4] += data[ 4] * data[1];
                massprop[ 5] += data[ 5] + data[1] * data[2] * data[2];
                massprop[ 6] += data[ 6] + data[1] * data[2] * data[3];
                massprop[ 7] += data[ 7] + data[1] * data[2] * data[4];
                massprop[ 8] += data[ 8] + data[1] * data[3] * data[2];
                massprop[ 9] += data[ 9] + data[1] * data[3] * data[3];
                massprop[10] += data[10] + data[1] * data[3] * data[4];
                massprop[11] += data[11] + data[1] * data[4] * data[2];
                massprop[12] += data[12] + data[1] * data[4] * data[3];
                massprop[13] += data[13] + data[1] * data[4] * data[4];

                status = EG_getTolerance(MODL->body[MODL->selbody].face[MODL->sellist[ilist]].eface, &toler);
                CHECK_STATUS(EG_getTolerance);

                maxtoler = MAX(maxtoler, toler);
            }

            if (fabs(massprop[1]) > EPS20) {
                massprop[ 2] /= massprop[1];
                massprop[ 3] /= massprop[1];
                massprop[ 4] /= massprop[1];
            }
            massprop[ 5] -= massprop[1] * massprop[2] * massprop[2];
            massprop[ 6] -= massprop[1] * massprop[2] * massprop[3];
            massprop[ 7] -= massprop[1] * massprop[2] * massprop[4];
            massprop[ 8] -= massprop[1] * massprop[3] * massprop[2];
            massprop[ 9] -= massprop[1] * massprop[3] * massprop[3];
            massprop[10] -= massprop[1] * massprop[3] * massprop[4];
            massprop[11] -= massprop[1] * massprop[4] * massprop[2];
            massprop[12] -= massprop[1] * massprop[4] * massprop[3];
            massprop[13] -= massprop[1] * massprop[4] * massprop[4];
        } else if (MODL->seltype == 1) {
            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                status = EG_getMassProperties(MODL->body[MODL->selbody].edge[MODL->sellist[ilist]].eedge, data);
                CHECK_STATUS(EG_getMassProperties);

                massprop[ 0] += data[ 0];          // should be 0
                massprop[ 1] += data[ 1];
                massprop[ 2] += data[ 2] * data[1];
                massprop[ 3] += data[ 3] * data[1];
                massprop[ 4] += data[ 4] * data[1];
                massprop[ 5] += data[ 5] + data[1] * data[2] * data[2];
                massprop[ 6] += data[ 6] + data[1] * data[2] * data[3];
                massprop[ 7] += data[ 7] + data[1] * data[2] * data[4];
                massprop[ 8] += data[ 8] + data[1] * data[3] * data[2];
                massprop[ 9] += data[ 9] + data[1] * data[3] * data[3];
                massprop[10] += data[10] + data[1] * data[3] * data[4];
                massprop[11] += data[11] + data[1] * data[4] * data[2];
                massprop[12] += data[12] + data[1] * data[4] * data[3];
                massprop[13] += data[13] + data[1] * data[4] * data[4];

                status = EG_getTolerance(MODL->body[MODL->selbody].edge[MODL->sellist[ilist]].eedge, &toler);
                CHECK_STATUS(EG_getTolerance);

                maxtoler = MAX(maxtoler, toler);
            }

            if (fabs(massprop[1]) > EPS20) {
                massprop[ 2] /= massprop[1];
                massprop[ 3] /= massprop[1];
                massprop[ 4] /= massprop[1];
            }
            massprop[ 5] -= massprop[1] * massprop[2] * massprop[2];
            massprop[ 6] -= massprop[1] * massprop[2] * massprop[3];
            massprop[ 7] -= massprop[1] * massprop[2] * massprop[4];
            massprop[ 8] -= massprop[1] * massprop[3] * massprop[2];
            massprop[ 9] -= massprop[1] * massprop[3] * massprop[3];
            massprop[10] -= massprop[1] * massprop[3] * massprop[4];
            massprop[11] -= massprop[1] * massprop[4] * massprop[2];
            massprop[12] -= massprop[1] * massprop[4] * massprop[3];
            massprop[13] -= massprop[1] * massprop[4] * massprop[4];
        } else if (MODL->seltype == 0) {
            for (ilist = 0; ilist < MODL->selsize; ilist++) {
                massprop[ 0] += 0;
                massprop[ 1] += 1;
                massprop[ 2] += MODL->body[MODL->selbody].node[MODL->sellist[ilist]].x;
                massprop[ 3] += MODL->body[MODL->selbody].node[MODL->sellist[ilist]].y;
                massprop[ 4] += MODL->body[MODL->selbody].node[MODL->sellist[ilist]].z;
            }

            if (fabs(massprop[1]) > EPS20) {
                massprop[ 2] /= massprop[1];
                massprop[ 3] /= massprop[1];
                massprop[ 4] /= massprop[1];
            }
            massprop[ 5]  = 0;
            massprop[ 6]  = 0;
            massprop[ 7]  = 0;
            massprop[ 8]  = 0;
            massprop[ 9]  = 0;
            massprop[10]  = 0;
            massprop[11]  = 0;
            massprop[12]  = 0;
            massprop[13]  = 0;
        } else {
            SPRINT1(0, "ERROR:: bad MODL->seltype=%d", MODL->seltype);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }
    }

    /* set @length, @area, and @volume */
    if        (MODL->seltype == 2) {
        MODL->pmtr[AT_length].value[0] = 0;
        MODL->pmtr[AT_length].dot[  0] = mpdot;

        MODL->pmtr[AT_area  ].value[0] = massprop[1];
        MODL->pmtr[AT_area  ].dot[  0] = mpdot;

        MODL->pmtr[AT_volume].value[0] = 0;
        MODL->pmtr[AT_volume].dot[  0] = mpdot;
    }  else if (MODL->seltype == 1) {
        MODL->pmtr[AT_length].value[0] = massprop[1];
        MODL->pmtr[AT_length].dot[  0] = mpdot;

        MODL->pmtr[AT_area  ].value[0] = 0;
        MODL->pmtr[AT_area  ].dot[  0] = mpdot;

        MODL->pmtr[AT_volume].value[0] = 0;
        MODL->pmtr[AT_volume].dot[  0] = mpdot;
    }  else if (MODL->seltype == 0) {
        MODL->pmtr[AT_length].value[0] = 0;
        MODL->pmtr[AT_length].dot[  0] = mpdot;

        MODL->pmtr[AT_area  ].value[0] = 0;
        MODL->pmtr[AT_area  ].dot[  0] = mpdot;

        MODL->pmtr[AT_volume].value[0] = 0;
        MODL->pmtr[AT_volume].dot[  0] = mpdot;
    } else if (MODL->seltype == -1 && MODL->body[MODL->selbody].botype == OCSM_WIRE_BODY) {
        MODL->pmtr[AT_length].value[0] = massprop[1];
        MODL->pmtr[AT_length].dot[  0] = mpdot;

        MODL->pmtr[AT_area  ].value[0] = 0;
        MODL->pmtr[AT_area  ].dot[  0] = mpdot;

        MODL->pmtr[AT_volume].value[0] = 0;
        MODL->pmtr[AT_volume].dot[  0] = mpdot;
    } else {
        MODL->pmtr[AT_length].value[0] = 0;
        MODL->pmtr[AT_length].dot[  0] = mpdot;

        MODL->pmtr[AT_area  ].value[0] = massprop[1];
        MODL->pmtr[AT_area  ].dot[  0] = mpdot;

        MODL->pmtr[AT_volume].value[0] = massprop[0];
        MODL->pmtr[AT_volume].dot[  0] = mpdot;
    }

    /* set @xcg, @ycg, and @zcg */
    MODL->pmtr[AT_xcg].value[0] = massprop[2];
    MODL->pmtr[AT_xcg].dot[  0] = mpdot;

    MODL->pmtr[AT_ycg].value[0] = massprop[3];
    MODL->pmtr[AT_ycg].dot[  0] = mpdot;

    MODL->pmtr[AT_zcg].value[0] = massprop[4];
    MODL->pmtr[AT_zcg].dot[  0] = mpdot;

    /* set @Ixx, @Ixy, @Ixz, @Iyx, @Iyy, @Iyz, @Izx, @Izy, and @Izz */
    MODL->pmtr[AT_Ixx].value[0] = massprop[5];
    MODL->pmtr[AT_Ixx].dot[  0] = mpdot;

    MODL->pmtr[AT_Ixy].value[0] = massprop[6];
    MODL->pmtr[AT_Ixy].dot[  0] = mpdot;

    MODL->pmtr[AT_Ixz].value[0] = massprop[7];
    MODL->pmtr[AT_Ixz].dot[  0] = mpdot;

    MODL->pmtr[AT_Iyx].value[0] = massprop[8];
    MODL->pmtr[AT_Iyx].dot[  0] = mpdot;

    MODL->pmtr[AT_Iyy].value[0] = massprop[9];
    MODL->pmtr[AT_Iyy].dot[  0] = mpdot;

    MODL->pmtr[AT_Iyz].value[0] = massprop[10];
    MODL->pmtr[AT_Iyz].dot[  0] = mpdot;

    MODL->pmtr[AT_Izx].value[0] = massprop[11];
    MODL->pmtr[AT_Izx].dot[  0] = mpdot;

    MODL->pmtr[AT_Izy].value[0] = massprop[12];
    MODL->pmtr[AT_Izy].dot[  0] = mpdot;

    MODL->pmtr[AT_Izz].value[0] = massprop[13];
    MODL->pmtr[AT_Izz].dot[  0] = mpdot;

    MODL->pmtr[AT_toler].value[0] = maxtoler;
    MODL->pmtr[AT_toler].dot[  0] = mpdot;

    PPRINT0(done setting up mass properties);

cleanup:
    PPRINT0(exit computeMassProps);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   computeMassPropsDot - populate .dot for the mass properties        *
 *                                                                      *
 ************************************************************************
 */

static int
computeMassPropsDot(modl_T *MODL)       /* (in)  pointer to base MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ibody, jbody, ileft, irite, iface, iedge, inode;
    int       npnt, ipnt, ntri, itri, ipmtr, ilist, okay, count;
    CINT      *ptype, *pindx, *tris, *tric;
    double    xmin,     xmax,     ymin,     ymax,     zmin,     zmax;
    double    xmin_dot, xmax_dot, ymin_dot, ymax_dot, zmin_dot, zmax_dot;
    double    x0,     y0,     z0,     x1,     y1,     z1,     x2,     y2,     z2;
    double    x0_dot, y0_dot, z0_dot, x1_dot, y1_dot, z1_dot, x2_dot, y2_dot, z2_dot;
    double    xcen,     ycen,     zcen,     aa,     areax,     areay,     areaz;
    double    xcen_dot, ycen_dot, zcen_dot, aa_dot, areax_dot, areay_dot, areaz_dot;
    double    ll,     dx,     dy,     dz;
    double    ll_dot, dx_dot, dy_dot, dz_dot;
    double    len,     area,     vol,     xcg,     ycg,     zcg;
    double    len_dot, area_dot, vol_dot, xcg_dot, ycg_dot, zcg_dot;
    double    Ixx,     Iyy,     Izz,     Ixy,     Ixz,     Iyz;
    double    Ixx_dot, Iyy_dot, Izz_dot, Ixy_dot, Ixz_dot, Iyz_dot;
    double    xyz1[3];
    CDOUBLE   *xyz, *uv, *dxyz;

    ROUTINE(computeMassPropsDot);

    /* --------------------------------------------------------------- */

    /* do not compute if finite differences are being used.  ie, if MODL
       is or has a perturbation */
    if (MODL->perturb != NULL) {
        goto cleanup;
    } else if (MODL->hasMPs == 2) {
        goto cleanup;
    } else {
        SPRINT0(2, "   computing mass properties (analytically)");
        MODL->hasMPs = 2;
    }

    ibody = MODL->selbody;

    if (ibody < 1 || ibody > MODL->nbody) {
        goto cleanup;
    }

    /* quick return if not a SolidBody, SheetBody, WireBody, or NodeBody */
    if (MODL->body[ibody].botype != OCSM_SOLID_BODY &&
        MODL->body[ibody].botype != OCSM_SHEET_BODY &&
        MODL->body[ibody].botype != OCSM_WIRE_BODY  &&
        MODL->body[ibody].botype != OCSM_NODE_BODY    ) {
        goto cleanup;
    }

    /* initialize the properties and their velocities */
    xmin = +HUGEQ;     xmin_dot = 0;
    xmax = -HUGEQ;     xmax_dot = 0;
    ymin = +HUGEQ;     ymin_dot = 0;
    ymax = -HUGEQ;     ymax_dot = 0;
    zmin = +HUGEQ;     zmin_dot = 0;
    zmax = -HUGEQ;     zmax_dot = 0;
    len  = 0;          len_dot  = 0;
    area = 0;          area_dot = 0;
    vol  = 0;          vol_dot  = 0;
    xcg  = 0;          xcg_dot  = 0;
    ycg  = 0;          ycg_dot  = 0;
    zcg  = 0;          zcg_dot  = 0;
    Ixx  = 0;          Ixx_dot  = 0;
    Iyy  = 0;          Iyy_dot  = 0;
    Izz  = 0;          Izz_dot  = 0;
    Ixy  = 0;          Ixy_dot  = 0;
    Ixz  = 0;          Ixz_dot  = 0;
    Iyz  = 0;          Iyz_dot  = 0;

    count = 0;

    /* propagate the has dots to all children -- take care of internal Xsects, such as a RULE or BLEND */
    for (jbody = 1; jbody <= MODL->nbody; jbody++) {
        if (MODL->body[jbody].ichld > 0 && MODL->body[jbody].hasdots > 0) {
            MODL->body[MODL->body[jbody].ichld].hasdots = MODL->body[jbody].hasdots;
        }
    }

    /* propagate the hasdots to all children -- take care of multiple RESTOREs */
    for (jbody = 1; jbody <= MODL->nbody; jbody++) {
        ileft = MODL->body[jbody].ileft;
        irite = MODL->body[jbody].irite;

        if (ileft > 0) {
            if (MODL->body[ileft].hasdots > 0) {
                MODL->body[jbody].hasdots = 1;
            }
        }
        if (irite > 0) {
            if (MODL->body[irite].hasdots > 0) {
                MODL->body[jbody].hasdots = 1;
            }
        }
    }


    /* make sure that we have tessellation velocities */
    status = createTessVels(MODL, ibody);
    CHECK_STATUS(createTessVels);

    /* SolidBody */
    if (MODL->body[ibody].botype == OCSM_SOLID_BODY && MODL->seltype == -1) {
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt, &xyz, &uv, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            status = ocsmGetTessVel(MODL, ibody, OCSM_FACE, iface, &dxyz);
            CHECK_STATUS(ocsmGetTessVels);

            for (ipnt = 0; ipnt < npnt; ipnt++) {
                if (xyz[3*ipnt  ] < xmin) {
                    xmin     = xyz[ 3*ipnt  ];
                    xmin_dot = dxyz[3*ipnt  ];
                }
                if (xyz[3*ipnt  ] > xmax) {
                    xmax     = xyz[ 3*ipnt  ];
                    xmax_dot = dxyz[3*ipnt  ];
                }
                if (xyz[3*ipnt+1] < ymin) {
                    ymin     = xyz[ 3*ipnt+1];
                    ymin_dot = dxyz[3*ipnt+1];
                }
                if (xyz[3*ipnt+1] > ymax) {
                    ymax     = xyz[ 3*ipnt+1];
                    ymax_dot = dxyz[3*ipnt+1];
                }
                if (xyz[3*ipnt+2] < zmin) {
                    zmin     = xyz[ 3*ipnt+2];
                    zmin_dot = dxyz[3*ipnt+2];
                }
                if (xyz[3*ipnt+2] > zmax) {
                    zmax     = xyz[ 3*ipnt+2];
                    zmax_dot = dxyz[3*ipnt+2];
                }
            }

            /* use divergence theorem */
            for (itri = 0; itri < ntri; itri++) {
                x0     = xyz[ 3*(tris[3*itri  ]-1)  ];
                x0_dot = dxyz[3*(tris[3*itri  ]-1)  ];
                y0     = xyz[ 3*(tris[3*itri  ]-1)+1];
                y0_dot = dxyz[3*(tris[3*itri  ]-1)+1];
                z0     = xyz[ 3*(tris[3*itri  ]-1)+2];
                z0_dot = dxyz[3*(tris[3*itri  ]-1)+2];

                x1     = xyz[ 3*(tris[3*itri+1]-1)  ];
                x1_dot = dxyz[3*(tris[3*itri+1]-1)  ];
                y1     = xyz[ 3*(tris[3*itri+1]-1)+1];
                y1_dot = dxyz[3*(tris[3*itri+1]-1)+1];
                z1     = xyz[ 3*(tris[3*itri+1]-1)+2];
                z1_dot = dxyz[3*(tris[3*itri+1]-1)+2];

                x2     = xyz[ 3*(tris[3*itri+2]-1)  ];
                x2_dot = dxyz[3*(tris[3*itri+2]-1)  ];
                y2     = xyz[ 3*(tris[3*itri+2]-1)+1];
                y2_dot = dxyz[3*(tris[3*itri+2]-1)+1];
                z2     = xyz[ 3*(tris[3*itri+2]-1)+2];
                z2_dot = dxyz[3*(tris[3*itri+2]-1)+2];

                xcen     = (x0     + x1     + x2    );
                xcen_dot = (x0_dot + x1_dot + x2_dot);
                ycen     = (y0     + y1     + y2    );
                ycen_dot = (y0_dot + y1_dot + y2_dot);
                zcen     = (z0     + z1     + z2    );
                zcen_dot = (z0_dot + z1_dot + z2_dot);

                areax     = (y1     - y0    ) * (z2     - z0    ) - (z1     - z0    ) * (y2     - y0    );
                areax_dot = (y1_dot - y0_dot) * (z2     - z0    ) - (z1_dot - z0_dot) * (y2     - y0    )
                          + (y1     - y0    ) * (z2_dot - z0_dot) - (z1     - z0    ) * (y2_dot - y0_dot);
                areay     = (z1     - z0    ) * (x2     - x0    ) - (x1     - x0    ) * (z2     - z0    );
                areay_dot = (z1_dot - z0_dot) * (x2     - x0    ) - (x1_dot - x0_dot) * (z2     - z0    )
                          + (z1     - z0    ) * (x2_dot - x0_dot) - (x1     - x0    ) * (z2_dot - z0_dot);
                areaz     = (x1     - x0    ) * (y2     - y0    ) - (y1     - y0    ) * (x2     - x0    );
                areaz_dot = (x1_dot - x0_dot) * (y2     - y0    ) - (y1_dot - y0_dot) * (x2     - x0    )
                          + (x1     - x0    ) * (y2_dot - y0_dot) - (y1     - y0    ) * (x2_dot - x0_dot);

                aa        = sqrt(areax * areax     + areay * areay     + areaz * areaz    );
                aa_dot    =     (areax * areax_dot + areay * areay_dot + areaz * areaz_dot) / aa;

                area     += aa;
                area_dot += aa_dot;

                vol      += xcen     * areax     + ycen     * areay     + zcen     * areaz;
                vol_dot  += xcen_dot * areax     + ycen_dot * areay     + zcen_dot * areaz
                         +  xcen     * areax_dot + ycen     * areay_dot + zcen     * areaz_dot;

                xcg      += xcen/2   * xcen     * areax     + xcen     * ycen     * areay     + xcen     * zcen     * areaz;
                xcg_dot  += xcen_dot * xcen     * areax     + xcen_dot * ycen     * areay     + xcen_dot * zcen     * areaz
                         +                                    xcen     * ycen_dot * areay     + xcen     * zcen_dot * areaz
                         +  xcen/2   * xcen     * areax_dot + xcen     * ycen     * areay_dot + xcen     * zcen     * areaz_dot;

                ycg      += ycen     * xcen     * areax     + ycen/2   * ycen     * areay     + ycen     * zcen     * areaz;
                ycg_dot  += ycen_dot * xcen     * areax     + ycen_dot * ycen     * areay     + ycen_dot * zcen     * areaz
                         +  ycen     * xcen_dot * areax                                       + ycen     * zcen_dot * areaz
                         +  ycen     * xcen     * areax_dot + ycen/2   * ycen     * areay_dot + ycen     * zcen     * areaz_dot;

                zcg      += zcen     * xcen     * areax     + zcen     * ycen     * areay     + zcen/2   * zcen     * areaz;
                zcg_dot  += zcen_dot * xcen     * areax     + zcen_dot * ycen     * areay     + zcen_dot * zcen     * areaz
                         +  zcen     * xcen_dot * areax     + zcen     * ycen_dot * areay
                         +  zcen     * xcen     * areax_dot + zcen     * ycen     * areay_dot + zcen/2   * zcen     * areaz_dot;

                Ixx      += (    ycen * ycen * ycen     * areay     +     zcen * zcen * zcen     * areaz    );
                Ixx_dot  += (3 * ycen * ycen * ycen_dot * areay     + 3 * zcen * zcen * zcen_dot * areaz    )
                         +  (    ycen * ycen * ycen     * areay_dot +     zcen * zcen * zcen     * areaz_dot);

                Iyy      += (    xcen * xcen * xcen     * areax     +     zcen * zcen * zcen     * areaz    );
                Iyy_dot  += (3 * xcen * xcen * xcen_dot * areax     + 3 * zcen * zcen * zcen_dot * areaz    )
                         +  (    xcen * xcen * xcen     * areax_dot +     zcen * zcen * zcen     * areaz_dot);

                Izz      += (    xcen * xcen * xcen     * areax     +     ycen * ycen * ycen     * areay    );
                Izz_dot  += (3 * xcen * xcen * xcen_dot * areax     + 3 * ycen * ycen * ycen_dot * areay    )
                         +  (    xcen * xcen * xcen     * areax_dot +     ycen * ycen * ycen     * areay_dot);

                Ixy      -= (xcen     * ycen     * xcen     * areax    /2
                          +  xcen     * ycen     * ycen     * areay    /2
                          +  xcen     * ycen     * zcen     * areaz      );
                Ixy_dot  -= (xcen_dot * ycen     * xcen     * areax    /2
                          +  xcen     * ycen_dot * xcen     * areax    /2
                          +  xcen     * ycen     * xcen_dot * areax    /2
                          +  xcen     * ycen     * xcen     * areax_dot/2

                          +  xcen_dot * ycen     * ycen     * areay    /2
                          +  xcen     * ycen_dot * ycen     * areay    /2
                          +  xcen     * ycen     * ycen_dot * areay    /2
                          +  xcen     * ycen     * ycen     * areay_dot/2

                          +  xcen_dot * ycen     * zcen     * areaz
                          +  xcen     * ycen_dot * zcen     * areaz
                          +  xcen     * ycen     * zcen_dot * areaz
                          +  xcen     * ycen     * zcen     * areaz_dot  );

                Ixz      -= (xcen     * zcen     * xcen     * areax    /2
                          +  xcen     * zcen     * ycen     * areay
                          +  xcen     * zcen     * zcen     * areaz    /2);
                Ixz_dot  -= (xcen_dot * zcen     * xcen     * areax    /2
                          +  xcen     * zcen_dot * xcen     * areax    /2
                          +  xcen     * zcen     * xcen_dot * areax    /2
                          +  xcen     * zcen     * xcen     * areax_dot/2

                          +  xcen_dot * zcen     * ycen     * areay
                          +  xcen     * zcen_dot * ycen     * areay
                          +  xcen     * zcen     * ycen_dot * areay
                          +  xcen     * zcen     * ycen     * areay_dot

                          +  xcen_dot * zcen     * zcen     * areaz    /2
                          +  xcen     * zcen_dot * zcen     * areaz    /2
                          +  xcen     * zcen     * zcen_dot * areaz    /2
                          +  xcen     * zcen     * zcen     * areaz_dot/2);

                Iyz      -= (ycen     * zcen     * xcen     * areax
                          +  ycen     * zcen     * ycen     * areay    /2
                          +  ycen     * zcen     * zcen     * areaz    /2);
                Iyz_dot  -= (ycen_dot * zcen     * xcen     * areax
                          +  ycen     * zcen_dot * xcen     * areax
                          +  ycen     * zcen     * xcen_dot * areax
                          +  ycen     * zcen     * xcen     * areax_dot

                          +  ycen_dot * zcen     * ycen     * areay    /2
                          +  ycen     * zcen_dot * ycen     * areay    /2
                          +  ycen     * zcen     * ycen_dot * areay    /2
                          +  ycen     * zcen     * ycen     * areay_dot/2

                          +  ycen_dot * zcen     * zcen     * areaz    /2
                          +  ycen     * zcen_dot * zcen     * areaz    /2
                          +  ycen     * zcen     * zcen_dot * areaz    /2
                          +  ycen     * zcen     * zcen     * areaz_dot/2);
            }
            count++;

            SPRINT3(2, "after iface %5d  (npnt=%5d, ntri=%5d)", iface, npnt, ntri);
            SPRINT2(2, "        xmin   %16.6f  %16.6f", xmin, xmin_dot);
            SPRINT2(2, "        xmax   %16.6f  %16.6f", xmax, xmax_dot);
            SPRINT2(2, "        ymin   %16.6f  %16.6f", ymin, ymin_dot);
            SPRINT2(2, "        ymax   %16.6f  %16.6f", ymax, ymax_dot);
            SPRINT2(2, "        zmin   %16.6f  %16.6f", zmin, zmin_dot);
            SPRINT2(2, "        zmax   %16.6f  %16.6f", zmax, zmax_dot);
            SPRINT2(2, "        area   %16.6f  %16.6f", area, area_dot);
            SPRINT2(2, "        vol    %16.6f  %16.6f", vol,  vol_dot );
            SPRINT2(2, "        xcg    %16.6f  %16.6f", xcg,  xcg_dot );
            SPRINT2(2, "        ycg    %16.6f  %16.6f", ycg,  ycg_dot );
            SPRINT2(2, "        zcg    %16.6f  %16.6f", zcg,  zcg_dot );
            SPRINT2(2, "        Ixx    %16.6f  %16.6f", Ixx,  Ixx_dot );
            SPRINT2(2, "        Iyy    %16.6f  %16.6f", Iyy,  Iyy_dot );
            SPRINT2(2, "        Izz    %16.6f  %16.6f", Izz,  Izz_dot );
            SPRINT2(2, "        Ixy    %16.6f  %16.6f", Ixy,  Ixy_dot );
            SPRINT2(2, "        Ixz    %16.6f  %16.6f", Ixz,  Ixz_dot );
            SPRINT2(2, "        Iyz    %16.6f  %16.6f", Iyz,  Iyz_dot );
        }

        /* normalize (since we actually accumulated twice the area, ...) */
        area     /=   2;
        area_dot /=   2;
        vol      /=  18;
        vol_dot  /=  18;
        xcg      /=  54;
        xcg_dot  /=  54;
        ycg      /=  54;
        ycg_dot  /=  54;
        zcg      /=  54;
        zcg_dot  /=  54;
        Ixx      /= 162;
        Ixx_dot  /= 162;
        Iyy      /= 162;
        Iyy_dot  /= 162;
        Izz      /= 162;
        Izz_dot  /= 162;
        Ixy      /= 162;
        Ixy_dot  /= 162;
        Ixz      /= 162;
        Ixz_dot  /= 162;
        Iyz      /= 162;
        Iyz_dot  /= 162;

        /* compute centroid (since xcg*vol, ... was accumulated above) */
        xcg     /= vol;
        xcg_dot  = xcg_dot / vol - vol_dot * xcg / vol;

        ycg     /= vol;
        ycg_dot  = ycg_dot / vol - vol_dot * ycg / vol;

        zcg     /= vol;
        zcg_dot  = zcg_dot / vol - vol_dot * zcg / vol;

        /* apply parallel axis theorem */
        Ixx     -= vol     * (                ycg * ycg     + zcg * zcg    );
        Ixx_dot -= vol_dot * (                ycg * ycg     + zcg * zcg    )
                 + vol * 2 * (                ycg * ycg_dot + zcg * zcg_dot);

        Iyy     -= vol     * (xcg * xcg                     + zcg * zcg    );
        Iyy_dot -= vol_dot * (xcg * xcg                     + zcg * zcg    )
                 + vol * 2 * (xcg * xcg_dot                 + zcg * zcg_dot);

        Izz     -= vol     * (xcg * xcg     + ycg * ycg                    );
        Izz_dot -= vol_dot * (xcg * xcg     + ycg * ycg                    )
                 + vol * 2 * (xcg * xcg_dot + ycg * ycg_dot                );

        Ixy     += vol     * xcg * ycg;
        Ixy_dot += vol_dot * xcg * ycg + vol * xcg_dot * ycg + vol * xcg * ycg_dot;

        Ixz     += vol     * xcg * zcg;
        Ixz_dot += vol_dot * xcg * zcg + vol * xcg_dot * zcg + vol * xcg * zcg_dot;

        Iyz     += vol     * ycg * zcg;
        Iyz_dot += vol_dot * ycg * zcg + vol * ycg_dot * zcg + vol * ycg * zcg_dot;

    /* SheetBody or a group of Faces */
    } else if (MODL->body[ibody].botype == OCSM_SHEET_BODY || MODL->seltype == 2) {
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            if (MODL->body[ibody].botype != OCSM_SHEET_BODY) {
                okay = 0;
                for (ilist = 0; ilist < MODL->selsize; ilist++) {
                    if (iface == MODL->sellist[ilist]) {
                        okay = 1;
                        break;
                    }
                }

                if (okay == 0) continue;
            }

            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt, &xyz, &uv, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            status = ocsmGetTessVel(MODL, ibody, OCSM_FACE, iface, &dxyz);
            CHECK_STATUS(ocsmGetTessVels);

            for (ipnt = 0; ipnt < npnt; ipnt++) {
                if (xyz[3*ipnt  ] < xmin) {
                    xmin     = xyz[ 3*ipnt  ];
                    xmin_dot = dxyz[3*ipnt  ];
                }
                if (xyz[3*ipnt  ] > xmax) {
                    xmax     = xyz[ 3*ipnt  ];
                    xmax_dot = dxyz[3*ipnt  ];
                }
                if (xyz[3*ipnt+1] < ymin) {
                    ymin     = xyz[ 3*ipnt+1];
                    ymin_dot = dxyz[3*ipnt+1];
                }
                if (xyz[3*ipnt+1] > ymax) {
                    ymax     = xyz[ 3*ipnt+1];
                    ymax_dot = dxyz[3*ipnt+1];
                }
                if (xyz[3*ipnt+2] < zmin) {
                    zmin     = xyz[ 3*ipnt+2];
                    zmin_dot = dxyz[3*ipnt+2];
                }
                if (xyz[3*ipnt+2] > zmax) {
                    zmax     = xyz[ 3*ipnt+2];
                    zmax_dot = dxyz[3*ipnt+2];
                }
            }

            for (itri = 0; itri < ntri; itri++) {
                x0     = xyz[ 3*(tris[3*itri  ]-1)  ];
                x0_dot = dxyz[3*(tris[3*itri  ]-1)  ];
                y0     = xyz[ 3*(tris[3*itri  ]-1)+1];
                y0_dot = dxyz[3*(tris[3*itri  ]-1)+1];
                z0     = xyz[ 3*(tris[3*itri  ]-1)+2];
                z0_dot = dxyz[3*(tris[3*itri  ]-1)+2];

                x1     = xyz[ 3*(tris[3*itri+1]-1)  ];
                x1_dot = dxyz[3*(tris[3*itri+1]-1)  ];
                y1     = xyz[ 3*(tris[3*itri+1]-1)+1];
                y1_dot = dxyz[3*(tris[3*itri+1]-1)+1];
                z1     = xyz[ 3*(tris[3*itri+1]-1)+2];
                z1_dot = dxyz[3*(tris[3*itri+1]-1)+2];

                x2     = xyz[ 3*(tris[3*itri+2]-1)  ];
                x2_dot = dxyz[3*(tris[3*itri+2]-1)  ];
                y2     = xyz[ 3*(tris[3*itri+2]-1)+1];
                y2_dot = dxyz[3*(tris[3*itri+2]-1)+1];
                z2     = xyz[ 3*(tris[3*itri+2]-1)+2];
                z2_dot = dxyz[3*(tris[3*itri+2]-1)+2];

                xcen     = (x0     + x1     + x2    );
                xcen_dot = (x0_dot + x1_dot + x2_dot);
                ycen     = (y0     + y1     + y2    );
                ycen_dot = (y0_dot + y1_dot + y2_dot);
                zcen     = (z0     + z1     + z2    );
                zcen_dot = (z0_dot + z1_dot + z2_dot);

                areax     = (y1     - y0    ) * (z2     - z0    ) - (z1     - z0    ) * (y2     - y0    );
                areax_dot = (y1_dot - y0_dot) * (z2     - z0    ) - (z1_dot - z0_dot) * (y2     - y0    )
                          + (y1     - y0    ) * (z2_dot - z0_dot) - (z1     - z0    ) * (y2_dot - y0_dot);
                areay     = (z1     - z0    ) * (x2     - x0    ) - (x1     - x0    ) * (z2     - z0    );
                areay_dot = (z1_dot - z0_dot) * (x2     - x0    ) - (x1_dot - x0_dot) * (z2     - z0    )
                          + (z1     - z0    ) * (x2_dot - x0_dot) - (x1     - x0    ) * (z2_dot - z0_dot);
                areaz     = (x1     - x0    ) * (y2     - y0    ) - (y1     - y0    ) * (x2     - x0    );
                areaz_dot = (x1_dot - x0_dot) * (y2     - y0    ) - (y1_dot - y0_dot) * (x2     - x0    )
                          + (x1     - x0    ) * (y2_dot - y0_dot) - (y1     - y0    ) * (x2_dot - x0_dot);

                aa        = sqrt(areax * areax     + areay * areay     + areaz * areaz    );
                aa_dot    =     (areax * areax_dot + areay * areay_dot + areaz * areaz_dot) / aa;

                area     += aa;
                area_dot += aa_dot;

                xcg      += xcen     * aa;
                xcg_dot  += xcen_dot * aa + xcen * aa_dot;

                ycg      += ycen     * aa;
                ycg_dot  += ycen_dot * aa + ycen * aa_dot;

                zcg      += zcen     * aa;
                zcg_dot  += zcen_dot * aa + zcen * aa_dot;

                Ixx      += aa     * (ycen * ycen     + zcen * zcen    );
                Ixx_dot  += aa_dot * (ycen * ycen     + zcen * zcen    )
                         +  aa * 2 * (ycen * ycen_dot + zcen * zcen_dot);

                Iyy      += aa     * (xcen * xcen     + zcen * zcen    );
                Iyy_dot  += aa_dot * (xcen * xcen     + zcen * zcen    )
                         +  aa * 2 * (xcen * xcen_dot + zcen * zcen_dot);

                Izz      += aa     * (xcen * xcen     + ycen * ycen    );
                Izz_dot  += aa_dot * (xcen *xcen      + ycen * ycen    )
                         +  aa * 2 * (xcen * xcen_dot + ycen * ycen_dot);

                Ixy      -= aa     * xcen * ycen;
                Ixy_dot  -= aa_dot * xcen * ycen + aa * xcen_dot * ycen + aa * xcen * ycen_dot;

                Ixz      -= aa     * xcen * zcen;
                Ixz_dot  -= aa_dot * xcen * zcen + aa * xcen_dot * zcen + aa * xcen * zcen_dot;

                Iyz      -= aa     * ycen * zcen;
                Iyz_dot  -= aa_dot * ycen * zcen + aa * ycen_dot * zcen + aa * ycen * zcen_dot;
            }

            SPRINT3(2, "after iface %5d  (npnt=%5d, ntri=%5d)", iface, npnt, ntri);
            SPRINT2(2, "        xmin   %16.6f  %16.6f", xmin, xmin_dot);
            SPRINT2(2, "        xmax   %16.6f  %16.6f", xmax, xmax_dot);
            SPRINT2(2, "        ymin   %16.6f  %16.6f", ymin, ymin_dot);
            SPRINT2(2, "        ymax   %16.6f  %16.6f", ymax, ymax_dot);
            SPRINT2(2, "        zmin   %16.6f  %16.6f", zmin, zmin_dot);
            SPRINT2(2, "        zmax   %16.6f  %16.6f", zmax, zmax_dot);
            SPRINT2(2, "        area   %16.6f  %16.6f", area, area_dot);
            SPRINT2(2, "        vol    %16.6f  %16.6f", vol,  vol_dot );
            SPRINT2(2, "        xcg    %16.6f  %16.6f", xcg,  xcg_dot );
            SPRINT2(2, "        ycg    %16.6f  %16.6f", ycg,  ycg_dot );
            SPRINT2(2, "        zcg    %16.6f  %16.6f", zcg,  zcg_dot );
            SPRINT2(2, "        Ixx    %16.6f  %16.6f", Ixx,  Ixx_dot );
            SPRINT2(2, "        Iyy    %16.6f  %16.6f", Iyy,  Iyy_dot );
            SPRINT2(2, "        Izz    %16.6f  %16.6f", Izz,  Izz_dot );
            SPRINT2(2, "        Ixy    %16.6f  %16.6f", Ixy,  Ixy_dot );
            SPRINT2(2, "        Ixz    %16.6f  %16.6f", Ixz,  Ixz_dot );
            SPRINT2(2, "        Iyz    %16.6f  %16.6f", Iyz,  Iyz_dot );

            count++;
        }

        /* normalize (since we actually accumulated twice the area, ...) */
        area     /=   2;
        area_dot /=   2;
        xcg      /=   6;
        xcg_dot  /=   6;
        ycg      /=   6;
        ycg_dot  /=   6;
        zcg      /=   6;
        zcg_dot  /=   6;
        Ixx      /=  18;
        Ixx_dot  /=  18;
        Iyy      /=  18;
        Iyy_dot  /=  18;
        Izz      /=  18;
        Izz_dot  /=  18;
        Ixy      /=  18;
        Ixy_dot  /=  18;
        Ixz      /=  18;
        Ixz_dot  /=  18;
        Iyz      /=  18;
        Iyz_dot  /=  18;

        /* compute centroid (since xcg*area, ... was accumulated above) */
        xcg     /= area;
        xcg_dot  = xcg_dot / area - area_dot * xcg / area;
        ycg     /= area;
        ycg_dot  = ycg_dot / area - area_dot * ycg / area;
        zcg     /= area;
        zcg_dot  = zcg_dot / area - area_dot * zcg / area;

        /* apply parallel axis theorem */
        Ixx     -= area     * (                ycg * ycg     + zcg * zcg    );
        Ixx_dot -= area_dot * (                ycg * ycg     + zcg * zcg    )
                 + area * 2 * (                ycg * ycg_dot + zcg * zcg_dot);

        Iyy     -= area     * (xcg * xcg                     + zcg * zcg    );
        Iyy_dot -= area_dot * (xcg * xcg                     + zcg * zcg    )
                 + area * 2 * (xcg * xcg_dot                 + zcg * zcg_dot);

        Izz     -= area     * (xcg * xcg     + ycg * ycg                    );
        Izz_dot -= area_dot * (xcg * xcg     + ycg * ycg                    )
                 + area * 2 * (xcg * xcg_dot + ycg * ycg_dot                );

        Ixy     += area     * xcg * ycg;
        Ixy_dot += area_dot * xcg * ycg + area * xcg_dot * ycg + area * xcg * ycg_dot;

        Ixz     += area     * xcg * zcg;
        Ixz_dot += area_dot * xcg * zcg + area * xcg_dot * zcg + area * xcg * zcg_dot;

        Iyz     += area     * ycg * zcg;
        Iyz_dot += area_dot * ycg * zcg + area * ycg_dot * zcg + area * ycg * zcg_dot;

    /* WireBody or a group of Edges */
    } else if (MODL->body[ibody].botype == OCSM_WIRE_BODY || MODL->seltype == 1) {
        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            if (MODL->body[ibody].botype != OCSM_WIRE_BODY) {
                okay = 0;
                for (ilist = 0; ilist < MODL->selsize; ilist++) {
                    if (iedge == MODL->sellist[ilist]) {
                        okay = 1;
                        break;
                    }
                }

                if (okay == 0) continue;
            }

            status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                    &npnt, &xyz, &uv);
            CHECK_STATUS(EG_getTessEdge);

            status = ocsmGetTessVel(MODL, ibody, OCSM_EDGE, iedge, &dxyz);
            CHECK_STATUS(ocsmGetTessVels);

            if (MODL->body[ibody].botype != OCSM_WIRE_BODY && MODL->selsize > 1) {
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    if (xyz[3*ipnt  ] < xmin) {
                        xmin     = xyz[ 3*ipnt  ];
                        xmin_dot = dxyz[3*ipnt  ];
                    }
                    if (xyz[3*ipnt  ] > xmax) {
                        xmax     = xyz[ 3*ipnt  ];
                        xmax_dot = dxyz[3*ipnt  ];
                    }
                    if (xyz[3*ipnt+1] < ymin) {
                        ymin     = xyz[ 3*ipnt+1];
                        ymin_dot = dxyz[3*ipnt+1];
                    }
                    if (xyz[3*ipnt+1] > ymax) {
                        ymax     = xyz[ 3*ipnt+1];
                        ymax_dot = dxyz[3*ipnt+1];
                    }
                    if (xyz[3*ipnt+2] < zmin) {
                        zmin     = xyz[ 3*ipnt+2];
                        zmin_dot = dxyz[3*ipnt+2];
                    }
                    if (xyz[3*ipnt+2] > zmax) {
                        zmax     = xyz[ 3*ipnt+2];
                        zmax_dot = dxyz[3*ipnt+2];
                    }
                }

            /* if there is only one Edge in sellist, *min refers to beginning
               of the Edge and *max refers to the end of the Edge */
            } else {
                xmin     = xyz[        0];
                xmin_dot = dxyz[       0];
                xmax     = xyz[ 3*npnt-3];
                xmax_dot = dxyz[3*npnt-3];
                ymin     = xyz[        1];
                ymin_dot = dxyz[       1];
                ymax     = xyz[ 3*npnt-2];
                ymax_dot = dxyz[3*npnt-2];
                zmin     = xyz[        2];
                zmin_dot = dxyz[       2];
                zmax     = xyz[ 3*npnt-1];
                zmax_dot = dxyz[3*npnt-1];
            }

            for (ipnt = 1; ipnt < npnt; ipnt++) {
                x0     = xyz[ 3*ipnt-3];
                x0_dot = dxyz[3*ipnt-3];
                y0     = xyz[ 3*ipnt-2];
                y0_dot = dxyz[3*ipnt-2];
                z0     = xyz[ 3*ipnt-1];
                z0_dot = dxyz[3*ipnt-1];

                x1     = xyz[ 3*ipnt  ];
                x1_dot = dxyz[3*ipnt  ];
                y1     = xyz[ 3*ipnt+1];
                y1_dot = dxyz[3*ipnt+1];
                z1     = xyz[ 3*ipnt+2];
                z1_dot = dxyz[3*ipnt+2];

                xcen     = x0     + x1;
                xcen_dot = x0_dot + x1_dot;

                ycen     = y0     + y1;
                ycen_dot = y0_dot + y1_dot;

                zcen     = z0     + z1;
                zcen_dot = z0_dot + z1_dot;

                dx     = x1     - x0;
                dx_dot = x1_dot - x0_dot;

                dy     = y1     - y0;
                dy_dot = y1_dot - y0_dot;

                dz     = z1     - z0;
                dz_dot = z1_dot - z0_dot;

                ll     = sqrt(dx * dx     + dy * dy     + dz * dz    );
                ll_dot =     (dx * dx_dot + dy * dy_dot + dz * dz_dot) / ll;

                len      += ll;
                len_dot  += ll_dot;

                xcg      += xcen     * ll;
                xcg_dot  += xcen_dot * ll + xcen * ll_dot;

                ycg      += ycen     * ll;
                ycg_dot  += ycen_dot * ll + ycen * ll_dot;

                zcg      += zcen     * ll;
                zcg_dot  += zcen_dot * ll + zcen * ll_dot;

                Ixx      += ll     * (ycen * ycen     + zcen * zcen    );
                Ixx_dot  += ll_dot * (ycen * ycen     + zcen * zcen    )
                         +  ll * 2 * (ycen * ycen_dot + zcen * zcen_dot);

                Iyy      += ll     * (xcen * xcen     + zcen * zcen    );
                Iyy_dot  += ll_dot * (xcen * xcen     + zcen * zcen    )
                         +  ll * 2 * (xcen * xcen_dot + zcen * zcen_dot);

                Izz      += ll     * (xcen * xcen     + ycen * ycen    );
                Izz_dot  += ll_dot * (xcen *xcen      + ycen * ycen    )
                         +  ll * 2 * (xcen * xcen_dot + ycen * ycen_dot);

                Ixy      -= ll     * xcen * ycen;
                Ixy_dot  -= ll_dot * xcen * ycen + ll * xcen_dot * ycen + ll * xcen * ycen_dot;

                Ixz      -= ll     * xcen * zcen;
                Ixz_dot  -= ll_dot * xcen * zcen + ll * xcen_dot * zcen + ll * xcen * zcen_dot;

                Iyz      -= ll     * ycen * zcen;
                Iyz_dot  -= ll_dot * ycen * zcen + ll * ycen_dot * zcen + ll * ycen * zcen_dot;
            }

            SPRINT2(2, "after iedge %5d  (npnt=%5d)", iedge, npnt);
            SPRINT2(2, "        xmin   %16.6f  %16.6f", xmin, xmin_dot);
            SPRINT2(2, "        xmax   %16.6f  %16.6f", xmax, xmax_dot);
            SPRINT2(2, "        ymin   %16.6f  %16.6f", ymin, ymin_dot);
            SPRINT2(2, "        ymax   %16.6f  %16.6f", ymax, ymax_dot);
            SPRINT2(2, "        zmin   %16.6f  %16.6f", zmin, zmin_dot);
            SPRINT2(2, "        zmax   %16.6f  %16.6f", zmax, zmax_dot);
            SPRINT2(2, "        area   %16.6f  %16.6f", area, area_dot);
            SPRINT2(2, "        vol    %16.6f  %16.6f", vol,  vol_dot );
            SPRINT2(2, "        xcg    %16.6f  %16.6f", xcg,  xcg_dot );
            SPRINT2(2, "        ycg    %16.6f  %16.6f", ycg,  ycg_dot );
            SPRINT2(2, "        zcg    %16.6f  %16.6f", zcg,  zcg_dot );
            SPRINT2(2, "        Ixx    %16.6f  %16.6f", Ixx,  Ixx_dot );
            SPRINT2(2, "        Iyy    %16.6f  %16.6f", Iyy,  Iyy_dot );
            SPRINT2(2, "        Izz    %16.6f  %16.6f", Izz,  Izz_dot );
            SPRINT2(2, "        Ixy    %16.6f  %16.6f", Ixy,  Ixy_dot );
            SPRINT2(2, "        Ixz    %16.6f  %16.6f", Ixz,  Ixz_dot );
            SPRINT2(2, "        Iyz    %16.6f  %16.6f", Iyz,  Iyz_dot );

            count++;
        }

        /* compute centroid (since xcg*length, ... was accumulated above) */
        xcg     /= len;
        xcg_dot  = xcg_dot / len - len_dot * xcg / len;
        ycg     /= len;
        ycg_dot  = ycg_dot / len - len_dot * ycg / len;
        zcg     /= len;
        zcg_dot  = zcg_dot / len - len_dot * zcg / len;

        /* normalize (since we actually accumulated twice the xceny, ...) */
        xcg     /=  2;
        xcg_dot /=  2;
        ycg     /=  2;
        ycg_dot /=  2;
        zcg     /=  2;
        zcg_dot /=  2;
        Ixx     /=  4;
        Ixx_dot /=  4;
        Iyy     /=  4;
        Iyy_dot /=  4;
        Izz     /=  4;
        Izz_dot /=  4;
        Ixy     /=  4;
        Ixy_dot /=  4;
        Ixz     /=  4;
        Ixz_dot /=  4;
        Iyz     /=  4;
        Iyz_dot /= 4;

        /* apply parallel axis theorem */
        Ixx     -= len     * (                ycg * ycg     + zcg * zcg    );
        Ixx_dot -= len_dot * (                ycg * ycg     + zcg * zcg    )
                 + len * 2 * (                ycg * ycg_dot + zcg * zcg_dot);

        Iyy     -= len     * (xcg * xcg                     + zcg * zcg    );
        Iyy_dot -= len_dot * (xcg * xcg                     + zcg * zcg    )
                 + len * 2 * (xcg * xcg_dot                 + zcg * zcg_dot);

        Izz     -= len     * (xcg * xcg     + ycg * ycg                    );
        Izz_dot -= len_dot * (xcg * xcg     + ycg * ycg                    )
                 + len * 2 * (xcg * xcg_dot + ycg * ycg_dot                );

        Ixy     += len     * xcg * ycg;
        Ixy_dot += len_dot * xcg * ycg + len * xcg_dot * ycg + len * xcg * ycg_dot;

        Ixz     += len     * xcg * zcg;
        Ixz_dot += len_dot * xcg * zcg + len * xcg_dot * zcg + len * xcg * zcg_dot;

        Iyz     += len     * ycg * zcg;
        Iyz_dot += len_dot * ycg * zcg + len * ycg_dot * zcg + len * ycg * zcg_dot;

    /* NodeBody or a group of Nodes */
    } else if (MODL->body[ibody].botype == OCSM_NODE_BODY || MODL->seltype == 0) {
        for (inode = 1; inode < MODL->body[ibody].nnode; inode++) {
            if (MODL->body[ibody].botype != OCSM_WIRE_BODY) {
                okay = 0;
                for (ilist = 0; ilist < MODL->selsize; ilist++) {
                    if (inode == MODL->sellist[ilist]) {
                        okay = 1;
                        break;
                    }
                }

                if (okay == 0) continue;
            }

            xyz1[0] = MODL->body[ibody].node[inode].x;
            xyz1[1] = MODL->body[ibody].node[inode].y;
            xyz1[2] = MODL->body[ibody].node[inode].z;

            status = ocsmGetTessVel(MODL, ibody, OCSM_NODE, inode, &dxyz);
            CHECK_STATUS(ocsmGetTessVels);

            if (xyz1[0] < xmin) {
                xmin     = xyz1[0];
                xmin_dot = dxyz[0];
            }
            if (xyz1[0] > xmax) {
                xmax     = xyz1[0];
                xmax_dot = dxyz[0];
            }
            if (xyz1[1] < ymin) {
                ymin     = xyz1[1];
                ymin_dot = dxyz[1];
            }
            if (xyz1[1] > ymax) {
                ymax     = xyz1[1];
                ymax_dot = dxyz[1];
            }
            if (xyz1[2] < zmin) {
                zmin     = xyz1[2];
                zmin_dot = dxyz[2];
            }
            if (xyz1[2] > zmax) {
                zmax     = xyz1[2];
                zmax_dot = dxyz[2];
            }

            xcg      += xyz1[0];
            xcg_dot  += dxyz[0];
            ycg      += xyz1[1];
            ycg_dot  += dxyz[1];
            zcg      += xyz1[2];
            zcg_dot  += dxyz[2];

            count++;
        }

        xcg     /= count;
        xcg_dot /= count;
        ycg     /= count;
        ycg_dot /= count;
        zcg     /= count;
        zcg_dot /= count;
    } else {
        printf("WE SHOULD NOT GET HERE 4\n");
        exit(0);
    }

    SPRINT1(2, "        count  %d",             count);
    SPRINT2(2, "        xmin   %16.6f  %16.6f", xmin, xmin_dot);
    SPRINT2(2, "        xmax   %16.6f  %16.6f", xmax, xmax_dot);
    SPRINT2(2, "        ymin   %16.6f  %16.6f", ymin, ymin_dot);
    SPRINT2(2, "        ymax   %16.6f  %16.6f", ymax, ymax_dot);
    SPRINT2(2, "        zmin   %16.6f  %16.6f", zmin, zmin_dot);
    SPRINT2(2, "        zmax   %16.6f  %16.6f", zmax, zmax_dot);
    SPRINT2(2, "        length %16.6f  %16.6f", len,  len_dot );
    SPRINT2(2, "        area   %16.6f  %16.6f", area, area_dot);
    SPRINT2(2, "        volume %16.6f  %16.6f", vol,  vol_dot );
    SPRINT2(2, "        xcg    %16.6f  %16.6f", xcg,  xcg_dot );
    SPRINT2(2, "        ycg    %16.6f  %16.6f", ycg,  ycg_dot );
    SPRINT2(2, "        zcg    %16.6f  %16.6f", zcg,  zcg_dot );
    SPRINT2(2, "        Ixx    %16.6f  %16.6f", Ixx,  Ixx_dot );
    SPRINT2(2, "        Iyy    %16.6f  %16.6f", Iyy,  Iyy_dot );
    SPRINT2(2, "        Izz    %16.6f  %16.6f", Izz,  Izz_dot );
    SPRINT2(2, "        Ixy    %16.6f  %16.6f", Ixy,  Ixy_dot );
    SPRINT2(2, "        Ixz    %16.6f  %16.6f", Ixz,  Ixz_dot );
    SPRINT2(2, "        Iyz    %16.6f  %16.6f", Iyz,  Iyz_dot );

    /* store the velocities in the AT parameters */
    status = ocsmFindPmtr(MODL, "@xmin", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, xmin_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@xmax", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, xmax_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@ymin", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, ymin_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@ymax", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, ymax_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@zmin", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, zmin_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@zmax", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, zmax_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@length", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, len_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@area", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, area_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@volume", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, vol_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@xcg", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, xcg_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@ycg", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, ycg_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@zcg", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, zcg_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Ixx", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Ixx_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Ixy", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Ixy_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Ixz", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Ixz_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Iyx", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Ixy_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Iyy", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Iyy_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Iyz", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Iyz_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Izx", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Ixz_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Izy", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Iyz_dot);
    CHECK_STATUS(ocsmSetVelD);

    status = ocsmFindPmtr(MODL, "@Izz", OCSM_LOCALVAR, 1, 1, &ipmtr);
    CHECK_STATUS(ocsmFindPmtr);
    status = ocsmSetVelD( MODL, ipmtr, 1, 1, Izz_dot);
    CHECK_STATUS(ocsmSetVelD);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   convertToBSplines - conert Body to BSpline with transformation     *
 *                                                                      *
 ************************************************************************
 */

int
convertToBSplines(ego    inbody,        /* (in)  input Body */
                 double mat[],          /* (in)  transformation matrix */
                 ego    *ebody)         /* (out) pointer to output Body */
{
    int     status = EGADS_SUCCESS;

    int     oclass, mtype, ichild, nchild, *senses;
    int     inode, nnode, iedge, nedge, iface, nface, iloop, nloop, ishell, nshell, *ivals, i, sense;
    int     oclass1, mtype1, nchild1, *senses1, jedge, periodic;
    double  xyz[18], xyz2[18], *rvals, trange[2];
    double  uv[18], range[4], tt[2], swap;
    ego     context, eref, *echilds, *enodes_orig=NULL, *eedges_orig=NULL, *efaces_orig=NULL, *eloops_orig=NULL, *eshells_orig=NULL;
    ego     *enodes=NULL, *ecurves=NULL, *eedges=NULL, *esurfaces=NULL, *efaces=NULL, *eshells=NULL;
    ego     *eloops2=NULL, *eloops=NULL, *efoo=NULL;
    ego     ecurve, esurface, etemp[2], topRef, prev, next;
            ego *echilds1;

    ROUTINE(convertToBSplines);

    /* --------------------------------------------------------------- */

    status = EG_getContext(inbody, &context);
    CHECK_STATUS(EG_getContext);

    /* get the Nodes, Edges, and Faces associated with the input Body */
    status = EG_getBodyTopos(inbody, NULL, NODE, &nnode, &enodes_orig);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(inbody, NULL, EDGE, &nedge, &eedges_orig);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(inbody, NULL, FACE, &nface, &efaces_orig);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(inbody, NULL, SHELL, &nshell, &eshells_orig);
    CHECK_STATUS(EG_getBodyTopos);

    /* get storage for the new Nodes, Curves, Edges, Surfaces, Faces, and Shells */
    MALLOC(enodes,    ego, nnode );
    MALLOC(ecurves,   ego, nedge );
    MALLOC(eedges,    ego, nedge );
    MALLOC(esurfaces, ego, nface );
    MALLOC(efaces,    ego, nface );
    MALLOC(eshells,   ego, nshell);

    /* make new Nodes by transforming the original Nodes */
    for (inode = 0; inode < nnode; inode++) {
        SPLINT_CHECK_FOR_NULL(enodes_orig );

        status = EG_getTopology(enodes_orig[inode], &eref, &oclass, &mtype,
                                xyz2, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        xyz[0] = mat[ 0] * xyz2[0] + mat[ 1] * xyz2[1] + mat[ 2] * xyz2[2] + mat[ 3];
        xyz[1] = mat[ 4] * xyz2[0] + mat[ 5] * xyz2[1] + mat[ 6] * xyz2[2] + mat[ 7];
        xyz[2] = mat[ 8] * xyz2[0] + mat[ 9] * xyz2[1] + mat[10] * xyz2[2] + mat[11];

        status = EG_makeTopology(context, NULL, NODE, 0, xyz, 0, NULL, NULL, &enodes[inode]);
        CHECK_STATUS(EG_makeTopology);

        status = EG_attributeDup(enodes_orig[inode], enodes[inode]);
        CHECK_STATUS(EG_attributeDup);
    }

    /* special processing for NodeBody */
    if (nnode == 1) {
        MALLOC(eloops, ego, 1);

        trange[0] = 0;
        trange[1] = 1;
        sense     = SFORWARD;

        status = EG_makeTopology(context, NULL, EDGE, DEGENERATE, trange, 1, enodes, &sense, &eedges[0]);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(context, NULL, LOOP, CLOSED, NULL, 1, eedges, &sense, eloops);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(context, NULL, BODY, WIREBODY, NULL, 1, eloops, NULL, ebody);
        CHECK_STATUS(EG_makeTopology);

        FREE(eloops);

        goto cleanup;
    }

    /* make new Edges by transforming the original Edges */
    for (iedge = 0; iedge < nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(eedges_orig );

        status = EG_getTopology(eedges_orig[iedge], &eref, &oclass, &mtype,
                                xyz, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        if (mtype == DEGENERATE) {
            eedges[iedge] = NULL;
            continue;
        }

        status = EG_getInfo(eref, &oclass, &mtype, &topRef, &prev, &next);
        CHECK_STATUS(EG_getInfo);

        if (mtype != BSPLINE) {
            status = EG_convertToBSpline(eedges_orig[iedge], &ecurve);
            CHECK_STATUS(EG_convertToBSpline);

            trange[0] = 0;    // signal to use BSPLINE range
            trange[1] = 0;
        } else {
            status = EG_copyObject(eref, NULL, &ecurve);
            CHECK_STATUS(EG_copyObject);

            trange[0] = xyz[0];
            trange[1] = xyz[1];
        }

        status = EG_getGeometry(ecurve, &oclass, &mtype, &eref, &ivals, &rvals);
        CHECK_STATUS(EG_getGeometry);

        for (i = ivals[3]; i < ivals[3]+3*ivals[2]; i+=3) {
            xyz2[0] = rvals[i  ];
            xyz2[1] = rvals[i+1];
            xyz2[2] = rvals[i+2];

            rvals[i  ] = mat[ 0] * xyz2[0] + mat[ 1] * xyz2[1] + mat[ 2] * xyz2[2] + mat[ 3];
            rvals[i+1] = mat[ 4] * xyz2[0] + mat[ 5] * xyz2[1] + mat[ 6] * xyz2[2] + mat[ 7];
            rvals[i+2] = mat[ 8] * xyz2[0] + mat[ 9] * xyz2[1] + mat[10] * xyz2[2] + mat[11];
        }

        status = EG_makeGeometry(context, CURVE, BSPLINE, NULL, ivals, rvals, &ecurves[iedge]);
        CHECK_STATUS(EG_makeGeometry);

        EG_free(ivals);
        EG_free(rvals);

        status = EG_getTopology(eedges_orig[iedge], &eref, &oclass, &mtype,
                                xyz, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        etemp[0] = enodes[EG_indexBodyTopo(inbody, echilds[       0])-1];
        etemp[1] = enodes[EG_indexBodyTopo(inbody, echilds[nchild-1])-1];

        /* use BSPLINE range if a new BSPLINE was made */
        if (trange[0] == 0 && trange[1] == 0) {
            status = EG_getRange(ecurves[iedge], trange, &periodic);
            CHECK_STATUS(EG_getRange);
        }

        status = EG_makeTopology(context, ecurves[iedge], oclass, mtype, trange,
                                 2, etemp, NULL, &eedges[iedge]);
        CHECK_STATUS(EG_makeTopology);

        status = EG_attributeDup(eedges_orig[iedge], eedges[iedge]);
        CHECK_STATUS(EG_attributeDup);
    }

    /* special processing for WireBody */
    if (nface == 0) {
        status = EG_getBodyTopos(inbody, NULL, LOOP, &nloop, &eloops_orig);
        CHECK_STATUS(EG_getBodyTopos);

        SPLINT_CHECK_FOR_NULL(eloops_orig);

        MALLOC(eloops, ego, nloop);

        status = EG_getTopology(eloops_orig[0], &eref, &oclass, &mtype,
                                xyz, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        MALLOC(efoo, ego, nchild);

        for (iedge = 0; iedge < nchild; iedge++) {
            efoo[iedge] = eedges[EG_indexBodyTopo(inbody, echilds[iedge])-1];
        }

        status = EG_makeTopology(context, NULL, oclass, mtype,
                                 xyz, nchild, efoo, senses, &eloops[0]);
        CHECK_STATUS(EG_makeTopology);

        FREE(efoo  );

        status = EG_makeTopology(context, NULL, BODY, WIREBODY,
                                 NULL, 1, eloops, senses, ebody);
        CHECK_STATUS(EG_makeTopology);

        FREE(eloops);

        goto cleanup;
    }

    /* make new Faces by transforming the original Faces */
    for (iface = 0; iface < nface; iface++) {
        SPLINT_CHECK_FOR_NULL(efaces_orig );

        status = EG_getTopology(efaces_orig[iface], &eref, &oclass, &mtype,
                                xyz, &nloop, &eloops2, &senses);
        CHECK_STATUS(EG_getTopology);

        SPLINT_CHECK_FOR_NULL(eloops2);

        status = EG_getInfo(eref, &oclass, &mtype, &topRef, &prev, &next);
        CHECK_STATUS(EG_getInfo);

        if (mtype != BSPLINE) {
            status = EG_convertToBSpline(efaces_orig[iface], &esurface);
            CHECK_STATUS(EG_convertToBSpline);
        } else {
            status = EG_copyObject(eref, NULL, &esurface);
            CHECK_STATUS(EG_copyObject);
        }

        status = EG_getGeometry(esurface, &oclass, &mtype, &eref, &ivals, &rvals);
        CHECK_STATUS(EG_getGeometry);

        for (i = ivals[3]+ivals[6]; i < ivals[3]+ivals[6]+3*ivals[2]*ivals[5]; i+=3) {
            xyz2[0] = rvals[i  ];
            xyz2[1] = rvals[i+1];
            xyz2[2] = rvals[i+2];

            rvals[i  ] = mat[ 0] * xyz2[0] + mat[ 1] * xyz2[1] + mat[ 2] * xyz2[2] + mat[ 3];
            rvals[i+1] = mat[ 4] * xyz2[0] + mat[ 5] * xyz2[1] + mat[ 6] * xyz2[2] + mat[ 7];
            rvals[i+2] = mat[ 8] * xyz2[0] + mat[ 9] * xyz2[1] + mat[10] * xyz2[2] + mat[11];
        }

        status = EG_makeGeometry(context, SURFACE, BSPLINE, NULL, ivals, rvals, &esurfaces[iface]);
        CHECK_STATUS(EG_makeGeometry);

        EG_free(ivals);
        EG_free(rvals);

        /* process the Loops */
        MALLOC(eloops, ego, nloop);

        for (iloop = 0; iloop < nloop; iloop++) {
            status = EG_getTopology(eloops2[iloop], &eref, &oclass, &mtype,
                                    xyz, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            MALLOC(efoo, ego, 2*nchild);

            /* process each Edge in each Loop (but store NULLs for DEGENERATE Edges */
            for (iedge = 0; iedge < nchild; iedge++) {
                status = EG_getTopology(echilds[iedge], &eref, &oclass1, &mtype1,
                                        xyz, &nchild1, &echilds1, &senses1);
                CHECK_STATUS(EG_getTopology);

                if (mtype1 != DEGENERATE) {
                    efoo[iedge] = eedges[EG_indexBodyTopo(inbody, echilds[iedge])-1];

                    status = EG_otherCurve(esurfaces[iface], efoo[iedge], 0, &efoo[iedge+nchild]);
                    CHECK_STATUS(EG_otherCurve);
                } else {
                    efoo[iedge       ] = NULL;
                    efoo[iedge+nchild] = NULL;
                }
            }

            /* if any of the Edges were NULL (DEGENERATE), proces them now */
            for (iedge = 0; iedge < nchild; iedge++) {
                if (efoo[iedge] != NULL) continue;

                /* Edge before iedge */
                if (iedge > 0) {
                    jedge = iedge - 1;
                } else {
                    jedge = nchild - 1;
                }

                status = EG_getTopology(efoo[jedge], &eref, &oclass1, &mtype1,
                                        xyz, &nchild1, &echilds1, &senses1);
                CHECK_STATUS(EG_getTopology);

                status = EG_getRange(efoo[jedge], tt, &periodic);
                CHECK_STATUS(EG_getRange);

                if (senses[jedge] == SFORWARD) {
                    etemp[0] = echilds1[1];
                    status = EG_evaluate(efoo[jedge+nchild], &tt[1], &uv[0]);
                    CHECK_STATUS(EG_evaluate);
                } else {
                    etemp[0] = echilds1[0];
                    status = EG_evaluate(efoo[jedge+nchild], &tt[0], &uv[0]);
                    CHECK_STATUS(EG_evaluate);
                }

                /* Edge after iedge */
                if (iedge < nchild-1) {
                    jedge = iedge + 1;
                } else {
                    jedge = 0;
                }

                status = EG_getRange(efoo[jedge], tt, &periodic);
                CHECK_STATUS(EG_getRange);

                if (senses[jedge] == SFORWARD) {
                    status = EG_evaluate(efoo[jedge+nchild], &tt[0], &uv[2]);
                    CHECK_STATUS(EG_evaluate);
                } else {
                    status = EG_evaluate(efoo[jedge+nchild], &tt[1], &uv[2]);
                    CHECK_STATUS(EG_evaluate);
                }

                /* make the DEGENERATE Edge and associated PCurve */
                if (senses[iedge] != SFORWARD) {
                    swap  = uv[2];
                    uv[2] = uv[0];
                    uv[0] = swap;

                    swap  = uv[3];
                    uv[3] = uv[1];
                    uv[1] = swap;
                }

                uv[2] -= uv[0];
                uv[3] -= uv[1];

                range[0] = 0;
                range[1] = sqrt(uv[2]*uv[2] + uv[3]*uv[3]);
                sense    = SFORWARD;

                status = EG_makeTopology(context, NULL, EDGE, DEGENERATE, range, 1, etemp, &sense, &efoo[iedge]);
                CHECK_STATUS(EG_makeTopology);

                status = EG_makeGeometry(context, PCURVE, LINE, NULL, NULL, uv, &efoo[iedge+nchild]);
                CHECK_STATUS(EG_makeGeometry);
            }

            /* make the Loop */
            status = EG_makeTopology(context, esurfaces[iface], oclass, mtype,
                                     NULL, nchild, efoo, senses, &eloops[iloop]);
            CHECK_STATUS(EG_makeTopology);

            FREE(efoo);
        }

        /* make the Face */
        status = EG_getTopology(efaces_orig[iface], &eref, &oclass, &mtype,
                                xyz, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        status = EG_makeTopology(context, esurfaces[iface], oclass, mtype,
                                 xyz, nloop, eloops, senses, &efaces[iface]);
        if (status < SUCCESS) {
            SPRINT1(0, "ERROR:: problem remaking iface=%d", iface+1);
            SPRINT1(0, "efaces_orig[%d]:", iface);
            ocsmPrintEgo(efaces_orig[iface]);

            for (iloop = 0; iloop < nloop; iloop++) {
                SPRINT1(0, "eloops[%d]:", iloop);
                ocsmPrintEgo(eloops[iloop]);
            }

            FREE(eloops);
            goto cleanup;
        }

        FREE(eloops);

        status = EG_attributeDup(efaces_orig[iface], efaces[iface]);
        CHECK_STATUS(EG_attributeDup);
    }

    /* make the SHELLs */
    for (ishell = 0; ishell < nshell; ishell++) {
        SPLINT_CHECK_FOR_NULL(eshells_orig);

        status = EG_getTopology(eshells_orig[ishell], &eref, &oclass, &mtype,
                                xyz, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        MALLOC(efoo, ego, nchild);

        for (ichild = 0; ichild < nchild; ichild++) {
            iface = EG_indexBodyTopo(inbody, echilds[ichild]) - 1;
            efoo[ichild] = efaces[iface];
        }

        status = EG_makeTopology(context, NULL, oclass, mtype,
                                 xyz, nchild, efoo, senses, &eshells[ishell]);
        CHECK_STATUS(EG_makeTopology);
    }

    /* finally make the Body */
    status = EG_getTopology(inbody, &eref, &oclass, &mtype,
                            xyz, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    if (mtype == SHEETBODY || mtype == SOLIDBODY) {
        status = EG_makeTopology(context, NULL, oclass, mtype,
                                 xyz, nchild, eshells, senses, ebody);
        CHECK_STATUS(EG_makeTopology);
    } else if (mtype == FACEBODY && nchild == 1) {
        status = EG_makeTopology(context, NULL, oclass, mtype,
                                 xyz, nchild, efaces, senses, ebody);
        CHECK_STATUS(EG_makeTopology);
    } else {
        SPRINT3(2, " convertToBSpline: oclass=%d, mtype=%d, nchild=%d", oclass, mtype, nchild);
        status = EGADS_TOPOERR;
        goto cleanup;
    }

    status = EG_attributeDup(inbody, *ebody);
    CHECK_STATUS(EG_attributeDup);

cleanup:
    if (enodes_orig  != NULL) EG_free(enodes_orig );
    if (eedges_orig  != NULL) EG_free(eedges_orig );
    if (eloops_orig  != NULL) EG_free(eloops_orig );
    if (efaces_orig  != NULL) EG_free(efaces_orig );
    if (eshells_orig != NULL) EG_free(eshells_orig);

    FREE(enodes   );
    FREE(ecurves  );
    FREE(eedges   );
    FREE(esurfaces);
    FREE(efaces   );
    FREE(eshells  );
    FREE(eloops   );
    FREE(efoo     );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   createPerturbation - create perturbed body for finite differencing *
 *                                                                      *
 ************************************************************************
 */

static int
createPerturbation(modl_T *MODL)        /* (in)  pointer to base MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ibody, nerror, itime, ntime=20;
    int       ipmtr, irow, icol, irc, builtTo, nbody_ptrb;
    double    *unew=NULL, *vnew=NULL, *uv_new=NULL, *xyz_new=NULL;
    modl_T    *PTRB = NULL;
    ego       newBody;

    void      *modl_ptrb=NULL;

    ROUTINE(createPerturbation);

    /* --------------------------------------------------------------- */

    /* if we found an error in a previous attempt to create a perturbation,
       return immediately (note: set MODL->dtime=0 before call) */
    if (MODL->dtime == -2) {
        goto cleanup;
    }

    /* if perturb exists, we may be able to return immediately.  this is because the
       mapping is generated just in time in createTessVels */
    if (MODL->perturb != NULL) {
        goto cleanup;
    }

    /* make sure the last Body on the stack is tessellated */
    status = ocsmTessellate(MODL, MODL->nbody);
    CHECK_STATUS(ocsmTessellate);

    /* try up to ntime increasingly smaller time steps */
    for (itime = 0; itime < ntime; itime++) {
        SPRINT1(1, "    MODL->dtime=%15.10f\n", MODL->dtime);
        nerror = 0;

        /* make a copy and set its driving parameters to "base + dtime * dot" */
        status = ocsmCopy(MODL, &modl_ptrb);
        CHECK_STATUS(ocsmCopy);

        PTRB = modl_ptrb;

        SPLINT_CHECK_FOR_NULL(PTRB);

        MODL->perturb  = PTRB;
        PTRB->basemodl = MODL;

        for (ipmtr = 1; ipmtr <= PTRB->npmtr; ipmtr++) {
            if (PTRB->pmtr[ipmtr].type == OCSM_DESPMTR) {
                irc = 0;
                for (irow = 0; irow < PTRB->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 0; icol < PTRB->pmtr[ipmtr].ncol; icol++) {
                        PTRB->pmtr[ipmtr].value[irc] += MODL->dtime * PTRB->pmtr[ipmtr].dot[irc];
                        PTRB->pmtr[ipmtr].dot[  irc]  = 0;
                        irc++;
                    }
                }
            }
        }

        /* recheck (this is needed to make sure that the indentation is updated) */
        status = ocsmCheck(PTRB);
        CHECK_STATUS(ocsmCheck);

        /* rebuild the perturbed copy */
        nbody_ptrb = 0;
        SPRINT0(2, ">>>\n>>> building perturbation\n>>>");
        status = ocsmBuild(PTRB, MODL->ibrch, &builtTo, &nbody_ptrb, NULL);

        if (status != SUCCESS) {
            SPRINT2(2, "WARNING:: ocsmBuild() -> status=%d, buildTo=%d\n", status, builtTo);
            (MODL->nwarn)++;
            nerror++;
        }

        /* check that base and ptrb have same number of Bodys */
        if (nerror == 0) {
            if (MODL->nbody != PTRB->nbody) {
                SPRINT0(1, "WARNING:: Base and perturbed models have different nbody");
                SPRINT1(1, "          MODL->nbody = %d", MODL->nbody);
                SPRINT1(1, "          PTRB->nbody = %d", PTRB->nbody);
                (MODL->nwarn)++;
            }
        }

        /* check that base and ptrb Bodys match topologically */
        if (nerror == 0) {
            for (ibody = 1; ibody <= MODL->nbody; ibody++) {
                if (MODL->body[ibody].onstack != 1) continue;
                if (MODL->body[ibody].botype  == OCSM_NODE_BODY) continue;

//$$$           for now, assume that WireBodys map without checking
                if        (MODL->body[ibody].botype == OCSM_WIRE_BODY &&
                           PTRB->body[ibody].botype == OCSM_WIRE_BODY   ) {
                    status  = SUCCESS;
                    newBody = NULL;

                /* do actual check for SolidBodys */
                } else {
                    status = EG_mapBody(MODL->body[ibody].ebody, PTRB->body[ibody].ebody,
                                        "_faceID", &newBody);
                }

                /* if topologes match, we can proceed */
                if (status == SUCCESS) {
                    if (newBody != NULL) {

                        // &&&&& do we need to clean up udp cache here?

                        EG_deleteObject(PTRB->body[ibody].ebody);
                        PTRB->body[ibody].ebody = newBody;

                        status = finishBody(PTRB, ibody);
                        CHECK_STATUS(finishBody);
                    }

                    /* tag that the body has been mapped */
                    status = EG_attributeAdd(PTRB->body[ibody].ebody, "__mapBody__", ATTRINT,
                                             1, &ibody, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                /* otherwise we have an error at this dtime */
                } else {
                    SPRINT2(2, "WARNING:: EG_mapBody(ibody=%d) -> status=%d\n", ibody, status);
                    (MODL->nwarn)++;
                    nerror++;
                    break;
                }
            }
        }

        /* if there are no errors above, then we do not need to look at any more times */
        if (nerror == 0) {

            /* update the velocity of the OUTPMTRs based upon the perturbation */
            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                if (MODL->pmtr[ipmtr].type != OCSM_OUTPMTR) continue;

                irc = 0;
                for (irow = 0; irow < PTRB->pmtr[ipmtr].nrow; irow++) {
                    for (icol = 0; icol < PTRB->pmtr[ipmtr].ncol; icol++) {
                        MODL->pmtr[ipmtr].dot[irc] = (PTRB->pmtr[ipmtr].value[irc] - MODL->pmtr[ipmtr].value[irc]) / MODL->dtime;
                        irc++;
                    }
                }
            }

            break;

        /* if there are more times to try, flip and decrease time step and try again */
        } else if (itime < ntime-1) {
            status = ocsmFree(PTRB);
            CHECK_STATUS(ocsmFree);

            MODL->perturb = NULL;
            MODL->dtime /= -2;

        /* otherwise we could not find a sufficiently small time step, so return an error  */
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "dtime=%15.10f is not sufficiently small", MODL->dtime);

            MODL->dtime = -2;      /* signify a problem */
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }
    }

cleanup:
    FREE(xyz_new);
    FREE(uv_new);
    FREE(unew);
    FREE(vnew);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   createTessVels - create tessellation velocities                    *
 *                                                                      *
 ************************************************************************
 */

int
createTessVels(modl_T *MODL,            /* (in)  pointer to base MODL */
               int    ibody)            /* (in)  Body index (1:nbody) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nnode, inode, nedge, iedge, nface, iface, ipnt, jpnt, ntri, periodic;
    int       ibeg, iend, npnt_edge, npnt_face, nbnd, iskip;
    int       nloop, npnt_egg, nbnd_egg, ntri_egg;
    int       itri, jtri, ip0, ip1, ip2, iter, niter;
    int       npnt_modl, npnt_ptrb, ntri_modl, ntri_ptrb;
    int       oclass, mtype, nchild, *senses, iedge2, iface2, nframe;
    int       attrType, attrLen;
    CINT      *ptype, *pindx, *tris, *tric, *tris2, *nlast1, *p_egg, *tris_egg;
    CINT      *tempIlist;
    double    dleft[18], data[18], dxyz[3], mat[4], rhs[2];
    double    dvbeg, dvend, dv, frac, t, trange[2];
    double    normx, normy, normz, norm, dotp, errx, erry, errz;
    double    *duvface, velmax, phi, umin, umax, vmin, vmax, srad2, toler;
    double    u0, u1, u2, ubar, v0, v1, v2, vbar, den;
    double    duavg, dvavg, *ddu=NULL, *ddv=NULL, *nnn=NULL, *fac=NULL;
    double    *weights=NULL, *duv_new=NULL;
    double    tedge2, uvface2[2], uvnew[2];
    double    *dudue=NULL, *dvdue=NULL, *dudve=NULL, *dvdve=NULL;
    CDOUBLE   *xyz_edge, *t_edge, *xyz_face, *uv_face, *uv_egg;
    CDOUBLE   *xyz_modl, *xyz_ptrb, *uv_modl, *uv_ptrb;
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;
    void      *eggdata, *eggdata_new;
    ego       ebody, etess, *enodes=NULL, *eedges=NULL, *efaces=NULL;
    ego       eedge2, eface2, efacenew, eref, *echilds;
    modl_T    *PTRB;
    body_T    body;
    const egBary *bary;

    ROUTINE(createTessVels);

    /* --------------------------------------------------------------- */

#if PRINT_CALLHISTORY > 0
    for (i_callHistory = 0; i_callHistory < indent_callHistory; i_callHistory++) fprintf(fp_callHistory, ".  ");
    fprintf(fp_callHistory, "createTessVels(ibody=%2d)\n", ibody);
    indent_callHistory++;
#endif

    SPRINT1(2, "enter createTessVels(ibody=%d)", ibody);

    PTRB = MODL->perturb;

    /* we need a tessellation */
    if (MODL->body[ibody].etess == NULL) {
        status = ocsmTessellate(MODL, ibody);
        CHECK_STATUS(ocsmTessellate);

        /* make sure the perturbed tessellation is updated if it existed */
        if (PTRB != NULL && PTRB->body[ibody].etess != NULL) {
            EG_deleteObject(PTRB->body[ibody].etess);
            PTRB->body[ibody].etess = NULL;
        }
    }

    /* we need a mapped tessellation */
    if (PTRB != NULL && PTRB->body[ibody].etess == NULL) {
        status = ocsmTessellate(PTRB, ibody);
        CHECK_STATUS(ocsmTessellate);
    }

    /* make lists of all Nodes, Edges, and Faces */
    body  = MODL->body[ibody];
    if (body.eebody == NULL) {
        ebody = body.ebody;
        etess = body.etess;

        status = EG_getBodyTopos(ebody, NULL, NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);
    } else {
        ebody = body.eebody;
        etess = body.eetess;

        status = EG_getBodyTopos(ebody, NULL, NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_getBodyTopos(ebody, NULL, EEDGE, &nedge, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_getBodyTopos(ebody, NULL, EFACE, &nface, &efaces);
        CHECK_STATUS(EG_getBodyTopos);
    }

    /* set flag that we have .dxyz's */
    MODL->body[ibody].hasdxyz = 1;

    /* allocate storage for and initialize all velocity storage */
    for (inode = 1; inode <= body.nnode; inode++) {
        MALLOC(body.node[inode].dxyz, double, 3);

        body.node[inode].dxyz[0] = 0;
        body.node[inode].dxyz[1] = 0;
        body.node[inode].dxyz[2] = 0;
    }

    for (iedge = 1; iedge <= body.nedge; iedge++) {
        if (body.edge[iedge].itype == DEGENERATE) continue;

        status = EG_getTessEdge(etess, iedge,
                                &npnt_edge, &xyz_edge, &t_edge);
        CHECK_STATUS(EG_getTessEdge);

        MALLOC(body.edge[iedge].dxyz, double, 3*npnt_edge);
        MALLOC(body.edge[iedge].dt,   double,   npnt_edge);

        for (ipnt = 0; ipnt < npnt_edge; ipnt++) {
            body.edge[iedge].dxyz[3*ipnt  ] = 0;
            body.edge[iedge].dxyz[3*ipnt+1] = 0;
            body.edge[iedge].dxyz[3*ipnt+2] = 0;

            body.edge[iedge].dt[    ipnt  ] = 0;
        }
    }

    for (iface = 1; iface <= body.nface; iface++) {
        status = EG_getTessFace(etess, iface,
                                &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        MALLOC(body.face[iface].dxyz, double, 3*npnt_face);
        MALLOC(body.face[iface].duv,  double, 2*npnt_face);

        for (ipnt = 0; ipnt < npnt_face; ipnt++) {
            body.face[iface].dxyz[3*ipnt  ] = 0;
            body.face[iface].dxyz[3*ipnt+1] = 0;
            body.face[iface].dxyz[3*ipnt+2] = 0;

            body.face[iface].duv[ 2*ipnt  ] = 0;
            body.face[iface].duv[ 2*ipnt+1] = 0;
        }
    }

    /* if the MODL has a perturbation, compute the tessellation velocities
       by finite differences */
    if (PTRB != NULL) {
        if (MODL->body[ibody].eebody != NULL) {
            status = OCSM_UNSUPPORTED;
            signalError(MODL, status,
                        "cannot currently find tessellation sensitivities via finite differences");
            goto cleanup;
        }

        if        (body.nnode != PTRB->body[ibody].nnode) {
            SPRINT3(0, "ERROR:: .nnode mismatch for ibody=%d, MODL=%d, PTRB=%d",
                    ibody, body.nnode, PTRB->body[ibody].nnode);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        } else if (body.nedge != PTRB->body[ibody].nedge) {
            SPRINT3(0, "ERROR:: .nedge mismatch for ibody=%d, MODL=%d, PTRB=%d",
                    ibody, body.nedge, PTRB->body[ibody].nedge);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        } else if (body.nface != PTRB->body[ibody].nface) {
            SPRINT3(0, "ERROR:: .nface mismatch for ibody=%d, MODL=%d, PTRB=%d",
                    ibody, body.nface, PTRB->body[ibody].nface);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

        for (inode = 1; inode <= body.nnode; inode++) {
            body.node[inode].dxyz[0] = (PTRB->body[ibody].node[inode].x - body.node[inode].x) / MODL->dtime;
            body.node[inode].dxyz[1] = (PTRB->body[ibody].node[inode].y - body.node[inode].y) / MODL->dtime;
            body.node[inode].dxyz[2] = (PTRB->body[ibody].node[inode].z - body.node[inode].z) / MODL->dtime;
        }

        for (iedge = 1; iedge <= body.nedge; iedge++) {
            /* do not process if a degenerate Edge */
            if (body.edge[iedge].itype == DEGENERATE) continue;

            status = EG_getTessEdge(body.etess, iedge,
                                    &npnt_modl, &xyz_modl, &uv_modl);
            CHECK_STATUS(EG_getTessEdge);

            status = EG_getTessEdge(PTRB->body[ibody].etess, -iedge,
                                    &npnt_ptrb, &xyz_ptrb, &uv_ptrb);
            CHECK_STATUS(EG_getTessEdge);

            if (npnt_modl != npnt_ptrb) {
                SPRINT4(0, "ERROR:: npnt mismatch for Edge %d:%d, MODL=%d, PTRB=%d",
                        ibody, iedge, npnt_modl, npnt_ptrb);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            for (ipnt = 0; ipnt < npnt_modl; ipnt++) {
                body.edge[iedge].dt[    ipnt  ] = (uv_ptrb[   ipnt  ] -  uv_modl[  ipnt  ]) / MODL->dtime;
                body.edge[iedge].dxyz[3*ipnt  ] = (xyz_ptrb[3*ipnt  ] - xyz_modl[3*ipnt  ]) / MODL->dtime;
                body.edge[iedge].dxyz[3*ipnt+1] = (xyz_ptrb[3*ipnt+1] - xyz_modl[3*ipnt+1]) / MODL->dtime;
                body.edge[iedge].dxyz[3*ipnt+2] = (xyz_ptrb[3*ipnt+2] - xyz_modl[3*ipnt+2]) / MODL->dtime;
            }
        }

        for (iface = 1; iface <= body.nface; iface++) {
            status = EG_getTessFace(body.etess, iface,
                                    &npnt_modl, &xyz_modl, &uv_modl, &ptype, &pindx,
                                    &ntri_modl, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            status = EG_getTessFace(PTRB->body[ibody].etess, -iface,
                                    &npnt_ptrb, &xyz_ptrb, &uv_ptrb, &ptype, &pindx,
                                    &ntri_ptrb, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            if (npnt_modl != npnt_ptrb) {
                SPRINT4(0, "ERROR:: npnt mismatch for Face %d:%d, MODL=%d, PTRB=%d",
                        ibody, iface, npnt_modl, npnt_ptrb);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            for (ipnt = 0; ipnt < npnt_modl; ipnt++) {
                body.face[iface].duv[ 2*ipnt  ] = (uv_ptrb[ 2*ipnt  ] -  uv_modl[2*ipnt  ]) / MODL->dtime;
                body.face[iface].duv[ 2*ipnt+1] = (uv_ptrb[ 2*ipnt+1] -  uv_modl[2*ipnt+1]) / MODL->dtime;
                body.face[iface].dxyz[3*ipnt  ] = (xyz_ptrb[3*ipnt  ] - xyz_modl[3*ipnt  ]) / MODL->dtime;
                body.face[iface].dxyz[3*ipnt+1] = (xyz_ptrb[3*ipnt+1] - xyz_modl[3*ipnt+1]) / MODL->dtime;
                body.face[iface].dxyz[3*ipnt+2] = (xyz_ptrb[3*ipnt+2] - xyz_modl[3*ipnt+2]) / MODL->dtime;
            }
        }

        goto cleanup;
    }

    /* set Node .dxyz from velocityOfNode */
    for (inode = 1; inode <= nnode; inode++) {
        status = velocityOfNode(MODL, ibody, inode,
                                body.node[inode].dxyz);
        CHECK_STATUS(velocityOfNode);

        if (PRINT_TESSSENS == 1) {
            SPRINT8(1, "ibody=%3d, inode=%3d,            xyz=%10.5f %10.5f %10.5f, dxyz=%10.5f %10.5f %10.5f",
                    ibody, inode,
                    body.node[inode].x, body.node[inode].y, body.node[inode].z,
                    body.node[inode].dxyz[0], body.node[inode].dxyz[1], body.node[inode].dxyz[2]);
        }
    }

    /* if a NodeBody, we are done */
    if (body.botype == OCSM_NODE_BODY) {
        goto cleanup;
    }

    /* set Edge .dxyz */
    for (iedge = 1; iedge <= nedge; iedge++) {
#ifdef GRAFIC
        int io_kbd=5, io_scr=6, ilin[4], isym[4], nper[4], indgr=1+4+16+64, nline=0, nplot=0;
        float tplot[1000], dvplot[1000];
        char pltitl[81];
#endif
        SPLINT_CHECK_FOR_NULL(eedges);

        /* do not process if a degenerate Edge */
        if (body.edge[iedge].itype == DEGENERATE) continue;

        /* get Edge info */
        status = EG_getRange(eedges[iedge-1], trange, &periodic);
        CHECK_STATUS(EG_getRange);

        /* get Edge info for when Edge was first generated */
        status = EG_attributeRet(eedges[iedge-1], "__trace__", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        status = EG_getTessEdge(etess, iedge,
                                &npnt_edge, &xyz_edge, &t_edge);
        CHECK_STATUS(EG_getTessEdge);

        status = EG_getTopology(eedges[iedge-1], &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        ibeg = status = EG_indexBodyTopo(ebody, echilds[0]);
        CHECK_STATUS(EG_indexBodyTopo);

        iend = status = EG_indexBodyTopo(ebody, echilds[1]);
        CHECK_STATUS(EG_indexBodyTopo);

        /* initially .dxyz comes from velocityOfEdge */
        if (MODL->body[ibody].eebody == NULL) {
            status = velocityOfEdge(MODL, ibody, iedge, npnt_edge, NULL,
                                    body.edge[iedge].dxyz);
            CHECK_STATUS(velocityOfEdge);
        } else {
            for (ipnt = 0; ipnt < npnt_edge; ipnt++) {

                /* map to the t in the underlying Edge */
                status = EG_effectiveMap(eedges[iedge-1], (double *)(&t_edge[ipnt]), &eedge2, &tedge2);
                CHECK_STATUS(EG_effectiveMap);

                iedge2 = status = EG_indexBodyTopo(MODL->body[ibody].ebody, eedge2);
                CHECK_STATUS(EG_indexBodyTopo);

                /* get the velocity in the underlying Edge */
                status = velocityOfEdge(MODL, ibody, iedge2, 1, &tedge2, &(body.edge[iedge].dxyz[3*ipnt]));
                CHECK_STATUS(velocityOfEdge);
            }
        }

        if (PRINT_TESSSENS == 1) {
            SPRINT0(1, "after velocityOfEdge");
            for (ipnt = 0; ipnt < npnt_edge; ipnt++) {
                SPRINT9(1, "ibody=%3d, iedge=%3d, ipnt=%4d, xyz=%10.5f %10.5f %10.5f, dxyz=%10.5f %10.5f %10.5f",
                        ibody, iedge, ipnt,
                        xyz_edge[3*ipnt], xyz_edge[3*ipnt+1], xyz_edge[3*ipnt+2],
                        body.edge[iedge].dxyz[3*ipnt], body.edge[iedge].dxyz[3*ipnt+1], body.edge[iedge].dxyz[3*ipnt+2]);
            }
        }

        /* make sure the velocities at the end of the Edge match the Node velocities */
        iskip = 1;

        if (fabs(body.edge[iedge].dxyz[            0] - body.node[body.edge[iedge].ibeg].dxyz[0]) > EPS06) iskip = 0;
        if (fabs(body.edge[iedge].dxyz[            1] - body.node[body.edge[iedge].ibeg].dxyz[1]) > EPS06) iskip = 0;
        if (fabs(body.edge[iedge].dxyz[            2] - body.node[body.edge[iedge].ibeg].dxyz[2]) > EPS06) iskip = 0;

        if (fabs(body.edge[iedge].dxyz[3*npnt_edge-3] - body.node[body.edge[iedge].iend].dxyz[0]) > EPS06) iskip = 0;
        if (fabs(body.edge[iedge].dxyz[3*npnt_edge-2] - body.node[body.edge[iedge].iend].dxyz[1]) > EPS06) iskip = 0;
        if (fabs(body.edge[iedge].dxyz[3*npnt_edge-1] - body.node[body.edge[iedge].iend].dxyz[2]) > EPS06) iskip = 0;

        /* make sure that the Edge has not been trimmed */
        if (EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "__trimmed__",
                            &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist) == EGADS_NOTFOUND) iskip = 0;

        /* skip if we have passed all teh above tests */
        if (iskip > 0) {
            continue;
        }

        /* subtract the velocity components at the interior points of the Edge.
           note that we don't do the endpints because there might be a
           singularity in the derivatives wrt. t and the ends */
        for (ipnt = 1; ipnt < npnt_edge-1; ipnt++) {
            status = EG_evaluate(eedges[iedge-1], &(t_edge[ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            data[6] = sqrt(data[3]*data[3] + data[4]*data[4] + data[5]*data[5]);
            data[3] /= data[6];
            data[4] /= data[6];
            data[5] /= data[6];

            dv = body.edge[iedge].dxyz[3*ipnt  ] * data[3]
               + body.edge[iedge].dxyz[3*ipnt+1] * data[4]
               + body.edge[iedge].dxyz[3*ipnt+2] * data[5];

#ifdef GRAFIC
            tplot[ nplot] = t_edge[ipnt];
            dvplot[nplot] = dv;
            nplot++;
#endif

            body.edge[iedge].dxyz[3*ipnt  ] -= dv * data[3];
            body.edge[iedge].dxyz[3*ipnt+1] -= dv * data[4];
            body.edge[iedge].dxyz[3*ipnt+2] -= dv * data[5];
        }
#ifdef GRAFIC
        nline++;
#endif

        if (PRINT_TESSSENS == 1) {
            SPRINT0(1, "after subtracting tangential");
            for (ipnt = 0; ipnt < npnt_edge; ipnt++) {
                SPRINT9(1, "ibody=%3d, iedge=%3d, ipnt=%4d, xyz=%10.5f %10.5f %10.5f, dxyz=%10.5f %10.5f %10.5f",
                        ibody, iedge, ipnt,
                        xyz_edge[3*ipnt], xyz_edge[3*ipnt+1], xyz_edge[3*ipnt+2],
                        body.edge[iedge].dxyz[3*ipnt], body.edge[iedge].dxyz[3*ipnt+1], body.edge[iedge].dxyz[3*ipnt+2]);
            }
        }

        /* find the magnitude of the projection of the Node velocity
           at the beginning of the Edge in the direction of the Edge
           and add it to the Edge velocity */
        status = EG_evaluate(eedges[iedge-1], &trange[0], data);
        CHECK_STATUS(EG_evaluate);

        if (fabs(data[3]) < EPS06 && fabs(data[4]) < EPS06 && fabs(data[5]) < EPS06) {
            t = 0.999 * trange[0] + 0.001 * trange[1];
            status = EG_evaluate(eedges[iedge-1], &t, data);
            CHECK_STATUS(EG_evaluate);
        }

        data[6] = sqrt(data[3]*data[3] + data[4]*data[4] + data[5]*data[5]);
        data[3] /= data[6];
        data[4] /= data[6];
        data[5] /= data[6];

        dvbeg = body.node[ibeg].dxyz[0] * data[3]
              + body.node[ibeg].dxyz[1] * data[4]
              + body.node[ibeg].dxyz[2] * data[5];

        /* find the magnitude of the projection of the Node velocity
           at the end of the Edge in the direction of the Edge
           and add it to the Edge velocity */
        status = EG_evaluate(eedges[iedge-1], &trange[1], data);
        CHECK_STATUS(EG_evaluate);

        if (fabs(data[3]) < EPS06 && fabs(data[4]) < EPS06 && fabs(data[5]) < EPS06) {
            t = 0.001 * trange[0] + 0.999 * trange[1];
            status = EG_evaluate(eedges[iedge-1], &t, data);
            CHECK_STATUS(EG_evaluate);
        }

        data[6] = sqrt(data[3]*data[3] + data[4]*data[4] + data[5]*data[5]);
        data[3] /= data[6];
        data[4] /= data[6];
        data[5] /= data[6];

        dvend = body.node[iend].dxyz[0] * data[3]
              + body.node[iend].dxyz[1] * data[4]
              + body.node[iend].dxyz[2] * data[5];

        /* for each interior point along the Edge, add an arc-length-weighted
           tangential velocity component if either end dv in non-zero */
        if (fabs(dvbeg) > EPS06 || fabs(dvend) > EPS06) {
            for (ipnt = 1; ipnt < npnt_edge-1; ipnt++) {
                frac = (t_edge[ipnt] - trange[0]) / (trange[1] - trange[0]);
                dv   = (1-frac) * dvbeg + frac * dvend;

                status = EG_evaluate(eedges[iedge-1], &(t_edge[ipnt]), data);
                CHECK_STATUS(EG_evaluate);

                data[6] = sqrt(data[3]*data[3] + data[4]*data[4] + data[5]*data[5]);
                data[3] /= data[6];
                data[4] /= data[6];
                data[5] /= data[6];

#ifdef GRAFIC
                tplot[ nplot] = t_edge[ipnt];
                dvplot[nplot] = dv;
                nplot++;
#endif

                body.edge[iedge].dxyz[3*ipnt  ] += dv * data[3];
                body.edge[iedge].dxyz[3*ipnt+1] += dv * data[4];
                body.edge[iedge].dxyz[3*ipnt+2] += dv * data[5];
            }
#ifdef GRAFIC
            nline++;

            tplot[ nplot] = t_edge[0];
            dvplot[nplot] = dvbeg;
            nplot++;

            tplot[ nplot] = t_edge[npnt_edge-1];
            dvplot[nplot] = dvend;
            nplot++;

            nline++;
#endif
        }

        /* make the velocities at the endpoints match the Nodes */
        body.edge[iedge].dxyz[0] = body.node[ibeg].dxyz[0];
        body.edge[iedge].dxyz[1] = body.node[ibeg].dxyz[1];
        body.edge[iedge].dxyz[2] = body.node[ibeg].dxyz[2];

        body.edge[iedge].dxyz[3*npnt_edge-3] = body.node[iend].dxyz[0];
        body.edge[iedge].dxyz[3*npnt_edge-2] = body.node[iend].dxyz[1];
        body.edge[iedge].dxyz[3*npnt_edge-1] = body.node[iend].dxyz[2];

        if (PRINT_TESSSENS == 1) {
            SPRINT2(1, "after adding trim motion, dvbeg=%10.5f, dvend=%10.5f",
                    dvbeg, dvend);
            for (ipnt = 0; ipnt < npnt_edge; ipnt++) {
                frac = (t_edge[ipnt] - trange[0]) / (trange[1] - trange[0]);
                SPRINT10(1, "ibody=%3d, iedge=%3d, ipnt=%4d, xyz=%10.5f %10.5f %10.5f, dxyz=%10.5f %10.5f %10.5f, frac=%10.5f",
                         ibody, iedge, ipnt,
                         xyz_edge[3*ipnt], xyz_edge[3*ipnt+1], xyz_edge[3*ipnt+2],
                         body.edge[iedge].dxyz[3*ipnt], body.edge[iedge].dxyz[3*ipnt+1], body.edge[iedge].dxyz[3*ipnt+2], frac);
            }
        }

        SPRINT6(2, " <- createTessVels(ibody=%3d, iedge=%3d, npnt=%5d) -> %12.6f %12.6f %12.6f",
            ibody, iedge, npnt_edge, body.edge[iedge].dxyz[0],
                                     body.edge[iedge].dxyz[1],
                                     body.edge[iedge].dxyz[2]);
        if (npnt_edge < 11) {
            for (ipnt = 1; ipnt < npnt_edge; ipnt++) {
                SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                        body.edge[iedge].dxyz[3*ipnt  ],
                        body.edge[iedge].dxyz[3*ipnt+1],
                        body.edge[iedge].dxyz[3*ipnt+2]);
            }
        } else {
            for (ipnt = 1; ipnt < 5; ipnt++) {
                SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                        body.edge[iedge].dxyz[3*ipnt  ],
                        body.edge[iedge].dxyz[3*ipnt+1],
                        body.edge[iedge].dxyz[3*ipnt+2]);
            }
            SPRINT0(2, "                                                            ...");
            for (ipnt = npnt_edge-5; ipnt < npnt_edge; ipnt++) {
                SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                        body.edge[iedge].dxyz[3*ipnt  ],
                        body.edge[iedge].dxyz[3*ipnt+1],
                        body.edge[iedge].dxyz[3*ipnt+2]);
            }
        }

#ifdef GRAFIC
        if (npnt_edge > 2) {
            ilin[0] =  GR_SOLID;
            isym[0] = -GR_SQUARE;
            nper[0] =  npnt_edge - 2;

            ilin[1] =  GR_DASHED;
            isym[1] = -GR_PLUS;
            nper[1] =  npnt_edge - 2;

            ilin[2] = -GR_DOTTED;
            isym[2] =  GR_CIRCLE;
            nper[2] =  2;

            snprintf(pltitl, 80, "~t~dv~edge %d", iedge);
            grinit_(&io_kbd, &io_scr, "edge velocity", strlen("edge veloity"));
            grline_(ilin, isym, &nline, pltitl, &indgr, tplot, dvplot, nper, strlen(pltitl));
        }
#endif
    }

    /* if a WireBody, we are done */
    if (body.botype == OCSM_WIRE_BODY) {
        goto cleanup;
    }

    /* set Face .dxyz  */
    for (iface = 1; iface <= nface; iface++) {
        SPLINT_CHECK_FOR_NULL(efaces);

        /* get Face info */
        status = EG_getTessFace(etess, iface,
                                &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        /* initially .dxyz comes from velocityOfFace */
        if (MODL->body[ibody].eebody == NULL) {
            status = velocityOfFace(MODL, ibody, iface, npnt_face, NULL,
                                    body.face[iface].dxyz);
            CHECK_STATUS(velocityOfFace);
        } else {
            for (ipnt = 0; ipnt < npnt_face; ipnt++) {

                /* map to the uv in the underlying Face */
                status = EG_effectiveMap(efaces[iface-1], (double*)(&uv_face[2*ipnt]), &eface2, uvface2);
                CHECK_STATUS(EG_effectiveMap);

                iface2 = status = EG_indexBodyTopo(ebody, eface2);
                CHECK_STATUS(EG_indexBodyTopo);

                /* get the velocity in the underlying Face */
                status = velocityOfFace(MODL, ibody, iface2, 1, uvface2, &body.face[iface].dxyz[3*ipnt]);
                CHECK_STATUS(velocityOfFace);
            }
        }

        if (PRINT_TESSSENS == 1) {
            SPRINT0(1, "after velocityOfFace");
            for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                SPRINT11(1, "ibody=%3d, iface=%3d, ipnt=%4d(%4d,%4d), xyz=%10.5f %10.5f %10.5f, dxyz=%10.5f %10.5f %10.5f",
                         ibody, iface, ipnt, ptype[ipnt], pindx[ipnt],
                         xyz_face[3*ipnt], xyz_face[3*ipnt+1], xyz_face[3*ipnt+2],
                         body.face[iface].dxyz[3*ipnt], body.face[iface].dxyz[3*ipnt+1], body.face[iface].dxyz[3*ipnt+2]);
            }
        }

        /* if this Face has not been trimmed, then we do not need to make
           any adjustments to the results returned from velocityOfFace */
        if (EG_attributeRet(MODL->body[ibody].face[iface].eface, "__trimmed__",
                            &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist) == EGADS_NOTFOUND) {
            for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                if        (ptype[ipnt] < 0) {
                    break;
                } else if (ptype[ipnt] == 0) {
                    inode = pindx[ipnt];

                    MODL->body[ibody].face[iface].dxyz[3*ipnt  ] = MODL->body[ibody].node[inode].dxyz[0];
                    MODL->body[ibody].face[iface].dxyz[3*ipnt+1] = MODL->body[ibody].node[inode].dxyz[1];
                    MODL->body[ibody].face[iface].dxyz[3*ipnt+2] = MODL->body[ibody].node[inode].dxyz[2];
                } else {
                    iedge = pindx[ipnt];
                    jpnt  = ptype[ipnt] - 1;

                    MODL->body[ibody].face[iface].dxyz[3*ipnt  ] = MODL->body[ibody].edge[iedge].dxyz[3*jpnt  ];
                    MODL->body[ibody].face[iface].dxyz[3*ipnt+1] = MODL->body[ibody].edge[iedge].dxyz[3*jpnt+1];
                    MODL->body[ibody].face[iface].dxyz[3*ipnt+2] = MODL->body[ibody].edge[iedge].dxyz[3*jpnt+2];
                }
            }


            continue;
        }

        /* subtract the velocity the components along the Face */
        for (ipnt = 0; ipnt < npnt_face; ipnt++) {
            status = EG_evaluate(efaces[iface-1], &(uv_face[2*ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            normx = data[4] * data[8] - data[5] * data[7];
            normy = data[5] * data[6] - data[3] * data[8];
            normz = data[3] * data[7] - data[4] * data[6];
            norm  = normx * normx + normy * normy + normz * normz;
            dotp  = normx * body.face[iface].dxyz[3*ipnt  ]
                  + normy * body.face[iface].dxyz[3*ipnt+1]
                  + normz * body.face[iface].dxyz[3*ipnt+2];

            if (fabs(norm) > EPS12) {
                body.face[iface].dxyz[3*ipnt  ] = normx / norm * dotp;
                body.face[iface].dxyz[3*ipnt+1] = normy / norm * dotp;
                body.face[iface].dxyz[3*ipnt+2] = normz / norm * dotp;
            }
        }

        if (PRINT_TESSSENS == 1) {
            SPRINT0(1, "after subtracting tangential components");
            for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                SPRINT11(1, "ibody=%3d, iface=%3d, ipnt=%4d(%4d,%4d), xyz=%10.5f %10.5f %10.5f, dxyz=%10.5f %10.5f %10.5f",
                         ibody, iface, ipnt, ptype[ipnt], pindx[ipnt],
                         xyz_face[3*ipnt], xyz_face[3*ipnt+1], xyz_face[3*ipnt+2],
                         body.face[iface].dxyz[3*ipnt], body.face[iface].dxyz[3*ipnt+1], body.face[iface].dxyz[3*ipnt+2]);
            }
        }

        /* get the .duv from the Nodes or Edges */
        for (ipnt = 0; ipnt < npnt_face; ipnt++) {
            if (ptype[ipnt] < 0) break;

            if (ptype[ipnt] == 0) {
                inode = pindx[ipnt];

                /* if a __C0blend__ Node, set the change to 0 */
                status = EG_attributeRet(MODL->body[ibody].node[inode].enode, "__C0blend__",
                                         &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
                if (status == SUCCESS) {
                    dxyz[0] = 0;
                    dxyz[1] = 0;
                    dxyz[2] = 0;

                /* otherwise get it from the Node */
                } else {
                    dxyz[0] = body.node[inode].dxyz[0];
                    dxyz[1] = body.node[inode].dxyz[1];
                    dxyz[2] = body.node[inode].dxyz[2];
                }
            } else {
                iedge = pindx[ipnt];
                jpnt  = ptype[ipnt] - 1;

                /* if a __C0blend__ Edge, set the change to 0 */
                status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "__C0blend__",
                                         &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
                if (status == SUCCESS) {
                    dxyz[0] = 0;
                    dxyz[1] = 0;
                    dxyz[2] = 0;

                /* otherwise get it from te Edge */
                } else {
                    dxyz[0] = body.edge[iedge].dxyz[3*jpnt  ];
                    dxyz[1] = body.edge[iedge].dxyz[3*jpnt+1];
                    dxyz[2] = body.edge[iedge].dxyz[3*jpnt+2];
                }
            }

            status = EG_evaluate(efaces[iface-1], &(uv_face[2*ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            mat[0] = data[3] * data[3] + data[4] * data[4] + data[5] * data[5];
            mat[1] = data[3] * data[6] + data[4] * data[7] + data[5] * data[8];
            rhs[0] = data[3] * dxyz[0] + data[4] * dxyz[1] + data[5] * dxyz[2];

            mat[2] = data[6] * data[3] + data[7] * data[4] + data[8] * data[5];
            mat[3] = data[6] * data[6] + data[7] * data[7] + data[8] * data[8];
            rhs[1] = data[6] * dxyz[0] + data[7] * dxyz[1] + data[8] * dxyz[2];

            status = matsol(mat, rhs, 2, &(body.face[iface].duv[2*ipnt]));
            if (status != SUCCESS) {
                body.face[iface].duv[2*ipnt  ] = 0;
                body.face[iface].duv[2*ipnt+1] = 0;

                status = SUCCESS;
            }
        }

        duvface = body.face[iface].duv;

        /* determine number of boundary points and the largest velocity
           on the boundary */
        velmax = 0;
        nbnd   = 0;

        for (ipnt = 0; ipnt < npnt_face; ipnt++) {
            if (ptype[ipnt] >= 0) {
                if (fabs(duvface[2*ipnt  ]) > velmax) velmax = fabs(duvface[2*ipnt  ]);
                if (fabs(duvface[2*ipnt+1]) > velmax) velmax = fabs(duvface[2*ipnt+1]);

                nbnd++;
            } else {
                break;
            }
        }

        /* update duv at the interior points of the Face based upon duv
           at its Edges and Nodes (as computed above) */
#ifndef __clang_analyzer__
        eggdata = body.face[iface].eggdata;
#endif

        /* if there are no boundary velocities, do not update duvface[] */
        if (velmax < EPS06) {
            SPRINT4(2, "Skipping sensitivities for Face %d:%d because velmax=%12.5e (nbnd=%d)",
                    ibody, iface, velmax, nbnd);

        /* if this is not a perturbed MODL and the grid on the Face
           was made with an external grid generator, have the external
           grid generator compute the sensitivity directly */
        } else if (INTERP_VEL == 0 && MODL->basemodl == NULL && eggdata != NULL) {
            SPRINT2(2, "Computing sensitivities by calling morph for Face %d:%d",
                    ibody, iface);

            status = MODL->eggInfo(eggdata, &npnt_egg, &nbnd_egg, &uv_egg, &p_egg,
                                   &ntri_egg, &tris_egg);
            CHECK_STATUS(eggInfo);

            MALLOC(duv_new, double, 2*npnt_egg);

            /* load in the uv velocities at the Boundary points */
            for (ipnt = 0; ipnt < nbnd_egg; ipnt++) {
                duv_new[2*ipnt  ] = duvface[2*ipnt  ];
                duv_new[2*ipnt+1] = duvface[2*ipnt+1];
            }

            /* call the external tessellator to propagate velocities
               into the interior */
            status = MODL->eggMorph(eggdata, duv_new, &eggdata_new);
            CHECK_STATUS(eggMorph);

            status = MODL->eggFree(eggdata_new);
            CHECK_STATUS(eggFree);

            /* save the uv velocities at the interior points */
            for (ipnt = nbnd_egg; ipnt < npnt_egg; ipnt++) {
                duvface[2*ipnt  ] = duv_new[2*ipnt  ];
                duvface[2*ipnt+1] = duv_new[2*ipnt+1];
            }

            FREE(duv_new);

        /* otherwise interpolate the duv on the boundary points on each Face into
           the Face's interior points (using mean-value coordinates or radial-basis
           functions) */
        } else {
            if (INTERP_VEL == 1 || INTERP_VEL == 2) {
                if (INTERP_VEL == 1) {
                    SPRINT2(2, "Interpolating sensitivities via MVC for Face %d:%d",
                            ibody, iface);
                } else {
                    SPRINT2(2, "Interpolating sensitivities via VR-MVC for Face %d:%d",
                            ibody, iface);
                }

                status = EG_getTessLoops(etess, iface, &nloop, &nlast1);
                CHECK_STATUS(EG_getTessLoops);

                MALLOC(weights, double, nlast1[nloop-1]);

                status = EG_getTessFace(etess, iface,
                                        &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                        &ntri, &tris, &tric);
                CHECK_STATUS(EG_getFaceTess);

                for (ipnt = nbnd; ipnt < npnt_face; ipnt++) {
                    status = mvcInterp(nloop, nlast1, uv_face, &(uv_face[2*ipnt]), weights);
                    CHECK_STATUS(mvcInterp);

                    for (jpnt = 0; jpnt < nbnd; jpnt++) {
                        duvface[2*ipnt  ] += weights[jpnt] * duvface[2*jpnt  ];
                        duvface[2*ipnt+1] += weights[jpnt] * duvface[2*jpnt+1];
                    }
                }

                FREE(weights);

            } else if (INTERP_VEL == 3) {
                SPRINT2(2, "Interpolating sensitivities via RBF for Face %d:%d",
                        ibody, iface);

                /* find the Face's bounding box */
                umin = uv_face[0];
                umax = uv_face[0];
                vmin = uv_face[1];
                vmax = uv_face[1];

                for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                    if (uv_face[2*ipnt  ] < umin) umin = uv_face[2*ipnt  ];
                    if (uv_face[2*ipnt  ] > umax) umax = uv_face[2*ipnt  ];
                    if (uv_face[2*ipnt+1] < vmin) vmin = uv_face[2*ipnt+1];
                    if (uv_face[2*ipnt+1] > vmax) vmax = uv_face[2*ipnt+1];
                }

                /* arbitrarily set the support radius so that each covers
                   about half of the domain */
                srad2 = 1.00 * MAX(umax-umin, vmax-vmin);
                srad2 = srad2 * srad2;

                MALLOC(weights, double, 2*nbnd);

                /* find the weights associated with each boundary point */
                status = rbfWeights(nbnd, srad2, uv_face, duvface, weights);
                CHECK_STATUS(rbfWeights);

                /* evaluate the RBF at each of the interior points */
                for (ipnt = nbnd; ipnt < npnt_face; ipnt++) {
                    for (jpnt = 0; jpnt < nbnd; jpnt++) {
                        phi = wendland(&uv_face[2*ipnt], &uv_face[2*jpnt], srad2);

                        duvface[2*ipnt  ] += weights[2*jpnt  ] * phi;
                        duvface[2*ipnt+1] += weights[2*jpnt+1] * phi;
                    }
                }

                FREE(weights);

            } else if (INTERP_VEL == 4 || INTERP_VEL == 5) {
                if (INTERP_VEL == 4) {
                    SPRINT2(2, "Interpolating sensitivities via smoothing for Face %d:%d",
                            ibody, iface);
                } else {
                    SPRINT2(2, "Interpolating sensitivities via Laplace for Face %d:%d",
                            ibody, iface);
                }

                /* compute the average velocities for the boundary points */
                duavg  = 0;
                dvavg  = 0;

                for (ipnt = 0; ipnt < nbnd; ipnt++) {
                    duavg += duvface[2*ipnt  ];
                    dvavg += duvface[2*ipnt+1];
                }

                duavg /= nbnd;
                dvavg /= nbnd;

                /* initialize the field velocities to the average boundary velocity */
                for (ipnt = nbnd; ipnt < npnt_face; ipnt++) {
                    duvface[2*ipnt  ] = duavg;
                    duvface[2*ipnt+1] = dvavg;
                }

                /* allocate and initialize the change arrays */
                MALLOC(fac, double, 3*ntri);
                MALLOC(ddu, double, npnt_face);
                MALLOC(ddv, double, npnt_face);
                MALLOC(nnn, double, npnt_face);

                for (ipnt = nbnd; ipnt < npnt_face; ipnt++) {
                    ddu[ipnt] = 0;
                    ddv[ipnt] = 0;
                    nnn[ipnt] = 0;
                }

                /* simple smoothing */
                if (INTERP_VEL == 4) {
                    for (itri = 0; itri < ntri; itri++) {
                        fac[3*itri  ] = 1;
                        fac[3*itri+1] = 1;
                        fac[3*itri+2] = 1;
                    }

                /* satisfy Laplace's equation */
                } else {
                    for (itri = 0; itri < ntri; itri++) {
                        ip0 = tris[3*itri  ] - 1;
                        ip1 = tris[3*itri+1] - 1;
                        ip2 = tris[3*itri+2] - 1;

                        /* find circumcenter */
                        u0 = uv_face[2*ip0  ];
                        v0 = uv_face[2*ip0+1];
                        u1 = uv_face[2*ip1  ];
                        v1 = uv_face[2*ip1+1];
                        u2 = uv_face[2*ip2  ];
                        v2 = uv_face[2*ip2+1];

                        den  = (u1 - u0) * (v2 - v0) - (u2 - u0) * (v1 - v0);
                        ubar = ((u1*u1 - u0*u0 + v1*v1 - v0*v0) * (v2 - v0)
                               -(u2*u2 - u0*u0 + v2*v2 - v0*v0) * (v1 - v0)) / (2 * den);
                        vbar = ((u2*u2 - u0*u0 + v2*v2 - v0*v0) * (u1 - u0)
                               -(u1*u1 - u0*u0 + v1*v1 - v0*v0) * (u2 - u0)) / (2 * den);

                        /* fac is based upon Laplces eqution */
                        fac[3*itri  ] = sqrt((SQR(ubar-(u1+u2)/2) + SQR(vbar-(v1+v2)/2))
                                            /(SQR(      u1-u2   ) + SQR(      v1-v2   )));
                        fac[3*itri+1] = sqrt((SQR(ubar-(u2+u0)/2) + SQR(vbar-(v2+v0)/2))
                                            /(SQR(      u2-u0   ) + SQR(      v2-v0   )));
                        fac[3*itri+2] = sqrt((SQR(ubar-(u0+u1)/2) + SQR(vbar-(v0+v1)/2))
                                            /(SQR(      u0-u1   ) + SQR(      v0-v1   )));
                    }
                }

                /* combine fac[] from adjacent triangles */
                for (itri = 0; itri < ntri; itri++) {
                    jtri = tric[3*itri  ] - 1;
                    if (jtri > itri) {
                        if        (tric[3*jtri  ]-1 == itri) {
                            fac[3*itri  ] += fac[3*jtri  ];
                            fac[3*jtri  ]  = fac[3*itri  ];
                        } else if (tric[3*jtri+1]-1 == itri) {
                            fac[3*itri  ] += fac[3*jtri+1];
                            fac[3*jtri+1]  = fac[3*itri  ];
                        } else if (tric[3*jtri+2]-1 == itri) {
                            fac[3*itri  ] += fac[3*jtri+2];
                            fac[3*jtri+2]  = fac[3*itri  ];
                        }
                    }

                    jtri = tric[3*itri+1] - 1;
                    if (jtri > itri) {
                        if        (tric[3*jtri  ]-1 == itri) {
                            fac[3*itri+1] += fac[3*jtri  ];
                            fac[3*jtri  ]  = fac[3*itri+1];
                        } else if (tric[3*jtri+1]-1 == itri) {
                            fac[3*itri+1] += fac[3*jtri+1];
                            fac[3*jtri+1]  = fac[3*itri+1];
                        } else if (tric[3*jtri+2]-1 == itri) {
                            fac[3*itri+1] += fac[3*jtri+2];
                            fac[3*jtri+2]  = fac[3*itri+1];
                        }
                    }

                    jtri = tric[3*itri+2] - 1;
                    if (jtri > itri) {
                        if        (tric[3*jtri  ]-1 == itri) {
                            fac[3*itri+2] += fac[3*jtri  ];
                            fac[3*jtri  ]  = fac[3*itri+2];
                        } else if (tric[3*jtri+1]-1 == itri) {
                            fac[3*itri+2] += fac[3*jtri+1];
                            fac[3*jtri+1]  = fac[3*itri+2];
                        } else if (tric[3*jtri+2]-1 == itri) {
                            fac[3*itri+2] += fac[3*jtri+2];
                            fac[3*jtri+2]  = fac[3*itri+2];
                        }
                    }
                }

                /* perform smoothing or Laplace iterations */
                niter = npnt_face - nbnd;
                toler = 1.0e-5;

                for (iter = 0; iter < niter; iter++) {

                    /* convergence check */
                    if (velmax < toler) break;

                    /* loop through the triangles and accumulate the changes at the points */
                    for (itri = 0;  itri < ntri; itri++) {
                        ip0 = tris[3*itri  ] - 1;
                        ip1 = tris[3*itri+1] - 1;
                        ip2 = tris[3*itri+2] - 1;

                        ddu[ip0] += fac[3*itri+2] * (duvface[2*ip1  ] - duvface[2*ip0  ])
                                  + fac[3*itri+1] * (duvface[2*ip2  ] - duvface[2*ip0  ]);
                        ddv[ip0] += fac[3*itri+2] * (duvface[2*ip1+1] - duvface[2*ip0+1])
                                  + fac[3*itri+1] * (duvface[2*ip2+1] - duvface[2*ip0+1]);
                        nnn[ip0] += fac[3*itri+2]
                                  + fac[3*itri+1];

                        ddu[ip1] += fac[3*itri  ] * (duvface[2*ip2  ] - duvface[2*ip1  ])
                                  + fac[3*itri+2] * (duvface[2*ip0  ] - duvface[2*ip1  ]);
                        ddv[ip1] += fac[3*itri  ] * (duvface[2*ip2+1] - duvface[2*ip1+1])
                                  + fac[3*itri+2] * (duvface[2*ip0+1] - duvface[2*ip1+1]);
                        nnn[ip1] += fac[3*itri  ]
                                  + fac[3*itri+2];

                        ddu[ip2] += fac[3*itri+1] * (duvface[2*ip0  ] - duvface[2*ip2  ])
                                  + fac[3*itri  ] * (duvface[2*ip1  ] - duvface[2*ip2  ]);
                        ddv[ip2] += fac[3*itri+1] * (duvface[2*ip0+1] - duvface[2*ip2+1])
                                  + fac[3*itri  ] * (duvface[2*ip1+1] - duvface[2*ip2+1]);
                        nnn[ip2] += fac[3*itri+1]
                                  + fac[3*itri  ];
                    }

                    /* apply the changes in velocities at the points, keep track of the
                       maximum change, and initialize change arrays for next iteration */
                    velmax = 0;
                    for (ipnt = nbnd; ipnt < npnt_face; ipnt++) {
                        ddu[ipnt] /= nnn[ipnt];
                        ddv[ipnt] /= nnn[ipnt];

                        duvface[2*ipnt  ] += ddu[ipnt];
                        duvface[2*ipnt+1] += ddv[ipnt];

                        if (fabs(ddu[ipnt]) > velmax) velmax = fabs(ddu[ipnt]);
                        if (fabs(ddv[ipnt]) > velmax) velmax = fabs(ddv[ipnt]);

                        ddu[ipnt] = 0;
                        ddv[ipnt] = 0;
                        nnn[ipnt] = 0;
                    }
                }

                /* free up the change arrays */
                FREE(nnn);
                FREE(ddv);
                FREE(ddu);
                FREE(fac);

            } else if (INTERP_VEL == 6) {
                SPRINT2(2, "Interpolating sensitivities via egads coarse mapping for Face %d:%d",
                            ibody, iface);

                status = EG_getTessFrame(MODL->body[ibody].etess, iface, &bary, &nframe, &tris2);
                CHECK_STATUS(EG_getTessFrame);

                for (ipnt = nbnd; ipnt < npnt_face; ipnt++) {
                    itri = bary[ipnt].tri - 1;
                    ip0  = tris2[3*itri  ] - 1;
                    ip1  = tris2[3*itri+1] - 1;
                    ip2  = tris2[3*itri+2] - 1;

                    duvface[2*ipnt  ] = bary[ipnt].w[0] * (duvface[2*ip0  ] - duvface[2*ip2  ])
                                      + bary[ipnt].w[1] * (duvface[2*ip1  ] - duvface[2*ip2  ])
                                      +                                       duvface[2*ip2  ];
                    duvface[2*ipnt+1] = bary[ipnt].w[0] * (duvface[2*ip0+1] - duvface[2*ip2+1])
                                      + bary[ipnt].w[1] * (duvface[2*ip1+1] - duvface[2*ip2+1])
                                      +                                       duvface[2*ip2+1];
                }
            } else {
                SPRINT1(0, "ERROR:: bad INTERP_VEL=%d", INTERP_VEL);
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

            /* contour plot of the displacements */
#ifdef GRAFIC
            {
                int    io_kbd=5, io_scr=6, indgr=1+4+16+64+1024, ncont=12, igrid;
                float  *du_face=NULL, *dv_face=NULL, cont[13];
                double umin, umax, vmin, vmax;
                char   pltitl[80];

                MALLOC(du_face, float, npnt_face);
                MALLOC(dv_face, float, npnt_face);

                umin = duvface[0];
                umax = duvface[0];
                vmin = duvface[1];
                vmax = duvface[1];

                for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                    if (duvface[2*ipnt  ] < umin) umin = duvface[2*ipnt  ];
                    if (duvface[2*ipnt  ] > umax) umax = duvface[2*ipnt  ];
                    if (duvface[2*ipnt+1] < vmin) vmin = duvface[2*ipnt+1];
                    if (duvface[2*ipnt+1] < vmax) vmax = duvface[2*ipnt+1];

                    du_face[ipnt] = duvface[2*ipnt  ];
                    dv_face[ipnt] = duvface[2*ipnt+1];
                }

                grinit_(&io_kbd, &io_scr, "Displacement plots",
                                   strlen("Displacement plots"));

                if (umax-umin > 1e-4) {
                    igrid = 0;
                    snprintf(pltitl, 80, "~u~v~du for Face %d", iface);
                    grctrl_(plotVels, &indgr, pltitl,
                            (void*)(&ntri),
                            (void*)(tris),
                            (void*)(&npnt_face),
                            (void*)(uv_face),
                            (void*)(du_face),
                            (void*)(&ncont),
                            (void*)(cont),
                            (void*)(&igrid),
                            (void*)NULL,
                            (void*)NULL,
                            STRLEN(pltitl));
                }

                if (vmax-vmin > 1e-4) {
                    igrid = 0;
                    snprintf(pltitl, 80, "~u~v~dv for Face %d", iface);
                    grctrl_(plotVels, &indgr, pltitl,
                            (void*)(&ntri),
                            (void*)(tris),
                            (void*)(&npnt_face),
                            (void*)(uv_face),
                            (void*)(dv_face),
                            (void*)(&ncont),
                            (void*)(cont),
                            (void*)(&igrid),
                            (void*)NULL,
                            (void*)NULL,
                            STRLEN(pltitl));
                }

                FREE(du_face);
                FREE(dv_face);
            }
#endif // GRAFIC
        }

        /* get the jacobian of the mapping from an EFace to the underlying Face */
        if (MODL->body[ibody].eebody != NULL) {
            status = EG_getTessFace(etess, iface,
                                    &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getFaceTess);

            MALLOC(dudue, double, npnt_face);
            MALLOC(dvdue, double, npnt_face);
            MALLOC(dudve, double, npnt_face);
            MALLOC(dvdve, double, npnt_face);

            status = efaceJacobian(MODL, ibody, iface, dudue, dvdue, dudve, dvdve);
            CHECK_STATUS(efaceJacobian);
        }

        /* update iface.dxyz */
        for (ipnt = 0; ipnt < npnt_face; ipnt++) {

            /* for points associated with Nodes, just copy .dxyz from the Node */
            if (ptype[ipnt] == 0) {
                inode = pindx[ipnt];

                body.face[iface].dxyz[3*ipnt  ] = body.node[inode].dxyz[0];
                body.face[iface].dxyz[3*ipnt+1] = body.node[inode].dxyz[1];
                body.face[iface].dxyz[3*ipnt+2] = body.node[inode].dxyz[2];

            /* for points associated with Edges, just copy .dxyz for the Egde */
            } else if (ptype[ipnt] > 0) {
                iedge = pindx[ipnt];
                jpnt  = ptype[ipnt] - 1;

                body.face[iface].dxyz[3*ipnt  ] = body.edge[iedge].dxyz[3*jpnt  ];
                body.face[iface].dxyz[3*ipnt+1] = body.edge[iedge].dxyz[3*jpnt+1];
                body.face[iface].dxyz[3*ipnt+2] = body.edge[iedge].dxyz[3*jpnt+2];

            /* for points in the interior of the Face ... */
            } else {
                if (MODL->body[ibody].eebody == NULL) {
                    status = EG_evaluate(efaces[iface-1], &(uv_face[2*ipnt]), dleft);
                    CHECK_STATUS(EG_evaluate);
                } else {
                    SPLINT_CHECK_FOR_NULL(dudue);
                    SPLINT_CHECK_FOR_NULL(dvdue);
                    SPLINT_CHECK_FOR_NULL(dudve);
                    SPLINT_CHECK_FOR_NULL(dvdve);

                    status = EG_effectiveMap(efaces[iface-1], (double*)(&uv_face[2*ipnt]), &efacenew, uvnew);
                    CHECK_STATUS(EG_effectiveMap);

                    status = EG_evaluate(efacenew, uvnew, data);
                    CHECK_STATUS(EG_evaluate);

                    dleft[3] = data[3] * dudue[ipnt] + data[6] * dvdue[ipnt];
                    dleft[4] = data[4] * dudue[ipnt] + data[7] * dvdue[ipnt];
                    dleft[5] = data[5] * dudue[ipnt] + data[8] * dvdue[ipnt];

                    dleft[6] = data[3] * dudve[ipnt] + data[6] * dvdve[ipnt];
                    dleft[7] = data[4] * dudve[ipnt] + data[7] * dvdve[ipnt];
                    dleft[8] = data[5] * dudve[ipnt] + data[8] * dvdve[ipnt];
                }

                /* velocity is sum of its nominal velocity and the velocity associated
                   with the .duv */
                body.face[iface].dxyz[3*ipnt  ] += dleft[3] * duvface[2*ipnt  ]
                                                 + dleft[6] * duvface[2*ipnt+1];
                body.face[iface].dxyz[3*ipnt+1] += dleft[4] * duvface[2*ipnt  ]
                                                 + dleft[7] * duvface[2*ipnt+1];
                body.face[iface].dxyz[3*ipnt+2] += dleft[5] * duvface[2*ipnt  ]
                                                 + dleft[8] * duvface[2*ipnt+1];
            }
        }

        FREE(dudue);
        FREE(dvdue);
        FREE(dudve);
        FREE(dvdve);

        if (PRINT_TESSSENS == 1) {
            SPRINT0(1, "after adding trim motion from Edges");
            for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                SPRINT11(1, "ibody=%3d, iface=%3d, ipnt=%4d(%4d,%4d), xyz=%10.5f %10.5f %10.5f, dxyz=%10.5f %10.5f %10.5f",
                         ibody, iface, ipnt, ptype[ipnt], pindx[ipnt],
                         xyz_face[3*ipnt], xyz_face[3*ipnt+1], xyz_face[3*ipnt+2],
                         body.face[iface].dxyz[3*ipnt], body.face[iface].dxyz[3*ipnt+1], body.face[iface].dxyz[3*ipnt+2]);
            }
        }

        SPRINT6(2, " <- createTessVels(ibody=%3d, iface=%3d, npnt=%5d) -> %12.6f %12.6f %12.6f",
            ibody, iface, npnt_face, body.face[iface].dxyz[0],
                                     body.face[iface].dxyz[1],
                                     body.face[iface].dxyz[2]);
        if (npnt_face < 11) {
            for (ipnt = 1; ipnt < npnt_face; ipnt++) {
                SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                        body.face[iface].dxyz[3*ipnt  ],
                        body.face[iface].dxyz[3*ipnt+1],
                        body.face[iface].dxyz[3*ipnt+2]);
            }
        } else {
            for (ipnt = 1; ipnt < 5; ipnt++) {
                SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                        body.face[iface].dxyz[3*ipnt  ],
                        body.face[iface].dxyz[3*ipnt+1],
                        body.face[iface].dxyz[3*ipnt+2]);
            }
            SPRINT0(2, "                                                            ...");
            for (ipnt = npnt_face-5; ipnt < npnt_face; ipnt++) {
                SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                        body.face[iface].dxyz[3*ipnt  ],
                        body.face[iface].dxyz[3*ipnt+1],
                        body.face[iface].dxyz[3*ipnt+2]);
            }
        }
    }

    /* compare Node velocities with Edge and Face velocities */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
            if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) continue;

            if (MODL->body[ibody].edge[iedge].ibeg == inode) {
                errx = MODL->body[ibody].edge[iedge].dxyz[0] - MODL->body[ibody].node[inode].dxyz[0];
                erry = MODL->body[ibody].edge[iedge].dxyz[1] - MODL->body[ibody].node[inode].dxyz[1];
                errz = MODL->body[ibody].edge[iedge].dxyz[2] - MODL->body[ibody].node[inode].dxyz[2];

                if (fabs(errx) > EPS06 || fabs(erry) > EPS06 || fabs(errz) > EPS06) {
                    SPRINT11(0, "WARNING:: dxyz mismatch: inode=%4d (%12.6f %12.6f %12.6f) ibeg =%4d (%12.6f %12.6f %12.6f)  err=(%12.6f %12.6f %12.6f)",
                           inode, MODL->body[ibody].node[inode].dxyz[0],
                                  MODL->body[ibody].node[inode].dxyz[1],
                                  MODL->body[ibody].node[inode].dxyz[2],
                           iedge, MODL->body[ibody].edge[iedge].dxyz[0],
                                  MODL->body[ibody].edge[iedge].dxyz[1],
                                  MODL->body[ibody].edge[iedge].dxyz[2], errx, erry, errz);
                    (MODL->nwarn)++;
                }
            }
            if (MODL->body[ibody].edge[iedge].iend == inode) {
                status = EG_getTessEdge(etess, iedge,
                                        &npnt_edge, &xyz_edge, &t_edge);
                CHECK_STATUS(EG_getTessEdge);

                errx = MODL->body[ibody].edge[iedge].dxyz[3*npnt_edge-3] - MODL->body[ibody].node[inode].dxyz[0];
                erry = MODL->body[ibody].edge[iedge].dxyz[3*npnt_edge-2] - MODL->body[ibody].node[inode].dxyz[1];
                errz = MODL->body[ibody].edge[iedge].dxyz[3*npnt_edge-1] - MODL->body[ibody].node[inode].dxyz[2];

                if (fabs(errx) > EPS06 || fabs(erry) > EPS06 || fabs(errz) > EPS06) {
                    SPRINT11(0, "WARNING:: dxyz mismatch: inode=%4d (%12.6f %12.6f %12.6f) iend =%4d (%12.6f %12.6f %12.6f)  err=(%12.6f %12.6f %12.6f)",
                           inode, MODL->body[ibody].node[inode].dxyz[0],
                                  MODL->body[ibody].node[inode].dxyz[1],
                                  MODL->body[ibody].node[inode].dxyz[2],
                           iedge, MODL->body[ibody].edge[iedge].dxyz[3*npnt_edge-3],
                                  MODL->body[ibody].edge[iedge].dxyz[3*npnt_edge-2],
                                  MODL->body[ibody].edge[iedge].dxyz[3*npnt_edge-1], errx, erry, errz);
                    (MODL->nwarn)++;
                }
            }
        }
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(etess, iface,
                                    &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                if (ptype[ipnt] == 0 && pindx[ipnt] == inode) {
                    errx = MODL->body[ibody].face[iface].dxyz[3*ipnt  ] - MODL->body[ibody].node[inode].dxyz[0];
                    erry = MODL->body[ibody].face[iface].dxyz[3*ipnt+1] - MODL->body[ibody].node[inode].dxyz[1];
                    errz = MODL->body[ibody].face[iface].dxyz[3*ipnt+2] - MODL->body[ibody].node[inode].dxyz[2];

                    if (fabs(errx) > EPS06 || fabs(erry) > EPS06 || fabs(errz) > EPS06) {
                        SPRINT11(0, "WARNING:: dxyz mismatch: inode=%4d (%12.6f %12.6f %12.6f) iface=%4d (%12.6f %12.6f %12.6f)  err=(%12.6f %12.6f %12.6f)",
                               inode, MODL->body[ibody].node[inode].dxyz[0],
                                      MODL->body[ibody].node[inode].dxyz[1],
                                      MODL->body[ibody].node[inode].dxyz[2],
                               iface, MODL->body[ibody].face[iface].dxyz[3*ipnt  ],
                                      MODL->body[ibody].face[iface].dxyz[3*ipnt+1],
                                      MODL->body[ibody].face[iface].dxyz[3*ipnt+2], errx, erry, errz);
                        (MODL->nwarn)++;
                    }
                } else if (ptype[ipnt] < 0) {
                    break;
                }
            }
        }
    }

    /* compare Edge velocities with Face velocities */
    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) continue;

        status = EG_getTessEdge(etess, iedge,
                                &npnt_edge, &xyz_edge, &t_edge);
        CHECK_STATUS(EG_getTessEdge);

        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(etess, iface,
                                    &npnt_face, &xyz_face, &uv_face, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (ipnt = 0; ipnt < npnt_face; ipnt++) {
                if (ptype[ipnt] > 0 && pindx[ipnt] == iedge) {
                    jpnt = ptype[ipnt] - 1;

                    errx = MODL->body[ibody].face[iface].dxyz[3*ipnt  ] - MODL->body[ibody].edge[iedge].dxyz[3*jpnt  ];
                    erry = MODL->body[ibody].face[iface].dxyz[3*ipnt+1] - MODL->body[ibody].edge[iedge].dxyz[3*jpnt+1];
                    errz = MODL->body[ibody].face[iface].dxyz[3*ipnt+2] - MODL->body[ibody].edge[iedge].dxyz[3*jpnt+2];

                    if (fabs(errx) > EPS06 || fabs(erry) > EPS06 || fabs(errz) > EPS06) {
                        SPRINT11(0, "WARNING:: dxyz mismatch: iedge=%4d (%12.6f %12.6f %12.6f) iface=%4d (%12.6f %12.6f %12.6f)  err=(%12.6f %12.6f %12.6f)",
                                 iedge, MODL->body[ibody].edge[iedge].dxyz[3*jpnt  ],
                                        MODL->body[ibody].edge[iedge].dxyz[3*jpnt+1],
                                        MODL->body[ibody].edge[iedge].dxyz[3*jpnt+2],
                                 iface, MODL->body[ibody].face[iface].dxyz[3*ipnt  ],
                                        MODL->body[ibody].face[iface].dxyz[3*ipnt+1],
                                        MODL->body[ibody].face[iface].dxyz[3*ipnt+2], errx, erry, errz);
                        (MODL->nwarn)++;
                    }
                } else if (ptype[ipnt] < 0) {
                    break;
                }
            }
        }
    }

cleanup:
#if PRINT_CALLHISTORY > 0
    indent_callHistory--;
#endif

    if (enodes != NULL) EG_free(enodes);
    if (eedges != NULL) EG_free(eedges);
    if (efaces != NULL) EG_free(efaces);

    FREE(weights);
    FREE(duv_new);
    FREE(ddu);
    FREE(ddv);
    FREE(nnn);
    FREE(fac);
    FREE(dudue);
    FREE(dvdue);
    FREE(dudve);
    FREE(dvdve);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   createVelocityCache - create velocity cache for RULE or BLEND      *
 *                                                                      *
 ************************************************************************
 */

static int
createVelocityCache(modl_T *MODL,       /* (in)  pointer to MODL */
                    int    jbody)       /* (in)  Body index (1:nbody) */
{
    int       status = EGADS_SUCCESS;   /* (out) return status */

    int       nsketch, i, oclass, mtype, nchild, attrType;
    CINT      *tempIlist;
    double    *Rbeg, *Rbeg_dot, Rbeg_local[2], *Rend, *Rend_dot, Rend_local[2];
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;
    ego       ebody, topref, eprev, enext, *echilds, esketch[MAX_NUM_SKETCHES];

    egadsSplineVels  splData;
    egadsSpline_T    spl;

    ROUTINE(createVelocityCache);

    /* --------------------------------------------------------------- */

    /* make array of Xsects */
//$$$    nsketch = 0;
//$$$    printf("ileft[jbody=%d]=%d,  irite[jbody=%d]=%d\n", jbody, MODL->body[jbody].ileft, jbody, MODL->body[jbody].irite);
//$$$    for (kbody = MODL->body[jbody].ileft; kbody <= MODL->body[jbody].irite; kbody++) {
//$$$        printf("     ichld[kbody=%d]=%d\n", kbody, MODL->body[kbody].ichld);
//$$$        if (MODL->body[kbody].ichld != jbody) continue;
//$$$        isketch[nsketch++] = kbody;
//$$$        printf("         nsketch=%d\n", nsketch);
//$$$    }

    status = EG_attributeRet(MODL->body[jbody].ebody, "__usedBodys__",
                             &attrType, &nsketch, &tempIlist, &tempRlist, &tempClist);
    CHECK_STATUS(EG_attributeRet);

    if (attrType != ATTRINT) {
        status = OCSM_ILLEGAL_ATTRIBUTE;
        goto cleanup;
    }

    /* fill in the array of Xsects */
    for (i = 0; i < nsketch; i++) {
        ebody      = MODL->body[tempIlist[i]].ebody;
        esketch[i] = NULL;
        echilds    = NULL;

        status = EG_getInfo(ebody, &oclass, &mtype, &topref, &eprev, &enext);
        CHECK_STATUS(EG_getInfo);

        /* if Xsect is a NodeBody or WireBody, store its Loop in esketch */
        if        (oclass == BODY && mtype == WIREBODY) {
            status = EG_getBodyTopos(ebody, NULL, NODE, &nchild, &echilds);
            CHECK_STATUS(EG_getBodyTopos);
            SPLINT_CHECK_FOR_NULL(echilds);

            if (nchild == 1) {          // NodeBody
                esketch[i] = echilds[0];
            } else {                    // WireBody
                EG_free(echilds);

                status = EG_getBodyTopos(ebody, NULL, LOOP, &nchild, &echilds);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(echilds);

                esketch[i] = echilds[0];
            }

        /* if Xsect is a SheetBody, store it's Loop in esketch unless it is the
           first or last Xsect, in which case store its  Loop */
        } else if (oclass == BODY && (mtype == FACEBODY || mtype == SHEETBODY)) {
            if (i == 0 || i == nsketch-1) {
                status = EG_getBodyTopos(ebody, NULL, FACE, &nchild, &echilds);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(echilds);

                esketch[i] = echilds[0];
            } else {
                EG_free(echilds);

                status = EG_getBodyTopos(ebody, NULL, LOOP, &nchild, &echilds);
                CHECK_STATUS(EG_getBodyTopos);
                SPLINT_CHECK_FOR_NULL(echilds);

                esketch[i] = echilds[0];
            }
        }

        if (echilds != NULL) {
            EG_free(echilds);
        }

        if (esketch[i] == NULL) {
            status = -9999;
            goto cleanup;
        }
    }

    /* reorder Loops to eliminate twisting */
    status = reorderLoops(MODL, nsketch, esketch, NINT(MODL->body[jbody].arg[1].val[0]));
    CHECK_STATUS(reorderLoops);

    /* compute data required to get design velocities */
    /*@ignore@*/
    spl.isketch = (int *)tempIlist;
    spl.MODL    = MODL;

    splData.usrData           = &spl;
    splData.velocityOfRange   = &splineVelocityOfRange;
    splData.velocityOfNode    = &splineVelocityOfNode;
    splData.velocityOfEdge    = &splineVelocityOfEdge;
    splData.velocityOfBspline = &splineVelocityOfBspline;
    /*@end@*/

    /* populate the _dot for use by RULE or BLEND sensitivities */
    if (MODL->body[jbody].brtype == OCSM_RULE) {
        status = EG_ruled_vels(nsketch, esketch,
                               &splData, MODL->body[jbody].ebody);
        CHECK_STATUS(EG_ruled_vels);

    } else {
        if        (MODL->body[jbody].arg[1].nval >= 8) {
            Rbeg          = MODL->body[jbody].arg[1].val;
            Rbeg_dot      = MODL->body[jbody].arg[1].dot;
        } else if (MODL->body[jbody].arg[1].nval >= 4) {
            Rbeg          = MODL->body[jbody].arg[1].val;
            Rbeg_dot      = MODL->body[jbody].arg[1].dot;
        } else if (MODL->body[jbody].arg[1].nval >= 2) {
            Rbeg_local[0] = 0;
            Rbeg_local[1] = MODL->body[jbody].arg[1].val[1];
            Rbeg          = Rbeg_local;
            Rbeg_dot      = MODL->body[jbody].arg[1].dot;
        } else {
            Rbeg          = NULL;
            Rbeg_dot      = NULL;
        }

        if        (MODL->body[jbody].arg[2].nval >= 8) {
            Rend          = MODL->body[jbody].arg[2].val;
            Rend_dot      = MODL->body[jbody].arg[2].dot;
        } else if (MODL->body[jbody].arg[2].nval >= 4) {
            Rend          = MODL->body[jbody].arg[2].val;
            Rend_dot      = MODL->body[jbody].arg[2].dot;
        } else if (MODL->body[jbody].arg[2].nval >= 2) {
            Rend_local[0] = 0;
            Rend_local[1] = MODL->body[jbody].arg[2].val[1];
            Rend          = Rend_local;
            Rend_dot      = MODL->body[jbody].arg[2].dot;
        } else {
            Rend          = NULL;
            Rend_dot      = NULL;
        }

//$$$        printf("EG_blend_vels(nsketch=%d, jbody=%d)\n", nsketch, jbody);
        status = EG_blend_vels(nsketch, esketch, Rbeg, Rbeg_dot, Rend, Rend_dot,
                               &splData, MODL->body[jbody].ebody);
        CHECK_STATUS(EG_blend_vels);
    }

    /* remember that we have a cache for jbody */
    MODL->body[jbody].hassens = 1;

    if (MODL->body[jbody].brtype == OCSM_RULE) {
        SPRINT1(2, "           finished RULE cache for jbody=%d", jbody);
    } else {
        SPRINT1(2, "           finished BLEND cache for jbody=%d", jbody);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   delPmtrByName - delete last Parameter with given name              *
 *                                                                      *
 ************************************************************************
 */

static int
delPmtrByName(modl_T *MODL,             /* (in)  pointer to MODL */
              char   name[])            /* (in)  Parameter name */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipmtr;

    ROUTINE(delPmtrByName);

    /* --------------------------------------------------------------- */

    /* start looking from the end of the list for the named Parameter */
    for (ipmtr = MODL->npmtr; ipmtr >= 1; ipmtr--) {
        if (strcmp(MODL->pmtr[ipmtr].name, name) == 0) {
            status = ocsmDelPmtr(MODL, ipmtr);
            goto cleanup;
        }
    }

    /* name not found */
    status = OCSM_NAME_NOT_FOUND;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   dumpEgadsFile - dump file if dumpEgads flag is set                 *
 *                                                                      *
 ************************************************************************
 */

static int
dumpEgadsFile(modl_T *MODL,
              int    ibody)
{
    int       status = SUCCESS;         /* (out) return status */

    int        sense, iarg, ipmtr, ibrch;
    double     data[6];
    char       dumpfile[MAX_EXPR_LEN], argname[MAX_NAME_LEN], attrname[MAX_NAME_LEN];
    ego        ecurve, enodes[2], eedge, eloop, ebody, etemp, emodel;

    ROUTINE(dumpEgadsFile);

    /* --------------------------------------------------------------- */

    if (MODL->dumpEgads == 0) {
        goto cleanup;

    /* do not dump if Body was just loaded from a file */
    } else if (ibody == MODL->bodyLoaded) {
        goto cleanup;
    }

    /* find filename */
    snprintf(dumpfile, MAX_EXPR_LEN, "Body_%06d.egads", ibody);

    (void) remove(dumpfile);

    /* if a SketchBody, create a dummy Body so that an .egads file
       can be created */
    if (MODL->body[ibody].botype == OCSM_SKETCH) {
        data[0] = 0;   data[1] = 0;   data[2] = 0;
        data[3] = 1;   data[4] = 0;   data[5] = 0;

        status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, data, &ecurve);
        CHECK_STATUS(EG_makeGeometry);

        status = EG_makeTopology(MODL->context, NULL, NODE, 0, &(data[0]),
                                 0, NULL, NULL, &(enodes[0]));
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, NODE, 0, &(data[3]),
                                 0, NULL, NULL, &(enodes[1]));
        CHECK_STATUS(EG_makeTopology);

        data[0] = 0;   data[1] = 1;

        status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE, data,
                                 2, enodes, NULL, &eedge);
        CHECK_STATUS(EG_makeTopology);

        sense = SFORWARD;
        status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN, NULL,
                                 1, &eedge, &sense, &eloop);
        CHECK_STATUS(EG_makeTopology);

        status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY, NULL,
                                 1, &eloop, NULL, &ebody);
        CHECK_STATUS(EG_makeTopology);

        status = EG_copyObject(ebody, NULL, &etemp);
        CHECK_STATUS(EG_copyObject);

        status = EG_deleteObject(ebody);
        CHECK_STATUS(EG_deleteBody);
    } else {
        status = EG_copyObject(MODL->body[ibody].ebody, NULL, &etemp);
        CHECK_STATUS(EG_copyObject);
    }

    /* make attributed Model */
    ibrch = MODL->body[ibody].ibrch;
    status = EG_attributeAdd(etemp, "__filename__", ATTRSTRING,
                             1, NULL, NULL, MODL->brch[ibrch].filename);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__brtype__", ATTRINT,
                             1, &(MODL->body[ibody].brtype), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    for (iarg = 1; iarg <= 9; iarg++) {
        snprintf(argname, MAX_NAME_LEN, "__arg%d__", iarg);
        if        (MODL->body[ibody].arg[iarg].nval > 0) {
            status = EG_attributeAdd(etemp, argname, ATTRREAL,
                                     MODL->body[ibody].arg[iarg].nval,
                                     NULL, MODL->body[ibody].arg[iarg].val, NULL);
            CHECK_STATUS(EG_attributeAdd);
        } else if (MODL->body[ibody].arg[iarg].nval == 0) {
            status = EG_attributeAdd(etemp, argname, ATTRSTRING,
                                     MODL->body[ibody].arg[iarg].nval,
                                     NULL, NULL, MODL->body[ibody].arg[iarg].str);
                CHECK_STATUS(EG_attributeAdd);
        }
    }

    status = EG_attributeAdd(etemp, "__ibrch__", ATTRINT,
                             1, &(MODL->body[ibody].ibrch), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__ileft__", ATTRINT,
                             1, &(MODL->body[ibody].ileft), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__irite__", ATTRINT,
                             1, &(MODL->body[ibody].irite), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__igroup__", ATTRINT,
                             1, &(MODL->body[ibody].igroup), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(etemp, "__botype__", ATTRINT,
                             1, &(MODL->body[ibody].botype), NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].name[0] == '@' &&
            MODL->pmtr[ipmtr].name[1] == '@'   ) {
            strcpy(attrname, "__");
            strcat(attrname, MODL->pmtr[ipmtr].name);
            strcat(attrname, "__");

            status = EG_attributeAdd(etemp, attrname, ATTRREAL,
                                     MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                                     NULL, MODL->pmtr[ipmtr].value, NULL);
            CHECK_STATUS(EG_attributeAdd);
        }
    }

    status = EG_makeTopology(MODL->context, NULL, MODEL, 0, NULL,
                             1, &etemp, NULL, &emodel);
    CHECK_STATUS(EG_makeTopology);

    status = EG_saveModel(emodel, dumpfile);
    CHECK_STATUS(EG_saveModel);

    status = EG_deleteObject(emodel);
    CHECK_STATUS(EG_deleteObject);

    SPRINT1(1, "--> dumped %s", dumpfile);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   efaceJacobian - compute jacobian of the Face to EFace transformation  *
 *                                                                      *
 ************************************************************************
 */

static int
efaceJacobian(modl_T *MODL,             /* (in)  pointer to MODL */
              int    ibody,             /* (in)  Body index (1:nbody) */
              int    iface,             /* (in)  Face index (1:nface) */
              double dudue[],           /* (out) derivative of transformation */
              double dvdue[],           /* (out) derivative of transformation */
              double dudve[],           /* (out) derivative of transformation */
              double dvdve[])           /* (out) derivative of transformation */
{
    int       status = SUCCESS;

    int       neface, npnt, ipnt, ntri, itri, ip0, ip1, ip2;
    int       *count=NULL;
    CINT      *ptype, *pindx, *tris, *tric;
    double    mat[9], rhs[3], ABC[3], DEF[3], eps;
    double    uveface1[2], uveface2[2], uvface0[2], uvface1[2], uvface2[2];
    double    *uvface=NULL;
    CDOUBLE   *xyze, *uve;
    ego       *eefaces, eeface, eface0, eface1, eface2, *efaces=NULL;

    ROUTINE(efaceJacobian);

    /* --------------------------------------------------------------- */

    if        (MODL->body[ibody].eebody == NULL) {
        SPRINT1(1, "MODL->body[%d].eebody is NULL", ibody);
        status = -999;
        goto cleanup;
    } else if (MODL->body[ibody].eetess == NULL) {
        SPRINT1(1, "MODL->body[%d].eetess is NULL", ibody);
        status = -999;
        goto cleanup;
    }

    /* find the EFace */
    status = EG_getBodyTopos(MODL->body[ibody].eebody, NULL, EFACE, &neface, &eefaces);
    CHECK_STATUS(EG_getBodyTopos);

    SPLINT_CHECK_FOR_NULL(eefaces);

    eeface = eefaces[iface-1];

    EG_free(eefaces);

    /* get the tessellation for this EFace */
    status = EG_getTessFace(MODL->body[ibody].eetess, iface,
                            &npnt, &xyze, &uve, &ptype, &pindx,
                            &ntri, &tris, &tric);
    CHECK_STATUS(EG_getTessFace);

    /* get storage for the number of triangles associated with each point */
    MALLOC(count, int, npnt);

    /* initialize all arrays */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        dudue[ipnt] = 0;
        dvdue[ipnt] = 0;
        dudve[ipnt] = 0;
        dvdve[ipnt] = 0;
        count[ipnt] = 0;
    }

    /* get the mapping between the EFace and the underlying Faces */
    MALLOC(efaces, ego,      npnt);
    MALLOC(uvface, double, 2*npnt);

    status = EG_getTessEFace(MODL->body[ibody].eetess, iface, efaces, uvface);
    CHECK_STATUS(EG_getTessEFace);

    /* loop through the triangles */
    for (itri = 0; itri < ntri; itri++) {
        ip0 = tris[3*itri  ] - 1;
        ip1 = tris[3*itri+1] - 1;
        ip2 = tris[3*itri+2] - 1;

        /* skip this triangle if it uses more than one underlying Face */
        if (efaces[ip0] != efaces[ip1] || efaces[ip0] != efaces[ip2]) continue;

        /* find the slope of the triangle and deposit it at the triangle's points */
        mat[0] = uve[2*ip0];   mat[1] = uve[2*ip0+1];   mat[2] = 1;
        mat[3] = uve[2*ip1];   mat[4] = uve[2*ip1+1];   mat[5] = 1;
        mat[6] = uve[2*ip2];   mat[7] = uve[2*ip2+1];   mat[8] = 1;

        rhs[0] = uvface[2*ip0];
        rhs[1] = uvface[2*ip1];
        rhs[2] = uvface[2*ip2];

        status = matsol(mat, rhs, 3, ABC);
        CHECK_STATUS(matsol);

        mat[0] = uve[2*ip0];   mat[1] = uve[2*ip0+1];   mat[2] = 1;
        mat[3] = uve[2*ip1];   mat[4] = uve[2*ip1+1];   mat[5] = 1;
        mat[6] = uve[2*ip2];   mat[7] = uve[2*ip2+1];   mat[8] = 1;

        rhs[0] = uvface[2*ip0+1];
        rhs[1] = uvface[2*ip1+1];
        rhs[2] = uvface[2*ip2+1];

        status = matsol(mat, rhs, 3, DEF);
        CHECK_STATUS(matsol);

        dudue[ip0] += ABC[0];
        dudve[ip0] += ABC[1];
        dvdue[ip0] += DEF[0];
        dvdve[ip0] += DEF[1];
        count[ip0] += 1;

        dudue[ip1] += ABC[0];
        dudve[ip1] += ABC[1];
        dvdue[ip1] += DEF[0];
        dvdve[ip1] += DEF[1];
        count[ip1] += 1;

        dudue[ip2] += ABC[0];
        dudve[ip2] += ABC[1];
        dvdue[ip2] += DEF[0];
        dvdve[ip2] += DEF[1];
        count[ip2] += 1;
    }

    /* loop through all the points */
    for (ipnt = 0; ipnt < npnt; ipnt++) {

        /* boundary points get zero derivative (since it will not be needed) */
        if (ptype[ipnt] >= 0) {
            dudue[ipnt] = 0;
            dvdue[ipnt] = 0;
            dudve[ipnt] = 0;
            dvdve[ipnt] = 0;

        /* if any triangle deposited a slope, divide by the number of triangles */
        } else if (count[ipnt] > 0) {
            dudue[ipnt] /= count[ipnt];
            dvdue[ipnt] /= count[ipnt];
            dudve[ipnt] /= count[ipnt];
            dvdve[ipnt] /= count[ipnt];

        /* otherwise get the derivative by finite differences */
        } else {
            SPRINT3(0, "WARNING:: using finite differences for EFace %d at (%10.5f,%10.5f)",
                    iface, uvface[2*ipnt], uvface[2*ipnt+1]);
            (MODL->nwarn)++;

            /* base point */
            eface0     = efaces[  ipnt  ];
            uvface0[0] = uvface[2*ipnt  ];
            uvface0[1] = uvface[2*ipnt+1];

            /* finite difference for d()/due */
            eface1     = NULL;
            eps        = 1e-5;
            uvface1[0] = HUGEQ;
            uvface1[1] = HUGEQ;

            while (eface1 != eface0) {
                eps = -eps / 2;

                uveface1[0] = uve[2*ipnt  ]+ eps;
                uveface1[1] = uve[2*ipnt+1];

                status = EG_effectiveMap(eeface, uveface1, &eface1, uvface1);
                CHECK_STATUS(EG_effectiveMap);
            }

            dudue[ipnt] = (uvface1[0] - uvface0[0]) / eps;
            dvdue[ipnt] = (uvface1[1] - uvface0[1]) / eps;

            /* finite difference for (d()/dve */
            eface2     = NULL;
            eps        = 1e-5;
            uvface2[0] = HUGEQ;
            uvface2[1] = HUGEQ;

            while (eface2 != eface0) {
                uveface2[0] = uve[2*ipnt  ];
                uveface2[1] = uve[2*ipnt+1] + eps;

                status = EG_effectiveMap(eeface, uveface2, &eface2, uvface2);
                CHECK_STATUS(EG_effectiveMap);
            }

            dudve[ipnt] = (uvface2[0] - uvface0[0]) / eps;
            dvdve[ipnt] = (uvface2[1] - uvface0[1]) / eps;
        }
    }

cleanup:
    FREE(efaces);
    FREE(uvface);
    FREE(count );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   evalRpn - evaluate Rpn-code                                        *
 *                                                                      *
 ************************************************************************
 */

static int
evalRpn(rpn_T     *rpn,                 /* (in)  pointer to Rpn-code */
/*@null@*/modl_T  *modl,                /* (in)  pointer to MODL */
        double    *val,                 /* (out) value      of expression */
        double    *dot,                 /* (out) derivative of expression */
        char      str[])                /* (out) value if string-valued or error */
{
    int       status = SUCCESS;         /* (out) return status */

    int       irpn, nvalstack, ival, ipmtr, jpmtr, irow, icol, irc, ietype, ii, jj;
    int       ibeg, iend, imprp, ibrch, update;
    int       nan1, nan2, nan3, nan4, nan5, nan6, nan7, nan8;
    double    val1, dot1, val2, dot2, val3;
#ifndef WIN32
    double __attribute__((unused)) dot3, val4, dot4;    /* needed to eliminate compiler warning */
#else
    double                         dot3, val4, dot4;
#endif
    double    xa,  xa_d,  ya,  ya_d,  xb, xb_d, yb, yb_d, xc, xc_d, yc, yc_d;
    double    dab, dab_d, dbc, dbc_d, R,  R_d,  L,  L_d;
    double    Xcent, Xcent_d, Ycent, Ycent_d, Xmidl, Xmidl_d, Ymidl, Ymidl_d;
    double    seglen, seglen_d, phi, phi_d, angle, angle_d, sweep, sweep_d;
    double    angab, angab_d, angbc, angbc_d;
    double    rad2deg = 1 / PIo180;
    double    pow1, pow2;
    char      prefix[MAX_NAME_LEN], suffix[MAX_NAME_LEN];
    char      str1[MAX_STRVAL_LEN], str2[MAX_STRVAL_LEN], str3[MAX_STRVAL_LEN];
    char      str4[MAX_STRVAL_LEN], str5[MAX_STRVAL_LEN], str6[MAX_STRVAL_LEN];
    char      str7[MAX_STRVAL_LEN], str8[MAX_STRVAL_LEN];
    char      errstr[MAX_STRVAL_LEN], tmp_text[MAX_STRVAL_LEN-17];
    char      *temp, *buffer, *esp_root;
    stack_T   *valstack=NULL;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(evalRpn);

#define PUSH_VAL(VAL,DOT,STR,NAN)               \
    if (nvalstack < MAX_EXPR_LEN-1) {           \
        valstack[nvalstack].val = VAL;          \
        valstack[nvalstack].dot = DOT;          \
        strcpy(valstack[nvalstack].str, STR);   \
        valstack[nvalstack].nan = NAN;          \
        nvalstack++;                            \
    } else {                                    \
        status = OCSM_VAL_STACK_OVERFLOW;       \
        goto cleanup;                           \
    }

#define POP_VAL(VAL,DOT,STR,NAN)                \
    if (nvalstack > 0) {                        \
        nvalstack--;                            \
        VAL = valstack[nvalstack].val;          \
        DOT = valstack[nvalstack].dot;          \
        strcpy(STR, valstack[nvalstack].str);   \
        NAN = valstack[nvalstack].nan;          \
    } else {                                    \
        status = OCSM_VAL_STACK_UNDERFLOW;      \
        goto cleanup;                           \
    }

    /* --------------------------------------------------------------- */

    MALLOC(valstack, stack_T, MAX_EXPR_LEN);

    /* default answer (in case there is an error) */
    *val   = 0;
    *dot   = 0;
    str[0] = '\0';

    /* flag to remember if this came from illegal_pmtr_name, illegal_value, or func_arg_out_of_bounds */
    ietype = 0;

    /* start with an empty value stack */
    nvalstack = 0;

    /* if any PARSE_NAME is a mass property, set up now */
    if (MODL != NULL) {
        irpn = 0;
        while (rpn[irpn].type != PARSE_END) {
            if (rpn[irpn].type == PARSE_NAME) {
                for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                    if (strcmp(MODL->pmtr[ipmtr].name, rpn[irpn].text) == 0       &&
                               MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                        if (MODL->pmtr[ipmtr].mprop == 1) {
                            status = computeMassProps(MODL);
                            CHECK_STATUS(computeMassProps);

                            ibrch  = MODL->ibrch;
                            update = 0;
                            for (imprp = 0; imprp < MODL->brch[ibrch].nmprp; imprp++) {
                                if (strcmp(rpn[irpn].text, MODL->brch[ibrch].mprp[imprp].name) == 0) {
                                    MODL->brch[ibrch].mprp[imprp].val = MODL->pmtr[ipmtr].value[0];
                                    update = 1;
                                    break;
                                }
                            }

                            if (update == 0) {
                                imprp = MODL->brch[ibrch].nmprp;

                                RALLOC(MODL->brch[ibrch].mprp, mprp_T, MODL->brch[ibrch].nmprp+1);

                                strncpy(MODL->brch[ibrch].mprp[imprp].name, rpn[irpn].text, 10);
                                MODL->brch[ibrch].mprp[imprp].val = MODL->pmtr[ipmtr].value[0];

                                (MODL->brch[ibrch].nmprp)++;
                            }

                            if (MODL->numdots > 0) {
                                if (MODL->basemodl != NULL) {
                                    MODL->basemodl->pmtr[ipmtr].dot[0]
                                        = (MODL->pmtr[ipmtr].value[0] - MODL->basemodl->brch[ibrch].mprp[imprp].val) / MODL->dtime;
                                } else if (MODL->needFDs == 0) {
                                    status = computeMassPropsDot(MODL);
                                    CHECK_STATUS(computeMassPropsDot);
                                }
                            }

                            break;
                        }
                    }
                }
            }
            irpn++;
        }
    }

    /* loop through whole Rpn-code */
    irpn = 0;
    while (rpn[irpn].type != PARSE_END) {

        SPRINT3(3, "executing %3d type=%2d, text=%s", irpn, rpn[irpn].type, rpn[irpn].text);

        /* PARSE_NUM */
        if (rpn[irpn].type == PARSE_NUMBER) {
            PUSH_VAL(strtod(rpn[irpn].text, (char**)NULL), 0.0, "", 0);

        /* PARSE_STRING */
        } else if (rpn[irpn].type == PARSE_STRING) {
            PUSH_VAL(0, 0, rpn[irpn].text, 0);

        /* PARSE_NAME */
        } else if (rpn[irpn].type == PARSE_NAME) {
            jpmtr = 0;
            if (MODL != NULL) {
                prefix[0] = '\0';
                suffix[0] = '\0';
                for (irc = 0; irc < MAX_NAME_LEN-1; irc++) {
                    if (rpn[irpn].text[irc] == '\0') {
                        break;
                    } else if (rpn[irpn].text[irc] != '.') {
                        prefix[irc  ] = rpn[irpn].text[irc];
                        prefix[irc+1] = '\0';
                    } else {
                        STRNCPY(suffix, &(rpn[irpn].text[irc]), MAX_NAME_LEN);
                        break;
                    }
                }

                for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                    if (strcmp(MODL->pmtr[ipmtr].name, prefix) == 0                   &&
                              (MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level] ||
                               MODL->pmtr[ipmtr].type  == OCSM_CONPMTR               )  ) {
                        jpmtr = ipmtr;

                        /* check for dot-suffix */
                        if (STRLEN(suffix) == 0) {
                            irow = icol = 1;

                            if (MODL->pmtr[jpmtr].str != NULL) {
                                status = ocsmGetValuS(MODL, jpmtr, str1);
                                CHECK_STATUS(ocsmGetValuS);

                                PUSH_VAL(0, 0, str1, 0);
                            } else {
                                status = ocsmGetValu(MODL, jpmtr, irow, icol, &val1, &dot1);
                                CHECK_STATUS(ocsmGetValu);

                                if (val1 != -HUGEQ) {
                                    PUSH_VAL(val1, dot1, "", 0);
                                } else {
                                    STRNCPY(tmp_text, rpn[irpn].text, MAX_STRVAL_LEN-18);
                                    snprintf(errstr, MAX_STRVAL_LEN, "\"%s\" is not defined", tmp_text);
                                    PUSH_VAL(0,    0,    "", 1);
                                    ietype = OCSM_ILLEGAL_VALUE;
                                }
                            }
                            break;
                        } else if (strcmp(suffix, ".nrow") == 0) {
                            if (MODL->pmtr[ipmtr].str != NULL) {
                                PUSH_VAL(0, 0, "", 0);
                            } else {
                                val1 = MODL->pmtr[ipmtr].nrow;
                                PUSH_VAL(val1, 0, "", 0);
                            }
                            break;
                        } else if (strcmp(suffix, ".ncol") == 0) {
                            if (MODL->pmtr[ipmtr].str != NULL) {
                                PUSH_VAL(0, 0, "", 0);
                            } else {
                                val1 = MODL->pmtr[ipmtr].ncol;
                                PUSH_VAL(val1, 0, "", 0);
                            }
                            break;
                        } else if (strcmp(suffix, ".size") == 0) {
                            if (MODL->pmtr[ipmtr].str != NULL) {
                                val1 = STRLEN(MODL->pmtr[ipmtr].str);
                                PUSH_VAL(val1, 0, "", 0);
                            } else {
                                val1 = (MODL->pmtr[ipmtr].nrow) * (MODL->pmtr[ipmtr].ncol);
                                PUSH_VAL(val1, 0, "", 0);
                            }
                            break;
                        } else if (strcmp(suffix, ".sum")  == 0) {
                            val1 = 0;
                            dot1 = 0;
                            for (irc = 0; irc < (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol); irc++) {
                                val1 += MODL->pmtr[ipmtr].value[irc];
                                dot1 += MODL->pmtr[ipmtr].dot[  irc];
                            }
                            PUSH_VAL(val1, dot1, "", 0);
                            break;
                        } else if (strcmp(suffix, ".norm")  == 0) {
                            val1 = 0;
                            dot1 = 0;
                            for (irc = 0; irc < (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol); irc++) {
                                val1 += MODL->pmtr[ipmtr].value[irc] * MODL->pmtr[ipmtr].value[irc];
                                dot1 += MODL->pmtr[ipmtr].value[irc] * MODL->pmtr[ipmtr].dot[  irc];
                            }
                            if (val1 > 0) {
                                PUSH_VAL(sqrt(val1), dot1/sqrt(val1), "", 0);
                            } else {
                                PUSH_VAL(0, 0, "", 0);
                            }
                            break;
                        } else if (strcmp(suffix, ".min")  == 0) {
                            val1 = MODL->pmtr[ipmtr].value[0];
                            dot1 = MODL->pmtr[ipmtr].dot[  0];
                            for (irc = 0; irc < (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol); irc++) {
                                if (MODL->pmtr[ipmtr].value[irc] < val1) {
                                    val1 = MODL->pmtr[ipmtr].value[irc];
                                    dot1 = MODL->pmtr[ipmtr].dot[  irc];
                                }
                            }
                            PUSH_VAL(val1, dot1, "", 0);
                            break;
                        } else if (strcmp(suffix, ".max")  == 0) {
                            val1 = MODL->pmtr[ipmtr].value[0];
                            dot1 = MODL->pmtr[ipmtr].dot[  0];
                            for (irc = 0; irc < (MODL->pmtr[ipmtr].nrow)*(MODL->pmtr[ipmtr].ncol); irc++) {
                                if (MODL->pmtr[ipmtr].value[irc] > val1) {
                                    val1 = MODL->pmtr[ipmtr].value[irc];
                                    dot1 = MODL->pmtr[ipmtr].dot[  irc];
                                }
                            }
                            PUSH_VAL(val1, dot1, "", 0);
                            break;
                        } else if (strcmp(suffix, ".dot")  == 0) {
                            val1 = MODL->pmtr[ipmtr].value[0];
                            dot1 = MODL->pmtr[ipmtr].dot[  0];
                            PUSH_VAL(dot1, 0, "", 0);
                            break;
                        } else {
                            signalError(MODL, OCSM_ILLEGAL_PMTR_NAME,
                                        "illegal suffix (%s) in name", suffix);
                            status = OCSM_ILLEGAL_PMTR_NAME;
                            goto cleanup;
                        }
                    }
                }
            }
            if (jpmtr == 0) {
                STRNCPY(tmp_text, rpn[irpn].text, MAX_STRVAL_LEN-18);
                snprintf(errstr, MAX_STRVAL_LEN, "\"%s\" is not defined", tmp_text);
                PUSH_VAL(0, 0, "", 1);
                ietype = OCSM_ILLEGAL_PMTR_NAME;
            }

        /* PARSE_ARRAY */
        } else if (rpn[irpn].type == PARSE_ARRAY) {
            jpmtr = 0;
            if (MODL != NULL) {
                for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
                    if (strcmp(MODL->pmtr[ipmtr].name, rpn[irpn].text) == 0       &&
                               MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
                        jpmtr = ipmtr;

                        POP_VAL(val1, dot1, str1, nan1);
                        POP_VAL(val2, dot2, str2, nan2);

                        irow = NINT(val2);
                        icol = NINT(val1);

                        status = ocsmGetValu(MODL, jpmtr, irow, icol, &val1, &dot1);
                        CHECK_STATUS(ocsmGetValu);

                        PUSH_VAL(val1, dot1, "", 0);
                        break;
                    }
                }
            }
            if (jpmtr == 0) {
                STRNCPY(tmp_text, rpn[irpn].text, MAX_STRVAL_LEN-18);
                snprintf(errstr, MAX_STRVAL_LEN, "\"%s\" is not defined", tmp_text);
                PUSH_VAL(0, 0, "", 1);
                ietype = OCSM_ILLEGAL_PMTR_NAME;
            }

        /* PARSE_OP1 or PARSE_OP2 or PARSE_OP3 */
        } else if (rpn[irpn].type == PARSE_OP1 ||
                   rpn[irpn].type == PARSE_OP2 ||
                   rpn[irpn].type == PARSE_OP3   ) {
            if        (strcmp(rpn[irpn].text, "+") == 0) {

                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);

                if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (STRLEN(str1) > 0 && STRLEN(str2) > 0) {
                    snprintf(str3, MAX_STRVAL_LEN, "%s%s", str2, str1);
                    PUSH_VAL(0, 0, str3, 0);
                } else if (STRLEN(str2) > 0) {
                    if (fabs(val1-NINT(val1))<EPS12) {
                        snprintf(str3, MAX_STRVAL_LEN, "%s%d", str2, NINT(val1));
                    } else {
                        snprintf(str3, MAX_STRVAL_LEN, "%s%f", str2,      val1 );
                    }
                    PUSH_VAL(0, 0, str3, 0);
                } else if (STRLEN(str1) > 0) {
                    if (fabs(val2-NINT(val2)) < EPS12) {
                        snprintf(str3, MAX_STRVAL_LEN, "%d%s", NINT(val2), str1);
                    } else {
                        snprintf(str3, MAX_STRVAL_LEN, "%f%s",      val2,  str1);
                    }
                    PUSH_VAL(0, 0, str3, 0);
                } else {
                    PUSH_VAL(val2+val1, dot2+dot1, "", 0);
                }
            } else if (strcmp(rpn[irpn].text, "-") == 0) {
                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(val2-val1, dot2-dot1, "", 0);
                }
            } else if (strcmp(rpn[irpn].text, "*") == 0) {
                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(val2*val1, dot1*val2+dot2*val1, "", 0);
                }
            } else if (strcmp(rpn[irpn].text, "/") == 0) {
                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0) {
                    STRNCPY(errstr, "divide by zero", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(val2/val1, (dot2*val1-dot1*val2)/val1/val1, "", 0);
                }
            } else if (strcmp(rpn[irpn].text, "^") == 0) {
                POP_VAL(val1, dot1, str1, nan1);
                POP_VAL(val2, dot2, str2, nan2);
                ival = (int)val1;

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == (double)ival && dot1 == 0) {
                    pow1 = pow(val2, ival  );
                    pow2 = pow(val2, ival-1);
                    PUSH_VAL(pow1, dot2*ival*pow2, "", 0);
                } else if (val2 < 0.0) {
                    STRNCPY(errstr, "a^b only for a>=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else if (val2 == 0) {
                    PUSH_VAL(0, 0, "", 0);
                } else {
                    pow1 = pow(val2, val1);
                    PUSH_VAL(pow1, (dot1*log(val2)+dot2*val1/val2)*pow1, "", 0);
                }
            }

        /* PARSE_FUNC */
        } else if (rpn[irpn].type == PARSE_FUNC) {

            /* pi(x) */
            if        (strcmp(rpn[irpn].text, "pi") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(val1*PI, dot1*PI, "", 0);
                }

            /* min(x,y) */
            } else if (strcmp(rpn[irpn].text, "min") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // y
                POP_VAL(val2, dot2, str2, nan2);  // x

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < val2) {
                    PUSH_VAL(val1, dot1, "", 0);
                } else {
                    PUSH_VAL(val2, dot2, "", 0);
                }

            /* max(x,y) */
            } else if (strcmp(rpn[irpn].text, "max") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // y
                POP_VAL(val2, dot2, str2, nan2);  // x

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 > val2) {
                    PUSH_VAL(val1, dot1, "", 0);
                } else {
                    PUSH_VAL(val2, dot2, "", 0);
                }

            /* sqrt(x) */
            } else if (strcmp(rpn[irpn].text, "sqrt") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < 0.0) {
                    STRNCPY(errstr, "sqrt(x) only for x>=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(sqrt(val1), dot1/2/sqrt(val1), "", 0);
                }

            /* abs(x) */
            } else if (strcmp(rpn[irpn].text, "abs") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 >= 0) {
                    PUSH_VAL(+val1, +dot1, "", 0);
                } else {
                    PUSH_VAL(-val1, -dot1, "", 0);
                }

            /* int(x) */
            } else if (strcmp(rpn[irpn].text, "int") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    ival = (int) val1;
                    PUSH_VAL((double)ival, 0.0, "", 0);
                }

            /* nint(x) */
            } else if (strcmp(rpn[irpn].text, "nint") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    if (val1 > 0) {
                        ival = (int) (val1 + 0.50);
                    } else {
                        ival = (int) (val1 - 0.50);
                    }
                    PUSH_VAL((double)ival, 0.0, "", 0);
                }

            /* ceil(x) */
            } else if (strcmp(rpn[irpn].text, "ceil") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL((double)ceil(val1), 0.0, "", 0);
                }

            /* floor(x) */
            } else if (strcmp(rpn[irpn].text, "floor") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL((double)floor(val1), 0.0, "", 0);
                }

            /* mod(a,b) */
            } else if (strcmp(rpn[irpn].text, "mod") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // b
                POP_VAL(val2, dot2, str2, nan2);  // a

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 <= 0) {
                    STRNCPY(errstr, "mod(a,b) only for b>0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(val2-val1*(int)(val2/val1), (val1*dot2-val2*dot1)/val1/val1, "", 0);
                }

            /* sign(x) */
            } else if (strcmp(rpn[irpn].text, "sign") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(val1, dot1, "", nan1);
                } else if (val1 > 0) {
                    PUSH_VAL(+1, 0, "", 0);
                } else if (val1 < 0) {
                    PUSH_VAL(-1, 0, "", 0);
                } else {
                    PUSH_VAL( 0, 0, "", 0);
                }

            /* exp(x) */
            } else if (strcmp(rpn[irpn].text, "exp") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(exp(val1), dot1*exp(val1), "", 0);
                }

            /* log(x) */
            } else if (strcmp(rpn[irpn].text, "log") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < 0.0) {
                    STRNCPY(errstr, "log(x) only for x>=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(log(val1), dot1/val1, "", 0);
                }

            /* log10(x) */
            } else if (strcmp(rpn[irpn].text, "log10") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < 0.0) {
                    STRNCPY(errstr, "log10(x) only for x>=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(log10(val1), dot1*log10(exp(1.))/val1, "", 0);
                }

            /* sin(x) */
            } else if (strcmp(rpn[irpn].text, "sin") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(sin(val1), dot1*cos(val1), "", 0);
                }

            /* sind(x) */
            } else if (strcmp(rpn[irpn].text, "sind") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status =  OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    val1 /= rad2deg;
                    dot1 /= rad2deg;
                    PUSH_VAL(sin(val1), dot1*cos(val1), "", 0);
                }

            /* asin(x) */
            } else if (strcmp(rpn[irpn].text, "asin") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < -1.0 || val1 > 1.0) {
                    STRNCPY(errstr, "asin(x) only for abs(x)<=1", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(asin(val1), dot1/sqrt(1-val1*val1), "", 0);
                }

            /* asind(x) */
            } else if (strcmp(rpn[irpn].text, "asind") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < -1.0 || val1 > 1.0) {
                    STRNCPY(errstr, "asind(x) only for abs(x)<=1", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(asin(val1)*rad2deg, dot1*rad2deg/sqrt(1-val1*val1), "", 0);
                }

            /* cos(x) */
            } else if (strcmp(rpn[irpn].text, "cos") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(cos(val1), -dot1*sin(val1), "", 0);
                }

            /* cosd(x) */
            } else if (strcmp(rpn[irpn].text, "cosd") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    val1 /= rad2deg;
                    dot1 /= rad2deg;
                    PUSH_VAL(cos(val1), -dot1*sin(val1), "", 0);
                }

            /* acos(x) */
            } else if (strcmp(rpn[irpn].text, "acos") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < -1.0 || val1 > 1.0) {
                    STRNCPY(errstr, "acos(x) only for abs(x)<=1", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(acos(val1), -dot1/sqrt(1-val1*val1), "", 0);
                }

            /* acosd(x) */
            } else if (strcmp(rpn[irpn].text, "acosd") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 < -1.0 || val1 > 1.0) {
                    STRNCPY(errstr, "acosd(x) only for abs(x)<=1", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(acos(val1)*rad2deg, -dot1*rad2deg/sqrt(1-val1*val1), "", 0);
                }

            /* tan(x) */
            } else if (strcmp(rpn[irpn].text, "tan") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(tan(val1), dot1/cos(val1)/cos(val1), "", 0);
                }

            /* tand(x) */
            } else if (strcmp(rpn[irpn].text, "tand") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    val1 /= rad2deg;
                    dot1 /= rad2deg;

                    PUSH_VAL(tan(val1), dot1/cos(val1)/cos(val1), "", 0);
                }

            /* atan(x) */
            } else if (strcmp(rpn[irpn].text, "atan") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(atan(val1), dot1/(1+val1*val1), "", 0);
                }

            /* atand(x) */
            } else if (strcmp(rpn[irpn].text, "atand") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    PUSH_VAL(atan(val1)*rad2deg, dot1*rad2deg/(1+val1*val1), "", 0);
                }

            /* atan2(y,x) */
            } else if (strcmp(rpn[irpn].text, "atan2") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x
                POP_VAL(val2, dot2, str2, nan2);  // y

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0 && val2 == 0.0) {
                    STRNCPY(errstr, "atan2(x,y) only for x!=0 or y!=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(atan2(val2,val1), (dot2*val1-dot1*val2)/(val1*val1+val2*val2), "", 0);
                }

            /* atan2d(y,x) */
            } else if (strcmp(rpn[irpn].text, "atan2d") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x
                POP_VAL(val2, dot2, str2, nan2);  // y

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0 && val2 == 0.0) {
                    STRNCPY(errstr, "atan2d(x,y) only for x!=0 or y!=0", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                } else {
                    PUSH_VAL(atan2(val2,val1)*rad2deg, (dot2*val1-dot1*val2)*rad2deg/(val1*val1+val2*val2), "", 0);
                }

            /* hypot(x,y) */
            } else if (strcmp(rpn[irpn].text, "hypot") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // y
                POP_VAL(val2, dot2, str2, nan2);  // x

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0 && val2 == 0.0) {
                    PUSH_VAL(0.0, 0.0, "", 0);
                } else {
                    PUSH_VAL(sqrt(val1*val1+val2*val2), (dot1*val1+dot2*val2)/sqrt(val1*val1+val2*val2), "", 0);
                }

            /* hypot3(x,y,z) */
            } else if (strcmp(rpn[irpn].text, "hypot3") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // z
                POP_VAL(val2, dot2, str2, nan2);  // y
                POP_VAL(val3, dot3, str3, nan3);  // x

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val1 == 0.0 && val2 == 0.0 && val3 == 0.0) {
                    PUSH_VAL(0.0, 0.0, "", 0);
                } else {
                    PUSH_VAL(sqrt(val1*val1+val2*val2+val3*val3), (dot1*val1+dot2*val2+dot3*val3)/sqrt(val1*val1+val2*val2+val3*val3), "", 0);
                }

            /* incline(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "incline") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    angle   = atan2(yb-ya, xb-xa);
                    angle_d = ((xb-xa) * (yb_d-ya_d) - (yb-ya) * (xb_d-xa_d))
                            / ((xb-xa) * (xb  -xa  ) + (yb-ya) * (yb  -ya  ));

                    PUSH_VAL(angle*rad2deg, angle_d*rad2deg, "", 0);
                }

            /* Xcent(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "Xcent") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xa
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    Xcent   = (xa   + xb  ) / 2;
                    Xcent_d = (xa_d + xb_d) / 2;

                    PUSH_VAL(Xcent, Xcent_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (4 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    Xcent   = (xa   + xb  ) / 2
                            - (R-dab) * (yb-ya) / (2*L);
                    Xcent_d = (xa_d + xb_d) / 2
                            - (R_d-dab_d) * (yb  -ya  ) / (2*L)
                            - (R  -dab  ) * (yb_d-ya_d) / (2*L)
                            + L_d * (R-dab) * (yb-ya) / (2*L*L);

                    PUSH_VAL(Xcent, Xcent_d, "", 0);
                }

            /* Ycent(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "Ycent") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    Ycent   = (ya   + yb  ) / 2;
                    Ycent_d = (ya_d + yb_d) / 2;

                    PUSH_VAL(Ycent, Ycent_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (4 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    Ycent   = (ya + yb) / 2
                            + (R-dab) * (xb-xa) / (2*L);
                    Ycent_d = (ya_d + yb_d) / 2
                            + (R_d-dab_d) * (xb  -xa  ) / (2*L)
                            + (R  -dab  ) * (xb_d-xa_d) / (2*L)
                            + L_d * (R-dab) * (xb-xa) / (2*L*L);

                    PUSH_VAL(Ycent, Ycent_d, "", 0);
                }

            /* Xmidl(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "Xmidl") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    Xmidl   = (xa   + xb  ) / 2;
                    Xmidl_d = (xa_d + xb_d) / 2;

                    PUSH_VAL(Xmidl, Xmidl_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    Xmidl   = (xa + xb) / 2
                            + dab * (yb-ya) / (2*L);
                    Xmidl_d = (xa_d + xb_d) / 2
                            + dab_d * (yb  -ya  ) / (2*L)
                            + dab   * (yb_d-ya_d) / (2*L)
                            - L_d * dab * (yb-ya) / (2*L*L);

                    PUSH_VAL(Xmidl, Xmidl_d, "", 0);
                }

            /* Ymidl(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "Ymidl") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    Ymidl   = (ya   + yb  ) / 2;
                    Ymidl_d = (ya_d + yb_d) / 2;

                    PUSH_VAL(Ymidl, Ymidl_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    Ymidl   = (ya   + yb  ) / 2
                            - dab * (xb-xa) / (2*L);
                    Ymidl_d = (ya_d + yb_d) / 2
                            - dab_d * (xb  -xa  ) / (2*L)
                            - dab   * (xb_d-xa_d) / (2*L)
                            + L_d * dab * (xb-xa) / (2*L*L);

                    PUSH_VAL(Ymidl, Ymidl_d, "", 0);
                }

            /* seglen(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "seglen") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    seglen   = sqrt((xb  -xa  )*(xb-xa) + (yb  -ya  )*(yb-ya));
                    seglen_d =     ((xb_d-xa_d)*(xb-xa) + (yb_d-ya_d)*(yb-ya)) / seglen;

                    PUSH_VAL(seglen, seglen_d, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    phi   = atan(L / (R-dab));
                    phi_d = ((R-dab) * L_d - L * (R_d-dab_d)) / (L*L + (R-dab)*(R-dab));

                    seglen   = 2 * R  * phi;
                    seglen_d = 2 * (R_d * phi + R * phi_d);

                    PUSH_VAL(seglen, seglen_d, "", 0);
                }

            /* radius(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "radius") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    PUSH_VAL(0.0, 0.0, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    PUSH_VAL(R, R_d, "", 0);
                }

            /* sweep(xa,ya,dab,xb,yb) */
            } else if (strcmp(rpn[irpn].text, "sweep") == 0) {
                POP_VAL(yb,  yb_d,  str1, nan1);  // yb
                POP_VAL(xb,  xb_d,  str2, nan2);  // xb
                POP_VAL(dab, dab_d, str3, nan3);  // dab
                POP_VAL(ya,  ya_d,  str4, nan4);  // ya
                POP_VAL(xa,  xa_d,  str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (fabs(dab) < EPS06) {
                    PUSH_VAL(0.0, 0.0, "", 0);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    R   = (L*L + dab*dab) / (2 * dab);
                    R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                    phi   = atan(L / (R-dab));
                    phi_d = ((R-dab) * L_d - L * (R_d-dab_d)) / (L*L + (R-dab)*(R-dab));

                    sweep   = 2 * phi;
                    sweep_d = 2 * phi_d;

                    if (dab > 0) {
                        while (sweep < 0) {
                            sweep += TWOPI;
                        }
                    } else {
                        while (sweep > 0) {
                            sweep -= TWOPI;
                        }
                    }

                    PUSH_VAL(sweep*rad2deg, sweep_d*rad2deg, "", 0);
                }

            /* turnang(xa,ya,dab,xb,yb,dbc,xc,yc) */
            } else if (strcmp(rpn[irpn].text, "turnang") == 0) {
                POP_VAL(yc,  yc_d,  str1, nan1);  // yc
                POP_VAL(xc,  xc_d,  str2, nan2);  // xc
                POP_VAL(dbc, dbc_d, str3, nan3);  // dbc
                POP_VAL(yb,  yb_d,  str4, nan4);  // yb
                POP_VAL(xb,  xb_d,  str5, nan5);  // xb
                POP_VAL(dab, dab_d, str6, nan6);  // dab
                POP_VAL(ya,  ya_d,  str7, nan7);  // ya
                POP_VAL(xa,  xa_d,  str8, nan8);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0 || STRLEN(str6) > 0 ||
                    STRLEN(str7) > 0 || STRLEN(str8) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0 || nan6 != 0 ||
                           nan7 != 0 || nan8 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    angab   = atan2(yb-ya, xb-xa);
                    angab_d = ((xb-xa)*(yb_d-ya_d) - (yb-ya)*(xb_d-xa_d))
                            / ((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  ));

                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    if        (fabs(dab-L) < EPS12) { //                  +L == dab
                        angab   -= 3 * PI / 2;
                        angab_d += 0;
                    } else if (fabs(dab+L) < EPS12) { // dab == -L
                        angab   += 3 * PI / 2;
                        angab_d += 0;
                    } else if (fabs(dab) > EPS06) {
                        R   = (L*L + dab*dab) / (2 * dab);
                        R_d = (dab * L * L_d - L * L * dab_d) / (2 * dab * dab);

                        phi   = atan(L / (R-dab));
                        phi_d = ((R-dab) * L_d - L * (R_d-dab_d)) / (L*L + (R-dab)*(R-dab));

                        if        (dab >  +L) {       //                  +L < dab
                            angab   += phi + PI;
                            angab_d += phi_d;
                        } else if (dab >  -L) {       //       -L < dab < +L
                            angab   += phi;
                            angab_d += phi_d;
                        } else {                      // dab < -L
                            angab   += phi - PI;
                            angab_d += phi_d;
                        }
                    }

                    angbc = atan2(yc-yb, xc-xb);
                    angbc_d = ((xc-xb)*(yc_d-yb_d) - (yc-yb)*(xc_d-xb_d))
                            / ((xc-xb)*(xc  -xb  ) + (yc-yb)*(yc  -yb  ));

                    L   = sqrt((xc-xb)*(xc  -xb  ) + (yc-yb)*(yc  -yb  )) /  2;
                    L_d =     ((xc-xb)*(xc_d-xb_d) + (yc-yb)*(yc_d-yb_d)) / (2 * L);

                    if        (fabs(dbc-L) < EPS12) { //                  +L == dbc
                        angbc   += 3 * PI / 2;
                        angbc_d += 0;
                    } else if (fabs(dbc+L) < EPS12) { // dbc == -L
                        angbc   -= 3 * PI / 2;
                        angbc_d += 0;
                    } else if (fabs(dbc) > EPS06) {
                        R   = (L*L + dbc*dbc) / (2 * dbc);
                        R_d = (dbc * L * L_d - L * L * dbc_d) / (2 * dbc * dbc);

                        phi   = atan(L / (R-dbc));
                        phi_d = ((R-dbc) * L_d - L * (R_d-dbc_d)) / (L*L + (R-dbc)*(R-dbc));

                        if        (dbc >  +L) {       //                  +L < dbc
                            angbc   -= phi + PI;
                            angbc_d -= phi_d;
                        } else if (dbc >  -L) {       //       -L < dbc < +L
                            angbc   -= phi;
                            angbc_d -= phi_d;
                        } else {                      // dbc < -L
                            angbc   -= phi - PI;
                            angbc_d -= phi_d;
                        }
                    }

                    angle   = angbc   - angab;
                    angle_d = angbc_d - angab_d;
                    while (angle < -PI) {
                        angle += TWOPI;
                    }
                    while (angle > +PI) {
                        angle -= TWOPI;
                    }

                    PUSH_VAL(angle*rad2deg, angle_d*rad2deg, "", 0);
                }

            /* dip(xa,ya,xb,yb,rad) */
            } else if (strcmp(rpn[irpn].text, "dip") == 0) {
                POP_VAL(R,  R_d,  str1, nan1);  // rad
                POP_VAL(yb, yb_d, str2, nan2);  // yb
                POP_VAL(xb, xb_d, str3, nan3);  // xb
                POP_VAL(ya, ya_d, str4, nan4);  // ya
                POP_VAL(xa, xa_d, str5, nan5);  // xa

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) > 0 ||
                    STRLEN(str4) > 0 || STRLEN(str5) > 0                       ) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0 ||
                           nan4 != 0 || nan5 != 0                ) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    L   = sqrt((xb-xa)*(xb  -xa  ) + (yb-ya)*(yb  -ya  )) /  2;
                    L_d =     ((xb-xa)*(xb_d-xa_d) + (yb-ya)*(yb_d-ya_d)) / (2 * L);

                    if (L > R) {
                        STRNCPY(errstr, "dip only for L<=R", MAX_STRVAL_LEN);
                        PUSH_VAL(0, 0, "", 1);
                        ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                    } else {
                        dab   = R   -                        sqrt(R*R - L*L);
                        dab_d = R_d - (R*R_d - L*L_d) / (2 * sqrt(R*R - L*L));
                        PUSH_VAL(dab, dab_d, "", 0);
                    }
                }

            /* smallang(x) */
            } else if (strcmp(rpn[irpn].text, "smallang") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // x

                if (STRLEN(str1) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    while (val1 > +180) {
                        val1 -= 360;
                    }
                    while (val1 < -180) {
                        val1 += 360;
                    }
                    PUSH_VAL(val1, dot1, "", 0);
                }

            /* val2str(num,digits) */
            } else if (strcmp(rpn[irpn].text, "val2str") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // digits
                POP_VAL(val2, dot2, str2, nan2);  // num

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (NINT(val1) == 0) {
                    snprintf(str3, MAX_STRVAL_LEN, "%d", NINT(val2));
                    PUSH_VAL(0, 0, str3, 0);
                } else if (NINT(val1) > 0) {
                    snprintf(str3, MAX_STRVAL_LEN, "%.*f", +NINT(val1), val2);
                    PUSH_VAL(0, 0, str3, 0);
                } else {
                    snprintf(str3, MAX_STRVAL_LEN, "%.*e", -NINT(val1), val2);
                    PUSH_VAL(0, 0, str3, 0);
                }

            /* str2val(string) */
            } else if (strcmp(rpn[irpn].text, "str2val") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // string

                if (STRLEN(str1) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (MODL != NULL) {
                    status = str2val(str1, MODL, &val2, &dot2, str2);
                    if (status != EGADS_SUCCESS) goto cleanup;
                    PUSH_VAL(val2, dot2, str2, 0);
                } else {
                    PUSH_VAL(0, 0, "", 1);
                }

            /* findstr(str1,str2) */
            } else if (strcmp(rpn[irpn].text, "findstr") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // str2
                POP_VAL(val2, dot2, str2, nan2);  // str1

                if (STRLEN(str1) == 0 || STRLEN(str2) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    temp = (char*) strstr(&(str2[1]), &(str1[1]));

                    if (temp == NULL) {
                        PUSH_VAL(0, 0, "", 0);
                    } else {
                        val3 = (int)(temp - str2);
                        PUSH_VAL(val3, 0, "", 0);
                    }
                }

            /* slice(str,ibeg,iend) */
            } else if (strcmp(rpn[irpn].text, "slice") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // iend
                POP_VAL(val2, dot2, str2, nan2);  // ibeg
                POP_VAL(val3, dot3, str3, nan3);  // str

                if (STRLEN(str1) > 0 || STRLEN(str2) > 0 || STRLEN(str3) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan1 != 0 || nan2 != 0 || nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else {
                    ibeg = NINT(val2) - 1;
                    iend = NINT(val1) - 1;
                    if (iend > STRLEN(str3)) iend = strlen(str3);
                    if (ibeg < 0 || ibeg > STRLEN(str3)-1) {
                        STRNCPY(errstr, "ibeg must be be between 1 and strlen(str)", MAX_STRVAL_LEN);
                        PUSH_VAL(0, 0, "", 1);
                        ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                    } else if (iend < ibeg) {
                        STRNCPY(errstr, "iend must not be less than ibeg", MAX_STRVAL_LEN);
                        PUSH_VAL(0, 0, "", 1);
                        ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                    } else {
                        STRNCPY(str4, &(str3[ibeg]), iend-ibeg+2);
                        PUSH_VAL(0, 0, str4, 0);
                    }
                }

            /* path($pwd) or path($csm) or path($root) or path($file) */
            } else if (strcmp(rpn[irpn].text, "path") == 0) {
                POP_VAL(val1, dot1, str1, nan1);

                if        (strcmp(str1, "pwd" ) == 0) {
                    /*@ignore@*/
                    if ((buffer = getcwd(NULL,0)) == NULL) {
                    /*@end@*/
                        STRNCPY(str2, ".", MAX_STRVAL_LEN);        // error
                    } else {
                        snprintf(str2, MAX_STRVAL_LEN, "%s%c", buffer, SLASH);
                        free(buffer);
                    }
                    PUSH_VAL(0, 0, str2, 0);
                } else if (strcmp(str1, "csm" ) == 0) {
                    if (MODL == NULL) {
                        strcpy(str2, "");
                    } else if (strchr(MODL->brch[MODL->ibrch].filename, SLASH) == NULL) {
                        snprintf(str2, MAX_STRVAL_LEN, ".%c", SLASH);
                    } else {
                        snprintf(str2, MAX_STRVAL_LEN, "%s", MODL->brch[MODL->ibrch].filename);
                        for (ii = STRLEN(str2)-1; ii >= 0; ii--) {
                            if (str2[ii  ] == SLASH) {
                                str2[ii+1] = '\0';
                                break;
                            }
                        }
                    }
                    PUSH_VAL(0, 0, str2, 0);
                } else if (strcmp(str1, "root") == 0) {
                    esp_root = getenv("ESP_ROOT");
                    if (esp_root != NULL) {
                        snprintf(str2, MAX_STRVAL_LEN, "%s%c", esp_root, SLASH);
                        PUSH_VAL(0, 0, str2, 0);
                    } else {
                        PUSH_VAL(0, 0, "", 1);
                    }
                } else if (strcmp(str1, "file") == 0) {
                    if (MODL == NULL) {
                        PUSH_VAL(0, 0, "", 1);
                    } else {
                        snprintf(str2, MAX_STRVAL_LEN, "%s", MODL->brch[MODL->ibrch].filename);
                        jj = 0;
                        for (ii = 0; ii < STRLEN(str2); ii++) {
                            if (str2[ii] == SLASH) {
                                jj = ii + 1;
                            }
                        }
                        PUSH_VAL(0, 0, &(str2[jj]), 0);
                    }
                } else {
                    STRNCPY(errstr, "valid arg for path() is only $pwd, $csm, $root, or $name", MAX_STRVAL_LEN);
                    PUSH_VAL(0, 0, "", 1);
                    ietype = OCSM_FUNC_ARG_OUT_OF_BOUNDS;
                }

            /* ifzero(test,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifzero") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // test

                if (STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val3 == 0) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }

            /* ifpos(test,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifpos") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // test

                if (STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val3 > 0) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }

            /* ifneg(test,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifneg") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // test

                if (STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan3 != 0) {
                    PUSH_VAL(0, 0, "", 1);
                } else if (val3 < 0) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }

            /* ifmatch(st1,pat,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifmatch") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // pat
                POP_VAL(val4, dot4, str4, nan4);  // str

                if (STRLEN(str3) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (STRLEN(str4) == 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (matches(str3, str4)) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }

            /* ifnan(test,ifTrue,ifFalse) */
            } else if (strcmp(rpn[irpn].text, "ifnan") == 0) {
                POP_VAL(val1, dot1, str1, nan1);  // ifFalse
                POP_VAL(val2, dot2, str2, nan2);  // ifTrue
                POP_VAL(val3, dot3, str3, nan3);  // test

                if (STRLEN(str3) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else if (nan3 != 0) {
                    PUSH_VAL(val2, dot2, str2, nan2);
                } else {
                    PUSH_VAL(val1, dot1, str1, nan1);
                }
            }
        } else {
            SPRINT2(3, "skipping type %d (%s)", rpn[irpn].type, rpn[irpn].text);
        }

        if (outLevel >= 3) {
            for (ii = 0; ii < nvalstack; ii++) {
                SPRINT4(3, "    %10.5f %10.5f %20s %5d",
                        valstack[ii].val, valstack[ii].dot,
                        valstack[ii].str, valstack[ii].nan);
            }
        }

        irpn++;
    }

    POP_VAL(*val, *dot, str, nan1);

    /* if error flag was set, return error */
    if (nan1 != 0) {
        strcpy(str, errstr);
        status = ietype;

    } else if (nvalstack > 0) {
        status = OCSM_VAL_STACK_OVERFLOW;
    }

#undef PUSH_VAL
#undef POP_VAL

cleanup:
    FREE(valstack);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   faceContains - determine if point is in Face's bounding box        *
 *                                                                      *
 ************************************************************************
 */

static int
faceContains(ego    eface,              /* (in)  pointer to Face */
             double xx,                 /* (in)  x-coordinate */
             double yy,                 /* (in)  y-coordinate */
             double zz)                 /* (in)  z-coordinate */
{
    int       status = 0;               /* (out) =0  not in bounding box */
                                        /*       =1      in bounding box */

    double    box[6];

    ROUTINE(faceContains);

    /* --------------------------------------------------------------- */

    status = EG_getBoundingBox(eface, box);
    CHECK_STATUS(EG_getBoundingBox);

    if (xx < box[0] || yy < box[1] || zz < box[2] ||
        xx > box[3] || yy > box[4] || zz > box[5]   ) {
        status = 0;
    } else {
        status = 1;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   finishBody - finish the definition of the body                     *
 *                                                                      *
 ************************************************************************
 */

static int
finishBody(modl_T *modl,                /* (in)  pointer to MODL */
           int    ibody)                /* (in)  Body index (1:nbody) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       nnode, nedge, nface, inode, iedge, iface, recycled, done;
    int       jbody, jedge, jface, nodes[2], ibeg, iend, periodic, found, jnode;
    int       ileft, irite, nlist, nlist2, nlist3, itype, itype2, itype3;
    int       iattr, nattr, iattrib[7], jattrib[7], iswap, nswap, attrType, attrLen, i, icount;
    int       noTopoChange, keepEdgeAttr,*newIlist=NULL, *needSeq=NULL;
    int       oclass1, mtype1, oclass2, mtype2, nhist, *hist=NULL;
    CINT      *tempIlist, *tempIlist2, *tempIlist3;
    double    data[18], trange[4], trange2[4];
    double    xparent, yparent, zparent, xold, yold, zold, dx, dy, dz;
    double    cosx, cosy, cosz, sinx, siny, sinz, nx, ny, nz, dist, fact, xcent, ycent, zcent;
    double    data1[18], data2[18], dot;
    double    bbox1[6], bbox2[6], dbest, dtest;
    CDOUBLE   *tempRlist, *tempRlist2, *tempRlist3;
    CCHAR     *tempClist, *tempClist2, *tempClist3, *aname3;
    body_T    *body=NULL;
    rbt_T     *rbt;

    int       nchild, ichild, oclass, mtype, ibrch, *senses;
    int       nloop, iloop, ntemp;
    double    *area=NULL, *xcg=NULL, *ycg=NULL, *zcg=NULL;
    ego       ebody, *enodes, eedge, *eedges, eface, *efaces, *echildren;
    ego       eref, *echilds, *eloops, topRef, prev, next, ecurve1, ecurve2, etemp1, etemp2;
#if PRINT_PROGRESS
    time_t    cpu_beg, cpu_end;
#endif

    ROUTINE(finishBody);

    /* --------------------------------------------------------------- */

    PPRINT_INIT(enter finish);

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* get Body info */
    body = &(MODL->body[ibody]);

    /* determine if this Body was recycled (in which case it
       will have a __filename__ attribute) */
    status = EG_attributeRet(body->ebody, "__filename__", &attrType, &attrLen,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == EGADS_SUCCESS) {
        recycled = 1;
    } else {
        recycled = 0;
        status = EGADS_SUCCESS;
    }

    /* print ego information */
    if (outLevel >= 3) {
        SPRINT1(3, "finishing Body %d:", ibody);
        ocsmPrintEgo(body->ebody);
    }

    /* create parent/child links in the Branches */
    ibrch = body->ibrch;
    ileft = body->ileft;
    irite = body->irite;

    if (ileft > 0) {
        ileft = MODL->body[ileft].ibrch;

        MODL->brch[ibrch].ileft = ileft;
        MODL->brch[ileft].ichld = ibrch;
    } else if (ibrch > 0) {
        MODL->brch[ibrch].ileft = -1;
    }

    if (irite > 0) {
        irite = MODL->body[irite].ibrch;

        MODL->brch[ibrch].irite = irite;
        MODL->brch[irite].ichld = ibrch;
    } else if (ibrch > 0) {
        MODL->brch[ibrch].irite = -1;
    }

    if (ibrch > 0) {
        MODL->brch[ibrch].ichld = -1;
    }

    PPRINT0(done with parent/child);

    /* if a NULL Body o SketchBody, set up quantities */
    if (body->botype == OCSM_NULL_BODY ||
        body->botype == OCSM_SKETCH      ) {
        body->nnode = 0;
        body->nedge = 0;
        body->nface = 0;

        goto cleanup;
    }

    /* get the number of Nodes, Edges, and Faces associated with this Body */
    ebody  = body->ebody;

    status = EG_getInfo(ebody, &oclass, &mtype, &topRef, &prev, &next);
    CHECK_STATUS(EG_getInfo);

    if (oclass == BODY) {
        status = EG_getBodyTopos(ebody, NULL, NODE, &nnode, NULL);
        CHECK_STATUS(EG_getBodyTopos:NODE);

        status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, NULL);
        CHECK_STATUS(EG_getBodyTopos:EDGE);

        status = EG_getBodyTopos(ebody, NULL, FACE, &nface, NULL);
        CHECK_STATUS(EG_getBodyTopos:FACE);
    } else {
        goto cleanup;
    }

    /* override number of Edges in NODE_BODY */
    if (body->botype == OCSM_NODE_BODY) {
        nedge = 0;
    }

    body->nnode = nnode;
    body->nedge = nedge;
    body->nface = nface;

    /* delete old Node, Edge, and Face storage */
    FREE(body->node);
    FREE(body->edge);
    FREE(body->face);

    /* if we are creating a perturbation (that is, is basemodl != NULL),
       make sure that the number of Nodes, Edges, and Faces matches
       the base model */
    if (MODL->basemodl != NULL) {
        if (ibody > MODL->basemodl->nbody) {
            SPRINT2(1, "WARNING:: trying to finish ibody=%d but base model only had %d Bodys",
                    ibody, MODL->basemodl->nbody);
            status = OCSM_PROBLEM_CREATING_PERTURB;
            (MODL->nwarn)++;
            goto cleanup;
        }

        if (nnode != MODL->basemodl->body[ibody].nnode) {
            SPRINT3(1, "WARNING:: nnode disagree for ibody %d, PRTB=%d, BASE=%d",
                    ibody, nnode, MODL->basemodl->body[ibody].nnode);
            (MODL->nwarn)++;
            status = OCSM_PROBLEM_CREATING_PERTURB;
            goto cleanup;
        }

        if (nedge != MODL->basemodl->body[ibody].nedge) {
            SPRINT3(1, "WARNING:: nedge disagree for ibody %d, PRTB=%d, BASE=%d",
                    ibody, nedge, MODL->basemodl->body[ibody].nedge);
            (MODL->nwarn)++;
            status = OCSM_PROBLEM_CREATING_PERTURB;
            goto cleanup;
        }

        if (nface != MODL->basemodl->body[ibody].nface) {
            SPRINT3(1, "WARNING:: nface disagree for ibody %d, PRTB=%d, BASE=%d",
                    ibody, nface, MODL->basemodl->body[ibody].nface);
            (MODL->nwarn)++;
            status = OCSM_PROBLEM_CREATING_PERTURB;
            goto cleanup;
        }
    }

    /* add any global Attributes to this Body */
    status = setEgoAttribute(MODL, 0, ebody);
    CHECK_STATUS(setEgoAttribute);

    /* add any Attributes associated with this Branch to this Body */
    ibrch = body->ibrch;

    status = setEgoAttribute(MODL, ibrch, ebody);
    CHECK_STATUS(setEgoAttribute);

    /* add the current Branch as an Attribute for this Body */
    status = EG_attributeAdd(ebody, "_body", ATTRINT,
                             1, &ibody, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(ebody, "_brch", ATTRINT,
                             1, &ibrch, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    body->gratt.object = NULL;
    body->gratt.active = 1;                              /* active */
    body->gratt.color  = 0x00000000;                     /* black */
    body->gratt.ptsize = 5;
    body->gratt.render = 64;                             /* FORWARD */
    body->gratt.dirty  = 1;

    PPRINT0(done with Body attributes);

    /* initialize the Nodes for this Body */
    if (nnode < 1) {
        SPRINT2(1, "WARNING:: nnode=%d for ibody=%d", nnode, ibody);
        (MODL->nwarn)++;
        status = OCSM_INTERNAL_ERROR;
        goto cleanup;
    }

    MALLOC(body->node, node_T, nnode+1);

    status = EG_getBodyTopos(ebody, NULL, NODE, &ntemp, &enodes);
    CHECK_STATUS(EG_getBodyTopos);

    if (ntemp != nnode) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "ntemp=%d does not match nnode=%d", ntemp, nnode);
        SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
    }

    if (enodes != NULL) {
        for (inode = 1; inode <= nnode; inode++) {
            status = EG_getTopology(enodes[inode-1],
                                    &eref, &oclass, &mtype, data,
                                    &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            body->node[inode].nedge = 0;
            body->node[inode].x     = data[0];
            body->node[inode].y     = data[1];
            body->node[inode].z     = data[2];
            body->node[inode].ibody = 0;
            body->node[inode].dxyz  = NULL;

            body->node[inode].gratt.object = NULL;
            body->node[inode].gratt.active = 1;              /* active */
            body->node[inode].gratt.color  = 0x00000000;     /* black */
            body->node[inode].gratt.ptsize = 5;
            body->node[inode].gratt.render = 64;             /* FORWARD */
            body->node[inode].gratt.dirty  = 1;

            body->node[inode].enode = enodes[inode-1];
        }

        EG_free(enodes);
    }

    PPRINT1(done initializing %d Nodes, nnode);

    /* initialize the Edges for this Body */
    if (body->botype != OCSM_NODE_BODY) {
        if (nedge < 1) {
            SPRINT2(1, "WARNING:: nedge=%d for ibody=%d", nedge, ibody);
            (MODL->nwarn)++;
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

        MALLOC(body->edge, edge_T, nedge+1);

        status = EG_getBodyTopos(ebody, NULL, EDGE, &ntemp, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        if (ntemp != nedge) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "ntemp=%d does not match nedge=%d", ntemp, nedge);
                SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
        }

        if (eedges != NULL) {
            for (iedge = 1; iedge <= nedge; iedge++) {
                status = EG_getTopology(eedges[iedge-1], &eref, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                nodes[0] = status = EG_indexBodyTopo(ebody, echilds[0]);
                CHECK_STATUS(EG_indexBodyTopo);

                nodes[1] = status = EG_indexBodyTopo(ebody, echilds[1]);
                CHECK_STATUS(EG_indexBodyTopo);

                body->edge[iedge].itype        = mtype;
                body->edge[iedge].ibeg         = nodes[0];
                body->edge[iedge].iend         = nodes[1];
                body->edge[iedge].ileft        = -1;
                body->edge[iedge].irite        = -1;
                body->edge[iedge].nface        = 0;
                body->edge[iedge].ibody        = -1;
                body->edge[iedge].iford        = -1;
                body->edge[iedge].imark        = -1;
                body->edge[iedge].gratt.object = NULL;
                body->edge[iedge].gratt.active = 1;              /* active */
                body->edge[iedge].gratt.color  = 0x00ff0000;     /* red */
                body->edge[iedge].gratt.bcolor = 0x00ffffff;     /* white */
                body->edge[iedge].gratt.mcolor = 0x00000000;     /* black */
                body->edge[iedge].gratt.lwidth = 2;
                body->edge[iedge].gratt.ptsize = 3;
                body->edge[iedge].gratt.render = 2 + 64;         /* FOREGROUND | FORWARD */
                body->edge[iedge].gratt.dirty  = 1;
                body->edge[iedge].dxyz         = NULL;
                body->edge[iedge].dt           = NULL;
                body->edge[iedge].eedge        = eedges[iedge-1];

                /* update the Node valence info */
                for (ichild = 0; ichild < nchild; ichild++) {
                    inode = status = EG_indexBodyTopo(ebody, echilds[ichild]);
                    CHECK_STATUS(EG_indexBodyTopos);

                    body->node[inode].nedge++;
                }
            }

            EG_free(eedges);
        }
    }

    PPRINT1(done initializing %d Edges, nedge);

    /* initialize the Faces for this Body */
    MALLOC(body->face, face_T, nface+1);

    status = EG_getBodyTopos(ebody, NULL, FACE, &ntemp, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (ntemp != nface) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "ntemp=%d does not match nface=%d", ntemp, nface);
        SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
    }

    if (efaces != NULL) {
        for (iface = 1; iface <= nface; iface++) {
            body->face[iface].ibody        = -1;
            body->face[iface].iford        = -1;
            body->face[iface].imark        = -1;
            body->face[iface].gratt.object = NULL;
            body->face[iface].gratt.active = 1;              /* active */
            body->face[iface].gratt.color  = 0x00ffffa3;     /* yellow (chaanged below for SheetBodys) */
            body->face[iface].gratt.bcolor = 0x007f7f7f;     /* grey */
            body->face[iface].gratt.mcolor = 0x00000000;     /* black */
            body->face[iface].gratt.lwidth = 1;
            body->face[iface].gratt.ptsize = 1;
            body->face[iface].gratt.render = 2 + 4 + 64;     /* FOREGROUND | ORIENTATION | FORWARD */
            body->face[iface].gratt.dirty  = 1;
            body->face[iface].eggdata      = NULL;
            body->face[iface].dxyz         = NULL;
            body->face[iface].duv          = NULL;
            body->face[iface].eface = efaces[iface-1];

            if (body->botype == OCSM_SHEET_BODY) {
                body->face[iface].gratt.color  = 0x00ffdadd; /* pink */
            }

            status = colorizeFace(MODL, ibody, iface);
            CHECK_STATUS(colorizeFace);

            /* update the Edge valence info */
            status = EG_getBodyTopos(ebody, efaces[iface-1], EDGE, &nchild, &echilds);
            CHECK_STATUS(EG_getBodyTopos);

            if (echilds != NULL) {
                for (ichild = 0; ichild < nchild; ichild++) {
                    if (echilds[ichild] == NULL) continue;

                    iedge = status = EG_indexBodyTopo(ebody, echilds[ichild]);
                    CHECK_STATUS(EG_indexBodyTopos);

                    SPLINT_CHECK_FOR_NULL(body->edge);

                    body->edge[iedge].nface++;
                }

                EG_free(echilds);
            }
        }

        EG_free(efaces);
    }

    nedge = body->nedge;
    nface = body->nface;

    /* check for spurious Nodes, which are Nodes that support two manifold
       Edges whose tangents are approximtely parallel at the Node */
    for (inode = 1; inode <= body->nnode; inode++) {
        if (body->node[inode].nedge == 2) {
            status = EG_getBodyTopos(ebody, body->node[inode].enode, EDGE,
                                     &ntemp, &eedges);
            CHECK_STATUS(EG_getBodyTopos);

            /* get info associated with first Edge */
            if (eedges != NULL) {
                status = EG_getTopology(eedges[0], &ecurve1, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);
                SPLINT_CHECK_FOR_NULL(echilds);

                iedge = EG_indexBodyTopo(ebody, eedges[0]);
                if (iedge > 0) {
                    if (MODL->body[ibody].edge[iedge].nface != 2) {
                        EG_free(eedges);
                        continue;
                    }
                }

                if        (echilds[0] == body->node[inode].enode) {
                    etemp1 = echilds[1];
                    status = EG_evaluate(eedges[0], &(data[0]), data1);
                    CHECK_STATUS(EG_evaluate);
                } else if (echilds[1] == body->node[inode].enode) {
                    etemp1 = echilds[0];
                    status = EG_evaluate(eedges[0], &(data[1]), data1);
                    CHECK_STATUS(EG_evaluate);
                } else {
                    etemp1   = NULL;
                }

                /* get info associated with second Edge */
                status = EG_getTopology(eedges[1], &ecurve2, &oclass, &mtype,
                                        data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                iedge = EG_indexBodyTopo(ebody, eedges[1]);
                if (iedge > 0) {
                    if (MODL->body[ibody].edge[iedge].nface != 2) {
                        EG_free(eedges);
                    continue;
                    }
                }

                if        (echilds[0] == body->node[inode].enode) {
                    etemp2 = echilds[1];
                    status = EG_evaluate(eedges[1], &(data[0]), data2);
                    CHECK_STATUS(EG_evaluate);
                } else if (echilds[1] == body->node[inode].enode) {
                    etemp2 = echilds[0];
                    status = EG_evaluate(eedges[1], &(data[1]), data2);
                    CHECK_STATUS(EG_evaluate);
                } else {
                    etemp2   = NULL;
                }

                /* if the two Edges do not form a Loop, check if tangents to the two Edges are
                   parallel or anti-parallel */
                if (etemp1 != NULL && etemp2 != NULL && etemp1 != etemp2) {
                    dot  =     (data1[3] * data2[3] + data1[4] * data2[4] + data1[5] * data2[5]);
                    dot /= sqrt(data1[3] * data1[3] + data1[4] * data1[4] + data1[5] * data1[5]);
                    dot /= sqrt(data2[3] * data2[3] + data2[4] * data2[4] + data2[5] * data2[5]);

                    if (fabs(dot-1) < 1e-3 || fabs(dot+1) < 1e-3) {
                        status = EG_getInfo(ecurve1, &oclass1, &mtype1, &topRef, &prev, &next);
                        CHECK_STATUS(EG_getInfo);

                        status = EG_getInfo(ecurve2, &oclass2, &mtype2, &topRef, &prev, &next);
                        CHECK_STATUS(EG_getInfo);

                        SPRINT5(1, "WARNING:: Node %4d (Edges %4d (%d) and %4d (%d)) appears to be spurious", inode,
                                EG_indexBodyTopo(ebody,eedges[0]), mtype1,
                                EG_indexBodyTopo(ebody,eedges[1]), mtype2);
                        (MODL->nwarn)++;
                    }
                }

                EG_free(eedges);
            }
        }
    }

    PPRINT0(done checking for spurious Nodes);

    /* special treatment for an isolated WireBody (.nface==0) */
    if (nface == 0) {
        for (iedge = 1; iedge <= nedge; iedge++) {
            SPLINT_CHECK_FOR_NULL(body->edge);

            /* WireBody that comes from COMBINE keeps .ibody and .iford */
            if (body->brtype == OCSM_COMBINE) {
                assert(body->ileft > 0);
                for (jedge = 1; jedge <= MODL->body[body->ileft].nedge; jedge++) {
                    status = EG_isSame(body->edge[iedge].eedge, MODL->body[body->ileft].edge[jedge].eedge);
                    if (status == EGADS_SUCCESS) {
                        body->edge[iedge].ibody = MODL->body[body->ileft].edge[jedge].ibody;
                        body->edge[iedge].iford = MODL->body[body->ileft].edge[jedge].iford;
                        break;
                    }
                }

                assert(body->irite > 0);
                for (jedge = 1; jedge <= MODL->body[body->irite].nedge; jedge++) {
                    status = EG_isSame(body->edge[iedge].eedge, MODL->body[body->irite].edge[jedge].eedge);
                    if (status == EGADS_SUCCESS) {
                        body->edge[iedge].ibody = MODL->body[body->irite].edge[jedge].ibody;
                        body->edge[iedge].iford = MODL->body[body->irite].edge[jedge].iford;
                        break;
                    }
                }

            /* WireBody that is a transform of a previous WireBody */
            } else if (body->ileft > 0 && body->brtype != OCSM_EXTRUDE &&
                                          body->brtype != OCSM_RULE    &&
                                          body->brtype != OCSM_BLEND   &&
                                          body->brtype != OCSM_SKEND   &&
                                          body->brtype != OCSM_JOIN      ) {
                body->edge[iedge].ibody = MODL->body[body->ileft].edge[iedge].ibody;
                body->edge[iedge].iford = MODL->body[body->ileft].edge[iedge].iford;

            /* newly created WireBody */
            } else {
                body->edge[iedge].ibody = ibody;
                body->edge[iedge].iford = iedge;
            }
        }

        /* check if WireBody is non-manifold */
        status = EG_getBodyTopos(ebody, NULL, LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);

        status = EG_getTopology(eloops[0], &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        EG_free(eloops);

        if (nchild != nedge && nedge > 0) {
            SPRINT0(0, "WARNING:: WireBody is non-manifold");
            (MODL->nwarn)++;

            body->nonmani = 1;
        }
    }

    /* store Csystem on this Body */
    if (ibrch > 0) {
        (void) storeCsystem(MODL, ibody);
        if (MODL->sigCode != SUCCESS) {
            status = freeBody(MODL, ibody);
            MODL->nbody--;
            goto cleanup;
        }
    }

    /* set up ileft and irite on the adjacent Edges */
    for (iface = 1; iface <= nface; iface++) {
        status = EG_getTopology(body->face[iface].eface, &eref,
                                &oclass, &mtype, data, &nloop, &eloops, &senses);
        CHECK_STATUS(EG_getTopology);

        for (iloop = 0; iloop < nloop; iloop++) {
            status = EG_getTopology(eloops[iloop], &eref,
                                    &oclass, &mtype, data, &nchild, &echildren, &senses);
            CHECK_STATUS(EG_getTopology);

            for (ichild = 0; ichild < nchild; ichild++) {
                SPLINT_CHECK_FOR_NULL(body->edge);

                iedge = status = EG_indexBodyTopo(ebody, echildren[ichild]);
                CHECK_STATUS(EG_indexBodyTopo);

                if (iedge < 1 || iedge > body->nedge) {
                    signalError(MODL, OCSM_INTERNAL_ERROR,
                                "echildren[%d] not found in body", ichild);
                    status = OCSM_INTERNAL_ERROR;
                    goto cleanup;
                }

                if (senses[ichild] == SFORWARD) {
                    body->edge[iedge].ileft = iface;
                } else {
                    body->edge[iedge].irite = iface;
                }
            }
        }
    }

    PPRINT1(done initializing %d Faces, nface);

    /* retrieve the Marks from the Edge and Face Attributes */
    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        eedge = body->edge[iedge].eedge;
        status = EG_attributeRet(eedge, "mark", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);

        if (status == SUCCESS && nlist > 0) {
            body->edge[iedge].imark = tempIlist[0];
        }
    }

    for (iface = 1; iface <= nface; iface++) {
        eface = body->face[iface].eface;
        status = EG_attributeRet(eface, "mark", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);

        if (status == SUCCESS && nlist > 0) {
            body->face[iface].imark = tempIlist[0];
        }
    }

    /* retrieve the Branch and Face order from the Faces Attributes */
    for (iface = 1; iface <= nface; iface++) {
        eface = body->face[iface].eface;
        status = EG_attributeRet(eface, "_body", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);

        if        (status == SUCCESS && nlist == 2) {
            body->face[iface].ibody = tempIlist[0];
            body->face[iface].iford = tempIlist[1];
        } else if (status == SUCCESS && nlist == 1) {
            body->face[iface].ibody = tempIlist[0];
            body->face[iface].iford = -1;
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "\"body\" attribute error for iface=%d (nlist=%d)", iface, nlist);
            SET_STATUS(OCSM_INTERNAL_ERROR, no_attribute);
        }

        status = EG_attributeRet(eface, "mark", &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);

        if (status == SUCCESS && nlist > 0) {
            body->face[iface].imark = tempIlist[0];
        }
    }

    /* add an Attribute to each Face to say that is was included
       in this Body */
    for (iface = 1; iface <= nface; iface++) {
        status = EG_attributeRet(body->face[iface].eface, "_hist",
                                 &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);

        if (status != SUCCESS) {
            status = EG_attributeAdd(body->face[iface].eface, "_hist", ATTRINT,
                                     1, &ibody, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);
        } else if (attrType != ATTRINT) {
            status = OCSM_INTERNAL_ERROR;
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "_hist is not an integer Attribute");
            goto cleanup;
        } else {
            MALLOC(newIlist, int, attrLen+1);
            for (i = 0; i < attrLen; i++) {
                newIlist[i] = tempIlist[i];
            }
            newIlist[attrLen] = ibody;

            status = EG_attributeAdd(body->face[iface].eface, "_hist", ATTRINT,
                                     attrLen+1, newIlist, NULL, NULL);
            FREE(newIlist);
            CHECK_STATUS(EG_attributeAdd);
        }
    }

    /* make sure that .ileft and .irite do not come from the same
       surface for any Edge that supports more than 2 Faces */
    for (iedge = 1; iedge <= body->nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        if (body->edge[iedge].nface <= 2) continue;

        ileft = body->edge[iedge].ileft;
        irite = body->edge[iedge].irite;

        if (ileft <= 0 || irite <= 0) {
            SPRINT5(0, "WARNING:: Edge %d:%d has .nface=%d, ileft=%d<=0, and irite=%d<0",
                    ibody, iedge, body->edge[iedge].nface, ileft, irite);
            (MODL->nwarn)++;
            continue;
        }

        if (body->face[ileft].ibody != body->face[irite].ibody ||
            body->face[ileft].iford != body->face[irite].iford   ) continue;

        /* adjust ileft to come from a Face with a surface different from irite's Surface */
        found = 0;

        for (jface = 1; jface <= body->nface; jface++) {
            if (found > 0) break;

            if (body->face[jface].ibody == body->face[irite].ibody &&
                body->face[jface].iford == body->face[irite].iford   ) continue;

            status = EG_getTopology(body->face[jface].eface, &etemp1,
                                    &oclass, &mtype, data, &nloop, &eloops, &senses);
            CHECK_STATUS(EG_getTopology);

            for (iloop = 0; iloop < nloop; iloop++) {
                if (found > 0) break;

                status = EG_getTopology(eloops[iloop], &eref,
                                        &oclass, &mtype, data, &nchild, &echildren, &senses);
                CHECK_STATUS(EG_getTopology);

                for (ichild = 0; ichild < nchild; ichild++) {
                    SPLINT_CHECK_FOR_NULL(body->edge);

                    jedge = status = EG_indexBodyTopo(ebody, echildren[ichild]);
                    CHECK_STATUS(EG_indexBodyTopo);

                    if (jedge < 1 || jedge > body->nedge) {
                        signalError(MODL, OCSM_INTERNAL_ERROR,
                                    "echildren[%d] not found in body", ichild);
                        status = OCSM_INTERNAL_ERROR;
                        goto cleanup;
                    }

                    if (jedge == iedge && senses[ichild] == SFORWARD) {
                        body->edge[iedge].ileft = jface;
                        found = 1;
                        break;
                    }
                }
            }
        }

        /* adjust irite to come from a Face with a surface different from ileft's Surface */
        for (jface = 1; jface <= body->nface; jface++) {
            if (found > 0) break;

            if (body->face[jface].ibody == body->face[ileft].ibody &&
                body->face[jface].iford == body->face[ileft].iford   ) continue;

            status = EG_getTopology(body->face[jface].eface, &etemp1,
                                    &oclass, &mtype, data, &nloop, &eloops, &senses);
            CHECK_STATUS(EG_getTopology);

            for (iloop = 0; iloop < nloop; iloop++) {
                if (found > 0) break;

                status = EG_getTopology(eloops[iloop], &eref,
                                        &oclass, &mtype, data, &nchild, &echildren, &senses);
                CHECK_STATUS(EG_getTopology);

                for (ichild = 0; ichild < nchild; ichild++) {
                    SPLINT_CHECK_FOR_NULL(body->edge);

                    jedge = status = EG_indexBodyTopo(ebody, echildren[ichild]);
                    CHECK_STATUS(EG_indexBodyTopo);

                    if (jedge < 1 || jedge > body->nedge) {
                        signalError(MODL, OCSM_INTERNAL_ERROR,
                                    "echildren[%d] not found in body", ichild);
                        status = OCSM_INTERNAL_ERROR;
                        goto cleanup;
                    }

                    if (jedge == iedge && senses[ichild] == SREVERSE) {
                        body->edge[iedge].irite = jface;
                        found = 1;
                        break;
                    }
                }
            }
        }

        if (found == 0) {
            SPRINT4(0, "WARNING:: could not adjust ileft=%d or irite=%d for Edge %d:%d", ileft, irite, ibody, iedge);
            (MODL->nwarn)++;
        }
    }

    /* delete old Edge Attributes (that may be copied onto entities
       by EGADS) */
    noTopoChange = EG_attributeRet(ebody, "__noTopoChange__",
                                   &itype, &nlist,
                                   &tempIlist, &tempRlist, &tempClist);
    keepEdgeAttr = EG_attributeRet(ebody, "__keepEdgeAttr__",
                                   &itype, &nlist,
                                   &tempIlist, &tempRlist, &tempClist);
    if (noTopoChange != SUCCESS && keepEdgeAttr != SUCCESS) {
        if (ibrch > 0 && recycled == 0                 &&
            MODL->brch[ibrch].bclass != OCSM_TRANSFORM &&
            MODL->brch[ibrch].type   != OCSM_UDPRIM    &&
            MODL->brch[ibrch].type   != OCSM_IMPORT      ) {

            for (iedge = 1; iedge <= nedge; iedge++) {
                SPLINT_CHECK_FOR_NULL(body->edge);

                status = EG_attributeNum(body->edge[iedge].eedge, &nattr);
                CHECK_STATUS(EG_attributeNum);

                /* this special treatment is needed since scribe Edges get the
                   _faceID of the scribing Face */
                for (iattr = nattr-1; iattr >= 0; iattr--) {
                    status = EG_attributeGet(body->edge[iedge].eedge, iattr+1, &aname3, &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeGet);

                    if (strcmp(aname3, "__scribeID__") != 0 && strcmp(aname3, "__trace__") != 0) {
                        status = EG_attributeDel(body->edge[iedge].eedge, aname3);
                        CHECK_STATUS(EG_attributeDel);
                    }
                }
            }
        }
    }

    if (keepEdgeAttr == SUCCESS) {
        status = EG_attributeDel(ebody, "__keepEdgeAttr__");
        CHECK_STATUS(EG_attributeDel);
    }

    /* set up the Branch and iford for each Edge */
    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        ileft = body->edge[iedge].ileft;
        irite = body->edge[iedge].irite;

        /* non-manifold with rite neighbor */
        if (ileft < 1 && irite > 0) {
            body->edge[iedge].ibody = body->face[irite].ibody;
            body->edge[iedge].iford = -3;

        /* non-manifold with left neighbor */
        } else if (ileft > 0 && irite < 1) {
            body->edge[iedge].ibody = body->face[ileft].ibody;
            body->edge[iedge].iford = -3;

        /* non-manifold without any neighbors */
        } else if (ileft < 1 || irite < 1) {
            body->edge[iedge].ibody = 0;
            body->edge[iedge].iford = -3;

        /* if noTopoChange is set, then Edge is associated with ileft */
        } else if (noTopoChange == SUCCESS) {
            body->edge[iedge].ibody = MODL->body[body->ileft].edge[iedge].ibody;
            body->edge[iedge].iford = MODL->body[body->ileft].edge[iedge].iford;

        /* if either ileft or irite is a FILLET, CHAMFER, CONNECT, or HOLLOW,
           then Edge is associated with it */
        } else if (MODL->body[body->face[ileft].ibody].brtype == OCSM_FILLET  ||
                   MODL->body[body->face[ileft].ibody].brtype == OCSM_CHAMFER ||
                   MODL->body[body->face[ileft].ibody].brtype == OCSM_CONNECT ||
                   MODL->body[body->face[ileft].ibody].brtype == OCSM_HOLLOW    ) {
            body->edge[iedge].ibody = body->face[ileft].ibody;
            body->edge[iedge].iford = 0;

        } else if (MODL->body[body->face[irite].ibody].brtype == OCSM_FILLET  ||
                   MODL->body[body->face[irite].ibody].brtype == OCSM_CHAMFER ||
                   MODL->body[body->face[irite].ibody].brtype == OCSM_CONNECT ||
                   MODL->body[body->face[irite].ibody].brtype == OCSM_HOLLOW    ) {
            body->edge[iedge].ibody = body->face[irite].ibody;
            body->edge[iedge].iford = 0;

        /* if there is no Branch, then use -5 */
        } else if (ibrch <= 0) {
            body->edge[iedge].ibody = -5;
            body->edge[iedge].iford = -5;

        /* if current Branch is a PRIMITIVE or GROWN, then Edge is associated with it */
        } else if (MODL->brch[ibrch].bclass == OCSM_PRIMITIVE ||
                   MODL->brch[ibrch].bclass == OCSM_GROWN       ) {
            body->edge[iedge].ibody = ibody;
            body->edge[iedge].iford = 10000 * body->face[ileft].iford
                                            + body->face[irite].iford;

        /* if current Branch is a TRANSFORM, then Edge is associated with ileft */
        } else if (MODL->brch[ibrch].bclass == OCSM_TRANSFORM) {
            body->edge[iedge].ibody = MODL->body[body->ileft].edge[iedge].ibody;
            body->edge[iedge].iford = MODL->body[body->ileft].edge[iedge].iford;

        /* if current Branch is a RESTORE, then Edge is associated with ileft */
        } else if (MODL->brch[ibrch].type == OCSM_RESTORE) {
            body->edge[iedge].ibody = MODL->body[body->ileft].edge[iedge].ibody;
            body->edge[iedge].iford = MODL->body[body->ileft].edge[iedge].iford;

        /* search up the tree to find the first common Body */
        } else {
            body->edge[iedge].ibody = -4;
            body->edge[iedge].iford = -4;

            /* get the _hist from the left and rite Faces */
            status = getEdgeHistory(MODL, ibody, iedge, &nhist, &hist);
            CHECK_STATUS(getEdgeHistory);

            if (hist != NULL) {
                body->edge[iedge].ibody = hist[nhist-1];
                body->edge[iedge].iford = 0;

                if (nhist > 1) {
                    body->edge[iedge].iford = 10000 * body->face[ileft].iford
                                                    + body->face[irite].iford;
                }

                FREE(hist);
            }
        }
    }

    /* set up the Body for each Node */
    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        ibeg = body->edge[iedge].ibeg;
        iend = body->edge[iedge].iend;

        assert(ibeg > 0);                         /* needed to avoid clang warning */
        assert(ibeg <= body->nnode);              /* needed to avoid clang warning */
        assert(iend > 0);                         /* needed to avoid clang warning */
        assert(iend <= body->nnode);              /* needed to avoid clang warning */

        if (body->edge[iedge].ibody > body->node[ibeg ].ibody) {
            body->node[ibeg ].ibody = body->edge[iedge].ibody;
        }

        if (body->edge[iedge].ibody > body->node[iend ].ibody) {
            body->node[iend ].ibody = body->edge[iedge].ibody;
        }
    }

    /* if a NodeBody, set the Body for the Node either as itself or its left parent */
    if (body->botype == OCSM_NODE_BODY) {
        if (body->ileft < 0) {
            body->node[1].ibody = ibody;
        } else {
            body->node[1].ibody = MODL->body[body->ileft].node[1].ibody;
        }
    }

    /* store the Body and Face order as Attributes for each Edge */
    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        eedge = body->edge[iedge].eedge;
        iattrib[0] = body->edge[iedge].ibody;
        iattrib[1] = body->edge[iedge].iford;

        status = EG_attributeAdd(eedge, "_body", ATTRINT,
                                 2, iattrib, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* report un-attributed Edges and Faces (but not if non-manifold) */
    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        if        (body->edge[iedge].nface >   2) {

        } else if (body->edge[iedge].iford == -3) {

        } else if (body->edge[iedge].ibody <=  0 ||
                   body->edge[iedge].iford <   0   ) {
            SPRINT4(1, "WARNING:: Edge %d:%3d has .ibody=%d  .iford=%d",
                    ibody, iedge, body->edge[iedge].ibody,
                    body->edge[iedge].iford);
            (MODL->nwarn)++;
        }
    }

    for (iface = 1; iface <= nface; iface++) {
        if (body->face[iface].ibody <= 0 ||
            body->face[iface].iford <  0   ) {
            SPRINT4(1, "WARNING:: Face %d:%3d has .ibody=%d  .iford=%d",
                    ibody, iface, body->face[iface].ibody,
                    body->face[iface].iford);
            (MODL->nwarn)++;
        }
    }

    /* if there are no topological changes, do not adjust any of
       the faceIDs, edgeIDs, or Attributes */
    status = EG_attributeRet(ebody, "__noTopoChange__",
                             &itype, &nlist,
                             &tempIlist, &tempRlist, &tempClist);
    if (status == SUCCESS) {
        status = EG_attributeDel(ebody, "__noTopoChange__");
        CHECK_STATUS(EG_attributeDel);

        goto finalize;
    }

    /* remove the faceID from all Faces, edgeID from all Edges,
       and nodeID from all Nodes */
    for (iface = 1; iface <= nface; iface++) {
        status = EG_attributeRet(body->face[iface].eface, "_faceID",
                                 &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS) {
            status = EG_attributeDel(body->face[iface].eface, "_faceID");
            CHECK_STATUS(EG_attributeDel);
        }
    }

    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        status = EG_attributeRet(body->edge[iedge].eedge, "_edgeID",
                                 &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS) {
            status = EG_attributeDel(body->edge[iedge].eedge, "_edgeID");
            CHECK_STATUS(EG_attributeDel);
        }
    }

    for (inode = 1; inode <= nnode; inode++) {
        status = EG_attributeRet(body->node[inode].enode, "_nodeID",
                                 &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS) {
            status = EG_attributeDel(body->node[inode].enode, "_nodeID");
            CHECK_STATUS(EG_attributeDel);
        }
    }

    PPRINT0(done adding Face attributes);

    /* create a red/black tree to hold all _faceIDs */
    status = rbtCreate(nface, &rbt);
    CHECK_STATUS(rbtCreate);
    SPLINT_CHECK_FOR_NULL(rbt);

    MALLOC(needSeq, int, nface+1);

    /* transfer the _body Attribute to the _faceID */
    icount = 0;

    for (iface = 1; iface <= nface; iface++) {
        needSeq[iface] = 0;
        status = EG_attributeRet(body->face[iface].eface, "_body",
                                 &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        iattrib[0] = tempIlist[0];
        iattrib[1] = tempIlist[1];
        iattrib[2] = 1;

        /* check to see if we have another _faceID with the same two initial entries */
        inode = rbtSearch(rbt, iattrib[0], iattrib[1], 0, 0);

        /* if not, add it now */
        if (inode < 0) {
            status = rbtInsert(rbt, iattrib[0], iattrib[1], 0, 0, iface);
            CHECK_STATUS(rbtInsert);

        /* otherwise increment the sequence number until it is unique */
        } else {
            icount++;
            needSeq[iface] = 1;
            needSeq[rbtLookup(rbt, inode)] = 1;

            for (jface = 1; jface < iface; jface++) {
                status = EG_attributeRet(body->face[jface].eface, "_faceID",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlist[0] == iattrib[0] &&
                    tempIlist[1] == iattrib[1]   ) {
                    iattrib[2] ++;
                }
            }
        }

        /* now add the initial _faceID */
        status = EG_attributeAdd(body->face[iface].eface, "_faceID", ATTRINT,
                                 3, iattrib, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* delete the RBT */
    status = rbtDelete(rbt);
    CHECK_STATUS(rbtDelete);

    rbt = NULL;

    PPRINT0(done with initial _faceID);

    /* reorder the faceIDs based upon cg location when sequence > 1 */
    if (icount > 0) {
        MALLOC(area, double, nface+1);
        MALLOC(xcg,  double, nface+1);
        MALLOC(ycg,  double, nface+1);
        MALLOC(zcg,  double, nface+1);

        /* store flag such that mass properties are computed when needed */
        for (iface = 1; iface <= nface; iface++) {
            area[iface] = -1;
        }

        icount = 0;
        nswap  = 1;
        while (nswap > 0) {
            icount++;
            nswap = 0;

            /* look for Faces that might have seq num > 1 */
            for (iface = 1; iface <= nface; iface++) {
                if (needSeq[iface] == 0) continue;

                status = EG_attributeRet(body->face[iface].eface, "_faceID",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                iattrib[0] = tempIlist[0];
                iattrib[1] = tempIlist[1];
                iattrib[2] = tempIlist[2];

                for (jface = 1; jface <= nface; jface++) {
                    if (needSeq[jface] == 0) continue;

                    status = EG_attributeRet(body->face[jface].eface, "_faceID",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeRet);

                    jattrib[0] = tempIlist[0];
                    jattrib[1] = tempIlist[1];
                    jattrib[2] = tempIlist[2];

                    if (iattrib[0] == jattrib[0] &&
                        iattrib[1] == jattrib[1] &&
                        iattrib[2] >  jattrib[2]   ) {

                        /* get the mass properties if we do not have them yet */
                        if (area[iface] < 0) {
                            status = EG_getMassProperties(body->face[iface].eface, data);
                            CHECK_STATUS(EG_getMassProperties);

                            area[iface] = data[1];
                            xcg[ iface] = data[2];
                            ycg[ iface] = data[3];
                            zcg[ iface] = data[4];
                        }

                        if (area[jface] < 0) {
                            status = EG_getMassProperties(body->face[jface].eface, data);
                            CHECK_STATUS(EG_getMassProperties);

                            area[jface] = data[1];
                            xcg[ jface] = data[2];
                            ycg[ jface] = data[3];
                            zcg[ jface] = data[4];
                        }

                        /* determine if we need a swap */
                        iswap = 0;
                        if        (fabs(xcg[iface]-xcg[jface]) > EPS06) {
                            if (xcg[iface] < xcg[jface]) {
                                iswap = 1;
                            }
                        } else if (fabs(ycg[iface]-ycg[jface]) > EPS06) {
                            if (ycg[iface] < ycg[jface]) {
                                iswap = 1;
                            }
                        } else if (fabs(zcg[iface]-zcg[jface]) > EPS06) {
                            if (zcg[iface] < zcg[jface]) {
                                iswap = 1;
                            }
                        } else if (area[iface] < area[jface]) {
                            iswap = 1;
                        }

                        /* perform the swap */
                        if (iswap > 0) {
                            status = EG_attributeAdd(body->face[iface].eface, "_faceID", ATTRINT,
                                                     3, jattrib, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            status = EG_attributeAdd(body->face[jface].eface, "_faceID", ATTRINT,
                                                     3, iattrib, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            iattrib[0] = jattrib[0];
                            iattrib[1] = jattrib[1];
                            iattrib[2] = jattrib[2];

                            nswap++;
                        }
                    }
                }
            }

            /* if a possible infinite loop because different criteria are
               used in different passes, post a warning and continue */
            if (nswap > 0 && icount > 2*nedge) {
                SPRINT0(1, "WARNING:: _faceID:iseq may be unusable");
                (MODL->nwarn)++;
                break;
            }
        }

        FREE(zcg );
        FREE(ycg );
        FREE(xcg );
        FREE(area);

        PPRINT0(done resolving _faceID sequence numbers);
    }

    FREE(needSeq);

    /* create a red/black tree to hold all _edgeIDs */
    status = rbtCreate(nedge, &rbt);
    CHECK_STATUS(rbtCreate);
    SPLINT_CHECK_FOR_NULL(rbt);

    MALLOC(needSeq, int, nedge+1);

    /* add the _edgeID Attribute to all Edges */
    icount = 0;

    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        needSeq[iedge] = 0;

        ileft = body->edge[iedge].ileft;
        if (ileft >= 0) {
            status = EG_attributeRet(body->face[ileft].eface, "_body",
                                     &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);

            iattrib[0] = tempIlist[0];
            iattrib[1] = tempIlist[1];
        } else {
            iattrib[0] = 0;
            iattrib[1] = 0;
        }

        irite = body->edge[iedge].irite;
        if (irite >= 0) {
            status = EG_attributeRet(body->face[irite].eface, "_body",
                                     &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);

            iattrib[2] = tempIlist[0];
            iattrib[3] = tempIlist[1];
        } else {
            iattrib[2] = 0;
            iattrib[3] = 0;
        }

        /* special handling for case that comes from a scribe operation
           (this case can be identified by having the same _faceID on
           both adjoining Faces and an Edge with a __scribeID__ attribute) */
        if (iattrib[0] == iattrib[2] && iattrib[1] == iattrib[3]) {
            status = EG_attributeRet(body->edge[iedge].eedge, "__scribeID__",
                                     &itype, &nlist,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == EGADS_SUCCESS) {
                iattrib[2] = tempIlist[0];
                iattrib[3] = tempIlist[1];
            }
        }

        /* reorder small to large */
        if (10000*iattrib[0]+iattrib[1] > 10000*iattrib[2]+iattrib[3]) {
            iswap      = iattrib[0];
            iattrib[0] = iattrib[2];
            iattrib[2] = iswap;

            iswap      = iattrib[1];
            iattrib[1] = iattrib[3];
            iattrib[3] = iswap;
        }

        iattrib[4] = 1;

        /* check to see if we have another _edgeID with the same four initial entries */
        inode = rbtSearch(rbt, iattrib[0], iattrib[1], iattrib[2], iattrib[3]);

        /* if not, add it now */
        if (inode < 0) {
            status = rbtInsert(rbt, iattrib[0], iattrib[1], iattrib[2], iattrib[3], iedge);
            CHECK_STATUS(rbtInsert);

        /* otherwise, increment the sequence number until it is unique */
        } else {
            icount++;
            needSeq[iedge] = 1;
            needSeq[rbtLookup(rbt, inode)] = 1;

            for (jedge = 1; jedge < iedge; jedge++) {
                status = EG_attributeRet(body->edge[jedge].eedge, "_edgeID",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlist[0] == iattrib[0] &&
                    tempIlist[1] == iattrib[1] &&
                    tempIlist[2] == iattrib[2] &&
                    tempIlist[3] == iattrib[3]   ) {
                    iattrib[4] ++;
                }
            }
        }

        /* now add the initial _edgeID */
        status = EG_attributeAdd(body->edge[iedge].eedge, "_edgeID", ATTRINT,
                                 5, iattrib, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* delete the RBT */
    status = rbtDelete(rbt);
    CHECK_STATUS(rbtDelete);

    rbt = NULL;

    PPRINT0(done with initial _edgeID);

    /* reorder the edgeIDs based upon cg location when sequence > 1 */
    if (icount > 0) {
        MALLOC(area, double, nedge+1);
        MALLOC(xcg,  double, nedge+1);
        MALLOC(ycg,  double, nedge+1);
        MALLOC(zcg,  double, nedge+1);

        /* store flag that mass properties are compouted when needed */
        for (iedge = 1; iedge <= nedge; iedge++) {
            area[iedge] = -1;
        }

        icount = 0;
        nswap  = 1;
        while (nswap > 0) {
            icount++;
            nswap = 0;

            /* look for Edges that might have seq num > 1 */
            for (iedge = 1; iedge <= nedge; iedge++) {
                if (needSeq[iedge] == 0) continue;

                SPLINT_CHECK_FOR_NULL(body->edge);

                status = EG_attributeRet(body->edge[iedge].eedge, "_edgeID",
                                         &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                iattrib[0] = tempIlist[0];
                iattrib[1] = tempIlist[1];
                iattrib[2] = tempIlist[2];
                iattrib[3] = tempIlist[3];
                iattrib[4] = tempIlist[4];

                for (jedge = 1; jedge <= nedge; jedge++) {
                    if (needSeq[jedge] == 0) continue;

                    status = EG_attributeRet(body->edge[jedge].eedge, "_edgeID",
                                             &itype, &nlist,
                                             &tempIlist, &tempRlist, &tempClist);
                    CHECK_STATUS(EG_attributeRet);

                    jattrib[0] = tempIlist[0];
                    jattrib[1] = tempIlist[1];
                    jattrib[2] = tempIlist[2];
                    jattrib[3] = tempIlist[3];
                    jattrib[4] = tempIlist[4];

                    if (iattrib[0] == jattrib[0] &&
                        iattrib[1] == jattrib[1] &&
                        iattrib[2] == jattrib[2] &&
                        iattrib[3] == jattrib[3] &&
                        iattrib[4] >  jattrib[4]   ) {

                        /* get the mass propeties if we do not have them yet */
                        if (area[iedge] < 0) {
                            status = EG_getMassProperties(body->edge[iedge].eedge, data);
                            CHECK_STATUS(EG_getMassProperties);

                            area[iedge] = data[1];
                            xcg[ iedge] = data[2];
                            ycg[ iedge] = data[3];
                            zcg[ iedge] = data[4];
                        }

                        if (area[jedge] < 0) {
                            status = EG_getMassProperties(body->edge[jedge].eedge, data);
                            CHECK_STATUS(EG_getMassProperties);

                            area[jedge] = data[1];
                            xcg[ jedge] = data[2];
                            ycg[ jedge] = data[3];
                            zcg[ jedge] = data[4];
                        }

                        /* determine if we need a swap */
                        iswap = 0;
                        if        (fabs(xcg[iedge]-xcg[jedge]) > EPS06) {
                            if (xcg[iedge] < xcg[jedge]) {
                                iswap = 1;
                            }
                        } else if (fabs(ycg[iedge]-ycg[jedge]) > EPS06) {
                            if (ycg[iedge] < ycg[jedge]) {
                                iswap = 1;
                            }
                        } else if (fabs(zcg[iedge]-zcg[jedge]) > EPS06) {
                            if (zcg[iedge] < zcg[jedge]) {
                                iswap = 1;
                            }
                        } else if (area[iedge] < area[jedge]) {
                            iswap = 1;
                        }

                        /* perform the swap */
                        if (iswap > 0) {
                            status = EG_attributeAdd(body->edge[iedge].eedge, "_edgeID", ATTRINT,
                                                     5, jattrib, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            status = EG_attributeAdd(body->edge[jedge].eedge, "_edgeID", ATTRINT,
                                                     5, iattrib, NULL, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            iattrib[0] = jattrib[0];
                            iattrib[1] = jattrib[1];
                            iattrib[2] = jattrib[2];
                            iattrib[3] = jattrib[3];
                            iattrib[4] = jattrib[4];

                            nswap++;
                        }
                    }
                }
            }

            /* if a possible infinite loop because different criteria are
               used in different passes, post a warning and continue */
            if (nswap > 0 && icount > 2*nedge) {
                SPRINT0(1, "WARNING:: _edgeID:iseq may be unusable");
                (MODL->nwarn)++;
                break;
            }
        }

        FREE(zcg );
        FREE(ycg );
        FREE(xcg );
        FREE(area);

        PPRINT0(done resolving _edgeID sequence numbers);
    }

    FREE(needSeq);

    /* persist Edge attributes for any Edge in left or rite parents with a matching _edgeID
       and which has equivalent underlying geometries */
    if (ibrch <= 0) {

    } else if (MODL->brch[ibrch].bclass != OCSM_TRANSFORM && recycled == 0) {
        ileft = body->ileft;
        irite = body->irite;

        for (iedge = 1; iedge <= nedge; iedge++) {
            SPLINT_CHECK_FOR_NULL(body->edge);

            done = 0;

            status = EG_getInfo(body->edge[iedge].eedge, &oclass, &mtype, &eref, &prev, &next);
            CHECK_STATUS(EG_getInfo);

            if (mtype == DEGENERATE) continue;

            status = EG_attributeRet(body->edge[iedge].eedge, "_edgeID",
                                     &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);

            status = EG_getRange(body->edge[iedge].eedge, trange, &periodic);
            CHECK_STATUS(EG_getRange);

            status = EG_getTopology(body->edge[iedge].eedge,
                                    &ecurve2, &oclass, &mtype, data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (ileft > 0 && MODL->body[ileft].ebody != NULL) {
                for (jedge = 1; jedge <= MODL->body[ileft].nedge; jedge++) {
                    status = EG_getInfo(MODL->body[ileft].edge[jedge].eedge, &oclass, &mtype, &eref, &prev, &next);
                    CHECK_STATUS(EG_getInfo);

                    if (mtype == DEGENERATE) continue;

                    status = EG_attributeRet(MODL->body[ileft].edge[jedge].eedge, "_edgeID",
                                             &itype2, &nlist2, &tempIlist2, &tempRlist2, &tempClist2);
                    CHECK_STATUS(EG_attributeRet);

                    status = EG_getRange(MODL->body[ileft].edge[jedge].eedge, trange2, &periodic);
                    CHECK_STATUS(EG_getRange);

                    status = EG_getTopology(MODL->body[ileft].edge[jedge].eedge,
                                            &ecurve1, &oclass, &mtype, data, &nchild, &echilds, &senses);
                    CHECK_STATUS(EG_getTopology);

                    /* _edgeID matches */
                    if (tempIlist[0] == tempIlist2[0]    &&
                        tempIlist[1] == tempIlist2[1]    &&
                        tempIlist[2] == tempIlist2[2]    &&
                        tempIlist[3] == tempIlist2[3]    &&
                        trange[0]    >= trange2[0]-EPS03 &&
                        trange[1]    <= trange2[1]+EPS03   ) {

                        status = EG_isSame(ecurve1, ecurve2);
                        if (status == EGADS_SUCCESS) {
                            SPRINT4(2, "Edge %d:%d getting Attributes from left parent %d:%d", ibody, iedge, ileft, jedge);

                            status = EG_attributeNum(MODL->body[ileft].edge[jedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[ileft].edge[jedge].eedge, iattr,
                                                         &aname3, &itype3, &nlist3, &tempIlist3, &tempRlist3, &tempClist3);
                                CHECK_STATUS(EG_attributeGet);

                                if (strcmp(aname3, "_body"  ) != 0 &&
                                    strcmp(aname3, "_edgeID") != 0 &&
                                    strcmp(aname3, "_nface" ) != 0   ) {
                                    SPRINT1(2, "   copying \"%s\"", aname3);

                                    status = EG_attributeAdd(body->edge[iedge].eedge, aname3, itype3,
                                                             nlist3, tempIlist3, tempRlist3, tempClist3);
                                    CHECK_STATUS(EG_attributeAdd);
                                }
                            }

                            status = colorizeEdge(MODL, ibody, iedge);
                            CHECK_STATUS(colorizeEdge);

                            done = 1;
                            break;
                        }

                    /* scribed Edge (in original Body) */
                    } else if (tempIlist[0] == tempIlist[2]     &&
                               trange[0]    >= trange2[0]-EPS03 &&
                               trange[1]    <= trange2[1]+EPS03   ) {

                        status = EG_isSame(ecurve1, ecurve2);
                        if (status == EGADS_SUCCESS) {
                            SPRINT4(2, "Edge %d:%d getting Attributes from left parent %d:%d (scribe)", ibody, iedge, ileft, jedge);

                            status = EG_attributeNum(MODL->body[ileft].edge[jedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[ileft].edge[jedge].eedge, iattr,
                                                         &aname3, &itype3, &nlist3, &tempIlist3, &tempRlist3, &tempClist3);
                                CHECK_STATUS(EG_attributeGet);

                                if (strcmp(aname3, "_body"  ) != 0 &&
                                    strcmp(aname3, "_edgeID") != 0 &&
                                    strcmp(aname3, "_nface" ) != 0   ) {
                                    SPRINT1(2, "   copying \"%s\"", aname3);

                                    status = EG_attributeAdd(body->edge[iedge].eedge, aname3, itype3,
                                                             nlist3, tempIlist3, tempRlist3, tempClist3);
                                    CHECK_STATUS(EG_attributeAdd);
                                }
                            }

                            status = colorizeEdge(MODL, ibody, iedge);
                            CHECK_STATUS(colorizeEdge);

                            done = 1;
                            break;
                        }
                    }
                }
            }

            if (done == 1) continue;

            if (irite > 0 && MODL->body[irite].ebody != NULL) {
                for (jedge = 1; jedge <= MODL->body[irite].nedge; jedge++) {
                    status = EG_getInfo(MODL->body[irite].edge[jedge].eedge, &oclass, &mtype, &eref, &prev, &next);
                    CHECK_STATUS(EG_getInfo);

                    if (mtype == DEGENERATE) continue;

                    status = EG_attributeRet(MODL->body[irite].edge[jedge].eedge, "_edgeID",
                                             &itype2, &nlist2, &tempIlist2, &tempRlist2, &tempClist2);
                    CHECK_STATUS(EG_attributeRet);

                    status = EG_getRange(MODL->body[irite].edge[jedge].eedge, trange2, &periodic);
                    CHECK_STATUS(EG_getRange);

                    status = EG_getTopology(MODL->body[irite].edge[jedge].eedge,
                                            &ecurve1, &oclass, &mtype, data, &nchild, &echilds, &senses);
                    CHECK_STATUS(EG_getTopology);

                    /* _edgeID matches */
                    if (tempIlist[0] == tempIlist2[0]    &&
                        tempIlist[1] == tempIlist2[1]    &&
                        tempIlist[2] == tempIlist2[2]    &&
                        tempIlist[3] == tempIlist2[3]    &&
                        trange[0]    >= trange2[0]-EPS03 &&
                        trange[1]    <= trange2[1]+EPS03   ) {

                        status = EG_isSame(ecurve1, ecurve2);
                        if (status == EGADS_SUCCESS) {
                            SPRINT4(2, "Edge %d:%d getting Attributes from rite parent %d:%d", ibody, iedge, irite, jedge);

                            status = EG_attributeNum(MODL->body[irite].edge[jedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[irite].edge[jedge].eedge, iattr,
                                                         &aname3, &itype3, &nlist3, &tempIlist3, &tempRlist3, &tempClist3);
                                CHECK_STATUS(EG_attributeGet);

                                if (strcmp(aname3, "_body"  ) != 0 &&
                                    strcmp(aname3, "_edgeID") != 0 &&
                                    strcmp(aname3, "_nface" ) != 0   ) {
                                    SPRINT1(2, "   copying \"%s\"", aname3);

                                    status = EG_attributeAdd(body->edge[iedge].eedge, aname3, itype3,
                                                             nlist3, tempIlist3, tempRlist3, tempClist3);
                                    CHECK_STATUS(EG_attributeAdd);
                                }
                            }

                            status = colorizeEdge(MODL, ibody, iedge);
                            CHECK_STATUS(colorizeEdge);

                            break;
                        }

                    /* scribed Edge (in original Body) */
                    } else if (tempIlist[0] == tempIlist[2]     &&
                               trange[0]    >= trange2[0]-EPS03 &&
                               trange[1]    <= trange2[1]+EPS03   ) {

                        status = EG_isSame(ecurve1, ecurve2);
                        if (status == EGADS_SUCCESS) {
                            SPRINT4(2, "Edge %d:%d getting Attributes from rite parent %d:%d (scribe)", ibody, iedge, irite, jedge);

                            status = EG_attributeNum(MODL->body[irite].edge[jedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[irite].edge[jedge].eedge, iattr,
                                                         &aname3, &itype3, &nlist3, &tempIlist3, &tempRlist3, &tempClist3);
                                CHECK_STATUS(EG_attributeGet);

                                if (strcmp(aname3, "_body"  ) != 0 &&
                                    strcmp(aname3, "_edgeID") != 0 &&
                                    strcmp(aname3, "_nface" ) != 0   ) {
                                    SPRINT1(2, "   copying \"%s\"", aname3);

                                    status = EG_attributeAdd(body->edge[iedge].eedge, aname3, itype3,
                                                             nlist3, tempIlist3, tempRlist3, tempClist3);
                                    CHECK_STATUS(EG_attributeAdd);
                                }
                            }

                            status = colorizeEdge(MODL, ibody, iedge);
                            CHECK_STATUS(colorizeEdge);

                            break;
                        }
                    }
                }
            }
        }

        PPRINT0(done persisting _edgeID from parent);

        /* if the last operation was an EXTRACT, persist Edge attributes associated with
           non-manifold Edges from any Edge in the left parent that matches */
        if (MODL->brch[ibrch].type == OCSM_EXTRACT && ileft > 0) {
            SPLINT_CHECK_FOR_NULL(body->edge);

            for (iedge = 1; iedge <= body->nedge; iedge++) {
                status = EG_getTopology(body->edge[iedge].eedge,
                                        &ecurve1, &oclass, &mtype, data, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

                if (mtype == DEGENERATE) continue;

                status = EG_attributeRet(body->edge[iedge].eedge, "_edgeID",
                                         &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeRet);

                if (tempIlist[0] != 0 || tempIlist[1] != 0) continue;

                status = EG_getRange(body->edge[iedge].eedge, trange, &periodic);
                CHECK_STATUS(EG_getRange);

                for (jedge = 1; jedge <= MODL->body[ileft].nedge; jedge++) {
                    status = EG_getTopology(MODL->body[ileft].edge[jedge].eedge,
                                            &ecurve2, &oclass, &mtype, data, &nchild, &echilds, &senses);
                    CHECK_STATUS(EG_getTopology);

                    if (mtype == DEGENERATE) continue;

                    status = EG_getRange(MODL->body[ileft].edge[jedge].eedge, trange2, &periodic);
                    CHECK_STATUS(EG_getRange);

                    status = EG_isSame(ecurve1, ecurve2);
                    if (status == EGADS_SUCCESS) {
                        if (trange[0] >= trange2[0]-EPS03 && trange[1] <= trange2[1]+EPS03) {
                            SPRINT4(2, "Edge %d:%d getting Attributes from left parent %d:%d (extract)", ibody, iedge, ileft, jedge);

                            status = EG_attributeNum(MODL->body[ileft].edge[jedge].eedge, &nattr);
                            CHECK_STATUS(EG_attributeNum);

                            for (iattr = 1; iattr <= nattr; iattr++) {
                                status = EG_attributeGet(MODL->body[ileft].edge[jedge].eedge, iattr,
                                                         &aname3, &itype3, &nlist3, &tempIlist3, &tempRlist3, &tempClist3);
                                CHECK_STATUS(EG_attributeGet);

                                if (strcmp(aname3, "_body"  ) != 0 &&
                                    strcmp(aname3, "_edgeID") != 0 &&
                                    strcmp(aname3, "_nface" ) != 0   ) {
                                    SPRINT1(2, "   copying \"%s\"", aname3);

                                    status = EG_attributeAdd(body->edge[iedge].eedge, aname3, itype3,
                                                             nlist3, tempIlist3, tempRlist3, tempClist3);
                                    CHECK_STATUS(EG_attributeAdd);
                                }
                            }

                            status = colorizeEdge(MODL, ibody, iedge);
                            CHECK_STATUS(colorizeEdge);

                            break;
                        }
                    }
                }
            }
        }

        PPRINT0(done persisting Attributes for non-manifold Edges from EXTRACT);

        /* persist Node attributes for any Node that matches the transformed Node
           location in the parent */
        for (inode = 1; inode <= nnode; inode++) {
            if (MODL->brch[ibrch].type == OCSM_UDPRIM) continue;
            if (MODL->brch[ibrch].type == OCSM_IMPORT) continue;

            /* start by removing any old attributes */
            status = EG_attributeDel(body->node[inode].enode, NULL);
            CHECK_STATUS(EG_attributeDel);

            /* find transformation in left parent */
            ileft = body->ileft;
            found = 0;
            if (ileft > 0) {
                for (jnode = 1; jnode <= MODL->body[ileft].nnode; jnode++) {
                    xparent = MODL->body[ileft].node[jnode].x;
                    yparent = MODL->body[ileft].node[jnode].y;
                    zparent = MODL->body[ileft].node[jnode].z;

                    if        (body->brtype == OCSM_TRANSLATE) {
                        xparent += body->arg[1].val[0];
                        yparent += body->arg[2].val[0];
                        zparent += body->arg[3].val[0];
                    } else if (body->brtype == OCSM_ROTATEX) {
                        cosx = cos(body->arg[1].val[0] * PIo180);
                        sinx = sin(body->arg[1].val[0] * PIo180);
                        dy   =     body->arg[2].val[0];
                        dz   =     body->arg[3].val[0];

                        yold = yparent;
                        zold = zparent;

                        yparent = dy + cosx * (yold - dy) - sinx * (zold - dz);
                        zparent = dz + sinx * (yold - dy) + cosx * (zold - dz);
                    } else if (body->brtype == OCSM_ROTATEY) {
                        cosy = cos(body->arg[1].val[0] * PIo180);
                        siny = sin(body->arg[1].val[0] * PIo180);
                        dz   =     body->arg[2].val[0];
                        dx   =     body->arg[3].val[0];

                        xold = xparent;
                        zold = zparent;

                        xparent = dx + cosy * (xold - dx) + siny * (zold - dz);
                        zparent = dz - siny * (xold - dx) + cosy * (zold - dz);
                    } else if (body->brtype == OCSM_ROTATEZ) {
                        cosz = cos(body->arg[1].val[0] * PIo180);
                        sinz = sin(body->arg[1].val[0] * PIo180);
                        dx   =     body->arg[2].val[0];
                        dy   =     body->arg[3].val[0];

                        xold = xparent;
                        yold = yparent;

                        xparent = dx + cosz * (xold - dx) - sinz * (yold - dy);
                        yparent = dy + sinz * (xold - dx) + sinz * (yold - dy);
                    } else if (body->brtype == OCSM_SCALE) {
                        fact  = body->arg[1].val[0];
                        xcent = body->arg[2].val[0];
                        ycent = body->arg[3].val[0];
                        zcent = body->arg[4].val[0];

                        xparent = xparent * fact + xcent * (1 - fact);
                        yparent = yparent * fact + ycent * (1 - fact);
                        zparent = zparent * fact + zcent * (1 - fact);
                    } else if (body->brtype == OCSM_MIRROR) {
                        nx   = body->arg[1].val[0];
                        ny   = body->arg[2].val[0];
                        nz   = body->arg[3].val[0];
                        dist = body->arg[4].val[0];

                        fact  = sqrt(nx*nx + ny*ny + nz*nz);
                        dx    = nx / fact;
                        dy    = ny / fact;
                        dz    = nz / fact;

                        xold = xparent;
                        yold = yparent;
                        zold = zparent;

                        xparent = (1-2*dx*dx) * xold + ( -2*dy*dx) * yold + ( -2*dz*dx) * zold + 2*dist*dx;
                        yparent = ( -2*dx*dy) * xold + (1-2*dy*dy) * yold + ( -2*dz*dy) * zold + 2*dist*dy;
                        zparent = ( -2*dx*dz) * xold + ( -2*dy*dz) * yold + (1-2*dz*dz) * zold + 2*dist*dz;
                    }

                    if (fabs(body->node[inode].x-xparent) < EPS06 &&
                        fabs(body->node[inode].y-yparent) < EPS06 &&
                        fabs(body->node[inode].z-zparent) < EPS06   ) {
                        SPRINT4(2, "Node %d:%d getting Attributes from left parent %d:%d", ibody, inode, ileft, jnode);
                        found = jnode;
                        break;
                    }
                }

                if (found > 0) {
                    status = EG_attributeNum(MODL->body[ileft].node[found].enode, &nattr);
                    CHECK_STATUS(EG_attributeNum);

                    for (iattr = 1; iattr <= nattr; iattr++) {
                        status = EG_attributeGet(MODL->body[ileft].node[found].enode, iattr,
                                                 &aname3, &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeGet);

                        if (strcmp(aname3, "_nodeID") != 0 && strcmp(aname3, "_nedge") != 0) {
                            status = EG_attributeAdd(body->node[inode].enode, aname3, attrType, attrLen,
                                                     tempIlist, tempRlist, tempClist);
                            CHECK_STATUS(EG_attributeAdd);
                        }
                    }
                }
            }

            irite = body->irite;
            found = 0;
            if (irite > 0) {
                for (jnode = 1; jnode <= MODL->body[irite].nnode; jnode++) {
                    xparent = MODL->body[irite].node[jnode].x;
                    yparent = MODL->body[irite].node[jnode].y;
                    zparent = MODL->body[irite].node[jnode].z;

                    if        (body->brtype == OCSM_TRANSLATE) {
                        xparent += body->arg[1].val[0];
                        yparent += body->arg[2].val[0];
                        zparent += body->arg[3].val[0];
                    } else if (body->brtype == OCSM_ROTATEX) {
                        cosx = cos(body->arg[1].val[0] * PIo180);
                        sinx = sin(body->arg[1].val[0] * PIo180);
                        dy   =     body->arg[2].val[0];
                        dz   =     body->arg[3].val[0];

                        yold = yparent;
                        zold = zparent;

                        yparent = dy + cosx * (yold - dy) - sinx * (zold - dz);
                        zparent = dz + sinx * (yold - dy) + cosx * (zold - dz);
                    } else if (body->brtype == OCSM_ROTATEY) {
                        cosy = cos(body->arg[1].val[0] * PIo180);
                        siny = sin(body->arg[1].val[0] * PIo180);
                        dz   =     body->arg[2].val[0];
                        dx   =     body->arg[3].val[0];

                        xold = xparent;
                        zold = zparent;

                        xparent = dx + cosy * (xold - dx) + siny * (zold - dz);
                        zparent = dz - siny * (xold - dx) + cosy * (zold - dz);
                    } else if (body->brtype == OCSM_ROTATEZ) {
                        cosz = cos(body->arg[1].val[0] * PIo180);
                        sinz = sin(body->arg[1].val[0] * PIo180);
                        dx   =     body->arg[2].val[0];
                        dy   =     body->arg[3].val[0];

                        xold = xparent;
                        yold = yparent;

                        xparent = dx + cosz * (xold - dx) - sinz * (yold - dy);
                        yparent = dy + sinz * (xold - dx) + sinz * (yold - dy);
                    } else if (body->brtype == OCSM_SCALE) {
                        fact  = body->arg[1].val[0];
                        xcent = body->arg[2].val[0];
                        ycent = body->arg[3].val[0];
                        zcent = body->arg[4].val[0];

                        xparent = xparent * fact + xcent * (1 - fact);
                        yparent = yparent * fact + ycent * (1 - fact);
                        zparent = zparent * fact + zcent * (1 - fact);
                    } else if (body->brtype == OCSM_MIRROR) {
                        nx   = body->arg[1].val[0];
                        ny   = body->arg[2].val[0];
                        nz   = body->arg[3].val[0];
                        dist = body->arg[4].val[0];

                        fact  = sqrt(nx*nx + ny*ny + nz*nz);
                        dx    = nx / fact;
                        dy    = ny / fact;
                        dz    = nz / fact;

                        xold = xparent;
                        yold = yparent;
                        zold = zparent;

                        xparent = (1-2*dx*dx) * xold + ( -2*dy*dx) * yold + ( -2*dz*dx) * zold + 2*dist*dx;
                        yparent = ( -2*dx*dy) * xold + (1-2*dy*dy) * yold + ( -2*dz*dy) * zold + 2*dist*dy;
                        zparent = ( -2*dx*dz) * xold + ( -2*dy*dz) * yold + (1-2*dz*dz) * zold + 2*dist*dz;
                    }

                    if (fabs(body->node[inode].x-xparent) < EPS06 &&
                        fabs(body->node[inode].y-yparent) < EPS06 &&
                        fabs(body->node[inode].z-zparent) < EPS06   ) {
                        SPRINT4(2, "Node %d:%d getting Attributes from rite parent %d:%d", ibody, inode, ileft, jnode);
                        found = jnode;
                        break;
                    }
                }

                if (found > 0) {
                    status = EG_attributeNum(MODL->body[irite].node[found].enode, &nattr);
                    CHECK_STATUS(EG_attributeNum);

                    for (iattr = 1; iattr <= nattr; iattr++) {
                        status = EG_attributeGet(MODL->body[irite].node[found].enode, iattr,
                                                 &aname3, &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
                        CHECK_STATUS(EG_attributeGet);

                        if (strcmp(aname3, "_nodeID") != 0 && strcmp(aname3, "_nedge") != 0) {
                            status = EG_attributeAdd(body->node[inode].enode, aname3, attrType, attrLen,
                                                     tempIlist, tempRlist, tempClist);
                            CHECK_STATUS(EG_attributeAdd);
                        }
                    }
                }
            }
        }

        PPRINT0(done persisting _nodeID from parent);
    }

    /* add the _nodeID Attribute to all Nodes */
    for (inode = 1; inode <= nnode; inode++) {
        status = EG_attributeAdd(body->node[inode].enode, "_nodeID", ATTRINT,
                                 1, &inode, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    PPRINT0(done adding _nodeID);

    /* add an Attribute to each Edge telling how many incident Faces it has */
    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        status = EG_attributeAdd(body->edge[iedge].eedge, "_nface", ATTRINT,
                                 1, &(body->edge[iedge].nface), NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* add an Attribute to each Node telling how many incident Edges it has */
    for (inode = 1; inode <= nnode; inode++) {
        status = EG_attributeAdd(body->node[inode].enode, "_nedge", ATTRINT,
                                 1, &(body->node[inode].nedge), NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);
    }

    /* transfer __trace__ from parent */
    if        (body->brtype == OCSM_EXTRUDE) {
        jbody = body->ileft;

        /* transfer __trace__ from Nodes in original Xsect */
        for (jnode = 1; jnode <= MODL->body[jbody].nnode; jnode++) {
            status = EG_attributeRet(MODL->body[jbody].node[jnode].enode, "__trace__",
                                     &attrType, &attrLen, &tempIlist, NULL, NULL);
            if (status == EGADS_SUCCESS) {
                found = 0;
                dbest = HUGEQ;
                for (inode = 1; inode <= body->nnode; inode++) {
                    dtest = fabs(MODL->body[jbody].node[jnode].x-body->node[inode].x)
                        +   fabs(MODL->body[jbody].node[jnode].y-body->node[inode].y)
                        +   fabs(MODL->body[jbody].node[jnode].z-body->node[inode].z);

                    if (dtest < dbest) {
                        found = inode;
                        dbest = dtest;
                    }
                }

                if (found > 0) {
                    status = EG_attributeAdd(body->node[found].enode, "__trace__",
                                             ATTRINT, attrLen, tempIlist, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                }
                if (dbest > EPS06) {
                    SPRINT5(0, "WARNING:: jbody=%2d, jnode=%2d, ibody=%2d, found=%2d, dbest=%12.9f (extrude)",
                           jbody, jnode, ibody, found, dbest);
                }
            }
        }

        /* transfer __trace__ from Edges in original Xsect */
        for (jedge = 1; jedge <= MODL->body[jbody].nedge; jedge++) {
            SPLINT_CHECK_FOR_NULL(body->edge);

            status = EG_getBoundingBox(MODL->body[jbody].edge[jedge].eedge, bbox1);
            CHECK_STATUS(EG_getBoundingBox);

            status = EG_attributeRet(MODL->body[jbody].edge[jedge].eedge, "__trace__",
                                     &attrType, &attrLen, &tempIlist, NULL, NULL);
            if (status == EGADS_SUCCESS) {
                found = 0;
                dbest = HUGEQ;
                for (iedge = 1; iedge <= body->nedge; iedge++) {
                    status = EG_getBoundingBox(body->edge[iedge].eedge, bbox2);
                    CHECK_STATUS(EG_getBoundingBox);

                    dtest = fabs(bbox1[0]-bbox2[0]) + fabs(bbox1[1]-bbox2[1])
                        +   fabs(bbox1[2]-bbox2[2]) + fabs(bbox1[3]-bbox2[3])
                        +   fabs(bbox1[4]-bbox2[4]) + fabs(bbox1[5]-bbox2[5]);

                    if (dtest < dbest) {
                        found = iedge;
                        dbest = dtest;
                    }
                }

                if (dbest < EPS06 && found > 0) {
                    status = EG_attributeAdd(body->edge[found].eedge, "__trace__",
                                             ATTRINT, attrLen, tempIlist, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    SPRINT5(0, "WARNING:: jbody=%2d, jedge=%2d, ibody=%2d, found=%2d, dbest=%12.9f (extrude)",
                            jbody, jedge, ibody, found, dbest);
                }
            }
        }

    } else if (body->brtype == OCSM_REVOLVE) {
        jbody = body->ileft;

        /* transfer __trace__ from Nodes in original Xsect */
        for (jnode = 1; jnode <= MODL->body[jbody].nnode; jnode++) {
            status = EG_attributeRet(MODL->body[jbody].node[jnode].enode, "__trace__",
                                     &attrType, &attrLen, &tempIlist, NULL, NULL);
            if (status == EGADS_SUCCESS) {
                found = 0;
                dbest = HUGEQ;
                for (inode = 1; inode <= body->nnode; inode++) {
                    dtest = fabs(MODL->body[jbody].node[jnode].x-body->node[inode].x)
                        +   fabs(MODL->body[jbody].node[jnode].y-body->node[inode].y)
                        +   fabs(MODL->body[jbody].node[jnode].z-body->node[inode].z);

                    if (dtest < dbest) {
                        found = inode;
                        dbest = dtest;
                    }
                }

                if (dbest < EPS06 && found > 0) {
                    status = EG_attributeAdd(body->node[found].enode, "__trace__",
                                             ATTRINT, attrLen, tempIlist, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    // no warning because a Node might be on the centerline
                }
            }
        }

        /* transfer __trace__ from Edges in original Xsect */
        for (jedge = 1; jedge <= MODL->body[jbody].nedge; jedge++) {
            SPLINT_CHECK_FOR_NULL(body->edge);

            status = EG_getBoundingBox(MODL->body[jbody].edge[jedge].eedge, bbox1);
            CHECK_STATUS(EG_getBoundingBox);

            status = EG_attributeRet(MODL->body[jbody].edge[jedge].eedge, "__trace__",
                                     &attrType, &attrLen, &tempIlist, NULL, NULL);
            if (status == EGADS_SUCCESS) {
                found = 0;
                dbest = HUGEQ;
                for (iedge = 1; iedge <= body->nedge; iedge++) {
                    status = EG_getBoundingBox(body->edge[iedge].eedge, bbox2);
                    CHECK_STATUS(EG_getBoundingBox);

                    dtest = fabs(bbox1[0]-bbox2[0]) + fabs(bbox1[1]-bbox2[1])
                        +   fabs(bbox1[2]-bbox2[2]) + fabs(bbox1[3]-bbox2[3])
                        +   fabs(bbox1[4]-bbox2[4]) + fabs(bbox1[5]-bbox2[5]);

                    if (dtest < dbest) {
                        found = iedge;
                        dbest = dtest;
                    }
                }

                if (dbest < EPS06 && found > 0) {
                    status = EG_attributeAdd(body->edge[found].eedge, "__trace__",
                                             ATTRINT, attrLen, tempIlist, NULL, NULL);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    // no warning becuase an Edge might be on the centerline
                }
            }
        }

    } else if (body->brtype == OCSM_RULE) {
        for (jbody = body->ileft; jbody <= body->irite; jbody++) {
            if (MODL->body[jbody].ichld != ibody) continue;

            /* remove __trace__ from all Nodes.  createVelocityCache propagates
               sensitivities from the Xsec Nodes to the Node on the RULEd body.
               removing __trace__ allows OCSM_RULE and OCSM_BLEND sensitivities
               to be consistently. */
            (void) EG_setOutLevel(MODL->context, 0);
            for (jnode = 1; jnode <= body->nnode; jnode++) {
                SPLINT_CHECK_FOR_NULL(body->node);

                (void) EG_attributeDel(body->node[jnode].enode, "__trace__");
            }
            (void) EG_setOutLevel(MODL->context, outLevel);

            /* remove __trace__ from all Edges.  this has to be done since RULE
               changes the Edge, and so you cannot evaluate the velocity on
               the original Edge in the Xsect */
            (void) EG_setOutLevel(MODL->context, 0);
            for (jedge = 1; jedge <= body->nedge; jedge++) {
                SPLINT_CHECK_FOR_NULL(body->edge);

                (void) EG_attributeDel(body->edge[jedge].eedge, "__trace__");
            }
            (void) EG_setOutLevel(MODL->context, outLevel);
        }

    } else if (body->brtype == OCSM_BLEND) {
        for (jbody = body->ileft; jbody <= body->irite; jbody++) {
            if (MODL->body[jbody].ichld != ibody) continue;

            /* FIX THIS:  for now we do not handle C0 Xsects properly */
            if (jbody != body->ileft && jbody != body->irite) continue;

            /* remove __trace__ from all Nodes.  this has to be done since BLEND
               can create new Nodes with tip treatments. createVelocityCache propagates
               Xsec Node sensitivities to the BLEND body Nodes. */
            (void) EG_setOutLevel(MODL->context, 0);
            for (jnode = 1; jnode <= body->nnode; jnode++) {
                SPLINT_CHECK_FOR_NULL(body->node);

                (void) EG_attributeDel(body->node[jnode].enode, "__trace__");
            }
            (void) EG_setOutLevel(MODL->context, outLevel);

            /* remove __trace__ from all Edges.  this has to be done since BLEND
               changes the Edge, and so you cannot evaluate the velocity on
               the original Edge in the Xsect  */
            (void) EG_setOutLevel(MODL->context, 0);
            for (jedge = 1; jedge <= body->nedge; jedge++) {
                SPLINT_CHECK_FOR_NULL(body->edge);

                (void) EG_attributeDel(body->edge[jedge].eedge, "__trace__");
            }
            (void) EG_setOutLevel(MODL->context, outLevel);
        }

    } else if (body->brtype == OCSM_SWEEP) {
        jbody = body->ileft;

        /* remove __trace__ from all Faces except iford=1 */
        (void) EG_setOutLevel(MODL->context, 0);
        for (iface = 1; iface <= body->nface; iface++) {
            if (body->face[iface].iford != 1 || MODL->body[jbody].botype != OCSM_SHEET_BODY) {
                (void) EG_attributeDel(body->face[iface].eface, "__trace__");
            }
        }
        (void) EG_setOutLevel(MODL->context, outLevel);

    }

finalize:
    /* add __trace__ to each Node */
    for (inode = 1; inode <= body->nnode; inode++) {
        status = addTraceToNode(MODL, ibody, inode);
        CHECK_STATUS(addTraceToNode);
    }

    /* add __trace__ to each Edge */
    for (iedge = 1; iedge <= body->nedge; iedge++) {
        status = addTraceToEdge(MODL, ibody, iedge);
        CHECK_STATUS(addTraceToEdge);
    }

    /* add __trace__ to each Face */
    for (iface = 1; iface <= body->nface; iface++) {
        status = addTraceToFace(MODL, ibody, iface);
        CHECK_STATUS(addTraceToFace);
    }

    /* color Edges as:
       non-manifold (brown)  if .nface <  2
       non-manifold (orange) if .nface >  2
       interior     (green)  if .iford != 0
       exterior     (blue)   otherwise */
    for (iedge = 1; iedge <= nedge; iedge++) {
        SPLINT_CHECK_FOR_NULL(body->edge);

        status = EG_attributeRet(body->edge[iedge].eedge, "__trace__",
                                 &attrType, &attrLen, &tempIlist, NULL, NULL);
        CHECK_STATUS(EG_attributeRet);

        ibrch = MODL->body[tempIlist[0]].ibrch;

        if        (body->edge[iedge].nface < 2) {
            body->edge[iedge].gratt.color = 0x008b4513;          /* brown */
        } else if (body->edge[iedge].nface > 2) {
            body->edge[iedge].gratt.color = 0x00ffa500;          /* orange */
        } else if (ibrch <= 0) {
            body->edge[iedge].gratt.color = 0x00000000;          /* black */
        } else if (MODL->brch[ibrch].bclass == OCSM_PRIMITIVE ||
                   MODL->brch[ibrch].bclass == OCSM_GROWN     ||
                   MODL->brch[ibrch].bclass == OCSM_SKETCH      ) {
            body->edge[iedge].gratt.color = 0x0000ff00;          /* green */
        } else {
            body->edge[iedge].gratt.color = 0x000000ff;          /* blue  */
        }

        status = colorizeEdge(MODL, ibody, iedge);
        CHECK_STATUS(colorizeEdge);
    }

    /* dump a copy of this Body */
    status = dumpEgadsFile(MODL, ibody);
    CHECK_STATUS(dumpEgadsFile);

    /* if this Body came from recycling, remove the __filename__ attribute */
    if (recycled == 1) {
        status = EG_attributeDel(MODL->body[ibody].ebody, "__filename__");
        CHECK_STATUS(EG_attributeDel);
    }

    /* restore status in cases where an interim error occurred above */
    status = EGADS_SUCCESS;

cleanup:
    PPRINT0(exit finish);

    FREE(hist);
    FREE(zcg );
    FREE(ycg );
    FREE(xcg );
    FREE(area);
    FREE(needSeq);

    if (MODL != NULL) {
        if (MODL->body != NULL) {
            if (MODL->body[ibody].node == NULL) MODL->body[ibody].nnode = 0;
            if (MODL->body[ibody].edge == NULL) MODL->body[ibody].nedge = 0;
            if (MODL->body[ibody].face == NULL) MODL->body[ibody].nface = 0;
        }
    }

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   finishCopy - finish the definition of a restored body              *
 *                                                                      *
 ************************************************************************
 */

static int
finishCopy(modl_T *modl,                /* (in)  pointer to MODL */
           int    isrc,                 /* (in)  Body index of source */
 /*@null@*/double matrix[],             /* (in)  transformation matrix (or NULL) */
           int    ibody)                /* (in)  Body index (1:nbody) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ibrch, ileft, irite;
    int       nnode, nedge, nface, ntemp, inode, iedge, iface;
    ego       ebody, *enodes, *eedges, *efaces;
    body_T    *body=NULL, *src=NULL;
#if PRINT_PROGRESS
    time_t    cpu_beg, cpu_end;
#endif

    ROUTINE(finishCopy);

    /* --------------------------------------------------------------- */

    PPRINT_INIT(enter finishCopy);

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* get Body info */
    src  = &(MODL->body[isrc ]);
    body = &(MODL->body[ibody]);

    /* print ego information */
    if (outLevel >= 3) {
        SPRINT1(3, "finishing Body %d:", ibody);
        ocsmPrintEgo(body->ebody);
    }

    /* create parent/child links in the Branches */
    ibrch = body->ibrch;
    ileft = body->ileft;
    irite = body->irite;

    if (ileft > 0) {
        ileft = MODL->body[ileft].ibrch;

        MODL->brch[ibrch].ileft = ileft;
        MODL->brch[ileft].ichld = ibrch;
    } else {
        MODL->brch[ibrch].ileft = -1;
    }

    if (irite > 0) {
        irite = MODL->body[irite].ibrch;

        MODL->brch[ibrch].irite = irite;
        MODL->brch[irite].ichld = ibrch;
    } else {
        MODL->brch[ibrch].irite = -1;
    }

    MODL->brch[ibrch].ichld = -1;

    PPRINT0(done with parent/child);

    /* if a NULL Body o SketchBody, set up quantities */
    if (body->botype == OCSM_NULL_BODY ||
        body->botype == OCSM_SKETCH      ) {
        body->nnode = 0;
        body->nedge = 0;
        body->nface = 0;

        goto cleanup;
    }

    /* get the number of Nodes, Edges, and Faces associated with this Body */
    ebody = body->ebody;
    nnode = src->nnode;
    nedge = src->nedge;
    nface = src->nface;

    body->nnode = nnode;
    body->nedge = nedge;
    body->nface = nface;

    /* delete old Node, Edge, and Face storage */
    FREE(body->node);
    FREE(body->edge);
    FREE(body->face);

    /* add any Attributes associated with this Branch to this Body */
    ibrch = body->ibrch;

    status = setEgoAttribute(MODL, ibrch, ebody);
    CHECK_STATUS(setEgoAttribute);

    /* add the current Branch as an Attribute for this Body */
    status = EG_attributeAdd(ebody, "_body", ATTRINT,
                             1, &ibody, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    status = EG_attributeAdd(ebody, "_brch", ATTRINT,
                             1, &ibrch, NULL, NULL);
    CHECK_STATUS(EG_attributeAdd);

    body->gratt.object = src->gratt.object;
    body->gratt.active = src->gratt.active;
    body->gratt.color  = src->gratt.color;
    body->gratt.ptsize = src->gratt.ptsize;
    body->gratt.render = src->gratt.render;
    body->gratt.dirty  = src->gratt.dirty;

    PPRINT0(done initializing Body);

    /* initialize the Nodes for this Body */
    MALLOC(body->node, node_T, nnode+1);

    status = EG_getBodyTopos(ebody, NULL, NODE, &ntemp, &enodes);
    CHECK_STATUS(EG_getBodyTopos);

    if (ntemp != nnode) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "ntemp=%d does not match nnode=%d", ntemp, nnode);
        SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
    }

    if (enodes != NULL) {
        for (inode = 1; inode <= nnode; inode++) {
            body->node[inode].nedge        = src->node[inode].nedge;
            body->node[inode].ibody        = src->node[inode].ibody;
            body->node[inode].dxyz         = NULL;
            body->node[inode].gratt.object = src->node[inode].gratt.object;
            body->node[inode].gratt.active = src->node[inode].gratt.active;
            body->node[inode].gratt.color  = src->node[inode].gratt.color;
            body->node[inode].gratt.ptsize = src->node[inode].gratt.ptsize;
            body->node[inode].gratt.render = src->node[inode].gratt.render;
            body->node[inode].gratt.dirty  = src->node[inode].gratt.dirty;
            body->node[inode].enode        = enodes[inode-1];

            if (matrix == NULL) {
                body->node[inode].x = src->node[inode].x;
                body->node[inode].y = src->node[inode].y;
                body->node[inode].z = src->node[inode].z;
            } else {
                body->node[inode].x = matrix[ 0] * src->node[inode].x
                                    + matrix[ 1] * src->node[inode].y
                                    + matrix[ 2] * src->node[inode].z + matrix[ 3];
                body->node[inode].y = matrix[ 4] * src->node[inode].x
                                    + matrix[ 5] * src->node[inode].y
                                    + matrix[ 6] * src->node[inode].z + matrix[ 7];
                body->node[inode].z = matrix[ 8] * src->node[inode].x
                                    + matrix[ 9] * src->node[inode].y
                                    + matrix[10] * src->node[inode].z + matrix[1];
            }
        }

        EG_free(enodes);
    }

    PPRINT1(done initializing %d Nodes, nnode);

    /* initialize the Edges for this Body */
    if (body->botype != OCSM_NODE_BODY) {
        if (nedge < 1) {
            SPRINT2(1, "WARNING:: nedge=%d for ibody=%d", nedge, ibody);
            (MODL->nwarn)++;
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

        MALLOC(body->edge, edge_T, nedge+1);

        status = EG_getBodyTopos(ebody, NULL, EDGE, &ntemp, &eedges);
        CHECK_STATUS(EG_getBodyTopos);

        if (ntemp != nedge) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "ntemp=%d does not match nedge=%d", ntemp, nedge);
            SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
        }

        if (eedges != NULL) {
            for (iedge = 1; iedge <= nedge; iedge++) {
                body->edge[iedge].itype        = src->edge[iedge].itype;
                body->edge[iedge].ibeg         = src->edge[iedge].ibeg;
                body->edge[iedge].iend         = src->edge[iedge].iend;
                body->edge[iedge].ileft        = src->edge[iedge].ileft;
                body->edge[iedge].irite        = src->edge[iedge].irite;
                body->edge[iedge].nface        = src->edge[iedge].nface;
                body->edge[iedge].ibody        = src->edge[iedge].ibody;
                body->edge[iedge].iford        = src->edge[iedge].iford;
                body->edge[iedge].imark        = src->edge[iedge].imark;
                body->edge[iedge].gratt.object = src->edge[iedge].gratt.object;
                body->edge[iedge].gratt.active = src->edge[iedge].gratt.active;
                body->edge[iedge].gratt.color  = src->edge[iedge].gratt.color;
                body->edge[iedge].gratt.bcolor = src->edge[iedge].gratt.bcolor;
                body->edge[iedge].gratt.mcolor = src->edge[iedge].gratt.mcolor;
                body->edge[iedge].gratt.lwidth = src->edge[iedge].gratt.lwidth;
                body->edge[iedge].gratt.ptsize = src->edge[iedge].gratt.ptsize;
                body->edge[iedge].gratt.render = src->edge[iedge].gratt.render;
                body->edge[iedge].gratt.dirty  = src->edge[iedge].gratt.dirty;
                body->edge[iedge].dxyz         = NULL;
                body->edge[iedge].dt           = NULL;
                body->edge[iedge].eedge        = eedges[iedge-1];
            }

            EG_free(eedges);
        }
    }

    PPRINT1(done initializing %d Edges, nedge);

    /* initialize the Faces for this Body */
    MALLOC(body->face, face_T, nface+1);

    status = EG_getBodyTopos(ebody, NULL, FACE, &ntemp, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (ntemp != nface) {
        signalError(MODL, OCSM_INTERNAL_ERROR,
                    "ntemp=%d does not match nface=%d", ntemp, nface);
        SET_STATUS(OCSM_INTERNAL_ERROR, EG_getBodyTopos);
    }

    if (efaces != NULL) {
        for (iface = 1; iface <= nface; iface++) {
            body->face[iface].ibody        = src->face[iface].ibody;
            body->face[iface].iford        = src->face[iface].iford;
            body->face[iface].imark        = src->face[iface].imark;
            body->face[iface].gratt.object = src->face[iface].gratt.object;
            body->face[iface].gratt.active = src->face[iface].gratt.active;
            body->face[iface].gratt.color  = src->face[iface].gratt.color;
            body->face[iface].gratt.bcolor = src->face[iface].gratt.bcolor;
            body->face[iface].gratt.mcolor = src->face[iface].gratt.mcolor;
            body->face[iface].gratt.lwidth = src->face[iface].gratt.lwidth;
            body->face[iface].gratt.ptsize = src->face[iface].gratt.ptsize;
            body->face[iface].gratt.render = src->face[iface].gratt.render;
            body->face[iface].gratt.dirty  = src->face[iface].gratt.dirty;
            body->face[iface].eggdata      = NULL;
            body->face[iface].dxyz         = NULL;
            body->face[iface].duv          = NULL;
            body->face[iface].eface        = efaces[iface-1];
        }

        EG_free(efaces);
    }

    PPRINT1(done initializing %d Faces, nface);

    /* store Csystem on this Body */
    (void) storeCsystem(MODL, ibody);
    if (MODL->sigCode != SUCCESS) {
        status = freeBody(MODL, ibody);
        MODL->nbody--;
        goto cleanup;
    }

    /* dump a copy of this Body */
    status = dumpEgadsFile(MODL, ibody);
    CHECK_STATUS(dumpEgadsFile);

    /* restore status in cases where an interim error occurred above */
    status = EGADS_SUCCESS;

cleanup:
    PPRINT0(exit finishCopy);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   finiteDifference - get derivatives by finite differences           *
 *                                                                      *
 ************************************************************************
 */

static int
finiteDifference(modl_T *modl,          /* (in)  pointer to MODL */
                 int    ibody,          /* (in)  Body index (1:nbody) */
                 int    seltype,        /* (in)  select type: OCSM_FACE, OCSM_EDGE, or OCSM_NODE */
                 int    iselect,        /* (in)  Face, Ege, or Node index (1:nent) */
                 int    npnt,           /* (in)  number of points */
       /*@null@*/double uv[],           /* (in)  array of t or uv at points (or NULL) */
                 double dxyz[])         /* (out) array of xyz at points */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface;

    modl_T    *MODL = (modl_T*)modl;

    int       npnt_base, npnt_ptrb, ntri_base, ntri_ptrb, ip0, ip1, ip2, itri, ipnt;
    int       oclass, mtype, nchild, *senses, itype, nlist, jnode;
    CINT      *tris_base, *tris_ptrb, *tric_base, *tric_ptrb;
    CINT      *ptype_base, *ptype_ptrb, *pindx_base, *pindx_ptrb;
    CINT      *tempIlist;
    double    uv_face[2], weights[3], data_base[18], data_ptrb[18];
    CDOUBLE   *xyz_base, *xyz_ptrb, *uv_base, *uv_ptrb;
    ego       eref, *echilds;

    ROUTINE(finiteDifference);

    /* --------------------------------------------------------------- */

    if (MODL->dtime == -2) {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] = 0;
            dxyz[3*ipnt+1] = 0;
            dxyz[3*ipnt+2] = 0;
        }
    } else if (seltype == OCSM_FACE) {
        iface = iselect;

        if (MODL->body[ibody].etess == NULL) {
            status = ocsmTessellate(MODL, ibody);
            CHECK_STATUS(ocsmTessellate);
        }

        if (MODL->perturb->body[ibody].etess == NULL) {
            status = ocsmTessellate(MODL->perturb, ibody);
            CHECK_STATUS(ocsmTessellate);
        }

        /* get the base and perturbed tessellations. note that we do not need to
           explicitly use the .fMap Attribute since it is taken care of in
           EG_getTessFace() */
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_base, &xyz_base, &uv_base, &ptype_base, &pindx_base,
                                &ntri_base, &tris_base, &tric_base);
        CHECK_STATUS(EG_getTessFace);

        status = EG_getTessFace(MODL->perturb->body[ibody].etess, -iface,
                                &npnt_ptrb, &xyz_ptrb, &uv_ptrb, &ptype_ptrb, &pindx_ptrb,
                                &ntri_ptrb, &tris_ptrb, &tric_ptrb);
        CHECK_STATUS(EG_getTessFace);

        /* if using tessellation points, just take finite difference of locations */
        if (uv == NULL) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                dxyz[3*ipnt  ] = (xyz_ptrb[3*ipnt  ] - xyz_base[3*ipnt  ]) / MODL->dtime;
                dxyz[3*ipnt+1] = (xyz_ptrb[3*ipnt+1] - xyz_base[3*ipnt+1]) / MODL->dtime;
                dxyz[3*ipnt+2] = (xyz_ptrb[3*ipnt+2] - xyz_base[3*ipnt+2]) / MODL->dtime;
            }

        /* otherwise, interpolate into the tessellation and then take finite differences */
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                uv_face[0] = uv[2*ipnt  ];
                uv_face[1] = uv[2*ipnt+1];

                status = EG_locateTessBody(MODL->body[ibody].etess, 1,
                                           &iface, uv_face, &itri, weights);
                CHECK_STATUS(EG_locateTessBody);

                ip0 = tris_base[3*(itri-1)  ] - 1;
                ip1 = tris_base[3*(itri-1)+1] - 1;
                ip2 = tris_base[3*(itri-1)+2] - 1;

                dxyz[3*ipnt  ] = ((xyz_ptrb[3*ip0  ] * weights[0]
                                  +xyz_ptrb[3*ip1  ] * weights[1]
                                  +xyz_ptrb[3*ip2  ] * weights[2])
                                 -(xyz_base[3*ip0  ] * weights[0]
                                  +xyz_base[3*ip1  ] * weights[1]
                                  +xyz_base[3*ip2  ] * weights[2])) / MODL->dtime;
                dxyz[3*ipnt+1] = ((xyz_ptrb[3*ip0+1] * weights[0]
                                  +xyz_ptrb[3*ip1+1] * weights[1]
                                  +xyz_ptrb[3*ip2+1] * weights[2])
                                 -(xyz_base[3*ip0+1] * weights[0]
                                  +xyz_base[3*ip1+1] * weights[1]
                                  +xyz_base[3*ip2+1] * weights[2])) / MODL->dtime;
                dxyz[3*ipnt+2] = ((xyz_ptrb[3*ip0+2] * weights[0]
                                  +xyz_ptrb[3*ip1+2] * weights[1]
                                  +xyz_ptrb[3*ip2+2] * weights[2])
                                 -(xyz_base[3*ip0+2] * weights[0]
                                  +xyz_base[3*ip1+2] * weights[1]
                                  +xyz_base[3*ip2+2] * weights[2])) / MODL->dtime;
            }
        }
    } else if (seltype == OCSM_EDGE) {
        iedge = iselect;

        if (MODL->body[ibody].etess == NULL) {
            status = ocsmTessellate(MODL, ibody);
            CHECK_STATUS(ocsmTessellate);
        }

        if (MODL->perturb->body[ibody].etess == NULL) {
            status = ocsmTessellate(MODL->perturb, ibody);
            CHECK_STATUS(ocsmTessellate);
        }

        /* get the base and perturbed tessellations.  note that we do not need to
           explicitly use the .eMap Attribute since it is taken care of in
           EG_getTessEdge() */
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt_base, &xyz_base, &uv_base);
        CHECK_STATUS(EG_getTessEdge);

        status = EG_getTessEdge(MODL->perturb->body[ibody].etess, -iedge,
                                &npnt_ptrb, &xyz_ptrb, &uv_ptrb);
        CHECK_STATUS(EG_getTessEdge);

        /* if using tessellation points, just take finite difference of locations */
        if (uv == NULL) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                dxyz[3*ipnt  ] = (xyz_ptrb[3*ipnt  ] - xyz_base[3*ipnt  ]) / MODL->dtime;
                dxyz[3*ipnt+1] = (xyz_ptrb[3*ipnt+1] - xyz_base[3*ipnt+1]) / MODL->dtime;
                dxyz[3*ipnt+2] = (xyz_ptrb[3*ipnt+2] - xyz_base[3*ipnt+2]) / MODL->dtime;
            }

        /* otherwise, interpolate into the tessellation and then take finite differences */
        } else {
//$$$   this might be a problem because it does not account for possible changes in t
//$$$       between the perturbed and baseline curves
//$$$
//$$$       perhaps we should use the same "normalized" t instead of the t itself (Bill Jones)
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                     &(uv[ipnt]), data_base);
                CHECK_STATUS(EG_evaluate);

                status = EG_evaluate(MODL->perturb->body[ibody].edge[iedge].eedge,
                                     &(uv[ipnt]), data_ptrb);
                CHECK_STATUS(EG_evaluate);

                dxyz[3*ipnt  ] = (data_ptrb[0] - data_base[0]) / MODL->dtime;
                dxyz[3*ipnt+1] = (data_ptrb[1] - data_base[1]) / MODL->dtime;
                dxyz[3*ipnt+2] = (data_ptrb[2] - data_base[2]) / MODL->dtime;
            }
        }

    } else if (seltype == OCSM_NODE) {
        inode = iselect;

        if (MODL->body[ibody].etess == NULL) {
            status = ocsmTessellate(MODL, ibody);
            CHECK_STATUS(ocsmTessellate);
        }

        if (MODL->perturb->body[ibody].etess == NULL) {
            status = ocsmTessellate(MODL->perturb, ibody);
            CHECK_STATUS(ocsmTessellate);
        }

        /* if .nMap exists, use mapped Node location in the perturbed Body */
        SPLINT_CHECK_FOR_NULL(MODL->perturb);

        status = EG_attributeRet(MODL->perturb->body[ibody].ebody, ".nMap",
                                 &itype, &nlist, &tempIlist, NULL, NULL);
        if (status == SUCCESS) {
            jnode = tempIlist[inode-1];
        } else {
            jnode = inode;
        }

        /* get the two locations */
        status = EG_getTopology(MODL->body[ibody].node[inode].enode, &eref,
                                &oclass, &mtype, data_base, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        status = EG_getTopology(MODL->perturb->body[ibody].node[jnode].enode, &eref,
                                &oclass, &mtype, data_ptrb, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        dxyz[0] = (data_ptrb[0] - data_base[0]) / MODL->dtime;
        dxyz[1] = (data_ptrb[1] - data_base[1]) / MODL->dtime;
        dxyz[2] = (data_ptrb[2] - data_base[2]) / MODL->dtime;

        /* bad value for seltype */
    } else {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   fixSketch - find constraints that will improve Sketch              *
 *                                                                      *
 ************************************************************************
 */

static int
fixSketch(sket_T *sket,                 /* (in)  Sketch structure */
          char   vars[],                /* (in)  variable string */
          char   cons_mod[])            /* (out) deleted and added constraints */
{
    int       status = SUCCESS;         /* (out) return status */

    int       i, j, count, ipnt, im1, ip1, npnt, icon, jcon;
    int       old_rank, new_rank, okay, nadd, ndel, *segtyp=NULL;
    double    *xyd=NULL, *xyd_out=NULL, *xy=NULL, *res=NULL, *jac=NULL, *dxy=NULL, *sval=NULL;
    double    dx, dy, dip;
    double    tan20=0.364, tan25=0.466, tan65=2.145;
    char      temp[MAX_EXPR_LEN], savetype;

    ROUTINE(fixSketch);

    /* --------------------------------------------------------------- */

    SPRINT2(2, "enter fixSketch(nvar=%d, ncon=%d)", sket->nvar, sket->ncon);

    /* default output (no suggestted deletions or additions) */
    cons_mod[0] = '\0';

    /* read the xyd from vars */
    count = 0;
    for (i = 0; i < STRLEN(vars); i++) {
        if (vars[i] == ';') {
            count++;
        }
    }

    assert(count > 0);
    MALLOC(xyd,     double, count);
    MALLOC(xyd_out, double, count);

    npnt    = 0;
    j       = 0;
    temp[0] = '\0';
    for (i = 0; i < STRLEN(vars); i++) {
        if (vars[i] == ';') {
            sscanf(temp, "%lf", &(xyd[npnt]));
            npnt++;
            j       = 0;
            temp[0] = '\0';
        } else {
            temp[j++] = vars[i];
            temp[j  ] = '\0';
        }
    }
    npnt /= 3;
    SPRINT1(2, "npnt=%d", npnt);

    assert (npnt > 1);
    MALLOC(segtyp, int, npnt);

    /* determine the Segment types */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        segtyp[ipnt] = 0;               // unclassified

        ip1 = ipnt + 1;   if (ip1 >= npnt) ip1 -= npnt;

        dx  = xyd[3*ip1  ] - xyd[3*ipnt  ];
        dy  = xyd[3*ip1+1] - xyd[3*ipnt+1];
        dip =                xyd[3*ip1 +2];

        /* linear Segments */
        if (fabs(dip) < EPS06) {
            if        (fabs(dy) < tan20*fabs(dx)) {
                segtyp[ipnt] = 1;       // horizontal
            } else if (fabs(dx) < tan20*fabs(dy)) {
                segtyp[ipnt] = 2;       // vertical
            } else {
                segtyp[ipnt] = 3;      // unknown linear Segment
            }

        /* circular arc Segments */
        } else {
            if (fabs(dy) > tan25*fabs(dx) && fabs(dy) < tan65*fabs(dx)) {
                if (dx*dy*dip > 0) {
                    segtyp[ipnt] = 4;   // 90hv bend: horizontal to vertical
                } else {
                    segtyp[ipnt] = 5;   // 90vh bend: vertical   to horizontal
                }
            } else if (fabs(dx) < tan20*fabs(dy)) {
                segtyp[ipnt] = 6;       // 180hh bend: horizontal to horizontal
            } else if (fabs(dy) < tan20*fabs(dx)) {
                segtyp[ipnt] = 7;       // 180vv bend: vertical   to vertical
            } else {
                segtyp[ipnt] = 8;       // unknown cirarc Segment
            }
        }

        SPRINT5(2, "%3d   %10.5f %10.5f %10.5f  %d",
                ipnt, xyd[3*ipnt], xyd[3*ipnt+1], xyd[3*ipnt+2], segtyp[ipnt]);
    }

    /* getting here means that we did not converge or that we are
       over-constrainted, so see if there are any redundant constraints
       (which will be detected by comparing the matrix ranks) */
    status = fixSketchRank(sket, npnt, segtyp, &old_rank);
    SPRINT1(2, "old_rank=%d", old_rank);
    CHECK_STATUS(fixSketchRank);

    /* check to see if any of the constraints could be deleted without
       reducing the rank */
    ndel = 0;
    for (icon = 0; icon < sket->ncon; icon++) {
        SPRINT4x(2, "trying to delete constraint %d (%c %2d %2d): ",
                 icon, sket->ctype[icon], sket->ipnt[icon], sket->ip1[icon]);

        ipnt = sket->ipnt[icon] - 1;    /* switch to bias-0 */

        /* do not try to delete a constraint that will not be
           processed by fixSketchRank, because otherwise we will
           not see a reduction in the rank and will therefore
           (perhaps) erroneously suggest that the constraint
           can be removed */
        if        (sket->ctype[icon] == 'X') {
            if (ipnt == 0) {
                SPRINT0(2, "cannot delete X on point 1");
                continue;
            }
        } else if (sket->ctype[icon] == 'Y') {
            if (ipnt == 0) {
                SPRINT0(2, "cannot delete Y on point 1");
                continue;
            }
        } else if (sket->ctype[icon] == 'V') {
        } else if (sket->ctype[icon] == 'W') {
        } else if (sket->ctype[icon] == 'H') {
        } else if (sket->ctype[icon] == 'D') {
        } else if (sket->ctype[icon] == 'L') {
            if        (segtyp[ipnt] == 1) {
                /* nearly horizontal */
            } else if (segtyp[ipnt] == 2) {
                /* nearly vertical */
            } else {
                SPRINT0(2, "not nearly horizontal or vertical");
                continue;     /* skip this one */
            }

        } else if (sket->ctype[icon] == 'T') {
            im1 = ipnt - 1;   if (im1 < 0) im1 += npnt;

            if        (segtyp[im1] == 1 && segtyp[ipnt] == 1) {
                /* both segs nearly horizontal */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 2) {
                /* both segs nearly vertical */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 4) {
                /* horizontal to 90hv */
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 1) {
                /* 90vh to hoirizontal */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 5) {
                /* vertical to 90vh */
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 2) {
                /* 90hv to vertical */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 6) {
                /* horizontal to 180hh */
            } else if (segtyp[im1] == 6 && segtyp[ipnt] == 1) {
                /* 180hh to horizontal */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 7) {
                /* vertical to 180vv */
            } else if (segtyp[im1] == 7 && segtyp[ipnt] == 2) {
                /* 180vv to vertical */
            } else {
                SPRINT0(2, "invalid horizontal or vertical connection");
                continue;     /* skip this one */
            }

        } else if (sket->ctype[icon] == 'P') {
            im1 = ipnt - 1;   if (im1 < 0) im1 += npnt;

            if        (segtyp[im1] == 1 && segtyp[ipnt] == 2) {
                /* horizontal and vertical */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 1) {
                /* vertical and horizontal */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 5) {
                /* horizontal and 90vh */
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 2) {
                /* 90vh and vertical */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 4) {
                /* vertical amd 90hv */
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 1) {
                /* 90hv and horizontal */
            } else {
                SPRINT0(2, "invalid horizontal and vertical connection");
                continue;     /* skip this one */
            }

        } else if (sket->ctype[icon] == 'R')  {

            if        (segtyp[ipnt] == 4 || segtyp[ipnt] == 5) {
                /* 90hv or 90vh */
            } else if (segtyp[ipnt] == 6 || segtyp[ipnt] == 7) {
                /* 180hh or 180vv */
            } else {
                SPRINT0(2, "not recognized bend");
                continue;     /* skip this one */
            }

        } else {
            SPRINT0(2, "unknown type");
            continue;         /* skip this one, since unknown type */
        }

        /* temporarily overwrite constraint type */
        savetype          = sket->ctype[icon];
        sket->ctype[icon] = ' ';

        status = fixSketchRank(sket, npnt, segtyp, &new_rank);
        SPRINT1x(2, "new_rank=%d  ", new_rank);
        CHECK_STATUS(fixSketchRank);

        sket->ctype[icon] = savetype;

        /* if removing the constraint does not reduce the rank, suggest that
           the constraint can be removed */
        if (new_rank == old_rank) {
            SPRINT0(2, "accept");
            ndel++;
            if (ndel == 1) {
                snprintf(cons_mod, MAX_EXPR_LEN, "*del;%c;%d;%d",
                         sket->ctype[icon], sket->ipnt[icon], sket->ip1[icon]);
            } else {
                snprintf(temp,     MAX_EXPR_LEN,     ";%c;%d;%d",
                         sket->ctype[icon], sket->ipnt[icon], sket->ip1[icon]);
                strncat(cons_mod, temp, MAX_EXPR_LEN);
            }
        } else {
            SPRINT0(2, "reject (rank was reduced)");
        }
    }

    SPRINT1(2, "suggesting %d constraints to delete", ndel);
    if (ndel > 0) goto cleanup;

    /* getting here means that no constraints could be removed without
       lowering the rank, so try adding various constraint types */
    nadd = 0;

    /* loop through all points to see if point-based constraints will improve the rank */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        im1 = ipnt - 1;   if (im1 < 0) im1 += npnt;

        /* check if adding 'X' constraint will improve rank */
        SPRINT1x(2, "trying to add X constraint %2d -1: ", ipnt+1);

        /* only consider if we do not already have an 'X' at this point */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (sket->ctype[jcon] == 'X' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have X");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'X';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = -1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;X;%d;-1", ipnt+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";X;%d;-1", ipnt+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'Y' constraint will improve rank */
        SPRINT1x(2, "trying to add Y constraint %2d -1: ", ipnt+1);

        /* only consider if we do not already have a 'Y' at this point */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (sket->ctype[jcon] == 'Y' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have Y");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'Y';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = -1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;Y;%d;-1", ipnt+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";Y;%d;-1", ipnt+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'T' constraint will improve rank */
        SPRINT1x(2, "trying to add T constraint %2d -1: ", ipnt+1);

        /* only consider if we do not already have a 'T' or 'P' at this point
           and we have the right horizontal or vertical connection */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if        (sket->ctype[jcon] == 'T' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have T");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'P' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have P");
                okay = 0;
                break;
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 4) {
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 1) {
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 5) {
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 2) {
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 6) {
            } else if (segtyp[im1] == 6 && segtyp[ipnt] == 1) {
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 7) {
            } else if (segtyp[im1] == 7 && segtyp[ipnt] == 2) {
            } else {
                SPRINT0(2, "wrong segtyp connections");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'T';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = -1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;T;%d;-1", ipnt+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";T;%d;-1", ipnt+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'P' constraint will improve rank */
        SPRINT1x(2, "trying to add P constraint %2d -1: ", ipnt+1);

        /* only consider if we do not already have a 'T' or 'P' at this point
           and we have the right horizontal or vertical connection */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if        (sket->ctype[jcon] == 'T' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have T");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'P' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have P");
                okay = 0;
                break;
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 5) {
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 2) {
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 4) {
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 1) {
            } else {
                SPRINT0(2, "wrong segtyp connections");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'P';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = -1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;P;%d;-1", ipnt+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";P;%d;-1", ipnt+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }
    }

    /* loop through all segments to see if segment-based constraints will improve rank */
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        ip1 = ipnt + 1;   if (ip1 >= npnt) ip1 -= npnt;
        SPRINT3(2, "ipnt=%d, ip1=%d, npnt=%d", ipnt, ip1, npnt);

        /* check if adding 'H' constraint will improve rank */
        SPRINT2x(2, "trying to add H constraint %2d %2d: ", ipnt+1, ip1+1);

        /* only consider if nearly horizontal and we do not
           have a 'H', 'V', or 'I' already on this segment */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (segtyp[ipnt] != 1) {
                SPRINT0(2, "not nearly horizontal");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'H' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have H");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'V' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have V");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'I' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have I");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'H';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = ip1  + 1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;H;%d;%d", ipnt+1, ip1+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";H;%d;%d", ipnt+1, ip1+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'V' constraint will improve rank */
        SPRINT2x(2, "trying to add V constraint %2d %2d: ", ipnt+1, ip1+1);

        /* only consider if nearly vertical and we do not
           have a 'H', 'V', or 'I' already on this segment */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (segtyp[ipnt] != 2) {
                SPRINT0(2, "not nearly vertical");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'H' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have H");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'V' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have V");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'I' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have I");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'V';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = ip1  + 1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;V;%d;%d", ipnt+1, ip1+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";V;%d;%d", ipnt+1, ip1+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'L' constraint will improve rank */
        SPRINT2x(2, "trying to add L constraint %2d %2d: ", ipnt+1, ip1+1);

        /* only consider if we do not already have an 'L'
           on this segment and not nearly horizontal or vertical */
        okay = 1;
        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (segtyp[ipnt] != 1 && segtyp[ipnt] != 2) {
                SPRINT0(2, "not nearly horizontal or vertical");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'L' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have L");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'L';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = ip1  + 1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;L;%d;%d", ipnt+1, ip1+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";L;%d;%d", ipnt+1, ip1+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

        /* check if adding 'R' constraint will improve rank */
        SPRINT2x(2, "trying to add R constraint %2d %2d: ", ipnt+1, ip1+1);

        /* only consider if we do not already have a 'R'
           on this Segment and not 180 bend */
        okay = 1;

        for (jcon = 0; jcon < sket->ncon; jcon++) {
            if (segtyp[ipnt] != 4 && segtyp[ipnt] != 5 &&
                segtyp[ipnt] != 6 && segtyp[ipnt] != 7   ) {
                SPRINT0(2, "not 90 or 180 bend");
                okay = 0;
                break;
            } else if (sket->ctype[jcon] == 'R' && sket->ipnt[jcon] == ipnt+1) {
                SPRINT0(2, "already have R");
                okay = 0;
                break;
            }
        }

        if (okay) {
            sket->ctype[sket->ncon] = 'R';
            sket->ipnt[ sket->ncon] = ipnt + 1;
            sket->ip1[  sket->ncon] = ip1  + 1;

            (sket->ncon)++;
            status = fixSketchRank(sket, npnt, segtyp, &new_rank);
            (sket->ncon)--;
            SPRINT1x(2, "new_rank=%d  ", new_rank);
            CHECK_STATUS(fixSketchRank);

            if (new_rank > old_rank) {
                SPRINT0(2, "accept");
                nadd++;

                if (nadd == 1) {
                    snprintf(cons_mod, MAX_EXPR_LEN, "*add;R;%d;%d", ipnt+1, ip1+1);
                } else {
                    snprintf(temp,     MAX_EXPR_LEN,     ";R;%d;%d", ipnt+1, ip1+1);
                    strncat(cons_mod, temp, MAX_EXPR_LEN);
                }
            } else {
                SPRINT0(2, "reject (rank did not improve)");
            }
        }

    }

    SPRINT1(2, "suggesting %d constraints to add", nadd);
    if (nadd > 0) goto cleanup;

cleanup:
    FREE(xyd_out);
    FREE(xyd );

    FREE(segtyp);

    FREE(sval);
    FREE(dxy );
    FREE(jac );
    FREE(res );
    FREE(xy  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   fixSketchRank - compute rank of simplified Jacobian matrix         *
 *                                                                      *
 ************************************************************************
 */

static int
fixSketchRank(sket_T *sket,             /* (in)  sketch info */
              int    npnt,              /* (in)  number of points */
              int    segtyp[],          /* (in)  array  os Segment types */
              int    *jrank)            /* (out) rank of Jacobian */
{
    int       status = SUCCESS;         /* (out) return status */

    int       icon, irow, nrow, icol, ncol, ipnt, im1, ip1;
    double    *jac=NULL;

    ROUTINE(fixSketchRank);

    /* --------------------------------------------------------------- */

    /* each point has an x, y, and dip */
    ncol = 3 * npnt;
    nrow = MAX(sket->ncon, ncol);

    /* allocate and initialize jacobian */
    MALLOC(jac, double, nrow*ncol);

    for (icon = 0; icon < nrow; icon++) {
        for (icol = 0; icol < ncol; icol++) {
            jac[icon*ncol+icol] = 0;
        }
    }

    /* add each of the constraints to the matricies */
    for (icon = 0; icon < sket->ncon; icon++) {
        ipnt = sket->ipnt[icon] - 1;     /* switch to bias-0 */
        ip1  = sket->ip1[ icon] - 1;

        /* 'X' constraint */
        if        (sket->ctype[icon] == 'X') {
            jac[icon*ncol+3*ipnt  ] = +1;

        /* 'Y' constraint */
        } else if (sket->ctype[icon] == 'Y') {
            jac[icon*ncol+3*ipnt+1] = +1;

        /* 'V' constraint */
        } else if (sket->ctype[icon] == 'V') {
            jac[icon*ncol+3*ipnt  ] = -1;
            jac[icon*ncol+3*ip1   ] = +1;

        /* 'W' constraint */
        } else if (sket->ctype[icon] == 'W') {
            jac[icon*ncol+3*ipnt  ] = -1;
            jac[icon*ncol+3*ip1   ] = +1;

        /* 'H' constraint */
        } else if (sket->ctype[icon] == 'H') {
            jac[icon*ncol+3*ipnt+1] = -1;
            jac[icon*ncol+3*ip1 +1] = +1;

        /* 'D' constraint */
        } else if (sket->ctype[icon] == 'D') {
            jac[icon*ncol+3*ipnt+1] = -1;
            jac[icon*ncol+3*ip1 +1] = +1;

        /* 'L' constraint */
        } else if (sket->ctype[icon] == 'L') {
            /* horizontal segment */
            if        (segtyp[ipnt] == 1) {
                jac[icon*ncol+3*ipnt  ] = -1;
                jac[icon*ncol+3*ip1   ] = +1;
            /* vertical segment */
            } else if (segtyp[ipnt] == 2) {
                jac[icon*ncol+3*ipnt+1] = -1;
                jac[icon*ncol+3*ip1 +1] = +1;
            }

        /* 'T' constraint */
        } else if (sket->ctype[icon] == 'T') {
            im1 = ipnt - 1;   if (im1 <  0   ) im1 += npnt;
            ip1 = ipnt + 1;   if (ip1 >= npnt) ip1 -= npnt;

            /* both horizontal segments */
            if        (segtyp[im1] == 1 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1 +1] = -1;
                jac[icon*ncol+3*ipnt+1] = +2;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* both vertical segments */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1   ] = -1;
                jac[icon*ncol+3*ipnt  ] = +2;
                jac[icon*ncol+3*ip1   ] = -1;
            /* horizontal to 90hv */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 4) {
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            /* 90vh to hoirizontal */
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
            /* vertical to 90vh */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 5) {
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* 90hv to vertical */
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
            /* horizontal to 180hh */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 6) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            /* 180hh to horizontal */
            } else if (segtyp[im1] == 6 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* vertical to 180vv */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 7) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* 180vv to vertical */
            } else if (segtyp[im1] == 7 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            }

        /* 'P' constraint */
        } else if (sket->ctype[icon] == 'P') {
            im1 = ipnt - 1;   if (im1 <  0   ) im1 += npnt;
            ip1 = ipnt + 1;   if (ip1 >= npnt) ip1 -= npnt;

            /* horizontal and vertical segments */
            if        (segtyp[im1] == 1 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            /* vertical and horizontal segments */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* horizontal and 90vh segments */
            } else if (segtyp[im1] == 1 && segtyp[ipnt] == 5) {
                jac[icon*ncol+3*ipnt  ] = +1;
                jac[icon*ncol+3*ip1   ] = -1;
            /* 90vh and vertical segments */
            } else if (segtyp[im1] == 5 && segtyp[ipnt] == 2) {
                jac[icon*ncol+3*im1 +1] = +1;
                jac[icon*ncol+3*ipnt+1] = -1;
            /* vertical and 90hv segments */
            } else if (segtyp[im1] == 2 && segtyp[ipnt] == 4) {
                jac[icon*ncol+3*ipnt+1] = +1;
                jac[icon*ncol+3*ip1 +1] = -1;
            /* 90hv and horizontal segments */
            } else if (segtyp[im1] == 4 && segtyp[ipnt] == 1) {
                jac[icon*ncol+3*im1   ] = +1;
                jac[icon*ncol+3*ipnt  ] = -1;
            }

        /* 'R' constraint */
        } else if (sket->ctype[icon] == 'R') {

            /* 90 bend */
            if        (segtyp[ipnt] == 4 || segtyp[ipnt] == 5) {
                jac[icon*ncol+3*ipnt+2] = +1;

            /* 180 bend */
            } else if (segtyp[ipnt] == 6 || segtyp[ipnt] == 7) {
                jac[icon*ncol+3*ipnt+2] = +1;
            }

        }
    }

    /* add implicit constraints for all non-CIRARC Segments */
    nrow = sket->ncon;

    for (ipnt = 0; ipnt < npnt; ipnt++) {
        if (segtyp[ipnt] <= 3) {
            jac[nrow*ncol+3*ipnt+2] = +1;
            nrow++;
        }
    }

    SPRINT0x(2, "\n              ");
    for (ipnt = 0; ipnt < npnt; ipnt++) {
        SPRINT3x(2, "x%-2d y%-2d d%-2d ", ipnt+1, ipnt+1, ipnt+1);
    }
#ifndef __clang_analyzer__
    SPRINT0(2, " ");
    for (irow = 0; irow < nrow; irow++) {
        if (irow < sket->ncon) {
            SPRINT4x(2, "%3d %c %2d %2d: ", irow, sket->ctype[irow], sket->ipnt[irow], sket->ip1[irow]);
        } else {
            SPRINT1x(2, "%3d cirarc : ", irow);
        }
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            SPRINT3x(2, "%3d %3d %3d ", NINT(jac[irow*ncol+3*ipnt  ]),
                                        NINT(jac[irow*ncol+3*ipnt+1]),
                                        NINT(jac[irow*ncol+3*ipnt+2]));
        }
        SPRINT0(2, " ");
    }
#endif

    /* compute the rank */
    *jrank = rank(jac, nrow, ncol);
    SPRINT1(2, "*jrank=%d", *jrank);

cleanup:
    FREE(jac);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   freeBody - free memory associated with a Body (undo newBody)       *
 *                                                                      *
 ************************************************************************
 */

static int
freeBody(modl_T *MODL,                  /* (in)  pointer to MODL */
         int    ibody)                  /* (in)  Body index (1:nbody) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iarg;

    ROUTINE(freeBody);

    /* --------------------------------------------------------------- */

    /* free up arguments */
    for (iarg = 1; iarg < 10; iarg++) {
        FREE(MODL->body[ibody].arg[iarg].val);   /* also free's .str since they are unioned */
        FREE(MODL->body[ibody].arg[iarg].dot);
    }

    /* free up Node, Edge, and Face tables */
    FREE(MODL->body[ibody].node);
    FREE(MODL->body[ibody].edge);
    FREE(MODL->body[ibody].face);

    /* cleanup sensitivity cache (if it exists) */
    if (MODL->body[ibody].hassens != 0) {
        SPRINT1(2, "resetting .hassens for ibody=%d", ibody);

        status = EG_setGeometry_dot(MODL->body[ibody].ebody, 0, 0,  NULL, NULL, NULL);
        CHECK_STATUS(EG_setGeometry_dot);

        MODL->body[ibody].hassens = 0;
    }

    /* mark that the Body was freed */
    MODL->body[ibody].ibrch = 0;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   getBodyTolerance - get the largest tolerance associated with       *
 *                      ebody and its Edges/Faces                       *
 *                                                                      *
 ************************************************************************
 */

static int
getBodyTolerance(ego    ebody,          /* (in)  pointer to Body */
                 double *toler)         /* (out) largest tolerance */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nface, nedge, iface, iedge, oclass, mtype;
    double    tol;

    ego       *efaces, *eedges, eref, eprev, enext;

    ROUTINE(getBodyTolerance);

    /* --------------------------------------------------------------- */

    *toler = 0;

    /* if ebody is really a MODEL, return a tolerance of -1 */
    status = EG_getInfo(ebody, &oclass, &mtype, &eref, &eprev, &enext);
    CHECK_STATUS(EG_getInfo);

    if (oclass == MODEL) {
        *toler = -1;
        goto cleanup;
    }

    /* get tolerance associated with the Body */
    status = EG_getTolerance(ebody, &tol);
    CHECK_STATUS(EG_getTolerance);

    SPRINT1(3, "    body         toler=%11.4e", tol);

    *toler = MAX(*toler, tol);

    /* for each Face associated with ebody, get its tolerance */
    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (efaces != NULL) {
        for (iface = 0; iface < nface; iface++) {
            status = EG_getTolerance(efaces[iface], &tol);
            CHECK_STATUS(EG_getTolerance);

            SPRINT2(3, "    iface=%-5d  toler=%11.4e", iface+1, tol);

            *toler = MAX(*toler, tol);
        }

        EG_free(efaces);
    }

    /* for each Edge associated with ebody, get its tolerance */
    status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, &eedges);
    CHECK_STATUS(EG_getBodyTopos);

    if (eedges != NULL) {
        for (iedge = 0; iedge < nedge; iedge++) {
            status = EG_getTolerance(eedges[iedge], &tol);
            CHECK_STATUS(EG_getTolerance);

            SPRINT2(3, "    iedge=%-5d  toler=%11.4e", iedge+1, tol);

            *toler = MAX(*toler, tol);
        }

        EG_free(eedges);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   getEdgeHistory - get history of Bodys associated with an Edge      *
 *                                                                      *
 ************************************************************************
 */

static int
getEdgeHistory(modl_T *MODL,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (1:nbody) */
               int    iedge,            /* (in)  Edge index (1:nedge) */
               int    *nhist,           /* (out) length of hist[] */
               int    *hist[])          /* (out) Bodys (latest first) - freeable */
{
    int     status = SUCCESS;

    int     ileft, irite, attrType, nlistL, nlistR, i, j;
    CINT    *tempIlistL, *tempIlistR;
    CDOUBLE *tempRlist;
    CCHAR   *tempClist;

    ROUTINE(getEdgeHistory);

    /* --------------------------------------------------------------- */

    /* default returns */
    *nhist = 0;
    *hist  = NULL;

    /* find left and rite Faces */
    ileft = MODL->body[ibody].edge[iedge].ileft;
    irite = MODL->body[ibody].edge[iedge].irite;

    /* if neither ileft or irite exist, return the history associated with the
       WireBody */
    if (ileft <= 0 && irite <= 0) {
        status = EG_attributeRet(MODL->body[ibody].ebody, "_hist",
                                 &attrType, &nlistL, &tempIlistL, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        if (attrType != ATTRINT) {
            status= OCSM_INTERNAL_ERROR;
            signalError(MODL, status,
                        "_hist attribute is not an integer");
            goto cleanup;
        }

        MALLOC(*hist, int, nlistL);

        j = nlistL - 1;
        for (i = 0; i < nlistL; i++) {
            (*hist)[i] = tempIlistL[j--];
        }
        *nhist = nlistL;

    /* if only ileft exists, then Edge has same history as ileft */
    } else if (irite <= 0) {
        status = EG_attributeRet(MODL->body[ibody].face[ileft].eface, "_hist",
                                 &attrType, &nlistL, &tempIlistL, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        if (attrType != ATTRINT) {
            status= OCSM_INTERNAL_ERROR;
            signalError(MODL, status,
                        "_hist attribute is not an integer");
            goto cleanup;
        }

        MALLOC(*hist, int, nlistL);

        j = nlistL - 1;
        for (i = 0; i < nlistL; i++) {
            (*hist)[i] = tempIlistL[j--];
        }
        *nhist = nlistL;

    /* if only irite exists, then Edge has same history as irite */
    } else if (ileft <= 0) {
        status = EG_attributeRet(MODL->body[ibody].face[irite].eface, "_hist",
                                 &attrType, &nlistR, &tempIlistR, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        if (attrType != ATTRINT) {
            status= OCSM_INTERNAL_ERROR;
            signalError(MODL, status,
                        "_hist attribute is not an integer");
            goto cleanup;
        }

        MALLOC(*hist, int, nlistR);

        j = nlistR - 1;
        for (i = 0; i < nlistR; i++) {
            (*hist)[i] = tempIlistR[j--];
        }
        *nhist = nlistR;

    /* both ileft and irite exist */
    } else {
        status = EG_attributeRet(MODL->body[ibody].face[ileft].eface, "_hist",
                                 &attrType, &nlistL, &tempIlistL, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        if (attrType != ATTRINT) {
            status= OCSM_INTERNAL_ERROR;
            signalError(MODL, status,
                        "_hist attribute is not an integer");
            goto cleanup;
        }

        status = EG_attributeRet(MODL->body[ibody].face[irite].eface, "_hist",
                                 &attrType, &nlistR, &tempIlistR, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeRet);

        if (attrType != ATTRINT) {
            status= OCSM_INTERNAL_ERROR;
            signalError(MODL, status,
                        "_hist attribute is not an integer");
            goto cleanup;
        }

        /* make up a new history by walking back from the ends of the two lists
           until there is a difference */
        MALLOC(*hist, int, MAX(nlistL, nlistR));

        nlistL--;
        nlistR--;
        *nhist = 0;
        while (nlistL >= 0 && nlistR >= 0) {
            if (tempIlistL[nlistL] != tempIlistR[nlistR]) break;

            (*hist)[*nhist] = tempIlistL[nlistL];
            nlistL--;
            nlistR--;
            (*nhist)++;
        }
    }

    SPRINT2x(2, "history for ibody=%d, iedge=%d:", ibody, iedge);
    for (i = 0; i < *nhist; i++) {
        SPRINT1x(2, " %2d", (*hist)[i]);
    }
    SPRINT0(2, " ");

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   getToken - get a token from a string                               *
 *                                                                      *
 ************************************************************************
 */

static int
getToken(char   *text,                  /* (in)  full text */
         int    nskip,                  /* (in)  tokens to skip */
         char   sep,                    /* (in)  seperator character */
         int    maxtok,                 /* (in)  size of token */
         char   *token)                 /* (out) token */
{
    int    lentok, i, count, iskip;

    token[0] = '\0';
    lentok   = 0;

    /* convert tabs to spaces */
    for (i = 0; i < STRLEN(text); i++) {
        if (text[i] == '\t') {
            text[i] = ' ';
        }
    }

    /* count the number of separators */
    count = 0;
    for (i = 0; i < STRLEN(text); i++) {
        if (text[i] == sep) {
            count++;
        }
    }

    if (count < nskip+1) return 0;

    /* skip over nskip tokens */
    i = 0;
    for (iskip = 0; iskip < nskip; iskip++) {
        while (text[i] != sep) {
            i++;
        }
        i++;
    }

    /* extract the token we are looking for */
    while (text[i] != sep) {
        token[lentok++] = text[i++];
        token[lentok  ] = '\0';

        if (lentok >= maxtok-1) {
            signalError(NULL, OCSM_INTERNAL_ERROR,
                        "token exceeds maxtok=%d", maxtok);
            break;
        }
    }

    return STRLEN(token);
}


/*
 ************************************************************************
 *                                                                      *
 *   joinSheetBodys - join 2 SheetsBodys into a new Sheet or SolidBody  *
 *                                                                      *
 ************************************************************************
 */

static int
joinSheetBodys(modl_T *modl,            /* (in)  pointer to MODL */
               int    ibodyl,           /* (in)  index of left SheetBody */
               int    ibodyr,           /* (in)  index of rite SheetBody */
               int    itype,            /* (in)  1=join at Edges to produce SheetBody */
                                        /* (in)  2=join at Faces to produce SolidBody */
               double toler,            /* (in)  tolerance */
               ego    *ebody)           /* (out) resulting SheetBody */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       nmatch, *matches=NULL, nfacel, nfacer, i, j, k;
    int       oclass, mtype, nchild, *senses;
    double    data[18];
    ego       ebodyl, ebodyr, *efacelist=NULL, eref, emodel, *ebodys, *echilds;

    int       nnodel, nedgel, nnoder, nedger, nloop;
    int       inode, iedge, iface, jnode, jedge, jface;
    int       oclassf, mtypef, oclassl, mtypel, *sensesr, *sensesl;
    int       oclasss, mtypes, *nodbod=NULL;
    int       ibeg, iend, iloop, nedglup, iedglup, nskip, skipthis;
    double    tol, toll, tolr, datal[4], datar[4];
    double    bboxl[6], bboxr[6], dataf[4];
    ego       *enodesl=NULL, *eedgesl=NULL, *efacesl=NULL;
    ego       *enodesr=NULL, *eedgesr=NULL, *efacesr=NULL, *eloopsr;
    ego       *enodes=NULL, *eedges=NULL, *efaces=NULL, eshell;
    ego       ecurve, esurface, etemp[2];
    ego       *eloops=NULL, *eedglupr, *eedglup=NULL;

    ROUTINE(joinSheetBodys);

    /* --------------------------------------------------------------- */

    ebodyl = MODL->body[ibodyl].ebody;
    ebodyr = MODL->body[ibodyr].ebody;

    if (outLevel > 1) {
        SPRINT0(2, "in joinSheetBodys: ebodyl");
        ocsmPrintEgo(ebodyl);
        SPRINT0(2, "in joinSheetBodys: ebodyr");
        ocsmPrintEgo(ebodyr);
    }

    /* determine the pairs of matched Edges */
    if (itype == 1) {
        status = EG_matchBodyEdges(ebodyl, ebodyr, toler, &nmatch, &matches);
        if (matches != NULL) {
            EG_free(matches);
            matches = NULL;
        }
        CHECK_STATUS(EG_matchBodyEdges);

        if (nmatch < 1) {
            status = OCSM_EDGE_NOT_FOUND;
            signalError(MODL, status,
                        "common Edges not found (use UNION instead)");
            goto cleanup;
        }

        if (outLevel > 1) {
            SPLINT_CHECK_FOR_NULL(matches);

            for (i = 0; i < nmatch; i++) {
                SPRINT4(2, "Edges: matches[%2d]=%3d, matches[%2d]=%3d", 2*i, matches[2*i], 2*i+1, matches[2*i+1]);
            }
        }
    }

    /* determine the pairs of matched Faces */
    status = EG_matchBodyFaces(ebodyl, ebodyr, toler, &nmatch, &matches);
    CHECK_STATUS(EG_matchBodyFaces);

    /* remove from matches those Faces whose bounding box differ */
    for (i = nmatch-1; i >= 0; i--) {
        SPLINT_CHECK_FOR_NULL(matches);

        /* use largest of specified toler and tolerance in Faces */
        tol = toler;

        status = EG_getTolerance(MODL->body[ibodyl].face[matches[2*i  ]].eface, &toll);
        CHECK_STATUS(EG_getTolerance);

        if (toll > tol) tol = toll;

        status = EG_getTolerance(MODL->body[ibodyr].face[matches[2*i+1]].eface, &tolr);
        CHECK_STATUS(EG_getTolerance);

        if (tolr > tol) tol = tolr;

        status = EG_getBoundingBox(MODL->body[ibodyl].face[matches[2*i  ]].eface, bboxl);
        CHECK_STATUS(EG_getBoundingBox);

        status = EG_getBoundingBox(MODL->body[ibodyr].face[matches[2*i+1]].eface, bboxr);
        CHECK_STATUS(EG_getBoundingBox);

        if (fabs(bboxl[0]-bboxr[0]) > tol ||
            fabs(bboxl[1]-bboxr[1]) > tol ||
            fabs(bboxl[2]-bboxr[2]) > tol ||
            fabs(bboxl[3]-bboxr[3]) > tol ||
            fabs(bboxl[4]-bboxr[4]) > tol ||
            fabs(bboxl[5]-bboxr[5]) > tol   ) {
            matches[2*i  ] = matches[2*nmatch-2];
            matches[2*i+1] = matches[2*nmatch-1];
            nmatch--;
        }
    }

    if (itype == 2 && nmatch < 1) {
        status = OCSM_FACE_NOT_FOUND;
        signalError(MODL, status,
                    "common Faces not found (use UNION instead)");
        goto cleanup;
    }

    if (outLevel > 1) {
        SPLINT_CHECK_FOR_NULL(matches);

        for (i = 0; i < nmatch; i++) {
            SPRINT4(2, "Faces: matches[%2d]=%3d, matches[%2d]=%3d", 2*i, matches[2*i], 2*i+1, matches[2*i+1]);
        }
    }

    /* make a list of the Faces to sew */
    nfacel = MODL->body[ibodyl].nface;
    nfacer = MODL->body[ibodyr].nface;

    MALLOC(efacelist, ego, nfacel+nfacer);

    j = 0;
    for (i = 1; i <= nfacel; i++) {
        efacelist[j++] = MODL->body[ibodyl].face[i].eface;
        SPRINT3(3, "adding   Face %d (%llx) to   efacelist for Body %d", i, (long long)efacelist[j-1], ibodyl);

        for (k = 0; k < nmatch; k++) {
            SPLINT_CHECK_FOR_NULL(matches);

            if (itype == 2 && i == matches[2*k]) {
                SPRINT3(3, "removing Face %d (%llx) from efacelist for Body %d", i, (long long)efacelist[j-1], ibodyl);
                j--;
                break;
            }
        }
    }

    for (i = 1; i <= nfacer; i++) {
        efacelist[j++] = MODL->body[ibodyr].face[i].eface;
        SPRINT3(3, "adding   Face %d (%llx) to   efacelist for Body %d", i, (long long)efacelist[j-1], ibodyr);

        for (k = 0; k < nmatch; k++) {
            SPLINT_CHECK_FOR_NULL(matches);

            if (i == matches[2*k+1]) {
                SPRINT3(3, "removing Face %d (%llx) from efacelist for Body %d", i, (long long)efacelist[j-1], ibodyl);
                j--;
                break;
            }
        }
    }
    SPRINT1(3, "there are %d Faces in efacelist", j);

    if (j <= 0) {
        status = OCSM_FACE_NOT_FOUND;
        signalError(MODL, status,
                    "no Faces left after common Faces were removed");
        goto cleanup;
    } else if (itype == 1) {
        status = EG_sewFaces(j, efacelist, toler, 1, &emodel);
    } else {
        status = EG_sewFaces(j, efacelist, toler, 0, &emodel);
    }

    FREE(efacelist);

    if (status == SUCCESS) {

        /* if the Model contains a single SheetBody or SolidBody, extract it */
        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                data, &nchild, &ebodys, &senses);
        CHECK_STATUS(EG_getTopology);

        if (nchild == 1) {
            status = EG_getTopology(ebodys[0], &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (itype == 1 && oclass == BODY && mtype == SHEETBODY) {
                status = EG_copyObject(ebodys[0], NULL, ebody);
                CHECK_STATUS(EG_copyObject);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                if (outLevel > 1 && *ebody != NULL) {
                    SPRINT0(2, "in joinSheetBodys: ebody");
                    ocsmPrintEgo(*ebody);
                }

                goto cleanup;
            } else if (itype == 2 && oclass == BODY && mtype == SOLIDBODY) {
                status = EG_copyObject(ebodys[0], NULL, ebody);
                CHECK_STATUS(EG_copyObject);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                if (outLevel > 1 && *ebody != NULL) {
                    SPRINT0(2, "in joinSheetBodys: ebody");
                    ocsmPrintEgo(*ebody);
                }

                goto cleanup;
            }
        }

        status = EG_deleteObject(emodel);
        CHECK_STATUS(EG_deleteObject);
    }

    /* getting here means that EG_sewFace may have failed.  so, try
       joining the Faces by hand */
    SPRINT0(1, "WARNING:: EG_sewFaces seemed to fail, so trying to join using fallback procedure");
    (MODL->nwarn)++;

    /* increase toler to the larger of given value and tolerances of
       the input Bodys */
    status = EG_getTolerance(ebodyl, &toll);
    CHECK_STATUS(EG_getTolerance);

    status = EG_getTolerance(ebodyr, &tolr);
    CHECK_STATUS(EG_getTolerance);

    if (toll > toler) toler = toll;
    if (tolr > toler) toler = tolr;

    /* extract the Nodes, Edges, and Faces from ebodyl */
    status = EG_getBodyTopos(ebodyl, NULL, NODE, &nnodel, &enodesl);
    CHECK_STATUS(EG_getBodyTopos);
    SPLINT_CHECK_FOR_NULL(enodesl);

    status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedgel, &eedgesl);
    CHECK_STATUS(EG_getBodyTopos);
    SPLINT_CHECK_FOR_NULL(eedgesl);

    status = EG_getBodyTopos(ebodyl, NULL, FACE, &nfacel, &efacesl);
    CHECK_STATUS(EG_getBodyTopos);
    SPLINT_CHECK_FOR_NULL(efacesl);

    /* extract the Nodes, Edges, and Faces from ebodyr */
    status = EG_getBodyTopos(ebodyr, NULL, NODE, &nnoder, &enodesr);
    CHECK_STATUS(EG_getBodyTopos);
    SPLINT_CHECK_FOR_NULL(enodesr);

    status = EG_getBodyTopos(ebodyr, NULL, EDGE, &nedger, &eedgesr);
    CHECK_STATUS(EG_getBodyTopos);
    SPLINT_CHECK_FOR_NULL(eedgesr);

    status = EG_getBodyTopos(ebodyr, NULL, FACE, &nfacer, &efacesr);
    CHECK_STATUS(EG_getBodyTopos);
    SPLINT_CHECK_FOR_NULL(efacesr);

    /* make arrays to hold the Nodes, Edges, and Faces in the joined Body */
    MALLOC(enodes, ego, nnodel+nnoder);
    MALLOC(eedges, ego, nedgel+nedger);
    MALLOC(efaces, ego, nfacel+nfacer);
    MALLOC(nodbod, int, nnodel+nnoder);

    /* link the Nodes, Edges, and Faces in ebody to ebodyl */
    for (inode = 0; inode < nnodel; inode++) {
        enodes[inode] = enodesl[inode];
    }
    for (iedge = 0; iedge < nedgel; iedge++) {
        eedges[iedge] = eedgesl[iedge];
    }
    for (iface = 0; iface < nfacel; iface++) {
        efaces[iface] = efacesl[iface];
    }

    /* for Nodes in ebodyr, either use the Node in ebodyl
       (if on the joint) or ebodyr */
    for (inode = 0; inode < nnoder; inode++) {
        status = EG_getTopology(enodesr[inode], &eref, &oclass, &mtype,
                                datar, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        enodes[nnodel+inode] = NULL;
        for (jnode = 0; jnode < nnodel; jnode++) {
            status = EG_getTopology(enodesl[jnode], &eref, &oclass, &mtype,
                                    datal, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (fabs(datal[0]-datar[0]) < toler &&
                fabs(datal[1]-datar[1]) < toler &&
                fabs(datal[2]-datar[2]) < toler   ) {

                enodes[nnodel+inode] = enodesl[jnode];
                nodbod[nnodel+inode] = jnode;   /* in ebodyl */
                break;
            }
        }

        if (enodes[nnodel+inode] == NULL) {
            enodes[nnodel+inode] = enodesr[inode];
            nodbod[nnodel+inode] = -1;       /* in ebodyr */
        }
    }

    /* for Edges in ebodyr, either use the Edge in ebodyl
       (if on the joint) or ebodyr */
    for (iedge = 0; iedge < nedger; iedge++) {
        status = EG_getTopology(eedgesr[iedge], &ecurve, &oclass, &mtype,
                                datar, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        ibeg = EG_indexBodyTopo(ebodyr, echilds[0]) - 1;
        iend = EG_indexBodyTopo(ebodyr, echilds[1]) - 1;

        /* if both Nodes are in ebodyl, get the reference to the
           corresponding Edge in ebodyl */
        if (nodbod[nnodel+ibeg] >= 0 && nodbod[nnodel+iend] >= 0) {
            eedges[nedgel+iedge] = NULL;

            status = EG_getBoundingBox(eedgesr[iedge], bboxr);
            CHECK_STATUS(EG_getBoundingBox);

            for (jedge = 0; jedge < nedgel; jedge++) {
                status = EG_getBoundingBox(eedgesl[jedge], bboxl);
                CHECK_STATUS(EG_getBoundingBox);

                if (fabs(bboxl[0]-bboxr[0]) < toler &&
                    fabs(bboxl[1]-bboxr[1]) < toler &&
                    fabs(bboxl[2]-bboxr[2]) < toler &&
                    fabs(bboxl[3]-bboxr[3]) < toler &&
                    fabs(bboxl[4]-bboxr[4]) < toler &&
                    fabs(bboxl[5]-bboxr[5]) < toler   ) {
                    eedges[nedgel+iedge] = eedgesl[jedge];
                    break;
                }
            }

            if (eedges[nedgel+iedge] == NULL) {
                SPRINT0(0, "ERROR:: expecting to find corresponding Edge in ebodyl");
                status = OCSM_INTERNAL_ERROR;
                goto cleanup;
            }

        /* if both Nodes are in ebodyr, just reference the Edge */
        } else if (nodbod[nnodel+ibeg] == -1 && nodbod[nnodel+iend] == -1) {
            eedges[nedgel+iedge] = eedgesr[iedge];

        /* otherwise make a new Edge */
        } else {
            etemp[0] = enodes[nnodel+ibeg];
            etemp[1] = enodes[nnodel+iend];

            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                                     datar, 2, etemp, NULL, &(eedges[nedgel+iedge]));
            CHECK_STATUS(EG_makeTopology);
        }
    }

    /* for Faces in ebodyr, either use the Face in ebodyr
       (if away from the joint) or a new Faces (which is adjusted for a new Edge) */
    nskip = 0;
    for (iface = 0; iface < nfacer; iface++) {
        status = EG_getBoundingBox(efacesr[iface], bboxr);
        CHECK_STATUS(EG_getBoundingBox);

        skipthis = 0;
        for (jface = 0; jface < nfacel; jface++) {
            status = EG_getBoundingBox(efacesl[jface], bboxl);
            CHECK_STATUS(EG_getBoundingBox);

            if (fabs(bboxl[0]-bboxr[0]) < toler &&
                fabs(bboxl[1]-bboxr[1]) < toler &&
                fabs(bboxl[2]-bboxr[2]) < toler &&
                fabs(bboxl[3]-bboxr[3]) < toler &&
                fabs(bboxl[4]-bboxr[4]) < toler &&
                fabs(bboxl[5]-bboxr[5]) < toler   ) {
                skipthis = 1;
                nskip++;
                break;
            }
        }

        if (skipthis > 0) continue;

        status = EG_getTopology(efacesr[iface], &esurface, &oclassf, &mtypef,
                                dataf, &nloop, &eloopsr, &sensesr);
        CHECK_STATUS(EG_getTopology);

        status = EG_getGeometry(esurface, &oclasss, &mtypes, &eref, NULL, NULL);
        CHECK_STATUS(EG_getGeometry);

        MALLOC(eloops, ego, nloop);

        for (iloop = 0; iloop < nloop; iloop++) {
            status = EG_getTopology(eloopsr[iloop], &eref, &oclassl, &mtypel,
                                    datal, &nedglup, &eedglupr, &sensesl);
            CHECK_STATUS(EG_getTopology);

            MALLOC(eedglup, ego, 2*nedglup);

            for (iedglup = 0; iedglup < nedglup; iedglup++) {
                jedge = EG_indexBodyTopo(ebodyr, eedglupr[iedglup]) - 1;
                eedglup[iedglup] = eedges[nedgel+jedge];
            }

            if (mtypes != PLANE) {
                for (iedglup = 0; iedglup < nedglup; iedglup++) {
                    eedglup[nedglup+iedglup] = eedglupr[nedglup+iedglup];
                }
            }

            status = EG_makeTopology(MODL->context, eref, LOOP, CLOSED,
                                     NULL, nedglup, eedglup, sensesl, &eloops[iloop]);
            CHECK_STATUS(EG_makeTopology);

            FREE(eedglup);
        }

        status = EG_makeTopology(MODL->context, esurface, FACE, mtypef,
                                 dataf, nloop, eloops, sensesr, &(efaces[nfacel+iface-nskip]));
        CHECK_STATUS(EG_makeTopology);

        status = EG_attributeDup(efacesr[iface], efaces[nfacel+iface-nskip]);
        CHECK_STATUS(EG_attributeDup);

        FREE(eloops);
    }

    /* create a Shell from all the Faces */
    status = EG_makeTopology(MODL->context, NULL, SHELL, CLOSED, NULL,
                             nfacel+nfacer-nskip, efaces, NULL, &eshell);
    if (status < SUCCESS && outLevel < 0) goto cleanup;      /* does not print message */
    CHECK_STATUS(EG_makeTopology);

    /* create either a SheetBody or a SolidBody*/
    if (itype == 1) {
        status = EG_makeTopology(MODL->context, NULL, BODY, SHEETBODY, NULL,
                                 1, &eshell, NULL, ebody);
        CHECK_STATUS(EG_makeTopology);
    } else {
        status = EG_makeTopology(MODL->context, NULL, BODY, SOLIDBODY, NULL,
                                 1, &eshell, NULL, ebody);
        CHECK_STATUS(EG_makeTopology);
    }

    /* cleanup now that Body was made */
    status = EG_deleteObject(eshell);
    CHECK_STATUS(EG_deleteObject);

    for (iface = 0; iface < nfacer-nskip; iface++) {
        status = EG_deleteObject(efaces[nfacel+iface]);
        CHECK_STATUS(EG_deleteObject);
    }

    if (outLevel > 1 && *ebody != NULL) {
        SPRINT0(2, "in joinSheetBodys: ebody");
        ocsmPrintEgo(*ebody);
    }

cleanup:
    if (matches != NULL) {
        EG_free(matches);
    }
    FREE(efacelist);

    EG_free(enodesl);
    EG_free(eedgesl);
    EG_free(efacesl);
    EG_free(enodesr);
    EG_free(eedgesr);
    EG_free(efacesr);

    FREE(enodes);
    FREE(eedges);
    FREE(efaces);
    FREE(eloops);
    FREE(nodbod);
    FREE(eedglup);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   joinWireBodys - join 2 WireBodys into a new WireBody               *
 *                                                                      *
 ************************************************************************
 */

static int
joinWireBodys(modl_T *modl,             /* (in)  pointer to MODL */
              int    ibodyl,            /* (in)  index of left WireBody */
              int    ibodyr,            /* (in)  index of rite WireBody */
              double toler,             /* (in)  tolerance */
              ego    *ebody)            /* (out) resulting WireBody */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       oclass, mtype, nchild, *sensesl, *sensesr;
    int       i, nedgel, nedger, nedges;
    double    data[4];
    ego       ebodyl, ebodyr, eref, *echilds, *eedgesl, *eedgesr, *eedges=NULL, eloop;

    ROUTINE(joinWireBodys);

    /* --------------------------------------------------------------- */

    ebodyl = MODL->body[ibodyl].ebody;
    ebodyr = MODL->body[ibodyr].ebody;

    if (outLevel > 1) {
        SPRINT0(2, "in joinWireBodys: ebodyl");
        ocsmPrintEgo(ebodyl);
        SPRINT0(2, "in joinWireBodys: ebodyr");
        ocsmPrintEgo(ebodyr);
    }

    /* extract the Edges from ebodyl */
    status = EG_getTopology(ebodyl, &eref, &oclass, &mtype,
                            data, &nchild, &echilds, &sensesl);
    CHECK_STATUS(EG_getTopology);

    status = EG_getTopology(echilds[0], &eref, &oclass, &mtype,
                            data, &nedgel, &eedgesl, &sensesl);
    CHECK_STATUS(EG_getTopology);

    /* extract the Edges from ebodyr */
    status = EG_getTopology(ebodyr, &eref, &oclass, &mtype,
                            data, &nchild, &echilds, &sensesr);
    CHECK_STATUS(EG_getTopology);

    status = EG_getTopology(echilds[0], &eref, &oclass, &mtype,
                            data, &nedger, &eedgesr, &sensesr);
    CHECK_STATUS(EG_getTopology);

    /* try to make a single loop from the Edges */
    nedges = nedgel + nedger;
    MALLOC(eedges, ego, nedges);

    nedges = 0;
    for (i = 0; i < nedgel; i++) {
        eedges[nedges++] = eedgesl[i];
    }

    for (i = 0; i < nedger; i++) {
        eedges[nedges++] = eedgesr[i];
    }

    status = EG_makeLoop(nedges, eedges, NULL, toler, &eloop);

    /* getting status < 0 means that an error was encountered and
       status > 0 means that not all Edges could be joined */
    if (status != 0) {
        status = OCSM_DID_NOT_CREATE_BODY;
        *ebody = NULL;
        goto cleanup;
    }

    status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,
                             NULL, 1, &eloop, NULL, ebody);
    CHECK_STATUS(EG_makeTopology);

    /* cleanup now that WireBody was made */
    status = EG_deleteObject(eloop);
    CHECK_STATUS(EG_deleteObject);

    if (outLevel > 1 && *ebody != NULL) {
        SPRINT0(2, "in joinWireBodys: ebody");
        ocsmPrintEgo(*ebody);
    }

cleanup:
    FREE(eedges);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   makeEdge - make an Edge between eNodes                             *
 *                                                                      *
 ************************************************************************
 */

static int
makeEdge(modl_T *modl,                  /* (in)  pointer to MODL */
         ego    ebeg,                   /* (in)  enode at beginning */
         ego    eend,                   /* (in)  enode at end */
         ego    *eedge)                 /* (out) created Edge */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       oclass, mtype, nchild, *senses;
    double    data[4], xyz_beg[4], xyz_end[4], xyz_line[6], tdata[2], result[3];
    ego       eobj, etopref, eprev, enext, eref, ecurve, *echilds, enodes[2];

    ROUTINE(makeEdge);

    /* --------------------------------------------------------------- */

    /* check to see if there is an Edge already connecting ebeg and eend */
    eobj = MODL->context;
    while (eobj != NULL) {
        status = EG_getInfo(eobj, &oclass, &mtype, &etopref, &eprev, &enext);
        CHECK_STATUS(EG_getInfo);

        if (etopref == MODL->context && oclass == EDGE && mtype == TWONODE) {
            status = EG_getTopology(eobj, &eref, &oclass, &mtype, data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            if (echilds[0] == ebeg && echilds[1] == eend) {
                *eedge = eobj;
                goto cleanup;
            }
        }

        eobj = enext;
    }

    /* if the two Nodes are the same, we will make a degenerate Edge */
    if (ebeg == eend) {
        tdata[0] = 0;
        tdata[1] = 1;

        status = EG_makeTopology(MODL->context, NULL, EDGE, DEGENERATE, tdata, 1, &ebeg, NULL, eedge);
        CHECK_STATUS(EG_makeTopology);

        goto cleanup;
    }

    /* get the coordinates of the two Nodes */
    status = EG_getTopology(ebeg, &eref, &oclass, &mtype,
                            xyz_beg, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    status = EG_getTopology(eend, &eref, &oclass, &mtype,
                            xyz_end, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    /* create a line between the Nodes */
    xyz_line[0] = xyz_beg[0];
    xyz_line[1] = xyz_beg[1];
    xyz_line[2] = xyz_beg[2];
    xyz_line[3] = xyz_end[0] - xyz_beg[0];
    xyz_line[4] = xyz_end[1] - xyz_beg[1];
    xyz_line[5] = xyz_end[2] - xyz_beg[2];

    status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, xyz_line, &ecurve);
    CHECK_STATUS(EG_makeGeometry);

    /* find the parametric coordinates of the endpoints */
    status = EG_invEvaluate(ecurve, xyz_beg, &(tdata[0]), result);
    CHECK_STATUS(EG_invEvaluate);

    status = EG_invEvaluate(ecurve, xyz_end, &(tdata[1]), result);
    CHECK_STATUS(EG_invEvaluate);

    /* make the Edge */
    enodes[0] = ebeg;
    enodes[1] = eend;

    status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,
                             tdata, 2, enodes, NULL, eedge);
    CHECK_STATUS(EG_makeTopology);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   makeFace - make a Face from an array of Edges                      *
 *                                                                      *
 ************************************************************************
 */

static int
makeFace(modl_T *modl,                  /* (in)  pointer to MODL */
         ego    eedges_in[],            /* (in)  array of 4 Edges */
         int    fillstyle,              /* (in)  fillstyle argument to EG_isoCline */
         int    dirn,                   /* (in)  direction for first Edge */
         double toler,                  /* (in)  tolerance in EG_otherCurve */
         ego    *eface)                 /* (out) created Face */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       iedge, jedge, nedge, senses[4], *senses2, oclass, mtype, nchild, periodic;
    double    data[4], range[4];
    ego       eedges[8], eloop, eref, *echilds, esurface, ebeg, eend;

    ROUTINE(makeFace);

    /* --------------------------------------------------------------- */

    if (eedges_in[3] == NULL) {
        nedge = 3;
    } else {
        nedge = 4;
    }

    /* create a Loop from the Edges */
    status = EG_getTopology(eedges_in[0], &eref, &oclass, &mtype, data,
                            &nchild, &echilds, &senses2);
    CHECK_STATUS(EG_getTopology);

    eedges[0] = eedges_in[0];

    if (dirn >= 0) {
        senses[0] = SFORWARD;
        ebeg      = echilds[0];
        eend      = echilds[1];
    } else {
        senses[0] = SREVERSE;
        ebeg      = echilds[1];
        eend      = echilds[0];
    }

    for (iedge = 1; iedge < nedge; iedge++) {
        for (jedge = 1; jedge < 4; jedge++) {
            if (eedges_in[jedge] == NULL) continue;

            status = EG_getTopology(eedges_in[jedge], &eref, &oclass, &mtype, data,
                                &nchild, &echilds, &senses2);
            CHECK_STATUS(EG_getTopology);

            if        (echilds[0] == eend) {
                eedges[iedge]    = eedges_in[jedge];
                senses[iedge]    = SFORWARD;
                eend             = echilds[1];
                eedges_in[jedge] = NULL;
                break;
            } else if (echilds[1] == eend) {
                eedges[iedge]    = eedges_in[jedge];
                senses[iedge]    = SREVERSE;
                eend             = echilds[0];
                eedges_in[jedge] = NULL;
                break;
            }
        }
    }

    if (eend != ebeg) {
        SPRINT0(0, "ERROR:: Loop is expected to be CLOSED but is OPEN");
        status = OCSM_INTERNAL_ERROR;
        goto cleanup;
    }

    status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED,
                             NULL, nedge, eedges, senses, &eloop);
    CHECK_STATUS(EG_makeTopology);

    /* create a Surface from the Loop (using the overloaded EG_isoCline) */
    status = EG_isoCline(eloop, fillstyle, 0.0, &esurface);
    CHECK_STATUS(EG_isoCline);

    status = EG_deleteObject(eloop);
    CHECK_STATUS(EG_deleteObject);

    /* find the PCurves associated with the Edges */
    for (iedge = 0; iedge < nedge; iedge++) {
        status = EG_otherCurve(esurface, eedges[iedge], toler, &(eedges[iedge+4]));
        CHECK_STATUS(EG_otherCurve);
    }

    /* if there are only three Edges, create a degenerate Edge at umin */
    if (nedge == 3) {
        status = EG_getRange(esurface, range, &periodic);
        CHECK_STATUS(EG_getRange);

        data[0] = range[2];
        data[1] = range[3];

        status = EG_makeTopology(MODL->context, NULL, EDGE, DEGENERATE,
                                 data, 1, &eend, NULL, &(eedges[3]));
        CHECK_STATUS(EG_makeTopology);

        data[0] = range[0];
        data[1] = range[2];
        data[2] = 0;
        data[3] = 1;

        status = EG_makeGeometry(MODL->context, PCURVE, LINE, NULL, NULL, data, &(eedges[7]));
        CHECK_STATUS(EG_makeGeometry);

        senses[3] = SREVERSE;
        nedge = 4;
    }

    /* make a new Loop and a Face using this Surface */
    status = EG_makeTopology(MODL->context, esurface, LOOP, CLOSED,
                             NULL, nedge, eedges, senses, &eloop);
    CHECK_STATUS(EG_makeTopology);

    senses[0] = SFORWARD;
    status = EG_makeTopology(MODL->context, esurface, FACE, SFORWARD,
                             NULL, 1, &eloop, senses, eface);
    CHECK_STATUS(EG_makeTopology);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   matches - check if two strings match (with * + ? wildcards)        *
 *                                                                      *
 ************************************************************************
 */

static int
matches(char pattern[],                /* (in)  pattern */
  const char string[])                 /* (in)  string to check */
{

    /* --------------------------------------------------------------- */

    /* matching rules:
       ? matches any one character
       + matches one or more characters
       * matches zero or more characters

       use an adaptation of the recursive code found at:
       http://codegolf.stackexchange.com/questions/467/implement-glob-matcher
    */

    if        (*pattern == '*') {
        return (matches(pattern+1, string) != '\0') || ((*string != '\0') && (matches(pattern, string+1) != 0));

    } else if (*pattern == '+') {
        return (*string != '\0') && ((matches(pattern+1, ++string) != 0) || (matches(pattern, string) != 0));

    } else if (*pattern == '?') {
        return (*string != '\0') && (matches(pattern+1, string+1) != 0);

    } else {
        return (*string == *pattern++) && ((*string++ == '\0') || (matches(pattern, string) != 0));

    }
}


/*
 ************************************************************************
 *                                                                      *
 *   matchLoop - possibly modify eloops[1] to closely match eloops[0]   *
 *                                                                      *
 ************************************************************************
 */

static int
matchLoop(ego     eloops[])             /* (in)  array of two Loop */
                                        /* (out) possibly modified eloops[1] */
{
    int       status = SUCCESS;         /* (out) return status */

    int       oclass, mtype, nchild, *senses2;
    int       mtype0, nedge0, *senses0;
    int       mtype1, nedge1, *senses1;
    int       iedge, jedge, ireorder, ibest;
    int       *senses=NULL;
    double    trange[4], data[18], tt;
    double    dx0a, dy0a, dz0a, dx0b, dy0b, dz0b, dx1a, dy1a, dz1a, dx1b, dy1b, dz1b;
    double    temp1, temp2, dotprod, dbest;
    double    *xyz0=NULL, *xyz1=NULL;
    ego       context, eref, *eedges0, *eedges1, *echilds, etemp;
    ego       *eedges=NULL;

    ROUTINE(matchLoop);

    /* --------------------------------------------------------------- */

    /* get the info associated with eloops[0] and eloops[1] */
    status = EG_getTopology(eloops[0], &eref, &oclass, &mtype0, data,
                            &nedge0, &eedges0, &senses0);
    CHECK_STATUS(EG_getTopology);

    status = EG_getTopology(eloops[1], &eref, &oclass, &mtype1, data,
                            &nedge1, &eedges1, &senses1);
    CHECK_STATUS(EG_getTopology);

    if (nedge0 != nedge1) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    } else if (mtype0 != mtype1) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* build an array of the coordinates at the Nodes associated with
       the Loops */
    MALLOC(xyz0, double, 6*(nedge0+1));
    MALLOC(xyz1, double, 6*(nedge1+1));

    /* beginning of each Edge */
    for (iedge = 0; iedge < nedge0; iedge++) {
        /* loop0 */
        status = EG_getTopology(eedges0[iedge], &eref, &oclass, &mtype, trange,
                                &nchild, &echilds, &senses2);
        CHECK_STATUS(EG_getTopology);

        if (senses0[iedge] == SFORWARD) {
            tt = trange[0];
        } else {
            tt = trange[1];
        }

        status = EG_evaluate(eedges0[iedge], &tt, data);
        CHECK_STATUS(EG_evaluate);

        xyz0[6*iedge  ] = data[0];
        xyz0[6*iedge+1] = data[1];
        xyz0[6*iedge+2] = data[2];

        tt = (trange[0] + trange[1]) / 2;

        status = EG_evaluate(eedges0[iedge], &tt, data);
        CHECK_STATUS(EG_evaluate);

        xyz0[6*iedge+3] = data[0];
        xyz0[6*iedge+4] = data[1];
        xyz0[6*iedge+5] = data[2];

        /* loop1 */
        status = EG_getTopology(eedges1[iedge], &eref, &oclass, &mtype, trange,
                                &nchild, &echilds, &senses2);
        CHECK_STATUS(EG_getTopology);

        if (senses1[iedge] == SFORWARD) {
            tt = trange[0];
        } else {
            tt = trange[1];
        }

        status = EG_evaluate(eedges1[iedge], &tt, data);
        CHECK_STATUS(EG_evaluate);

        xyz1[6*iedge  ] = data[0];
        xyz1[6*iedge+1] = data[1];
        xyz1[6*iedge+2] = data[2];

        tt = (trange[0] + trange[1]) / 2;

        status = EG_evaluate(eedges1[iedge], &tt, data);
        CHECK_STATUS(EG_evaluate);

        xyz1[6*iedge+3] = data[0];
        xyz1[6*iedge+4] = data[1];
        xyz1[6*iedge+5] = data[2];
    }

    /* first Node (if closed) or last Node (if open) */
    if (mtype0 == CLOSED) {
        xyz0[6*nedge0  ] = xyz0[0];
        xyz0[6*nedge0+1] = xyz0[1];
        xyz0[6*nedge0+2] = xyz0[2];

        xyz1[6*nedge1  ] = xyz1[0];
        xyz1[6*nedge1+1] = xyz1[1];
        xyz1[6*nedge1+2] = xyz1[2];
    } else {
        status = EG_getTopology(eedges0[nedge0-1], &eref, &oclass, &mtype, trange,
                                &nchild, &echilds, &senses2);
        CHECK_STATUS(EG_getTopology);

        if (senses0[nedge0-1] == SFORWARD) {
            tt = trange[0];
        } else {
            tt = trange[1];
        }

        status = EG_evaluate(eedges0[nedge0-1], &tt, data);
        CHECK_STATUS(EG_evaluate);

        xyz0[6*nedge0  ] = data[0];
        xyz0[6*nedge0+1] = data[1];
        xyz0[6*nedge0+2] = data[2];

        status = EG_getTopology(eedges1[nedge1-1], &eref, &oclass, &mtype, trange,
                                &nchild, &echilds, &senses2);
        CHECK_STATUS(EG_getTopology);

        if (senses0[nedge1-1] == SFORWARD) {
            tt = trange[0];
        } else {
            tt = trange[1];
        }

        status = EG_evaluate(eedges1[nedge1-1], &tt, data);
        CHECK_STATUS(EG_evaluate);

        xyz1[6*nedge1  ] = data[0];
        xyz1[6*nedge1+1] = data[1];
        xyz1[6*nedge1+2] = data[2];
    }

    /* for each reordering, count the number of Edges which are in
       the "same" direction */
    ibest = 0;
    dbest = 0;

    /* simple rotations */
    for (ireorder = 0; ireorder < nedge0; ireorder++) {
        dotprod = 0;

        for (iedge = 0; iedge < nedge0; iedge++) {
            jedge = (iedge + ireorder) % nedge0;

            dx0a = xyz0[6*iedge+3] - xyz0[6*iedge  ];
            dy0a = xyz0[6*iedge+4] - xyz0[6*iedge+1];
            dz0a = xyz0[6*iedge+5] - xyz0[6*iedge+2];
            dx0b = xyz0[6*iedge+6] - xyz0[6*iedge+3];
            dy0b = xyz0[6*iedge+7] - xyz0[6*iedge+4];
            dz0b = xyz0[6*iedge+8] - xyz0[6*iedge+5];
            dx1a = xyz1[6*jedge+3] - xyz1[6*jedge  ];
            dy1a = xyz1[6*jedge+4] - xyz1[6*jedge+1];
            dz1a = xyz1[6*jedge+5] - xyz1[6*jedge+2];
            dx1b = xyz1[6*jedge+6] - xyz1[6*jedge+3];
            dy1b = xyz1[6*jedge+7] - xyz1[6*jedge+4];
            dz1b = xyz1[6*jedge+8] - xyz1[6*jedge+5];

            temp1  =     (dx0a * dx1a + dy0a * dy1a + dz0a * dz1a);
            temp1 /= sqrt(dx0a * dx0a + dy0a * dy0a + dz0a * dz0a);
            temp1 /= sqrt(dx1a * dx1a + dy1a * dy1a + dz1a * dz1a);
            temp2  =     (dx0b * dx1b + dy0b * dy1b + dz0b * dz1b);
            temp2 /= sqrt(dx0b * dx0b + dy0b * dy0b + dz0b * dz0b);
            temp2 /= sqrt(dx1b * dx1b + dy1b * dy1b + dz1b * dz1b);
            dotprod += temp1 + temp2;
        }

        if (dotprod > dbest) {
            ibest = +ireorder;
            dbest =  dotprod;
        }
    }

    /* flip and rotations */
    for (ireorder = 1; ireorder <= nedge0; ireorder++) {
        dotprod = 0;

        for (iedge = 0; iedge < nedge0; iedge++) {
            jedge = (2 * nedge0 - iedge - ireorder) % nedge0;

            dx0a = xyz0[6*iedge+3] - xyz0[6*iedge  ];
            dy0a = xyz0[6*iedge+4] - xyz0[6*iedge+1];
            dz0a = xyz0[6*iedge+5] - xyz0[6*iedge+2];
            dx0b = xyz0[6*iedge+6] - xyz0[6*iedge+3];
            dy0b = xyz0[6*iedge+7] - xyz0[6*iedge+4];
            dz0b = xyz0[6*iedge+8] - xyz0[6*iedge+5];
            dx1a = xyz1[6*jedge+3] - xyz1[6*jedge  ];
            dy1a = xyz1[6*jedge+4] - xyz1[6*jedge+1];
            dz1a = xyz1[6*jedge+5] - xyz1[6*jedge+2];
            dx1b = xyz1[6*jedge+6] - xyz1[6*jedge+3];
            dy1b = xyz1[6*jedge+7] - xyz1[6*jedge+4];
            dz1b = xyz1[6*jedge+8] - xyz1[6*jedge+5];

            temp1  =     (dx0a * dx1b + dy0a * dy1b + dz0a * dz1b);
            temp1 /= sqrt(dx0a * dx0a + dy0a * dy0a + dz0a * dz0a);
            temp1 /= sqrt(dx1b * dx1b + dy1b * dy1b + dz1b * dz1b);
            temp2  =     (dx0b * dx1a + dy0b * dy1a + dz0b * dz1a);
            temp2 /= sqrt(dx0b * dx0b + dy0b * dy0b + dz0b * dz0b);
            temp2 /= sqrt(dx1a * dx1a + dy1a * dy1a + dz1a * dz1a);
            dotprod -= temp1 + temp2;
        }

        if (dotprod > dbest) {
            ibest = -ireorder;
            dbest =  dotprod;
        }
    }

    /* if the best was a simple rotation, make a new Loop */
    if (ibest > 0) {
        MALLOC(eedges, ego, nedge1);
        MALLOC(senses, int, nedge1);

        for (iedge = 0; iedge < nedge1; iedge++) {
            jedge = (iedge + ibest) % nedge1;

            eedges[iedge] =  eedges1[jedge];
            senses[iedge] = +senses1[jedge];
        }

        status = EG_getContext(eloops[1], &context);
        CHECK_STATUS(EG_getContext);

        status = EG_makeTopology(context, NULL, LOOP, mtype0, NULL,
                                 nedge1, eedges, senses, &etemp);
        CHECK_STATUS(EG_makeTopology);

        status = EG_deleteObject(eloops[1]);
        CHECK_STATUS(EG_deleteObject);

        eloops[1] = etemp;

    /* if the best was a flip and rotation, make the new Loop */
    } else if (ibest < 0) {
        MALLOC(eedges, ego, nedge1);
        MALLOC(senses, int, nedge1);

        for (iedge = 0; iedge < nedge1; iedge++) {
            jedge = (2 * nedge1 - iedge + ibest) % nedge1;

            eedges[iedge] =  eedges1[jedge];
            senses[iedge] = -senses1[jedge];
        }

        status = EG_getContext(eloops[1], &context);
        CHECK_STATUS(EG_getContext);

        status = EG_makeTopology(context, NULL, LOOP, mtype0, NULL,
                                 nedge1, eedges, senses, &etemp);
        CHECK_STATUS(EG_makeTopology);

        status = EG_deleteObject(eloops[1]);
        CHECK_STATUS(EG_deleteObject);

        eloops[1] = etemp;
    }

cleanup:
    FREE(xyz0);
    FREE(xyz1);
    FREE(eedges);
    FREE(senses);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   matchValue - check if attribute value matches an argument          *
 *                                                                      *
 ************************************************************************
 */

static int
matchValue(varg_T  arg,                /* (in)  argument */
           int     itype,              /* (in)  attribute type */
           int     nlist,              /* (in)  attribute length */
           CINT    *tempIlist,         /* (in)  attribute integer values */
           CDOUBLE *tempRlist,         /* (in)  attribute real    values */
           CCHAR   *tempClist)         /* (in)  attribute string  value */
{
    int match = 0;                     /* (out) =1 if matches */

    int i;

    /* --------------------------------------------------------------- */

    if (strcmp(arg.str, "*") == 0) {
        match = 1;

    } else if (itype == ATTRSTRING) {
        if (matches((char*)arg.str, tempClist) == 1) {
            match = 1;
        }

    } else if (itype == ATTRINT && nlist == arg.nval) {
        for (i = 0; i < nlist; i++) {
            if (NINT(arg.val[i]) == tempIlist[i]) match++;
        }
        if (match == nlist) {
            match = 1;
        } else {
            match = 0;
        }

    } else if (itype == ATTRREAL && nlist == arg.nval) {
        for (i = 0; i < nlist; i++) {
            if (fabs(arg.val[i]-tempRlist[i]) < EPS06) match++;
        }
        if (match == nlist) {
            match = 1;
        } else {
            match = 0;
        }

    } else if (itype != ATTRCSYS) {
        if (matches((char*)arg.str, "*") == 1) {
            match = 1;
        }
    }

    return match;
}


/*
 ************************************************************************
 *                                                                      *
 *   matsol - Gaussian elimination with partial pivoting                *
 *                                                                      *
 ************************************************************************
 */

static int
matsol(double    A[],                   /* (in)  matrix to be solved (stored rowwise) */
                                        /* (out) upper-triangular form of matrix */
       double    b[],                   /* (in)  right hand side */
                                        /* (out) right-hand side after swapping */
       int       n,                     /* (in)  size of matrix */
       double    x[])                   /* (out) solution of A*x=b */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ir, jc, kc, imax;
    double    amax, swap, fact;

    ROUTINE(matsol);

    /* --------------------------------------------------------------- */

    /* reduce each column of A */
    for (kc = 0; kc < n; kc++) {

        /* find pivot element */
        imax = kc;
        amax = fabs(A[kc*n+kc]);

        for (ir = kc+1; ir < n; ir++) {
            if (fabs(A[ir*n+kc]) > amax) {
                imax = ir;
                amax = fabs(A[ir*n+kc]);
            }
        }

        /* check for possibly-singular matrix (ie, near-zero pivot) */
        if (amax < EPS12) {
            status = OCSM_SINGULAR_MATRIX;
            goto cleanup;
        }

        /* if diagonal is not pivot, swap rows in A and b */
        if (imax != kc) {
            for (jc = 0; jc < n; jc++) {
                swap         = A[kc  *n+jc];
                A[kc  *n+jc] = A[imax*n+jc];
                A[imax*n+jc] = swap;
            }

            swap    = b[kc  ];
            b[kc  ] = b[imax];
            b[imax] = swap;
        }

        /* row-reduce part of matrix to the bottom of and right of [kc,kc] */
        for (ir = kc+1; ir < n; ir++) {
            fact = A[ir*n+kc] / A[kc*n+kc];

            for (jc = kc+1; jc < n; jc++) {
                A[ir*n+jc] -= fact * A[kc*n+jc];
            }

            b[ir] -= fact * b[kc];

            A[ir*n+kc] = 0;
        }
    }

    /* back-substitution pass */
    x[n-1] = b[n-1] / A[(n-1)*n+(n-1)];

    for (jc = n-2; jc >= 0; jc--) {
        x[jc] = b[jc];
        for (kc = jc+1; kc < n; kc++) {
            x[jc] -= A[jc*n+kc] * x[kc];
        }
        x[jc] /= A[jc*n+jc];
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   mvcInterp - interpolate using mean-value coordinates               *
 *                                                                      *
 ************************************************************************
 */

static int
mvcInterp(int        nloop,             /* (in)  number of loops */
          CINT       nlast1[],          /* (in)  last point (plus 1) in each loop */
          CDOUBLE    uvframe[],         /* (in)  coordinates of points in loop(s) */
          CDOUBLE    uv[],              /* (in)  point at which weights should be computed */
          double     weights[])         /* (out) weights associated with each frame point */
{
    int       status = SUCCESS;         /* (out) return status */

    int       i, j, im1, ip1, ibeg, ntotal, k, numneg;
    double    umin, umax, vmin, vmax, du, dv, dl, mu, eps, wi, wsum=0;
    double    du1, dv1, du2, dv2, du3, dv3, den, s, t;
    double    *duv=NULL, *A=NULL, *D=NULL, *R=NULL;

    ROUTINE(mvcInterp);

    /* --------------------------------------------------------------- */

    /* default return */
    ntotal = nlast1[nloop-1];

    for (i = 0; i < ntotal; i++) {
        weights[i] = 0;
    }

    /* get temporary storage */
    MALLOC(duv, double, 2*ntotal);
    MALLOC(A,   double,   ntotal);
    MALLOC(D,   double,   ntotal);
    MALLOC(R,   double,   ntotal);

    /* find the extrema of u and v and an overall tolerance */
    umin = uvframe[0];
    umax = uvframe[0];
    vmin = uvframe[1];
    vmax = uvframe[1];

    for (i = 0; i < ntotal; i++) {
        if (uvframe[2*i  ] < umin) umin = uvframe[2*i  ];
        if (uvframe[2*i  ] > umax) umax = uvframe[2*i  ];
        if (uvframe[2*i+1] < vmin) vmin = uvframe[2*i+1];
        if (uvframe[2*i+1] > vmax) vmax = uvframe[2*i+1];
    }

    eps = EPS12 * sqrt((umax-umin) * (umax-umin) + (vmax-vmin) * (vmax-vmin));

    /* compute A, D, and R for each segment of the frame */
    ibeg = 0;
    for (j = 0; j < nloop; j++) {
        for (i = ibeg; i < nlast1[j]; i++) {
            ip1 = i + 1;
            if (ip1 == nlast1[j]) ip1 = ibeg;

            duv[2*i    ] = uvframe[2*i    ] - uv[0];
            duv[2*i  +1] = uvframe[2*i  +1] - uv[1];
            duv[2*ip1  ] = uvframe[2*ip1  ] - uv[0];
            duv[2*ip1+1] = uvframe[2*ip1+1] - uv[1];

            A[i] =     (duv[2*i    ]*duv[2*ip1+1] - duv[2*ip1  ]*duv[2*i+1]) / 2.0;
            D[i] =      duv[2*ip1  ]*duv[2*i    ] + duv[2*ip1+1]*duv[2*i+1];
            R[i] = sqrt(duv[2*i    ]*duv[2*i    ] + duv[2*i  +1]*duv[2*i+1]);

            /* if any frame point is very close to uv, return weights=1
               for that point */
            if (R[i] <= eps) {
                weights[i] = 1.0;
                goto cleanup;
            }
        }
        ibeg = nlast1[j];
    }

    /* handle the special case when uv lies on one of the segments of
       the frame */
    ibeg = 0;
    for (j = 0; j < nloop; j++) {
        for (i = ibeg; i < nlast1[j]; i++) {
            ip1 = i + 1;
            if (ip1 == nlast1[j]) ip1 = ibeg;

            if ((fabs(A[i]) <= eps) && (D[i] < 0.0)) {
                du = uvframe[2*ip1  ] - uvframe[2*i  ];
                dv = uvframe[2*ip1+1] - uvframe[2*i+1];
                dl = sqrt(du*du + dv*dv);
                if (dl <= eps) {
                    SPRINT0(0, "ERROR:: dl is less than eps");
                    status = OCSM_INTERNAL_ERROR;
                    goto cleanup;
                }

                du = uv[0] - uvframe[2*i  ];
                dv = uv[1] - uvframe[2*i+1];
                mu = sqrt(du*du + dv*dv) / dl;
                if ((mu < 0.0) || (mu > 1.0)) {
                    SPRINT1(0, "ERROR:: mu(=%lf) -- out of range", mu);
                    status = OCSM_INTERNAL_ERROR;
                    goto cleanup;
                }

                weights[i  ] = 1.0 - mu;
                weights[ip1] =       mu;
                goto cleanup;
            }
        }
        ibeg = nlast1[j];
    }

    /* compute the weights for any point in the interior */
    ibeg = 0;
    for (j = 0; j < nloop; j++) {
        for (i = ibeg; i < nlast1[j]; i++) {
            im1 = i - 1;
            if (i   == ibeg)       im1  = nlast1[j]-1;

            ip1 = i + 1;
            if (ip1 == nlast1[j])  ip1  = ibeg;

            wi = 0.0;
            if (fabs(A[im1]) > eps) wi  = (R[im1] - D[im1] / R[i]) / A[im1];
            if (fabs(A[i  ]) > eps) wi += (R[ip1] - D[i  ] / R[i]) / A[i  ];

            wsum       += wi;
            weights[i]  = wi;
        }
        ibeg = nlast1[j];
    }

    /* special code for visibiity-reduced mean value coordinates */
    if (INTERP_VEL == 2) {

        /* set all negtive weights to zero */
        numneg = 0;
        for (i = 0; i < ntotal; i++) {
            if (weights[i] < 0) {
                wsum -= weights[i];
                weights[i] = 0;
                numneg++;
            }
        }

        /* set weights to zero if ray from uv to frame point is
           hidden by another boundary segment */
        if (numneg > 0) {
            for (k = 0; k < ntotal; k++) {
                if (fabs(weights[k]) < EPS12) continue;

                ibeg = 0;
                for (j = 0; j < nloop; j++) {
                    for (i = ibeg; i < nlast1[j]; i++) {
                        if (fabs(weights[k]) < EPS12) break;

                        im1 = i - 1;
                        if (i == ibeg) im1  = nlast1[j]-1;

                        if (im1 == k || i == k) continue;

                        du1 = uvframe[2*k  ] - uv[0];
                        dv1 = uvframe[2*k+1] - uv[1];

                        du2 = uvframe[2*im1  ] - uvframe[2*i  ];
                        dv2 = uvframe[2*im1+1] - uvframe[2*i+1];

                        du3 = uvframe[2*im1  ] - uv[0];
                        dv3 = uvframe[2*im1+1] - uv[1];

                        den = du1 * dv2 - du2 * dv1;

                        if (fabs(den) < EPS12) continue;

                        s = (du3 * dv2 - du2 * dv3) / den;
                        t = (du1 * dv3 - du3 * dv1) / den;

                        if (s > 0 && s < 1 && t >= 0 && t <= 1) {
                            wsum -= weights[k];
                            weights[k] = 0;
                        }
                    }
                    ibeg = nlast1[j];
                }
            }
        }
    }

    /* normalize the weights */
    if (fabs(wsum) > 0.0) {
        for (i = 0; i < ntotal; i++) {
            weights[i] /= wsum;
        }
    }

cleanup:
    FREE(R);
    FREE(D);
    FREE(A);
    FREE(duv);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   newBody - create and initialize a new Body                         *
 *                                                                      *
 ************************************************************************
 */

static int
newBody(modl_T *modl,                   /* (in)  pointer to MODL */
        int    ibrch,                   /* (in)  Branch index (1:mbrch) */
        int    brtype,                  /* (in)  Branch type */
        int    ileft,                   /* (in)  left parent Body (or 0) */
        int    irite,                   /* (in)  rite parent Body (or 0) */
/*@null@*/varg_T args[],                /* (in)  array of arguments */
        int    hasdots,                 /* (in)  =1 if any arguments have non-zero dots */
        int    botype,                  /* (in)  Body type */
        int    *ibody)                  /* (out) new Body index */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iarg, ival, jbody;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(newBody);

    /* --------------------------------------------------------------- */

    /* extend the Body list (if needed) */
    if (MODL->nbody >= MODL->mbody) {
        MODL->mbody += 25;
        RALLOC(MODL->body, body_T, MODL->mbody+1);

        for (jbody = MODL->nbody+1; jbody <= MODL->mbody; jbody++) {
            MODL->body[jbody].ibrch  =  0;
            MODL->body[jbody].botype =  0;
            MODL->body[jbody].ileft  = -1;
            MODL->body[jbody].irite  = -1;
            MODL->body[jbody].ichld  = -1;
            MODL->body[jbody].igroup = -1;

            for (iarg = 1; iarg < 10; iarg++) {
                MODL->body[jbody].arg[iarg].val = NULL;
                MODL->body[jbody].arg[iarg].dot = NULL;
            }

            MODL->body[jbody].ebody   = NULL;
            MODL->body[jbody].eebody  = NULL;
            MODL->body[jbody].etess   = NULL;
            MODL->body[jbody].eetess  = NULL;
            MODL->body[jbody].npnts   = 0;
            MODL->body[jbody].ntris   = 0;

            MODL->body[jbody].onstack = 0;
            MODL->body[jbody].hasdots = 0;
            MODL->body[jbody].hasdxyz = 0;
            MODL->body[jbody].botype  = 0;
            MODL->body[jbody].nonmani = 0;
            MODL->body[jbody].CPU     = 0;
            MODL->body[jbody].nnode   = 0;
            MODL->body[jbody].node    = NULL;
            MODL->body[jbody].nedge   = 0;
            MODL->body[jbody].edge    = NULL;
            MODL->body[jbody].nface   = 0;
            MODL->body[jbody].face    = NULL;
            MODL->body[jbody].hassens = 0;
        }
    }

    /* create the new Body and initialize it */
    MODL->nbody++;

    MODL->ngroup++;

    *ibody = MODL->nbody;
    MODL->body[*ibody].ibrch  = ibrch;
    MODL->body[*ibody].brtype = brtype;
    MODL->body[*ibody].ileft  = ileft;
    MODL->body[*ibody].irite  = irite;
    MODL->body[*ibody].ichld  = 0;
    MODL->body[*ibody].igroup = MODL->ngroup;

    if (args != NULL) {
        for (iarg = 1; iarg < 10; iarg++) {
            MODL->body[*ibody].arg[iarg].nval = args[iarg].nval;
            MODL->body[*ibody].arg[iarg].nrow = args[iarg].nrow;
            MODL->body[*ibody].arg[iarg].ncol = args[iarg].ncol;

            if (args[iarg].nval == 0) {
                MALLOC(MODL->body[*ibody].arg[iarg].str, char, (int)(STRLEN(args[iarg].str)+1));

                strcpy(MODL->body[*ibody].arg[iarg].str, args[iarg].str);

                if (MODL->body[*ibody].arg[iarg].dot != NULL) {
                    SPRINT2(0, "ERROR:: MODL->body[%d].arg[%d].dot is not NULL", *ibody, iarg);
                    status = BAD_MALLOC;
                    goto cleanup;
                }
            } else if (args[iarg].nval > 0) {
                MALLOC(MODL->body[*ibody].arg[iarg].val, double, args[iarg].nval);
                MALLOC(MODL->body[*ibody].arg[iarg].dot, double, args[iarg].nval);

                for (ival = 0; ival < args[iarg].nval; ival++) {
                    MODL->body[*ibody].arg[iarg].val[ival] = args[iarg].val[ival];
                    MODL->body[*ibody].arg[iarg].dot[ival] = args[iarg].dot[ival];
                }
            }
        }
    } else {
        for (iarg = 1; iarg < 10; iarg++) {
            MODL->body[*ibody].arg[iarg].nval = -1;
            MODL->body[*ibody].arg[iarg].nrow =  0;
            MODL->body[*ibody].arg[iarg].ncol =  0;
            MODL->body[*ibody].arg[iarg].val  = NULL;
            MODL->body[*ibody].arg[iarg].dot  = NULL;
        }
    }

    MODL->body[*ibody].ebody  = NULL;
    MODL->body[*ibody].eebody = NULL;
    MODL->body[*ibody].etess  = NULL;
    MODL->body[*ibody].eetess = NULL;
    MODL->body[*ibody].npnts  = 0;
    MODL->body[*ibody].ntris  = 0;

    MODL->body[*ibody].onstack = 0;
    MODL->body[*ibody].hasdots = hasdots;
    MODL->body[*ibody].hasdxyz = 0;
    MODL->body[*ibody].botype  = botype;
    MODL->body[*ibody].nonmani = 0;
    MODL->body[*ibody].CPU     = 0;
    MODL->body[*ibody].nnode   = 0;
    MODL->body[*ibody].node    = NULL;
    MODL->body[*ibody].nedge   = 0;
    MODL->body[*ibody].edge    = NULL;
    MODL->body[*ibody].nface   = 0;
    MODL->body[*ibody].face    = NULL;
    MODL->body[*ibody].hassens = 0;

    /* link children */
    if (ileft > 0) {
        MODL->body[ileft].ichld = *ibody;
    }
    if (irite > 0) {
        MODL->body[irite].ichld = *ibody;
    }

    MODL->hasMPs = 0;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   parseName - parse namestr into Parameter name, row, and column     *
 *                                                                      *
 ************************************************************************
 */

static int
parseName(modl_T *modl,                 /* (in)  pointer to MODL */
          char   string[],              /* (in)  name string to parse */
          char   pname[],               /* (out) Parameter name (at least MAX_NAME_LEN long) */
          int    *ipmtr,                /* (out) Parameter index (1:npmtr) or 0 if none */
          int    *irow,                 /* (out) row index (1:nrow) */
                                        /*       =0 if not given, =-999 if given as : */
          int    *icol)                 /* (out) column index (1:ncol) */
                                        /*       =0 if not given, =-999 if given as : */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       i, icount, jcount, jpmtr;
    double    rownum, colnum, dot;
    char      row[MAX_EXPR_LEN], col[MAX_EXPR_LEN];
    char      str[MAX_STRVAL_LEN];

    ROUTINE(parseName);

    /* --------------------------------------------------------------- */

    /* break str1 into pname[irow,icol]
          name      -> irow=   0, icol=   0
          name[1,2] -> irow=   1, icol=   2
          name[:,2] -> irow=-999, icol=   2
          name[1,:] -> irow=   1, icol=-999
          name[:,:] -> irow=-999, icol=-999
          name[1]   -> error
    */

    /* peel off each part of pname[irow,icol] */
    if (strstr(string, ",") != NULL) {
        pname[0] = '\0';
        row[0]   = '\0';
        col[0]   = '\0';
        icount   = 0;
        jcount   = 0;

        for (i = 0; i < STRLEN(string); i++) {
            if (icount == 0) {
                if (string[i] != '[') {
                    pname[jcount  ] = string[i];
                    pname[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    jcount = 0;
                }
            } else if (icount == 1) {
                if (string[i] != ',') {
                    row[jcount  ] = string[i];
                    row[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    jcount = 0;
                }
            } else {
                if (string[i] != ']') {
                    col[jcount  ] = string[i];
                    col[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    break;
                }
            }
        }

    /* otherwise try peeling off each part of pname[irow] (with icol=1) */
    } else {
        pname[0] = '\0';
        row[0]   = '\0';
        col[0]   = '\0';
        icount   = 0;
        jcount   = 0;

        for (i = 0; i < STRLEN(string); i++) {
            if (icount == 0) {
                if (string[i] != '[') {
                    pname[jcount  ] = string[i];
                    pname[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    jcount = 0;
                }
            } else {
                if (string[i] != ']') {
                    col[0] = '0';
                    col[1] = '\0';

                    row[jcount  ] = string[i];
                    row[jcount+1] = '\0';
                    jcount++;
                } else {
                    icount++;
                    icount++;
                    break;
                }
            }
        }
    }

    /* return error if not in specified form */
    if (icount != 0 && icount != 3) {
        status = OCSM_ILLEGAL_PMTR_NAME;
        goto cleanup;
    }

    /* convert row and col to an integer */
    if (STRLEN(row) == 0) {
        *irow = 0;
    } else if (strcmp(row, ":") == 0) {
        *irow = -999;
    } else {
        status = str2val(row, MODL, &rownum, &dot, str);
        CHECK_STATUS(str2val:row);
        if (STRLEN(str) > 0) {
            status = OCSM_WRONG_PMTR_TYPE;
            goto cleanup;
        }

        *irow = NINT(rownum);
    }

    if (STRLEN(col) == 0) {
        *icol = 0;
    } else if (strcmp(col, ":") == 0) {
        *icol = -999;
    } else {
        status = str2val(col, MODL, &colnum, &dot, str);
        CHECK_STATUS(str2val:col);
        if (STRLEN(str) > 0) {
            status = OCSM_WRONG_PMTR_TYPE;
            goto cleanup;
        }

        *icol = NINT(colnum);
    }

    /* look for current Parameter index */
    *ipmtr = 0;
    for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {
        if (strcmp(MODL->pmtr[jpmtr].name, pname) == 0) {
            if (MODL->pmtr[jpmtr].type == OCSM_OUTPMTR) {
                *ipmtr = jpmtr;
                break;
            } else if (MODL->pmtr[jpmtr].scope == MODL->scope[MODL->level]) {
                *ipmtr = jpmtr;
                break;
            }
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   printAttrs - prints Attributes associated with an ebody            *
 *                                                                      *
 ************************************************************************
 */

static int
printAttrs(ego    ebody)                /* (in)  pointer to Body */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nlist, nattr, iattr, nface, nedge, nnode, iface, iedge, inode;

    int       itype, i, oclass, mtype, nchild, *senses;
    CINT      *tempIlist;
    double    bbox[6];
    CDOUBLE   *tempRlist;
    CCHAR     *attrName, *tempClist;
    ego       *efaces, *eedges, *enodes, eref, *echilds;

    ROUTINE(printAttrs);

    /* --------------------------------------------------------------- */

    /* Body Attributes */
    status = EG_attributeNum(ebody, &nattr);
    CHECK_STATUS(EG_attributeNum);

    SPRINT0(0, "    Body");

    for (iattr = 1; iattr <= nattr; iattr++) {
        status = EG_attributeGet(ebody, iattr, &attrName, &itype, &nlist,
                                 &tempIlist, &tempRlist, &tempClist);
        CHECK_STATUS(EG_attributeGet);

        SPRINT1x(0, "        %-20s =", attrName);

        if        (itype == ATTRINT) {
            for (i = 0; i < nlist; i++) {
                SPRINT1x(0, "%5d ", tempIlist[i]);
            }
            SPRINT0(0, " ");
        } else if (itype == ATTRREAL) {
            for (i = 0; i < nlist; i++) {
                SPRINT1x(0, "%11.5f ", tempRlist[i]);
            }
            SPRINT0(0, " ");
        } else if (itype == ATTRCSYS) {
            for (i = 0; i < nlist; i++) {
                SPRINT1x(0, "%11.5f ", tempRlist[i]);
            }
            SPRINT0(0, "                             =");
            for (i = nlist; i < nlist+12; i++) {
                SPRINT1x(0, "%11.5f ", tempRlist[i]);
            }
            SPRINT0(0, " ");
        } else if (itype == ATTRSTRING) {
            SPRINT1(0, "%s", tempClist);
        }
    }

    /* for each Face associated with ebody, get its Attributes and bounding box */
    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (efaces != NULL) {
        for (iface = 0; iface < nface; iface++) {
            status = EG_getBoundingBox(efaces[iface], bbox);
            CHECK_STATUS(EG_getBoundingBox);

            SPRINT7(0, "    iface  = %d   (%10.5f %10.5f %10.5f -> %10.5f %10.5f %10.5f)",
                    iface+1, bbox[0], bbox[1], bbox[2], bbox[3], bbox[4], bbox[5]);

            status = EG_attributeNum(efaces[iface], &nattr);
            CHECK_STATUS(EG_attributeNum);

            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(efaces[iface], iattr, &attrName, &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeGet);

                SPRINT1x(0, "        %-20s =", attrName);

                if        (itype == ATTRINT) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%5d ", tempIlist[i]);
                    }
                } else if (itype == ATTRREAL) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                } else if (itype == ATTRCSYS) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                    SPRINT0(0, "                             =");
                    for (i = nlist; i < nlist+12; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                } else if (itype == ATTRSTRING) {
                    SPRINT1x(0, "%s", tempClist);
                }
                SPRINT0(0, " ");
            }
        }

        EG_free(efaces);
    }

    /* for each Edge associated with ebody, get its Attributes and bounding box */
    status = EG_getBodyTopos(ebody, NULL, EDGE, &nedge, &eedges);
    CHECK_STATUS(EG_getBodyTopos);

    if (eedges != NULL) {
        for (iedge = 0; iedge < nedge; iedge++) {
            status = EG_getBoundingBox(eedges[iedge], bbox);
            CHECK_STATUS(EG_getBoundingBox);

            SPRINT7(0, "    iedge  = %d   (%10.5f %10.5f %10.5f -> %10.5f %10.5f %10.5f)",
                    iedge+1, bbox[0], bbox[1], bbox[2], bbox[3], bbox[4], bbox[5]);

            status = EG_attributeNum(eedges[iedge], &nattr);
            CHECK_STATUS(EG_attributeNum);

            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(eedges[iedge], iattr, &attrName, &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeGet);

                SPRINT1x(0, "        %-20s =", attrName);

                if        (itype == ATTRINT) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%5d ", tempIlist[i]);
                    }
                } else if (itype == ATTRREAL) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                } else if (itype == ATTRCSYS) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                    SPRINT0(0, "                             =");
                    for (i = nlist; i < nlist+12; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                } else if (itype == ATTRSTRING) {
                    SPRINT1x(0, "%s", tempClist);
                }
                SPRINT0(0, " ");
            }
        }

        EG_free(eedges);
    }

    /* for each Node associated with ebody, get its Attributes */
    status = EG_getBodyTopos(ebody, NULL, NODE, &nnode, &enodes);
    CHECK_STATUS(EG_getBodyTopos);

    if (enodes != NULL) {
        for (inode = 0; inode < nnode; inode++) {
            status = EG_getTopology(enodes[inode], &eref, &oclass, &mtype, bbox,
                                    &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            SPRINT4(0, "    inode  = %d   (%10.5f %10.5f %10.5f)",
                    inode+1, bbox[0], bbox[1], bbox[2]);

            status = EG_attributeNum(enodes[inode], &nattr);
            CHECK_STATUS(EG_attributeNum);

            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(enodes[inode], iattr, &attrName, &itype, &nlist,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeGet);

                SPRINT1x(0, "        %-20s =", attrName);

                if        (itype == ATTRINT) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%5d ", tempIlist[i]);
                    }
                } else if (itype == ATTRREAL) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                } else if (itype == ATTRCSYS) {
                    for (i = 0; i < nlist; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                    SPRINT0(0, "                             =");
                    for (i = nlist; i < nlist+12; i++) {
                        SPRINT1x(0, "%11.5f ", tempRlist[i]);
                    }
                } else if (itype == ATTRSTRING) {
                    SPRINT1x(0, "%s", tempClist);
                }
                SPRINT0(0, " ");
            }
        }

        EG_free(enodes);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   printBodyInfo - print info about a Body                            *
 *                                                                      *
 ************************************************************************
 */

static int
printBodyInfo(body_T *body)             /* (in)  pointer to Body */
{
    int       status = SUCCESS;         /* (out) return status */

    int       inode, iedge, iface, i, oclass, mtype, nloop, iloop, nedge, *senses;
    double    data[18];
    ego       eref, *eloops, *eedges;

    ROUTINE(printBodyInfo);

    /* --------------------------------------------------------------- */

    /* loop through all Nodes */
    SPRINT0(1, "inode nedge ibody       x            y            z");
    for (inode = 1; inode <= body->nnode; inode++) {
        SPRINT6(1, "%5d %5d %5d %12.5f %12.5f %12.5f", inode,
                body->node[inode].nedge,
                body->node[inode].ibody,
                body->node[inode].x,
                body->node[inode].y,
                body->node[inode].z);
    }

    /* loop through all Edges */
    SPRINT0(1, "iedge itype  ibeg  iend ileft irite nface ibody iford imark");
    for (iedge = 1; iedge <= body->nedge; iedge++) {
        SPRINT10(1, "%5d %5d %5d %5d %5d %5d %5d %5d %5d %5d", iedge,
                 body->edge[iedge].itype,
                 body->edge[iedge].ibeg,
                 body->edge[iedge].iend,
                 body->edge[iedge].ileft,
                 body->edge[iedge].irite,
                 body->edge[iedge].nface,
                 body->edge[iedge].ibody,
                 body->edge[iedge].iford,
                 body->edge[iedge].imark);
    }

    /* loop through all Faces */
    SPRINT0(1, "iface ibody iford imark Edges...");
    for (iface = 1; iface <= body->nface; iface++) {
        SPRINT4x(1,"%5d %5d %5d %5d", iface,
                 body->face[iface].ibody,
                 body->face[iface].iford,
                 body->face[iface].imark);

        status = EG_getTopology(body->face[iface].eface, &eref, &oclass, &mtype,
                                data, &nloop, &eloops, &senses);
        CHECK_STATUS(EG_getTopology);

        for (iloop = 0; iloop < nloop; iloop++) {
            status = EG_getTopology(eloops[iloop], &eref, &oclass, &mtype,
                                    data, &nedge, &eedges, &senses);
            CHECK_STATUS(EG_getTopology);

            for (i = 0; i < nedge; i++) {
                iedge = status = EG_indexBodyTopo(body->ebody, eedges[i]);
                CHECK_STATUS(EG_indexBodyTopo);

                if (iloop > 0) iedge *= -1;

                SPRINT1x(1, " %4d", iedge*senses[i]);
            }
        }
        SPRINT0(1, " ");
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   printPmtrs - print all Parameters to file                          *
 *                                                                      *
 ************************************************************************
 */

static int
printPmtrs(modl_T *modl,                /* (in)  pointer to MODL */
           FILE   *fp)                  /* (in)  pointer to FILE */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       ipmtr, irow, icol, index;

    ROUTINE(printPmtrs);

    /* --------------------------------------------------------------- */

    /* loop through all Parameters and print its name and value */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if        (MODL->pmtr[ipmtr].type == OCSM_DESPMTR) {
            fprintf(fp, "    %5d [e]  %-32s",   ipmtr,                          MODL->pmtr[ipmtr].name);
        } else if (MODL->pmtr[ipmtr].type == OCSM_CFGPMTR) {
            fprintf(fp, "    %5d [f]  %-32s",   ipmtr,                          MODL->pmtr[ipmtr].name);
        } else if (MODL->pmtr[ipmtr].type == OCSM_LOCALVAR) {
            fprintf(fp, "    %5d [%1d]  %-32s", ipmtr, MODL->pmtr[ipmtr].scope, MODL->pmtr[ipmtr].name);
        } else if (MODL->pmtr[ipmtr].type == OCSM_CONPMTR) {
            fprintf(fp, "    %5d [c]  %-32s",   ipmtr,                          MODL->pmtr[ipmtr].name);
        }

        if (MODL->pmtr[ipmtr].str != NULL) {
            fprintf(fp, " ---------  %-s\n", MODL->pmtr[ipmtr].str);
        } else {
            index = 0;
            for (irow = 1; irow <= MODL->pmtr[ipmtr].nrow; irow++) {
                for (icol = 1; icol <= MODL->pmtr[ipmtr].ncol; icol++) {
                    if (index > 0) {
                        fprintf(fp, "\n                                               ");
                    }

                    fprintf(fp, " [%3d,%3d] %11.5f %11.5f",
                            irow, icol,
                            MODL->pmtr[ipmtr].value[index],
                            MODL->pmtr[ipmtr].dot[  index]);

                    if (MODL->pmtr[ipmtr].type != OCSM_DESPMTR &&
                        MODL->pmtr[ipmtr].type != OCSM_CFGPMTR   ) {
                    } else if (MODL->pmtr[ipmtr].lbnd[index] <= -HUGEQ) {
                        fprintf(fp, "    >>   unbounded");
                    } else {
                        fprintf(fp, "    >> %11.5f", MODL->pmtr[ipmtr].lbnd[ index]);
                    }

                    if (MODL->pmtr[ipmtr].type != OCSM_DESPMTR &&
                        MODL->pmtr[ipmtr].type != OCSM_CFGPMTR   ) {
                    } else if (MODL->pmtr[ipmtr].ubnd[index] >= +HUGEQ) {
                        fprintf(fp, " <<   unbounded");
                    } else {
                        fprintf(fp, " << %11.5f",   MODL->pmtr[ipmtr].ubnd[ index]);
                    }

                    index++;
                }
            }
            fprintf(fp, "\n");
        }
    }

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   rank - compute the rank of a matrix                                *
 *                                                                      *
 ************************************************************************
 */

static int
rank(double mat[],                      /* (in)  input matrix */
     int    nrow,                       /* (in)  number of rows */
     int    ncol)                       /* (in)  number of columns */
{
    int       status = SUCCESS;         /* (out) return status or rank */

    int       i, j, ii, jj, pivot;
    double    amax, swap, *A=NULL;

    ROUTINE(rank);

    /* --------------------------------------------------------------- */

    assert(nrow > 0);
    assert(ncol > 0);

    /* make a copy of the matrix */
    MALLOC(A, double, nrow*ncol);

    for (i = 0; i < nrow; i++) {
        for (j = 0; j < ncol; j++) {
            A[i*ncol+j] = mat[i*ncol+j];
        }
    }

    /* convert A to row reduced echelon form */
    i = 0;
    for (j = 0; j < ncol; j++) {

        /* find largest element in column j (in row i or below) */
        amax  = A[i*ncol+j];
        pivot = i;

        for (ii = i+1; ii < nrow; ii++) {
            if (fabs(A[ii*ncol+j]) > fabs(amax)) {
                amax = A[ii*ncol+j];
                pivot = ii;
            }
        }

        /* if pivot is nearly zero, skip to next column */
        if (fabs(amax) < EPS12) continue;

        /* swap rows i and pivot */
        if (i != pivot) {
            for (jj = 0; jj < ncol; jj++) {
                swap             = A[pivot*ncol+jj];
                A[pivot*ncol+jj] = A[i    *ncol+jj];
                A[i    *ncol+jj] = swap;
            }
        }

        /* normalize row i */
        for (jj = 0; jj < ncol; jj++) {
            A[i*ncol+jj] /= amax;
        }

        /* reduce rest of rows */
        for (ii = i+1; ii < nrow; ii++) {
            amax = A[ii*ncol+j];
            for (jj = j; jj < ncol; jj++) {
                A[ii*ncol+jj] -= amax * A[i*ncol+jj];
            }
        }

        /* next row */
        i++;
        if (i >= nrow) break;
    }

    /* rank (which is stored in status) is number of non-zero rows */
    for (i = 0; i < nrow; i++) {
        for (j = 0; j < ncol; j++) {
            if (fabs(A[i*ncol+j]) > EPS06) {
                status++;
                break;
            }
        }
    }

cleanup:
    FREE(A);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   rbfWeights - compute radial-basis function (RBF) weights           *
 *                                                                      *
 ************************************************************************
 */

static int
rbfWeights(int        nbnd,             /* (in)  number of boundary points */
           double     srad2,            /* (in)  support radius squared */
           CDOUBLE    uv[],             /* (in)  location of boundary points */
           double     duv[],            /* (in)  velocity of boundary points */
           double     weights[])        /* (out) RBF weights */
{
    int  status = SUCCESS;

    int        i, j;
    double     *mat=NULL, *rhs=NULL, *W=NULL, *ans=NULL;

    ROUTINE(rbfWeights);

    /* --------------------------------------------------------------- */

    MALLOC(mat, double, nbnd*nbnd);
    MALLOC(rhs, double, nbnd     );
    MALLOC(W,   double, nbnd     );
    MALLOC(ans, double, nbnd     );

    /* set up matrix */
    for (i = 0; i < nbnd; i++) {
        for (j = 0; j < nbnd; j++) {
            mat[(i  )*nbnd+(j  )] = wendland(&uv[2*i], &uv[2*j], srad2);
        }
    }

    /* solve for u-weights */
    for (i = 0; i < nbnd; i++) {
        rhs[i] = duv[2*i  ];
    }

    status = solsvd(mat, rhs, nbnd, nbnd, W, ans);
    CHECK_STATUS(solsvd);

    for (i = 0; i < nbnd; i++) {
        weights[2*i  ] = ans[i];
    }

    /* solve for v-weights */
    for (i = 0; i < nbnd; i++) {
        rhs[i] = duv[2*i+1];
    }

    status = solsvd(mat, rhs, nbnd, nbnd, W, ans);
    CHECK_STATUS(solsvd);

    for (i = 0; i < nbnd; i++) {
        weights[2*i+1] = ans[i];
    }

cleanup:
    FREE(mat);
    FREE(rhs);
    FREE(W   );
    FREE(ans);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtCompareKeys - compare (ikey1,ikey2,ikey3,ikey4) with (jkey1,jkey2,jkey3,jkey4) and return -1/0/+1 *
 *                                                                      *
 ************************************************************************
 */

static int
rbtCompareKeys(int    ikey1,            /* first  key of i */
               int    jkey1,            /* first  key of j */
               int    ikey2,            /* second key of i */
               int    jkey2,            /* second key of j */
               int    ikey3,            /* third  key of i */
               int    jkey3,            /* third  key of j */
               int    ikey4,            /* fourth key of i */
               int    jkey4)            /* fourth key of j */
{
                                        /* (out) -1, or 0, or +1 */

    ROUTINE(rbtCompareKeys);

    /* --------------------------------------------------------------- */

    /* compare primary keys */
    if        (ikey1 < jkey1) {
        return -1;
    } else if (ikey1 > jkey1) {
        return +1;

    /* compare secondary keys */
    } else if (ikey2 < jkey2) {
        return -1;
    } else if (ikey2 > jkey2) {
        return +1;

    /* compare tertiary keys */
    } else if (ikey3 < jkey3) {
        return -1;
    } else if (ikey3 > jkey3) {
        return +1;

    /* compare quaternary keys */
    } else if (ikey4 < jkey4) {
        return -1;
    } else if (ikey4 > jkey4) {
        return +1;

    /* all keys are the same */
    } else {
        return 0;
    }
}


/*
 ************************************************************************
 *                                                                      *
 * rbtCreate - create a new Tree                                        *
 *                                                                      *
 * Reference: "Introduction to Algorithms" by Thomas Cormen,            *
 *             Charles Leiserson, and Ronald Rivest, McGraw-Hill,       *
 *             1991, pp 244-280.                                        *
 *                                                                      *
 ************************************************************************
 */

static int
rbtCreate(int    chunk,                 /* (in)  chunk size for allocations */
          rbt_T  **tree)                /* (out) pointer to new RBT */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(rbtCreate);

    /* --------------------------------------------------------------- */

    /* default return value */
    *tree = NULL;

    /* get a new Tree and a default number of Nodes */
    MALLOC(*tree, rbt_T, 1);

    (*tree)->mnode = chunk;
    (*tree)->chunk = chunk;
    (*tree)->key1  = NULL;
    (*tree)->key2  = NULL;
    (*tree)->key3  = NULL;
    (*tree)->key4  = NULL;
    (*tree)->data  = NULL;
    (*tree)->left  = NULL;
    (*tree)->rite  = NULL;
    (*tree)->prnt  = NULL;
    (*tree)->colr  = NULL;

    MALLOC((*tree)->key1, int, (*tree)->mnode);
    MALLOC((*tree)->key2, int, (*tree)->mnode);
    MALLOC((*tree)->key3, int, (*tree)->mnode);
    MALLOC((*tree)->key4, int, (*tree)->mnode);
    MALLOC((*tree)->data, int, (*tree)->mnode);
    MALLOC((*tree)->left, int, (*tree)->mnode);
    MALLOC((*tree)->rite, int, (*tree)->mnode);
    MALLOC((*tree)->prnt, int, (*tree)->mnode);
    MALLOC((*tree)->colr, int, (*tree)->mnode);

    /* initialize the Tree */
    (*tree)->nnode =  0;
    (*tree)->root  = -1;

cleanup:
    return status;
}


/*
 ******************************************************************************
 *                                                                            *
 * rbtDelete - delete an entire Tree                                          *
 *                                                                            *
 ******************************************************************************
 */

static int
rbtDelete(rbt_T   *tree)                /* (in)  pointer to RBT */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(rbtDelete);

    /* --------------------------------------------------------------- */

    /* check for valid tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* free all elements in the Tree and then the Tree itself */
    FREE(tree->key1);
    FREE(tree->key2);
    FREE(tree->key3);
    FREE(tree->key4);
    FREE(tree->data);
    FREE(tree->left);
    FREE(tree->rite);
    FREE(tree->prnt);
    FREE(tree->colr);

    FREE(tree);

cleanup:
    return status;
}


/*
 ******************************************************************************
 *                                                                            *
 * rbtInsert - insert a Node into a Tree                                      *
 *                                                                            *
 ******************************************************************************
 */

static int
rbtInsert(rbt_T   *tree,                /* (in)  poiner to RBT */
          int     key1,                 /* (in)  first  key */
          int     key2,                 /* (in)  second key */
          int     key3,                 /* (in)  third  key */
          int     key4,                 /* (in)  fourth key */
          int     data)                 /* (in)  associated data */
{
    int       status = SUCCESS;         /* (out) index of node created (bias-0) */
                                        /*       or return status */

    int    inode, ix, iy, iz, ipz, ippz;

    ROUTINE(rbtInsert);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* expand size of Tree if we have used up all available Nodes */
    if (tree->nnode >= tree->mnode) {
        tree->mnode += tree->chunk;
        RALLOC(tree->key1, int, tree->mnode);
        RALLOC(tree->key2, int, tree->mnode);
        RALLOC(tree->key3,  int, tree->mnode);
        RALLOC(tree->key4,  int, tree->mnode);
        RALLOC(tree->data,  int, tree->mnode);
        RALLOC(tree->left,  int, tree->mnode);
        RALLOC(tree->rite,  int, tree->mnode);
        RALLOC(tree->prnt,  int, tree->mnode);
        RALLOC(tree->colr,  int, tree->mnode);
    }

    /* put the new Node at the bottom of the Tree */
    tree->key1[tree->nnode] = key1;
    tree->key2[tree->nnode] = key2;
    tree->key3[tree->nnode] = key3;
    tree->key4[tree->nnode] = key4;
    tree->data[tree->nnode] = data;
    tree->left[tree->nnode] = -1;
    tree->rite[tree->nnode] = -1;
    tree->prnt[tree->nnode] = -1;       /* over-written below */
    tree->colr[tree->nnode] = -1;       /* over-written below */
    tree->nnode ++;

    /* find out where the new Node will fall into the current Tree */
    iz = tree->nnode - 1;
    iy = -1;
    ix = tree->root;

    while (ix >= 0) {
        iy = ix;
        if (rbtCompareKeys(key1, tree->key1[ix],
                           key2, tree->key2[ix],
                           key3, tree->key3[ix],
                           key4, tree->key4[ix]) < 0) {
            ix = tree->left[ix];
        } else {
            ix = tree->rite[ix];
        }
    }

    /* link the new Node to its parent and vice versa */

    tree->prnt[iz] = iy;

    if (iy == -1) {
        tree->root = iz;
    } else if (rbtCompareKeys(key1, tree->key1[iy],
                              key2, tree->key2[iy],
                              key3, tree->key3[iy],
                              key4, tree->key4[iy]) < 0) {
        tree->left[iy] = iz;
    } else {
        tree->rite[iy] = iz;
    }

    /* make inode (the returned value) point to the new Node */
    inode = iz;

    /* now start reordering the Tree following the red-black algorithm
          so that the Tree is a balanced as possible */
    tree->colr[iz] = RBT_RED;

    /* determine what violations of the red-black properties were
          introduced above */
    while ((iz != tree->root) && (tree->colr[tree->prnt[iz]] == RBT_RED)) {

        /* move a violation of the red-child-black-parent violation up
              the Tree while maintaining that every simple path from
              a Nde to a descendent leaf contains the same number
              of black Nodes */

        ipz  = tree->prnt[iz ];
        ippz = tree->prnt[ipz];

        if (ipz == tree->left[ippz]) {
            iy = tree->rite[ippz];

            if ((iy >= 0) && (tree->colr[iy] == RBT_RED)) {
                tree->colr[ipz ] = RBT_BLACK;
                tree->colr[iy  ] = RBT_BLACK;
                tree->colr[ippz] = RBT_RED;
                iz               = ippz;
            } else {
                if (iz == tree->rite[ipz]) {
                    iz = ipz;
                    rbtRotateLeft(tree, iz);
                }

                ipz  = tree->prnt[iz ];
                ippz = tree->prnt[ipz];

                tree->colr[ipz ] = RBT_BLACK;
                tree->colr[ippz] = RBT_RED;
                rbtRotateRite(tree, ippz);
            }
        } else {
            iy = tree->left[ippz];

            if ((iy >= 0) && (tree->colr[iy] == RBT_RED)) {
                tree->colr[ipz ] = RBT_BLACK;
                tree->colr[iy  ] = RBT_BLACK;
                tree->colr[ippz] = RBT_RED;
                iz               = ippz;
            } else {
                if (iz == tree->left[ipz]) {
                    iz = ipz;
                    rbtRotateRite(tree, iz);
                }

                ipz  = tree->prnt[iz ];
                ippz = tree->prnt[ipz];

                tree->colr[ipz ] = RBT_BLACK;
                tree->colr[ippz] = RBT_RED;
                rbtRotateLeft(tree, ippz);
            }
        }
    }

    /* finally color the Root of the tree black */
    tree->colr[tree->root] = RBT_BLACK;

    status = inode;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtLookup - look up data associated with a node                      *
 *                                                                      *
 ************************************************************************
 */

static int
rbtLookup(rbt_T   *tree,                /* pointer to RBT */
          int     inode)                /* node to look up */
{
    int       status = SUCCESS;         /* (out) data value at inode */
                                        /*       or return status */

    ROUTINE(rbtLookup);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* check for valid istart */
    if (inode < 0 || inode >= tree->nnode) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    status = tree->data[inode];

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtMaximum - find rite-most Node in subTree                          *
 *                                                                      *
 ************************************************************************
 */
#if 0

static int
rbtMaximum(rbt_T   *tree,               /* (in)  pointer to RBT */
           int     istart)              /* (in)  node at which to start search */
{
    int       status = SUCCESS;         /* (out) index of rite-most node (bias-0) */
                                        /*       or return status */
    int ix;

    ROUTINE(rbtMaximum);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* check for valid istart */
    if (istart < 0 || istart >= tree->nnode) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* start at given istart or root if istart < 0 */
    if (istart < 0) {
        ix = tree->root;
    } else {
        ix = istart;
    }

    /* find the ritemost Node by following the rite children */
    while (tree->rite[ix] >= 0) {
        ix = tree->rite[ix];
    }

    status = ix;

cleanup:
    return status;
}
#endif


/*
 ************************************************************************
 *                                                                      *
 * rbtMinimum - find left-most Node in subTree                          *
 *                                                                      *
 ************************************************************************
 */
#if 0

static int
rbtMinimum(rbt_T   *tree,               /* (in)  pointer to RBT */
           int     istart)              /* (in)  node at which to start search */
{
    int       status = SUCCESS;         /* (out) index of left-most node (bias-0) */
                                        /*       or return status */
    int ix;

    ROUTINE(rbtMinimum);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* check for valid istart */
    if (istart < 0 || istart >= tree->nnode) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* start at given istart or root if istart < 0 */
    if (istart < 0) {
        ix = tree->root;
    } else {
        ix = istart;
    }

    /* find the leftmost Node by following the left children */
    while (tree->left[ix] >= 0) {
        ix = tree->left[ix];
    }

    status = ix;

cleanup:
    return status;
}
#endif


/*
 ************************************************************************
 *                                                                      *
 * rbtNext - find Node immediately to the rite                          *
 *                                                                      *
 ************************************************************************
 */
#if 0

static int
rbtNext(rbt_T   *tree,                  /* (in)  pointer to RBT */
        int     istart)                 /* (in)  node at which to start search */
{
    int       status = SUCCESS;         /* (out) index of node to rite (bias-0) */
                                        /*       or return status */
    int ix, iy;

    ROUTINE(rbtNext);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* check for valid istart */
    if (istart < 0 || istart >= tree->nnode) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* start at given istart or root if istart < 0 */
    if (istart < 0) {
        ix = tree->root;
    } else {
        ix = istart;
    }

    /* if the rite child is not empty, then find the minimum of the
          Tree starting at the rite child */
    if (tree->rite[ix] >= 0) {
        status = rbtMinimum(tree, tree->rite[ix]);

    /* otherwise, iy is the lowest ancestor of ix whose left child
          is also an ancestor of ix */
    } else {
        iy = tree->prnt[ix];

        while ((iy >= 0) && (ix == tree->rite[iy])) {
            ix = iy;
            iy = tree->prnt[iy];
        }

        status = iy;
    }

cleanup:
    return status;
}
#endif


/*
 ************************************************************************
 *                                                                      *
 * rbtPrev - find Node immediately to the left                          *
 *                                                                      *
 ************************************************************************
 */
#if 0

static int
rbtPrev(rbt_T   *tree,                  /* (in)  pointer to RBT */
        int     istart)                 /* (in)  node at which to start */
{
    int       status = SUCCESS;         /* (out) index of node to left (bias-0) */
                                        /*       or return status */
    int ix, iy;

    ROUTINE(rbtPrev);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* check for valid istart */
    if (istart < 0 || istart >= tree->nnode) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    /* start at given istart or root if istart < 0 */
    if (istart < 0) {
        ix = tree->root;
    } else {
        ix = istart;
    }

    /* if the left child is not empty, then find the maximum of the
          Tree starting at the left child */
    if (tree->left[ix] >= 0) {
        status = rbtMaximum(tree, tree->left[ix]);

    /* otherwise, iy is the lowest ancestor of ix whose rite child
          is also an ancestor of ix */
    } else {
        iy = tree->prnt[ix];

        while ((iy >= 0) && (ix == tree->left[iy])) {
            ix = iy;
            iy = tree->prnt[iy];
        }

        status = iy;
    }

cleanup:
    return status;
}
#endif


/*
 ************************************************************************
 *                                                                      *
 * rbtRotateLeft - rotate Nodes to the left                             *
 *                                                                      *
 ************************************************************************
 */

static void
rbtRotateLeft(rbt_T   *tree,            /* (in)  pointer to RBT */
              int     inode)            /* (in)  node to rotate to the left */
{
    int ix, iy;

    ROUTINE(rbtRotateLeft);

    /* --------------------------------------------------------------- */

    ix = inode;
    iy = tree->rite[ix];

    /* turn iy's left subTree into ix's rite subTree */
    tree->rite[ix] = tree->left[iy];

    if (tree->left[iy] >= 0) {
        tree->prnt[tree->left[iy]] = ix;
    }

    /* link ix's parent to iy */
    tree->prnt[iy] = tree->prnt[ix];

    if (tree->prnt[ix] == -1) {
        tree->root = iy;
    } else if (ix == tree->left[tree->prnt[ix]]) {
        tree->left[tree->prnt[ix]] = iy;
    } else {
        tree->rite[tree->prnt[ix]] = iy;
    }

    /* put ix on iy's left */
    tree->left[iy] = ix;
    tree->prnt[ix] = iy;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtRotateRite - rotate Nodes to the rite                             *
 *                                                                      *
 ************************************************************************
 */

static void
rbtRotateRite(rbt_T   *tree,            /* (in)  pointer to RBT */
              int     inode)            /* (in)  node to rotate to the rite */
{
    int ix, iy;

    ROUTINE(rbtRotateRite);

    /* --------------------------------------------------------------- */

    ix = inode;
    iy = tree->left[ix];

    /* turn iy's rite subTree into ix's left subTree */
    tree->left[ix] = tree->rite[iy];

    if (tree->rite[iy] >= 0) {
        tree->prnt[tree->rite[iy]] = ix;
    }

    /* link ix's parent to iy */
    tree->prnt[iy] = tree->prnt[ix];

    if (tree->prnt[ix] == -1) {
        tree->root = iy;
    } else if (ix == tree->rite[tree->prnt[ix]]) {
        tree->rite[tree->prnt[ix]] = iy;
    } else {
        tree->left[tree->prnt[ix]] = iy;
    }

    /* put ix on iy's rite */
    tree->rite[iy] = ix;
    tree->prnt[ix] = iy;
}


/*
 ************************************************************************
 *                                                                      *
 * rbtSearch - search for Node in Tree                                  *
 *                                                                      *
 ************************************************************************
 */

static int
rbtSearch(rbt_T   *tree,                /* (in)  pointer to RBT */
          int     key1,                 /* (in)  first  key */
          int     key2,                 /* (in)  second key */
          int     key3,                 /* (in)  third  key */
          int     key4)                 /* (in)  fourth key */
{
    int       status = SUCCESS;         /* (out) return status */

    int ix, ians;

    ROUTINE(rbtSearch);

    /* --------------------------------------------------------------- */

    /* check for valid Tree */
    if (tree == NULL) {
        status = OCSM_ILLEGAL_ARGUMENT;
        goto cleanup;
    }

    /* start at the Root of the Tree */
    ix = tree->root;

    /* iteratively descend the Tree, moving left or rite depending on
          the relative location of the key with the keys in the Tree */
    while(ix >= 0) {
        ians = rbtCompareKeys(key1, tree->key1[ix],
                              key2, tree->key2[ix],
                              key3, tree->key3[ix],
                              key4, tree->key4[ix]);
        if        (ians < 0) {
            ix = tree->left[ix];
        } else if (ians > 0) {
            ix = tree->rite[ix];
        } else {
            break;
        }
    }

    status = ix;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   recycleBody - recycle a Body if its arguments are unchanged        *
 *                                                                      *
 ************************************************************************
 */

static int
recycleBody(modl_T *modl,               /* (in)  pointer to MODL */
            int    ibrch,               /* (in)  Branch index (1:nbrch) */
            int    brtype,              /* (in)  Branch type */
            varg_T args[],              /* (in)  array  of arguments */
            int    hasdots)             /* (in)  =1 if any arguments have non-zero dots */
{
    int       status = SUCCESS;         /* (out) return status or 1 if successful recycling */

    int       iarg, ival, nattr, iattr, attrType, attrLen, ipmtr;
    int       oclass, mtype, nchild, *senses, ileft, irite, igroup, botype;
    int       ibody, jbody, okay, numRemaining;
    CINT      *tempIlist;
    double    *values=NULL, *dots=NULL, data[4];
    CDOUBLE   *tempRlist;
    char      *csysname=NULL, filename[80];
    char      argname[MAX_NAME_LEN], attrname[MAX_NAME_LEN];
    CCHAR     *tempClist, *aname;
    ego       emodel, eref, *echilds, ebody;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(recycleBody);

    /* --------------------------------------------------------------- */

    /* if loadEgads is set, read the file now (if it exists) */
    if (MODL->loadEgads > 0) {

        /* read the file */
        ibody = MODL->nbody + 1;
        snprintf(filename, 80, "Body_%06d.egads", ibody);

        (void) EG_setOutLevel(MODL->context, 0);
        status = EG_loadModel(MODL->context, 0, filename, &emodel);
        (void) EG_setOutLevel(MODL->context, outLevel);
        if (status != SUCCESS) {
            status = SUCCESS;
            goto cleanup;
        }

        SPRINT1(1, "<-- loaded %s", filename);

        /* get Body from Model */
        status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        if (status < SUCCESS || oclass != MODEL || nchild != 1) {
            SPRINT3(1, "WARNING:: status=%d, oclass=%d, nchild=%d",
                    status, oclass, nchild);

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          =  0;
            goto cleanup;
        }

        /* make sure .csm filenames match the file */
        status = EG_attributeRet(echilds[0], "__filename__", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrType == ATTRSTRING) {
            if (strcmp(MODL->brch[ibrch].filename, (char*)tempClist) != 0) {
                SPRINT1(1, "WARNING:: Filename in file (%s) does not match", tempClist);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                (MODL->nwarn)++;
                MODL->loadEgads = -1;
                status          =  SUCCESS;
                goto cleanup;
            }
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __filename__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          = SUCCESS;
            goto cleanup;
        }

        /* make sure Branch types match the file */
        status = EG_attributeRet(echilds[0], "__brtype__", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrType == ATTRINT && attrLen == 1) {
            if (tempIlist[0] != brtype) {
                SPRINT1(1, "WARNING:: Branch type in file (%s) does not match",
                        ocsmGetText(tempIlist[0]));

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                (MODL->nwarn)++;
                MODL->loadEgads = -1;
                status          =  SUCCESS;
                goto cleanup;
            }
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __brtype__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          = SUCCESS;
            goto cleanup;
        }

        /* make sure Branch arguments match the file */
        for (iarg = 1; iarg <= 9; iarg++) {
            snprintf(argname, MAX_NAME_LEN, "__arg%d__", iarg);
            (void) EG_setOutLevel(MODL->context, 0);
            status = EG_attributeRet(echilds[0], argname, &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            (void) EG_setOutLevel(MODL->context, outLevel);
            if (status == SUCCESS && iarg > MODL->brch[ibrch].narg) {
                SPRINT2(1, "WARNING:: more arguments in file (%d) than current Branch (%d)",
                        iarg, MODL->brch[ibrch].narg);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                (MODL->nwarn)++;
                MODL->loadEgads = -1;
                status          =  SUCCESS;
                goto cleanup;
            } else if (status == SUCCESS && attrType == ATTRREAL) {
                if (attrLen != args[iarg].nval) {
                    SPRINT3(1, "WARNING:: attrLen=%d does not match args[%d].nval=%d",
                            attrLen, iarg, args[iarg].nval);

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                    (MODL->nwarn)++;
                    MODL->loadEgads = -1;
                    status          =  SUCCESS;
                    goto cleanup;
                }
                for (ival = 0; ival < attrLen; ival++) {
                    if (fabs(tempRlist[ival]-args[iarg].val[ival]) > EPS06) {
                        SPRINT6(1, "WARNING:: args[%d].val[%d]=%12.6f but %s[%d]=%12.6f",
                                iarg, ival, args[iarg].val[ival], argname, ival, tempRlist[ival]);

                        status = EG_deleteObject(emodel);
                        CHECK_STATUS(EG_deleteObject);

                        (MODL->nwarn)++;
                        MODL->loadEgads = -1;
                        status          =  SUCCESS;
                        goto cleanup;
                    }
                }
            } else if (status == SUCCESS && attrType == ATTRSTRING) {
                if (strcmp(tempClist, args[iarg].str) != 0) {
                    SPRINT4(1, "WARNING:: arg[%d].str=%s but %s=%s",
                            iarg, args[iarg].str, argname, tempClist);

                    status = EG_deleteObject(emodel);
                    CHECK_STATUS(EG_deleteObject);

                    (MODL->nwarn)++;
                    MODL->loadEgads = -1;
                    status          =  SUCCESS;
                    goto cleanup;
                }
            } else if (status != SUCCESS && MODL->brch[ibrch].narg > iarg) {
                SPRINT2(1, "WARNING:: more arguments in current Branch (%d) than file (%d)",
                        MODL->brch[ibrch].narg, iarg);

                status = EG_deleteObject(emodel);
                CHECK_STATUS(EG_deleteObject);

                (MODL->nwarn)++;
                MODL->loadEgads = -1;
                status          =  SUCCESS;
                goto cleanup;
            }
        }

        /* pull out other Attributes needed to create the new Body */
        status = EG_attributeRet(echilds[0], "__ileft__", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrType == ATTRINT && attrLen == 1) {
            ileft  = tempIlist[0];
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __ileft__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          =  SUCCESS;
            goto cleanup;
        }

        status = EG_attributeRet(echilds[0], "__irite__", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrType == ATTRINT && attrLen == 1) {
            irite  = tempIlist[0];
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __irite__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          =  SUCCESS;
            goto cleanup;
        }

        status = EG_attributeRet(echilds[0], "__igroup__", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrType == ATTRINT && attrLen == 1) {
            igroup = tempIlist[0];
        } else {
            SPRINT0(1, "WARNING:: file does not have the attribute __igroup__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          = SUCCESS;
            goto cleanup;
        }

        status = EG_attributeRet(echilds[0], "__botype__", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrType == ATTRINT && attrLen == 1) {
            botype = tempIlist[0];
        } else {
            SPRINT0(1, "WARNING:: file does not have attribute __botype__");

            status = EG_deleteObject(emodel);
            CHECK_STATUS(EG_deleteObject);

            (MODL->nwarn)++;
            MODL->loadEgads = -1;
            status          =  SUCCESS;
            goto cleanup;
        }

        /* create the new Body */
        status = newBody(MODL, ibrch, brtype, ileft, irite, args,
                         hasdots, botype, &ibody);
        CHECK_STATUS(newBody);

        MODL->body[ibody].igroup = igroup;

        status = EG_copyObject(echilds[0], NULL, &ebody);
        CHECK_STATUS(EG_copyObject);

        /* remove temporary Attributes */
        status = EG_attributeDel(ebody, "__ibrch__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__ileft__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__irite__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__igroup__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__botype__");
        CHECK_STATUS(EG_attributeDel);

        status = EG_attributeDel(ebody, "__brtype__");
        CHECK_STATUS(EG_attributeDel);

        /* note: __filename__ is not deleted here so that finishBody
           can determine if teh Body came from a Body_xxxxxx.egads
           file.  finishBody removes __filename__ at the end */

        (void) EG_setOutLevel(MODL->context, 0);
        (void) EG_attributeDel(ebody, "__arg1__");
        (void) EG_attributeDel(ebody, "__arg2__");
        (void) EG_attributeDel(ebody, "__arg3__");
        (void) EG_attributeDel(ebody, "__arg4__");
        (void) EG_attributeDel(ebody, "__arg5__");
        (void) EG_attributeDel(ebody, "__arg6__");
        (void) EG_attributeDel(ebody, "__arg7__");
        (void) EG_attributeDel(ebody, "__arg8__");
        (void) EG_attributeDel(ebody, "__arg9__");
        (void) EG_setOutLevel(MODL->context, outLevel);

        /* set up returns from UDPs and UDFs */
        status = EG_attributeNum(ebody, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = nattr; iattr >= 1; iattr--) {
            status = EG_attributeGet(ebody, iattr, &aname, &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            if (strncmp(aname, "__@@", 4) == 0) {
                strcpy(attrname, &(aname[2]));
                attrname[STRLEN(attrname)-2] = '\0';
                status = ocsmFindPmtr(MODL, attrname, OCSM_LOCALVAR, attrLen, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                if        (attrType == ATTRINT) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, (double)tempIlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (attrType == ATTRREAL) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1,         tempRlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (attrType == ATTRSTRING) {
                    status =  ocsmSetValu(MODL, ipmtr, 1, 1, (char *)tempClist   );
                    CHECK_STATUS(ocsmSetValu);
                }
            }

            MODL->bodyLoaded = ibody;
        }

        if (botype != OCSM_SKETCH) {
            MODL->body[ibody].ebody = ebody;
        }

        status = setupAtPmtrs(MODL, 0);
        CHECK_STATUS(setupAtPmtrs);

        status = finishBody(MODL, ibody);
        CHECK_STATUS(finishBody);

        status = EG_deleteObject(emodel);
        CHECK_STATUS(EG_deleteObject);

        SPRINT2(1, "                          Body   %4d loaded from \"%s\"",
                ibody, filename);

        /* if a dummy Body associated with a Sketch, delete it now */
        if (botype == OCSM_SKETCH) {
            status = EG_deleteObject(ebody);
            CHECK_STATUS(EG_deleteObject);

        /* if there are more Bodys remaining because Branch created more
           than one Body (such as OCSM_UNION with toMark=1), keep reading */
        } else {
            status = EG_attributeRet(ebody, "__numRemaining__", &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS && attrType == ATTRINT && attrLen == 1) {
                numRemaining = tempIlist[0];

                if (numRemaining > 0) {
                    status = recycleBody(modl, ibrch, brtype, args, hasdots);
                    return status;
                }
            }
        }

        status = 1;
        goto cleanup;
    }

    /**********************************************************/
    /* we are not reading from a file, but rather from memory */
    /**********************************************************/

    /* if we have exhaused the recycling, return status=0 (to signify
       that an old Body was not recycled) */
    if (MODL->nbody+1 > MODL->recycle) {
        status = SUCCESS;
        goto cleanup;
    }

    /* by default use the next Body */
    ibody = MODL->nbody + 1;

    /* if a OCSM_UNION and toMark==1, find the last Body that matches ibrch */
    if (brtype == OCSM_UNION && NINT(args[1].val[0]) == 1) {
        while ((ibody+1) <= MODL->recycle) {
            if (MODL->body[ibody+1].ibrch  == ibrch) {
                SPRINT1(0, "                          ... skipping Body %4d", ibody);
                ibody++;
            } else {
                break;
            }
        }
    }

    /* make sure that the next Body's Branch can be recycled.  it
       cannot under the following circumstances: */
    okay = 1;

    /* if the ibrch or brtype is not the expected one (this can happen if
       a previously suppressed Branch has been activated), we need to rebuild */
    if (MODL->body[ibody].ibrch  != ibrch) {
        SPRINT3(1, "WARNING:: recycling stopped: MODL->body[%d].ibrch=%d, ibrch=%d",
                ibody, MODL->body[ibody].ibrch, ibrch);
        okay = 0;
    } else if (MODL->body[ibody].brtype != brtype) {
        SPRINT3(1, "WARNING:: recycling stopped: MODL->body[%d].brtype=%d, brtype=%d",
                ibody, MODL->body[ibody].brtype, brtype);
        okay = 0;
    }

    /* if the value of any of the arguments has changed, we need to rebuild */
    for (iarg = 1; iarg < 10; iarg++) {
        if (okay == 0) break;

        if (MODL->body[ibody].arg[iarg].nval != args[iarg].nval) {
            SPRINT5(1, "WARNING:: recycling stopped: MODL->body[%d].arg[%d].nval=%d, args[%d].nval=%d",
                    ibody, iarg, MODL->body[ibody].arg[iarg].nval, iarg, args[iarg].nval);
            okay = 0;
            break;
        }

        for (ival = 0; ival < args[iarg].nval; ival++) {
            if (MODL->body[ibody].arg[iarg].val[ival] != args[iarg].val[ival]) {
                SPRINT7(1, "WARNING:: recycling stopped: MODL->body[%d].arg[%d].val[%d]=%f, args[%d].val[%d]=%f\n",
                        ibody, iarg, ival, MODL->body[ibody].arg[iarg].val[ival], iarg, ival, args[iarg].val[ival]);
                okay = 0;
                break;
            }
        }
    }

    /* if a UDPRIM and any of the arguments of any of its associated udparg's
       arguments have changed, we need to rebuild */
    if (okay == 1) {
        if (MODL->body[ibody].brtype == OCSM_UDPRIM) {
            for (jbody = ibody-1; jbody > 0; jbody--) {
                if (MODL->body[jbody].brtype != OCSM_UDPARG) break;

                if (MODL->body[jbody].hasdots == 2) {
                    SPRINT2(1, "WARNING:: recycling stopped: MODL->body[%d].hasdots=%d",
                            jbody, MODL->body[jbody].hasdots);
                    okay = 0;
                    break;
                }
            }
        }
    }

    /* free up all Bodys starting at ibody */
    if (okay == 0) {
        for (jbody = ibody; jbody <= MODL->recycle; jbody++) {
            status = removeVels(MODL, jbody);
            CHECK_STATUS(removeVels);

            ibrch = MODL->body[jbody].ibrch;

            status = freeBody(MODL, jbody);
            CHECK_STATUS(freeBody);

            if (MODL->body[jbody].etess != NULL) {
                status = EG_deleteObject(MODL->body[jbody].etess);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[jbody].etess = NULL;
            }

            if (MODL->body[jbody].eetess != NULL) {
                status = EG_deleteObject(MODL->body[jbody].eetess);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[jbody].eetess = NULL;
            }

            if (MODL->body[jbody].eebody != NULL) {
                status = EG_deleteObject(MODL->body[jbody].eebody);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[jbody].eebody = NULL;
            }

            if (MODL->body[jbody].ebody != NULL) {
                if (ibrch > 0 && ibrch <= MODL->nbrch) {
                    if (MODL->brch[ibrch].type == OCSM_UDPRIM) {
                        status = udp_clean(&(MODL->brch[ibrch].arg1[1]), MODL->body[jbody].ebody);
                        if (status == EGADS_NOTFOUND || status == EGADS_NOTMODEL) {
                            /* this means that some other Body probably cleaned up this udp
                               or that this is a user-defined component (udc) */
                        } else {
                            CHECK_STATUS(udp_clean);
                        }
                    }
                }

                status = EG_deleteObject(MODL->body[jbody].ebody);
                CHECK_STATUS(EG_deleteObject);

                MODL->body[jbody].ebody = NULL;
            }
        }

        MODL->recycle = ibody;

        /* return status=0 (to signify that an old Body was not recycled) */
        status = SUCCESS;
        goto cleanup;
    }

    /* set up returns from UDPs and UDFs */
    /*@ignore@*/
    ebody = MODL->body[ibody].ebody;
    /*@end@*/

    if (ebody != NULL) {
        status = EG_attributeNum(ebody, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = nattr; iattr >= 1; iattr--) {
            status = EG_attributeGet(ebody, iattr, &aname, &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            if (strncmp(aname, "__@@", 4) == 0) {
                strcpy(attrname, &(aname[2]));
                attrname[STRLEN(attrname)-2] = '\0';
                status = ocsmFindPmtr(MODL, attrname, OCSM_LOCALVAR, attrLen, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                if        (attrType == ATTRINT) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, (double)tempIlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (attrType == ATTRREAL) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1,         tempRlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (attrType == ATTRSTRING) {
                    status =  ocsmSetValu(MODL, ipmtr, 1, 1, (char *)tempClist   );
                    CHECK_STATUS(ocsmSetValu);
                }
            }
        }
    }

    /* increment number of Bodys */
    MODL->nbody = ibody;
    SPRINT1(1, "                          Body   %4d recycled", MODL->nbody);

    /* store the velocities (since they may have changed even though
       the arguments may not have changed) */
    MODL->body[ibody].hasdots = hasdots;

    for (iarg = 1; iarg < 10; iarg++) {
        for (ival = 0; ival < args[iarg].nval; ival++) {
            MODL->body[ibody].arg[iarg].dot[ival] = args[iarg].dot[ival];
        }
    }

    /* update the Group number */
    MODL->ngroup++;

    /* reset the selection */
    MODL->seltype = -1;
    MODL->selbody = ibody;

    /* reset flag so that mass properties are computed again */
    MODL->hasMPs = 0;

    /* set up returns from UDPs and UDFs */
    if (ebody != NULL) {
        status = EG_attributeNum(ebody, &nattr);
        CHECK_STATUS(EG_attributeNum);

        for (iattr = nattr; iattr >= 1; iattr--) {
            status = EG_attributeGet(ebody, iattr, &aname, &attrType, &attrLen,
                                     &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeGet);

            if (strncmp(aname, "__@@", 4) == 0) {
                strcpy(attrname, &(aname[2]));
                attrname[STRLEN(attrname)-2] = '\0';
                status = ocsmFindPmtr(MODL, attrname, OCSM_LOCALVAR, attrLen, 1, &ipmtr);
                CHECK_STATUS(ocsmFindPmtr);

                if        (attrType == ATTRINT) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1, (double)tempIlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (attrType == ATTRREAL) {
                    status = ocsmSetValuD(MODL, ipmtr, 1, 1,         tempRlist[0]);
                    CHECK_STATUS(ocsmSetValuD);
                } else if (attrType == ATTRSTRING) {
                    status =  ocsmSetValu(MODL, ipmtr, 1, 1, (char *)tempClist   );
                    CHECK_STATUS(ocsmSetValu);
                }
            }
        }
    }

    status = setupAtPmtrs(MODL, 1);
    CHECK_STATUS(setupAtPmtrs);

    /* recycle other Bodys if there are any remaining */
    if (ebody != NULL) {
        status = EG_attributeRet(ebody, "__numRemaining__", &attrType, &attrLen,
                                 &tempIlist, &tempRlist, &tempClist);
        if (status == SUCCESS && attrType == ATTRINT && attrLen == 1) {
            numRemaining = tempIlist[0];

            if (numRemaining > 0) {
                status = recycleBody(modl, ibrch, brtype, args, hasdots);
                return status;
            }
        }
    }

    /* return status=1 (to signify that an old Body WAS recycled) */
    status = 1;

cleanup:
    FREE(csysname);
    FREE(values);
    FREE(dots  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   removeFaceAttributes - remove Face Attributes that start with . or _ *
 *                                                                      *
 ************************************************************************
 */

static int
removeFaceAttributes(ego    ebody)      /* (in)  pointer to Body */
{
    int       status = SUCCESS;         /* (out) return status */

    int       nface, iface, nattr, iattr, attrType, attrLen;
    CINT      *tempIlist;
    CDOUBLE   *tempRlist;
    CCHAR     *aname, *tempClist;
    ego       *efaces;

    ROUTINE(removeFaceAttributes);

    /* --------------------------------------------------------------- */

    status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (efaces != NULL) {
        for (iface = 0; iface < nface; iface++) {
            status = EG_attributeNum(efaces[iface], &nattr);
            CHECK_STATUS(EG_attributeNum);

            for (iattr = nattr; iattr >= 1; iattr--) {
                status = EG_attributeGet(efaces[iface], iattr, &aname, &attrType, &attrLen,
                                         &tempIlist, &tempRlist, &tempClist);
                CHECK_STATUS(EG_attributeGet);

                if (aname[0] == '.' || aname[0] == '_') {
                    status = EG_attributeDel(efaces[iface], aname);
                    CHECK_STATUS(EG_attributeDel);
                }
            }
        }

        EG_free(efaces);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   removePerturbation - remove a perturbation if it exists            *
 *                                                                      *
 ************************************************************************
 */

static int
removePerturbation(modl_T *modl)        /* (in)  pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(removePerturbation);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* if this has a perturbed Body, free it and reset data */
    if (MODL->perturb != NULL) {
        status = ocsmFree(MODL->perturb);
        CHECK_STATUS(ocsmFree);

        MODL->perturb = NULL;
        MODL->dtime   = 0;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   removeVels - remove velocity information                           *
 *                                                                      *
 ************************************************************************
 */

int
removeVels(modl_T *modl,                /* (in)  pointer to MODL */
           int    ibody)                /* (in)  Body index (1:nbody)  or 0 for all*/

{
    int       status = SUCCESS;         /* (out) return status */

    int       jbody, inode, iedge, iface;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(removeVels);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* quick return if ibody has no .dxyz entries */
    if (ibody > 0 && MODL->body[ibody].hasdxyz == 0) {
        if (MODL->body[ibody].hassens != 0) {
            SPRINT1(2, "resetting .hassens for ibody=%d", ibody);

            if (MODL->body[ibody].ebody != NULL) {
                status = EG_setGeometry_dot(MODL->body[ibody].ebody, 0, 0,  NULL, NULL, NULL);
                CHECK_STATUS(EG_setGeometry_dot);
            }

            MODL->body[ibody].hassens = 0;
        }
        goto cleanup;
    }

    /* remove storage for selected Bodys */
    for (jbody = 1; jbody <= MODL->nbody; jbody++) {
        if (ibody != 0 && jbody != ibody) continue;

        if (MODL->body[jbody].hasdxyz != 0) {

            if (MODL->body[jbody].node != NULL) {
                for (inode = 1; inode <= MODL->body[jbody].nnode; inode++) {
                    FREE(MODL->body[jbody].node[inode].dxyz);
                }
            }

            if (MODL->body[jbody].edge != NULL) {
                for (iedge = 1; iedge <= MODL->body[jbody].nedge; iedge++) {
                    FREE(MODL->body[jbody].edge[iedge].dt  );
                    FREE(MODL->body[jbody].edge[iedge].dxyz);
                }
            }

            if (MODL->body[jbody].face != NULL) {
                for (iface = 1; iface <= MODL->body[jbody].nface;iface++) {
                    FREE(MODL->body[jbody].face[iface].duv );
                    FREE(MODL->body[jbody].face[iface].dxyz);
                }
            }
        }

        if (MODL->body[jbody].hassens != 0) {
            SPRINT1(2, "resetting .hassens for jbody=%d", jbody);

            if (MODL->body[jbody].ebody != NULL) {
                status = EG_setGeometry_dot(MODL->body[jbody].ebody, 0, 0,  NULL, NULL, NULL);
                CHECK_STATUS(EG_setGeometry_dot);
            }

            MODL->body[jbody].hassens = 0;
        }

        MODL->body[jbody].hasdxyz = 0;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   reorderLoops - reorder Loops to improve rules and blends           *
 *                                                                      *
 ************************************************************************
 */

static int
reorderLoops(modl_T *modl,              /* (in)  pointer to MODL */
             int    nloop,              /* (in)  number of Loops */
             ego    eloops[],           /* (both)array  of Loops */
             int    startFrom)          /* (in)  +1 to start at beg, -1 to start at end, 0 to return */

{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int      iloop, jloop, iedge, jedge, itest, ishift, modified, sense, i, j;
    int      oclassi, oclassj, oclassk, oclassg, mtypei, mtypej, mtypek, mtypeg, nedgei, nedgej, nedgek;
    int      *sensesi, *sensesj, *sensesk, nnode, *sensesnew=NULL;
    double   uvlimitsi[4], uvlimitsj[4], uvlimitsk[4], data[18], *xyzi=NULL, *xyzj=NULL;
    double   areai[3], areaj[3], dotprod, ltest, ltest0, ltest1, lshift;
    ego      erefi, erefj, erefk, erefg, *eedgesi, *eedgesj, *eedgesk;
    ego      *enodes, *elist, *eedgesnew=NULL, etemp;

    ROUTINE(reorderLoops);

    /* --------------------------------------------------------------- */

    if (outLevel >= 3) {
        for (iloop = 0; iloop < nloop; iloop++) {
            SPRINT1(3, "at beg of reorderLoops: eloops[%d]", iloop);
            ocsmPrintEgo(eloops[iloop]);
        }
    }

    /* extract just the Loop for interior Xsects and convert bounding
       WireBodys into Loops */
    for (iloop = 0; iloop < nloop; iloop++) {
        status = EG_getTopology(eloops[iloop], &erefi,
                                &oclassi, &mtypei, uvlimitsi, &nedgei, &eedgesi, &sensesi);
        CHECK_STATUS(EG_getTopology);

        /* if a Loop, leave alone */
        if (oclassi == LOOP) {

        /* if a Node, leave alone */
        } else if (oclassi == NODE) {

        /* if an interior Face, convert to Loop */
        } else if (oclassi == FACE) {
            if (iloop > 0 && iloop < nloop-1) {
                eloops[iloop] = eedgesi[0];
            }

        /* if a WireBody, convert to Loop */
        } else if (oclassi == BODY && mtypei == WIREBODY) {
            eloops[iloop] = eedgesi[0];

        /* not a recognized  type */
        } else {
            signalError(MODL, OCSM_WRONG_TYPES_ON_STACK,
                        "Sketch %d is not FACE, NODE, or WireBody", iloop);
            status = OCSM_WRONG_TYPES_ON_STACK;
            goto cleanup;
        }
    }

    /* the base Xsect (which will not be modified) is at either end */
    if (startFrom == 0) {
        goto cleanup;
    } else if (startFrom > 0) {
        iloop = 0;
    } else {
        iloop = nloop - 1;
    }

    /* process each pair of Xsects in turn */
    while (1) {
        if (startFrom > 0) {
            jloop = iloop + 1;
            if (jloop >= nloop) break;
        } else {
            jloop = iloop - 1;
            if (jloop < 0) break;
        }
        modified = 0;

        /* get info on iloop */
        status = EG_getTopology(eloops[iloop], &erefi,
                                &oclassi, &mtypei, uvlimitsi, &nedgei, &eedgesi, &sensesi);
        CHECK_STATUS(EG_getTopology);

        if (oclassi == FACE) {
            etemp  = eedgesi[0];
            status = EG_getTopology(etemp, &erefi,
                                    &oclassi, &mtypei, uvlimitsi, &nedgei, &eedgesi, &sensesi);
            CHECK_STATUS(EG_getTopology);
        }

        /* get info on jloop */
        status = EG_getTopology(eloops[jloop], &erefj,
                                &oclassj, &mtypej, uvlimitsj, &nedgej, &eedgesj, &sensesj);
        CHECK_STATUS(EG_getTopology);

        if (oclassj == FACE) {
            etemp  = eedgesj[0];
            status = EG_getTopology(etemp, &erefj,
                                    &oclassj, &mtypej, uvlimitsj, &nedgej, &eedgesj, &sensesj);
            CHECK_STATUS(EG_getTopology);
        }

        if (oclassi != LOOP   || oclassj != LOOP  ) {
            iloop = jloop;
            continue;
        }

        /* make sure the Loops are either both OPEN or CLOSED */
        if (mtypei != mtypej) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "Loops %d and %d are different mtypes", iloop, jloop);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

        /* make sure that Loops have same number of Edges */
        if (nedgei != nedgej) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "Loop %d has %d Edges, but Loop %d has %d Edges", iloop, nedgei, jloop, nedgej);
            SPRINT1(0, "eloops[iloop] has %d Edges", nedgei);
            ocsmPrintEgo(eloops[iloop]);
            SPRINT1(0, "eloops[jloop] has %d Edges", nedgej);
            ocsmPrintEgo(eloops[jloop]);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        } else if (nedgei < 1) {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "Loop %d only has %d Edges", iloop, nedgei);
            status = OCSM_INTERNAL_ERROR;
            SPRINT1(0, "eloops[iloop] has %d Edges", nedgei);
            ocsmPrintEgo(eloops[iloop]);
            goto cleanup;
        }

        nedgej = nedgei;

        /* set up the coordinates at the Nodes and midpoints in the two Loops */
        MALLOC(xyzi, double, 6*nedgei+3);
        MALLOC(xyzj, double, 6*nedgej+3);

        for (iedge = 0; iedge < nedgei; iedge++) {
            status = EG_getTopology(eedgesi[iedge], &erefk,
                                    &oclassk, &mtypeg, uvlimitsk, &nnode, &enodes, &sensesk);
            CHECK_STATUS(EG_getTopology);

            if (sensesi[iedge] > 0) {
                status = EG_getTopology(enodes[0], &erefk,
                                        &oclassk, &mtypek, &(xyzi[6*iedge]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            } else {
                status = EG_getTopology(enodes[1], &erefk,
                                        &oclassk, &mtypek, &(xyzi[6*iedge]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            }

            if (mtypeg != DEGENERATE) {
                uvlimitsk[2] = (uvlimitsk[0] + uvlimitsk[1]) / 2;

                status = EG_evaluate(eedgesi[iedge], &uvlimitsk[2], data);
                CHECK_STATUS(EG_evaluate);

                xyzi[6*iedge+3] = data[0];
                xyzi[6*iedge+4] = data[1];
                xyzi[6*iedge+5] = data[2];
            } else {
                xyzi[6*iedge+3] = xyzi[3*iedge  ];
                xyzi[6*iedge+4] = xyzi[3*iedge+1];
                xyzi[6*iedge+5] = xyzi[3*iedge+2];
            }
        }

        if (mtypei == OPEN) {
            if (sensesi[nedgei-1] > 0) {
                status = EG_getTopology(enodes[1], &erefk,
                                        &oclassk, &mtypek, &(xyzi[6*nedgei]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            } else {
                status = EG_getTopology(enodes[0], &erefk,
                                        &oclassk, &mtypek, &(xyzi[6*nedgei]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            }
        }

        for (iedge = 0; iedge < nedgej; iedge++) {
            status = EG_getTopology(eedgesj[iedge], &erefk,
                                    &oclassk, &mtypeg, uvlimitsk, &nnode, &enodes, &sensesk);
            CHECK_STATUS(EG_getTopology);

            if (sensesj[iedge] > 0) {
                status = EG_getTopology(enodes[0], &erefk,
                                        &oclassk, &mtypek, &(xyzj[6*iedge]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            } else {
                status = EG_getTopology(enodes[1], &erefk,
                                        &oclassk, &mtypek, &(xyzj[6*iedge]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            }

            if (mtypeg != DEGENERATE) {
                uvlimitsk[2] = (uvlimitsk[0] + uvlimitsk[1]) / 2;

                status = EG_evaluate(eedgesj[iedge], &uvlimitsk[2], data);
                CHECK_STATUS(EG_evaluate);

                xyzj[6*iedge+3] = data[0];
                xyzj[6*iedge+4] = data[1];
                xyzj[6*iedge+5] = data[2];
            } else {
                xyzj[6*iedge+3] = xyzj[3*iedge  ];
                xyzj[6*iedge+4] = xyzj[3*iedge+1];
                xyzj[6*iedge+5] = xyzj[3*iedge+2];
            }
        }

        if (mtypej == OPEN) {
            if (sensesi[nedgej-1] > 0) {
                status = EG_getTopology(enodes[1], &erefk,
                                        &oclassk, &mtypek, &(xyzj[6*nedgej]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            } else {
                status = EG_getTopology(enodes[0], &erefk,
                                        &oclassk, &mtypek, &(xyzj[6*nedgej]), &nnode, &elist, &sensesk);
                CHECK_STATUS(EG_getTopology);
            }
        }

        /* if the Loops are open, flip if distances can be reduced by
           flipping jloop */
        if (mtypei == OPEN ||mtypej == OPEN) {
            ltest0 = 0;
            ltest1 = 0;
            for (i = 0; i < 2*nedgei+1; i++) {
                j = 2*nedgei - i;

                ltest0 += sqrt((xyzi[3*i  ]-xyzj[3*i  ]) * (xyzi[3*i  ]-xyzj[3*i  ])
                              +(xyzi[3*i+1]-xyzj[3*i+1]) * (xyzi[3*i+1]-xyzj[3*i+1])
                              +(xyzi[3*i+2]-xyzj[3*i+2]) * (xyzi[3*i+2]-xyzj[3*i+2]));
                ltest1 += sqrt((xyzi[3*i  ]-xyzj[3*j  ]) * (xyzi[3*i  ]-xyzj[3*j  ])
                              +(xyzi[3*i+1]-xyzj[3*j+1]) * (xyzi[3*i+1]-xyzj[3*j+1])
                              +(xyzi[3*i+2]-xyzj[3*j+2]) * (xyzi[3*i+2]-xyzj[3*j+2]));
            }

            if (ltest1 < ltest0) {
                SPRINT1(1, "WARNING:: reversing Loop %d", jloop);
                (MODL->nwarn)++;
                modified++;

                status = EG_flipObject(eloops[jloop], &etemp);
                CHECK_STATUS(EG_flipObject);

                eloops[jloop] = etemp;
            }

            iloop = jloop;
            continue;
        }

        /* find the area of iloop and jloop */
        areai[0] = areai[1] = areai[2] = 0;
        areaj[0] = areaj[1] = areaj[2] = 0;

        for (iedge = 1; iedge < 2*nedgei-1; iedge++) {
            areai[0] += (xyzi[1] - xyzi[6*nedgei-2]) * (xyzi[3*iedge+2] - xyzi[6*nedgei-1])
                      - (xyzi[2] - xyzi[6*nedgei-1]) * (xyzi[3*iedge+1] - xyzi[6*nedgei-2]);
            areai[1] += (xyzi[2] - xyzi[6*nedgei-1]) * (xyzi[3*iedge  ] - xyzi[6*nedgei-3])
                      - (xyzi[0] - xyzi[6*nedgei-3]) * (xyzi[3*iedge+2] - xyzi[6*nedgei-1]);
            areai[2] += (xyzi[0] - xyzi[6*nedgei-3]) * (xyzi[3*iedge+1] - xyzi[6*nedgei-2])
                      - (xyzi[1] - xyzi[6*nedgei-2]) * (xyzi[3*iedge  ] - xyzi[6*nedgei-3]);

            areaj[0] += (xyzj[1] - xyzj[6*nedgej-2]) * (xyzj[3*iedge+2] - xyzj[6*nedgej-1])
                      - (xyzj[2] - xyzj[6*nedgej-1]) * (xyzj[3*iedge+1] - xyzj[6*nedgej-2]);
            areaj[1] += (xyzj[2] - xyzj[6*nedgej-1]) * (xyzj[3*iedge  ] - xyzj[6*nedgej-3])
                      - (xyzj[0] - xyzj[6*nedgej-3]) * (xyzj[3*iedge+2] - xyzj[6*nedgej-1]);
            areaj[2] += (xyzj[0] - xyzj[6*nedgej-3]) * (xyzj[3*iedge+1] - xyzj[6*nedgej-2])
                      - (xyzj[1] - xyzj[6*nedgej-2]) * (xyzj[3*iedge  ] - xyzj[6*nedgej-3]);
        }

        /* if the dot products of the areas is negative, flip the direction of jloop */
        dotprod = areai[0] * areaj[0] + areai[1] * areaj[1] + areai[2] * areaj[2];
        if (dotprod < 0) {
            SPRINT1(1, "WARNING:: reversing Loop %d", jloop);
            (MODL->nwarn)++;
            modified++;

            etemp  = eloops[jloop];
            status = EG_flipObject(etemp, &(eloops[jloop]));
            CHECK_STATUS(EG_flipObject);

            status = EG_getTopology(eloops[jloop], &erefj,
                                    &oclassj, &mtypej, uvlimitsj, &nedgej, &eedgesj, &sensesj);
            CHECK_STATUS(EG_getTopology);

            if (oclassj == FACE) {
                etemp  = eedgesj[0];
                status = EG_getTopology(etemp, &erefj,
                                        &oclassj, &mtypej, uvlimitsj, &nedgej, &eedgesj, &sensesj);
                CHECK_STATUS(EG_getTopology);
            }

            for (iedge = 0; iedge < nedgej; iedge++) {
                status = EG_getTopology(eedgesj[iedge], &erefk,
                                        &oclassk, &mtypek, uvlimitsk, &nnode, &enodes, &sensesk);
                CHECK_STATUS(EG_getTopology);

                if (sensesj[iedge] > 0) {
                    status = EG_getTopology(enodes[0], &erefk,
                                            &oclassk, &mtypek, &(xyzj[6*iedge]), &nnode, &elist, &sensesk);
                    CHECK_STATUS(EG_getTopology);
                } else {
                    status = EG_getTopology(enodes[1], &erefk,
                                            &oclassk, &mtypek, &(xyzj[6*iedge]), &nnode, &elist, &sensesk);
                    CHECK_STATUS(EG_getTopology);
                }
            }
        }

        /* find the shift of jloop that minimizes the distance between the Nodes of iloop
           and the Nodes of jloop */
        ishift = 0;
        lshift = HUGEQ;

        /* compute the sum of the distances for each candidate shift */
        for (itest = 0; itest < 2*nedgei; itest++) {

            ltest = 0;
            for (iedge = 0; iedge < 2*nedgei; iedge++) {
                jedge = (iedge + itest) % (2*nedgei);

                ltest += sqrt(SQR(xyzi[3*iedge  ]-xyzj[3*jedge  ])
                             +SQR(xyzi[3*iedge+1]-xyzj[3*jedge+1])
                             +SQR(xyzi[3*iedge+2]-xyzj[3*jedge+2]));
            }
            if (ltest < lshift) {
                ishift = itest / 2;
                lshift = ltest;
            }
        }

        /* create the new rotated Loop */
        if (ishift > 0) {
            SPRINT2(1, "WARNING:: shifting  Loop %d with ishift=%d", jloop, ishift);
            (MODL->nwarn)++;
            modified++;

            MALLOC(eedgesnew, ego, 2*nedgej);
            MALLOC(sensesnew, int, 2*nedgej);

            /* shift the Loop by ishift */
            for (iedge = 0; iedge < nedgej; iedge++) {
                jedge = (iedge + ishift) % nedgej;
                eedgesnew[iedge] = eedgesj[jedge];
                sensesnew[iedge] = sensesj[jedge];
            }

            status = EG_getTopology(eloops[jloop], &erefk,
                                    &oclassk, &mtypek, uvlimitsk, &nedgek, &eedgesk, &sensesk);
            CHECK_STATUS(EG_getTopology);

            if (oclassk == FACE) {
                status = EG_getGeometry(erefk, &oclassg, &mtypeg, &erefg, NULL, NULL);
                CHECK_STATUS(EG_getGeometry);

                if (mtypeg != PLANE) {
                    for (iedge = 0; iedge < nedgej; iedge++) {
                        jedge = (iedge + ishift) % nedgej;
                        eedgesnew[iedge+nedgej] = eedgesj[jedge+nedgej];
                    }
                }
            }

            /* make new Loop */
            status = EG_makeTopology(MODL->context, erefk, LOOP, CLOSED,
                                     NULL, nedgej, eedgesnew, sensesnew, &etemp);
            CHECK_STATUS(EG_makeTopology);

            FREE(sensesnew);
            FREE(eedgesnew);

            /* either store the new Loop or make a new Face (if the original jloop
               was a Face) */
            if (oclassk != FACE) {
                eloops[jloop] = etemp;
            } else {
                sense = SFORWARD;
                status = EG_makeTopology(MODL->context, erefk, FACE, mtypek,
                                         NULL, 1, &etemp, &sense, &(eloops[jloop]));
                CHECK_STATUS(EG_makeTopology);
            }
        }

        FREE(xyzj);
        FREE(xyzi);

        /* next iloop,jloop pair */
        iloop = jloop;
    }

cleanup:
    FREE(xyzj);
    FREE(xyzi);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   selectBody - select a Body from a Model                            *
 *                                                                      *
 ************************************************************************
 */

static int
selectBody(ego    emodel,               /* (in)  pointer to Model */
           char*  order,                /* (in)  order type */
           int    index)                /* (in)  index into list (1:nchild) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       i, j, imin, oclass, mtype, nchild, *senses;
    double    box[14], datamin, datamax, data2[4], *data=NULL;
    ego       eref, *ebodys;

    ROUTINE(selectBody);

    /* --------------------------------------------------------------- */

    status = EG_getTopology(emodel, &eref, &oclass, &mtype,
                            data2, &nchild, &ebodys, &senses);
    CHECK_STATUS(EG_getTopology);

    /* if nchild is just one, return the answer immediately */
    if (nchild == 1) {
        status = SUCCESS;
        goto cleanup;
    } else if (nchild < 1) {
        SPRINT2(1, "WARNING:: emodel(=%llx) has %d children", (long long)emodel, nchild);
        status = OCSM_INTERNAL_ERROR;
        goto cleanup;
    }

    /* make an array that has data based upon order.  note that we
       will always want to return the (index-1)'th smallest entry so that
       quantities that are to maximized are stored as negative value */

    MALLOC(data, double, nchild);

    if        (strcmp(order, "none") == 0 ||
               strcmp(order, "0")    == 0   ) {
        for (i = 0; i < nchild; i++) {
            data[i] = i;
        }
    } else if (strcmp(order, "xmin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = +box[0];
        }
    } else if (strcmp(order, "xmax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = -box[3];
        }
    } else if (strcmp(order, "ymin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = +box[1];
        }
    } else if (strcmp(order, "ymax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = -box[4];
        }
    } else if (strcmp(order, "zmin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = +box[2];
        }
    } else if (strcmp(order, "zmax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getBoundingBox(ebodys[i], box);
            CHECK_STATUS(EG_getBoundingBox);

            data[i] = -box[5];
        }
    } else if (strcmp(order, "amin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getMassProperties(ebodys[i], box);
            CHECK_STATUS(EG_getMassProperties);

            data[i] = +box[1];
        }
    } else if (strcmp(order, "amax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getMassProperties(ebodys[i], box);
            CHECK_STATUS(EG_getMassProperties);

            data[i] = -box[1];
        }
    } else if (strcmp(order, "vmin") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getMassProperties(ebodys[i], box);
            CHECK_STATUS(EG_getMassProperties);

            data[i] = +box[0];
        }
    } else if (strcmp(order, "vmax") == 0) {
        for (i = 0; i < nchild; i++) {
            status = EG_getMassProperties(ebodys[i], box);
            CHECK_STATUS(EG_getMassProperties);

            data[i] = -box[0];
        }
    } else {
        status = OCSM_ILLEGAL_TYPE;
        goto cleanup;
    }

    /* find the largest entry in data */
    datamax = data[0];
    for (i = 1; i < nchild; i++) {
        if (data[i] > datamax) datamax = data[i];
    }

    /* move the smallest index-1 entries to the end of the list */
    for (j = 0; j < index-1; j++) {
        datamin = data[0];
        imin    = 0;
        for (i = 1; i < nchild; i++) {
            if (data[i] < datamin) {
                datamin = data[i];
                imin    = i;
            }
        }

        data[imin] = (++datamax);
    }

    /* return the smallest entry in data */
    datamin = data[0];
    imin    = 0;
    for (i = 1; i < nchild; i++) {
        if (data[i] < datamin) {
            datamin = data[i];
            imin    = i;
        }
    }

    status = imin;

cleanup:
    FREE(data);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   setEgoAttribute - set Attribute(s) from Branch Attribute           *
 *                                                                      *
 ************************************************************************
 */

static int
setEgoAttribute(modl_T *modl,           /* (in)  pointer to MODL */
                int    ibrch,           /* (in)  Branch index (1:nbrch) or 0 */
                ego    eobject)         /* (in)  ego to get Attribute */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iattr, nval, nrow, ncol, ival;
    double    value, dot, *values=NULL, *dots=NULL;
    char      aname[MAX_STRVAL_LEN], str[MAX_STRVAL_LEN];
    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(setEgoAttribute);

    /* --------------------------------------------------------------- */

    /* global Attributes */
    if (ibrch == 0) {
        for (iattr = 0; iattr < MODL->nattr; iattr++) {
            if (MODL->attr[iattr].name[0] != '!') {
                strncpy(aname, MODL->attr[iattr].name, MAX_STRVAL_LEN);
            } else {
                status = str2val(&(MODL->attr[iattr].name[1]), MODL, &value, &dot, aname);
                CHECK_STATUS(str2val);

                if (STRLEN(aname) == 0) {
                    signalError(NULL, OCSM_ILLEGAL_ARGUMENT,
                                "Attribute name (%s) must evaluate to a string",
                                MODL->attr[iattr].name);
                    status = OCSM_ILLEGAL_ARGUMENT;
                    goto cleanup;
                }
            }

            SPRINT2x(2, "       setting global attribute %3d: %s -> ",
                     iattr, aname);

            /* global Attribute value is a string */
            if (MODL->attr[iattr].defn[0] == '$') {
                SPRINT1(2, "%s", &(MODL->attr[iattr].defn[1]));
                status = EG_attributeAdd(eobject, aname, ATTRSTRING,
                                         1, NULL, NULL, &(MODL->attr[iattr].defn[1]));
                CHECK_STATUS(EG_attributeAdd);

            /* global Attribute value comes from a Parameter or list of expressions */
            } else {
                status = str2vals(MODL->attr[iattr].defn, MODL, &nrow, &ncol, &values, &dots, str);
                CHECK_STATUS(str2vals);

                if (STRLEN(str) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                } else {
                    SPLINT_CHECK_FOR_NULL(values);
                    SPLINT_CHECK_FOR_NULL(dots  );

                    nval = nrow * ncol;

                    if (nval > 0) {
                        for (ival = 0; ival < nval; ival++) {
                            SPRINT1x(2, "%10.4f ", values[ival]);
                        }
                        SPRINT0(2, " ");
                        status = EG_attributeAdd(eobject, aname, ATTRREAL,
                                                 nval, NULL, values, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                        if (strcmp(aname, ".tParams") == 0) {
                            status = EG_attributeAdd(eobject, "_tParams", ATTRREAL,
                                                     nval, NULL, values, NULL);
                            CHECK_STATUS(EG_attributeAdd);
                        }

                        FREE(values);
                        FREE(dots  );
                    }
                }
            }
        }

    /* Branch Attributes and Csystems */
    } else {
        for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
            if (MODL->brch[ibrch].attr[iattr].name[0] != '!') {
                strncpy(aname, MODL->brch[ibrch].attr[iattr].name, MAX_STRVAL_LEN);
            } else {
                status = str2val(&(MODL->brch[ibrch].attr[iattr].name[1]), MODL, &value, &dot, aname);
                CHECK_STATUS(str2val);

                if (STRLEN(aname) == 0) {
                    signalError(NULL, OCSM_ILLEGAL_ARGUMENT,
                                "Attribute name (%s) must evaluate to a string",
                                MODL->brch[ibrch].attr[iattr].name);
                    status = OCSM_ILLEGAL_ARGUMENT;
                    goto cleanup;
                }
            }

            if        (MODL->brch[ibrch].attr[iattr].type == ATTRREAL) {
                SPRINT2x(2, "       setting branch attribute %3d: %s -> ",
                         iattr, aname);
            } else if (MODL->brch[ibrch].attr[iattr].type == ATTRCSYS) {
                SPRINT2x(2, "       setting branch csystem   %3d: %s -> ",
                         iattr, aname);
            }

            /* Branch Attribute value is a string */
            if (MODL->brch[ibrch].attr[iattr].defn[0] == '$'     &&
                MODL->brch[ibrch].attr[iattr].type    == ATTRREAL  ) {

                status = str2val(MODL->brch[ibrch].attr[iattr].defn, MODL, &value, &dot, str);
                CHECK_STATUS(str2val);

                SPRINT1(2, "%s", str);
                status = EG_attributeAdd(eobject, aname, ATTRSTRING,
                                         1, NULL, NULL, str);
                CHECK_STATUS(EG_attributeAdd);

            /* Branch Attribute value comes from a Parameter or list of expressions */
            } else {
                status = str2vals(MODL->brch[ibrch].attr[iattr].defn, MODL, &nrow, &ncol, &values, &dots, str);
                CHECK_STATUS(str2vals);

                if (STRLEN(str) > 0) {
                    SPRINT1(2, "%s", str);
                    status = EG_attributeAdd(eobject, aname, ATTRSTRING,
                                             1, NULL, NULL, str);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    nval = nrow * ncol;

                    if (nval > 0 && values != NULL) {
                        for (ival = 0; ival < nval; ival++) {
#ifndef __clang_analyzer__
                            SPRINT1x(2, "%10.4f ", values[ival]);
#endif
                        }
                        SPRINT0(2, " ");
                        if (MODL->brch[ibrch].attr[iattr].type == ATTRREAL) {
                            status = EG_attributeAdd(eobject, aname, ATTRREAL,
                                                     nval, NULL, values, NULL);
                            CHECK_STATUS(EG_attributeAdd);

                            if (strcmp(aname, ".tParams") == 0) {
                                status = EG_attributeAdd(eobject, "_tParams", ATTRREAL,
                                                         nval, NULL, values, NULL);
                                CHECK_STATUS(EG_attributeAdd);
                            }
                        }
                    }
                }

                FREE(values);
                FREE(dots  );
            }
        }
    }

cleanup:
    FREE(values);
    FREE(dots  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   setFaceAttribute - set Attribute(s) to Face                        *
 *                                                                      *
 ************************************************************************
 */

static int
setFaceAttribute(modl_T *modl,          /* (in)  pointer to MODL */
                 int    ibody,          /* (in)  Body index (1:nbody) */
                 int    iface,          /* (in)  Face index (1:nface) */
                 int    jbody,          /* (in)  Branch index (=0 for automatic) */
                 int    jford,          /* (in)  Face order */
                 int    npatn,          /* (in)  number of active patterns */
                 patn_T *patn)          /* (in)  array  of active patterns */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       *iattrib=NULL, nattrib, i, ibrch;
    body_T    *body=NULL;

    int       nface;
    ego       *efaces;

    ROUTINE(setFaceAttribute);

    /* --------------------------------------------------------------- */

    /* check magic number */
    if (MODL == NULL) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    } else if (MODL->magic != OCSM_MAGIC) {
        status = OCSM_NOT_MODL_STRUCTURE;
        goto cleanup;
    }

    /* check that valid ibody is given */
    if (ibody == 0) {
        goto cleanup;
    } else if (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    }

    /* get Body info */
    body = &(MODL->body[ibody]);
    ibrch =  MODL->body[ibody].ibrch;

    /* allocate storage for new Attributes */
    MALLOC(iattrib, int, 2+2*npatn);

    nattrib = 0;

    if (jbody == 0) {
        iattrib[nattrib++] = ibody;
        iattrib[nattrib++] = jford;
    } else {
        iattrib[nattrib++] = jbody;
        iattrib[nattrib++] = jford;
    }

    for (i = npatn-1; i >= 0; i--) {
        if (patn[i].itype == OCSM_PATBEG ||
            patn[i].itype == OCSM_RECALL   ) {
            iattrib[nattrib++] = patn[i].ibeg;
            iattrib[nattrib++] = patn[i].icopy;
        }
    }

    /* save the Body Attributes */
    status = EG_getBodyTopos(body->ebody, NULL, FACE, &nface, &efaces);
    CHECK_STATUS(EG_getBodyTopos);

    if (efaces != NULL) {
        if (MODL->brch[ibrch].type != OCSM_RESTORE) {
            status = EG_attributeAdd(efaces[iface-1], "_body", ATTRINT,
                                     2, iattrib, NULL, NULL);
            CHECK_STATUS(EG_attributeAdd);
        }

        iattrib[0] = ibrch;
        status = EG_attributeAdd(efaces[iface-1], "_brch", ATTRINT,
                                 nattrib, iattrib, NULL, NULL);
        CHECK_STATUS(EG_attributeAdd);

        status = setEgoAttribute(MODL, ibrch, efaces[iface-1]);
        CHECK_STATUS(setEgoAttribute);

        EG_free(efaces);
    }

cleanup:
    FREE(iattrib);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   setupAtPmtrs - sets up Parameters starting with @                  *
 *                                                                      *
 ************************************************************************
 */

static int
setupAtPmtrs(modl_T *modl,              /* (in)  pointer to MODL */
             int    havesel)            /* (in)  =+1 if seltype is already set */
                                        /*       =-1 if a mark was selected */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int       AT_seltype=0, AT_selbody=0, AT_sellist=0;
    int       AT_nbody=0,   AT_nface=0,   AT_nedge=0,  AT_nnode=0;
    int       AT_ibody=0,   AT_iface=0,   AT_iedge=0,  AT_inode=0;
    int       AT_igroup=0,  AT_itype=0,   AT_nbors=0,  AT_ibody1=0, AT_ibody2=0;
    int       AT_xmin=0,    AT_ymin=0,    AT_zmin=0,   AT_xmax=0,   AT_ymax=0,   AT_zmax=0;
    int       AT_length=0,  AT_area=0,    AT_volume=0;
    int       AT_xcg=0,     AT_ycg=0,     AT_zcg=0;
    int       AT_Ixx=0,     AT_Ixy=0,     AT_Ixz=0;
    int       AT_Iyx=0,     AT_Iyy=0,     AT_Iyz=0;
    int       AT_Izx=0,     AT_Izy=0,     AT_Izz=0;
    int       AT_toler=0,   AT_signal=0,  AT_nwarn=0;
    int       AT_edata=0,   AT_stack=0,   AT_scope=0,  AT_version=0;
    double    mpdot;

    int       ipmtr, itype, nface, nedge, nnode, ntemp, nbors, nlist;
    int       oclass, mtype, nchild, *sense, ilist;
    CINT      *tempIlist;
    double    data[18];
    CDOUBLE   *tempRlist;
    CCHAR     *tempClist;
    ego       eref, *echild, *enodes;
#if PRINT_PROGRESS
    time_t    cpu_beg, cpu_end;
#endif

    ROUTINE(setupAtPmtrs);

    /* --------------------------------------------------------------- */

    PPRINT_INIT(enter setupAtPmtrs);

    /* if there are no Bodys, then return without setting up any @-Parameters except @version */
    if (MODL->nbody <= 0) {
        for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
            if (MODL->pmtr[ipmtr].type  == OCSM_LOCALVAR            &&
                MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level] &&
                strcmp(MODL->pmtr[ipmtr].name, "@version") == 0       ) {
                AT_version = ipmtr;
                break;
            }
        }

        if (AT_version == 0) {
            status = ocsmNewPmtr(MODL, "@version", OCSM_LOCALVAR, 1, 1);
            CHECK_STATUS(ocsmNewPmtr);
            AT_version = MODL->npmtr;
        }

        status = ocsmSetValuD(MODL, AT_version, 1, 1, OCSM_MAJOR_VERSION+0.01*OCSM_MINOR_VERSION);
        CHECK_STATUS(ocsmSetValuD);

        goto cleanup;
    }

    /* initialize selection info if we do not have it already */
    if (havesel == 0) {
        MODL->seltype = -1;
        MODL->selbody = MODL->nbody;
        MODL->selsize = 0;

        FREE(MODL->sellist);
    }

    /* if current Body is NULL, return without setting up any @-Parameters */
    if (havesel == -1) {
        /* handled below */
    } else if (MODL->selbody > 0) {
        if (MODL->body[MODL->selbody].botype == OCSM_NULL_BODY ||
            MODL->body[MODL->selbody].botype == OCSM_SKETCH      ) {
            goto cleanup;
        }
    } else {
        if (MODL->body[MODL->nbody].botype == OCSM_NULL_BODY ||
            MODL->body[MODL->nbody].botype == OCSM_SKETCH      ) {
            goto cleanup;
        }
    }

    /* determine the value to set for the velocities of massprops based
       upon whether or not any of the DESPMTRs have non-zero dots */
    if (MODL->numdots == 0) {
        mpdot = 0;
    } else {
        mpdot = -HUGEQ;
    }

    /* get the Parameter indices for each of the variables (at this level) */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type  == OCSM_LOCALVAR           &&
            MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level]  ) {
            if (strcmp(MODL->pmtr[ipmtr].name, "@seltype") == 0) AT_seltype = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@selbody") == 0) AT_selbody = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@sellist") == 0) AT_sellist = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nbody"  ) == 0) AT_nbody   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nface"  ) == 0) AT_nface   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nedge"  ) == 0) AT_nedge   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nnode"  ) == 0) AT_nnode   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ibody"  ) == 0) AT_ibody   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@iface"  ) == 0) AT_iface   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@iedge"  ) == 0) AT_iedge   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@inode"  ) == 0) AT_inode   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@igroup" ) == 0) AT_igroup  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@itype"  ) == 0) AT_itype   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nbors"  ) == 0) AT_nbors   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ibody1" ) == 0) AT_ibody1  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ibody2" ) == 0) AT_ibody2  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@xmin"   ) == 0) AT_xmin    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ymin"   ) == 0) AT_ymin    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zmin"   ) == 0) AT_zmin    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@xmax"   ) == 0) AT_xmax    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ymax"   ) == 0) AT_ymax    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zmax"   ) == 0) AT_zmax    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@length" ) == 0) AT_length  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@area"   ) == 0) AT_area    = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@volume" ) == 0) AT_volume  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@xcg"    ) == 0) AT_xcg     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@ycg"    ) == 0) AT_ycg     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@zcg"    ) == 0) AT_zcg     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixx"    ) == 0) AT_Ixx     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixy"    ) == 0) AT_Ixy     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Ixz"    ) == 0) AT_Ixz     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyx"    ) == 0) AT_Iyx     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyy"    ) == 0) AT_Iyy     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Iyz"    ) == 0) AT_Iyz     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izx"    ) == 0) AT_Izx     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izy"    ) == 0) AT_Izy     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@Izz"    ) == 0) AT_Izz     = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@toler"  ) == 0) AT_toler   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@signal" ) == 0) AT_signal  = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@nwarn"  ) == 0) AT_nwarn   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@edata"  ) == 0) AT_edata   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@stack"  ) == 0) AT_stack   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@scope"  ) == 0) AT_scope   = ipmtr;
            if (strcmp(MODL->pmtr[ipmtr].name, "@version") == 0) AT_version = ipmtr;
        }
    }

    /* make any Parameter that does not exist */
    if (AT_seltype == 0) {
        status = ocsmNewPmtr(MODL, "@seltype", OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_seltype = MODL->npmtr;
    }

    if (AT_selbody == 0) {
        status = ocsmNewPmtr(MODL, "@selbody", OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_selbody = MODL->npmtr;
    }

    if (AT_sellist == 0) {
        status = ocsmNewPmtr(MODL, "@sellist", OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_sellist = MODL->npmtr;
    }

    if (AT_nbody == 0) {
        status = ocsmNewPmtr(MODL, "@nbody",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nbody = MODL->npmtr;
    }

    if (AT_nface == 0) {
        status = ocsmNewPmtr(MODL, "@nface",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nface = MODL->npmtr;
    }

    if (AT_nedge == 0) {
        status = ocsmNewPmtr(MODL, "@nedge",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nedge = MODL->npmtr;
    }

    if (AT_nnode == 0) {
        status = ocsmNewPmtr(MODL, "@nnode",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nnode = MODL->npmtr;
    }

    if (AT_ibody == 0) {
        status = ocsmNewPmtr(MODL, "@ibody",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ibody = MODL->npmtr;
    }

    if (AT_iface == 0) {
        status = ocsmNewPmtr(MODL, "@iface",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_iface = MODL->npmtr;
    }

    if (AT_iedge == 0) {
        status = ocsmNewPmtr(MODL, "@iedge",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_iedge = MODL->npmtr;
    }

    if (AT_inode == 0) {
        status = ocsmNewPmtr(MODL, "@inode",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_inode = MODL->npmtr;
    }

    if (AT_igroup == 0) {
        status = ocsmNewPmtr(MODL, "@igroup",  OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_igroup = MODL->npmtr;
    }

    if (AT_itype == 0) {
        status = ocsmNewPmtr(MODL, "@itype",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_itype = MODL->npmtr;
    }

    if (AT_nbors == 0) {
        status = ocsmNewPmtr(MODL, "@nbors",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nbors = MODL->npmtr;
    }

    if (AT_ibody1 == 0) {
        status = ocsmNewPmtr(MODL, "@ibody1",  OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ibody1 = MODL->npmtr;
    }

    if (AT_ibody2 == 0) {
        status = ocsmNewPmtr(MODL, "@ibody2",  OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_ibody2 = MODL->npmtr;
    }

    if (AT_xmin == 0) {
        status = ocsmNewPmtr(MODL, "@xmin",    OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_xmin = MODL->npmtr;
    }

    if (AT_ymin == 0) {
        status = ocsmNewPmtr(MODL, "@ymin",    OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_ymin = MODL->npmtr;
    }

    if (AT_zmin == 0) {
        status = ocsmNewPmtr(MODL, "@zmin",    OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_zmin = MODL->npmtr;
    }

    if (AT_xmax == 0) {
        status = ocsmNewPmtr(MODL, "@xmax",    OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_xmax = MODL->npmtr;
    }

    if (AT_ymax == 0) {
        status = ocsmNewPmtr(MODL, "@ymax",    OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_ymax = MODL->npmtr;
    }

    if (AT_zmax == 0) {
        status = ocsmNewPmtr(MODL, "@zmax",    OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_zmax = MODL->npmtr;
    }

    if (AT_length == 0) {
        status = ocsmNewPmtr(MODL, "@length",  OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_length = MODL->npmtr;
    }

    if (AT_area == 0) {
        status = ocsmNewPmtr(MODL, "@area",    OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_area = MODL->npmtr;
    }

    if (AT_volume == 0) {
        status = ocsmNewPmtr(MODL, "@volume",  OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_volume = MODL->npmtr;
    }

    if (AT_xcg == 0) {
        status = ocsmNewPmtr(MODL, "@xcg",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_xcg = MODL->npmtr;
    }

    if (AT_ycg == 0) {
        status = ocsmNewPmtr(MODL, "@ycg",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_ycg = MODL->npmtr;
    }

    if (AT_zcg == 0) {
        status = ocsmNewPmtr(MODL, "@zcg",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_zcg = MODL->npmtr;
    }

    if (AT_Ixx == 0) {
        status = ocsmNewPmtr(MODL, "@Ixx",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Ixx = MODL->npmtr;
    }

    if (AT_Ixy == 0) {
        status = ocsmNewPmtr(MODL, "@Ixy",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Ixy = MODL->npmtr;
    }

    if (AT_Ixz == 0) {
        status = ocsmNewPmtr(MODL, "@Ixz",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Ixz = MODL->npmtr;
    }

    if (AT_Iyx == 0) {
        status = ocsmNewPmtr(MODL, "@Iyx",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Iyx = MODL->npmtr;
    }

    if (AT_Iyy == 0) {
        status = ocsmNewPmtr(MODL, "@Iyy",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Iyy = MODL->npmtr;
    }

    if (AT_Iyz == 0) {
        status = ocsmNewPmtr(MODL, "@Iyz",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Iyz = MODL->npmtr;
    }

    if (AT_Izx == 0) {
        status = ocsmNewPmtr(MODL, "@Izx",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Izx = MODL->npmtr;
    }

    if (AT_Izy == 0) {
        status = ocsmNewPmtr(MODL, "@Izy",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Izy = MODL->npmtr;
    }

    if (AT_Izz == 0) {
        status = ocsmNewPmtr(MODL, "@Izz",     OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_Izz = MODL->npmtr;
    }

    if (AT_toler == 0) {
        status = ocsmNewPmtr(MODL, "@toler",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        MODL->pmtr[MODL->npmtr].mprop    = 1;
        MODL->pmtr[MODL->npmtr].value[0] = -HUGEQ;
        AT_toler = MODL->npmtr;
    }

    if (AT_signal == 0) {
        status = ocsmNewPmtr(MODL, "@signal",  OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_signal = MODL->npmtr;
    }

    if (AT_nwarn == 0) {
        status = ocsmNewPmtr(MODL, "@nwarn",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_nwarn = MODL->npmtr;
    }

    if (AT_edata == 0) {
        status = ocsmNewPmtr(MODL, "@edata",   OCSM_LOCALVAR, 1, 23);
        CHECK_STATUS(ocsmNewPmtr);
        AT_edata = MODL->npmtr;
    }

    if (AT_stack == 0) {
        status = ocsmNewPmtr(MODL, "@stack",   OCSM_LOCALVAR, 1, MAX_STACK_SIZE);
        CHECK_STATUS(ocsmNewPmtr);
        AT_stack = MODL->npmtr;
    }

    if (AT_scope == 0) {
        status = ocsmNewPmtr(MODL, "@scope",   OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_scope = MODL->npmtr;
    }

    if (AT_version == 0) {
        status = ocsmNewPmtr(MODL, "@version", OCSM_LOCALVAR, 1, 1);
        CHECK_STATUS(ocsmNewPmtr);
        AT_version = MODL->npmtr;
    }

    if (AT_stack == 0) {
        status = -999;
        goto cleanup;
    }

    PPRINT0(done setting up pmtrs);

    /* initialize @edata */
    MODL->pmtr[AT_edata].ncol = 1;
    status = ocsmSetValuD(MODL, AT_edata, 1, 1, -HUGEQ);
    CHECK_STATUS(ocsmSetValuD);

    /* store the signal and number of warnings */
    status = ocsmSetValuD(MODL, AT_signal, 1, 1, (double)(MODL->sigCode));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_nwarn,  1, 1, (double)(MODL->nwarn));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_scope, 1, 1, MODL->scope[MODL->level]);
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_version, 1, 1, OCSM_MAJOR_VERSION+0.01*OCSM_MINOR_VERSION);
    CHECK_STATUS(ocsmSetValuD);

    /* special processing if processing a Mark */
    if (havesel == -1) {
        MODL->seltype = -1;
        MODL->selbody =  0;
        FREE(MODL->sellist);

        status = ocsmSetValuD(MODL, AT_seltype, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_selbody, 1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        goto cleanup;
    }

    /* if no Body is selected, select the last Body */
    if (MODL->selbody < 0) {
        MODL->seltype = -1;
        MODL->selbody = MODL->nbody;
        SPRINT1(1, "WARNING:: selecting Body %d by default", MODL->selbody);
        (MODL->nwarn)++;
    }

    /* special processing if selected Body is a NullBody */
    if (MODL->body[MODL->selbody].botype == OCSM_NULL_BODY) {
        status = ocsmSetValuD(MODL, AT_seltype, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_selbody, 1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        MODL->pmtr[AT_sellist].nrow = 1;
        MODL->pmtr[AT_sellist].ncol = 1;

        RALLOC(MODL->pmtr[AT_sellist].value, double, 1);
        RALLOC(MODL->pmtr[AT_sellist].dot,   double, 1);

        status = ocsmSetValuD(MODL, AT_sellist, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nbody,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody,   1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nface,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_iface,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nedge,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_iedge,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nnode,   1, 1,  1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_inode,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_igroup,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_itype,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nbors,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody1,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody2,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xmin,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xmax,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ymin,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ymax,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zmin,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zmax,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_length,  1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_area,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_volume,  1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xcg,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ycg,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_zcg,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Ixz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Iyz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_Izz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_toler,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        goto cleanup;
    }

    /* special processing if selected Body is a NodeBody */
    if (MODL->body[MODL->selbody].botype == OCSM_NODE_BODY) {
        status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, NODE, &nnode, &enodes);
        CHECK_STATUS(EG_getBodyTopos);
        SPLINT_CHECK_FOR_NULL(enodes);

        status = EG_getTopology(enodes[0], &eref, &oclass, &mtype,
                                data, &nchild, &echild, &sense);
        CHECK_STATUS(EG_getTopology);

        EG_free(enodes);

        status = ocsmSetValuD(MODL, AT_seltype, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_selbody, 1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        MODL->pmtr[AT_sellist].nrow = 1;
        MODL->pmtr[AT_sellist].ncol = 1;
        RALLOC(MODL->pmtr[AT_sellist].value, double, 1);
        RALLOC(MODL->pmtr[AT_sellist].dot,   double, 1);

        status = ocsmSetValuD(MODL, AT_sellist, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nbody,   1, 1, (double)(MODL->nbody));
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody,   1, 1, (double)(MODL->selbody));
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nface,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_iface,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nedge,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_iedge,   1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nnode,   1, 1,  1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_inode,   1, 1,  1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_igroup,  1, 1, (double)(MODL->body[MODL->selbody].igroup));
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_itype,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_nbors,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody1,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody2,  1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_xmin,    1, 1,  data[0]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_xmin,    1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_xmax,    1, 1,  data[0]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_xmax,    1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_ymin,    1, 1,  data[1]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_ymin,    1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_ymax,    1, 1,  data[1]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_ymax,    1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_zmin,    1, 1,  data[2]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_zmin,    1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_zmax,    1, 1,  data[2]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_zmax,    1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_length,  1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_length,  1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_area,    1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_area,    1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_volume,  1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_volume,  1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_xcg,     1, 1,  data[0]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_xcg,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_ycg,     1, 1,  data[1]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_ycg,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_zcg,     1, 1,  data[2]);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_zcg,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Ixx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Ixx,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Ixy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Ixy,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Ixz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Ixz,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Iyx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Iyx,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Iyy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Iyy,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Iyz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Iyz,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Izx,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Izx,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Izy,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Izy,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_Izz,     1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);
        status = ocsmSetVelD( MODL, AT_Izz,     1, 1,  mpdot);
        CHECK_STATUS(ocsmSetVelD);

        status = ocsmSetValuD(MODL, AT_toler,   1, 1,  0.0);
        CHECK_STATUS(ocsmSetValuD);

        goto cleanup;
    }

    /* set @seltype, @selbody, and @sellist */
    status = ocsmSetValuD(MODL, AT_seltype, 1, 1, (double)(MODL->seltype));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_selbody, 1, 1, (double)(MODL->selbody));
    CHECK_STATUS(ocsmSetValuD);

    /* seltype is Node, Edge, or Face (selsize entries) */
    if (MODL->selsize >= 1) {
        RALLOC(MODL->sellist, int, MODL->selsize);

        MODL->pmtr[AT_sellist].nrow = 1;
        MODL->pmtr[AT_sellist].ncol = MODL->selsize;
        RALLOC(MODL->pmtr[AT_sellist].value, double, MODL->selsize);
        RALLOC(MODL->pmtr[AT_sellist].dot,   double, MODL->selsize);

        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            status = ocsmSetValuD(MODL, AT_sellist, 1, ilist+1, (double)(MODL->sellist[ilist]));
            CHECK_STATUS(ocsmSetValuD);
        }
    /* seltype is Body (1 entry) */
    } else {
        RALLOC(MODL->sellist, int, 1);

        MODL->pmtr[AT_sellist].nrow = 1;
        MODL->pmtr[AT_sellist].ncol = 1;
        RALLOC(MODL->pmtr[AT_sellist].value, double, 1);
        RALLOC(MODL->pmtr[AT_sellist].dot,   double, 1);

        status = ocsmSetValuD(MODL, AT_sellist, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);
    }

    /* set @nbody and @ibody */
    status = ocsmSetValuD(MODL, AT_nbody, 1, 1, (double)(MODL->nbody));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_ibody, 1, 1, (double)(MODL->selbody));
    CHECK_STATUS(ocsmSetValuD);

    /* set @nface, @nedge, and @nnode */
    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, FACE, &nface, NULL);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, EDGE, &nedge, NULL);
    CHECK_STATUS(EG_getBodyTopos);

    status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody, NULL, NODE, &nnode, NULL);
    CHECK_STATUS(EG_getBodyTopos);

    status = ocsmSetValuD(MODL, AT_nface, 1, 1, (double)(nface));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_nedge, 1, 1, (double)(nedge));
    CHECK_STATUS(ocsmSetValuD);

    status = ocsmSetValuD(MODL, AT_nnode, 1, 1, (double)(nnode));
    CHECK_STATUS(ocsmSetValuD);

    /* set @iface, @iedge, and @inode */
    if (MODL->seltype == 2 && MODL->selsize == 1) {
        status = ocsmSetValuD(MODL, AT_iface, 1, 1, (double)(MODL->sellist[0]));
    } else if (MODL->seltype == 2) {
        status = ocsmSetValuD(MODL, AT_iface, 1, 1, -2.0);
    } else {
        status = ocsmSetValuD(MODL, AT_iface, 1, 1, -1.0);
    }
    CHECK_STATUS(ocsmSetValuD);

    if (MODL->seltype == 1 && MODL->selsize == 1) {
        status = ocsmSetValuD(MODL, AT_iedge, 1, 1, (double)(MODL->sellist[0]));
    } else if (MODL->seltype == 1) {
        status = ocsmSetValuD(MODL, AT_iedge, 1, 1, -2.0);
    } else {
        status = ocsmSetValuD(MODL, AT_iedge, 1, 1, -1.0);
    }
    CHECK_STATUS(ocsmSetValuD);

    if (MODL->seltype == 0 && MODL->selsize == 1) {
        status = ocsmSetValuD(MODL, AT_inode, 1, 1, (double)(MODL->sellist[0]));
    } else if (MODL->seltype == 0) {
        status = ocsmSetValuD(MODL, AT_inode, 1, 1, -2.0);
    } else {
        status = ocsmSetValuD(MODL, AT_inode, 1, 1, -1.0);
    }
    CHECK_STATUS(ocsmSetValuD);

    /* set @igroup */
    status = ocsmSetValuD(MODL, AT_igroup, 1, 1, (double)(MODL->body[MODL->selbody].igroup));
    CHECK_STATUS(ocsmSetValuD);

    /* set @itype */
    if        (MODL->body[MODL->selbody].botype == OCSM_WIRE_BODY) {
        status = ocsmSetValuD(MODL, AT_itype, 1, 1, 1.0);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->body[MODL->selbody].botype == OCSM_SHEET_BODY) {
        status = ocsmSetValuD(MODL, AT_itype, 1, 1, 2.0);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->body[MODL->selbody].botype == OCSM_SOLID_BODY) {
        status = ocsmSetValuD(MODL, AT_itype, 1, 1, 3.0);
        CHECK_STATUS(ocsmSetValuD);
    }

    /* set @nbors */
    if        (MODL->seltype == 0) {
        nbors = 0;
        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody,
                                     MODL->body[MODL->selbody].node[MODL->sellist[ilist]].enode,
                                     EDGE, &ntemp, NULL);
            CHECK_STATUS(EG_getBodyTopos);
            nbors += ntemp;
        }
        status = ocsmSetValuD(MODL, AT_nbors, 1, 1, nbors);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->seltype == 1) {
        nbors  = 0;
        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody,
                                     MODL->body[MODL->selbody].edge[MODL->sellist[ilist]].eedge,
                                     FACE, &ntemp, NULL);
            CHECK_STATUS(EG_getBodyTopos);
            nbors += ntemp;
        }
        status = ocsmSetValuD(MODL, AT_nbors, 1, 1, nbors);
        CHECK_STATUS(ocsmSetValuD);
    } else if (MODL->seltype == 2) {
        nbors  = 0;
        for (ilist = 0; ilist < MODL->selsize; ilist++) {
            status = EG_getBodyTopos(MODL->body[MODL->selbody].ebody,
                                     MODL->body[MODL->selbody].face[MODL->sellist[ilist]].eface,
                                     EDGE, &ntemp, NULL);
            CHECK_STATUS(EG_getBodyTopos);
            nbors += ntemp;
        }
        status = ocsmSetValuD(MODL, AT_nbors, 1, 1, nbors);
        CHECK_STATUS(ocsmSetValuD);
    } else {
        status = ocsmSetValuD(MODL, AT_nbors, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);
    }

    /* set @ibody1 and @ibody2 */
    if (MODL->selsize == 1 && (MODL->seltype == 1 || MODL->seltype == 2)) {
        if (MODL->seltype == 1) {
            status = EG_attributeRet(MODL->body[MODL->selbody].edge[MODL->sellist[0]].eedge,
                                     "_body", &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);
        } else {
            status = EG_attributeRet(MODL->body[MODL->selbody].face[MODL->sellist[0]].eface,
                                     "_body", &itype, &nlist, &tempIlist, &tempRlist, &tempClist);
            CHECK_STATUS(EG_attributeRet);
        }

        if (itype == ATTRINT && nlist == 2) {
            status = ocsmSetValuD(MODL, AT_ibody1, 1, 1, (double)(tempIlist[0]));
            CHECK_STATUS(ocsmSetValuD);

            status = ocsmSetValuD(MODL, AT_ibody2, 1, 1, (double)(tempIlist[1]));
            CHECK_STATUS(ocsmSetValuD);
        } else {
            status = ocsmSetValuD(MODL, AT_ibody1, 1, 1, -1.0);
            CHECK_STATUS(ocsmSetValuD);

            status = ocsmSetValuD(MODL, AT_ibody2, 1, 1, -1.0);
            CHECK_STATUS(ocsmSetValuD);
        }
    } else {
        status = ocsmSetValuD(MODL, AT_ibody1, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);

        status = ocsmSetValuD(MODL, AT_ibody2, 1, 1, -1.0);
        CHECK_STATUS(ocsmSetValuD);
    }

    PPRINT0(done setting up header);

cleanup:
    PPRINT0(exit setupAtPmtrs);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   setupForFiniteDifferences - check if fnite differences are needed  *
 *                                                                      *
 ************************************************************************
 */

static int
setupForFiniteDifferences(modl_T *MODL) /* (in)  pointer to MODL */
{
    int       status = SUCCESS;         /* (out) return status */

    ROUTINE(setupForFiniteDifferences);

    /* --------------------------------------------------------------- */

    /* set time finite difference time step */
    if (FORCE_FINITE_DIFFS > 0) {
        MODL->dtime = DTIME_NOM;
    } else if (MODL->perturb == NULL && MODL->dtime == 0 && MODL->needFDs != 0) {
        MODL->dtime = DTIME_NOM;
    }

    /* if time step was set and we are the base MODL, create the perturbation now */
    if (MODL->perturb == NULL && MODL->dtime > 0) {
        status = createPerturbation(MODL);
        CHECK_STATUS(createPerturbation);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   setupUdprimFile - set up file for UDPARG and UDPRIM                *
 *                                                                      *
 ************************************************************************
 */

static int
setupUdprimFile(modl_T *MODL,           /* (in)  pointer to MODL */
                int    itype,           /* (in)  =0 for file, =1 for stream */
                FILE   *csm_file,       /* (in)  pointer to current .csm file */
                char   filename[],      /* (in)  current filename */
                int    *linenum,        /* (both) current line number */
                char   str[])           /* (both) argument (at least MAX_LINE_LEN long) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       itmp, i;
    char      tmpfilename[MAX_LINE_LEN], tmpfileline[MAX_LINE_LEN];
    char      pathname[MAX_EXPR_LEN], *thisChar;
    FILE      *tmp_file=NULL;

    ROUTINE(setupUdprimFile);

    /* --------------------------------------------------------------- */

    if (strncmp(str, "<<", MAX_EXPR_LEN) == 0) {

        /* if itype==1, set up a stream */
        if (itype == 1) {
            snprintf(str, MAX_LINE_LEN-1, "$<<inline/%d>>", MODL->ninline);

            /* add marker that we have an inline stream */
            if (MODL->minline == 0) {
                MODL->minline = 512;
                MALLOC(MODL->sinline, char, MODL->minline);
            }

            if (MODL->ninline >= MODL->minline-4) {
                MODL->minline += 512;
                RALLOC(MODL->sinline, char, MODL->minline);
            }

            strcpy(&(MODL->sinline[MODL->ninline]), "<<\n");
            MODL->ninline += 3;

            /* read lines until we find "<<" */
            while (1) {
                (*linenum)++;
                if (fgets(tmpfileline, MAX_LINE_LEN, csm_file) == NULL) break;

                thisChar = tmpfileline;
                while (*thisChar == ' ' || *thisChar == '\t') {
                    thisChar++;
                }
                if (strncmp(thisChar, ">>", 2) == 0) {
                    break;
                }

                if (MODL->ninline+(int)(strlen(tmpfileline)) >= MODL->minline-2) {
                    MODL->minline += strlen(tmpfileline) + 512;
                    RALLOC(MODL->sinline, char, MODL->minline);
                }

                strcpy(&(MODL->sinline[MODL->ninline]), tmpfileline);
                MODL->ninline += strlen(tmpfileline);
            }
            MODL->ninline++;

            goto cleanup;
        }

        /* if this is the first tmp file, make a directory */
        if (MODL->tmpDirNum < 0) {
            for (itmp = 0; itmp < 999; itmp++) {
                snprintf(tmpfilename, MAX_LINE_LEN, "tmp_OpenCSM_%02d/00", itmp);

                tmp_file = fopen(tmpfilename, "r");
                if (tmp_file != NULL) {
                    fclose(tmp_file);
                    continue;
                }

                /* we found an unused directory, so make it now */
                snprintf(tmpfilename, MAX_LINE_LEN, "tmp_OpenCSM_%02d", itmp);
                if (MKDIR(tmpfilename) != 0) {
                    SPRINT1(0, "ERROR:: could not make \"%s\"", tmpfilename);
                    status = OCSM_FILE_NOT_FOUND;
                    goto cleanup;
                }

                MODL->tmpDirNum = itmp;
                break;
            }
        }

        if (MODL->tmpDirNum < 0) {
            SPRINT0(0, "ERROR:: could not find possible tmpdir");
            status = OCSM_FILE_NOT_FOUND;
            goto cleanup;
        }

        /* look for a tmp file that does not exist */
        for (itmp = 0; itmp < 999; itmp++) {
            snprintf(tmpfilename, MAX_LINE_LEN, "tmp_OpenCSM_%02d/%02d", MODL->tmpDirNum, itmp);

            tmp_file = fopen(tmpfilename, "r");
            if (tmp_file != NULL) {
                fclose(tmp_file);
                continue;
            }

            /* we found an unused tmp file, so copy from filename to tmpfilename now */
            tmp_file = fopen(tmpfilename, "w");
            if (tmp_file != NULL) {
                while (1) {
                    (*linenum)++;
                    if (fgets(tmpfileline, MAX_LINE_LEN, csm_file) == NULL) break;

                    thisChar = tmpfileline;
                    while (*thisChar == ' ' || *thisChar == '\t') {
                        thisChar++;
                    }
                    if (strncmp(thisChar, ">>", 2) == 0) {
                        break;
                    }

                    itmp = fputs(tmpfileline, tmp_file);
                    if (itmp < 0) break;
                }

                fclose(tmp_file);
                tmp_file = NULL;
                SPRINT1(1, "--> diverting inputs to tmp file \"%s\"", tmpfilename);

                snprintf(str, MAX_LINE_LEN, "$%s", tmpfilename);

                break;
            }
        }
    }

    /* convert arguments that start with "$/" to relative pathnames */
    if (strncmp(str, "$$/", 3) == 0) {
        STRNCPY(pathname, filename, MAX_EXPR_LEN);
        i = STRLEN(pathname) - 1;
        while (pathname[i] != SLASH) {
            pathname[i] = '\0';
            i--;
            if (i < 0) break;
        }
        STRNCPY(tmpfilename, &(str[3]), MAX_EXPR_LEN);
        snprintf(str, MAX_EXPR_LEN, "$%s%s", pathname, tmpfilename);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   signalError - add to error message buffer                          *
 *                                                                      *
 ************************************************************************
 */

static void
signalError(
  /*@null@*/void   *modl,               /* (in)  pointer to MODL */
            int    status,              /* (in)  status flag */
            char   format[],            /* (in)  format specifier */
            ...)                        /* (in)  variable arguments for format */
{
    va_list   args;

    char      sigMesg[MAX_STR_LEN];
    int       ibrch;

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(signalError);

    /* --------------------------------------------------------------- */

    if (MODL == NULL) {
        printf("ERROR:: (%s)\n        ", ocsmGetText(status));
        goto cleanup;
    }

    /* remember the Branch where this error happened */
    ibrch = MODL->ibrch;

    /* set up the va structure */
    va_start(args, format);

    /* save the signal code */
    MODL->sigCode = status;

    /* add the error to the sigMesg */

    /* Branch is known */
    if        (ibrch > 0 && STRLEN(MODL->brch[ibrch].filename) > 0) {
        snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s) in Branch %s at [[%s:%d]]\n        ",
                 ocsmGetText(status), MODL->brch[ibrch].name, MODL->brch[ibrch].filename, MODL->brch[ibrch].linenum);

     /* there are no Branches (yet) */
    } else if (MODL->nbrch == 0) {
        snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s)\n        ",
                 ocsmGetText(status));

    /* Branch is known, but there is not file */
    } else if (ibrch > 0) {
        snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s) in Branch %s [[not in file]]\n        ",
                 ocsmGetText(status), MODL->brch[ibrch].name);

    /* unknown how we got here */
    } else {
        snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s)\n        ",
                 ocsmGetText(status));
    }
    SPRINT1x(0, "%s", MODL->sigMesg);

    vsnprintf(sigMesg, MAX_STR_LEN, format, args);
    SPRINT1(0, "%s", sigMesg);

    strncat(MODL->sigMesg, sigMesg, MAX_STR_LEN-1);

    /* clean up the va structure */
    va_end(args);

cleanup:
    return;
}


/*
 ************************************************************************
 *                                                                      *
 *   signalError2 - add to error message buffer                         *
 *                                                                      *
 ************************************************************************
 */

static void
signalError2(
   /*@null@*/void   *modl,              /* (in)  pointer to MODL */
             int    status,             /* (in)  status flag */
             char   filename[],         /* (in)  filename */
             int    linenum,            /* (in)  line number */
             char   format[],           /* (in)  format specifier */
             ...)                       /* (in)  variable arguments for format */
{
    va_list   args;

    char      sigMesg[MAX_STR_LEN];

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(signalError2);

    /* --------------------------------------------------------------- */

    if (MODL == NULL) {
        printf("ERROR:: (%s)\n        ", ocsmGetText(status));
        goto cleanup;
    }

    /* set up the va structure */
    va_start(args, format);

    /* save the signal code */
    MODL->sigCode = status;

    /* add the error to the sigMesg */
    snprintf(MODL->sigMesg, MAX_STR_LEN, "ERROR:: (%s) at [[%s:%d]]\n        ",
             ocsmGetText(status), filename, linenum);
    SPRINT1x(0, "%s", MODL->sigMesg);

    vsnprintf(sigMesg, MAX_STR_LEN, format, args);
    SPRINT1(0, "%s", sigMesg);

    strncat(MODL->sigMesg, sigMesg, MAX_STR_LEN-1);

    /* clean up the va structure */
    va_end(args);

cleanup:
    return;
}


/*
 ************************************************************************
 *                                                                      *
 *   solidBoolean - performs solid boolean and loosens tolers if needed *
 *                                                                      *
 ************************************************************************
 */

static int
solidBoolean(modl_T *MODL,              /* (in)  pointer to MODL */
             ego    ebodyl,             /* (in)  Body on left */
             ego    ebodyr,             /* (in)  Body on rite */
             int    type,               /* (in)  boolean type */
             double maxtol,             /* (in)  maximum allowable tolerance */
             ego    *emodel)            /* (out) model containing result */
{
    int       status = SUCCESS;         /* (out) return status */

    int       oclass, mtype, nchild, *senses, itry, inudge;
    double    tolerl, tolerr, data[4], xform[12];
    char      filename[MAX_FILENAME_LEN];
    ego       eref, *echilds, ebodyrr, context, ebodys2[2], emodel2, exform;

    ROUTINE(solidBoolean);

    /* --------------------------------------------------------------- */

    status = EG_getContext(ebodyl, &context);
    CHECK_STATUS(EG_getContext);

    if (outLevel >= 3) {
        SPRINT0(3, "before EG_solidBoolean: ebodyl");
        ocsmPrintEgo(ebodyl);
        SPRINT0(3, "before EG_solidBoolean: ebodyr");
        ocsmPrintEgo(ebodyr);
    }

    /* if ebodyl is a model, just do a simple FUSION */
    status = EG_getTopology(ebodyl, &eref, &oclass, &mtype,
                            data, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    if (oclass == MODEL) {
        status = EG_getTopology(echilds[0], &eref, &oclass, &mtype,
                                data, &nchild, &echilds, &senses);
        CHECK_STATUS(EG_getTopology);

        if (oclass == BODY && mtype == WIREBODY) {
            status = EG_solidBoolean(ebodyl, ebodyr, type, emodel);
            SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
                    0.0, -1, status, ocsmGetText(status));
        } else {
            status = EG_getTopology(ebodyr, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);
            if (oclass == FACE) {
                status = EG_solidBoolean(ebodyl, ebodyr, type, emodel);
                SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
                        0.0, -1, status, ocsmGetText(status));
            } else {
                status = EG_generalBoolean(ebodyl, ebodyr, type, maxtol, emodel);
                SPRINT4(2, "    -> EG_generalBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
                        0.0, -1, status, ocsmGetText(status));
            }
        }

        /* if boolean failed and dumpEgads is specified, then dump
           a model that contains the two offending Bodys*/
        if (status < EGADS_SUCCESS && MODL->dumpEgads == 2) {
            SPRINT1(0, "ERROR:: EG_solidBoolean -> status=%d", status);

            snprintf(filename, MAX_FILENAME_LEN, "BOOL_ERROR_%d.egads", type);
            SPRINT1(0, "ERROR:: dumping \"%s\" for failed Boolean operation", filename);

            status = EG_copyObject(ebodyl, NULL, &(ebodys2[0]));
            CHECK_STATUS(EG_copyObject);
            status = EG_copyObject(ebodyr, NULL, &(ebodys2[1]));
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 2, ebodys2, NULL, &emodel2);
            CHECK_STATUS(EG_makeTopology);

            status = remove(filename);
            if (status == 0) {
                SPRINT1(1, "WARNING:: file \"%s\" is being overwritten", filename);
                (MODL->nwarn)++;
            }

            status = EG_saveModel(emodel2, filename);
            CHECK_STATUS(EG_saveModel);

            status = EG_deleteObject(emodel2);
            CHECK_STATUS(EG_deleteObject);
        }
        goto cleanup;
    }

    /* if maxtol<0, then use -maxtol as tolerance (and do not do tolerance adjustments) */
    if (maxtol < 0) {
        (void)  EG_setOutLevel(context, 0);
        status = EG_generalBoolean(ebodyl, ebodyr, type, -maxtol, emodel);
        (void) EG_setOutLevel(context, outLevel);
        SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
               -maxtol, -1, status, ocsmGetText(status));
        CHECK_STATUS(EG_solidBoolean);

        goto cleanup;
    }

    /* find the tolerances of the orginal Bodys */
    status = EG_getTolerance(ebodyl, &tolerl);
    CHECK_STATUS(EG_getTolerance);

    status = EG_getTolerance(ebodyr, &tolerr);
    CHECK_STATUS(EG_getTolerance);
    SPRINT3(3, "    maxtol=%e, tolerl=%e, tolerr=%e", maxtol, tolerl, tolerr);

    /* loop to keep increasing tolerance until we either get a good
       result or we have reached the specified tolerance */
    for (itry = 0; itry < 10; itry++) {

        /* try the boolean operation */
        (void) EG_setOutLevel(context, 0);
        status = EG_generalBoolean(ebodyl, ebodyr, type, maxtol, emodel);

        /* instead of returning EGADS_EMPTY, EG_generalBoolean(FUSION) returns a
           MODEL with two Bodys */
        if (type == FUSION && status == EGADS_SUCCESS) {
            status = EG_getTopology(*emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            if (status != EGADS_SUCCESS || nchild != 1) {
                status = EGADS_EMPTY;
            }
        }
        (void) EG_setOutLevel(context, outLevel);

        SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
               MAX(tolerl,tolerr), -1, status, ocsmGetText(status));

        /* if boolean failed and dumpEgads is specified, then dump
           a model that contains the two offending Bodys*/
        if (status < EGADS_SUCCESS && MODL->dumpEgads == 2) {
            SPRINT1(0, "ERROR:: EG_solidBoolean -> status=%d", status);

            snprintf(filename, MAX_FILENAME_LEN, "BOOL_ERROR_%d.egads", type);
            SPRINT1(0, "ERROR:: dumping \"%s\" for failed Boolean operation", filename);

            status = EG_copyObject(ebodyl, NULL, &(ebodys2[0]));
            CHECK_STATUS(EG_copyObject);
            status = EG_copyObject(ebodyr, NULL, &(ebodys2[1]));
            CHECK_STATUS(EG_copyObject);

            status = EG_makeTopology(MODL->context, NULL, MODEL, 0,
                                     NULL, 2, ebodys2, NULL, &emodel2);
            CHECK_STATUS(EG_makeTopology);

            status = remove(filename);
            if (status == 0) {
                SPRINT1(1, "WARNING:: file \"%s\" is being overwritten", filename);
                (MODL->nwarn)++;
            }

            status = EG_saveModel(emodel2, filename);
            CHECK_STATUS(EG_saveModel);

            status = EG_deleteObject(emodel2);
            CHECK_STATUS(EG_deleteObject);
        }
        SPRINT2(3, "    EG_solidBoolean(itry=%d) -> status=%d", itry, status);

        /* the operation succeeded */
        if (status == EGADS_SUCCESS) {

            /* if on the first try, so simply return */
            if (itry == 0) {
                goto cleanup;

            /* otherwise, generate a warning about new tolerance */
            } else {
                SPRINT1(1, "WARNING:: tolerance increased to %e to get good result", MAX(tolerl,tolerr));
                (MODL->nwarn)++;
                goto cleanup;
            }
        }

        /* otherwise, remove the bad model and try increasing the tolerance (by a factor of 4)
           up to the user-specified value */
        if (*emodel != NULL) {
            status = EG_deleteObject(*emodel);
            CHECK_STATUS(EG_deleteObject);
        }

        if        (tolerl < tolerr) {
            tolerl = tolerr;
        } else if (tolerr < tolerl) {
            tolerr = tolerl;
        } else if (tolerl < maxtol) {
            tolerl = MIN(4*tolerl, maxtol);
            tolerr = tolerl;
        } else {
            break;
        }
    }

    /* now that we have tried changing tolerances, and that has apparently not
       worked, try nudging ebodyr in each of the cardinal directions (this
       is not right, but at least it works sometimes) */
    status = EG_getTolerance(ebodyr, &tolerr);
    CHECK_STATUS(EG_getTolerance);

    xform[0] = 1;   xform[1] = 0;   xform[ 2] = 0;
    xform[4] = 0;   xform[5] = 1;   xform[ 6] = 0;
    xform[8] = 0;   xform[9] = 0;   xform[10] = 1;

    for (inudge = 0; inudge < 6; inudge++) {
        if        (inudge == 0) {
            xform[3] = +2*tolerr;   xform[7] = 0;         xform[11] = 0;
        } else if (inudge == 1) {
            xform[3] = -2*tolerr;   xform[7] = 0;         xform[11] = 0;
        } else if (inudge == 2) {
            xform[3] = 0;           xform[7] = +2*tolerr; xform[11] = 0;
        } else if (inudge == 3) {
            xform[3] = 0;           xform[7] = -2*tolerr; xform[11] = 0;
        } else if (inudge == 4) {
            xform[3] = 0;           xform[7] = 0;         xform[11] = +2*tolerr;
        } else {
            xform[3] = 0;           xform[7] = 0;         xform[11] = -2*tolerr;
        }

        status = EG_makeTransform(MODL->context, xform, &exform);
        CHECK_STATUS(EG_makeTransform);

        status = EG_copyObject(ebodyr, exform, &ebodyrr);
        CHECK_STATUS(EG_copyObject);

        status = EG_generalBoolean(ebodyl, ebodyrr, type, maxtol, emodel);

        EG_deleteObject(ebodyrr);

        /* instead of returning EGADS_EMPTY, EG_generalBoolean(FUSION) returns a
           MODEL with two Bodys */
        if (type == FUSION && status == EGADS_SUCCESS) {
            SPLINT_CHECK_FOR_NULL(*emodel);

            status = EG_getTopology(*emodel, &eref, &oclass, &mtype,
                                    data, &nchild, &echilds, &senses);
            if (status != EGADS_SUCCESS || nchild != 1) {
                status = EG_deleteObject(*emodel);
                CHECK_STATUS(EG_deleteObject);

                status = EGADS_EMPTY;
            }
        }

        SPRINT4(2, "    -> EG_solidBoolean(toler=%8.3e, nudge=%2d, status=%d (%s)",
               MAX(tolerl,tolerr), inudge, status, ocsmGetText(status));

        if (status == EGADS_SUCCESS) {
            SPRINT3(1, "WARNING:: nudged rite Body by (%12.4e,%12.4e,%12.4e)",
                    xform[3], xform[7], xform[11]);
            (MODL->nwarn)++;
            goto cleanup;
        }
    }

    /* getting here means nothing we tried worked */
    signalError(MODL, OCSM_INTERNAL_ERROR,
                "max trys exceeded in solidBoolean");
    status = OCSM_INTERNAL_ERROR;

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   solveSketch - solve a Sketch                                       *
 *                                                                      *
 ************************************************************************
 */

static int
solveSketch(modl_T *modl,               /* (in)  pointer to MODL */
            sket_T *sket)               /* (both) array of Sketch info */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    ROUTINE(solveSketch);

    /* --------------------------------------------------------------- */

    /* returrn if already solved */
    if (sket->solved == 1) {
        goto cleanup;
    }

    /* check for under- or over-constrained Sketch */
    if        (sket->ncon < sket->nvar) {
        sket->signal = OCSM_UNDERCONSTRAINED;
        goto cleanup;
    } else if (sket->ncon > sket->nvar) {
        sket->signal = OCSM_OVERCONSTRAINED;
        goto cleanup;
    }

    /* try using the (original) Newton solver first */
    status = solveSketchOrig(modl, sket);
    if (status == SUCCESS) goto cleanup;

    /* if it failed, clear the signal and try using the Levenberg-Marquardt solver */
    SPRINT0(1, "trying Levenberg-Marquardt solver");

    MODL->sigCode = 0;

    status = solveSketchLM(modl, sket);
    if (status == SUCCESS) goto cleanup;

    /* if that failed too, ignore not_converged */
    if (status == OCSM_NOT_CONVERGED) {
        sket->signal = OCSM_NOT_CONVERGED;
        status = SUCCESS;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   solveSketchLM - solve a Sketch (using Levenberg-Marquardt)         *
 *                                                                      *
 ************************************************************************
 */

static int
solveSketchLM(modl_T *modl,             /* (in)  pointer to MODL */
              sket_T *sket)             /* (both) array of Sketch info */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        jpmtr, jndex, ivar, nvar, icon, ncon, iter, niter, k;
    double     value, dot, rms, rmslast, lambda, f0max, toler, save_value, dfdx_max, omega=0.25;
    double     *val_init=NULL, *neg_f0=NULL, *neg_f0old=NULL, *delx=NULL, *dfdx=NULL;
    double     *JtJ=NULL, *JtQ=NULL;
    char       str[MAX_STRVAL_LEN];

    ROUTINE(solveSketchLM);

    /* --------------------------------------------------------------- */

    for (icon = 0; icon < sket->ncon; icon++) {
        SPRINT2(2, "    -> setting con[%3d] = %s", icon, sket->con[icon]);
    }

    nvar = sket->nvar;
    ncon = sket->ncon;

    /* get needed arrays */
    MALLOC(val_init,  double,  nvar        );
    MALLOC(neg_f0,    double,         ncon );
    MALLOC(neg_f0old, double,         ncon );
    MALLOC(dfdx,      double, (nvar)*(ncon));
    MALLOC(delx,      double,  nvar        );
    MALLOC(JtJ,       double, (nvar)*(ncon));
    MALLOC(JtQ,       double,  nvar        );

    /* store the initial values in case we need to revert because solver failed */
    toler = 0;
    for (ivar = 0; ivar < nvar; ivar++) {
        jpmtr = sket->ipmtr[ivar];
        jndex = sket->index[ivar];
        val_init[ivar] = MODL->pmtr[jpmtr].value[jndex];

        delx[ivar] = 0;

        toler = MAX(toler, fabs(val_init[ivar]));
    }
    toler = EPS09 * MAX(toler, 1);

    /* Levenburg-Marquardt iteration to change the Sketch variables until
       the constraints are satisfied */
    niter   = 200;
    lambda  = 0.01;
    rmslast = 1e300;

    for (iter = 0; iter < niter; iter++) {
#ifdef GRAFIC
        {
            int   io_kbd=5, io_scr=6, ilin=GR_SOLID, isym=GR_CIRCLE, nper=0, nline=1, indgr=1+4+16+64;
            float xplot[1000], yplot[1000];
            char  pltitl[80];

            /* remember points */
            for (ivar = 0; ivar < sket->nvar; ivar++) {
                jpmtr = sket->ipmtr[ivar];
                jndex = sket->index[ivar];

                if (strcmp(MODL->pmtr[jpmtr].name, "::x") == 0) {
                    xplot[jndex] = MODL->pmtr[jpmtr].value[jndex];
                    nper         = jndex + 1;
                }
                if (strcmp(MODL->pmtr[jpmtr].name, "::y") == 0) {
                    yplot[jndex] = MODL->pmtr[jpmtr].value[jndex];
                    nper         = jndex + 1;
                }
            }

            assert (nper >    0);
            assert (nper < 1000);

            for (ivar = 0; ivar < nper; ivar++) {
                SPRINT3(1, "%3d %10.5f %10.5f", ivar, xplot[ivar], yplot[ivar]);
            }

            /* close sketch */
            xplot[nper] = xplot[0];
            yplot[nper] = yplot[0];
            nper++;

            /* plot */
            snprintf(pltitl, 80, "~x~y~sketch at beginning of iteration %d", iter);
            grinit_(&io_kbd, &io_scr, "sketch evolution", STRLEN("sketch evolution"));
            grline_(&ilin, &isym, &nline, pltitl,
                    &indgr, xplot, yplot, &nper, STRLEN(pltitl));
        }
#endif // GRAFIC

        /* evaluate the constraints */
        f0max = 0;
        rms   = 0;
        for (icon = 0; icon < ncon; icon++) {
            status = str2val(sket->con[icon], MODL, &value, &dot, str);
            CHECK_STATUS(str2val);

            if (STRLEN(str) > 0) {
                signalError(MODL, OCSM_WRONG_PMTR_TYPE,
                            "constraint cannot have a string value (%s)", str);
                goto cleanup;
            }

            if (iter != 0) {
                neg_f0old[icon] = neg_f0[icon];
            }

            neg_f0[icon] = -value;
            SPRINT3(2, "       f0[%4d] = %11.4e  (%s)", icon, value, sket->con[icon]);

            if (iter == 0) {
                neg_f0old[icon] = neg_f0[icon];
            }

            rms += value * value;

            if (fabs(value) > f0max) {
                f0max = fabs(value);
            }
        }

        SPRINT2(1, "    -> solving   iter = %3d,   f0max = %12.4e", iter, f0max);

        /* if we have converged, stop the Levenburg-Marquardt iterations */
        if (f0max < toler) {
            break;
        }

        /* rms <= rmslast, we are converging, so decrease lambda and accept step */
        if (rms <= rmslast) {
            lambda = MAX(0.5*lambda, 1.0e-10);
            SPRINT3(2, "       rmslast=%12.4e  rms=%12.4e  ACCEPT  lambda=%12.4e", rmslast, rms, lambda);

            rmslast = rms;
            omega   = MIN(1.2*omega, 1);

        /* rms > rmslast, not converging, so increase lambda and revert to old step */
        } else {
            lambda = MIN(2.0*lambda, 1.0e+10);
            SPRINT3(2, "       rmslast=%12.4e  rms=%12.4e  REJECT  lambda=%12.4e", rmslast, rms, lambda);

            for (ivar = 0; ivar < nvar; ivar++) {
                jpmtr = sket->ipmtr[ivar];
                jndex = sket->index[ivar];
                MODL->pmtr[jpmtr].value[jndex] -= omega * delx[ivar];

                for (icon = 0; icon < ncon; icon++) {
                    neg_f0[icon] = neg_f0old[icon];
                }
            }
        }

        /* build up the Jacobian matrix by perturbing the solver variables
           one at a time */
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            save_value = MODL->pmtr[jpmtr].value[jndex];
            MODL->pmtr[jpmtr].value[jndex] += EPS06;

            for (icon = 0; icon < ncon; icon++) {
                status = str2val(sket->con[icon], MODL, &value, &dot, str);
                CHECK_STATUS(str2val);

                if (STRLEN(str) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                }

                dfdx[icon*(nvar)+ivar] = (value + neg_f0[icon]) / EPS06;
            }

            MODL->pmtr[jpmtr].value[jndex] = save_value;
        }

        /* print out the Jacobian matrix */
        SPRINT0(2, "Jacobian matrix");
        for (icon = 0; icon < ncon; icon++) {
            dfdx_max = 0;
            SPRINT1x(2, "%3d: ", icon);

            for (ivar = 0; ivar < nvar; ivar++) {
                SPRINT1x(2, "%12.4e ", dfdx[icon*(nvar)+ivar]);
                if (fabs(dfdx[icon*(nvar)+ivar]) > dfdx_max) {
                    dfdx_max = fabs(dfdx[icon*(nvar)+ivar]);
                }
            }
            SPRINT1(2, " | %12.4e", dfdx_max);
        }

        /* find Jtranspose * J */
        for (ivar = 0; ivar < nvar; ivar++) {
            for (icon = 0; icon < ncon; icon++) {
                JtJ[icon*(nvar)+ivar] = 0;
                for (k = 0; k < nvar; k++) {
                    JtJ[icon*(nvar)+ivar] += dfdx[k*(nvar)+ivar] * dfdx[k*(nvar)+icon];
                }
            }
#ifndef __clang_analyzer__
            JtJ[ivar*(nvar)+ivar] *= (1.0 + lambda);
#endif
        }

        /* find Jtranspose * Q */
        for (ivar = 0; ivar < nvar; ivar++) {
            JtQ[ivar] = 0;
            for (icon = 0; icon < ncon; icon++) {
                JtQ[ivar] += dfdx[icon*(nvar)+ivar] * neg_f0[icon];
            }
        }

        /* take the Levenburg-Marquardt step */
        status = matsol(JtJ, JtQ, ncon, delx);
        CHECK_STATUS(matsol);

        /* update design variables */
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            MODL->pmtr[jpmtr].value[jndex] += omega * delx[ivar];

            SPRINT4(2, "       x [%4d] = %11.5f  (%s[%d])",
                    ivar, MODL->pmtr[jpmtr].value[jndex], MODL->pmtr[jpmtr].name, jndex+1);
        }
    }

    /* if converged, print final solution */
    if (f0max < toler) {
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            SPRINT3(1, "    -> updating  %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

    /* otherwise we ran out of iterations, so revert to initial guesses */
    } else {
        SPRINT0(1, "WARNING:: reverting to initial solution");

        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            MODL->pmtr[jpmtr].value[jndex] = val_init[ivar];
            SPRINT3(1, "    -> reverting %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

        status = OCSM_NOT_CONVERGED;
    }

    sket->solved = 1;

cleanup:
    FREE(val_init );
    FREE(delx     );
    FREE(dfdx     );
    FREE(neg_f0   );
    FREE(JtJ      );
    FREE(JtQ      );
    FREE(neg_f0old);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   solveSketchOrig - solve a Sketch (original method)                 *
 *                                                                      *
 ************************************************************************
 */

static int
solveSketchOrig(modl_T *modl,           /* (in)  pointer to MODL */
                sket_T *sket)           /* (both) array of Sketch info */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int        jpmtr, jndex, nvar, ivar, ncon, icon, iter, niter;
    double     value, value1, value2, dot;
    double     *val_init=NULL, *f0neg=NULL, *dfdx=NULL, *delx=NULL;
    double     f0max, toler, f0last, save_value, omega, dfdx_max;
    char       str[MAX_STRVAL_LEN];

    ROUTINE(solveSketchOrig);

    /* --------------------------------------------------------------- */

    for (icon = 0; icon < sket->ncon; icon++) {
        SPRINT2(2, "    -> setting con[%3d] = %s", icon, sket->con[icon]);
    }

    nvar = sket->nvar;
    ncon = sket->ncon;

    /* set up for function evaluation and Jacobian */
    MALLOC(val_init, double, nvar     );
    MALLOC(f0neg,    double,      ncon);
    MALLOC(dfdx,     double, nvar*ncon);
    MALLOC(delx,     double, nvar     );

    /* store the initial values in case we need to revert because solver failed */
    toler = 0;
    for (ivar = 0; ivar < nvar; ivar++) {
        jpmtr = sket->ipmtr[ivar];
        jndex = sket->index[ivar];
        val_init[ivar] = MODL->pmtr[jpmtr].value[jndex];

        toler = MAX(toler, fabs(val_init[ivar]));
    }
    toler = EPS09 * MAX(toler, 1);

    /* for each 'S' and 'R' constraint, set the sign of the dip of the
       associated segment so as to give the smallest residual */
    for (icon = 0; icon < sket->ncon; icon++) {
        if (sket->ctype[icon] == 'S' || sket->ctype[icon] == 'R') {
            status = str2val(sket->con[icon], MODL, &value1, &dot, str);
            CHECK_STATUS(str2val);

            jpmtr = sket->id;
            jndex = sket->ip1[icon] - 1;
            MODL->pmtr[jpmtr].value[jndex] *= -1;

            status = str2val(sket->con[icon], MODL, &value2, &dot, str);
            CHECK_STATUS(str2val);

            if (fabs(value1) < fabs(value2)) {
                MODL->pmtr[jpmtr].value[jndex] *= -1;
            } else {
                SPRINT1(1, "WARNING:: sign of ::d[%d] flipped to reduce initial residual", jndex+1);
                (MODL->nwarn)++;
            }
        }
    }

    /* Newton iteration to change the Sketch variables until
       the constraints are satisfied */
    niter   = 25;
    omega   = 0.25;
    f0last  = 1e+100;

    for (iter = 0; iter < niter; iter++) {

#ifdef GRAFIC
        {
            int   io_kbd=5, io_scr=6, ilin=GR_SOLID, isym=GR_CIRCLE, nper=0, nline=1, indgr=1+4+16+64;
            float xplot[MAX_SKETCH_SIZE+1], yplot[MAX_SKETCH_SIZE+1];
            char  pltitl[80];

            /* remember points */
            for (ivar = 0; ivar < nvar; ivar++) {
                jpmtr = sket->ipmtr[ivar];
                jndex = sket->index[ivar];

                if (strcmp(MODL->pmtr[jpmtr].name, "::x") == 0) {
                    xplot[jndex] = MODL->pmtr[jpmtr].value[jndex];
                    nper         = jndex + 1;
                }
                if (strcmp(MODL->pmtr[jpmtr].name, "::y") == 0) {
                    yplot[jndex] = MODL->pmtr[jpmtr].value[jndex];
                    nper         = jndex + 1;
                }
            }

            for (ivar = 0; ivar < nper; ivar++) {
                SPRINT3(1, "%3d %10.5f %10.5f", ivar, xplot[ivar], yplot[ivar]);
            }

            /* close sketch */
            xplot[nper] = xplot[0];
            yplot[nper] = yplot[0];
            nper++;

            /* plot */
            snprintf(pltitl, 80, "~x~y~sketch at beginning of iteration %d", iter);
            grinit_(&io_kbd, &io_scr, "sketch evolution", STRLEN("sketch evolution"));
            grline_(&ilin, &isym, &nline, pltitl,
                    &indgr, xplot, yplot, &nper, STRLEN(pltitl));
        }
#endif // GRAFIC

        /* evaluate the constraints */
        f0max = 0;
        for (icon = 0; icon < ncon; icon++) {
            status = str2val(sket->con[icon], MODL, &value, &dot, str);
            CHECK_STATUS(str2val);
            if (STRLEN(str) > 0) {
                status = OCSM_WRONG_PMTR_TYPE;
                goto cleanup;
            }

            f0neg[icon] = -value;
            SPRINT2(2, "       f0[%4d] = %11.4e", icon, value);

            if (fabs(value) > f0max) {
                f0max = fabs(value);
            }
        }

        SPRINT2x(1, "    -> solving   iter = %3d,   f0max = %12.4e", iter, f0max);

        /* if we have converged, stop the Newton iterations */
        if (f0max < toler) {
            SPRINT0(1, "   converged");
            break;

        /* f0max < f0last, we are converging, so increase omega */
        } else if (f0max < f0last) {
            f0last = f0max;
            omega  = MIN(1.2*omega, 1);
            SPRINT1(1, "   accepting, omega=%10.5f", omega);

        /* otherwise, revert to last solution and decrease omega */
        } else {
#ifndef __clang_analyzer__
            for (ivar = 0; ivar < nvar; ivar++) {
                jpmtr = sket->ipmtr[ivar];
                jndex = sket->index[ivar];

                MODL->pmtr[jpmtr].value[jndex] -= omega * delx[ivar];
            }
#endif

            omega = omega / 2.0;
            SPRINT1(1, "   rejecting, omega=%10.5f", omega);

            continue;
        }

        /* build up the Jacobian matrix by perturbing the solver variables
           one at a time */
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            save_value = MODL->pmtr[jpmtr].value[jndex];
            MODL->pmtr[jpmtr].value[jndex] += EPS06;

            for (icon = 0; icon < ncon; icon++) {
                status = str2val(sket->con[icon], MODL, &value, &dot, str);
                CHECK_STATUS(str2val);
                if (STRLEN(str) > 0) {
                    status = OCSM_WRONG_PMTR_TYPE;
                    goto cleanup;
                }

#ifndef __clang_analyzer__
                dfdx[icon*(ncon)+ivar] = (value + f0neg[icon]) / EPS06;
#endif
            }

            MODL->pmtr[jpmtr].value[jndex] = save_value;
        }

        /* print out the Jacobian matrix */
        SPRINT0(2, "Jacobian matrix");
        for (icon = 0; icon < ncon; icon++) {
            dfdx_max = 0;
            SPRINT1x(2, "%3d: ", icon);

            for (ivar = 0; ivar < nvar; ivar++) {
#ifndef __clang_analyzer__
                SPRINT1x(2, "%12.4e ", dfdx[icon*(ncon)+ivar]);
                if (fabs(dfdx[icon*(ncon)+ivar]) > dfdx_max) {
                    dfdx_max = fabs(dfdx[icon*(ncon)+ivar]);
                }
#endif
            }
            SPRINT1(2, " | %12.4e", dfdx_max);
        }

        /* take the Newton step */
        status = matsol(dfdx, f0neg, ncon, delx);
        CHECK_STATUS(matsol);

        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            MODL->pmtr[jpmtr].value[jndex] += omega * delx[ivar];

            SPRINT4(2, "       x [%4d] = %11.5f  (%s[%d])",
                    ivar, MODL->pmtr[jpmtr].value[jndex], MODL->pmtr[jpmtr].name, jndex+1);
        }
    }

    /* if converged, print final solution */
    if (f0max < toler) {
        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            SPRINT3(1, "    -> updating  %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

    /* otherwise we ran out of iterations, so revert to initial guesses */
    } else {
        SPRINT0(1, "WARNING:: reverting to initial solution");

        for (ivar = 0; ivar < nvar; ivar++) {
            jpmtr = sket->ipmtr[ivar];
            jndex = sket->index[ivar];

            MODL->pmtr[jpmtr].value[jndex] = val_init[ivar];
            SPRINT3(1, "    -> reverting %s[%d] = %10.5f", MODL->pmtr[jpmtr].name, jndex+1,
                    MODL->pmtr[jpmtr].value[jndex]);
        }

        status = OCSM_NOT_CONVERGED;
    }

    sket->solved = 1;

cleanup:
    FREE(delx );
    FREE(dfdx );
    FREE(f0neg);
    FREE(val_init);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   splineVelocityOfBspline - callback function for EG_blend/ruled_vels *
 *                                                                      *
 ************************************************************************
 */

static int
splineVelocityOfBspline(
            /*@unused@*/void   *usrData,    /* (in)  blind pointer to user data */
      /*@unused@*/const ego    secs[],      /* (in)  array of sections */
            /*@unused@*/int    isec,        /* (in)  current section (bias-0) */
            /*@unused@*/ego    eedge,       /* (in)  Edge for which sensitivity is desired */
                        ego    egeom,       /* (in)  B-spline CURVE for the Edge */
                        int    *ivec[],     /* (out) integer data for the B-spline */
                        double *rvec[],     /* (out) real    data for the B-spline */
                        double *rvec_dot[]) /* (out) velocity of B-spline real data */
{
    int status = EGADS_SUCCESS;

    int i, iedge, ibody, oclass, mtype, nreal;
    ego ref;

    egadsSpline_T *spl;

    ROUTINE(splineVelocityOfBspline);

    /* --------------------------------------------------------------- */

    /* get the b-spline data sensitivity */
    status = EG_getGeometry(egeom, &oclass, &mtype, &ref, ivec, rvec);
    CHECK_STATUS(EG_getGeometry);

    /* get the b-spline data sensitivity */
    if (EG_hasGeometry_dot(eedge) == EGADS_SUCCESS) {
        EG_free(*rvec);

        status = EG_getGeometry_dot(egeom, rvec, rvec_dot);
        CHECK_STATUS(EG_getGeometry_dot);

    /* otherwise approximate it */
    } else {
        spl = (egadsSpline_T *)usrData;

        ibody = spl->isketch[isec];
        iedge = 1;
        while( spl->MODL->body[ibody].edge[iedge].eedge != eedge ) {
            iedge++;
            if (iedge > spl->MODL->body[ibody].nedge) {
                SPRINT0(0, "ERROR:: Could not find edge in sketch!");
                status = OCSM_UNKNOWN;
                goto cleanup;
            }
        }

        if (oclass == CURVE) {
            nreal = (*ivec)[3] + 3*(*ivec)[2];
            if (((*ivec)[0]&2) != 0) nreal += (*ivec)[2];

        } else {
            nreal = (*ivec)[3] + (*ivec)[6] + 3*(*ivec)[2]*(*ivec)[5];
            if (((*ivec)[0]&2) != 0)
              nreal += (*ivec)[2]*(*ivec)[5];
        }

        /* TODO Compute d(Knot)/d(Param) */
        *rvec_dot = NULL;
        MALLOC(*rvec_dot, double, nreal);

        for (i = 0; i < nreal; i++) {
            (*rvec_dot)[i] = 0.0;
        }
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   splineVelocityOfEdge - callback function for EG_blend/ruled_vels   *
 *                                                                      *
 ************************************************************************
 */

static int
splineVelocityOfEdge(void*   usrData,        /* (in)  blind pointer to user data */
   /*@unused@*/const ego     secs[],         /* (in)  array of sections */
                     int     isec,           /* (in)  current section (bias-0) */
                     ego     eedge,          /* (in)  Edge for which sensitivity is desired */
                     CINT    npnt,           /* (in)  number   of t for evaluation */
                     CDOUBLE ts[],           /* (in)  array    of t for evaluation */
                     CDOUBLE ts_dot[],       /* (in)  velocity of t for evaluation */
                     double  xyz[],          /* (out) coordinates at ts */
                     double  xyz_dot[],      /* (out) velocity    at ts */
                     double  dxdt_beg[],     /* (out) tangent vector at beg of eedge */
                     double  dxdt_beg_dot[], /* (out) velocity of dxdt_beg */
                     double  dxdt_end[],     /* (out) tangent vector ay end of eedge */
                     double  dxdt_end_dot[]) /* (out) velocity of dxdt_end */
{
    int status = EGADS_SUCCESS;  /* (out) return status */

    int    ipnt, ibody, iedge;
    double x[18], x_dot[18], dt[2], tt[2], xx_dot[6];

    egadsSpline_T *spl;

    ROUTINE(splineVelocityOfEdge);

    /* --------------------------------------------------------------- */

    if (EG_hasGeometry_dot(eedge) == EGADS_SUCCESS) {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            /* evaluate the points and sensitivity */
            status = EG_evaluate_dot(eedge, &ts[ipnt], &ts_dot[ipnt], x, x_dot);
            CHECK_STATUS(EG_evaluate_dot);

            xyz[3*ipnt  ] = x[0];
            xyz[3*ipnt+1] = x[1];
            xyz[3*ipnt+2] = x[2];

            xyz_dot[3*ipnt  ] = x_dot[0];
            xyz_dot[3*ipnt+1] = x_dot[1];
            xyz_dot[3*ipnt+2] = x_dot[2];

            /* set the sensitivity of the tangent at the beginning and end */
            if (ipnt == 0) {
                dxdt_beg[0] = x[3];
                dxdt_beg[1] = x[4];
                dxdt_beg[2] = x[5];

                dxdt_beg_dot[0] = x_dot[3];
                dxdt_beg_dot[1] = x_dot[4];
                dxdt_beg_dot[2] = x_dot[5];
            }

            if (ipnt == npnt-1) {
                dxdt_end[0] = x[3];
                dxdt_end[1] = x[4];
                dxdt_end[2] = x[5];

                dxdt_end_dot[0] = x_dot[3];
                dxdt_end_dot[1] = x_dot[4];
                dxdt_end_dot[2] = x_dot[5];
            }
        }
    } else {
        spl = (egadsSpline_T *)usrData;

        ibody = spl->isketch[isec];
        iedge = 1;
        while( spl->MODL->body[ibody].edge[iedge].eedge != eedge ) {
            iedge++;
            if (iedge > spl->MODL->body[ibody].nedge) {
                SPRINT0(0, "ERROR:: Could not find edge in sketch!");
                status = OCSM_UNKNOWN;
                goto cleanup;
            }
        }

        /* compute the sensitivites */
        status = velocityOfEdge(spl->MODL, ibody, iedge, npnt,
                                (double *)ts, xyz_dot);
        CHECK_STATUS(velocityOfEdge);

        /* evaluate the points */
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate(eedge, &ts[ipnt], x);
            CHECK_STATUS(EG_evaluate);

            xyz[3*ipnt  ] = x[0];
            xyz[3*ipnt+1] = x[1];
            xyz[3*ipnt+2] = x[2];

            /* add t-value sensitivity via chain rule */
            xyz_dot[3*ipnt  ] += x[3]*ts_dot[ipnt];
            xyz_dot[3*ipnt+1] += x[4]*ts_dot[ipnt];
            xyz_dot[3*ipnt+2] += x[5]*ts_dot[ipnt];

            /* set the sensitivity of the tangent at the beginning and end */
            if (ipnt == 0) {
                dxdt_beg[0] = x[3];
                dxdt_beg[1] = x[4];
                dxdt_beg[2] = x[5];
            }

            if (ipnt == npnt-1) {
                dxdt_end[0] = x[3];
                dxdt_end[1] = x[4];
                dxdt_end[2] = x[5];
            }
        }

        /* approximate (via finite differences) the sensitivity of the tangent
           at the beginning and end */
        dt[0] = 0.1 * (ts[     1] - ts[     0]);
        dt[1] = 0.1 * (ts[npnt-1] - ts[npnt-2]);

        tt[0] = ts[     0] + dt[0];
        tt[1] = ts[npnt-1] - dt[1];

        status = velocityOfEdge(spl->MODL, ibody, iedge, 2, tt, xx_dot);
        CHECK_STATUS(velocityOfEdge);

        dxdt_beg_dot[0] = (xx_dot[0] - xyz_dot[       0]) / dt[0];
        dxdt_beg_dot[1] = (xx_dot[1] - xyz_dot[       1]) / dt[0];
        dxdt_beg_dot[2] = (xx_dot[2] - xyz_dot[       2]) / dt[0];

        dxdt_end_dot[0] = (xyz_dot[3*npnt-3] - xx_dot[3]) / dt[1];
        dxdt_end_dot[1] = (xyz_dot[3*npnt-2] - xx_dot[4]) / dt[1];
        dxdt_end_dot[2] = (xyz_dot[3*npnt-1] - xx_dot[5]) / dt[1];
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   splineVelocityOfNode - callback function for EG_blend/ruled_vels   *
 *                                                                      *
 ************************************************************************
 */

static int
splineVelocityOfNode(void*  usrData,   /* (in)  blind pointer to user data */
   /*@unused@*/const ego    secs[],    /* (in)  array of sections */
                     int    isec,      /* (in)  current section (bias-0) */
                     ego    enode,     /* (in)  Node for which sensitivity is desired */
         /*@unused@*/ego    eedge,     /* (in)  Edge attached to the node */
                     double xyz[],     /* (out) coordinates of enode */
                     double xyz_dot[]) /* (out) velocity    of enode */
{
    int status = EGADS_SUCCESS;  /* (out) return status */

    int           inode, ibody;
    egadsSpline_T *spl;

    ROUTINE(splineVelocityOfNode);

    /* --------------------------------------------------------------- */

    if (EG_hasGeometry_dot(enode) == EGADS_SUCCESS) {
        /* evaluate the point and sensitivity */
        status = EG_evaluate_dot(enode, NULL, NULL, xyz, xyz_dot);
        CHECK_STATUS(EG_evaluate_dot);
    } else {
        spl = (egadsSpline_T *)usrData;

        ibody = spl->isketch[isec];
        inode = 1;
        while( spl->MODL->body[ibody].node[inode].enode != enode ) {
            inode++;
            if (inode > spl->MODL->body[ibody].nnode) {
                SPRINT0(0, "ERROR:: Could not find node in sketch!");
                status = OCSM_UNKNOWN;
                goto cleanup;
            }
        }

        /* get the coordinate of the Node */
        status = EG_evaluate(enode, NULL, xyz);
        CHECK_STATUS(EG_evaluate);

        /* get the velocity */
        status = velocityOfNode(spl->MODL, ibody, inode, xyz_dot);
        CHECK_STATUS(velocityOfNode);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   splineVelocityOfRange - callback function for EG_blend/ruled_vels  *
 *                                                                      *
 ************************************************************************
 */

static int
splineVelocityOfRange(void*  usrData,       /* (in)  blind pointer to user data */
    /*@unused@*/const ego    secs[],        /* (in)  array of sections */
                      int    isec,          /* (in)  current section (bias-0) */
                      ego    eedge,         /* (in)  Edge for which sensitivity is desired */
                      double trange[],      /* (out) range of parametric coordinates */
                      double trange_dot[])  /* (out) velocity of trange */
{
    int status = EGADS_SUCCESS;  /* (out) return status */

    int    ibody, iedge, periodic;

    egadsSpline_T *spl;

    ROUTINE(splineVelocityOfRange);

    /* --------------------------------------------------------------- */

    if (EG_hasGeometry_dot(eedge) == EGADS_SUCCESS) {
        status = EG_getRange_dot(eedge, trange, trange_dot, &periodic);
        CHECK_STATUS(EG_getRange_dot);

    } else {
        spl = (egadsSpline_T *)usrData;

        ibody = spl->isketch[isec];
        iedge = 1;
        while( spl->MODL->body[ibody].edge[iedge].eedge != eedge ) {
            iedge++;
            if (iedge > spl->MODL->body[ibody].nedge) {
                SPRINT0(0, "ERROR:: Could not find edge in sketch!");
                status = OCSM_UNKNOWN;
                goto cleanup;
            }
        }

        status = EG_getRange(eedge, trange, &periodic);
        CHECK_STATUS(EG_getRange);

        trange_dot[0] = 0;
        trange_dot[1] = 0;
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   storeCsystem - store Csystem on Body from Branch and parents       *
 *                                                                      *
 ************************************************************************
 */

static int
storeCsystem(modl_T *modl,              /* (in)  pointer to MODL */
             int    ibody)              /* (in)  Body index (1:nbody) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    int     ibrch, ileft, irite, nattr, iattr, nrow, ncol, nval;
    int     periodic, oclass, mtype, nchild, *senses;
    int     attrType1, nlist1, attrType2, nlist2, inode, iedge, iface;
    CINT    *tempIlist1, *tempIlist2;
    double  dot, *values=NULL, *dots=NULL, csvalues[9], range[4], uv[2], data[18];
    CDOUBLE *tempRlist1, *tempRlist2;
    char    *csysname=NULL, str[MAX_STRVAL_LEN];
    CCHAR   *aname1, *tempClist1, *tempClist2;
    ego     eref, *echilds;

    ROUTINE(storeCsystem);

    /* --------------------------------------------------------------- */

    ibrch = MODL->body[ibody].ibrch;
    ileft = MODL->body[ibody].ileft;
    irite = MODL->body[ibody].irite;

    /* add Csystem from left parent.  note that if the previous
       operation is a transformation, ibody will already have
       a (possiblye-transformed) Cystem on it already*/
    if (ileft > 0 && ileft <= MODL->nbody) {
        if (MODL->body[ileft].ebody != NULL) {
            status = EG_attributeNum(MODL->body[ileft].ebody, &nattr);
            CHECK_STATUS(EG_attributeNum);

            /* loop through each Csystem in ileft */
            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(MODL->body[ileft].ebody, iattr,
                                         &aname1, &attrType1, &nlist1,
                                         &tempIlist1, &tempRlist1, &tempClist1);
                CHECK_STATUS(EG_attributeGet);

                if (attrType1 == ATTRCSYS) {
                    SPRINT1(2, "ileft has Csystem %s", aname1);

                    /* only apply this Csystem to ibody if ibody
                       does not already have such a Csystem */
                    status = EG_attributeRet(MODL->body[ibody].ebody, aname1,
                                             &attrType2, &nlist2,
                                             &tempIlist2, &tempRlist2, &tempClist2);
                    /* do nothing if it matches */
                    if (status == SUCCESS && attrType1 == attrType2) {
                        SPRINT1(2, "          Csystem %s already exists on ibody (skipping)", aname1);

                    /* if an Attribute exists, raise an error */
                    } else if (status == SUCCESS) {
                        signalError(MODL, OCSM_NAME_NOT_UNIQUE,
                                    "Attribute or Csystem \"%s\" already exists (left)", aname1);
                        status = MODL->sigCode;
                        goto cleanup;

                    /* otherwise, add the Csystem to ibody */
                    } else {
                        SPRINT0(2, "          adding Csystem to ibody");
                        status = EG_attributeAdd(MODL->body[ibody].ebody, aname1, ATTRCSYS,
                                                 9, NULL, tempRlist1, NULL);
                        CHECK_STATUS(EG_attributeAdd);
                    }
                }
            }
        }
    }

    /* add Csystem from rite parent */
    if (irite > 0 && irite <= MODL->nbody) {
        if (MODL->body[irite].ebody != NULL) {
            status = EG_attributeNum(MODL->body[irite].ebody, &nattr);
            CHECK_STATUS(EG_attributeNum);

            /* loop through each Csystem in irite */
            for (iattr = 1; iattr <= nattr; iattr++) {
                status = EG_attributeGet(MODL->body[irite].ebody, iattr,
                                         &aname1, &attrType1, &nlist1,
                                         &tempIlist1, &tempRlist1, &tempClist1);
                CHECK_STATUS(EG_attributeGet);

                if (attrType1 == ATTRCSYS) {
                    SPRINT1(2, "irite has Csystem %s", aname1);

                    /* apply this Csystem to ibody */
                    status = EG_attributeRet(MODL->body[ibody].ebody, aname1,
                                             &attrType2, &nlist2,
                                             &tempIlist2, &tempRlist2, &tempClist2);

                    /* if both left and rite had same Csystem name, use the one from the rite */
                    if (status == SUCCESS && attrType1 == ATTRCSYS && attrType2 == ATTRCSYS) {
                        SPRINT1(1, "WARNING:: Csystem \"%s\" from rite Body overrides the left", aname1);
                        (MODL->nwarn)++;
                        status = EG_attributeAdd(MODL->body[ibody].ebody, aname1, ATTRCSYS,
                                                 9, NULL, tempRlist1, NULL);
                        CHECK_STATUS(EG_attributeAdd);

                    /* if an Attribute or Csystem already exists, raise an error */
                    } else if (status == SUCCESS) {
                        signalError(MODL, OCSM_NAME_NOT_UNIQUE,
                                    "Attribute or Csystem \"%s\" already exists (rite)", aname1);
                        status = MODL->sigCode;
                        goto cleanup;

                    /* otherwise, add the Csystem to ibody */
                    } else {
                        SPRINT0(2, "          adding Csystem to ibody");
                        status = EG_attributeAdd(MODL->body[ibody].ebody, aname1, ATTRCSYS,
                                                 9, NULL, tempRlist1, NULL);
                        CHECK_STATUS(EG_attributeAdd);
                    }
                }
            }
        }
    }

    /* add Cystem from Branch */
    for (iattr = 0; iattr < MODL->brch[ibrch].nattr; iattr++) {
        if (MODL->brch[ibrch].attr[iattr].type == ATTRCSYS) {
            SPRINT1(2, "ibrch has Csystem %s", MODL->brch[ibrch].attr[iattr].name);

            status = str2vals(MODL->brch[ibrch].attr[iattr].defn, MODL,
                              &nrow, &ncol, &values, &dots, str);
            CHECK_STATUS(str2vals);
            SPLINT_CHECK_FOR_NULL(values);

            /* apply this Csystem to ibody */
            status = EG_attributeRet(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name,
                                     &attrType2, &nlist2,
                                     &tempIlist2, &tempRlist2, &tempClist2);

            /* if an Attribute already exists, raise an error */
            if (status == SUCCESS && attrType2 != ATTRCSYS) {
                signalError(MODL, OCSM_NAME_NOT_UNIQUE,
                            "Attribute \"%s\" already exists (branch)", MODL->brch[ibrch].attr[iattr].name);
                status = MODL->sigCode;
                goto cleanup;
            }

            /* if there are 9 values, add the Csystem to ibody */
            if (nrow*ncol == 9) {
                /* x0, y0, z0, dx1, dy1, dz1, dx2, dy2, dz2 */
                SPRINT0(2, "          adding Csystem to ibody");

                /* origin (can be anywhere) */
                csvalues[0] = values[0];
                csvalues[1] = values[1];
                csvalues[2] = values[2];
                /* direction 1 */
                csvalues[3] = values[3];
                csvalues[4] = values[4];
                csvalues[5] = values[5];
                /* direction 2 */
                csvalues[6] = values[6];
                csvalues[7] = values[7];
                csvalues[8] = values[8];

                dot = csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];
                if (dot < EPS12) {
                    signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                "Csystem \"%s\" has zero length dirn1", MODL->brch[ibrch].attr[iattr].name);
                    status = MODL->sigCode;
                    goto cleanup;
                }

                /* subtract out of direction 2 the part that is parallel to direction 1 */
                dot = csvalues[3] * csvalues[6] + csvalues[4] * csvalues[7] + csvalues[5] * csvalues[8];
                if (fabs(dot) > EPS06) {
                    SPRINT1(1, "WARNING:: removing non-orthogonal part from dirn2 for csystem \"%s\"",
                            MODL->brch[ibrch].attr[iattr].name);
                    (MODL->nwarn)++;

                    dot /= csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];

                    csvalues[6] -= dot * csvalues[3];
                    csvalues[7] -= dot * csvalues[4];
                    csvalues[8] -= dot * csvalues[5];
                }

                dot = csvalues[6] * csvalues[6] + csvalues[7] * csvalues[7] + csvalues[8] * csvalues[8];
                if (dot < EPS12) {
                    signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                "Csystem \"%s\" has zero length dirn2", MODL->brch[ibrch].attr[iattr].name);
                    status = MODL->sigCode;
                    goto cleanup;
                }

                /* add CSYSTEM to Body */
                status = EG_attributeAdd(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name, ATTRCSYS,
                                         9, NULL, csvalues, NULL);
                CHECK_STATUS(EG_attributeRet);

                /* add _csys_* Attribute that remembers 9 input values */
                nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
                MALLOC(csysname, char, nval);
                snprintf(csysname, nval, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
                status = EG_attributeAdd(MODL->body[ibody].ebody, csysname, ATTRREAL,
                                         9, NULL, values, NULL);
                FREE(csysname);
                CHECK_STATUS(EG_attributeAdd);

            /* if there are 5 values and first is positive, add the Csystem to ibody based upon a Face */
            } else if (nrow*ncol == 5 && values[0] > 0) {
                /* +iface, ubar0, vbar0, du2, dv2 */
                iface = NINT(+values[0]);

                if (iface >= 1 && iface <= MODL->body[ibody].nface) {
                    SPRINT1(2, "          adding Csystem to ibody from iface=%d", iface);

                    status = EG_getTopology(MODL->body[ibody].face[iface].eface, &eref,
                                            &oclass, &mtype, range, &nchild, &echilds, &senses);
                    CHECK_STATUS(EG_getTopology);

                    uv[0] = (1-values[1]) * range[0] + values[1] * range[1];
                    uv[1] = (1-values[2]) * range[2] + values[2] * range[3];

                    status = EG_evaluate(MODL->body[ibody].face[iface].eface, uv, data);
                    CHECK_STATUS(EG_evaluate);

                    /* origin (on Face) */
                    csvalues[0] =  data[0];
                    csvalues[1] =  data[1];
                    csvalues[2] =  data[2];
                    /* direction 1 (normal to Face) */
                    csvalues[3] = (data[4] * data[8]   - data[5] * data[7]) * mtype;
                    csvalues[4] = (data[5] * data[6]   - data[3] * data[8]) * mtype;
                    csvalues[5] = (data[3] * data[7]   - data[4] * data[6]) * mtype;
                    /* direction 2 (specified in terms of du and dv) */
                    csvalues[6] =  data[3] * values[3] + data[6] * values[4];
                    csvalues[7] =  data[4] * values[3] + data[7] * values[4];
                    csvalues[8] =  data[5] * values[3] + data[8] * values[4];

                    dot = csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn1", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    dot = csvalues[6] * csvalues[6] + csvalues[7] * csvalues[7] + csvalues[8] * csvalues[8];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn2", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* add CSYSTEM to Body */
                    status = EG_attributeAdd(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name, ATTRCSYS,
                                             9, NULL, csvalues, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    /* add _csys_* Attribute that remembers 5 input values */
                    nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
                    MALLOC(csysname, char, nval);
                    snprintf(csysname, nval, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
                    status = EG_attributeAdd(MODL->body[ibody].ebody, csysname, ATTRREAL,
                                             5, NULL, values, NULL);
                    FREE(csysname);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    status = OCSM_FACE_NOT_FOUND;
                    goto cleanup;
                }

            /* if there are 5 values and first is negative, add the Csystem to ibody based upon a Edge */
            } else if (nrow*ncol == 5 && values[0] < 0) {
                /* -iedge, tbar, dx2, dy2, dz2 */
                iedge = NINT(-values[0]);
                if (iedge >= 1 && iedge <= MODL->body[ibody].nedge) {
                    SPRINT1(2, "          adding Csystem to ibody from iedge=%d", iedge);

                    status = EG_getRange(MODL->body[ibody].edge[iedge].eedge, range, &periodic);
                    CHECK_STATUS(EG_getRange);

                    uv[0] = (1-values[1]) * range[0] + values[1] * range[1];

                    status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge, uv, data);
                    CHECK_STATUS(EG_evaluate);

                    /* origin (on the Edge) */
                    csvalues[0] = data[0];
                    csvalues[1] = data[1];
                    csvalues[2] = data[2];
                    /* direction 1 (tangent to Edge) */
                    csvalues[3] = data[3];
                    csvalues[4] = data[4];
                    csvalues[5] = data[5];
                    /* direction 2 */
                    csvalues[6] = values[2];
                    csvalues[7] = values[3];
                    csvalues[8] = values[4];

                    dot = csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn1", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* subtract out of direction 2 the part that is parallel to direction 1 */
                    dot = csvalues[3] * csvalues[6] + csvalues[4] * csvalues[7] + csvalues[5] * csvalues[8];
                    if (fabs(dot) > EPS06) {
                        SPRINT1(1, "WARNING:: removing non-orthogonal part from dirn2 for csystem \"%s\"",
                                MODL->brch[ibrch].attr[iattr].name);
                        (MODL->nwarn)++;

                        dot /= csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];

                        csvalues[6] -= dot * csvalues[3];
                        csvalues[7] -= dot * csvalues[4];
                        csvalues[8] -= dot * csvalues[5];
                    }

                    dot = csvalues[6] * csvalues[6] + csvalues[7] * csvalues[7] + csvalues[8] * csvalues[8];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn2", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* add CSYSTEM to Body */
                    status = EG_attributeAdd(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name, ATTRCSYS,
                                             9, NULL, csvalues, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    /* add _csys_* Attribute that remembers 5 input values */
                    nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
                    MALLOC(csysname, char, nval);
                    snprintf(csysname, nval, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
                    status = EG_attributeAdd(MODL->body[ibody].ebody, csysname, ATTRREAL,
                                             5, NULL, values, NULL);
                    FREE(csysname);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    status = OCSM_EDGE_NOT_FOUND;
                    goto cleanup;
                }

            /* if there are 7 values, add the Csystem to ibody based upon a Node */
            } else if (nrow*ncol == 7) {
                /* inode, dx1, dy1, dz1, dx2, dy2, dz2 */
                inode = NINT(values[0]);
                if (inode >= 1 && inode <= MODL->body[ibody].nnode) {
                    SPRINT1(2, "          adding Csystem to ibody from inode=%d", inode);

                    /* origin (at Node) */
                    csvalues[0] = MODL->body[ibody].node[inode].x;
                    csvalues[1] = MODL->body[ibody].node[inode].y;
                    csvalues[2] = MODL->body[ibody].node[inode].z;
                    /* direction 1 */
                    csvalues[3] = values[1];
                    csvalues[4] = values[2];
                    csvalues[5] = values[3];
                    /* direction 2 */
                    csvalues[6] = values[4];
                    csvalues[7] = values[5];
                    csvalues[8] = values[6];

                    dot = csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn1", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* subtract out of direction 2 the part that is parallel to direction 1 */
                    dot = csvalues[3] * csvalues[6] + csvalues[4] * csvalues[7] + csvalues[5] * csvalues[8];
                    if (fabs(dot) > EPS06) {
                        SPRINT1(1, "WARNING:: removing non-orthogonal part from dirn2 for csystem \"%s\"",
                                MODL->brch[ibrch].attr[iattr].name);
                        (MODL->nwarn)++;

                        dot /= csvalues[3] * csvalues[3] + csvalues[4] * csvalues[4] + csvalues[5] * csvalues[5];

                        csvalues[6] -= dot * csvalues[3];
                        csvalues[7] -= dot * csvalues[4];
                        csvalues[8] -= dot * csvalues[5];
                    }

                    dot = csvalues[6] * csvalues[6] + csvalues[7] * csvalues[7] + csvalues[8] * csvalues[8];
                    if (dot < EPS12) {
                        signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                                    "Csystem \"%s\" has zero length dirn2", MODL->brch[ibrch].attr[iattr].name);
                        status = MODL->sigCode;
                        goto cleanup;
                    }

                    /* add CSYSTEM to Body */
                    status = EG_attributeAdd(MODL->body[ibody].ebody, MODL->brch[ibrch].attr[iattr].name, ATTRCSYS,
                                             9, NULL, csvalues, NULL);
                    CHECK_STATUS(EG_attributeAdd);

                    /* add _csys_* Attribute that remembers 7 input values */
                    nval = STRLEN(MODL->brch[ibrch].attr[iattr].name) + 7;
                    MALLOC(csysname, char, nval);
                    snprintf(csysname, nval, "_csys_%s", MODL->brch[ibrch].attr[iattr].name);
                    status = EG_attributeAdd(MODL->body[ibody].ebody, csysname, ATTRREAL,
                                             7, NULL, values, NULL);
                    FREE(csysname);
                    CHECK_STATUS(EG_attributeAdd);
                } else {
                    status = OCSM_NODE_NOT_FOUND;
                    goto cleanup;
                }

            /* otherwise raise an error */
            } else {
                signalError(MODL, OCSM_ILLEGAL_CSYSTEM,
                            "Csystem values \"%s\" do not match expected pattern",
                            MODL->brch[ibrch].attr[iattr].defn);
                status = MODL->sigCode;
                goto cleanup;
            }

            FREE(values);
            FREE(dots  );
        }
    }

cleanup:
    FREE(csysname);
    FREE(values);
    FREE(dots  );

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   str2rpn - convert expression to Rpn-code                           *
 *                                                                      *
 ************************************************************************
 */

static int
str2rpn(char      str[],                /* (in)  string containing expression */
        rpn_T     *rpn)                 /* (in)  pointer to Rpn-code */
{
    int       status = SUCCESS;         /* (out) return status */

    typedef struct {
        int       type;                 /* type of token */
        char      text[MAX_STRVAL_LEN]; /* text associated with token */
    } tok_T;

    tok_T     token[  MAX_EXPR_LEN],
              opstack[MAX_EXPR_LEN];
    int       istr, jstr, ntoken, nrpn, nopstack, nparen, nbrakt;
    int       i, j, count, type;
    char      text[MAX_STRVAL_LEN], temp_str[MAX_STR_LEN];

    ROUTINE(str2rpn);

#define ADD_TOKEN(TYPE, TEXT)                                \
    if (ntoken < MAX_EXPR_LEN-1) {                           \
        token[ntoken].type = TYPE;                           \
        STRNCPY(token[ntoken].text, TEXT, MAX_STRVAL_LEN);   \
        ntoken++;                                            \
    } else {                                                 \
        status = OCSM_TOKEN_STACK_OVERFLOW;                  \
        goto cleanup;                                        \
    }

#define ADD_TOKEN_CHAR(TYPE, CHAR)                           \
    if (ntoken < MAX_EXPR_LEN-1) {                           \
        token[ntoken].type = TYPE;                           \
        token[ntoken].text[0] = CHAR;                        \
        token[ntoken].text[1] = '\0';                        \
        ntoken++;                                            \
    } else {                                                 \
        status = OCSM_TOKEN_STACK_OVERFLOW;                  \
        goto cleanup;                                        \
    }

#define PUSH_OP(TYPE, TEXT)                                  \
    if (nopstack < MAX_EXPR_LEN-1) {                         \
        opstack[nopstack].type = TYPE;                       \
        STRNCPY(opstack[nopstack].text, TEXT, MAX_STRVAL_LEN); \
        nopstack++;                                          \
    } else {                                                 \
        status = OCSM_OP_STACK_OVERFLOW;                     \
        goto cleanup;                                        \
    }

#define POP_OP(TYPE, TEXT)                                    \
    if (nopstack > 0) {                                       \
        nopstack--;                                           \
        TYPE = opstack[nopstack].type;                        \
        STRNCPY(TEXT, opstack[nopstack].text, MAX_STRVAL_LEN);  \
    } else {                                                  \
        status = OCSM_OP_STACK_UNDERFLOW;                     \
        goto cleanup;                                         \
    }

#define PUSH_RPN(TYPE, TEXT)                                 \
    if (nrpn < MAX_EXPR_LEN-1) {                             \
        rpn[nrpn].type = TYPE;                               \
        STRNCPY(rpn[nrpn].text, TEXT, MAX_STRVAL_LEN);       \
        nrpn++;                                              \
    } else {                                                 \
        status = OCSM_RPN_STACK_OVERFLOW;                    \
        goto cleanup;                                        \
    }

#define POP_RPN(TYPE, TEXT)                                  \
    if (nrpn > 0) {                                          \
        nrpn--;                                              \
        TYPE = rpn[nrpn].type;                               \
        STRNCPY(TEXT, rpn[nrpk].text, MAX_STRVAL_LEN);       \
    } else {                                                 \
        status = OCSM_RPN_STACK_UNDERFLOW;                   \
        goto cleanup;                                        \
    }

    /* --------------------------------------------------------------- */

    SPRINT1(3, "enter str2rpn(str=%s)", str);

    /* convert str to tokens
       - surrounded by parentheses
       - remove white space
       - check for valid character
       - convert unary ops to binary ops:
            (+  to  (0+
            (-  to  (0-
            [+  to  [0+
            [-  to  [0-
            ,+  to  ,0+
            ,-  to  ,0-
       - check count and nesting of parentheses
    */
    ntoken = 0;               /* number of tokens */
    nparen = 1;               /* number of unmatched open parens */
    nbrakt = 0;               /* number of unmatched open brackets */

    /* first token is an open paren */
    ADD_TOKEN(PARSE_OPENP, "(");

    /* loop through all characters of the string containing the expression */
    for (istr = 0; istr < STRLEN(str); istr++) {

        /* if first two characters are "$!", strip them off (so that
           implicit string can be treated as an expression) */
        if (istr == 0 && STRLEN(str) > 1 && str[0] == '$' && str[1] == '!') {
            istr++;
            continue;
        }

        /* ignore exclamation point (for backward compatibility) */
        if        (str[istr] == '!') {

        /* dollar sign introduces string (that is terminated by comma,
           plus, open-bracket, or end-of-line */
        } else if (str[istr] == '$') {
            istr++;
            jstr = 0;
            temp_str[jstr] = '\0';

            while (istr < STRLEN(str)) {
                if (str[istr] == ',' || str[istr] == '+' ||
                    str[istr] == ')'                       ) {
                    istr--;
                    break;
                } else if (str[istr] >= 'a' && str[istr] <= 'z') {
                    temp_str[jstr++] = str[istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] >= 'A' && str[istr] <= 'Z') {
                    temp_str[jstr++] = str[istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] >= '0' && str[istr] <= '9') {
                    temp_str[jstr++] = str[istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] == '@' || str[istr] == '_'  ||
                           str[istr] == ':' || str[istr] == ';'  ||
                           str[istr] == '$' || str[istr] == '.'  ||
                           str[istr] == '-' || str[istr] == '*'  ||
                           str[istr] == '/' || str[istr] == '\\' ||
                           str[istr] == '?' || str[istr] == '%'  ||
                           str[istr] == '(' || str[istr] == '^'  ||
                           str[istr] == '[' || str[istr] == ']'  ||
                           str[istr] == '{' || str[istr] == '}'  ||
                           str[istr] == '<' || str[istr] == '>'  ||
                           str[istr] == '='                        ) {
                    temp_str[jstr++] = str[istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] == '\'' && str[istr+1] == ',') {
                    temp_str[jstr++] = str[++istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] == '\'' && str[istr+1] == '+') {
                    temp_str[jstr++] = str[++istr];
                    temp_str[jstr  ] = '\0';
                } else if (str[istr] == '\'' && str[istr+1] == ')') {
                    temp_str[jstr++] = str[++istr];
                    temp_str[jstr  ] = '\0';
                } else {
                    SPRINT2(0, "ERROR:: illegal character (%c) in string %s", str[istr], str);
                    status = OCSM_ILLEGAL_CHAR_IN_EXPR;
                    goto cleanup;
                }

                istr++;
            }
            ADD_TOKEN(PARSE_STRING, temp_str);

        /* open parenthesis */
        } else if (str[istr] == '(') {

            /* add the new PARSE_OPENP token */
            ADD_TOKEN(PARSE_OPENP, "(");

            nparen++;

        /* close parenthesis */
        } else if (str[istr] == ')') {

            /* add the new PARSE_CLOSEP token */
            ADD_TOKEN(PARSE_CLOSEP, ")");

            nparen--;

            /* make sure there is a matching open for this close */
            if (nparen < 1) {
                SPRINT1(1, ") before ( at character %d", istr);
                status = OCSM_CLOSE_BEFORE_OPEN;
                goto cleanup;
            }

        /* open bracket */
        } else if (str[istr] == '[') {

            /* add the new PARSE_OPENB token */
            ADD_TOKEN(PARSE_OPENB, "[");

            nbrakt++;

        /* close bracket */
        } else if (str[istr] == ']') {

            /* add the new PARSE_CLOSEB token */
            ADD_TOKEN(PARSE_CLOSEB, "]");

            nbrakt--;

            /* make sure there is a matching open for this close */
            if (nbrakt < 0) {
                SPRINT1(1, "] before [ at character %d", istr);
                status = OCSM_CLOSE_BEFORE_OPEN;
                goto cleanup;
            }

        /* comma (which separates the arguments of a function) */
        } else if (str[istr] == ',') {

            /* add the new PARSE_COMMA token */
            ADD_TOKEN(PARSE_COMMA, ",");

        /* digit (0-9) or period (which starts a number) */
        } else if (str[istr] == '.' || isdigit(str[istr]) != 0) {

            /* start a new PARSE_NUMBER token */
            ADD_TOKEN_CHAR(PARSE_NUMBER, str[istr]);

            /* add new characters from str as long as we are within a number */
            i = 1;
            for (jstr = istr+1; jstr < STRLEN(str); jstr++) {
                if (isdigit(str[jstr]) != 0 || str[jstr] == '.') {
                    token[ntoken-1].text[i  ] = str[jstr];
                    token[ntoken-1].text[i+1] = '\0';
                    i++;
                    istr++;

                /* if we find an 'E' or 'e' while making a number, put it
                   and the character after it (which might be a + or - or
                   digit) into the number */
                } else if (str[jstr] == 'E' || str[jstr] == 'e') {
                    token[ntoken-1].text[i  ] = str[jstr  ];
                    token[ntoken-1].text[i+1] = str[jstr+1];
                    token[ntoken-1].text[i+2] = '\0';
                    i++; i++;
                    istr++; istr++;
                    jstr++;   /* advance jstr since we consumed 2 characters */
                } else {
                    break;
                }
            }

        /* letter (a-z, A-Z, :, and @) (which starts a name or func) */
        } else if (isalpha(str[istr]) != 0 || str[istr] == ':'
                                           || str[istr] == '@') {

            /* start a new PARSE_NAME token */
            ADD_TOKEN_CHAR(PARSE_NAME, str[istr]);

            /* add new characters from str as long as we are within a name */
            i = 1;
            for (jstr = istr+1; jstr < STRLEN(str); jstr++) {
                if (isalpha(str[jstr]) !=  0  || isdigit(str[jstr]) !=  0 ||
                            str[jstr]  == '_' ||         str[jstr]  == '@'||
                            str[jstr]  == ':' ||         str[jstr]  == '.'  ) {
                    token[ntoken-1].text[i  ] = str[jstr];
                    token[ntoken-1].text[i+1] = '\0';
                    i++;
                    istr++;

                /* ignore exclamation points */
                } else if (str[jstr] == '!') {
                    istr++;

                /* convert to PARSE_FUNC if followed by open parenthesis */
                } else if (str[jstr] == '(') {
                    token[ntoken-1].type = PARSE_FUNC;
                    break;

                /* convert to PARSE_ARRAY if followed by open bracket */
                } else if (str[jstr] == '[') {
                    token[ntoken-1].type = PARSE_ARRAY;
                    break;

                } else {
                    break;
                }
            }

        /* plus or minus */
        } else if (str[istr] == '+' || str[istr] == '-') {

            /* if previous character is comma or open, convert this
               unary +/- into a binary +/- by adding a "0" before it */
            if (token[ntoken-1].type == PARSE_OPENP ||
                token[ntoken-1].type == PARSE_OPENB ||
                token[ntoken-1].type == PARSE_COMMA   ) {
                ADD_TOKEN(PARSE_NUMBER, "0");
            }

            /* add the new PARSE_OP1 token */
            ADD_TOKEN_CHAR(PARSE_OP1, str[istr]);

        /* asterisk or slash */
        } else if (str[istr] == '*' || str[istr] == '/') {

            /* add the new PARSE_OP2 token */
            ADD_TOKEN_CHAR(PARSE_OP2, str[istr]);

        /* caret */
        } else if (str[istr] == '^') {

            /* add the new PARSE_OP3 token */
            ADD_TOKEN_CHAR(PARSE_OP3, str[istr]);

        /* white space (' ' or \t, \r or \n) */
        } else if (str[istr] == ' '  || str[istr] == '\t' ||
                   str[istr] == '\r' || str[istr] == '\n'   ) {

        /* illegal character */
        } else {
            SPRINT2(1, "Illegal character at character %d (%c)", istr, str[istr]);
            status = OCSM_ILLEGAL_CHAR_IN_EXPR;
            goto cleanup;
        }
    }

    /* add a close parenthesis at the end */
    ADD_TOKEN(PARSE_CLOSEP, ")");

    nparen--;

    /* verify that the open and close parentheses are balanced */
    if        (nparen < 0) {
        SPRINT0(1, "More ) than (");
        status = OCSM_CLOSE_BEFORE_OPEN;
        goto cleanup;
    } else if (nparen > 0) {
        SPRINT0(1, "More ( than )");
        status = OCSM_MISSING_CLOSE;
        goto cleanup;
    }

    if        (nbrakt < 0) {
        SPRINT0(1, "More ] than [:");
        status = OCSM_CLOSE_BEFORE_OPEN;
        goto cleanup;
    } else if (nbrakt > 0) {
        SPRINT0(1, "More [ than ]");
        status = OCSM_MISSING_CLOSE;
        goto cleanup;
    }

    /* verify that the open and close parentheses are properly nested */
    for (i = 1; i < ntoken; i++) {
        if (token[i].type == PARSE_CLOSEP ||
            token[i].type == PARSE_CLOSEB   ) {
            count = 0;
            for (j = i-1; j >= 0; j--) {
                if (token[j].type == PARSE_OPENP ||
                    token[j].type == PARSE_OPENB   ) {
                    if (count == 0) {
                        if        (token[i].type == PARSE_CLOSEP &&
                                   token[j].type != PARSE_OPENP    ) {
                            SPRINT0(1, ") found but expected ]");
                            status = OCSM_IMPROPER_NESTING;
                            goto cleanup;
                        } else if (token[i].type == PARSE_CLOSEB &&
                                   token[j].type != PARSE_OPENB    ) {
                            SPRINT0(1, "] found by expected )");
                            status = OCSM_IMPROPER_NESTING;
                            goto cleanup;
                        }
                        break;
                    } else {
                        count--;
                    }
                } else if (token[j].type == PARSE_CLOSEP ||
                           token[j].type == PARSE_CLOSEB   ) {
                    count++;
                }
            }
        }
    }

    /* check for a proper sequencing of tokens */
    for (i = 0; i < ntoken-1; i++) {
        if         (token[i].type == PARSE_OP1  ||
                    token[i].type == PARSE_OP2  ||
                    token[i].type == PARSE_OP3    ) {
            if (token[i+1].type == PARSE_OP1    ||
                token[i+1].type == PARSE_OP2    ||
                token[i+1].type == PARSE_OP3    ||
                token[i+1].type == PARSE_CLOSEP ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_CLOSEB ||
                token[i+1].type == PARSE_COMMA    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_OPENP) {
            if (token[i+1].type == PARSE_OP1    ||
                token[i+1].type == PARSE_OP2    ||
                token[i+1].type == PARSE_OP3    ||
                token[i+1].type == PARSE_CLOSEP ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_CLOSEB ||
                token[i+1].type == PARSE_COMMA    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_CLOSEP) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_OPENB) {
            if (token[i+1].type == PARSE_OP1    ||
                token[i+1].type == PARSE_OP2    ||
                token[i+1].type == PARSE_OP3    ||
                token[i+1].type == PARSE_CLOSEP ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_CLOSEB ||
                token[i+1].type == PARSE_COMMA    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_CLOSEB) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_COMMA) {
            if (token[i+1].type == PARSE_OP1    ||
                token[i+1].type == PARSE_OP2    ||
                token[i+1].type == PARSE_OP3    ||
                token[i+1].type == PARSE_CLOSEP ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_CLOSEB ||
                token[i+1].type == PARSE_COMMA    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_NAME) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_ARRAY) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_NUMBER) {
            if (token[i+1].type == PARSE_OPENP  ||
                token[i+1].type == PARSE_OPENB  ||
                token[i+1].type == PARSE_NAME   ||
                token[i+1].type == PARSE_ARRAY  ||
                token[i+1].type == PARSE_FUNC   ||
                token[i+1].type == PARSE_NUMBER   ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        } else if (token[i].type == PARSE_FUNC    ) {
            if (token[i+1].type != PARSE_OPENP    ) {
                SPRINT2(1, "Illegal token sequence: %s %s", token[i].text, token[i+1].text);
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }
        }
    }

    /* make sure all function names are known */
    for (i = 0; i < ntoken; i++) {
        if (token[i].type == PARSE_FUNC) {
            if (strcmp(token[i].text, "pi"      ) == 0 ||
                strcmp(token[i].text, "min"     ) == 0 ||
                strcmp(token[i].text, "max"     ) == 0 ||
                strcmp(token[i].text, "sqrt"    ) == 0 ||
                strcmp(token[i].text, "abs"     ) == 0 ||
                strcmp(token[i].text, "int"     ) == 0 ||
                strcmp(token[i].text, "nint"    ) == 0 ||
                strcmp(token[i].text, "ceil"    ) == 0 ||
                strcmp(token[i].text, "floor"   ) == 0 ||
                strcmp(token[i].text, "mod"     ) == 0 ||
                strcmp(token[i].text, "sign"    ) == 0 ||
                strcmp(token[i].text, "exp"     ) == 0 ||
                strcmp(token[i].text, "log"     ) == 0 ||
                strcmp(token[i].text, "log10"   ) == 0 ||
                strcmp(token[i].text, "sin"     ) == 0 ||
                strcmp(token[i].text, "sind"    ) == 0 ||
                strcmp(token[i].text, "asin"    ) == 0 ||
                strcmp(token[i].text, "asind"   ) == 0 ||
                strcmp(token[i].text, "cos"     ) == 0 ||
                strcmp(token[i].text, "cosd"    ) == 0 ||
                strcmp(token[i].text, "acos"    ) == 0 ||
                strcmp(token[i].text, "acosd"   ) == 0 ||
                strcmp(token[i].text, "tan"     ) == 0 ||
                strcmp(token[i].text, "tand"    ) == 0 ||
                strcmp(token[i].text, "atan"    ) == 0 ||
                strcmp(token[i].text, "atand"   ) == 0 ||
                strcmp(token[i].text, "atan2"   ) == 0 ||
                strcmp(token[i].text, "atan2d"  ) == 0 ||
                strcmp(token[i].text, "hypot"   ) == 0 ||
                strcmp(token[i].text, "hypot3"  ) == 0 ||
                strcmp(token[i].text, "incline" ) == 0 ||
                strcmp(token[i].text, "Xcent"   ) == 0 ||
                strcmp(token[i].text, "Ycent"   ) == 0 ||
                strcmp(token[i].text, "Xmidl"   ) == 0 ||
                strcmp(token[i].text, "Ymidl"   ) == 0 ||
                strcmp(token[i].text, "seglen"  ) == 0 ||
                strcmp(token[i].text, "radius"  ) == 0 ||
                strcmp(token[i].text, "sweep"   ) == 0 ||
                strcmp(token[i].text, "turnang" ) == 0 ||
                strcmp(token[i].text, "dip"     ) == 0 ||
                strcmp(token[i].text, "smallang") == 0 ||
                strcmp(token[i].text, "val2str" ) == 0 ||
                strcmp(token[i].text, "str2val" ) == 0 ||
                strcmp(token[i].text, "findstr" ) == 0 ||
                strcmp(token[i].text, "slice"   ) == 0 ||
                strcmp(token[i].text, "path"    ) == 0 ||
                strcmp(token[i].text, "ifzero"  ) == 0 ||
                strcmp(token[i].text, "ifpos"   ) == 0 ||
                strcmp(token[i].text, "ifneg"   ) == 0 ||
                strcmp(token[i].text, "ifmatch" ) == 0 ||
                strcmp(token[i].text, "ifnan"   ) == 0   ) {
            } else {
                SPRINT1(1, "Illegel function name: %s", token[i].text);
                status = OCSM_ILLEGAL_FUNC_NAME;
                goto cleanup;
            }
        }
    }

    /* make sure all numbers are properly formed */
    for (i = 0; i < ntoken; i++) {
        if (token[i].type == PARSE_NUMBER) {
            count = 0;
            for (j = 0; j < STRLEN(token[i].text); j++) {
                if (token[i].text[j] == '.') count++;
            }

            if (count > 1) {
                SPRINT1(3, "Illegal number: %s", token[i].text);
                status = OCSM_ILLEGAL_NUMBER;
                goto cleanup;
            }
        }
    }

    /* print the tokens */
    if (outLevel >= 3) {
        SPRINT0(3, "token list");
        for (i = 0; i < ntoken; i++) {
            SPRINT3(3, "    %3d: type=%2d, text=%s", i, token[i].type, token[i].text);
        }
    }

    /* start with empty Rpn-code and op-stacks */
    nrpn     = 0;
    nopstack = 0;

    /* create the Rpn-code stack by cycling through the tokens */
    for (i = 0; i < ntoken; i++) {

        /* PARSE_NAME, PARSE_NUMBER, or PARSE_STRING */
        if (token[i].type == PARSE_NAME   ||
            token[i].type == PARSE_NUMBER ||
            token[i].type == PARSE_STRING   ) {
            PUSH_RPN(token[i].type, token[i].text);

        /* PARSE_OP1 */
        } else if (token[i].type == PARSE_OP1) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP || type == PARSE_OPENB ||
                    type == PARSE_COMMA ||
                    type == PARSE_FUNC  || type == PARSE_ARRAY  ) {
                    PUSH_OP(type, text);
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_OP2 */
        } else if (token[i].type == PARSE_OP2) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP || type == PARSE_OPENB ||
                    type == PARSE_COMMA ||
                    type == PARSE_FUNC  || type == PARSE_ARRAY ||
                    type == PARSE_OP1                            ) {
                    PUSH_OP(type, text);
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_OP3 */
        } else if (token[i].type == PARSE_OP3) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP || type == PARSE_OPENB ||
                    type == PARSE_COMMA ||
                    type == PARSE_FUNC  || type == PARSE_ARRAY ||
                    type == PARSE_OP1   || type == PARSE_OP2    ) {
                    PUSH_OP(type, text);
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_OPENP */
        } else if (token[i].type == PARSE_OPENP) {
            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_CLOSEP */
        } else if (token[i].type == PARSE_CLOSEP) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if  (type == PARSE_OPENP) {
                    if (nopstack <= 0) {

                    } else if (opstack[nopstack-1].type == PARSE_FUNC) {
                        POP_OP(type, text);
                        PUSH_RPN(type, text);
                    }
                    break;
                } else if (type == PARSE_OPENB) {
                    SPRINT0(1, "Found  [ ... )");
                    status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                    goto cleanup;
                } else {
                    PUSH_RPN(type, text);
                }
            }

        /* PARSE_OPENB */
        } else if (token[i].type == PARSE_OPENB) {
            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_CLOSEB */
        } else if (token[i].type == PARSE_CLOSEB) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP) {
                    SPRINT0(1, "Found ( ... ]");
                    status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                    goto cleanup;
                } else if (type == PARSE_OPENB || type == PARSE_COMMA) {
                    PUSH_OP(type, text);
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

            POP_OP(type, text);

            /* two subscripts for array */
            if (type == PARSE_COMMA) {
                POP_OP(type, text);
                POP_OP(type, text);
                PUSH_RPN(type, text);

            /* one subscript for array */
            } else if (type == PARSE_OPENB) {
                PUSH_RPN(PARSE_NUMBER, "0");

                POP_OP(type, text);
                PUSH_RPN(type, text);

            } else {
                SPRINT0(1, "Expected array name when ] found");
                status = OCSM_ILLEGAL_TOKEN_SEQUENCE;
                goto cleanup;
            }

        /* PARSE_COMMA */
        } else if (token[i].type == PARSE_COMMA) {
            while (nopstack > 0) {
                POP_OP(type, text);
                if (type == PARSE_OPENP) {
                    PUSH_OP(type, text);
                    break;
                } else if (type == PARSE_OPENB) {
                    PUSH_OP(type, text);
                    PUSH_OP(PARSE_COMMA, ",");
                    break;
                } else {
                    PUSH_RPN(type, text);
                }
            }

        /* PARSE_FUNC */
        } else if (token[i].type == PARSE_FUNC) {
            PUSH_OP(token[i].type, token[i].text);

        /* PARSE_ARRAY */
        } else if (token[i].type == PARSE_ARRAY) {
            PUSH_OP(token[i].type, token[i].text);

        }
    }

    /* add everything left on the op-stack to the Rpn-code */
    while (nopstack > 0) {
        POP_OP(type, text);

        PUSH_RPN(type, text);
    }

    /* add a PARSE_END to the end of the Rpn-code */
    PUSH_RPN(PARSE_END, "");

    /* print the Rpn-code */
    if (outLevel >= 3) {
        SPRINT0(3, "rpn-code list");
        for (i = 0; i < nrpn; i++) {
            SPRINT3(3, "    %3d: type=%2d, text=%s", i, rpn[i].type, rpn[i].text);
        }
        SPRINT0(3, "exit  str2rpn");
    }

#undef PUSH_OP
#undef POP_OP

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   str2val - convert and evaluate expression (in string)              *
 *                                                                      *
 ************************************************************************
 */

static int
str2val(char      expr[],               /* (in)  string containing expression */
/*@null@*/modl_T  *modl,                /* (in)  pointer to MODL */
        double    *val,                 /* (out) value      of expression */
        double    *dot,                 /* (out) derivative of expression */
        char      str[])                /* (out) value if string-valued (w/o leading $) */
{
    int       status = SUCCESS;         /* (out) return status */

    modl_T    *MODL = (modl_T*)modl;

    rpn_T     *rpn=NULL;                /* Rpn-code */

    ROUTINE(str2val);

    /* --------------------------------------------------------------- */

    SPRINT1(3, "enter str2val(expr=%s)", expr);

    /* default returns */
    *val   = 0;
    *dot   = 0;
    str[0] = '\0';

    MALLOC(rpn, rpn_T, MAX_STACK_SIZE);

    /* short-cut if expression is a single digit */
    if (STRLEN(expr) == 1) {
        if (expr[0] >= '0' && expr[0] <= '9') {
            *val   = expr[0] - '0';
            goto cleanup;
        }
    }

    /* convert the expression to Rpn-code */
    status = str2rpn(expr, rpn);
    if (status != SUCCESS) {
        signalError(MODL, status,
                    "could not parse \"%s\"", expr);
    }
    CHECK_STATUS(str2rpn);

    /* evaluate the Rpn-code */
    status = evalRpn(rpn, modl, val, dot, str);
    if (status != SUCCESS) {
        signalError(MODL, status,
                    "%s when evaluating \"%s\"", str, expr);
    }
    CHECK_STATUS(evalRpn);

cleanup:
    SPRINT3(3, "    %10.5f %10.5f %20s", *val, *dot, str);

    FREE(rpn);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   str2valNoSignal - convert and evaluate expression (in string)      *
 *                                                                      *
 ************************************************************************
 */

static int
str2valNoSignal(char      expr[],       /* (in)  string containing expression */
                modl_T    *modl,        /* (in)  pointer to MODL */
                double    *val,         /* (out) value      of expression */
                double    *dot,         /* (out) derivative of expression */
                char      str[])        /* (out) value if string-valued (w/o leading $) */
{
    int       status = SUCCESS;         /* (out) return status */

    rpn_T     *rpn=NULL;                /* Rpn-code */

    ROUTINE(str2valNoSignal);

    /* --------------------------------------------------------------- */

    SPRINT1(3, "enter str2valNoSignal(expr=%s)", expr);

    /* default returns */
    *val   = 0;
    *dot   = 0;
    str[0] = '\0';

    MALLOC(rpn, rpn_T, MAX_STACK_SIZE);

    /* short-cut if expression is a single digit */
    if (STRLEN(expr) == 1) {
        if (expr[0] >= '0' && expr[0] <= '9') {
            *val   = expr[0] - '0';
            goto cleanup;
        }
    }

    /* convert the expression to Rpn-code */
    status = str2rpn(expr, rpn);
    if (status != SUCCESS) goto cleanup;      // do not print error message

    /* evaluate the Rpn-code */
    status = evalRpn(rpn, modl, val, dot, str);
    if (status != SUCCESS) goto cleanup;      // do not print error message

cleanup:
    SPRINT3(3, "    %10.5f %10.5f %20s", *val, *dot, str);

    FREE(rpn);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   str2vals - convert and evaluate expression to multiple values      *
 *                                                                      *
 ************************************************************************
 */

static int
str2vals(char      expr[],              /* (in)  string containing expression(s) */
         modl_T    *modl,               /* (in)  pointer to MODL */
         int       *nrow,               /* (out) number of rows (if from Parameter) */
         int       *ncol,               /* (out) number of cols (if from Parameter) */
         double    *vals[],             /* (out) values      of expression (freeable) */
         double    *dots[],             /* (out) derivatives of expression (freeable) */
         char      str[])               /* (out) value if string (w/o leading $) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ival, i, ibeg=0, ipmtr, nval, ibrch, imprp, update;
    double    val, dot;
    char      tempexpr[MAX_STR_LEN];
    modl_T    *MODL = (modl_T*)modl;

    rpn_T     *rpn=NULL;                /* Rpn-code */

    ROUTINE(str2vals);

    /* --------------------------------------------------------------- */

    SPRINT1(3, "enter str2vals(expr=%s)", expr);

    /* default returns */
    *nrow = 0;
    *ncol = 0;
    *vals = NULL;
    *dots = NULL;
    str[0] = '\0';

    MALLOC(rpn, rpn_T, MAX_STACK_SIZE);

    /* short-cut if expression is a single digit */
    if (STRLEN(expr) == 1) {
        if (expr[0] >= '0' && expr[0] <= '9') {
            MALLOC(*vals, double, 1);
            MALLOC(*dots, double, 1);

            *nrow    = 1;
            *ncol    = 1;
            *vals[0] = expr[0] - '0';
            *dots[0] = 0;

            SPRINT4(3, "    %10.5f %10.5f %20s %5d",
                    *vals[0], *dots[0], "", 0);

            goto cleanup;
        }
    }

    /* if expr matches the name of Parameter (with possible unary + or -), return its value(s) */
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (strcmp(MODL->pmtr[ipmtr].name, expr    ) == 0                    ||
           (strcmp(MODL->pmtr[ipmtr].name, &expr[1]) == 0 && expr[0] == '-') ||
           (strcmp(MODL->pmtr[ipmtr].name, &expr[1]) == 0 && expr[0] == '+')   ) {
            if (MODL->pmtr[ipmtr].scope == MODL->scope[MODL->level] ||
                MODL->pmtr[ipmtr].type  == OCSM_CONPMTR             ||
                MODL->pmtr[ipmtr].type  == OCSM_OUTPMTR               ) {

                if (MODL->pmtr[ipmtr].str != NULL) {
                    strcpy(str, MODL->pmtr[ipmtr].str);

                    SPRINT4(3, "    %10.5f %10.5f %20s %5d",
                            0., 0., str, 0);
                } else {
                    if (MODL->pmtr[ipmtr].mprop == 1) {
                        status = computeMassProps(MODL);
                        CHECK_STATUS(computeMassProps);

                        ibrch  = MODL->ibrch;
                        update = 0;
                        for (imprp = 0; imprp < MODL->brch[ibrch].nmprp; imprp++) {
                            if (strcmp(expr, MODL->brch[ibrch].mprp[imprp].name) == 0) {
                                MODL->brch[ibrch].mprp[imprp].val = MODL->pmtr[ipmtr].value[0];
                                update = 1;
                                break;
                            }
                        }

                        if (update == 0) {
                            imprp = MODL->brch[ibrch].nmprp;

                            RALLOC(MODL->brch[ibrch].mprp, mprp_T, MODL->brch[ibrch].nmprp+1);

                            strncpy(MODL->brch[ibrch].mprp[imprp].name, expr, 10);
                            MODL->brch[ibrch].mprp[imprp].val = MODL->pmtr[ipmtr].value[0];

                            (MODL->brch[ibrch].nmprp)++;
                        }

                        if (MODL->numdots > 0) {
                            if (MODL->basemodl != NULL) {
                                MODL->basemodl->pmtr[ipmtr].dot[0]
                                    = (MODL->pmtr[ipmtr].value[0] = MODL->basemodl->brch[ibrch].mprp[imprp].val) / MODL->dtime;
                            } else if (MODL->needFDs == 0) {
                                status = computeMassPropsDot(MODL);
                                CHECK_STATUS(computeMassPropsDot);
                            }
                        }
                    }

                    *nrow = MODL->pmtr[ipmtr].nrow;
                    *ncol = MODL->pmtr[ipmtr].ncol;
                    nval  = (*nrow) * (*ncol);

                    MALLOC(*vals, double, nval);
                    MALLOC(*dots, double, nval);

                    for (i = 0; i < nval; i++) {
                        (*vals)[i] = MODL->pmtr[ipmtr].value[i];
                        (*dots)[i] = MODL->pmtr[ipmtr].dot[  i];

                        if (expr[0] == '-') {
                            (*vals)[i] *= -1;
                            (*dots)[i] *= -1;
                        }

                        if (MODL->pmtr[ipmtr].value[i] != -HUGEQ) {
                            SPRINT4(3, "    %10.5f %10.5f %20s %5d",
                                    (*vals)[i], (*dots)[i], "", 0);
                        }
                    }
                }
                goto cleanup;
            }
        }
    }

    /* if it starts with $!, treat as non-string expression */
    if (STRLEN(expr) > 1 && expr[0] == '$' && expr[1] == '!') {
        ibeg = 2;

    /* if it starts with a dollar sign, it should evaluate to one string */
    } else if (expr[0] == '$') {
        STRNCPY(tempexpr, expr, MAX_STR_LEN);

        /* convert the expression to Rpn-code */
        status = str2rpn(tempexpr, rpn);
        if (status != SUCCESS) {
            signalError(MODL, status,
                        "could not parse \"%s\"", tempexpr);
            goto cleanup;
        }
        CHECK_STATUS(str2rpn);

        /* evaluate the Rpn-code */
        status = evalRpn(rpn, modl, &val, &dot, tempexpr);
        if (status != SUCCESS) {
            signalError(MODL, status,
                        "%s when evaluating \"%s\"", tempexpr, expr);
        } else if (STRLEN(tempexpr) == 0) {
            signalError(MODL, status,
                        "%s when evaluating \"%s\"", tempexpr, expr);
        } else {
            *nrow = 0;
            *ncol = 0;
            STRNCPY(str, tempexpr, MAX_STRVAL_LEN);
        }
        goto cleanup;
    }

    /* count the number of semicolons (with an implicit semicolon at the end) */
    *nrow = 0;
    *ncol = 0;
    for (i = 0; i < STRLEN(expr); i++) {
        if (expr[i] == ';') {
            (*ncol)++;
        }
    }
    if (expr[STRLEN(expr)-1] != ';') (*ncol)++;

    if (*ncol <= 0) {
        goto cleanup;
    }

    *nrow = 1;

    /* make arrays to hold the values and dots */
    MALLOC(*vals, double, *ncol);
    MALLOC(*dots, double, *ncol);

    /* loop through the string one value at a time */
    for (ival = 0; ival < *ncol; ival++) {
        STRNCPY(tempexpr, expr, MAX_STR_LEN);

        /* tempexpr contains the part of expr between semicolons */
        i = ibeg;
        while (tempexpr[i] != ';' && i < STRLEN(expr)) {
            i++;
        }
        tempexpr[i] = '\0';

        if (STRLEN(tempexpr) == 0) {
            status = OCSM_ILLEGAL_VALUE;
            signalError(MODL, status,
                        "expression %d is blank", ival);
            goto cleanup;
        }

        /* convert the expression to Rpn-code */
        status = str2rpn(&(tempexpr[ibeg]), rpn);
        if (status != SUCCESS) {
            signalError(MODL, status,
                        "could not parse \"%s\"", &(expr[ibeg]));
        }
        CHECK_STATUS(str2rpn);

        /* evaluate the Rpn-code */
        status = evalRpn(rpn, modl, &val, &dot, tempexpr);
        if (status != SUCCESS) {
            signalError(MODL, status,
                        "%s when evaluating \"%s\"", tempexpr, expr);
            goto cleanup;
        }

        if (STRLEN(tempexpr) > 0) {
            if (*nrow == 1 && *ncol == 1 && ival == 0) {
                *nrow = 0;
                *ncol = 0;
                STRNCPY(str, tempexpr, MAX_STRVAL_LEN);
            } else {
                status = OCSM_WRONG_PMTR_TYPE;
                signalError(MODL, status,
                            "cannot have string in multi-valued expression");
            }
            goto cleanup;
        }

        (*vals)[ival] = val;
        (*dots)[ival] = dot;

        ibeg = i + 1;
    }

cleanup:
    FREE(rpn);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   solsvd - solve  A * x = b  via singular value decomposition        *
 *                                                                      *
 ************************************************************************
 */

static int
solsvd(double A[],                      /* (in)  mrow*ncol matrix */
       double b[],                      /* (in)  mrow-vector (right-hand sides) */
       int    mrow,                     /* (in)  number of rows */
       int    ncol,                     /* (in)  number of columns */
       double W[],                      /* (out) ncol-vector of singular values */
       double x[])                      /* (out) ncol-vector (solution) */
{
    int    status = SUCCESS;            /* (out) return status */

    int    irow, jcol, i, j, k, flag, its, jj, ip1=0, nm=0;
    double *U=NULL, *V=NULL, *r=NULL, *t=NULL;
    double wmin, wmax, s, anorm, c, f, g, h, scale, xx, yy, zz;

    ROUTINE(solsvd);

    /* --------------------------------------------------------------- */

    /* this routine is an adaptation of svf.f found in the netlib
       repository.  it is a modification of a routine from the eispack
       collection, which in turn is a translation of the algol procedure svd,
       num. math. 14, 403-420(1970) by golub and reinsch.
       handbook for auto. comp., vol ii-linear algebra, 134-151(1971). */

    /* default return */
    for (jcol = 0; jcol < ncol; jcol++) {
        x[jcol] = 0;
    }

    /* check for legal size for A */
    if (ncol <= 0) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    } else if (mrow < ncol) {
        status = OCSM_ILLEGAL_VALUE;
        goto cleanup;
    }

    MALLOC(U, double, mrow*ncol);
    MALLOC(V, double, ncol*ncol);
    MALLOC(r, double, ncol     );
    MALLOC(t, double, ncol     );

    /* initializations needed to avoid clang warning */
    for (i = 0; i < ncol; i++) {
        W[i] = 0;
        r[i] = 0;
        t[i] = 0;
    }

    /* initialize U to the original A */
    for (irow = 0; irow < mrow; irow++) {
        for (jcol = 0; jcol < ncol; jcol++) {
            U[irow*ncol+jcol] = A[irow*ncol+jcol];
        }
    }

    /* decompose A into U*W*V' */
    g     = 0;
    scale = 0;
    anorm = 0;

    /* Householder reduction of U to bidiagonal form */
    for (i = 0; i < ncol; i++) {
        ip1   = i + 1;
        r[i]  = scale * g;
        g     = 0;
        s     = 0;
        scale = 0;
        if (i < mrow) {
            for (k = i; k < mrow; k++) {
                scale += fabs(U[k*ncol+i]);
            }
            if (scale != 0) {
                for (k = i; k < mrow; k++) {
                    U[k*ncol+i] /= scale;
                    s           += U[k*ncol+i] * U[k*ncol+i];
                }
                f           = U[i*ncol+i];
                g           = -FSIGN(sqrt(s), f);
                h           = f * g - s;
                U[i*ncol+i] = f - g;
                for (j = ip1; j < ncol; j++) {
                    s = 0;
                    for (k = i; k < mrow; k++) {
                        s += U[k*ncol+i] * U[k*ncol+j];
                    }
                    f = s / h;
                    for (k = i; k < mrow; k++) {
                        U[k*ncol+j] += f * U[k*ncol+i];
                    }
                }
                for (k = i; k < mrow; k++) {
                    U[k*ncol+i] *= scale;
                }
            }
        }
        W[i]  = scale  * g;
        g     = 0;
        s     = 0;
        scale = 0;
        if (i < mrow && i+1 != ncol) {
            for (k = ip1; k < ncol; k++) {
                scale += fabs(U[i*ncol+k]);
            }
            if (scale != 0) {
                for (k = ip1; k < ncol; k++) {
                    U[i*ncol+k] /= scale;
                    s           += U[i*ncol+k] * U[i*ncol+k];
                }
                f           = U[i*ncol+ip1];
                g           = -FSIGN(sqrt(s), f);
                h           = f * g - s;
                U[i*ncol+ip1] = f - g;
                for (k = ip1; k < ncol; k++) {
                    r[k] = U[i*ncol+k] / h;
                }
                for (j = ip1; j < mrow; j++) {
                    s = 0;
                    for (k = ip1; k < ncol; k++) {
                        s += U[j*ncol+k] * U[i*ncol+k];
                    }
                    for (k = ip1; k < ncol; k++) {
                        U[j*ncol+k] += s * r[k];
                    }
                }
                for (k = ip1; k < ncol; k++) {
                    U[i*ncol+k] *= scale;
                }
            }
        }
        anorm = MAX(anorm, (fabs(W[i]) + fabs(r[i])));
    }

    /* accumulation of right-hand transformations */
    for (i = ncol-1; i >= 0; i--) {
        if (i < ncol-1) {
            if (g != 0) {
                for (j = ip1; j < ncol; j++) {
                    V[j*ncol+i] = (U[i*ncol+j] / U[i*ncol+ip1]) / g; /* avoid possible underflow */
                }
                for (j = ip1; j < ncol; j++) {
                    s = 0;
                    for (k = ip1; k < ncol; k++) {
                        s += U[i*ncol+k] * V[k*ncol+j];
                    }
                    for (k = ip1; k < ncol; k++) {
                        V[k*ncol+j] += s * V[k*ncol+i];
                    }
                }
            }
            for (j = ip1; j < ncol; j++) {
                V[i*ncol+j] = 0;
                V[j*ncol+i] = 0;
            }
        }
        V[i*ncol+i] = 1;
        g           = r[i];
        ip1         = i;
    }

    /* accumulation of left-side transformations */
    for (i = MIN(mrow, ncol)-1; i >= 0; i--) {
        ip1 = i + 1;
        g = W[i];
        for (j = ip1; j < ncol; j++) {
            U[i*ncol+j] = 0;
        }
        if (g != 0) {
            g = 1 / g;
            for (j = ip1; j < ncol; j++) {
                s = 0;
                for (k = ip1; k < mrow; k++) {
                    s += U[k*ncol+i] * U[k*ncol+j];
                }
                f = (s / U[i*ncol+i]) * g;
                for (k = i; k < mrow; k++) {
                    U[k*ncol+j] += f * U[k*ncol+i];
                }
            }
            for (j = i; j < mrow; j++) {
                U[j*ncol+i] *= g;
            }
        } else {
            for (j = i; j < mrow; j++) {
                U[j*ncol+i] = 0;
            }
        }
        ++U[i*ncol+i];
    }

    /* diagonalization of the bidiagonal form */

    /* loop over singular values */
    for (k = ncol-1; k >= 0; k--) {

        /* loop over allowed iterations */
        for (its = 0; its < 30; its++) {

            /* test for splitting */
            flag = 1;
            for (ip1 = k; ip1 >= 0; ip1--) {
                nm = ip1 - 1;

                if ((double)(fabs(r[ip1]) + anorm) == anorm) {
                    flag = 0;
                    break;
                }

                assert (nm >= 0);                 /* needed to avoid clang warning */
                assert (nm < ncol);               /* needed to avoid clang warning */

                if ((double)(fabs(W[nm]) + anorm) == anorm) break;
            }
            if (flag) {
                c = 0;
                s = 1;
                for (i = ip1; i < k+1; i++) {
                    f    = s * r[i];
                    r[i] = c * r[i];
                    if ((double)(fabs(f) + anorm) == anorm) break;
                    g    = W[i];
                    if (fabs(f) > fabs(g)) {
                        h = fabs(f) * sqrt(1 + (g/f) * (g/f));
                    } else if (fabs(g) == 0) {
                        h = 0;
                    } else {
                        h = fabs(g) * sqrt(1 + (f/g) * (f/g));
                    }
                    W[i] = h;
                    h    = 1 / h;
                    c    = g * h;
                    s    = -f * h;
                    for (j = 0; j < mrow; j++) {
                        yy           = U[j*ncol+nm];
                        zz           = U[j*ncol+i ];
                        U[j*ncol+nm] = yy * c + zz * s;
                        U[j*ncol+i ] = zz * c - yy * s;
                    }
                }
            }

            /* test for convergence */
            zz = W[k];
            if (ip1 == k) {

                /* make singular values non-negative */
                if (zz < 0) {
                    W[k] = -zz;
                    for (j = 0; j < ncol; j++) {
                        V[j*ncol+k] = -V[j*ncol+k];
                    }
                }
                break;
            }

            assert (ip1 >= 0);                    /* needed to avoid clang warning */
            assert (ip1 < ncol);                  /* needed to avoid clang warning */

            /* shift from bottom 2*2 minor */
            xx = W[ip1];
            nm = k - 1;
            yy = W[nm];
            g  = r[nm];
            h  = r[k];
            f  = ((yy - zz) * (yy + zz) + (g - h) * (g + h)) / (2 * h * yy);
            g  = sqrt(f * f + 1);
            f  = ((xx - zz) * (xx + zz) + h * ((yy / (f + FSIGN(g, f))) - h)) / xx;

            /* next QR transformation */
            c = 1;
            s = 1;
            for (j = ip1; j <= nm; j++) {
                i    = j + 1;
                g    = r[i];
                yy   = W[i];
                h    = s * g;
                g    = c * g;
                if (fabs(f) > fabs(h)) {
                    zz = fabs(f) * sqrt(1 + (h/f) * (h/f));
                } else if (fabs(h) == 0) {
                    zz = 0;
                } else {
                    zz = fabs(h) * sqrt(1 + (f/h) * (f/h));
                }
                r[j] = zz;
                c    = f / zz;
                s    = h / zz;
                f    = xx * c + g * s;
                g    = g * c - xx * s;
                h    = yy * s;
                yy  *= c;
                for (jj = 0; jj < ncol; jj++) {
                    xx           = V[jj*ncol+j];
                    zz           = V[jj*ncol+i];
                    V[jj*ncol+j] = xx * c + zz * s;
                    V[jj*ncol+i] = zz * c - xx * s;
                }
                if (fabs(f) > fabs(h)) {
                    zz = fabs(f) * sqrt(1 + (h/f) * (h/f));
                } else if (fabs(h) == 0) {
                    zz = 0;
                } else {
                    zz = fabs(h) * sqrt(1 + (f/h) * (f/h));
                }

                /* rotation can be arbitrary if zz=0 */
                W[j] = zz;
                if (zz != 0) {
                    zz = 1 / zz;
                    c  = f * zz;
                    s  = h * zz;
                }
                f  = c * g  + s * yy;
                xx = c * yy - s * g;
                for (jj = 0; jj < mrow; jj++) {
                    yy           = U[jj*ncol+j];
                    zz           = U[jj*ncol+i];
                    U[jj*ncol+j] = yy * c + zz * s;
                    U[jj*ncol+i] = zz * c - yy * s;
                }
            }
            r[ip1] = 0;
            r[k  ] = f;
            W[k  ] = xx;
        }
    }

    /* find the largest singular value (for scaling) */
    wmax = 0;
    for (jcol = 0; jcol < ncol; jcol++) {
        if (W[jcol] > wmax) {
            wmax = W[jcol];
        }
    }

    /* set all singular values less than wmin to zero */
    wmin = wmax * 1.0e-6;
    for (jcol = 0; jcol < ncol; jcol++) {
        if (W[jcol] < wmin) {
            W[jcol] = 0;
        }
    }

    /* perform the back-substitution */
    for (j = 0; j < ncol; j++) {
        s = 0;
        if (W[j] != 0) {
            for (i = 0; i < mrow; i++) {
                s += U[i*ncol+j] * b[i];
            }
            s /= W[j];
        }
        t[j] = s;
    }

    for (j = 0; j < ncol; j++) {
        s = 0;
        for (k = 0; k < ncol; k++) {
            s += V[j*ncol+k] * t[k];
        }
        x[j] = s;
    }

cleanup:
    FREE(t);
    FREE(r);
    FREE(V);
    FREE(U);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   velocityForPrimitive - compute the velocity for a primitive        *
 *                                                                      *
 ************************************************************************
 */

int
velocityForPrimitive(modl_T *MODL,      /* (in)  pointer to MODL */
                     int    ibody,      /* (in)  Body index (1:nbody) */
                     int    npnt,       /* (in)  number of points */
                     double xyz[],      /* (in)  coordinated of points */
                     double dxyz[])     /* (out) velocities  of points */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipnt;
    double    ubar, vbar, wbar, dx, dy, dz, perm[9];
    double    x1, y1, z1, x1dot, y1dot, z1dot;
    double    x2, y2, z2, x2dot, y2dot, z2dot;
    double    x3, y3, z3, x3dot, y3dot, z3dot;
    double    x4, y4, z4, x4dot, y4dot, z4dot;
    double    x5,         x5dot;
    double    r5, s5, t5, r5dot, s5dot, t5dot;
    double    xvrtx, yvrtx, zvrtx, xvrtxdot, yvrtxdot, zvrtxdot;
    double    xbase, ybase, zbase, xbasedot, ybasedot, zbasedot;
    double    xbeg,  ybeg,  zbeg,  xbegdot,  ybegdot,  zbegdot;
    double    xend,  yend,  zend,  xenddot,  yenddot,  zenddot;
    double    rad,   tht,          raddot,   thtdot;
    double    psi,   phi,   len,   psidot,   phidot,   lendot;
    double    num,   den,          numdot,   dendot;

    ROUTINE(velocityForPrimitive);

    /* --------------------------------------------------------------- */

    /* get the velocities for a BOX */
    if (MODL->body[ibody].brtype == OCSM_BOX) {
        SPRINT0(2, "        -> analytical for BOX");

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            if (fabs(MODL->body[ibody].arg[4].val[0]) > EPS06) {
                ubar = (xyz[3*ipnt  ] - MODL->body[ibody].arg[1].val[0]) / MODL->body[ibody].arg[4].val[0];
            } else {
                ubar = 0;
            }
            if (fabs(MODL->body[ibody].arg[5].val[0]) > EPS06) {
                vbar = (xyz[3*ipnt+1] - MODL->body[ibody].arg[2].val[0]) / MODL->body[ibody].arg[5].val[0];
            } else {
                vbar = 0;
            }
            if (fabs(MODL->body[ibody].arg[6].val[0]) > EPS06) {
                wbar = (xyz[3*ipnt+2] - MODL->body[ibody].arg[3].val[0]) / MODL->body[ibody].arg[6].val[0];
            } else {
                wbar = 0;
            }

            dxyz[3*ipnt  ] = MODL->body[ibody].arg[1].dot[0] + MODL->body[ibody].arg[4].dot[0] * ubar;
            dxyz[3*ipnt+1] = MODL->body[ibody].arg[2].dot[0] + MODL->body[ibody].arg[5].dot[0] * vbar;
            dxyz[3*ipnt+2] = MODL->body[ibody].arg[3].dot[0] + MODL->body[ibody].arg[6].dot[0] * wbar;
        }

    /* get the velocities for a SPHERE */
    } else if (MODL->body[ibody].brtype == OCSM_SPHERE) {
        SPRINT0(2, "        -> analytical for SPHERE");

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            ubar = (xyz[3*ipnt  ] - MODL->body[ibody].arg[1].val[0]) / MODL->body[ibody].arg[4].val[0];
            vbar = (xyz[3*ipnt+1] - MODL->body[ibody].arg[2].val[0]) / MODL->body[ibody].arg[4].val[0];
            wbar = (xyz[3*ipnt+2] - MODL->body[ibody].arg[3].val[0]) / MODL->body[ibody].arg[4].val[0];

            dxyz[3*ipnt  ] = MODL->body[ibody].arg[1].dot[0] + MODL->body[ibody].arg[4].dot[0] * ubar;
            dxyz[3*ipnt+1] = MODL->body[ibody].arg[2].dot[0] + MODL->body[ibody].arg[4].dot[0] * vbar;
            dxyz[3*ipnt+2] = MODL->body[ibody].arg[3].dot[0] + MODL->body[ibody].arg[4].dot[0] * wbar;
        }

    /* get the velocities for a CONE */
    } else if (MODL->body[ibody].brtype == OCSM_CONE) {
        SPRINT0(2, "        -> analytical for CONE");

        dx = MODL->body[ibody].arg[4].val[0] - MODL->body[ibody].arg[1].val[0];
        dy = MODL->body[ibody].arg[5].val[0] - MODL->body[ibody].arg[2].val[0];
        dz = MODL->body[ibody].arg[6].val[0] - MODL->body[ibody].arg[3].val[0];

        /* permute the coordinates so that fabs(dx) is largest */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            perm[0] = 1;  perm[1] = 0;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 1;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 0;  perm[8] = 1;
        } else if (fabs(dy) >= fabs(dz)) {
            perm[0] = 0;  perm[1] = 1;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 0;  perm[5] = 1;
            perm[6] = 1;  perm[7] = 0;  perm[8] = 0;
        } else {
            perm[0] = 0;  perm[1] = 0;  perm[2] = 1;
            perm[3] = 1;  perm[4] = 0;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 1;  perm[8] = 0;
        }

        xvrtx = perm[0] * MODL->body[ibody].arg[1].val[0]
              + perm[1] * MODL->body[ibody].arg[2].val[0]
              + perm[2] * MODL->body[ibody].arg[3].val[0];
        yvrtx = perm[3] * MODL->body[ibody].arg[1].val[0]
              + perm[4] * MODL->body[ibody].arg[2].val[0]
              + perm[5] * MODL->body[ibody].arg[3].val[0];
        zvrtx = perm[6] * MODL->body[ibody].arg[1].val[0]
              + perm[7] * MODL->body[ibody].arg[2].val[0]
              + perm[8] * MODL->body[ibody].arg[3].val[0];

        xbase = perm[0] * MODL->body[ibody].arg[4].val[0]
              + perm[1] * MODL->body[ibody].arg[5].val[0]
              + perm[2] * MODL->body[ibody].arg[6].val[0];
        ybase = perm[3] * MODL->body[ibody].arg[4].val[0]
              + perm[4] * MODL->body[ibody].arg[5].val[0]
              + perm[5] * MODL->body[ibody].arg[6].val[0];
        zbase = perm[6] * MODL->body[ibody].arg[4].val[0]
              + perm[7] * MODL->body[ibody].arg[5].val[0]
              + perm[8] * MODL->body[ibody].arg[6].val[0];

        rad  = MODL->body[ibody].arg[7].val[0];

        xvrtxdot = perm[0] * MODL->body[ibody].arg[1].dot[0]
                 + perm[1] * MODL->body[ibody].arg[2].dot[0]
                 + perm[2] * MODL->body[ibody].arg[3].dot[0];
        yvrtxdot = perm[3] * MODL->body[ibody].arg[1].dot[0]
                 + perm[4] * MODL->body[ibody].arg[2].dot[0]
                 + perm[5] * MODL->body[ibody].arg[3].dot[0];
        zvrtxdot = perm[6] * MODL->body[ibody].arg[1].dot[0]
                 + perm[7] * MODL->body[ibody].arg[2].dot[0]
                 + perm[8] * MODL->body[ibody].arg[3].dot[0];

        xbasedot = perm[0] * MODL->body[ibody].arg[4].dot[0]
                 + perm[1] * MODL->body[ibody].arg[5].dot[0]
                 + perm[2] * MODL->body[ibody].arg[6].dot[0];
        ybasedot = perm[3] * MODL->body[ibody].arg[4].dot[0]
                 + perm[4] * MODL->body[ibody].arg[5].dot[0]
                 + perm[5] * MODL->body[ibody].arg[6].dot[0];
        zbasedot = perm[6] * MODL->body[ibody].arg[4].dot[0]
                 + perm[7] * MODL->body[ibody].arg[5].dot[0]
                 + perm[8] * MODL->body[ibody].arg[6].dot[0];

        raddot  = MODL->body[ibody].arg[7].dot[0];

        dx = xbase - xvrtx;
        dy = ybase - yvrtx;
        dz = zbase - zvrtx;

        tht = atan2(dy, dx);
        phi = atan2(dz, sqrt(dy*dy + dx*dx));
        len = sqrt(dx*dx + dy*dy + dz*dz);
        psi = atan2(rad, len);

        num = dy;
        den = dx;
        if (fabs(num) > EPS06 || fabs(den) > EPS06) {
            numdot = ybasedot - yvrtxdot;
            dendot = xbasedot - xvrtxdot;
            thtdot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            thtdot = 0;
        }

        num = dz;
        den = sqrt(dy*dy + dx*dx);
        if (fabs(den) > EPS06) {
            numdot = zbasedot - zvrtxdot;
            dendot = (dx * (xbasedot - xvrtxdot) + dy * (ybasedot - yvrtxdot)) / den;
            phidot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            phidot = 0;
        }

        lendot = ( dx * (xbasedot - xvrtxdot)
                 + dy * (ybasedot - yvrtxdot)
                 + dz * (zbasedot - zvrtxdot)) / len;

        psidot = (raddot * len - lendot * rad) / (len * len * rad * rad);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            x1 = perm[0] * xyz[3*ipnt] + perm[1] * xyz[3*ipnt+1] + perm[2] * xyz[3*ipnt+2];
            y1 = perm[3] * xyz[3*ipnt] + perm[4] * xyz[3*ipnt+1] + perm[5] * xyz[3*ipnt+2];
            z1 = perm[6] * xyz[3*ipnt] + perm[7] * xyz[3*ipnt+1] + perm[8] * xyz[3*ipnt+2];

            /* move to origin */
            x2 = x1 - xvrtx;
            y2 = y1 - yvrtx;
            z2 = z1 - zvrtx;

            /* rotate around z2 axis so that cone lies in (x3,z3) plane */
            x3 = x2 * cos(tht) + y2 * sin(tht);
            y3 = y2 * cos(tht) - x2 * sin(tht);
            z3 = z2;

            /* rotate around y3 axis so that cone lies along x3 axis */
            x4 = x3 * cos(phi) + z3 * sin(phi);
            y4 = y3;
            z4 = z3 * cos(phi) - x3 * sin(phi);

            /* conical coordinates (x, psi, theta) */
            x5 = x4;
            s5 = atan2(sqrt(y4*y4 + z4*z4), x4);   /* psi5 */
            t5 = atan2(z4, y4);                    /* theta5 */

            /* set velocities on the cone in its canonical orientation */
            x5dot = x5 / len * lendot;
            t5dot = 0;
            s5dot = s5 / psi * psidot;

            /* transform velocities back to original orientation */
            x4dot = x5dot;
            y4dot = x5dot * cos(t5)       * tan(s5)
                  + s5dot * cos(t5)  * x5 / cos(s5) / cos(s5)
                  - t5dot * sin(t5)  * x5 * tan(s5);
            z4dot = x5dot * sin(t5)       * tan(s5)
                  + s5dot * sin(t5)  * x5 / cos(s5) / cos(s5)
                  + t5dot * cos(t5)  * x5 * tan(s5);

            x3dot = x4dot * cos(phi) - x4 * phidot * sin(phi)
                  - z4dot * sin(phi) - z4 * phidot * cos(phi);
            y3dot = y4dot;
            z3dot = z4dot * cos(phi) - z4 * phidot * sin(phi)
                  + x4dot * sin(phi) + x4 * phidot * cos(phi);

            x2dot = x3dot * cos(tht) - x3 * thtdot * sin(tht)
                  - y3dot * sin(tht) - y3 * thtdot * cos(tht);
            y2dot = y3dot * cos(tht) - y3 * thtdot * sin(tht)
                  + x3dot * sin(tht) + x3 * thtdot * cos(tht);
            z2dot = z3dot;

            x1dot = x2dot + xvrtxdot;
            y1dot = y2dot + yvrtxdot;
            z1dot = z2dot + zvrtxdot;

            dxyz[3*ipnt  ] = perm[0] * x1dot + perm[3] * y1dot + perm[6] * z1dot;
            dxyz[3*ipnt+1] = perm[1] * x1dot + perm[4] * y1dot + perm[7] * z1dot;
            dxyz[3*ipnt+2] = perm[2] * x1dot + perm[5] * y1dot + perm[8] * z1dot;
        }

    /* get the velocities for a CYLINDER */
    } else if (MODL->body[ibody].brtype == OCSM_CYLINDER) {
        SPRINT0(2, "        -> analytical for CYLINDER");

        dx = MODL->body[ibody].arg[4].val[0] - MODL->body[ibody].arg[1].val[0];
        dy = MODL->body[ibody].arg[5].val[0] - MODL->body[ibody].arg[2].val[0];
        dz = MODL->body[ibody].arg[6].val[0] - MODL->body[ibody].arg[3].val[0];

        /* permute the coordinates so that fabs(dx) is largest */
        if (fabs(dx) >= fabs(dy) && fabs(dx) >= fabs(dz)) {
            perm[0] = 1;  perm[1] = 0;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 1;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 0;  perm[8] = 1;
        } else if (fabs(dy) >= fabs(dz)) {
            perm[0] = 0;  perm[1] = 1;  perm[2] = 0;
            perm[3] = 0;  perm[4] = 0;  perm[5] = 1;
            perm[6] = 1;  perm[7] = 0;  perm[8] = 0;
        } else {
            perm[0] = 0;  perm[1] = 0;  perm[2] = 1;
            perm[3] = 1;  perm[4] = 0;  perm[5] = 0;
            perm[6] = 0;  perm[7] = 1;  perm[8] = 0;
        }

        xbeg = perm[0] * MODL->body[ibody].arg[1].val[0]
             + perm[1] * MODL->body[ibody].arg[2].val[0]
             + perm[2] * MODL->body[ibody].arg[3].val[0];
        ybeg = perm[3] * MODL->body[ibody].arg[1].val[0]
             + perm[4] * MODL->body[ibody].arg[2].val[0]
             + perm[5] * MODL->body[ibody].arg[3].val[0];
        zbeg = perm[6] * MODL->body[ibody].arg[1].val[0]
             + perm[7] * MODL->body[ibody].arg[2].val[0]
             + perm[8] * MODL->body[ibody].arg[3].val[0];

        xend = perm[0] * MODL->body[ibody].arg[4].val[0]
             + perm[1] * MODL->body[ibody].arg[5].val[0]
             + perm[2] * MODL->body[ibody].arg[6].val[0];
        yend = perm[3] * MODL->body[ibody].arg[4].val[0]
             + perm[4] * MODL->body[ibody].arg[5].val[0]
             + perm[5] * MODL->body[ibody].arg[6].val[0];
        zend = perm[6] * MODL->body[ibody].arg[4].val[0]
             + perm[7] * MODL->body[ibody].arg[5].val[0]
             + perm[8] * MODL->body[ibody].arg[6].val[0];

        rad  = MODL->body[ibody].arg[7].val[0];

        xbegdot = perm[0] * MODL->body[ibody].arg[1].dot[0]
                + perm[1] * MODL->body[ibody].arg[2].dot[0]
                + perm[2] * MODL->body[ibody].arg[3].dot[0];
        ybegdot = perm[3] * MODL->body[ibody].arg[1].dot[0]
                + perm[4] * MODL->body[ibody].arg[2].dot[0]
                + perm[5] * MODL->body[ibody].arg[3].dot[0];
        zbegdot = perm[6] * MODL->body[ibody].arg[1].dot[0]
                + perm[7] * MODL->body[ibody].arg[2].dot[0]
                + perm[8] * MODL->body[ibody].arg[3].dot[0];

        xenddot = perm[0] * MODL->body[ibody].arg[4].dot[0]
                + perm[1] * MODL->body[ibody].arg[5].dot[0]
                + perm[2] * MODL->body[ibody].arg[6].dot[0];
        yenddot = perm[3] * MODL->body[ibody].arg[4].dot[0]
                + perm[4] * MODL->body[ibody].arg[5].dot[0]
                + perm[5] * MODL->body[ibody].arg[6].dot[0];
        zenddot = perm[6] * MODL->body[ibody].arg[4].dot[0]
                + perm[7] * MODL->body[ibody].arg[5].dot[0]
                + perm[8] * MODL->body[ibody].arg[6].dot[0];

        raddot  = MODL->body[ibody].arg[7].dot[0];

        dx = xend - xbeg;
        dy = yend - ybeg;
        dz = zend - zbeg;

        tht = atan2(dy, dx);                      /* -azimuth  from  xz plane */
        phi = atan2(dz, sqrt(dy*dy + dx*dx));     /* elevation above xy plane */
        len = sqrt(dx*dx + dy*dy + dz*dz);

        num = dy;
        den = dx;
        if (fabs(num) > EPS06 || fabs(den) > EPS06) {
            numdot = yenddot - ybegdot;
            dendot = xenddot - xbegdot;
            thtdot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            thtdot = 0;
        }

        num = dz;
        den = sqrt(dy*dy + dx*dx);
        if (fabs(den) > EPS06) {
            numdot = zenddot - zbegdot;
            dendot = (dx * (xenddot - xbegdot) + dy * (yenddot - ybegdot)) / den;
            phidot = (numdot * den - dendot * num) / (num * num + den * den);
        } else {
            phidot = 0;
        }

        lendot = ( dx * (xenddot - xbegdot)
                 + dy * (yenddot - ybegdot)
                 + dz * (zenddot - zbegdot)) / len;

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            x1 = perm[0] * xyz[3*ipnt] + perm[1] * xyz[3*ipnt+1] + perm[2] * xyz[3*ipnt+2];
            y1 = perm[3] * xyz[3*ipnt] + perm[4] * xyz[3*ipnt+1] + perm[5] * xyz[3*ipnt+2];
            z1 = perm[6] * xyz[3*ipnt] + perm[7] * xyz[3*ipnt+1] + perm[8] * xyz[3*ipnt+2];

            /* move to origin */
            x2 = x1 - xbeg;
            y2 = y1 - ybeg;
            z2 = z1 - zbeg;

            /* rotate around z2 axis so that cylinder lies in (x3,z3) plane */
            x3 = x2 * cos(tht) + y2 * sin(tht);
            y3 = y2 * cos(tht) - x2 * sin(tht);
            z3 = z2;

            /* rotate around y3 axis so that cylinder lies along x3 axis */
            x4 = x3 * cos(phi) + z3 * sin(phi);
            y4 = y3;
            z4 = z3 * cos(phi) - x3 * sin(phi);

            /* cylindrical coordinates (x, r, theta) */
            x5 = x4;
            r5 = sqrt(y4*y4 + z4*z4);   /* rad5 */
            t5 = atan2(z4, y4);         /* theta5 */

            /* set velocities on the cylinder in its canonical orientation */
            x5dot = x5 / len * lendot;
            r5dot = r5 / rad * raddot;
            t5dot = 0;

            /* transform velocities back to original orientation */
            x4dot = x5dot;
            y4dot = r5dot * cos(t5)  - r5 * t5dot  * sin(t5);
            z4dot = r5dot * sin(t5)  + r5 * t5dot  * cos(t5);

            x3dot = x4dot * cos(phi) - x4 * phidot * sin(phi)
                  - z4dot * sin(phi) - z4 * phidot * cos(phi);
            y3dot = y4dot;
            z3dot = z4dot * cos(phi) - z4 * phidot * sin(phi)
                  + x4dot * sin(phi) + x4 * phidot * cos(phi);

            x2dot = x3dot * cos(tht) - x3 * thtdot * sin(tht)
                  - y3dot * sin(tht) - y3 * thtdot * cos(tht);
            y2dot = y3dot * cos(tht) - y3 * thtdot * sin(tht)
                  + x3dot * sin(tht) + x3 * thtdot * cos(tht);
            z2dot = z3dot;

            x1dot = x2dot + xbegdot;
            y1dot = y2dot + ybegdot;
            z1dot = z2dot + zbegdot;

            dxyz[3*ipnt  ] = perm[0] * x1dot + perm[3] * y1dot + perm[6] * z1dot;
            dxyz[3*ipnt+1] = perm[1] * x1dot + perm[4] * y1dot + perm[7] * z1dot;
            dxyz[3*ipnt+2] = perm[2] * x1dot + perm[5] * y1dot + perm[8] * z1dot;
        }
    }

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   velocityOfEdge - compute Edge velocities analytically              *
 *                                                                      *
 ************************************************************************
 */

int
velocityOfEdge(modl_T *MODL,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (1:nbody) */
               int    iedge,            /* (in)  Edge index (1:nedge) */
               int    npnt,             /* (in)  number of points */
     /*@null@*/double t[],              /* (in)  para coords ( npnt in length) */
               double dxyz[])           /* (out) velocities (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       jedge, kedge, ipnt, jbody, kbody, jbrch, npnt_tess, ileft, irite, iarg, periodic, found, knode, kface, iface;
    int       i, attrType, attrLen;
    int       oclass, mtype, nchild, *senses;
    CINT      *tempIlist;
    double    uvleft[6], uvrite[6], dxyzleft[3], dxyzrite[3], xyzleft[18], xyzrite[18], temp[18], uvbest[2], xyzbest[18];
    double    normleft[4], normrite[4], A[9], b[3];
    double    data[18], data_dot[18], mat[12], scale, trange[2], bboxj[6], bboxk[6], dbest, dtest, frac;
    double    *ts=NULL, *xyz=NULL;
    CDOUBLE   *xyz_tess, *t_tess;
    ego       ecurve, eref, *echilds;

    int         ibrch, udp_num, *udp_types, *udp_idef, needfd;
    double      *udp_ddef;
    char        **udp_names, primtype[MAX_EXPR_LEN];

    ROUTINE(velocityOfEdge);

    /* --------------------------------------------------------------- */

#if PRINT_CALLHISTORY > 0
    for (i_callHistory = 0; i_callHistory < indent_callHistory; i_callHistory++) fprintf(fp_callHistory, ".  ");
    fprintf(fp_callHistory, "velocityOfEdge(ibody=%2d, iedge=%3d)\n", ibody, iedge);
    indent_callHistory++;
#endif

    /* overall strategy:
     - if a degenerate edge return 0
     - find (jbody,jedge) which is where (ibody,iedge) first existed
     - find mat           which is the transformation matrix needed to
                          transform a point in (ibody,iedge) back to (jbody,jedge)
     - find scale         which is the scale factor needed to transform
                          t in (ibody,iedge) back to (jbody,jedge) for LINEs
     - find xyz           which are the physical   coordinates of the points in (jbody,jedge)
     - find ts            which are the parametric coordinates of the points in (jbody,jedge)
     - find dxyz          which are the velocities in the (jbody,jedge)
     - transform dxyz     back to (ibody,iedge)
    */

    if (t == NULL) {
        SPRINT3(2, " -> velocityOfEdge(ibody=%3d, iedge=%3d, npnt=%5d) -> NULL", ibody, iedge, npnt);
    } else if (npnt < 11) {
        SPRINT4(2, " -> velocityOfEdge(ibody=%3d, iedge=%3d, npnt=%5d) -> %12.6f", ibody, iedge, npnt, t[0]);
        for (ipnt = 1; ipnt < npnt; ipnt++) {
            SPRINT1(2, "                                                        %12.6f", t[ipnt]);
        }
    } else {
        SPRINT4(2, " -> velocityOfEdge(ibody=%3d, iedge=%3d, npnt=%5d) -> %12.6f", ibody, iedge, npnt, t[0]);
        for (ipnt = 1; ipnt <= 5; ipnt++) {
            SPRINT1(2, "                                                        %12.6f", t[ipnt]);
        }
        SPRINT0(2, "                                                            ...")
        for (ipnt = npnt-5; ipnt < npnt; ipnt++) {
            SPRINT1(2, "                                                        %12.6f", t[ipnt]);
        }
    }

    if        (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    } else if (iedge < 1 || iedge > MODL->body[ibody].nedge) {
        status = OCSM_EDGE_NOT_FOUND;
        goto cleanup;
    }

    /* if this is a degenerate Edge, return zero velocities */
    if (MODL->body[ibody].edge[iedge].itype == DEGENERATE) {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] = 0;
            dxyz[3*ipnt+1] = 0;
            dxyz[3*ipnt+2] = 0;
        }

        goto cleanup;
    }

    /* if there is an active perturbation, get velocity by finite
       differences */
    if (MODL->perturb != NULL) {
        SPRINT0(2, "        -> finite differencing");
        status = finiteDifference(MODL, ibody, OCSM_EDGE, iedge, npnt, t, dxyz);
        CHECK_STATUS(finiteDifference);

        goto cleanup;
    }

    /* get the necessary temporary storage */
    MALLOC(xyz, double, 3*npnt);
    MALLOC(ts,  double,   npnt);

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    status = xformEdgeToOriginal(MODL, ibody, iedge, mat, &scale);
    CHECK_STATUS(xformEdgeToOriginal);

    /* jbody is the Body in which this Edge first appeared */
    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    jbody = tempIlist[0];
    jedge = tempIlist[1];
    jbrch = MODL->body[jbody].ibrch;
    SPRINT4(2, "        ibody=%d,iedge=%d maps to jbody=%d,jedge=%d", ibody, iedge, jbody, jedge);

    /* if t==NULL, then find the locations of the tessellation points when
       the Edge was first created */
    if (t == NULL) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt_tess, &xyz_tess, &t_tess);
        CHECK_STATUS(EG_getTessEdge);

        if (npnt != npnt_tess) {
            status = OCSM_ILLEGAL_ARGUMENT;
            goto cleanup;
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                ts[ipnt] = t_tess[ipnt];
            }

            /* xyz are the tessellation points transformed back
               to their locations in jbody */
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                xyz[3*ipnt  ] = xyz_tess[3*ipnt  ] * mat[ 0]
                              + xyz_tess[3*ipnt+1] * mat[ 1]
                              + xyz_tess[3*ipnt+2] * mat[ 2] + mat[ 3];
                xyz[3*ipnt+1] = xyz_tess[3*ipnt  ] * mat[ 4]
                              + xyz_tess[3*ipnt+1] * mat[ 5]
                              + xyz_tess[3*ipnt+2] * mat[ 6] + mat[ 7];
                xyz[3*ipnt+2] = xyz_tess[3*ipnt  ] * mat[ 8]
                              + xyz_tess[3*ipnt+1] * mat[ 9]
                              + xyz_tess[3*ipnt+2] * mat[10] + mat[11];
            }
        }

    /* otherwise, find the locations at the given t's when the Edge
       was first created */
    } else {

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            ts[ipnt] = t[ipnt];
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate(MODL->body[ibody].edge[iedge].eedge,
                                 &(t[ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            xyz[3*ipnt  ] = data[0] * mat[ 0]
                          + data[1] * mat[ 1]
                          + data[2] * mat[ 2] + mat[ 3];
            xyz[3*ipnt+1] = data[0] * mat[ 4]
                          + data[1] * mat[ 5]
                          + data[2] * mat[ 6] + mat[ 7];
            xyz[3*ipnt+2] = data[0] * mat[ 8]
                          + data[1] * mat[ 9]
                          + data[2] * mat[10] + mat[11];
        }
    }

    /* if there are dots on the Edge, use them directly */
    if (EG_hasGeometry_dot(MODL->body[ibody].edge[iedge].eedge) == EGADS_SUCCESS) {
        SPRINT0(2, "        -> getting velocity from dot cache");

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate_dot(MODL->body[ibody].edge[iedge].eedge, &(ts[ipnt]), NULL, data, data_dot);
            CHECK_STATUS(EG_evaluate_dot);

            dxyz[3*ipnt  ] = data_dot[0];
            dxyz[3*ipnt+1] = data_dot[1];
            dxyz[3*ipnt+2] = data_dot[2];
        }

        goto cleanup;
    }

    /* if the Edge is a LINE, modify t by scale */
    status = EG_getTopology(MODL->body[ibody].edge[iedge].eedge, &ecurve, &oclass, &mtype,
                            data, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    status = EG_getGeometry(ecurve, &oclass, &mtype, &eref, NULL, NULL);
    CHECK_STATUS(EG_getGeometry);

    if (oclass == CURVE && mtype == LINE) {
        SPRINT1(2, "            -> modifying ts by factor %10.5f", scale);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            ts[ipnt] /= scale;
        }
    }

    /* if there are no Parameter changes, then the velocities are all 0 (and do not
       bother computing the derivatives below) */
    if (MODL->body[jbody].hasdots == 0) {
        SPRINT1(2, "        -> setting to zero (Edge in %s)", ocsmGetText(MODL->body[jbody].brtype));
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] = 0;
            dxyz[3*ipnt+1] = 0;
            dxyz[3*ipnt+2] = 0;
        }

    /* get the velocities for a BOX */
    } else if (MODL->body[jbody].brtype == OCSM_BOX) {
        status = velocityForPrimitive(MODL, jbody, npnt, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a SPHERE */
    } else if (MODL->body[jbody].brtype == OCSM_SPHERE) {
        status = velocityForPrimitive(MODL, jbody, npnt, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a CONE */
    } else if (MODL->body[jbody].brtype == OCSM_CONE) {
        status = velocityForPrimitive(MODL, jbody, npnt, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a CYLINDER */
    } else if (MODL->body[jbody].brtype == OCSM_CYLINDER) {
        status = velocityForPrimitive(MODL, jbody, npnt, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a UDPRIM */
    } else if (MODL->body[jbody].brtype == OCSM_UDPRIM) {
        SPRINT0(2, "        -> analytical for UDPRIM");

        /* load and execute the user-defined primitive */
        ibrch = MODL->body[jbody].ibrch;

        STRNCPY(primtype, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);

        status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
        if (status == EGADS_NOLOAD) {
            status = EGADS_SUCCESS;
        }
        CHECK_STATUS(udp_initialize);

        status = udp_clrArguments(primtype);
        CHECK_STATUS(udp_clrArguments);

        needfd = 0;

        /* go back to first associated udparg statement whose primtype matches the
           UDPRIM's primtype */
        kbody = jbody - 1;
        while (kbody > 0 && MODL->body[kbody].brtype == OCSM_UDPARG &&
              strcmp(MODL->body[kbody].arg[1].str, MODL->body[jbody].arg[1].str) == 0) {
            kbody--;
        }
        kbody++;

        while (kbody <= jbody) {
            for (iarg = 3; iarg < 10; iarg+=2) {
                if (MODL->body[kbody].arg[iarg].nval < 0) break;

                if (MODL->body[kbody].arg[iarg].nval > 0) {
                    status = udp_setVelocity(MODL->body[kbody].arg[1].str,
                                             MODL->body[jbody].ebody,
                                             MODL->body[kbody].arg[iarg-1].str,
                                             MODL->body[kbody].arg[iarg  ].dot,
                                             MODL->body[kbody].arg[iarg  ].nval);

                    if (status != EGADS_SUCCESS) {
                        /* indexerr indicates that a variable is not available for sensitivity,
                           (for example an integer), so we will just get zeroes */
                        if (status == EGADS_INDEXERR) {
                            SPRINT2(1, "WARNING:: analytic sensitivity cannot be computed for \"%s\" in %s (1)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* notfound indicates that a variable is not available for sensitivity,
                           so compute sensitivity by finite differences */
                        } else if (status == EGADS_NOTFOUND) {
                            SPRINT2(1, "WARNING:: analytic sensitivity cannot be computed for \"%s\" in %s (2)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* unknown error type */
                        } else {
                            needfd++;
                        }
                    }
                }
            }

            kbody++;
        }

        /* if any of the velocities could not be set, we need finite differences */
        if (needfd > 0) {
            SPRINT0(1, "        -> reverting to finiteDifferences");

            if (MODL->perturb == NULL) {
                MODL->dtime = DTIME_NOM;

                status = createPerturbation(MODL);
                CHECK_STATUS(createPerturbation);
            }

            status = finiteDifference(MODL, ibody, OCSM_EDGE, iedge, npnt, t, dxyz);
            CHECK_STATUS(finiteDifference);

            goto cleanup;
        }

        if (jedge > 0) {
            status = udp_sensitivity(primtype, MODL->body[jbody].ebody,
                                     npnt, OCSM_EDGE, jedge, ts, dxyz);
            if (status == EGADS_NOLOAD) {
                SPRINT0(1, "        -> reverting to finiteDifferences");

                if (MODL->perturb == NULL) {
                    MODL->dtime = DTIME_NOM;

                    status = createPerturbation(MODL);
                    CHECK_STATUS(createPerturbation);
                }

                status = finiteDifference(MODL, ibody, OCSM_EDGE, iedge, npnt, t, dxyz);
                CHECK_STATUS(finiteDifference);
                goto cleanup;
            }
            CHECK_STATUS(udp_sensitivity);
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "cannot find Edge %d:%d in jbody=%d", ibody, iedge, jbody);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

    /* get the velocities for an EXTRUDEd WireBody */
    } else if (MODL->body[jbody].brtype == OCSM_EXTRUDE  &&
               MODL->body[jbody].botype == OCSM_WIRE_BODY  ) {

        status = EG_getRange(MODL->body[jbody].edge[1].eedge, trange, &periodic);
        CHECK_STATUS(EG_getRange);

        status = velocityOfNode(MODL, jbody, MODL->body[jbody].edge[1].ibeg, dxyz);
        CHECK_STATUS(velocityOfNode);

        for (ipnt = 1; ipnt < npnt; ipnt++) {
            frac = (ts[ipnt] - trange[0]) / (trange[1] - trange[0]);

            dxyz[3*ipnt  ] = dxyz[0] + frac * MODL->body[jbody].arg[1].dot[0];
            dxyz[3*ipnt+1] = dxyz[1] + frac * MODL->body[jbody].arg[2].dot[0];
            dxyz[3*ipnt+2] = dxyz[2] + frac * MODL->body[jbody].arg[3].dot[0];
        }

    /* get the velocities for an EXTRUDE */
    } else if (MODL->body[jbody].brtype == OCSM_EXTRUDE) {

        status = EG_attributeRet(MODL->body[jbody].edge[jedge].eedge, "__trace__",
                                 &attrType, &attrLen, &tempIlist, NULL, NULL);
        CHECK_STATUS(EG_attributeRet);

        /* if this Edge has a long history, it came from the Xsect, get the velocity from it */
        if (attrLen > 2) {
            kbody = tempIlist[0];
            kedge = tempIlist[1];

            status = velocityOfEdge(MODL, kbody, kedge, npnt, t, dxyz);
            CHECK_STATUS(velocityOfEdge);

            /* otherwise try to figure out the heritage of the Edge */
        } else {
            status = EG_getRange(MODL->body[jbody].edge[jedge].eedge, trange, &periodic);
            CHECK_STATUS(EG_getRange);

            status = EG_evaluate(MODL->body[jbody].edge[jedge].eedge, trange, data);
            CHECK_STATUS(EG_evaluate);

            /* see if the beginning of the Edge is at one of the Nodes */
            found = 0;
            kbody = MODL->body[jbody].ileft;
            for (knode = 1; knode <= MODL->body[kbody].nnode; knode++) {
                if (fabs(MODL->body[kbody].node[knode].x-data[0]) < EPS06 &&
                    fabs(MODL->body[kbody].node[knode].y-data[1]) < EPS06 &&
                    fabs(MODL->body[kbody].node[knode].z-data[2]) < EPS06   ) {

                    status = velocityOfNode(MODL, kbody, knode, data);
                    CHECK_STATUS(velocityOfNode);

                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        data[3] = (ts[ipnt] - trange[0]) / (trange[1] - trange[0]);
                        dxyz[3*ipnt  ] = data[0] + data[3] * MODL->body[jbody].arg[1].dot[0];
                        dxyz[3*ipnt+1] = data[1] + data[3] * MODL->body[jbody].arg[2].dot[0];
                        dxyz[3*ipnt+2] = data[2] + data[3] * MODL->body[jbody].arg[3].dot[0];
                    }

                    found = knode;
                    break;
                }
            }

            /* get bounding box of jedge, minus the extrude offset */
            if (found == 0) {
                status = EG_getBoundingBox(MODL->body[jbody].edge[jedge].eedge, bboxj);
                CHECK_STATUS(EG_getBoundingBox);

                bboxj[0] -= MODL->body[jbody].arg[1].val[0];
                bboxj[1] -= MODL->body[jbody].arg[2].val[0];
                bboxj[2] -= MODL->body[jbody].arg[3].val[0];
                bboxj[3] -= MODL->body[jbody].arg[1].val[0];
                bboxj[4] -= MODL->body[jbody].arg[2].val[0];
                bboxj[5] -= MODL->body[jbody].arg[3].val[0];

                /* see if jedge is one of the displaced Edges */
                found = 0;
                dbest = HUGEQ;

                for (kedge = 1; kedge <= MODL->body[kbody].nedge; kedge++) {
                    status = EG_getBoundingBox(MODL->body[kbody].edge[kedge].eedge, bboxk);
                    CHECK_STATUS(EG_getBoundingBox);

                    dtest = fabs(bboxj[0]-bboxk[0]) + fabs(bboxj[1]-bboxk[1])
                        +   fabs(bboxj[2]-bboxk[2]) + fabs(bboxj[3]-bboxk[3])
                        +   fabs(bboxj[4]-bboxk[4]) + fabs(bboxj[5]-bboxk[5]);

                    if (dtest < dbest) {
                        found = kedge;
                        dbest = dtest;
                    }
                }

                if (found > 0) {
                    status = velocityOfEdge(MODL, kbody, found, npnt, ts, dxyz);
                    CHECK_STATUS(velocityOfEdge);

                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        dxyz[3*ipnt  ] += MODL->body[jbody].arg[1].dot[0];
                        dxyz[3*ipnt+1] += MODL->body[jbody].arg[2].dot[0];
                        dxyz[3*ipnt+2] += MODL->body[jbody].arg[3].dot[0];
                    }
                }
            }
        }

    /* if the Edge was generated by an OCSM_RULE or OCSM_BLEND, get the velocity
       from  the _dot routine */
    } else if (MODL->body[jbody].brtype == OCSM_RULE ||
               MODL->body[jbody].brtype == OCSM_BLEND  ) {

        /* if the sensitivity is not present, make it now */
        if (MODL->body[jbody].hassens == 0) {
            SPRINT1(2, "           creating RULE cache for jbody=%d", jbody);

            status = createVelocityCache(MODL, jbody);
            CHECK_STATUS(createVelocityCache);
        } else {
            SPRINT1(2, "           reusing  RULE cache for jbody=%d", jbody);
        }

        /* Edge is one for which the EG_evaluate_dot works */
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate_dot(MODL->body[jbody].edge[jedge].eedge,
                                     &(ts[ipnt]), NULL, data, data_dot);
            CHECK_STATUS(EG_evaluate_dot);

            dxyz[3*ipnt  ] = data_dot[0];
            dxyz[3*ipnt+1] = data_dot[1];
            dxyz[3*ipnt+2] = data_dot[2];
        }

    /* if the Edge was generated by an OCSM_BOOLEAN or another OCSM_GROWN,
       the velocity can be obtained from Face velocities */
    } else if (MODL->brch[jbrch].bclass == OCSM_BOOLEAN ||
               MODL->brch[jbrch].bclass == OCSM_GROWN    ) {

        ileft = MODL->body[jbody].edge[jedge].ileft;
        irite = MODL->body[jbody].edge[jedge].irite;
        SPRINT3(2, "        -> Edge velocity gotten from BOOLEAN or GROWN (jbody=%d, ileft=%d, irite=%d)", jbody, ileft, irite);

        kbody = 0;
        kface = 0;

        /* if a non-manifold Edge, find the Face in the SolidBody associated with the Edge midpoint */
        if        (ileft <= 0 && irite <= 0) {

        } else if (ileft <= 0 || irite <= 0) {
            if        (MODL->body[MODL->body[jbody].ileft].botype == OCSM_SOLID_BODY) {
                kbody = MODL->body[jbody].ileft;
            } else if (MODL->body[MODL->body[jbody].irite].botype == OCSM_SOLID_BODY) {
                kbody = MODL->body[jbody].irite;
            } else {
                status = OCSM_BODY_NOT_FOUND;
                signalError(MODL, status,
                            "could not find matching SolidBody for jedge=%d", jedge);
                goto cleanup;
            }

            temp[0] = xyz[3*(npnt/2)  ];
            temp[1] = xyz[3*(npnt/2)+1];
            temp[2] = xyz[3*(npnt/2)+2];

            kface = 0;
            dbest = HUGEQ;
            for (iface = 1; iface <= MODL->body[kbody].nface; iface++) {
                status = EG_invEvaluate(MODL->body[kbody].face[iface].eface, temp, uvbest, xyzbest);
                CHECK_STATUS(EG_invEvaluate);

                dtest = (temp[0]-xyzbest[0]) * (temp[0]-xyzbest[0])
                    +   (temp[1]-xyzbest[1]) * (temp[1]-xyzbest[1])
                    +   (temp[2]-xyzbest[2]) * (temp[2]-xyzbest[2]);
                if (dtest < dbest) {
                    kface     = iface;
                    dbest     = dtest;
                }
            }
            if (sqrt(dbest) > EPS06) {
                status = OCSM_FACE_NOT_FOUND;
                signalError(MODL, status,
                            "could not find Face in kbody=%d", kbody);
                goto cleanup;
            }
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate(MODL->body[jbody].edge[jedge].eedge,
                                 &(ts[ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            /* velocity of left Face */
            if (ileft > 0) {
                status = EG_getEdgeUVeval(MODL->body[jbody].face[ileft].eface,
                                          MODL->body[jbody].edge[jedge].eedge, 0, ts[ipnt], uvleft);
                CHECK_STATUS(EG_getEdgeUVeval);

                status = velocityOfFace(MODL, jbody, ileft, 1, uvleft, dxyzleft);
                CHECK_STATUS(velocityOfFace);

                status = EG_evaluate(MODL->body[jbody].face[ileft].eface, uvleft, xyzleft);
                CHECK_STATUS(EG_evaluate);
            } else {
                status = EG_evaluate(MODL->body[jbody].edge[jedge].eedge, &(ts[ipnt]), temp);
                CHECK_STATUS(EG_evaluate);

                status = EG_invEvaluate(MODL->body[kbody].face[kface].eface, temp, uvleft, data);
                CHECK_STATUS(EG_invEvaluate);

                status = velocityOfFace(MODL, kbody, kface, 1, uvleft, dxyzleft);
                CHECK_STATUS(velocityOfFace);

                status = EG_evaluate(MODL->body[kbody].face[kface].eface, uvleft, xyzleft);
                CHECK_STATUS(EG_evaluate);
            }

            /* velocity of rite Face */
            if (irite > 0) {
                status = EG_getEdgeUVeval(MODL->body[jbody].face[irite].eface,
                                          MODL->body[jbody].edge[jedge].eedge, 0, ts[ipnt], uvrite);
                CHECK_STATUS(EG_getEdgeUVeval);

                status = velocityOfFace(MODL, jbody, irite, 1, uvrite, dxyzrite);
                CHECK_STATUS(velocityOfFace);

                status = EG_evaluate(MODL->body[jbody].face[irite].eface, uvrite, xyzrite);
                CHECK_STATUS(EG_evaluate);
            } else {
                status = EG_evaluate(MODL->body[jbody].edge[jedge].eedge, &(ts[ipnt]), temp);
                CHECK_STATUS(EG_evaluate);

                status = EG_invEvaluate(MODL->body[kbody].face[kface].eface, temp, uvrite, data);
                CHECK_STATUS(EG_invEvaluate);

                status = velocityOfFace(MODL, kbody, kface, 1, uvrite, dxyzrite);
                CHECK_STATUS(velocityOfFace);

                status = EG_evaluate(MODL->body[kbody].face[kface].eface, uvrite, xyzrite);
                CHECK_STATUS(EG_evaluate);
            }

            /* if both ileft and irite are non-positive, returned velocity is 0 */
            if (ileft <= 0 && irite <= 0) {
                dxyz[3*ipnt  ] = 0;
                dxyz[3*ipnt+1] = 0;
                dxyz[3*ipnt+2] = 0;

            /* if all velocities are 0, then returned velocity is 0 too */
            } else if (fabs(dxyzleft[0]) < EPS06 &&
                       fabs(dxyzleft[1]) < EPS06 &&
                       fabs(dxyzleft[2]) < EPS06 &&
                       fabs(dxyzrite[0]) < EPS06 &&
                       fabs(dxyzrite[1]) < EPS06 &&
                       fabs(dxyzrite[2]) < EPS06   ) {
                dxyz[3*ipnt  ] = 0;
                dxyz[3*ipnt+1] = 0;
                dxyz[3*ipnt+2] = 0;

            } else if (fabs(dxyzleft[0]-dxyzrite[0]) < EPS06 &&
                       fabs(dxyzleft[1]-dxyzrite[1]) < EPS06 &&
                       fabs(dxyzleft[2]-dxyzrite[2]) < EPS06   ) {
                dxyz[3*ipnt  ] = (dxyzleft[0] + dxyzrite[0]) / 2;
                dxyz[3*ipnt+1] = (dxyzleft[1] + dxyzrite[1]) / 2;
                dxyz[3*ipnt+2] = (dxyzleft[2] + dxyzrite[2]) / 2;

            /* otherwise find a combination of the Face velocities */
            } else {

                /* left Face normal */
                normleft[0]  = xyzleft[4] * xyzleft[8] - xyzleft[5] * xyzleft[7];
                normleft[1]  = xyzleft[5] * xyzleft[6] - xyzleft[3] * xyzleft[8];
                normleft[2]  = xyzleft[3] * xyzleft[7] - xyzleft[4] * xyzleft[6];
                normleft[3]  = sqrt(normleft[0]*normleft[0] + normleft[1]*normleft[1] + normleft[2]*normleft[2]);
                normleft[0] /= normleft[3];
                normleft[1] /= normleft[3];
                normleft[2] /= normleft[3];

                /* rite Face normal */
                normrite[0]  = xyzrite[4] * xyzrite[8] - xyzrite[5] * xyzrite[7];
                normrite[1]  = xyzrite[5] * xyzrite[6] - xyzrite[3] * xyzrite[8];
                normrite[2]  = xyzrite[3] * xyzrite[7] - xyzrite[4] * xyzrite[6];
                normrite[3]  = sqrt(normrite[0]*normrite[0] + normrite[1]*normrite[1] + normrite[2]*normrite[2]);
                normrite[0] /= normrite[3];
                normrite[1] /= normrite[3];
                normrite[2] /= normrite[3];

                /* just use face velocity if normleft and normrite are parallel */
                if (fabs(normleft[1]*normrite[2]-normleft[2]*normrite[1]) < EPS12 &&
                    fabs(normleft[2]*normrite[0]-normleft[0]*normrite[2]) < EPS12 &&
                    fabs(normleft[0]*normrite[1]-normleft[1]*normrite[0]) < EPS12   ) {
                    dxyz[3*ipnt  ] = dxyzleft[0];
                    dxyz[3*ipnt+1] = dxyzleft[1];
                    dxyz[3*ipnt+2] = dxyzleft[2];

                /* just use rite Face velocity if normleft is zero */
                } else if (fabs(normleft[0]) < EPS06 &&
                           fabs(normleft[1]) < EPS06 &&
                           fabs(normleft[2]) < EPS06   ) {
                    dxyz[3*ipnt  ] = dxyzrite[0];
                    dxyz[3*ipnt+1] = dxyzrite[1];
                    dxyz[3*ipnt+2] = dxyzrite[2];

                /* just use left Face velocity if normrite is zero */
                } else if (fabs(normrite[0]) < EPS06 &&
                           fabs(normrite[1]) < EPS06 &&
                           fabs(normrite[2]) < EPS06   ) {
                    dxyz[3*ipnt  ] = dxyzleft[0];
                    dxyz[3*ipnt+1] = dxyzleft[1];
                    dxyz[3*ipnt+2] = dxyzleft[2];

                /* find a common velocity that is consistent with the
                   normal velocities of the left and rite Face */
                } else {
                    A[0] = normleft[0];
                    A[1] = normleft[1];
                    A[2] = normleft[2];
                    b[0] = normleft[0] * dxyzleft[0] + normleft[1] * dxyzleft[1] + normleft[2] * dxyzleft[2];

                    A[3] = normrite[0];
                    A[4] = normrite[1];
                    A[5] = normrite[2];
                    b[1] = normrite[0] * dxyzrite[0] + normrite[1] * dxyzrite[1] + normrite[2] * dxyzrite[2];

                    A[6] = data[3];
                    A[7] = data[4];
                    A[8] = data[5];
                    b[2] = 0;

                    status = matsol(A, b, 3, &(dxyz[3*ipnt]));
                    if (status < 0) {
                        SPRINT0(1, "WARNING:: singular matrix detected.  setting vel=0");
                        SPRINT4(1, "ibody=%d,  iedge=%d, ileft=%d,  irite=%d", ibody, iedge, ileft, irite);
                        SPRINT3(1, "xyzleft   %10.4f %10.4f %10.4f", xyzleft[0],  xyzleft[1],  xyzleft[2]);
                        SPRINT3(1, "xyzrite   %10.4f %10.4f %10.4f", xyzrite[0],  xyzrite[1],  xyzrite[2]);
                        SPRINT3(1, "normleft  %10.4f %10.4f %10.4f", normleft[0], normleft[1], normleft[2]);
                        SPRINT3(1, "normrite  %10.4f %10.4f %10.4f", normrite[0], normrite[1], normrite[2]);
                        SPRINT3(1, "dxyzleft  %10.4f %10.4f %10.4f", dxyzleft[0], dxyzleft[1], dxyzleft[2]);
                        SPRINT3(1, "dxyzrite  %10.4f %10.4f %10.4f", dxyzrite[0], dxyzrite[1], dxyzrite[2]);
                        dxyz[3*ipnt  ] = 0;
                        dxyz[3*ipnt+1] = 0;
                        dxyz[3*ipnt+2] = 0;
                    }
                }
            }
        }

#ifdef ANALYTIC_SKETCH
//$$$    /* get the velocities for a sketch */
//$$$    } else if (MODL->body[jbody].brtype == OCSM_SKEND) {
//$$$        SPRINT0(2, "        -> analytical for SKEND");
//$$$
//$$$        for (ipnt = 0; ipnt < npnt; ipnt++) {
//$$$            dxyz[3*ipnt  ] = 0;
//$$$            dxyz[3*ipnt+1] = 0;
//$$$            dxyz[3*ipnt+2] = 0;
//$$$        }
#endif

    }

    /* modify the velocities based upon the Edge's history */
    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    for (i = 0; i < attrLen; i+=2) {
        if (MODL->body[tempIlist[i]].brtype != OCSM_EXTRUDE) {
                status = xformVelocity(MODL, tempIlist[i], npnt, xyz, dxyz);
                CHECK_STATUS(xformVelocity);
            }
    }

cleanup:
#if PRINT_CALLHISTORY > 0
    indent_callHistory--;
#endif

    SPRINT6(2, " <- velocityOfEdge(ibody=%3d, iedge=%3d, npnt=%5d) -> %12.6f %12.6f %12.6f",
            ibody, iedge, npnt, dxyz[0], dxyz[1], dxyz[2]);
    if (npnt < 11) {
        for (ipnt = 1; ipnt < npnt; ipnt++) {
            SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                    dxyz[3*ipnt], dxyz[3*ipnt+1], dxyz[3*ipnt+2]);
        }
    } else {
        for (ipnt = 1; ipnt < 5; ipnt++) {
            SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                    dxyz[3*ipnt], dxyz[3*ipnt+1], dxyz[3*ipnt+2]);
        }
        SPRINT0(2, "                                                            ...");
        for (ipnt = npnt-5; ipnt < npnt; ipnt++) {
            SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                    dxyz[3*ipnt], dxyz[3*ipnt+1], dxyz[3*ipnt+2]);
        }
    }

    FREE(ts);
    FREE(xyz);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   velocityOfFace - compute Face velocities analytically              *
 *                                                                      *
 ************************************************************************
 */

int
velocityOfFace(modl_T *MODL,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (1:nbody) */
               int    iface,            /* (in)  Face index (1:nface) */
               int    npnt,             /* (in)  number of points */
     /*@null@*/double uv[],             /* (in)  para coords (2*npnt in length) */
               double dxyz[])           /* (out) velocities  (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       jface, ipnt, jbody, kbody, npnt_tess, ntri_tess;
    int       iarg, nedge, nsketch=0, isketch[MAX_NUM_SKETCHES];
    int       iedge, attrType, attrLen, *iinfo=NULL;
    int       oclass, mtype, nchild, *senses, istrip, i;
    CINT      *tris, *tric, *ptype, *pindx, *tempIlist;
    double    data[18], mat[12], mat2[12], trange[4], frac, scale;
    double    *ts=NULL, *tn=NULL, *vels=NULL;
    double    *uvs=NULL, *xyz=NULL, *ttemp=NULL, *stemp=NULL;
    double    data_dot[18];
    double    edgeData[4], *rinfo, xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd;
    double    A, B, C, D, E, F, s, t;
    CDOUBLE   *xyz_tess, *uv_tess;
    ego       esurf, eref, *echilds, rgeom;

    int       ibrch, udp_num, *udp_types, *udp_idef, needfd, periodic;
    double    *udp_ddef;
    char      **udp_names, primtype[MAX_EXPR_LEN];

    ROUTINE(velocityOfFace);

    /* --------------------------------------------------------------- */

#if PRINT_CALLHISTORY > 0
    for (i_callHistory = 0; i_callHistory < indent_callHistory; i_callHistory++) fprintf(fp_callHistory, ".  ");
    fprintf(fp_callHistory, "velocityOfFace(ibody=%2d, iface=%3d)\n", ibody, iface);
    indent_callHistory++;
#endif

    /* overall strategy:
     - find (jbody,jface) which is where (ibody,iface) first existed
     - find mat           which is the transformation matrix needed to
                          transform a point in (ibody,iface) back to (jbody,jface)
     - find scale         which is the scale factor needed to transform
                          uv in (ibody,iface) back to (jbody,jface) for PLANEs
     - find xyz           which are the physical   coordinates of the points in (jbody,jface)
     - find uvs           which are the parametric coordinates of the points in (jbody,jface)
     - find dxyz          which are the velocities in the (jbody,jface)
     - transform dxyz     back to (ibody,iface)
    */

    if (uv == NULL) {
        SPRINT3(2, " -> velocityOfFace(ibody=%3d, iface=%3d, npnt=%5d) -> NULL", ibody, iface, npnt);
    } else if (npnt < 11) {
        SPRINT5(2, " -> velocityOfFace(ibody=%3d, iface=%3d, npnt=%5d) -> %12.6f %12.6f", ibody, iface, npnt, uv[0], uv[1]);
        for (ipnt = 1; ipnt < npnt; ipnt++) {
            SPRINT2(2, "                                                        %12.6f %12.6f", uv[2*ipnt], uv[2*ipnt+1]);
        }
    } else {
        SPRINT5(2, " -> velocityOfFace(ibody=%3d, iface=%3d, npnt=%5d) -> %12.6f %12.6f", ibody, iface, npnt, uv[0], uv[1]);
        for (ipnt = 1; ipnt <= 5; ipnt++) {
            SPRINT2(2, "                                                        %12.6f %12.6f", uv[2*ipnt], uv[2*ipnt+1]);
        }
        SPRINT0(2, "                                                            ...");
        for (ipnt = npnt-5; ipnt < npnt; ipnt++) {
            SPRINT2(2, "                                                        %12.6f %12.6f", uv[2*ipnt], uv[2*ipnt+1]);
        }
    }

    if        (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    } else if (iface < 1 || iface > MODL->body[ibody].nface) {
        status = OCSM_FACE_NOT_FOUND;
        goto cleanup;
    }

    /* if there is an active perturbation, get velocity by finite
       differences */
    if (MODL->perturb != NULL) {
        SPRINT0(2, "        -> finite differencing");
        status = finiteDifference(MODL, ibody, OCSM_FACE, iface, npnt, uv, dxyz);
        CHECK_STATUS(finiteDifference);

        goto cleanup;
    }

    /* get the necessary temporary storage */
    MALLOC(xyz, double, 3*npnt);
    MALLOC(uvs, double, 2*npnt);

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    status = xformFaceToOriginal(MODL, ibody, iface, mat, &scale);
    CHECK_STATUS(xformFaceToOriginal);

    /* jbody is the Body in which this Face first appeared */
    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    jbody = tempIlist[0];
    jface = tempIlist[1];
    SPRINT4(2, "        ibody=%d,iface=%d maps to jbody=%d,jface=%d", ibody, iface, jbody, jface);

    /* if uv==NULL, then find the locations of the tessellation points when
       the Face was first created */
    if (uv == NULL) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt_tess, &xyz_tess, &uv_tess, &ptype, &pindx,
                                &ntri_tess, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        if (npnt != npnt_tess) {
            status = OCSM_ILLEGAL_ARGUMENT;
            goto cleanup;
        } else {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                uvs[2*ipnt  ] = uv_tess[2*ipnt  ];
                uvs[2*ipnt+1] = uv_tess[2*ipnt+1];
            }

            /* xyz are the tessellation points transformed back
               to their locations in jbody */
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                xyz[3*ipnt  ] = xyz_tess[3*ipnt  ] * mat[ 0]
                              + xyz_tess[3*ipnt+1] * mat[ 1]
                              + xyz_tess[3*ipnt+2] * mat[ 2] + mat[ 3];
                xyz[3*ipnt+1] = xyz_tess[3*ipnt  ] * mat[ 4]
                              + xyz_tess[3*ipnt+1] * mat[ 5]
                              + xyz_tess[3*ipnt+2] * mat[ 6] + mat[ 7];
                xyz[3*ipnt+2] = xyz_tess[3*ipnt  ] * mat[ 8]
                              + xyz_tess[3*ipnt+1] * mat[ 9]
                              + xyz_tess[3*ipnt+2] * mat[10] + mat[11];
            }
        }

    /* otherwise, find the locations at the given uv's when the Face
       was first created */
    } else {
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            uvs[2*ipnt  ] = uv[2*ipnt  ];
            uvs[2*ipnt+1] = uv[2*ipnt+1];
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            status = EG_evaluate(MODL->body[ibody].face[iface].eface,
                                 &(uv[2*ipnt]), data);
            CHECK_STATUS(EG_evaluate);

            xyz[3*ipnt  ] = data[0] * mat[ 0]
                          + data[1] * mat[ 1]
                          + data[2] * mat[ 2] + mat[ 3];
            xyz[3*ipnt+1] = data[0] * mat[ 4]
                          + data[1] * mat[ 5]
                          + data[2] * mat[ 6] + mat[ 7];
            xyz[3*ipnt+2] = data[0] * mat[ 8]
                          + data[1] * mat[ 9]
                          + data[2] * mat[10] + mat[11];
        }
    }

    /* if the Face is a PLANE, modify uv by scale */
    status = EG_getTopology(MODL->body[ibody].face[iface].eface, &esurf, &oclass, &mtype,
                            data, &nchild, &echilds, &senses);
    CHECK_STATUS(EG_getTopology);

    status = EG_getGeometry(esurf, &oclass, &mtype, &eref, NULL, NULL);
    CHECK_STATUS(EG_getGeometry);

    if (oclass == SURFACE && mtype == PLANE) {
        SPRINT1(2, "            -> modifying uvs by factor %10.5f", scale);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            uvs[2*ipnt  ] /= scale;
            uvs[2*ipnt+1] /= scale;
        }
    }

    /* if there are no Parameter changes, then the velocities are all 0 (and do not
       bother computing the derivatives below) */
    if (MODL->body[jbody].hasdots == 0) {
        SPRINT1(2, "        -> setting to zero (Face in %s)", ocsmGetText(MODL->body[jbody].brtype));
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] = 0;
            dxyz[3*ipnt+1] = 0;
            dxyz[3*ipnt+2] = 0;
        }

    /* get the velocities for a BOX */
    } else if (MODL->body[jbody].brtype == OCSM_BOX) {
        status = velocityForPrimitive(MODL, jbody, npnt, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a SPHERE */
    } else if (MODL->body[jbody].brtype == OCSM_SPHERE) {
        status = velocityForPrimitive(MODL, jbody, npnt, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a CONE */
    } else if (MODL->body[jbody].brtype == OCSM_CONE) {
        status = velocityForPrimitive(MODL, jbody, npnt, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a CYLINDER */
    } else if (MODL->body[jbody].brtype == OCSM_CYLINDER) {
        status = velocityForPrimitive(MODL, jbody, npnt, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a UDPRIM */
    } else if (MODL->body[jbody].brtype == OCSM_UDPRIM) {
        SPRINT0(2, "        -> analytical for UDPRIM");

        /* load and execute the user-defined primitive */
        ibrch = MODL->body[jbody].ibrch;

        STRNCPY(primtype, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);

        status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
        if (status == EGADS_NOLOAD) {
            status = EGADS_SUCCESS;
        }
        CHECK_STATUS(udp_initialize);

        status = udp_clrArguments(primtype);
        CHECK_STATUS(udp_clrArguments);

        needfd = 0;

        /* go back to first associated udparg statement whose primtype matches the
           UDPRIM's primtype */
        kbody = jbody - 1;
        while (kbody > 0 && MODL->body[kbody].brtype == OCSM_UDPARG &&
              strcmp(MODL->body[kbody].arg[1].str, MODL->body[jbody].arg[1].str) == 0) {
            kbody--;
        }
        kbody++;

        while (kbody <= jbody) {
            for (iarg = 3; iarg < 10; iarg+=2) {
                if (MODL->body[kbody].arg[iarg].nval < 0) break;

                if (MODL->body[kbody].arg[iarg].nval > 0) {
                    status = udp_setVelocity(MODL->body[kbody].arg[1].str,
                                             MODL->body[jbody].ebody,
                                             MODL->body[kbody].arg[iarg-1].str,
                                             MODL->body[kbody].arg[iarg  ].dot,
                                             MODL->body[kbody].arg[iarg  ].nval);

                    if (status != EGADS_SUCCESS) {
                        /* indexerr indicates that a variable is not available for sensitivity,
                           (for example an integer), so we will just get zeroes */
                        if (status == EGADS_INDEXERR) {
                            SPRINT2(1, "WARNING:: analytic sensitivity cannot be computed for \"%s\" in %s (3)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* notfound indicates that a variable is not available for sensitivity,
                           so compute sensitivity by finite differences */
                        } else if (status == EGADS_NOTFOUND) {
                            SPRINT2(1, "WARNING:: analytic sensitivity cannot be computed for \"%s\" in %s (4)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* unknown error type */
                        } else {
                            needfd++;
                        }
                    }
                }
            }

            kbody++;
        }

        /* if any of the velocities could not be set, we need finite differences */
        if (needfd > 0) {
            SPRINT0(1, "        -> reverting to finiteDifferences");

            if (MODL->perturb == NULL) {
                MODL->dtime = DTIME_NOM;

                status = createPerturbation(MODL);
                CHECK_STATUS(createPerturbation);
            }

            status = finiteDifference(MODL, ibody, OCSM_FACE, iface, npnt, uv, dxyz);
            CHECK_STATUS(finiteDifference);
            goto cleanup;
        }

        /* scale uvs if the Face has an _scaleuv Attribute */
        status = EG_attributeRet(MODL->body[jbody].face[jface].eface, "_scaleuv",
                                 &attrType, &attrLen, &tempIlist, NULL, NULL);
        if (status == SUCCESS && attrType == ATTRINT && attrLen == 1) {
            for (ipnt = 0; ipnt < npnt; ipnt++) {
                uvs[2*ipnt  ] /= scale;
                uvs[2*ipnt+1] /= scale;
            }
        }

        if (jface > 0) {
            status = udp_sensitivity(primtype, MODL->body[jbody].ebody,
                                     npnt, OCSM_FACE, jface, uvs, dxyz);
            if (status == EGADS_NOLOAD) {
                SPRINT0(1, "        -> reverting to finiteDifferences");

                if (MODL->perturb == NULL) {
                    MODL->dtime = DTIME_NOM;

                    status = createPerturbation(MODL);
                    CHECK_STATUS(createPerturbation);
                }

                status = finiteDifference(MODL, ibody, OCSM_FACE, iface, npnt, uv, dxyz);
                CHECK_STATUS(finiteDifference);
                goto cleanup;
            }
            CHECK_STATUS(udp_sensitivity);
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "cannot find Face %d:%d in jbody=%d", ibody, iface, jbody);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

    /* get the velocities for an EXTRUDE */
    } else if (MODL->body[jbody].brtype == OCSM_EXTRUDE) {
        SPRINT0x(2, "        -> analytical for EXTRUDE");

        MALLOC(ts,   double,   npnt);
        MALLOC(tn,   double,   npnt);
        MALLOC(vels, double, 3*npnt);

        /* count number of Edges in left parent */
        kbody = MODL->body[jbody].ileft;
        nedge = MODL->body[kbody].nedge;

        /* analytical derivatives from Xsect */
        if (jface <= nedge) {
            iedge = jface;

            SPRINT1(2, "  (edge %d)", iedge);

            /* check to see if Edge is a line.  if it is, then there may not be a direct
               relationship between a (uv) in the Face (plane) and the (t) in the Edge (line).
               so we have to project the point in the Face in the negative extrusion direction
               until we hit the Edge */
            kbody = MODL->body[jbody].ileft;
            status = EG_getTopology(MODL->body[kbody].edge[iedge].eedge, &eref, &oclass, &mtype,
                                    edgeData, &nchild, &echilds, &senses);
            CHECK_STATUS(EG_getTopology);

            status = EG_getGeometry(eref, &oclass, &mtype, &rgeom, &iinfo, &rinfo);
            if (status != SUCCESS) {
                EG_free(iinfo);
                EG_free(rinfo);
            }
            CHECK_STATUS(EG_getGeometry);

            if (oclass == CURVE && mtype == LINE) {
                xa = rinfo[0];
                ya = rinfo[1];
                za = rinfo[2];
                xb = rinfo[0] + rinfo[3];
                yb = rinfo[1] + rinfo[4];
                zb = rinfo[2] + rinfo[5];

                EG_free(iinfo);
                EG_free(rinfo);

                MALLOC(ttemp, double, npnt);
                MALLOC(stemp, double, npnt);

                for (ipnt = 0; ipnt < npnt; ipnt++) {

                    /* find the physical coordinates */
                    status = EG_evaluate(MODL->body[jbody].face[jface].eface,
                                         &(uvs[2*ipnt]), data);
                    CHECK_STATUS(EG_evaluate);

                    xc = data[0];
                    yc = data[1];
                    zc = data[2];
                    xd = data[0] - MODL->body[jbody].arg[1].val[0];
                    yd = data[1] - MODL->body[jbody].arg[2].val[0];
                    zd = data[2] - MODL->body[jbody].arg[3].val[0];

                    /* find the intersection of the line along the Edge (t) and
                       a line from the point in the negative extrusion direction (s) */
                    A = (xc - xd) * (xc - xd) + (yc - yd) * (yc - yd) + (zc - zd) * (zc - zd);
                    B = (xb - xa) * (xc - xd) + (yb - ya) * (yc - yd) + (zb - za) * (zc - zd);
                    C = (xc - xa) * (xc - xd) + (yc - ya) * (yc - yd) + (zc - za) * (zc - zd);
                    D = (xb - xa) * (xc - xd) + (yb - ya) * (yc - yd) + (zb - za) * (zc - zd);
                    E = (xb - xa) * (xb - xa) + (yb - ya) * (yb - ya) + (zb - za) * (zb - za);
                    F = (xc - xa) * (xb - xa) + (yc - ya) * (yb - ya) + (zc - za) * (zb - za);

                    s = (C * E - F * B) / (A * E - D * B);
                    t = (A * F - D * C) / (A * E - D * B);

                    stemp[ipnt] = s;
                    ttemp[ipnt] = t;
                }

                /* get velocities from the Edge */
                status = velocityOfEdge(MODL, kbody, iedge, npnt, ttemp, vels);
                CHECK_STATUS(velocityOfEdge);

                /* apply velocities to Face */
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = vels[3*ipnt  ] + stemp[ipnt] * MODL->body[jbody].arg[1].dot[0];
                    dxyz[3*ipnt+1] = vels[3*ipnt+1] + stemp[ipnt] * MODL->body[jbody].arg[2].dot[0];
                    dxyz[3*ipnt+2] = vels[3*ipnt+2] + stemp[ipnt] * MODL->body[jbody].arg[3].dot[0];
                }

                FREE(ttemp);
                FREE(stemp);

            /* Edge is not a line, so we can just use mapped parametric coordinates */
            } else {
                EG_free(iinfo);
                EG_free(rinfo);

                status = EG_getRange(MODL->body[jbody].face[iedge].eface, trange, &periodic);
                CHECK_STATUS(EG_getRange);

                /* assume that jface=1 maps to iedge=1 in Xsect */
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    ts[ipnt] = uvs[2*ipnt  ];
                    tn[ipnt] = uvs[2*ipnt+1] / scale;
                }

                /* get velocities from (the possibly-transformed) Xsect */
                kbody = MODL->body[jbody].ileft;
                status = velocityOfEdge(MODL, kbody, iedge, npnt, ts, vels);
                CHECK_STATUS(velocityOfEdge);

                /* apply velocities to Face */
                for (ipnt = 0; ipnt < npnt; ipnt++) {
                    frac = (tn[ipnt] - trange[3]) / (trange[2] - trange[3]);

                    dxyz[3*ipnt  ] = vels[3*ipnt  ] + frac * MODL->body[jbody].arg[1].dot[0];
                    dxyz[3*ipnt+1] = vels[3*ipnt+1] + frac * MODL->body[jbody].arg[2].dot[0];
                    dxyz[3*ipnt+2] = vels[3*ipnt+2] + frac * MODL->body[jbody].arg[3].dot[0];
                }
            }

        /* analytical derivatives for ends (should be handled by Xsect) */
        } else {
            printf("WE SHOULD NOT GET HERE 5\n");
            exit(0);
        }

        FREE(vels);
        FREE(tn  );
        FREE(ts  );

    /* get the velocities for a RULE */
    } else if (MODL->body[jbody].brtype == OCSM_RULE) {
        SPRINT0(2, "        -> analytical for RULE");

        for (kbody = MODL->body[jbody].ileft; kbody <= MODL->body[jbody].irite; kbody++) {
            if (MODL->body[kbody].ichld != jbody) continue;
            isketch[nsketch++] = kbody;
        }

        if (nsketch < 2) {
            status = OCSM_INSUFFICIENT_BODYS_ON_STACK;
            signalError(MODL, status,
                        "RULE requires at least 2 Bodys on stack");
            goto cleanup;
        }

        /* count number of Edges */
        nedge = MAX(MODL->body[isketch[0]].nedge,
                    MODL->body[isketch[1]].nedge);

        /* if the sensitivity is not present, make it now */
        if (MODL->body[jbody].hassens == 0) {
            SPRINT1(2, "           creating RULE cache for jbody=%d", jbody);

            status = createVelocityCache(MODL, jbody);
            CHECK_STATUS(createVelocityCache);
        } else {
            SPRINT1(2, "           reusing  RULE cache for jbody=%d", jbody);
        }

        /* Face is one for which the EG_evaluate_dot works */
        if (jface <= nedge*(nsketch-1)) {
            SPRINT1(2, "  (jface %d)", jface);

            for (ipnt = 0; ipnt < npnt; ipnt++) {
                status = EG_evaluate_dot(MODL->body[jbody].face[jface].eface,
                                         &(uvs[2*ipnt]), NULL, data, data_dot);
                CHECK_STATUS(EG_evaluate_dot);

                dxyz[3*ipnt  ] = data_dot[0];
                dxyz[3*ipnt+1] = data_dot[1];
                dxyz[3*ipnt+2] = data_dot[2];
            }

        /* analytical derivative for beg */
        } else if (jface == nedge*(nsketch-1)+1) {
            kbody = isketch[0];
            SPRINT1(2, "  (beg [at Xsect %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the RULE) back to
               its corresponding location in kbody (the original Xsect) */
            status = xformFaceToOriginal(MODL, jbody, jface, mat2, &scale);
            CHECK_STATUS(xformFaceToOriginal);

           /* get velocity from Xsect (RULE beg) */
            if (MODL->body[kbody].nface == 1) {
                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }

        /* analytical derivative for end */
        } else if (jface == nedge*(nsketch-1)+2) {
            kbody = isketch[nsketch-1];
            SPRINT1(2, "  (end [at Xsect %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the RULE) back to
               its corresponding location in kbody (the original Xsect) */
            status = xformFaceToOriginal(MODL, jbody, jface, mat2, &scale);
            CHECK_STATUS(xformFaceToOriginal);

            /* get velocity from Xsect (RULE end) */
            if (MODL->body[kbody].nface == 1) {
                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }
        } else {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

    /* get the velocities for a BLEND */
    } else if (MODL->body[jbody].brtype == OCSM_BLEND) {
        SPRINT0(2, "        -> analytical for BLEND");

        for (kbody = MODL->body[jbody].ileft; kbody <= MODL->body[jbody].irite; kbody++) {
            if (MODL->body[kbody].ichld != jbody) continue;
            isketch[nsketch++] = kbody;
        }
        assert (nsketch > 1);                     // needed for scan-build

        /* if the sensitivity is not present, make it now */
        if (MODL->body[jbody].hassens == 0) {
            SPRINT1(2, "           creating BLEND cache for jbody=%d", jbody);

            status = createVelocityCache(MODL, jbody);
            CHECK_STATUS(createVelocityCache);

            SPRINT1(2, "           finished BLEND cache for jbody=%d", jbody);
        } else {
            SPRINT1(2, "           reusing  BLEND cache for jbody=%d", jbody);
        }

        /* now that we have a good cache, determine the strip associated
           with iface */
        status = EG_attributeRet(MODL->body[jbody].face[jface].eface, ".blendStrip",
                                 &attrType, &attrLen, &tempIlist, NULL, NULL);
        CHECK_STATUS(EG_attributeRet);
        istrip = tempIlist[0];

        /* Face is one for which the EG_evaluate_dot works */
        if (istrip == -1 || istrip == -2 || istrip > 0) {
            SPRINT1(2, "  (strip %d)", istrip);

            for (ipnt = 0; ipnt < npnt; ipnt++) {
                status = EG_evaluate_dot(MODL->body[jbody].face[jface].eface,
                                         &(uvs[2*ipnt]), NULL, data, data_dot);
                CHECK_STATUS(EG_evaluate_dot);

                dxyz[3*ipnt  ] = data_dot[0];
                dxyz[3*ipnt+1] = data_dot[1];
                dxyz[3*ipnt+2] = data_dot[2];
            }

        /* analytical derivative for beg */
        } else if (istrip == -3) {
            kbody = isketch[0];
            SPRINT1(2, "  (beg [at Xsect %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the BLEND) back to
               its corresponding location in kbody (the original Xsect) */
            status = xformFaceToOriginal(MODL, jbody, jface, mat2, &scale);
            CHECK_STATUS(xformFaceToOriginal);

           /* get velocity from Xsect (BLEND beg) */
            if (MODL->body[kbody].nface == 1) {
                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }

        /* analytical derivative for end */
        } else if (istrip == -4) {
            kbody = isketch[nsketch-1];
            SPRINT1(2, "  (end [at Xsect %d])", kbody);

            while (MODL->body[kbody].ileft > 0) {
                kbody = MODL->body[kbody].ileft;
            }

            /* find the transformation matrix which is required
               to track a point from its location in jbody (the BLEND) back to
               its corresponding location in kbody (the original Xsect) */
            status = xformFaceToOriginal(MODL, jbody, jface, mat2, &scale);
            CHECK_STATUS(xformFaceToOriginal);

            /* get velocity from Xsect (BLEND end) */
            if (MODL->body[kbody].nface == 1) {
                status = velocityOfFace(MODL, kbody, 1, npnt, uvs, dxyz);
                CHECK_STATUS(velocityOfFace);
            } else {
                for (ipnt = 0 ; ipnt < npnt; ipnt++) {
                    dxyz[3*ipnt  ] = 0;
                    dxyz[3*ipnt+1] = 0;
                    dxyz[3*ipnt+2] = 0;
                }
            }
        } else {
            status = OCSM_FACE_NOT_FOUND;
            goto cleanup;
        }

#ifdef ANALYTIC_SKETCH
//$$$    /* get the velocities for a sketch */
//$$$    } else if (MODL->body[jbody].brtype == OCSM_SKEND) {
//$$$        SPRINT0(2, "        -> analytical for SKEND");
//$$$
//$$$        for (ipnt = 0; ipnt < npnt; ipnt++) {
//$$$            dxyz[3*ipnt  ] = 0;
//$$$            dxyz[3*ipnt+1] = 0;
//$$$            dxyz[3*ipnt+2] = 0;
//$$$        }
#endif

    /* unknown primitive type, so get velocities by finite differences */
    } else {
        SPRINT1(2, "        -> using finiteDifference (brtype=%s)",
                ocsmGetText(MODL->body[jbody].brtype));

        if (MODL->perturb == NULL) {
            MODL->dtime = DTIME_NOM;

            status = createPerturbation(MODL);
            CHECK_STATUS(createPerturbation);
        }

        status = finiteDifference(MODL, ibody, OCSM_FACE, iface, npnt, uv, dxyz);
        CHECK_STATUS(finiteDifference);
        goto cleanup;
    }

    /* follow the children (up to the root) and modify the velocities
       for any OCSM_TRANSFORM that is visited */
    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    for (i = 0; i < attrLen; i+=2) {
        kbody = tempIlist[i];

        if (MODL->body[kbody].brtype != OCSM_EXTRUDE) {
            status = xformVelocity(MODL, kbody, npnt, xyz, dxyz);
            CHECK_STATUS(xformVelocity);
        } else if (MODL->body[ibody].botype == OCSM_SOLID_BODY &&
                   MODL->body[ibody].face[iface].iford == 2      ) {
            status = xformVelocity(MODL, kbody, npnt, xyz, dxyz);
            CHECK_STATUS(xformVelocity);
        }
    }

cleanup:
#if PRINT_CALLHISTORY > 0
    indent_callHistory--;
#endif

    SPRINT6(2, " <- velocityOfFace(ibody=%3d, iface=%3d, npnt=%5d) -> %12.6f %12.6f %12.6f",
            ibody, iface, npnt, dxyz[0], dxyz[1], dxyz[2]);
    if (npnt < 11) {
        for (ipnt = 1; ipnt < npnt; ipnt++) {
            SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                    dxyz[3*ipnt], dxyz[3*ipnt+1], dxyz[3*ipnt+2]);
        }
    } else {
        for (ipnt = 1; ipnt < 5; ipnt++) {
            SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                    dxyz[3*ipnt], dxyz[3*ipnt+1], dxyz[3*ipnt+2]);
        }
        SPRINT0(2, "                                                            ...");
        for (ipnt = npnt-5; ipnt < npnt; ipnt++) {
            SPRINT3(2, "                                                        %12.6f %12.6f %12.6f",
                    dxyz[3*ipnt], dxyz[3*ipnt+1], dxyz[3*ipnt+2]);
        }
    }

    FREE(xyz);
    FREE(uvs);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   velocityOfNode - compute Node velocities analytically              *
 *                                                                      *
 ************************************************************************
 */

int
velocityOfNode(modl_T *MODL,            /* (in)  pointer to MODL */
               int    ibody,            /* (in)  Body index (1:nbody) */
               int    inode,            /* (in)  Node index (1:nnode) */
               double dxyz[])           /* (out) velocities (3*npnt in length) */
{
    int       status = SUCCESS;         /* (out) return status */

    int       iedge, jbody, jedge, kbody, jnode, knode, iface, kface, j, jbrch;
    int       attrType, attrLen, oclass, mtype, nchild, *senses;
    CINT      *tempIlist;
    double    tang[3], tang1[3], tang2[3], A[9], b[3], x[3], t, scale, mat[12];
    double    velo[3], velo1[3], velo2[3], trange[4], dtest, dbest, dxyzface[3], dxyzedge[3];
    double    data[18], data_dot[18], xyz[3], uvbest[2], xyzbest[3], uvface[2], *uvs=NULL;
    ego       eref, *echilds;

    int       ibrch, iarg, udp_num, *udp_types, *udp_idef, needfd;
    double    *udp_ddef;
    char      **udp_names, primtype[MAX_EXPR_LEN];

    ROUTINE(velocityOfNode);

    /* --------------------------------------------------------------- */

#if PRINT_CALLHISTORY > 0
    for (i_callHistory = 0; i_callHistory < indent_callHistory; i_callHistory++) fprintf(fp_callHistory, ".  ");
    fprintf(fp_callHistory, "velocityOfNode(ibody=%2d, inode=%3d)\n", ibody, inode);
    indent_callHistory++;
#endif

    SPRINT2(2, " -> velocityOfNode(ibody=%d, inode=%d)", ibody, inode);

    if        (ibody < 1 || ibody > MODL->nbody) {
        status = OCSM_ILLEGAL_BODY_INDEX;
        goto cleanup;
    } else if (inode < 1 || inode > MODL->body[ibody].nnode) {
        status = OCSM_NODE_NOT_FOUND;
        goto cleanup;
    }

    /* if there is an active perturbation, get velocity by finite
       differences */
    if (MODL->perturb != NULL) {
        status = finiteDifference(MODL, ibody, OCSM_NODE, inode, 1, NULL, dxyz);
        CHECK_STATUS(finiteDifference);

        goto cleanup;
    }

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    status = xformNodeToOriginal(MODL, ibody, inode, mat, &scale);
    CHECK_STATUS(xformEdgeToOriginal);

    /* jbody is the Body in which this Node first appeared */
    status = EG_attributeRet(MODL->body[ibody].node[inode].enode, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    jbody = tempIlist[0];
    jnode = tempIlist[1];
    jbrch = MODL->body[jbody].ibrch;
    SPRINT4(2, "        ibody=%d,inode=%d maps to jbody=%d,jnode=%d", ibody, inode, jbody, jnode);

    /* find the location of the Node when it was first created */
    xyz[0] = MODL->body[ibody].node[inode].x * mat[ 0]
           + MODL->body[ibody].node[inode].y * mat[ 1]
           + MODL->body[ibody].node[inode].z * mat[ 2] + mat[ 3];
    xyz[1] = MODL->body[ibody].node[inode].x * mat[ 4]
           + MODL->body[ibody].node[inode].y * mat[ 5]
           + MODL->body[ibody].node[inode].z * mat[ 6] + mat[ 7];
    xyz[2] = MODL->body[ibody].node[inode].x * mat[ 8]
           + MODL->body[ibody].node[inode].y * mat[ 9]
           + MODL->body[ibody].node[inode].z * mat[10] + mat[11];

    /* if the .dots are all zero, then the velocities are 0 (and do not
       bother computing the derivatives below) */
    if (MODL->body[jbody].hasdots == 0) {
        SPRINT1(2, "        -> setting to zero (Node in %s)", ocsmGetText(MODL->body[jbody].brtype));
        dxyz[0] = 0;
        dxyz[1] = 0;
        dxyz[2] = 0;

    /* if there are dots on the Node, use them directly */
    } else if (EG_hasGeometry_dot(MODL->body[ibody].node[inode].enode) == EGADS_SUCCESS) {
        SPRINT0(2, "        -> getting velocity from dot cache");

        status = EG_evaluate_dot(MODL->body[ibody].node[inode].enode, NULL, NULL, data, data_dot);
        CHECK_STATUS(EG_evaluate_dot);

        dxyz[0] = data_dot[0];
        dxyz[1] = data_dot[1];
        dxyz[2] = data_dot[2];

        goto cleanup;

    /* get the velocities for a point */
    } else if (MODL->body[jbody].brtype == OCSM_POINT) {
        SPRINT0(2, "        -> analytical for POINT");

        dxyz[0] = MODL->body[jbody].arg[1].dot[0];
        dxyz[1] = MODL->body[jbody].arg[2].dot[0];
        dxyz[2] = MODL->body[jbody].arg[3].dot[0];

    /* get the velocities for a BOX */
    } else if (MODL->body[jbody].brtype == OCSM_BOX) {
        status = velocityForPrimitive(MODL, jbody, 1, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a SPHERE */
    } else if (MODL->body[jbody].brtype == OCSM_SPHERE) {
        status = velocityForPrimitive(MODL, jbody, 1, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a CONE */
    } else if (MODL->body[jbody].brtype == OCSM_CONE) {
        status = velocityForPrimitive(MODL, jbody, 1, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocities for a CYLINDER */
    } else if (MODL->body[jbody].brtype == OCSM_CYLINDER) {
        status = velocityForPrimitive(MODL, jbody, 1, xyz, dxyz);
        CHECK_STATUS(velocityForPrimitive);

    /* get the velocity for a UDPRIM */
    } else if (MODL->body[jbody].brtype == OCSM_UDPRIM) {
        SPRINT0(2, "        -> analytical for UDPRIM");

        /* load and execute the user-defined primitive */
        ibrch = MODL->body[jbody].ibrch;

        STRNCPY(primtype, &(MODL->brch[ibrch].arg1[1]), MAX_EXPR_LEN);

        status = udp_initialize(primtype, &udp_num, &udp_names, &udp_types, &udp_idef, &udp_ddef);
        if (status == EGADS_NOLOAD) {
            status = EGADS_SUCCESS;
        }
        CHECK_STATUS(udp_initialize);

        status = udp_clrArguments(primtype);
        CHECK_STATUS(udp_clrArguments);

        needfd = 0;

        /* go back to first associated udparg statement whose primtype matches the
           UDPRIM's primtype */
        kbody = jbody - 1;
        while (kbody > 0 && MODL->body[kbody].brtype == OCSM_UDPARG &&
               strcmp(MODL->body[kbody].arg[1].str, MODL->body[jbody].arg[1].str) == 0 ) {
            kbody--;
        }
        kbody++;

        while (kbody <= jbody) {
            for (iarg = 3; iarg < 10; iarg+=2) {
                if (MODL->body[kbody].arg[iarg].nval < 0) break;

                if (MODL->body[kbody].arg[iarg].nval > 0) {
                    status = udp_setVelocity(MODL->body[kbody].arg[1].str,
                                             MODL->body[jbody].ebody,
                                             MODL->body[kbody].arg[iarg-1].str,
                                             MODL->body[kbody].arg[iarg  ].dot,
                                             MODL->body[kbody].arg[iarg  ].nval);

                    if (status != EGADS_SUCCESS) {
                        /* indexerr indicates that a variable is not available for sensitivity,
                           (for example an integer), so we will just get zeroes */
                        if (status == EGADS_INDEXERR) {
                            SPRINT2(1, "WARNING:: analytic sensitivity cannot be computed for \"%s\" in %s (5)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* notfound indicates that a variable is not available for sensitivity,
                           so compute sensitivity by finite differences */
                        } else if (status == EGADS_NOTFOUND) {
                            SPRINT2(1, "WARNING:: sensitivity cannot be computed for \"%s\" in %s (6)",
                                    MODL->body[kbody].arg[iarg-1].str, MODL->body[kbody].arg[1].str);
                            (MODL->nwarn)++;
                            needfd++;
                        /* unknown error type */
                        } else {
                            needfd++;
                        }
                    }
                }
            }

            kbody++;
        }

        /* if any of the velocities could not be set, we need finite differences */
        if (needfd > 0) {
            SPRINT0(1, "        -> reverting to finiteDifferences");

            if (MODL->perturb == NULL) {
                MODL->dtime = DTIME_NOM;

                status = createPerturbation(MODL);
                CHECK_STATUS(createPerturbation);
            }

            status = finiteDifference(MODL, ibody, OCSM_NODE, inode, 1, &t, dxyz);
            CHECK_STATUS(finiteDifference);
            goto cleanup;
        }

        /* find the Node in jbody that maps to Node inode in ibody */
        if (jbody == ibody) {
            jnode = inode;
        } else {
            jnode = -1;
            for (knode = 1; knode <= MODL->body[jbody].nnode; knode++) {
                if (fabs(MODL->body[jbody].node[knode].x-xyz[0]) < EPS06 &&
                    fabs(MODL->body[jbody].node[knode].y-xyz[1]) < EPS06 &&
                    fabs(MODL->body[jbody].node[knode].z-xyz[2]) < EPS06   ) {
                    jnode = knode;
                    break;
                }
            }
        }
        SPRINT4(2, "        ibody=%d,inode=%d maps to jbody=%d,jnode=%d", ibody, inode, jbody, jnode);

        if (jnode > 0) {
            status = udp_sensitivity(primtype, MODL->body[jbody].ebody,
                                     1, OCSM_NODE, jnode, NULL, dxyz);
            if (status == EGADS_NOLOAD) {
                SPRINT0(1, "        -> reverting to finiteDifferences");

                if (MODL->perturb == NULL) {
                    MODL->dtime = DTIME_NOM;

                    status = createPerturbation(MODL);
                    CHECK_STATUS(createPerturbation);
                }

                status = finiteDifference(MODL, ibody, OCSM_NODE, inode, 1, NULL, dxyz);
                CHECK_STATUS(finiteDifference);
                goto cleanup;
            }
            CHECK_STATUS(udp_sensitivity);
        } else {
            signalError(MODL, OCSM_INTERNAL_ERROR,
                        "cannot find Node %d:%d in jbody=%d", ibody, inode, jbody);
            status = OCSM_INTERNAL_ERROR;
            goto cleanup;
        }

    /* if the Node was generated by an extrude, the velocity can be
       obtained directly */
    } else if (MODL->body[jbody].brtype == OCSM_EXTRUDE) {

        /* if one of the original Nodes, get velocity directly */
        if (inode%2 == 1) {
            status = velocityOfNode(MODL, jbody, jnode, dxyz);
            CHECK_STATUS(velocityOfNode);

        /* otherwise get velocity from previous Node and and increment
           because of the extrusion */
        } else {
            status = velocityOfNode(MODL, jbody, jnode-1, dxyz);
            CHECK_STATUS(velocityOfNode);

            dxyz[0] += MODL->body[jbody].arg[1].dot[0];
            dxyz[1] += MODL->body[jbody].arg[2].dot[0];
            dxyz[2] += MODL->body[jbody].arg[3].dot[0];
        }

    /* if the Node was generated by a OCSM_GROWN and is a WireBody,
           the velocity if obtained directly from the Node */
    } else if (MODL->brch[jbrch].bclass == OCSM_GROWN    &&
               MODL->body[jbody].botype == OCSM_WIRE_BODY  ) {

        SPRINT1(2, "        -> Node velocity gotten from %s", ocsmGetText(MODL->body[jbody].brtype));

        dxyz[0] = HUGEQ;       // very big so that we know if the Node cannot be found
        dxyz[1] = HUGEQ;
        dxyz[2] = HUGEQ;

        for (kbody = MODL->body[jbody].ileft; kbody <= MODL->body[jbody].irite; kbody++) {
            if (MODL->body[kbody].ichld != jbody) continue;

            if (fabs(MODL->body[kbody].node[1].x-MODL->body[jbody].node[jnode].x) < EPS06 &&
                fabs(MODL->body[kbody].node[1].y-MODL->body[jbody].node[jnode].y) < EPS06 &&
                fabs(MODL->body[kbody].node[1].z-MODL->body[jbody].node[jnode].z) < EPS06   ) {

                status = velocityOfNode(MODL, kbody, 1, dxyz);
                CHECK_STATUS(velocityOfNode);

                break;
            }
        }

    } else if (MODL->body[jbody].brtype == OCSM_RULE ||
               MODL->body[jbody].brtype == OCSM_BLEND) {

        /* NOTE: the rounded tip blend operation with a blunt trailing edge
         * creates a new Node on the trailing edge that does not trace back to any Xsec.
         * Using EG_evaluate_dot is the only way to get the sensitivities of that new Node.
         */

        /* if the sensitivity is not present, make it now */
        if (MODL->body[jbody].hassens == 0) {
            SPRINT1(2, "           creating RULE/BLEND cache for jbody=%d", jbody);

            status = createVelocityCache(MODL, jbody);
            CHECK_STATUS(createVelocityCache);
        } else {
            SPRINT1(2, "           reusing  RULE/BLEND cache for jbody=%d", jbody);
        }

        status = EG_evaluate_dot(MODL->body[jbody].node[jnode].enode,
                                 NULL, NULL, data, data_dot);
        CHECK_STATUS(EG_evaluate_dot);

        dxyz[0] = data_dot[0];
        dxyz[1] = data_dot[1];
        dxyz[2] = data_dot[2];

    /* if the Node was generated by an INTERSECTION or SUBTRACTion of a
       WireBody and  SolidBody, the velocity is consistent with both the
       Edge and Solid velocities */
    } else if ((MODL->body[jbody].botype == OCSM_WIRE_BODY   ) &&
               (MODL->body[jbody].brtype == OCSM_INTERSECT ||
                MODL->body[jbody].brtype == OCSM_SUBTRACT    ) &&
               (MODL->body[jbody].node[jnode].nedge == 1     )   ) {

        SPRINT0(2, "       -> Node velocity gotten from Edge and trimming Solid");

        xyz[0] = MODL->body[jbody].node[jnode].x;
        xyz[1] = MODL->body[jbody].node[jnode].y;
        xyz[2] = MODL->body[jbody].node[jnode].z;

        /* find the tangent and velocity at the end of the Edge */
        jedge = 0;
        for (iedge = 1; iedge <= MODL->body[jbody].nedge; iedge++) {
            if        (MODL->body[jbody].edge[iedge].ibeg == jnode) {
                jedge = iedge;
                break;
            } else if (MODL->body[jbody].edge[iedge].iend == jnode) {
                jedge = iedge;
                break;
            }
        }
        if (jedge == 0) {
            status = OCSM_EDGE_NOT_FOUND;
            signalError(MODL, status,
                        "could not Find Edge that matches jnode=%d", jnode);
            goto cleanup;
        }

        status = EG_invEvaluate(MODL->body[jbody].edge[jedge].eedge, xyz, uvbest, xyzbest);
        CHECK_STATUS(EG_invEvaluate);

        t = uvbest[0];

        status = EG_evaluate(MODL->body[jbody].edge[abs(jedge)].eedge, &t, data);
        CHECK_STATUS(EG_evaluate);

        tang1[0] = data[3] / sqrt(data[3]*data[3] + data[4]*data[4] + data[5]*data[5]);
        tang1[1] = data[4] / sqrt(data[3]*data[3] + data[4]*data[4] + data[5]*data[5]);
        tang1[2] = data[5] / sqrt(data[3]*data[3] + data[4]*data[4] + data[5]*data[5]);

        status = velocityOfEdge(MODL, jbody, abs(jedge), 1, &t, dxyzedge);
        CHECK_STATUS(velocityOfEdge);

        /* find the Face (and point) in the SolidBody associated with xyznode */
        if        (MODL->body[MODL->body[jbody].ileft].botype == OCSM_SOLID_BODY) {
            kbody = MODL->body[jbody].ileft;
        } else if (MODL->body[MODL->body[jbody].irite].botype == OCSM_SOLID_BODY) {
            kbody = MODL->body[jbody].irite;
        } else {
            status = OCSM_BODY_NOT_FOUND;
            signalError(MODL, status,
                        "could not find matching SolidBody for jnode=%d", jnode);
            goto cleanup;
        }

        kface = 0;
        dbest = HUGEQ;
        for (iface = 1; iface <= MODL->body[kbody].nface; iface++) {
            status = EG_invEvaluate(MODL->body[kbody].face[iface].eface, xyz, uvbest, xyzbest);
            CHECK_STATUS(EG_invEvaluate);

            dtest = (xyz[0]-xyzbest[0]) * (xyz[0]-xyzbest[0])
                +   (xyz[1]-xyzbest[1]) * (xyz[1]-xyzbest[1])
                +   (xyz[2]-xyzbest[2]) * (xyz[2]-xyzbest[2]);
            if (dtest < dbest) {
                kface     = iface;
                uvface[0] = uvbest[0];
                uvface[1] = uvbest[1];
                dbest     = dtest;
            }
        }
        if (sqrt(dbest) > EPS06) {
            status = OCSM_FACE_NOT_FOUND;
            signalError(MODL, status,
                        "could not find Face in kbody=%d", kbody);
            goto cleanup;
        }
        status = EG_evaluate(MODL->body[kbody].face[kface].eface, uvface, data);
        CHECK_STATUS(EG_evaluate);

        status = velocityOfFace(MODL, kbody, kface, 1, uvface, dxyzface);
        CHECK_STATUS(velocityOfFace);

        A[0] = tang1[0];   A[1] = -data[3];   A[2] = -data[6];   b[0] = dxyzface[0] - dxyzedge[0];
        A[3] = tang1[1];   A[4] = -data[4];   A[5] = -data[7];   b[1] = dxyzface[1] - dxyzedge[1];
        A[6] = tang1[2];   A[7] = -data[5];   A[8] = -data[8];   b[2] = dxyzface[2] - dxyzedge[2];

        status = matsol(A, b, 3, x);
        CHECK_STATUS(matsol);

        dxyz[0] = dxyzedge[0] + x[0] * tang1[0];
        dxyz[1] = dxyzedge[1] + x[0] * tang1[1];
        dxyz[2] = dxyzedge[2] + x[0] * tang1[2];

    /* if the Node was generated by a OCSM_BOOLEAN or OCSM_GROWN,
       the velocity can be obtained from Edge velocities */
    } else if (MODL->brch[jbrch].bclass == OCSM_BOOLEAN ||
               MODL->brch[jbrch].bclass == OCSM_GROWN     ) {

        SPRINT0(2, "        -> Node velocity gotten from BOOLEAN or GROWN");

        velo1[0] = velo1[1] = velo1[2] = 0;
        tang1[0] = tang1[1] = tang1[2] = 0;

        /* find two non-parallel Edges */
        j = 0;
        for (iedge = 1; iedge <= MODL->body[jbody].nedge; iedge++) {
            if (MODL->body[jbody].edge[iedge].ibeg == jnode ||
                MODL->body[jbody].edge[iedge].iend == jnode   ) {
                if (MODL->body[jbody].edge[iedge].itype == DEGENERATE) continue;

                status = EG_getTopology(MODL->body[jbody].edge[iedge].eedge,
                                        &eref, &oclass, &mtype,
                                        trange, &nchild, &echilds, &senses);
                CHECK_STATUS(EG_getTopology);

//$$$                if (mtype == DEGENERATE) continue;

                if (MODL->body[jbody].edge[iedge].ibeg == jnode) {
                    t = trange[0];
                } else {
                    t = trange[1];
                }

                /* velocity normal to Edge */
                status = velocityOfEdge(MODL, jbody, iedge, 1, &t, velo);
                CHECK_STATUS(velocityOfEdge);

                /* normalize tangent such that largest element is one */
                status = EG_evaluate(MODL->body[jbody].edge[iedge].eedge, &t, data);
                CHECK_STATUS(EG_evaluate);

                /* if the slope we get is zero (which may happen at a C0 junction
                   in a blend), step a little away from the actual Node */
                if (fabs(data[3]) < EPS12 && fabs(data[4]) < EPS12 && fabs(data[5]) < EPS12) {
                    if (MODL->body[jbody].edge[iedge].ibeg == inode) {
                        t = 0.999 * trange[0] + 0.001 * trange[1];
                    } else {
                        t = 0.001 * trange[0] + 0.999 * trange[1];
                    }

                    status = EG_evaluate(MODL->body[jbody].edge[iedge].eedge, &t, data);
                    CHECK_STATUS(EG_evaluate);
                }

                if (fabs(data[3]) < EPS12 && fabs(data[4]) < EPS12 && fabs(data[5]) < EPS12) {
                    signalError(MODL, OCSM_INTERNAL_ERROR,
                                "cannot compute velocity of Node %d:%d", jbody, inode);
                    goto cleanup;
                } else if (fabs(data[3]) >= MAX(fabs(data[4]), fabs(data[5]))) {
                    tang[0] = 1;
                    tang[1] = data[4] / data[3];
                    tang[2] = data[5] / data[3];
                } else if (fabs(data[4]) >= fabs(data[5])) {
                    tang[0] = data[3] / data[4];
                    tang[1] = 1;
                    tang[2] = data[5] / data[4];
                } else {
                    tang[0] = data[3] / data[5];
                    tang[1] = data[4] / data[5];
                    tang[2] = 1;
                }

                /* first Edge */
                if        (j == 0) {
                    tang1[0] = tang[0];
                    tang1[1] = tang[1];
                    tang1[2] = tang[2];
                    velo1[0] = velo[0];
                    velo1[1] = velo[1];
                    velo1[2] = velo[2];
                    j++;

                /* second Edge */
                } else if (j == 1) {
                    tang2[0] = tang[0];
                    tang2[1] = tang[1];
                    tang2[2] = tang[2];
                    velo2[0] = velo[0];
                    velo2[1] = velo[1];
                    velo2[2] = velo[2];

                    /* process second Edge if not parallel to first Edge */
                    if (fabs(tang1[0]-tang2[0]) > EPS03 ||
                        fabs(tang1[1]-tang2[1]) > EPS03 ||
                        fabs(tang1[2]-tang2[2]) > EPS03   ) {
                        j++;

                        /* minimize (velo1+x[0]*tang1) - (velo2+x[1]*tang2) */
                        A[0] =   tang1[0]*tang1[0] + tang1[1]*tang1[1] + tang1[2]*tang1[2];
                        A[1] = - tang1[0]*tang2[0] - tang1[1]*tang2[1] - tang1[2]*tang2[2];
                        A[2] = - tang2[0]*tang1[0] - tang2[1]*tang1[1] - tang2[2]*tang1[2];
                        A[3] =   tang2[0]*tang2[0] + tang2[1]*tang2[1] + tang2[2]*tang2[2];

                        b[0] = (velo2[0]-velo1[0]) * tang1[0]
                             + (velo2[1]-velo1[1]) * tang1[1]
                             + (velo2[2]-velo1[2]) * tang1[2];
                        b[1] = (velo1[0]-velo2[0]) * tang2[0]
                             + (velo1[1]-velo2[1]) * tang2[1]
                             + (velo1[2]-velo2[2]) * tang2[2];

                        status = matsol(A, b, 2, x);
                        CHECK_STATUS(matsol);

                        /* reconstruct velocity by velo+x[0]*tang1 */
                        dxyz[0] = velo1[0] + x[0] * tang1[0];
                        dxyz[1] = velo1[1] + x[0] * tang1[1];
                        dxyz[2] = velo1[2] + x[0] * tang1[2];
                        break;
                    }
                }
            }
        }

        /* getting here means that we did not find two non-parallel Edges,
           so just return the (local) Edge velocity */
        if (j < 2) {
            SPRINT0(2, "WARNING:: could not find two non-parallel Edges");
            (MODL->nwarn)++;

            dxyz[0] = velo1[0];
            dxyz[1] = velo1[1];
            dxyz[2] = velo1[2];
        }

#ifdef ANALYTIC_SKETCH
//$$$    /* get the velocities for a sketch */
//$$$    } else if (MODL->body[jbody].brtype == OCSM_SKEND) {
//$$$        SPRINT0(2, "        -> analytical for SKEND");
//$$$
//$$$        dxyz[0] = 0;
//$$$        dxyz[1] = 0;
//$$$        dxyz[2] = 0;
#endif

    /* unknown primitive type, so get velocities by finite differences */
    } else {
        SPRINT1(2, "        -> using finiteDifference (brtype=%s)",
                ocsmGetText(MODL->body[jbody].brtype));

        if (MODL->perturb == NULL) {
            MODL->dtime = DTIME_NOM;

            status = createPerturbation(MODL);
            CHECK_STATUS(createPerturbation);
        }

        status = finiteDifference(MODL, ibody, OCSM_NODE, inode, 1, NULL, dxyz);
        CHECK_STATUS(finiteDifference);
        goto cleanup;
    }

    /* modify the velocities based upon the Node's history */
    status = EG_attributeRet(MODL->body[ibody].node[inode].enode, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    for (j = 0; j < attrLen; j+=2) {
        if (MODL->body[tempIlist[j]].brtype != OCSM_EXTRUDE) {
            status = xformVelocity(MODL, tempIlist[j], 1, xyz, dxyz);
            CHECK_STATUS(xformVelocity);
        }
    }

cleanup:
#if PRINT_CALLHISTORY > 0
    indent_callHistory--;
#endif

    SPRINT5(2, " <- velocityOfNode(ibody=%3d, inode=%3d) -> %12.6f %12.6f %12.6f",
            ibody, inode, dxyz[0], dxyz[1], dxyz[2]);

    FREE(uvs);

    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   wendland - wendland C2 basis function                              *
 *                                                                      *
 ************************************************************************
 */

static double
wendland(CDOUBLE    uv1[],              /* (in)  location of first  point */
         CDOUBLE    uv2[],              /* (in)  location of second point */
         double     srad2)              /* (in)  support radius sqraured */
{
    double  phi;                        /* (out) value to C2-Wendland */

    double  r2bar, rbar, pow1;

    /* ---------------------------------------------------------- */

    r2bar = ((uv1[0] - uv2[0]) * (uv1[0] - uv2[0])
           + (uv1[1] - uv2[1]) * (uv1[1] - uv2[1])) / srad2;

    if (fabs(r2bar) > 1) {
        phi = 0;
    } else {
        rbar = sqrt(r2bar);
        pow1 = pow(1-rbar, 4);
        phi  = pow1 * (4 * rbar + 1);
    }

//cleanup:
    return phi;
}


/*
 ************************************************************************
 *                                                                      *
 *   writeAsciiStl - write ASCII .stl file                              *
 *                                                                      *
 ************************************************************************
 */

static int
writeAsciiStl(modl_T *MODL,             /* (in)  pointer to MODL */
              int    nstack,            /* (in)  number of Bodys on stack */
              int    *stack,            /* (in)  array  of Bodys on stack */
              char   filename[])        /* (in)  name of output file */
{
    int      status = SUCCESS;          /* (out) return status */

    int      istack, ibody, iface, npnt, ntri, itri;
    CINT     *ptype, *pindx, *tris, *tric;
    double   x0, y0, z0, x1, y1, z1, x2, y2, z2;
    CDOUBLE  *xyz, *uv;
    FILE     *fp;

    ROUTINE(writeAsciiStl);

    /* --------------------------------------------------------------- */

    /* make sure that we have a tessellation */
    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        status = ocsmTessellate(MODL, ibody);
        CHECK_STATUS(ocsmTessellate);
    }

    /* open the output file */
    fp = fopen(filename, "w");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: cannot open \"%s\"", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* create header */
    fprintf(fp, "solid OBJECT\n");

    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        /* write the Triangles */
        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt, &xyz, &uv, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            for (itri = 0; itri < ntri; itri++) {
                x0 = xyz[3*tris[3*itri  ]-3];
                y0 = xyz[3*tris[3*itri  ]-2];
                z0 = xyz[3*tris[3*itri  ]-1];
                x1 = xyz[3*tris[3*itri+1]-3];
                y1 = xyz[3*tris[3*itri+1]-2];
                z1 = xyz[3*tris[3*itri+1]-1];
                x2 = xyz[3*tris[3*itri+2]-3];
                y2 = xyz[3*tris[3*itri+2]-2];
                z2 = xyz[3*tris[3*itri+2]-1];

                fprintf(fp, "  facet normal %14.6e %14.6e %14.6e\n",
                        (y1 - y0) * (z2 - z0) - (y2 - y0) * (z1 - z0),
                        (z1 - z0) * (x2 - x0) - (z2 - z0) * (x1 - x0),
                        (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0));
                fprintf(fp, "    outer loop\n");
                fprintf(fp, "      vertex   %14.6e %14.6e %14.6e\n", x0, y0, z0);
                fprintf(fp, "      vertex   %14.6e %14.6e %14.6e\n", x1, y1, z1);
                fprintf(fp, "      vertex   %14.6e %14.6e %14.6e\n", x2, y2, z2);
                fprintf(fp, "    endloop\n");
                fprintf(fp, "  endfacet\n");
            }
        }
    }

    fprintf(fp, "endsolid OBJECT\n");
    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   writeAsciiUgrid - write ASCII .ugrid file                          *
 *                                                                      *
 ************************************************************************
 */

static int
writeAsciiUgrid(modl_T *MODL,           /* (in)  pointer to MODL */
                int    ibody,           /* (in)  Body index (1:nbody) */
                char   filename[])      /* (in)  name of output file */
{
    int      status = SUCCESS;          /* (out) return status */

    int      inode, iedge, iface, npnt, ntri, ipnt, itri, ip0, ip1, ip2;
    CINT     *ptype, *pindx, *tris, *tric;
    CDOUBLE  *xyz, *uv;
    FILE     *fp;

    ROUTINE(writeAsciiUgrid);

    /* --------------------------------------------------------------- */

    /* make sure that we have a tessellation */
    status = ocsmTessellate(MODL, ibody);
    CHECK_STATUS(ocsmTessellate);

    /* open the output file */
    fp = fopen(filename, "w");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: cannot open \"%s\"", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* create header */
    fprintf(fp, "%8d %8d %8d %8d %8d %8d %8d\n",
            MODL->body[ibody].npnts,
            MODL->body[ibody].ntris,   0, 0, 0, 0, 0);

    /* write the Points (Nodes, then Edges, then Faces) */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        fprintf(fp, "%22.15e %22.15e %22.15e\n",
                MODL->body[ibody].node[inode].x,
                MODL->body[ibody].node[inode].y,
                MODL->body[ibody].node[inode].z);
    }

    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt, &xyz, &uv);
        CHECK_STATUS(EG_getTessEdge);

        for (ipnt = 1; ipnt < npnt-1; ipnt++) {
            fprintf(fp, "%22.15e %22.15e %22.15e\n",
                    xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
        }
    }

    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            if (ptype[ipnt] < 0) {
                fprintf(fp, "%22.15e %22.15e %22.15e\n",
                        xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
            }
        }
    }

    /* write the Triangles */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (itri = 0; itri < ntri; itri++) {
            ip0 = tris[3*itri  ] - 1;
            if        (ptype[ip0] < 0) {       /* interior to Face */
                ip0   = MODL->body[ibody].face[iface].globid + ip0;
            } else if (ptype[ip0] > 0) {       /* interior to Edge */
                iedge = pindx[ip0];
                ip0   = MODL->body[ibody].edge[iedge].globid + ptype[ip0];
            } else {                           /* at Node */
                inode = pindx[ip0];
                ip0   = inode;
            }

            ip1 = tris[3*itri+1] - 1;
            if        (ptype[ip1] < 0) {       /* interior to Face */
                ip1   = MODL->body[ibody].face[iface].globid + ip1;
            } else if (ptype[ip1] > 0) {       /* interior to Edge */
                iedge = pindx[ip1];
                ip1   = MODL->body[ibody].edge[iedge].globid + ptype[ip1];
            } else {                           /* at Node */
                inode = pindx[ip1];
                ip1   = inode;
            }

            ip2 = tris[3*itri+2] - 1;
            if        (ptype[ip2] < 0) {       /* interior to Face */
                ip2   = MODL->body[ibody].face[iface].globid + ip2;
            } else if (ptype[ip2] > 0) {       /* interior to Edge */
                iedge = pindx[ip2];
                ip2   = MODL->body[ibody].edge[iedge].globid + ptype[ip2];
            } else {                           /* at Node */
                inode = pindx[ip2];
                ip2   = inode;
            }

            fprintf(fp, "%8d %8d %8d\n", ip0, ip1, ip2);
        }
    }

    /* write out Face number for each Triangle */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &ptype, &pindx,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (itri = 0; itri < ntri; itri++) {
            fprintf(fp, "%8d\n", iface);
        }
    }

    /* close the file */
    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   writeBinaryStl - binary ASCII .stl file                            *
 *                                                                      *
 ************************************************************************
 */

int
writeBinaryStl(modl_T *MODL,            /* (in)  pointer to MODL */
               int    nstack,           /* (in)  number of Bodys on stack */
               int    *stack,           /* (in)  array  of Bodys on stack */
               char   filename[])       /* (in)  name of output file */
{
    int    status = SUCCESS;            /* (out) return status */

#define UINT16 unsigned short int
#define UINT32 unsigned int
#define REAL32 float

    int     istack, ibody, iface, npnt, ntri, itri, attrType, attrLen;
    CINT    *ptype, *pindx, *tris, *tric, *tempIlist;
    CDOUBLE *xyz, *uv, *tempRlist;
    CCHAR   *tempClist;

    UINT16 icolr;
    UINT32 ntris;
    REAL32 vert0[3], vert1[3], vert2[3], norm[3];
    char   header[]  = "written by OpenCSM                                                             ";
    FILE   *fp = NULL;

    ROUTINE(writeBinaryStl);

    /* --------------------------------------------------------------- */

    /* make sure that we have a tessellation */
    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        status = ocsmTessellate(MODL, ibody);
        CHECK_STATUS(ocsmTessellate);
    }

    /* open the output file */
    fp = fopen(filename, "wb");
    if (fp == NULL) {
        SPRINT1(0, "ERROR:: cannot open \"%s\"", filename);
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* create header */
    (void) fwrite(header, sizeof(char), 80, fp);

    /* count and write the number of Triangles */
    ntris = 0;
    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt, &xyz, &uv, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            ntris += ntri;
        }
    }
    (void) fwrite(&ntris, sizeof(UINT32), 1, fp);

    /* process each of the Faces in each Body on the stack */
    for (istack = 0; istack < nstack; istack++) {
        ibody = stack[istack];
        if (ibody <= 0) continue;

        for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
            status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                    &npnt, &xyz, &uv, &ptype, &pindx,
                                    &ntri, &tris, &tric);
            CHECK_STATUS(EG_getTessFace);

            /* the default color is 0 */
            icolr = 0;

            /* if Body has _stlColor attribute, use it */
            status = EG_attributeRet(MODL->body[ibody].ebody, "_stlColor",
                                     &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS) {
                if (attrType == ATTRREAL && attrLen == 1) {
                    icolr = NINT(tempRlist[0]);
                }
            }

            /* if Face has _stlColor attribute, use it */
            status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "_stlColor",
                                     &attrType, &attrLen, &tempIlist, &tempRlist, &tempClist);
            if (status == SUCCESS) {
                if (attrType == ATTRREAL && attrLen == 1) {
                    icolr = NINT(tempRlist[0]);
                }
            }

            /* reset status in case we got an error above */
            status = SUCCESS;

            /* write the triangles */
            for (itri = 0; itri < ntri; itri++) {
                vert0[0] = xyz[3*tris[3*itri  ]-3];
                vert0[1] = xyz[3*tris[3*itri  ]-2];
                vert0[2] = xyz[3*tris[3*itri  ]-1];
                vert1[0] = xyz[3*tris[3*itri+1]-3];
                vert1[1] = xyz[3*tris[3*itri+1]-2];
                vert1[2] = xyz[3*tris[3*itri+1]-1];
                vert2[0] = xyz[3*tris[3*itri+2]-3];
                vert2[1] = xyz[3*tris[3*itri+2]-2];
                vert2[2] = xyz[3*tris[3*itri+2]-1];

                norm[0] = (vert1[1] - vert0[1]) * (vert2[2] - vert0[2])
                        - (vert2[1] - vert0[1]) * (vert1[2] - vert0[2]);
                norm[1] = (vert1[2] - vert0[2]) * (vert2[0] - vert0[0])
                        - (vert2[2] - vert0[2]) * (vert1[0] - vert0[0]);
                norm[2] = (vert1[0] - vert0[0]) * (vert2[1] - vert0[1])
                        - (vert2[0] - vert0[0]) * (vert1[1] - vert0[1]);

                (void) fwrite(norm,   sizeof(REAL32), 3, fp);
                (void) fwrite(vert0,  sizeof(REAL32), 3, fp);
                (void) fwrite(vert1,  sizeof(REAL32), 3, fp);
                (void) fwrite(vert2,  sizeof(REAL32), 3, fp);
                (void) fwrite(&icolr, sizeof(UINT16), 1, fp);
            }
        }
    }

    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   writePlotFile - write ASCII .plot file                             *
 *                                                                      *
 ************************************************************************
 */

static int
writePlotFile(modl_T *MODL,             /* (in)  pointer to MODL */
              int    ibody,             /* (in)  Body index (1:nbody) */
              char   filename[])        /* (in)  filename */
{
    int    status = SUCCESS;            /* (out) return status */

    int     inode, iedge, iface, count, npnt, ipnt, ntri;
    CINT    *ptype, *pindx, *tris, *tric;
    CDOUBLE *xyz, *uv;
    FILE    *fp;

    ROUTINE(writePlotFile);

    /* --------------------------------------------------------------- */

    /* count unique points */
    count = MODL->body[ibody].nnode;

    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt, &xyz, &uv);
        CHECK_STATUS(EG_getTessEdge);

        count += (npnt - 2);
    }

    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &pindx, &ptype,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            if (ptype[ipnt] == -1) count++;
        }
    }

    /* open the file */
    fp = fopen(filename, "w");
    if (fp == NULL) {
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    fprintf(fp, "%8d %8d %s\n", count, 0, filename);

    /* add Nodes to the file */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        fprintf(fp, "%22.15e %22.15e %22.15e\n",
                MODL->body[ibody].node[inode].x,
                MODL->body[ibody].node[inode].y,
                MODL->body[ibody].node[inode].z);
    }

    /* add interior Edge points to the file */
    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt, &xyz, &uv);
        CHECK_STATUS(EG_getTessEdge);

        for (ipnt = 1; ipnt < npnt-1; ipnt++) {
            fprintf(fp, "%22.15e %22.15e %22.15e\n",
                    xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
        }
    }

    /* add interior Face points to the file */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &pindx, &ptype,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            if (ptype[ipnt] == -1) {
                fprintf(fp, "%22.15e %22.15e %22.15e\n",
                        xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2]);
            }
        }
    }

    /* finalize the file */
    fprintf(fp, "%8d %8d %s\n", 0, 0, "end");
    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   writeSensFile - write ASCII .sens file                             *
 *                                                                      *
 ************************************************************************
 */

static int
writeSensFile(modl_T *MODL,             /* (in)  pointer to MODL */
              int    ibody,             /* (in)  Body index (1:nbody) */
              char   filename[])        /* (in)  filename */
{
    int    status = SUCCESS;            /* (out) return status */

    int     count, ipmtr, i, inode, iedge, iface, npnt, ipnt, ntri, itri;
    CINT    *pindx, *ptype, *tris, *tric;
    double  *vels=NULL;
    CDOUBLE *xyz, *uv, *Vels;
    FILE    *fp;

    ROUTINE(writeSensFile);

    /* --------------------------------------------------------------- */

    /* count the number od DESPMTRs */
    count = 0;
    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR) {
            count++;
        }
    }

    /* open the file */
    fp = fopen(filename, "w");
    if (fp == NULL) {
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    /* write the DESPMTRs in the header of the file */
    fprintf(fp, "%8d\n", count);

    for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {
        if (MODL->pmtr[ipmtr].type == OCSM_DESPMTR) {
            fprintf(fp, "%8d %s\n",
                    MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol,
                    MODL->pmtr[ipmtr].name);

            for (i = 0; i < MODL->pmtr[ipmtr].nrow*MODL->pmtr[ipmtr].ncol; i++) {
                fprintf(fp, "     %22.15e %22.15e\n",
                        MODL->pmtr[ipmtr].value[i], MODL->pmtr[ipmtr].dot[i]);
            }
        }
    }

    fprintf(fp, "%8d %8d %8d\n",
            MODL->body[ibody].nnode,
            MODL->body[ibody].nedge,
            MODL->body[ibody].nface);

    /* write Nodes to the files */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        MALLOC(vels, double, 3);

        status = ocsmGetVel(MODL, ibody, OCSM_NODE, inode, 1, NULL, vels);
        CHECK_STATUS(ocsmGetVel);

        fprintf(fp, "%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e\n",
                MODL->body[ibody].node[inode].x,
                MODL->body[ibody].node[inode].y,
                MODL->body[ibody].node[inode].z,
                vels[0], vels[1], vels[2]);

        FREE(vels);
    }

    /* write Edges to the file */
    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt, &xyz, &uv);
        CHECK_STATUS(EG_getTessEdge);

        status = ocsmGetTessVel(MODL, ibody, OCSM_EDGE, iedge, &Vels);
        CHECK_STATUS(ocsmGetTessVel);

        fprintf(fp, "%8d\n", npnt);
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            fprintf(fp, "%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e\n",
                    xyz[ 3*ipnt], xyz[ 3*ipnt+1], xyz[ 3*ipnt+2],
                    Vels[3*ipnt], Vels[3*ipnt+1], Vels[3*ipnt+2],
                    uv[    ipnt]);
        }
    }

    /* write Faces to the file */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &pindx, &ptype,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        status = ocsmGetTessVel(MODL, ibody, OCSM_FACE, iface, &Vels);
        CHECK_STATUS(ocsmGetTessVel);

        fprintf(fp, "%8d %8d\n", npnt, ntri);
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            fprintf(fp, "%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %8d %8d\n",
                    xyz[ 3*ipnt], xyz[ 3*ipnt+1], xyz[ 3*ipnt+2],
                    Vels[3*ipnt], Vels[3*ipnt+1], Vels[3*ipnt+2],
                    uv[  2*ipnt], uv[  2*ipnt+1],
                    ptype[ ipnt], pindx[ ipnt  ]);
        }
        for (itri = 0; itri < ntri; itri++) {
            fprintf(fp, "%8d %8d %8d %8d %8d %8d\n",
                    tris[3*itri], tris[3*itri+1], tris[3*itri+2],
                    tric[3*itri], tric[3*itri+1], tric[3*itri+2]);
        }
    }

    /* finalize the file */
    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   writeTessFile - write ASCII .tess file                             *
 *                                                                      *
 ************************************************************************
 */

static int
writeTessFile(modl_T *MODL,             /* (in)  pointer to MODL */
              int    ibody,             /* (in)  Body index (1:nbody) */
              char   filename[])        /* (in)  filename */
{
    int    status = SUCCESS;            /* (out) return status */

    int     inode, iedge, iface, npnt, ipnt, ntri, itri;
    CINT    *ptype, *pindx, *tris, *tric;
    CDOUBLE *xyz, *uv;
    FILE    *fp;

    ROUTINE(writeTessFile);

    /* --------------------------------------------------------------- */

    /* open the file */
    fp = fopen(filename, "w");
    if (fp == NULL) {
        status = OCSM_FILE_NOT_FOUND;
        goto cleanup;
    }

    fprintf(fp, "%8d %8d %8d\n",
            MODL->body[ibody].nnode,
            MODL->body[ibody].nedge,
            MODL->body[ibody].nface);

    /* write the Nodes to the file */
    for (inode = 1; inode <= MODL->body[ibody].nnode; inode++) {
        fprintf(fp, "%22.15e %22.15e %22.15e\n",
                MODL->body[ibody].node[inode].x,
                MODL->body[ibody].node[inode].y,
                MODL->body[ibody].node[inode].z);
    }

    /* write the Edges to the file */
    for (iedge = 1; iedge <= MODL->body[ibody].nedge; iedge++) {
        status = EG_getTessEdge(MODL->body[ibody].etess, iedge,
                                &npnt, &xyz, &uv);
        CHECK_STATUS(EG_getTessEdge);

        fprintf(fp, "%8d\n", npnt);
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            fprintf(fp, "%22.15e %22.15e %22.15e %22.15e\n",
                    xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2], uv[ipnt]);
        }
    }

    /* write the Faces to the file */
    for (iface = 1; iface <= MODL->body[ibody].nface; iface++) {
        status = EG_getTessFace(MODL->body[ibody].etess, iface,
                                &npnt, &xyz, &uv, &pindx, &ptype,
                                &ntri, &tris, &tric);
        CHECK_STATUS(EG_getTessFace);

        fprintf(fp, "%8d %8d\n", npnt, ntri);
        for (ipnt = 0; ipnt < npnt; ipnt++) {
            fprintf(fp, "%22.15e %22.15e %22.15e %22.15e %22.15e %8d %8d\n",
                    xyz[3*ipnt], xyz[3*ipnt+1], xyz[3*ipnt+2],
                    uv[ 2*ipnt], uv[ 2*ipnt+1], ptype[ipnt], pindx[ipnt]);
        }
        for (itri = 0; itri < ntri; itri++) {
            fprintf(fp, "%8d %8d %8d %8d %8d %8d\n",
                    tris[3*itri], tris[3*itri+1], tris[3*itri+2],
                    tric[3*itri], tric[3*itri+1], tric[3*itri+2]);
        }
    }

    /* finalize the file */
    fclose(fp);

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   xformEdgeToOriginal - collect transformation for Edge to original  *
 *                                                                      *
 ************************************************************************
 */

static int
xformEdgeToOriginal(modl_T *MODL,       /* (in)  pointer to MODL */
                    int    ibody,       /* (in)  Body index of source (1:nbody) */
                    int    iedge,       /* (in)  Edge index of source (1:nedge) */
                    double mat[],       /* (out) transformation matrix */
                    double *scale)      /* (out) scale factor */
{
    int      status = SUCCESS;          /* (out) return status */

    int      kk, kbody, j;
    int      attrType, attrLen;
    CINT     *tempIlist;
    double   dx, dy, dz, costht, sintht, temp0, temp1, temp2;
    double   xcent, ycent, zcent, fact, nx, ny, nz, dist;

    ROUTINE(xformEdgeToOriginal);

    /* --------------------------------------------------------------- */

    SPRINT2(2, "        xformEdgeToOriginal(ibody=%d, iedge=%d)", ibody, iedge);

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    mat[ 0] = 1;   mat[ 1] = 0;   mat[ 2] = 0;   mat[ 3] = 0;
    mat[ 4] = 0;   mat[ 5] = 1;   mat[ 6] = 0;   mat[ 7] = 0;
    mat[ 8] = 0;   mat[ 9] = 0;   mat[10] = 1;   mat[11] = 0;

    *scale = 1;

    status = EG_attributeRet(MODL->body[ibody].edge[iedge].eedge, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    for (kk = attrLen-2; kk >= 0; kk-=2) {
        kbody = tempIlist[kk];

        /* translate */
        if        (MODL->body[kbody].brtype == OCSM_TRANSLATE) {
            SPRINT1(2, "            -> translate (kbody=%d)", kbody);

            dx = MODL->body[kbody].arg[1].val[0];
            dy = MODL->body[kbody].arg[2].val[0];
            dz = MODL->body[kbody].arg[3].val[0];

            mat[ 3] -= dx;
            mat[ 7] -= dy;
            mat[11] -= dz;

        /* rotatex */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEX) {
            SPRINT1(2, "            -> rotatex   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dy     =     MODL->body[kbody].arg[2].val[0];
            dz     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[4+j] =   temp1 * costht + temp2 * sintht;
                mat[8+j] = - temp1 * sintht + temp2 * costht;
            }

            mat[ 7] += dy - dy * costht - dz * sintht;
            mat[11] += dz + dy * sintht - dz * costht;

        /* rotatey */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEY) {
            SPRINT1(2, "            -> rotatey   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dz     =     MODL->body[kbody].arg[2].val[0];
            dx     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp2 = mat[8+j];
                temp0 = mat[  j];

                mat[8+j] =   temp2 * costht + temp0 * sintht;
                mat[  j] = - temp2 * sintht + temp0 * costht;
            }

            mat[11] += dz - dz * costht - dx * sintht;
            mat[ 3] += dx + dz * sintht - dx * costht;

        /* rotatez */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEZ) {
            SPRINT1(2, "            -> rotatez   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dx     =     MODL->body[kbody].arg[2].val[0];
            dy     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];

                mat[  j] =   temp0 * costht + temp1 * sintht;
                mat[4+j] = - temp0 * sintht + temp1 * costht;
            }

            mat[ 3] += dx - dx * costht - dy * sintht;
            mat[ 7] += dy + dx * sintht - dy * costht;

        /* scale */
        } else if (MODL->body[kbody].brtype == OCSM_SCALE) {
            SPRINT1(2, "            -> scale     (kbody=%d)", kbody);

            fact  = MODL->body[kbody].arg[1].val[0];
            xcent = MODL->body[kbody].arg[2].val[0];
            ycent = MODL->body[kbody].arg[3].val[0];
            zcent = MODL->body[kbody].arg[4].val[0];

            mat[ 0] /= fact;
            mat[ 1] /= fact;
            mat[ 2] /= fact;
            mat[ 3]  = (mat[ 3] - xcent) / fact + xcent;
            mat[ 4] /= fact;
            mat[ 5] /= fact;
            mat[ 6] /= fact;
            mat[ 7]  = (mat[ 7] - ycent) / fact + ycent;
            mat[ 8] /= fact;
            mat[ 9] /= fact;
            mat[10] /= fact;
            mat[11]  = (mat[11] - zcent) / fact + zcent;

            *scale *= fact;

        /* mirror */
        } else if (MODL->body[kbody].brtype == OCSM_MIRROR) {
            SPRINT1(2, "            -> mirror    (kbody=%d)", kbody);

            nx    = MODL->body[kbody].arg[1].val[0];
            ny    = MODL->body[kbody].arg[2].val[0];
            nz    = MODL->body[kbody].arg[3].val[0];
            dist  = MODL->body[kbody].arg[4].val[0];

            fact  = sqrt(nx*nx + ny*ny + nz*nz);
            dx    = nx / fact;
            dy    = ny / fact;
            dz    = nz / fact;

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[  j] = temp0 * (1-2*dx*dx) + temp1 * ( -2*dy*dx) + temp2 * ( -2*dz*dx);
                mat[4+j] = temp0 * ( -2*dx*dy) + temp1 * (1-2*dy*dy) + temp2 * ( -2*dz*dy);
                mat[8+j] = temp0 * ( -2*dx*dz) + temp1 * ( -2*dy*dz) + temp2 * (1-2*dz*dz);
            }

            mat[ 3] += 2 * dist * dx;
            mat[ 7] += 2 * dist * dy;
            mat[11] += 2 * dist * dz;

        /* applycsys */
        } else if (MODL->body[kbody].brtype == OCSM_APPLYCSYS) {
            SPRINT1(2, "            -> applycsys (kbody=%d)", kbody);

        }
    }

    if (*scale != 1) {
        SPRINT1(2, "              *scale = %12.5f", *scale);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   xformFaceToOriginal - collect transformation for Face to original  *
 *                                                                      *
 ************************************************************************
 */

static int
xformFaceToOriginal(modl_T *MODL,       /* (in)  pointer to MODL */
                    int    ibody,       /* (in)  Body index of source (1:nbody) */
                    int    iface,       /* (in)  Face index of source (1:nface) */
                    double mat[],       /* (out) transformation matrix */
                    double *scale)      /* (out) scale factor */
{
    int      status = SUCCESS;          /* (out) return status */

    int      attrType, attrLen, kk, kbody, j;
    CINT     *tempIlist;
    double   dx, dy, dz, costht, sintht, temp0, temp1, temp2;
    double   xcent, ycent, zcent, fact, nx, ny, nz, dist;

    ROUTINE(xformFaceToOriginal);

    /* --------------------------------------------------------------- */

    SPRINT2(2, "        xformFaceToOriginal(ibody=%d, iface=%d)", ibody, iface);

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    mat[ 0] = 1;   mat[ 1] = 0;   mat[ 2] = 0;   mat[ 3] = 0;
    mat[ 4] = 0;   mat[ 5] = 1;   mat[ 6] = 0;   mat[ 7] = 0;
    mat[ 8] = 0;   mat[ 9] = 0;   mat[10] = 1;   mat[11] = 0;

    *scale = 1;

    status = EG_attributeRet(MODL->body[ibody].face[iface].eface, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    /* walk from ibody back to the original */
    for (kk = attrLen-2; kk >= 0; kk-=2) {
        kbody = tempIlist[kk];

        /* translate */
        if        (MODL->body[kbody].brtype == OCSM_TRANSLATE) {
            SPRINT1(2, "            -> translate (kbody=%d)", kbody);

            dx = MODL->body[kbody].arg[1].val[0];
            dy = MODL->body[kbody].arg[2].val[0];
            dz = MODL->body[kbody].arg[3].val[0];

            mat[ 3] -= dx;
            mat[ 7] -= dy;
            mat[11] -= dz;

        /* rotatex */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEX) {
            SPRINT1(2, "            -> rotatex   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dy     =     MODL->body[kbody].arg[2].val[0];
            dz     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[4+j] =   temp1 * costht + temp2 * sintht;
                mat[8+j] = - temp1 * sintht + temp2 * costht;
            }

            mat[ 7] += dy - dy * costht - dz * sintht;
            mat[11] += dz + dy * sintht - dz * costht;

        /* rotatey */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEY) {
            SPRINT1(2, "            -> rotatey   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dz     =     MODL->body[kbody].arg[2].val[0];
            dx     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp2 = mat[8+j];
                temp0 = mat[  j];

                mat[8+j] =   temp2 * costht + temp0 * sintht;
                mat[  j] = - temp2 * sintht + temp0 * costht;
            }

            mat[11] += dz - dz * costht - dx * sintht;
            mat[ 3] += dx + dz * sintht - dx * costht;

        /* rotatez */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEZ) {
            SPRINT1(2, "            -> rotatez   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dx     =     MODL->body[kbody].arg[2].val[0];
            dy     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];

                mat[  j] =   temp0 * costht + temp1 * sintht;
                mat[4+j] = - temp0 * sintht + temp1 * costht;
            }

            mat[ 3] += dx - dx * costht - dy * sintht;
            mat[ 7] += dy + dx * sintht - dy * costht;

        /* scale */
        } else if (MODL->body[kbody].brtype == OCSM_SCALE) {
            SPRINT1(2, "            -> scale     (kbody=%d)", kbody);

            fact  = MODL->body[kbody].arg[1].val[0];
            xcent = MODL->body[kbody].arg[2].val[0];
            ycent = MODL->body[kbody].arg[3].val[0];
            zcent = MODL->body[kbody].arg[4].val[0];

            mat[ 0] /= fact;
            mat[ 1] /= fact;
            mat[ 2] /= fact;
            mat[ 3]  = (mat[ 3] - xcent) / fact + xcent;
            mat[ 4] /= fact;
            mat[ 5] /= fact;
            mat[ 6] /= fact;
            mat[ 7]  = (mat[ 7] - ycent) / fact + ycent;
            mat[ 8] /= fact;
            mat[ 9] /= fact;
            mat[10] /= fact;
            mat[11]  = (mat[11] - zcent) / fact + zcent;

            *scale *= fact;

        /* mirror */
        } else if (MODL->body[kbody].brtype == OCSM_MIRROR) {
            SPRINT1(2, "            -> mirror    (kbody=%d)", kbody);

            nx    = MODL->body[kbody].arg[1].val[0];
            ny    = MODL->body[kbody].arg[2].val[0];
            nz    = MODL->body[kbody].arg[3].val[0];
            dist  = MODL->body[kbody].arg[4].val[0];

            fact  = sqrt(nx*nx + ny*ny + nz*nz);
            dx    = nx / fact;
            dy    = ny / fact;
            dz    = nz / fact;

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[  j] = temp0 * (1-2*dx*dx) + temp1 * ( -2*dy*dx) + temp2 * ( -2*dz*dx);
                mat[4+j] = temp0 * ( -2*dx*dy) + temp1 * (1-2*dy*dy) + temp2 * ( -2*dz*dy);
                mat[8+j] = temp0 * ( -2*dx*dz) + temp1 * ( -2*dy*dz) + temp2 * (1-2*dz*dz);
            }

            mat[ 3] += 2 * dist * dx;
            mat[ 7] += 2 * dist * dy;
            mat[11] += 2 * dist * dz;

        /* applycsys */
        } else if (MODL->body[kbody].brtype == OCSM_APPLYCSYS) {
            SPRINT1(2, "            -> applycsys (kbody=%d)", kbody);

        /* extrude (but only for iford=2) */
        } else if (MODL->body[kbody].brtype == OCSM_EXTRUDE) {
            if (MODL->body[ibody].face[iface].iford == 2) {
                SPRINT1(2, "            -> extrude   (kbody=%d)", kbody);
                dx = MODL->body[kbody].arg[1].val[0];
                dy = MODL->body[kbody].arg[2].val[0];
                dz = MODL->body[kbody].arg[3].val[0];

                mat[ 3] -= dx;
                mat[ 7] -= dy;
                mat[11] -= dz;
            }
        }
    }

    if (*scale != 1) {
        SPRINT1(2, "              *scale = %12.5f", *scale);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   xformNodeToOriginal - collect transformation for Node to original  *
 *                                                                      *
 ************************************************************************
 */

static int
xformNodeToOriginal(modl_T *MODL,       /* (in)  pointer to MODL */
                    int    ibody,       /* (in)  Body index of source (1:nbody) */
                    int    inode,       /* (in)  Node index of source (1:nnode) */
                    double mat[],       /* (out) transformation matrix */
                    double *scale)      /* (out) scale factor */
{
    int      status = SUCCESS;          /* (out) return status */

    int      kk, kbody, j, attrType, attrLen;
    CINT     *tempIlist;
    double   dx, dy, dz, costht, sintht, temp0, temp1, temp2;
    double   xcent, ycent, zcent, fact, nx, ny, nz, dist;

    ROUTINE(xformNodeToOriginal);

    /* --------------------------------------------------------------- */

    SPRINT2(2, "        xformNodeToOriginal(ibody=%d, inode=%d)", ibody, inode);

    /* find the transformation matrix which is required
       to track a point from its location in ibody back to
       its corresponding location in jbody */
    mat[ 0] = 1;   mat[ 1] = 0;   mat[ 2] = 0;   mat[ 3] = 0;
    mat[ 4] = 0;   mat[ 5] = 1;   mat[ 6] = 0;   mat[ 7] = 0;
    mat[ 8] = 0;   mat[ 9] = 0;   mat[10] = 1;   mat[11] = 0;

    *scale = 1;

    status = EG_attributeRet(MODL->body[ibody].node[inode].enode, "__trace__",
                             &attrType, &attrLen, &tempIlist, NULL, NULL);
    CHECK_STATUS(EG_attributeRet);

    /* walk from ibody back to the original */
    for (kk = attrLen-2; kk >= 0; kk-=2) {
        kbody = tempIlist[kk];

        /* translate */
        if        (MODL->body[kbody].brtype == OCSM_TRANSLATE) {
            SPRINT1(2, "            -> translate (kbody=%d)", kbody);

            dx = MODL->body[kbody].arg[1].val[0];
            dy = MODL->body[kbody].arg[2].val[0];
            dz = MODL->body[kbody].arg[3].val[0];

            mat[ 3] -= dx;
            mat[ 7] -= dy;
            mat[11] -= dz;

        /* rotatex */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEX) {
            SPRINT1(2, "            -> rotatex   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dy     =     MODL->body[kbody].arg[2].val[0];
            dz     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[4+j] =   temp1 * costht + temp2 * sintht;
                mat[8+j] = - temp1 * sintht + temp2 * costht;
            }

            mat[ 7] += dy - dy * costht - dz * sintht;
            mat[11] += dz + dy * sintht - dz * costht;

        /* rotatey */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEY) {
            SPRINT1(2, "            -> rotatey   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dz     =     MODL->body[kbody].arg[2].val[0];
            dx     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp2 = mat[8+j];
                temp0 = mat[  j];

                mat[8+j] =   temp2 * costht + temp0 * sintht;
                mat[  j] = - temp2 * sintht + temp0 * costht;
            }

            mat[11] += dz - dz * costht - dx * sintht;
            mat[ 3] += dx + dz * sintht - dx * costht;

        /* rotatez */
        } else if (MODL->body[kbody].brtype == OCSM_ROTATEZ) {
            SPRINT1(2, "            -> rotatez   (kbody=%d)", kbody);

            costht = cos(MODL->body[kbody].arg[1].val[0] * PIo180);
            sintht = sin(MODL->body[kbody].arg[1].val[0] * PIo180);
            dx     =     MODL->body[kbody].arg[2].val[0];
            dy     =     MODL->body[kbody].arg[3].val[0];

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];

                mat[  j] =   temp0 * costht + temp1 * sintht;
                mat[4+j] = - temp0 * sintht + temp1 * costht;
            }

            mat[ 3] += dx - dx * costht - dy * sintht;
            mat[ 7] += dy + dx * sintht - dy * costht;

        /* scale */
        } else if (MODL->body[kbody].brtype == OCSM_SCALE) {
            SPRINT1(2, "            -> scale     (kbody=%d)", kbody);

            fact  = MODL->body[kbody].arg[1].val[0];
            xcent = MODL->body[kbody].arg[2].val[0];
            ycent = MODL->body[kbody].arg[3].val[0];
            zcent = MODL->body[kbody].arg[4].val[0];

            mat[ 0] /= fact;
            mat[ 1] /= fact;
            mat[ 2] /= fact;
            mat[ 3]  = (mat[ 3] - xcent) / fact + xcent;
            mat[ 4] /= fact;
            mat[ 5] /= fact;
            mat[ 6] /= fact;
            mat[ 7]  = (mat[ 7] - ycent) / fact + ycent;
            mat[ 8] /= fact;
            mat[ 9] /= fact;
            mat[10] /= fact;
            mat[11]  = (mat[11] - zcent) / fact + zcent;

            *scale *= fact;

        /* mirror */
        } else if (MODL->body[kbody].brtype == OCSM_MIRROR) {
            SPRINT1(2, "            -> mirror    (kbody=%d)", kbody);

            nx    = MODL->body[kbody].arg[1].val[0];
            ny    = MODL->body[kbody].arg[2].val[0];
            nz    = MODL->body[kbody].arg[3].val[0];
            dist  = MODL->body[kbody].arg[4].val[0];

            fact  = sqrt(nx*nx + ny*ny + nz*nz);
            dx    = nx / fact;
            dy    = ny / fact;
            dz    = nz / fact;

            for (j = 0; j < 4; j++) {
                temp0 = mat[  j];
                temp1 = mat[4+j];
                temp2 = mat[8+j];

                mat[  j] = temp0 * (1-2*dx*dx) + temp1 * ( -2*dy*dx) + temp2 * ( -2*dz*dx);
                mat[4+j] = temp0 * ( -2*dx*dy) + temp1 * (1-2*dy*dy) + temp2 * ( -2*dz*dy);
                mat[8+j] = temp0 * ( -2*dx*dz) + temp1 * ( -2*dy*dz) + temp2 * (1-2*dz*dz);
            }

            mat[ 3] += 2 * dist * dx;
            mat[ 7] += 2 * dist * dy;
            mat[11] += 2 * dist * dz;

        /* applycsys */
        } else if (MODL->body[kbody].brtype == OCSM_APPLYCSYS) {
            SPRINT1(2, "            -> applycsys (kbody=%d)", kbody);

        }
    }

    if (*scale != 1) {
        SPRINT1(2, "              *scale = %12.5f", *scale);
    }

cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   xformVelocity - transform velocity and xyz by following tree       *
 *                                                                      *
 ************************************************************************
 */

static int
xformVelocity(modl_T *MODL,             /* (in)  pointer to MODL */
              int    jbody,             /* (in)  Body index (1:nbody) */
              int    npnt,              /* (in)  number of points */
              double xyz[],             /* (both)coordinates to be transformed */
              double dxyz[])            /* (both)velocities  to be transformed */
{
    int       status = SUCCESS;         /* (out) return status */

    int       ipnt;
    double    dx, dy, dz, sintht, costht, fact, nx, ny, nz, dist;
    double    xold, xolddot, yold, yolddot, zold, zolddot, thtdot;
    double    xbase, ybase, zbase;
    double    dxdot, dydot, dzdot, factdot, nxdot, nydot, nzdot, distdot;
    double    xcent, ycent, zcent, xcentdot, ycentdot, zcentdot;

    ROUTINE(xformVelocity);

    /* --------------------------------------------------------------- */

    SPRINT2(2, "        xformVelocity(jbody=%d, npnt=%d)", jbody, npnt);

    /* translate */
    if (MODL->body[jbody].brtype == OCSM_TRANSLATE) {
        SPRINT1(2, "            -> translate (jbody=%d)", jbody);

        dx    = MODL->body[jbody].arg[1].val[0];
        dy    = MODL->body[jbody].arg[2].val[0];
        dz    = MODL->body[jbody].arg[3].val[0];

        dxdot = MODL->body[jbody].arg[1].dot[0];
        dydot = MODL->body[jbody].arg[2].dot[0];
        dzdot = MODL->body[jbody].arg[3].dot[0];

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] += dxdot;
            dxyz[3*ipnt+1] += dydot;
            dxyz[3*ipnt+2] += dzdot;
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xyz[3*ipnt  ] += dx;
            xyz[3*ipnt+1] += dy;
            xyz[3*ipnt+2] += dz;
        }

    /* rotatex */
    } else if (MODL->body[jbody].brtype == OCSM_ROTATEX) {
        SPRINT1(2, "            -> rotatex   (jbody=%d)", jbody);

        sintht = sin(MODL->body[jbody].arg[1].val[0] * PIo180);
        costht = cos(MODL->body[jbody].arg[1].val[0] * PIo180);
        thtdot =     MODL->body[jbody].arg[1].dot[0] * PIo180;

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            yold    = xyz[3*ipnt+1];
            zold    = xyz[3*ipnt+2];

            yolddot = dxyz[3*ipnt+1];
            zolddot = dxyz[3*ipnt+2];

            dxyz[3*ipnt+1] = MODL->body[jbody].arg[2].dot[0]
                + (yolddot - MODL->body[jbody].arg[2].dot[0]) * costht
                - (yold    - MODL->body[jbody].arg[2].val[0]) * sintht * thtdot
                - (zolddot - MODL->body[jbody].arg[3].dot[0]) * sintht
                - (zold    - MODL->body[jbody].arg[3].val[0]) * costht * thtdot;
            dxyz[3*ipnt+2] = MODL->body[jbody].arg[3].dot[0]
                + (yolddot - MODL->body[jbody].arg[2].dot[0]) * sintht
                + (yold    - MODL->body[jbody].arg[2].val[0]) * costht * thtdot
                + (zolddot - MODL->body[jbody].arg[3].dot[0]) * costht
                - (zold    - MODL->body[jbody].arg[3].val[0]) * sintht * thtdot;
        }

        ybase = MODL->body[jbody].arg[2].val[0];
        zbase = MODL->body[jbody].arg[3].val[0];

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            yold = xyz[3*ipnt+1];
            zold = xyz[3*ipnt+2];

            xyz[3*ipnt+1] = ybase + (yold-ybase) * costht - (zold-zbase) * sintht;
            xyz[3*ipnt+2] = zbase + (yold-ybase) * sintht + (zold-zbase) * costht;
        }

    /* rotatey */
    } else if (MODL->body[jbody].brtype == OCSM_ROTATEY) {
        SPRINT1(2, "            -> rotatey   (jbody=%d)", jbody);

        sintht = sin(MODL->body[jbody].arg[1].val[0] * PIo180);
        costht = cos(MODL->body[jbody].arg[1].val[0] * PIo180);
        thtdot =     MODL->body[jbody].arg[1].dot[0] * PIo180;

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xold    = xyz[3*ipnt  ];
            zold    = xyz[3*ipnt+2];

            xolddot = dxyz[3*ipnt  ];
            zolddot = dxyz[3*ipnt+2];

            dxyz[3*ipnt+2] = MODL->body[jbody].arg[2].dot[0]
                + (zolddot - MODL->body[jbody].arg[2].dot[0]) * costht
                - (zold    - MODL->body[jbody].arg[2].val[0]) * sintht * thtdot
                - (xolddot - MODL->body[jbody].arg[3].dot[0]) * sintht
                - (xold    - MODL->body[jbody].arg[3].val[0]) * costht * thtdot;
            dxyz[3*ipnt  ] = MODL->body[jbody].arg[3].dot[0]
                + (zolddot - MODL->body[jbody].arg[2].dot[0]) * sintht
                + (zold    - MODL->body[jbody].arg[2].val[0]) * costht * thtdot
                + (xolddot - MODL->body[jbody].arg[3].dot[0]) * costht
                - (xold    - MODL->body[jbody].arg[3].val[0]) * sintht * thtdot;
        }

        zbase = MODL->body[jbody].arg[2].val[0];
        xbase = MODL->body[jbody].arg[3].val[0];

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            zold = xyz[3*ipnt+2];
            xold = xyz[3*ipnt  ];

            xyz[3*ipnt+2] = zbase + (zold-zbase) * costht - (xold-xbase) * sintht;
            xyz[3*ipnt  ] = xbase + (zold-zbase) * sintht + (xold-xbase) * costht;
        }

    /* rotatez */
    } else if (MODL->body[jbody].brtype == OCSM_ROTATEZ) {
        SPRINT1(2, "            -> rotatez   (jbody=%d)", jbody);

        sintht = sin(MODL->body[jbody].arg[1].val[0] * PIo180);
        costht = cos(MODL->body[jbody].arg[1].val[0] * PIo180);
        thtdot =     MODL->body[jbody].arg[1].dot[0] * PIo180;

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xold    = xyz[3*ipnt  ];
            yold    = xyz[3*ipnt+1];

            xolddot = dxyz[3*ipnt  ];
            yolddot = dxyz[3*ipnt+1];

            dxyz[3*ipnt  ] = MODL->body[jbody].arg[2].dot[0]
                + (xolddot - MODL->body[jbody].arg[2].dot[0]) * costht
                - (xold    - MODL->body[jbody].arg[2].val[0]) * sintht * thtdot
                - (yolddot - MODL->body[jbody].arg[3].dot[0]) * sintht
                - (yold    - MODL->body[jbody].arg[3].val[0]) * costht * thtdot;
            dxyz[3*ipnt+1] = MODL->body[jbody].arg[3].dot[0]
                + (xolddot - MODL->body[jbody].arg[2].dot[0]) * sintht
                + (xold    - MODL->body[jbody].arg[2].val[0]) * costht * thtdot
                + (yolddot - MODL->body[jbody].arg[3].dot[0]) * costht
                - (yold    - MODL->body[jbody].arg[3].val[0]) * sintht * thtdot;
        }

        xbase = MODL->body[jbody].arg[2].val[0];
        ybase = MODL->body[jbody].arg[3].val[0];

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xold = xyz[3*ipnt  ];
            yold = xyz[3*ipnt+1];

            xyz[3*ipnt  ] = xbase + (xold-xbase) * costht - (yold-ybase) * sintht;
            xyz[3*ipnt+1] = ybase + (xold-xbase) * sintht + (yold-ybase) * costht;
        }

    /* scale */
    } else if (MODL->body[jbody].brtype == OCSM_SCALE) {
        SPRINT1(2, "            -> scale     (jbody=%d)", jbody);

        fact     = MODL->body[jbody].arg[1].val[0];
        xcent    = MODL->body[jbody].arg[2].val[0];
        ycent    = MODL->body[jbody].arg[3].val[0];
        zcent    = MODL->body[jbody].arg[4].val[0];

        factdot  = MODL->body[jbody].arg[1].dot[0];
        xcentdot = MODL->body[jbody].arg[2].dot[0];
        ycentdot = MODL->body[jbody].arg[3].dot[0];
        zcentdot = MODL->body[jbody].arg[4].dot[0];

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xold    = xyz[3*ipnt  ];
            yold    = xyz[3*ipnt+1];
            zold    = xyz[3*ipnt+2];

            xolddot = dxyz[3*ipnt  ];
            yolddot = dxyz[3*ipnt+1];
            zolddot = dxyz[3*ipnt+2];

            dxyz[3*ipnt  ] = factdot * (xold - xcent) + xolddot * fact + xcentdot * (1 - fact);
            dxyz[3*ipnt+1] = factdot * (yold - ycent) + yolddot * fact + ycentdot * (1 - fact);
            dxyz[3*ipnt+2] = factdot * (zold - zcent) + zolddot * fact + zcentdot * (1 - fact);
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xyz[3*ipnt  ] = xyz[3*ipnt  ] * fact + xcent * (1 - fact);
            xyz[3*ipnt+1] = xyz[3*ipnt+1] * fact + ycent * (1 - fact);
            xyz[3*ipnt+2] = xyz[3*ipnt+2] * fact + zcent * (1 - fact);
        }

    /* mirror */
    } else if (MODL->body[jbody].brtype == OCSM_MIRROR) {
        SPRINT1(2, "            -> mirror    (jbody=%d)", jbody);

        nx       = MODL->body[jbody].arg[1].val[0];
        ny       = MODL->body[jbody].arg[2].val[0];
        nz       = MODL->body[jbody].arg[3].val[0];
        dist     = MODL->body[jbody].arg[4].val[0];

        nxdot    = MODL->body[jbody].arg[1].dot[0];
        nydot    = MODL->body[jbody].arg[2].dot[0];
        nzdot    = MODL->body[jbody].arg[3].dot[0];
        distdot  = MODL->body[jbody].arg[4].dot[0];

        fact     = sqrt(nx*nx    + ny*ny    + nz*nz   );
        factdot  =     (nx*nxdot + ny*nydot + nz*nzdot) / fact;

        dx       = nx / fact;
        dy       = ny / fact;
        dz       = nz / fact;

        dxdot    = (fact * nxdot - nx * factdot) / fact / fact;
        dydot    = (fact * nydot - ny * factdot) / fact / fact;
        dzdot    = (fact * nzdot - nz * factdot) / fact / fact;

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xold    = xyz[3*ipnt  ];
            yold    = xyz[3*ipnt+1];
            zold    = xyz[3*ipnt+2];

            xolddot = dxyz[3*ipnt  ];
            yolddot = dxyz[3*ipnt+1];
            zolddot = dxyz[3*ipnt+2];

            dxyz[3*ipnt  ] = xolddot * (1-2*dx*dx) + xold * (-4*dx*dxdot           )
                           + yolddot * ( -2*dx*dy) + yold * (-2*dx*dydot-2*dy*dxdot)
                           + zolddot * ( -2*dx*dz) + zold * (-2*dx*dzdot-2*dz*dxdot)
                           + distdot * (  2*dx   ) + dist * (            2*   dxdot);
            dxyz[3*ipnt+1] = xolddot * ( -2*dy*dx) + xold * (-2*dy*dxdot-2*dx*dydot)
                           + yolddot * (1-2*dy*dy) + yold * (-4*dy*dydot           )
                           + zolddot * ( -2*dy*dz) + zold * (-2*dy*dzdot-2*dz*dydot)
                           + distdot * (  2*dy   ) + dist * (            2*   dydot);
            dxyz[3*ipnt+2] = xolddot * ( -2*dz*dx) + xold * (-2*dz*dxdot-2*dx*dzdot)
                           + yolddot * ( -2*dz*dy) + yold * (-2*dz*dydot-2*dy*dzdot)
                           + zolddot * (1-2*dz*dz) + zold * (-4*dz*dzdot           )
                           + distdot * (  2*dz   ) + dist * (            2*   dzdot);
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xold = xyz[3*ipnt  ];
            yold = xyz[3*ipnt+1];
            zold = xyz[3*ipnt+2];

            xyz[3*ipnt  ] = xold * (1-2*dx*dx) + yold * ( -2*dy*dx) + zold * ( -2*dz*dx) + 2*dist*dx;
            xyz[3*ipnt+1] = xold * ( -2*dx*dy) + yold * (1-2*dy*dy) + zold * ( -2*dz*dy) + 2*dist*dy;
            xyz[3*ipnt+2] = xold * ( -2*dx*dz) + yold * ( -2*dy*dz) + zold * (1-2*dz*dz) + 2*dist*dz;
        }

    /* applycsys */
    } else if (MODL->body[jbody].brtype == OCSM_APPLYCSYS) {
        SPRINT1(2, "            -> applycsys (jbody=%d)", jbody);

    /* extrude (but last Face only) */
    } else if (MODL->body[jbody].brtype == OCSM_EXTRUDE) {
        SPRINT1(2, "            -> extrude (jbody=%d)", jbody);

        dx    = MODL->body[jbody].arg[1].val[0];
        dy    = MODL->body[jbody].arg[2].val[0];
        dz    = MODL->body[jbody].arg[3].val[0];

        dxdot = MODL->body[jbody].arg[1].dot[0];
        dydot = MODL->body[jbody].arg[2].dot[0];
        dzdot = MODL->body[jbody].arg[3].dot[0];

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            dxyz[3*ipnt  ] += dxdot;
            dxyz[3*ipnt+1] += dydot;
            dxyz[3*ipnt+2] += dzdot;
        }

        for (ipnt = 0; ipnt < npnt; ipnt++) {
            xyz[3*ipnt  ] += dx;
            xyz[3*ipnt+1] += dy;
            xyz[3*ipnt+2] += dz;
        }

    }

    SPRINT3(2, "            -> xyz  %12.6f %12.6f %12.6f", xyz[ 0], xyz[ 1], xyz[ 2]);
    SPRINT3(2, "            -> dxyz %12.6f %12.6f %12.6f", dxyz[0], dxyz[1], dxyz[2]);

//cleanup:
    return status;
}


/*
 ************************************************************************
 *                                                                      *
 *   plotFace - level 3 GRAFIC routine for plotting tiled domain        *
 *                                                                      *
 ************************************************************************
 */

#ifdef GRAFIC
static void
plotFace(int    *ifunct,                /* (in)  GRAFIC function indicator */
         void   *modl,                  /* (in)  pointer to tile   structure */
         void   *ibodyP,                /* (in)  Body index (1:nbody) */
         void   *ifaceP,                /* (in)  Face index (1:nface) */
         void   *isymbP,                /* (in)  =1 if symbols to be plotted */
         void   *a4,                    /* (in)  dummy GRAFIC argument */
         void   *a5,                    /* (in)  dummy GRAFIC argument */
         void   *a6,                    /* (in)  dummy GRAFIC argument */
         void   *a7,                    /* (in)  dummy GRAFIC argument */
         void   *a8,                    /* (in)  dummy GRAFIC argument */
         void   *a9,                    /* (in)  dummy GRAFIC argument */
         float  *scale,                 /* (out) array of scales */
         char   *text,                  /* (out) help text */
         int    textlen)                /* (in)  length of text */
{
    modl_T   *MODL   = (modl_T   *) modl;
    int      *ibody  = (int      *) ibodyP;
    int      *iface  = (int      *) ifaceP;
    int      *isymb  = (int      *) isymbP;

    int      status, nloop, iloop, iedge, nedge, ibest;
    int      oclass, mtype, *senses, i, periodic, ipnt, npnt=0;
    double   data[18], uvrange[4], tt, dbest, dtest, ubest, vbest;
    double   umin=0, umax=0, vmin=0, vmax=0;
    CDOUBLE  *xyz, *t;
    float    u4, v4, ucrsgr, vcrsgr;
    char     dum[] = " ";
    ego      *eloops, eref, *eedges;

    int      iblack  = GR_BLACK;
    int      isquare = GR_SQUARE;
    int      iplus   = GR_PLUS;
    int      icircle = GR_CIRCLE;
    int      init    = 1;
    int      izero   = 0;
    int      icolor  = 0;
    int      jcolors[] = {GR_RED, GR_GREEN, GR_BLUE, GR_CYAN, GR_MAGENTA};

    ROUTINE(plotFace);

    /* --------------------------------------------------------------- */

    /* return scales */
    if (*ifunct == 0) {
        status = EG_getRange(MODL->body[*ibody].face[*iface].eface, uvrange, &periodic);
        CHECK_STATUS(EG_getRange);

        scale[0] = uvrange[0];
        scale[1] = uvrange[1];
        scale[2] = uvrange[2];
        scale[3] = uvrange[3];

        snprintf(text, 40, "Exam Near Symb");

    /* plot image */
    } else if (*ifunct == 1) {

        /* get the Loops for this Face */
        status = EG_getBodyTopos(MODL->body[*ibody].ebody, MODL->body[*ibody].face[*iface].eface,
                                 LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);

        /* get the Edges in each Loop */
        if (eloops != NULL) {
            for (iloop = 0; iloop < nloop; iloop++) {
                SPRINT1(1, "Loop %d\n", iloop+1);

                status = EG_getTopology(eloops[iloop], &eref, &oclass, &mtype, data, &nedge, &eedges, &senses);
                CHECK_STATUS(EG_getTopology);

                for (i = 0; i < nedge; i++) {
                    grcolr_(&(jcolors[icolor]));

                    iedge = status = EG_indexBodyTopo(MODL->body[*ibody].ebody, eedges[i]);
                    CHECK_STATUS(EG_indexBodyTopo);
                    SPRINT1(1, "      Edge %d", iedge);

                    status = EG_getTessEdge(MODL->body[*ibody].etess, iedge,
                                            &npnt, &xyz, &t);
                    CHECK_STATUS(EG_getTessEdge);

                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        status = EG_getEdgeUV(MODL->body[*ibody].face[*iface].eface,
                                              MODL->body[*ibody].edge[ iedge].eedge, 0, t[ipnt], data);
                        CHECK_STATUS(EG_getEdgeUV);

                        u4 = data[0];
                        v4 = data[1];

                        if (ipnt == 0) {
                            grmov2_(&u4, &v4);
                            grsymb_(&isquare);
                        } else if (ipnt == npnt-1) {
                            grdrw2_(&u4, &v4);
                            grsymb_(&isquare);
                        } else {
                            grdrw2_(&u4, &v4);
                            grsymb_(&iplus);
                        }
                    }

                    icolor = (icolor + 1) % 5;   // next color
                    npnt++;                      // discretize each Edge a bit differently
                }
            }

            EG_free(eloops);
        }

        grcolr_(&iblack);

    /* "E"xamine option */
    } else if (*ifunct == -5) {

        ocsmPrintEgo(MODL->body[*ibody].face[*iface].eface);

        /* get the Loops for this Face */
        status = EG_getBodyTopos(MODL->body[*ibody].ebody, MODL->body[*ibody].face[*iface].eface,
                                 LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);

        /* get the Edges in each Loop */
        if (eloops != NULL) {
            for (iloop = 0; iloop < nloop; iloop++) {
                SPRINT1(1, "Loop %5d", iloop+1);
                status = EG_getTopology(eloops[iloop], &eref, &oclass, &mtype, data, &nedge, &eedges, &senses);
                CHECK_STATUS(EG_getTopology);

                for (iedge = 0; iedge < nedge; iedge++) {
                    status = EG_getRange(eedges[nedge+iedge], uvrange, &periodic);
                    CHECK_STATUS(EG_getRange);

                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        tt = uvrange[0] + (uvrange[1] - uvrange[0]) * (double)(ipnt) / (double)(npnt-1);

                        status = EG_evaluate(eedges[nedge+iedge], &tt, data);
                        CHECK_STATUS(EG_evaluate);

                        if (ipnt == 0) {
                            umin = data[0];
                            umax = data[0];
                            vmin = data[1];
                            vmax = data[1];
                        } else {
                            if (data[0] < umin) umin = data[0];
                            if (data[0] > umax) umax = data[0];
                            if (data[1] < vmin) vmin = data[1];
                            if (data[1] > vmax) vmax = data[1];
                        }
                    }

                    SPRINT5(1, "Edge %5d: umin=%12.4f, umax=%12.4f, vmin=%12.4f, vmax=%12.4f",
                            EG_indexBodyTopo(MODL->body[*ibody].ebody, eedges[iedge]),
                            umin, umax, vmin, vmax);
                }
            }

            EG_free(eloops);
        }

    /* "N"earest option */
    } else if (*ifunct == -14) {
        grvalu_("XCRSGR", &izero, &ucrsgr, dum, STRLEN("XCRSGR"), STRLEN(dum));
        grvalu_("YCRSGR", &izero, &vcrsgr, dum, STRLEN("YCRSGR"), STRLEN(dum));
        SPRINT2(1, "ucrsgr=%f, vcrsgr=%f", ucrsgr, vcrsgr);

        ubest = HUGEQ;
        vbest = HUGEQ;
        dbest = HUGEQ;
        ibest = -1;

        /* get the Loops for this Face */
        status = EG_getBodyTopos(MODL->body[*ibody].ebody, MODL->body[*ibody].face[*iface].eface,
                                 LOOP, &nloop, &eloops);
        CHECK_STATUS(EG_getBodyTopos);

        /* get the Edges in each Loop */
        if (eloops != NULL) {
            for (iloop = 0; iloop < nloop; iloop++) {
                status = EG_getTopology(eloops[iloop], &eref, &oclass, &mtype, data, &nedge, &eedges, &senses);
                CHECK_STATUS(EG_getTopology);

                for (iedge = 0; iedge < nedge; iedge++) {
                    status = EG_getRange(eedges[nedge+iedge], uvrange, &periodic);
                    CHECK_STATUS(EG_getRange);

                    for (ipnt = 0; ipnt < npnt; ipnt++) {
                        tt = uvrange[0] + (uvrange[1] - uvrange[0]) * (double)(ipnt) / (double)(npnt-1);

                        status = EG_evaluate(eedges[nedge+iedge], &tt, data);
                        CHECK_STATUS(EG_evaluate);

                        dtest = (ucrsgr - data[0]) * (ucrsgr - data[0])
                            + (vcrsgr - data[1]) * (vcrsgr - data[1]);
                        if (dtest < dbest) {
                            dbest = dtest;
                            ibest = iedge;
                            ubest = data[0];
                            vbest = data[1];
                        }
                    }

                    npnt++;
                }
            }

            EG_free(eloops);
        }

        SPRINT3(1, "ibest=%d, uvbest=%f, %f", ibest, ubest, vbest);

        u4 = ubest;
        v4 = vbest;
        grmov2_(&u4, &v4);
        grsymb_(&icircle);

    /* "S"ymbols option */
    } else if (*ifunct == -19) {
        if (*isymb == 0) {
            *isymb  = 1;
        } else {
            *isymb  = 0;
        }

        isymbP = (void*)(isymb);

        grscpt_(&init, "R", STRLEN("R"));

    } else {
        SPRINT0(0, "Illegal option selected");
    }

cleanup:
    return;
}
#endif // GRAFIC


/*
 ************************************************************************
 *                                                                      *
 *   plotVels - level 3 GRAFIC routine for plotting Face velocities     *
 *                                                                      *
 ************************************************************************
 */

#ifdef GRAFIC
static void
plotVels(int    *ifunct,                /* (in)  GRAFIC function indicator */
         void   *ntriP,                 /* (in)  number of triangles */
         void   *trisP,                 /* (in)  array  of triangles */
         void   *npntP,                 /* (in)  number of points */
         void   *uv_faceP,              /* (in)  array  of points */
         void   *d_faceP,               /* (in)  array of velocities */
         void   *ncontP,                /* (in)  number of contours */
         void   *contP,                 /* (in)  array  of contours */
         void   *igridP,                /* (in)  plot grid? */
         void   *a8,                    /* (in)  dummy GRAFIC argument */
         void   *a9,                    /* (in)  dummy GRAFIC argument */
         float  *scale,                 /* (out) array of scales */
         char   *text,                  /* (out) help text */
         int    textlen)                /* (in)  length of text */
{
    int      *ntri   = (int      *) ntriP;
    int      *tris   = (int      *) trisP;
    int      *npnt   = (int      *) npntP;
    double   *uv_face= (double   *) uv_faceP;
    float    *d_face = (float    *) d_faceP;
    int      *ncont  = (int      *) ncontP;
    float    *cont   = (float    *) contP;
    int      *igrid  = (int      *) igridP;

    int      ipnt, itri, icont, ip0, ip1, ip2, ibest;
    float    x4[3], y4[3], d4[3], ubest, vbest, dbest, Dtest, Dbest;
    float    ucrsgr, vcrsgr;
    double   umin=0, umax=0, vmin=0, vmax=0, dmin, dmax;
    char     dum[] = " ";

    int      iblack  = GR_BLACK;
    int      icircle = GR_CIRCLE;
    int      init    = 1;
    int      izero   = 0;
    int      ithree  = 3;

    ROUTINE(plotVels);

    /* --------------------------------------------------------------- */

    /* return scales */
    if (*ifunct == 0) {
        umin = uv_face[0];
        umax = uv_face[0];
        vmin = uv_face[1];
        vmax = uv_face[1];
        dmin = d_face[ 0];
        dmax = d_face[ 1];

        for (ipnt = 1; ipnt < (*npnt); ipnt++) {
            if (uv_face[2*ipnt  ] < umin) umin = uv_face[2*ipnt  ];
            if (uv_face[2*ipnt  ] > umax) umax = uv_face[2*ipnt  ];
            if (uv_face[2*ipnt+1] < vmin) vmin = uv_face[2*ipnt+1];
            if (uv_face[2*ipnt+1] > vmax) vmax = uv_face[2*ipnt+1];
            if ( d_face[  ipnt  ] < dmin) dmin =  d_face[  ipnt  ];
            if ( d_face[  ipnt  ] > dmax) dmax =  d_face[  ipnt  ];
        }

        scale[0] = umin;
        scale[1] = umax;
        scale[2] = vmin;
        scale[3] = vmax;

        for (icont = 0; icont < (*ncont); icont++) {
            cont[icont] = dmin + (dmax - dmin) * icont / (*ncont - 1);
        }

        snprintf(text, 40, "Examine Grid");

    /* plot image */
    } else if (*ifunct == 1) {

        for (itri = 0; itri < (*ntri); itri++) {
            ip0 = tris[3*itri  ] - 1;
            ip1 = tris[3*itri+1] - 1;
            ip2 = tris[3*itri+2] - 1;

            x4[0] = uv_face[2*ip0  ];
            x4[1] = uv_face[2*ip1  ];
            x4[2] = uv_face[2*ip2  ];

            y4[0] = uv_face[2*ip0+1];
            y4[1] = uv_face[2*ip1+1];
            y4[2] = uv_face[2*ip2+1];

            d4[0] =  d_face[  ip0  ];
            d4[1] =  d_face[  ip1  ];
            d4[2] =  d_face[  ip2  ];

            if (*ncont <= 13) {
                grcol2_(x4, y4, d4, &ithree, cont, ncont);
            } else {
                grmon2_(x4, y4, d4, &ithree, cont, ncont);
            }
        }

        grcolr_(&iblack);

        if (*igrid == 1) {
            for (itri = 0; itri < (*ntri); itri++) {
                ip0 = tris[3*itri  ] - 1;
                ip1 = tris[3*itri+1] - 1;
                ip2 = tris[3*itri+2] - 1;

                x4[0] = uv_face[2*ip0  ];
                x4[1] = uv_face[2*ip1  ];
                x4[2] = uv_face[2*ip2  ];

                y4[0] = uv_face[2*ip0+1];
                y4[1] = uv_face[2*ip1+1];
                y4[2] = uv_face[2*ip2+1];

                grply2_(x4, y4, &ithree);
            }
        }

    /* "E"xamine option */
    } else if (*ifunct == -5) {
        grvalu_("XCRSGR", &izero, &ucrsgr, dum, STRLEN("XCRSGR"), STRLEN(dum));
        grvalu_("YCRSGR", &izero, &vcrsgr, dum, STRLEN("YCRSGR"), STRLEN(dum));

        ibest = -1;
        ubest =  0;
        vbest =  0;
        dbest =  0;
        Dbest =  HUGEQ;

        for (ipnt = 0; ipnt < (*npnt); ipnt++) {
            Dtest = (uv_face[2*ipnt  ] - ucrsgr) * (uv_face[2*ipnt  ] - ucrsgr)
                  + (uv_face[2*ipnt+1] - vcrsgr) * (uv_face[2*ipnt+1] - vcrsgr);
            if (Dtest < Dbest) {
                ibest = ipnt;
                ubest = uv_face[2*ipnt  ];
                vbest = uv_face[2*ipnt+1];
                dbest =  d_face[  ipnt  ];
                Dbest = Dtest;
            }
        }

        SPRINT4(0, "Closest point (%5d) at %10.5f,%10.5f with value %10.5f",
                ibest, ubest, vbest, dbest);

        grmov2_(&ubest, &vbest);
        grsymb_(&icircle);

    /* "G"rid option */
    } else if (*ifunct == -7) {
        if (*igrid == 0) {
            *igrid  = 1;
        } else {
            *igrid  = 0;
        }

        igridP = (void*)(igrid);

        grscpt_(&init, "R", STRLEN("R"));

    } else {
        SPRINT0(0, "Illegal option selected");
    }

//cleanup:
    return;
}
#endif // GRAFIC


/*
 ************************************************************************
 *                                                                      *
 *   printBacktrace - print a backtrace                                 *
 *                                                                      *
 ************************************************************************
 */

#ifdef BACKTRACE
static void
printBacktrace()
{
    void*  callstack[128];
    int    i, frames = backtrace(callstack, 128);
    char** strs = backtrace_symbols(callstack, frames);

    for (i = 0; i < frames; ++i) {
        SPRINT1(0, "%s", strs[i]);
    }

    free(strs);
}
#endif // BACKTRACE
